; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32822.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0M@BNJJKMGF@?$GA?9?$DN?$FL?$FN?2?0?$DL?8?4?1@ ; `string'
PUBLIC	??_C@_0BA@LCLOGKDG@imgui_impl_glfw@		; `string'
PUBLIC	??_C@_0P@JJHDDBGF@IMGUI_VIEWPORT@		; `string'
PUBLIC	??_C@_0N@GFDLLEAC@No?5Title?5Yet@		; `string'
EXTRN	glfwGetMonitorContentScale:PROC
EXTRN	__imp_GetWindowLongW:PROC
EXTRN	glfwSetWindowPos:PROC
EXTRN	__imp_GetMessageExtraInfo:PROC
EXTRN	glfwSetWindowOpacity:PROC
EXTRN	glfwSetCharCallback:PROC
EXTRN	__imp_RemovePropA:PROC
EXTRN	glfwSetErrorCallback:PROC
EXTRN	__imp_CallWindowProcW:PROC
EXTRN	__imp_SetPropA:PROC
EXTRN	glfwSetWindowSize:PROC
EXTRN	glfwSetWindowSizeCallback:PROC
EXTRN	glfwSetWindowFocusCallback:PROC
EXTRN	__imp_SetWindowLongPtrW:PROC
EXTRN	glfwSetCursorPosCallback:PROC
EXTRN	glfwGetKeyName:PROC
EXTRN	glfwGetMonitorPos:PROC
EXTRN	glfwSetWindowTitle:PROC
EXTRN	__imp_GetWindowLongPtrW:PROC
EXTRN	glfwGetGamepadState:PROC
EXTRN	glfwSetWindowPosCallback:PROC
EXTRN	glfwDestroyWindow:PROC
EXTRN	glfwGetWin32Window:PROC
EXTRN	glfwGetWindowPos:PROC
EXTRN	glfwGetMonitorWorkarea:PROC
EXTRN	glfwGetMonitors:PROC
EXTRN	glfwGetError:PROC
EXTRN	glfwSetWindowCloseCallback:PROC
EXTRN	glfwCreateStandardCursor:PROC
EXTRN	glfwShowWindow:PROC
EXTRN	glfwMakeContextCurrent:PROC
EXTRN	glfwWindowHint:PROC
EXTRN	glfwCreateWindow:PROC
EXTRN	glfwSetScrollCallback:PROC
EXTRN	glfwSetKeyCallback:PROC
EXTRN	glfwDestroyCursor:PROC
EXTRN	glfwSetCursor:PROC
EXTRN	__imp_GetPropA:PROC
EXTRN	glfwSetMouseButtonCallback:PROC
EXTRN	glfwSetCursorEnterCallback:PROC
EXTRN	glfwGetWindowSize:PROC
EXTRN	glfwFocusWindow:PROC
EXTRN	glfwSetClipboardString:PROC
EXTRN	glfwGetFramebufferSize:PROC
EXTRN	glfwSetMonitorCallback:PROC
EXTRN	__imp_SetWindowLongW:PROC
EXTRN	glfwGetVideoMode:PROC
EXTRN	glfwCreateWindowSurface:PROC
EXTRN	glfwGetTime:PROC
EXTRN	glfwGetWindowAttrib:PROC
EXTRN	glfwGetInputMode:PROC
EXTRN	glfwSwapInterval:PROC
EXTRN	glfwGetClipboardString:PROC
EXTRN	glfwSwapBuffers:PROC
;	COMDAT ??_C@_0N@GFDLLEAC@No?5Title?5Yet@
CONST	SEGMENT
??_C@_0N@GFDLLEAC@No?5Title?5Yet@ DB 'No Title Yet', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JJHDDBGF@IMGUI_VIEWPORT@
CONST	SEGMENT
??_C@_0P@JJHDDBGF@IMGUI_VIEWPORT@ DB 'IMGUI_VIEWPORT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LCLOGKDG@imgui_impl_glfw@
CONST	SEGMENT
??_C@_0BA@LCLOGKDG@imgui_impl_glfw@ DB 'imgui_impl_glfw', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BNJJKMGF@?$GA?9?$DN?$FL?$FN?2?0?$DL?8?4?1@
CONST	SEGMENT
??_C@_0M@BNJJKMGF@?$GA?9?$DN?$FL?$FN?2?0?$DL?8?4?1@ DB '`-=[]\,;''./', 00H ; `string'
PUBLIC	??_GImGui_ImplGlfw_ViewportData@@QEAAPEAXI@Z	; ImGui_ImplGlfw_ViewportData::`scalar deleting destructor'
PUBLIC	??$IM_DELETE@UImGui_ImplGlfw_ViewportData@@@@YAXPEAUImGui_ImplGlfw_ViewportData@@@Z ; IM_DELETE<ImGui_ImplGlfw_ViewportData>
PUBLIC	??$IM_DELETE@UImGui_ImplGlfw_Data@@@@YAXPEAUImGui_ImplGlfw_Data@@@Z ; IM_DELETE<ImGui_ImplGlfw_Data>
PUBLIC	?_grow_capacity@?$ImVector@UImGuiPlatformMonitor@@@@QEBAHH@Z ; ImVector<ImGuiPlatformMonitor>::_grow_capacity
PUBLIC	?reserve@?$ImVector@UImGuiPlatformMonitor@@@@QEAAXH@Z ; ImVector<ImGuiPlatformMonitor>::reserve
PUBLIC	?resize@?$ImVector@UImGuiPlatformMonitor@@@@QEAAXH@Z ; ImVector<ImGuiPlatformMonitor>::resize
PUBLIC	?push_back@?$ImVector@UImGuiPlatformMonitor@@@@QEAAXAEBUImGuiPlatformMonitor@@@Z ; ImVector<ImGuiPlatformMonitor>::push_back
PUBLIC	??1ImGui_ImplGlfw_ViewportData@@QEAA@XZ		; ImGui_ImplGlfw_ViewportData::~ImGui_ImplGlfw_ViewportData
PUBLIC	??0ImGui_ImplGlfw_ViewportData@@QEAA@XZ		; ImGui_ImplGlfw_ViewportData::ImGui_ImplGlfw_ViewportData
PUBLIC	?ImGui_ImplGlfw_NewFrame@@YAXXZ			; ImGui_ImplGlfw_NewFrame
PUBLIC	?ImGui_ImplGlfw_Shutdown@@YAXXZ			; ImGui_ImplGlfw_Shutdown
PUBLIC	?ImGui_ImplGlfw_InitForOpenGL@@YA_NPEAUGLFWwindow@@_N@Z ; ImGui_ImplGlfw_InitForOpenGL
PUBLIC	?ImGui_ImplGlfw_RestoreCallbacks@@YAXPEAUGLFWwindow@@@Z ; ImGui_ImplGlfw_RestoreCallbacks
PUBLIC	?ImGui_ImplGlfw_InstallCallbacks@@YAXPEAUGLFWwindow@@@Z ; ImGui_ImplGlfw_InstallCallbacks
PUBLIC	?ImGui_ImplGlfw_MonitorCallback@@YAXPEAUGLFWmonitor@@H@Z ; ImGui_ImplGlfw_MonitorCallback
PUBLIC	?ImGui_ImplGlfw_CharCallback@@YAXPEAUGLFWwindow@@I@Z ; ImGui_ImplGlfw_CharCallback
PUBLIC	?ImGui_ImplGlfw_CursorEnterCallback@@YAXPEAUGLFWwindow@@H@Z ; ImGui_ImplGlfw_CursorEnterCallback
PUBLIC	?ImGui_ImplGlfw_CursorPosCallback@@YAXPEAUGLFWwindow@@NN@Z ; ImGui_ImplGlfw_CursorPosCallback
PUBLIC	?ImGui_ImplGlfw_WindowFocusCallback@@YAXPEAUGLFWwindow@@H@Z ; ImGui_ImplGlfw_WindowFocusCallback
PUBLIC	?ImGui_ImplGlfw_KeyCallback@@YAXPEAUGLFWwindow@@HHHH@Z ; ImGui_ImplGlfw_KeyCallback
PUBLIC	?ImGui_ImplGlfw_ScrollCallback@@YAXPEAUGLFWwindow@@NN@Z ; ImGui_ImplGlfw_ScrollCallback
PUBLIC	?ImGui_ImplGlfw_MouseButtonCallback@@YAXPEAUGLFWwindow@@HHH@Z ; ImGui_ImplGlfw_MouseButtonCallback
PUBLIC	??0ImGui_ImplGlfw_Data@@QEAA@XZ			; ImGui_ImplGlfw_Data::ImGui_ImplGlfw_Data
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImGuiPlatformMonitor@@@@QEAAXH@Z DD imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImGuiPlatformMonitor@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?reserve@?$ImVector@UImGuiPlatformMonitor@@@@QEAAXH@Z DD imagerel $LN26+28
	DD	imagerel $LN26+134
	DD	imagerel $chain$0$?reserve@?$ImVector@UImGuiPlatformMonitor@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?reserve@?$ImVector@UImGuiPlatformMonitor@@@@QEAAXH@Z DD imagerel $LN26+134
	DD	imagerel $LN26+145
	DD	imagerel $chain$1$?reserve@?$ImVector@UImGuiPlatformMonitor@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@UImGuiPlatformMonitor@@@@QEAAXH@Z DD imagerel $LN11
	DD	imagerel $LN11+52
	DD	imagerel $unwind$?resize@?$ImVector@UImGuiPlatformMonitor@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$ImVector@UImGuiPlatformMonitor@@@@QEAAXAEBUImGuiPlatformMonitor@@@Z DD imagerel $LN11
	DD	imagerel $LN11+120
	DD	imagerel $unwind$?push_back@?$ImVector@UImGuiPlatformMonitor@@@@QEAAXAEBUImGuiPlatformMonitor@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImGui_ImplGlfw_InitPlatformInterface@@YAXXZ DD imagerel ?ImGui_ImplGlfw_InitPlatformInterface@@YAXXZ
	DD	imagerel ?ImGui_ImplGlfw_InitPlatformInterface@@YAXXZ+338
	DD	imagerel $unwind$?ImGui_ImplGlfw_InitPlatformInterface@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImGui_ImplGlfw_SwapBuffers@@YAXPEAUImGuiViewport@@PEAX@Z DD imagerel ?ImGui_ImplGlfw_SwapBuffers@@YAXPEAUImGuiViewport@@PEAX@Z
	DD	imagerel ?ImGui_ImplGlfw_SwapBuffers@@YAXPEAUImGuiViewport@@PEAX@Z+62
	DD	imagerel $unwind$?ImGui_ImplGlfw_SwapBuffers@@YAXPEAUImGuiViewport@@PEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImGui_ImplGlfw_GetWindowMinimized@@YA_NPEAUImGuiViewport@@@Z DD imagerel ?ImGui_ImplGlfw_GetWindowMinimized@@YA_NPEAUImGuiViewport@@@Z
	DD	imagerel ?ImGui_ImplGlfw_GetWindowMinimized@@YA_NPEAUImGuiViewport@@@Z+31
	DD	imagerel $unwind$?ImGui_ImplGlfw_GetWindowMinimized@@YA_NPEAUImGuiViewport@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImGui_ImplGlfw_GetWindowFocus@@YA_NPEAUImGuiViewport@@@Z DD imagerel ?ImGui_ImplGlfw_GetWindowFocus@@YA_NPEAUImGuiViewport@@@Z
	DD	imagerel ?ImGui_ImplGlfw_GetWindowFocus@@YA_NPEAUImGuiViewport@@@Z+31
	DD	imagerel $unwind$?ImGui_ImplGlfw_GetWindowFocus@@YA_NPEAUImGuiViewport@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImGui_ImplGlfw_GetWindowSize@@YA?AUImVec2@@PEAUImGuiViewport@@@Z DD imagerel ?ImGui_ImplGlfw_GetWindowSize@@YA?AUImVec2@@PEAUImGuiViewport@@@Z
	DD	imagerel ?ImGui_ImplGlfw_GetWindowSize@@YA?AUImVec2@@PEAUImGuiViewport@@@Z+105
	DD	imagerel $unwind$?ImGui_ImplGlfw_GetWindowSize@@YA?AUImVec2@@PEAUImGuiViewport@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImGui_ImplGlfw_GetWindowPos@@YA?AUImVec2@@PEAUImGuiViewport@@@Z DD imagerel ?ImGui_ImplGlfw_GetWindowPos@@YA?AUImVec2@@PEAUImGuiViewport@@@Z
	DD	imagerel ?ImGui_ImplGlfw_GetWindowPos@@YA?AUImVec2@@PEAUImGuiViewport@@@Z+105
	DD	imagerel $unwind$?ImGui_ImplGlfw_GetWindowPos@@YA?AUImVec2@@PEAUImGuiViewport@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImGui_ImplGlfw_ShowWindow@@YAXPEAUImGuiViewport@@@Z DD imagerel ?ImGui_ImplGlfw_ShowWindow@@YAXPEAUImGuiViewport@@@Z
	DD	imagerel ?ImGui_ImplGlfw_ShowWindow@@YAXPEAUImGuiViewport@@@Z+134
	DD	imagerel $unwind$?ImGui_ImplGlfw_ShowWindow@@YAXPEAUImGuiViewport@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImGui_ImplGlfw_DestroyWindow@@YAXPEAUImGuiViewport@@@Z DD imagerel ?ImGui_ImplGlfw_DestroyWindow@@YAXPEAUImGuiViewport@@@Z
	DD	imagerel ?ImGui_ImplGlfw_DestroyWindow@@YAXPEAUImGuiViewport@@@Z+81
	DD	imagerel $unwind$?ImGui_ImplGlfw_DestroyWindow@@YAXPEAUImGuiViewport@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?ImGui_ImplGlfw_DestroyWindow@@YAXPEAUImGuiViewport@@@Z DD imagerel ?ImGui_ImplGlfw_DestroyWindow@@YAXPEAUImGuiViewport@@@Z+81
	DD	imagerel ?ImGui_ImplGlfw_DestroyWindow@@YAXPEAUImGuiViewport@@@Z+159
	DD	imagerel $chain$0$?ImGui_ImplGlfw_DestroyWindow@@YAXPEAUImGuiViewport@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?ImGui_ImplGlfw_DestroyWindow@@YAXPEAUImGuiViewport@@@Z DD imagerel ?ImGui_ImplGlfw_DestroyWindow@@YAXPEAUImGuiViewport@@@Z+159
	DD	imagerel ?ImGui_ImplGlfw_DestroyWindow@@YAXPEAUImGuiViewport@@@Z+222
	DD	imagerel $chain$1$?ImGui_ImplGlfw_DestroyWindow@@YAXPEAUImGuiViewport@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImGui_ImplGlfw_CreateWindow@@YAXPEAUImGuiViewport@@@Z DD imagerel ?ImGui_ImplGlfw_CreateWindow@@YAXPEAUImGuiViewport@@@Z
	DD	imagerel ?ImGui_ImplGlfw_CreateWindow@@YAXPEAUImGuiViewport@@@Z+454
	DD	imagerel $unwind$?ImGui_ImplGlfw_CreateWindow@@YAXPEAUImGuiViewport@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImGui_ImplGlfw_WindowSizeCallback@@YAXPEAUGLFWwindow@@HH@Z DD imagerel ?ImGui_ImplGlfw_WindowSizeCallback@@YAXPEAUGLFWwindow@@HH@Z
	DD	imagerel ?ImGui_ImplGlfw_WindowSizeCallback@@YAXPEAUGLFWwindow@@HH@Z+25
	DD	imagerel $unwind$?ImGui_ImplGlfw_WindowSizeCallback@@YAXPEAUGLFWwindow@@HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?ImGui_ImplGlfw_WindowSizeCallback@@YAXPEAUGLFWwindow@@HH@Z DD imagerel ?ImGui_ImplGlfw_WindowSizeCallback@@YAXPEAUGLFWwindow@@HH@Z+25
	DD	imagerel ?ImGui_ImplGlfw_WindowSizeCallback@@YAXPEAUGLFWwindow@@HH@Z+81
	DD	imagerel $chain$0$?ImGui_ImplGlfw_WindowSizeCallback@@YAXPEAUGLFWwindow@@HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?ImGui_ImplGlfw_WindowSizeCallback@@YAXPEAUGLFWwindow@@HH@Z DD imagerel ?ImGui_ImplGlfw_WindowSizeCallback@@YAXPEAUGLFWwindow@@HH@Z+81
	DD	imagerel ?ImGui_ImplGlfw_WindowSizeCallback@@YAXPEAUGLFWwindow@@HH@Z+124
	DD	imagerel $chain$2$?ImGui_ImplGlfw_WindowSizeCallback@@YAXPEAUGLFWwindow@@HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?ImGui_ImplGlfw_WindowSizeCallback@@YAXPEAUGLFWwindow@@HH@Z DD imagerel ?ImGui_ImplGlfw_WindowSizeCallback@@YAXPEAUGLFWwindow@@HH@Z+124
	DD	imagerel ?ImGui_ImplGlfw_WindowSizeCallback@@YAXPEAUGLFWwindow@@HH@Z+129
	DD	imagerel $chain$3$?ImGui_ImplGlfw_WindowSizeCallback@@YAXPEAUGLFWwindow@@HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImGui_ImplGlfw_WindowPosCallback@@YAXPEAUGLFWwindow@@HH@Z DD imagerel ?ImGui_ImplGlfw_WindowPosCallback@@YAXPEAUGLFWwindow@@HH@Z
	DD	imagerel ?ImGui_ImplGlfw_WindowPosCallback@@YAXPEAUGLFWwindow@@HH@Z+25
	DD	imagerel $unwind$?ImGui_ImplGlfw_WindowPosCallback@@YAXPEAUGLFWwindow@@HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?ImGui_ImplGlfw_WindowPosCallback@@YAXPEAUGLFWwindow@@HH@Z DD imagerel ?ImGui_ImplGlfw_WindowPosCallback@@YAXPEAUGLFWwindow@@HH@Z+25
	DD	imagerel ?ImGui_ImplGlfw_WindowPosCallback@@YAXPEAUGLFWwindow@@HH@Z+81
	DD	imagerel $chain$0$?ImGui_ImplGlfw_WindowPosCallback@@YAXPEAUGLFWwindow@@HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?ImGui_ImplGlfw_WindowPosCallback@@YAXPEAUGLFWwindow@@HH@Z DD imagerel ?ImGui_ImplGlfw_WindowPosCallback@@YAXPEAUGLFWwindow@@HH@Z+81
	DD	imagerel ?ImGui_ImplGlfw_WindowPosCallback@@YAXPEAUGLFWwindow@@HH@Z+124
	DD	imagerel $chain$2$?ImGui_ImplGlfw_WindowPosCallback@@YAXPEAUGLFWwindow@@HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?ImGui_ImplGlfw_WindowPosCallback@@YAXPEAUGLFWwindow@@HH@Z DD imagerel ?ImGui_ImplGlfw_WindowPosCallback@@YAXPEAUGLFWwindow@@HH@Z+124
	DD	imagerel ?ImGui_ImplGlfw_WindowPosCallback@@YAXPEAUGLFWwindow@@HH@Z+129
	DD	imagerel $chain$3$?ImGui_ImplGlfw_WindowPosCallback@@YAXPEAUGLFWwindow@@HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImGui_ImplGlfw_NewFrame@@YAXXZ DD imagerel $LN54
	DD	imagerel $LN54+311
	DD	imagerel $unwind$?ImGui_ImplGlfw_NewFrame@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?ImGui_ImplGlfw_NewFrame@@YAXXZ DD imagerel $LN54+311
	DD	imagerel $LN54+347
	DD	imagerel $chain$1$?ImGui_ImplGlfw_NewFrame@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?ImGui_ImplGlfw_NewFrame@@YAXXZ DD imagerel $LN54+347
	DD	imagerel $LN54+476
	DD	imagerel $chain$4$?ImGui_ImplGlfw_NewFrame@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?ImGui_ImplGlfw_NewFrame@@YAXXZ DD imagerel $LN54+476
	DD	imagerel $LN54+486
	DD	imagerel $chain$5$?ImGui_ImplGlfw_NewFrame@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?ImGui_ImplGlfw_NewFrame@@YAXXZ DD imagerel $LN54+486
	DD	imagerel $LN54+512
	DD	imagerel $chain$6$?ImGui_ImplGlfw_NewFrame@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImGui_ImplGlfw_UpdateMonitors@@YAXXZ DD imagerel ?ImGui_ImplGlfw_UpdateMonitors@@YAXXZ
	DD	imagerel ?ImGui_ImplGlfw_UpdateMonitors@@YAXXZ+535
	DD	imagerel $unwind$?ImGui_ImplGlfw_UpdateMonitors@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ DD imagerel ?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ
	DD	imagerel ?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ+83
	DD	imagerel $unwind$?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ DD imagerel ?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ+83
	DD	imagerel ?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ+130
	DD	imagerel $chain$2$?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ DD imagerel ?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ+130
	DD	imagerel ?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ+1257
	DD	imagerel $chain$6$?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ DD imagerel ?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ+1257
	DD	imagerel ?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ+1322
	DD	imagerel $chain$7$?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ DD imagerel ?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ+1322
	DD	imagerel ?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ+1378
	DD	imagerel $chain$8$?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ DD imagerel ?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ+1378
	DD	imagerel ?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ+1407
	DD	imagerel $chain$9$?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImGui_ImplGlfw_UpdateMouseCursor@@YAXXZ DD imagerel ?ImGui_ImplGlfw_UpdateMouseCursor@@YAXXZ
	DD	imagerel ?ImGui_ImplGlfw_UpdateMouseCursor@@YAXXZ+68
	DD	imagerel $unwind$?ImGui_ImplGlfw_UpdateMouseCursor@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?ImGui_ImplGlfw_UpdateMouseCursor@@YAXXZ DD imagerel ?ImGui_ImplGlfw_UpdateMouseCursor@@YAXXZ+68
	DD	imagerel ?ImGui_ImplGlfw_UpdateMouseCursor@@YAXXZ+104
	DD	imagerel $chain$1$?ImGui_ImplGlfw_UpdateMouseCursor@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?ImGui_ImplGlfw_UpdateMouseCursor@@YAXXZ DD imagerel ?ImGui_ImplGlfw_UpdateMouseCursor@@YAXXZ+104
	DD	imagerel ?ImGui_ImplGlfw_UpdateMouseCursor@@YAXXZ+233
	DD	imagerel $chain$4$?ImGui_ImplGlfw_UpdateMouseCursor@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?ImGui_ImplGlfw_UpdateMouseCursor@@YAXXZ DD imagerel ?ImGui_ImplGlfw_UpdateMouseCursor@@YAXXZ+233
	DD	imagerel ?ImGui_ImplGlfw_UpdateMouseCursor@@YAXXZ+243
	DD	imagerel $chain$5$?ImGui_ImplGlfw_UpdateMouseCursor@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?ImGui_ImplGlfw_UpdateMouseCursor@@YAXXZ DD imagerel ?ImGui_ImplGlfw_UpdateMouseCursor@@YAXXZ+243
	DD	imagerel ?ImGui_ImplGlfw_UpdateMouseCursor@@YAXXZ+251
	DD	imagerel $chain$6$?ImGui_ImplGlfw_UpdateMouseCursor@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImGui_ImplGlfw_UpdateMouseData@@YAXXZ DD imagerel ?ImGui_ImplGlfw_UpdateMouseData@@YAXXZ
	DD	imagerel ?ImGui_ImplGlfw_UpdateMouseData@@YAXXZ+27
	DD	imagerel $unwind$?ImGui_ImplGlfw_UpdateMouseData@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?ImGui_ImplGlfw_UpdateMouseData@@YAXXZ DD imagerel ?ImGui_ImplGlfw_UpdateMouseData@@YAXXZ+27
	DD	imagerel ?ImGui_ImplGlfw_UpdateMouseData@@YAXXZ+126
	DD	imagerel $chain$5$?ImGui_ImplGlfw_UpdateMouseData@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?ImGui_ImplGlfw_UpdateMouseData@@YAXXZ DD imagerel ?ImGui_ImplGlfw_UpdateMouseData@@YAXXZ+126
	DD	imagerel ?ImGui_ImplGlfw_UpdateMouseData@@YAXXZ+473
	DD	imagerel $chain$7$?ImGui_ImplGlfw_UpdateMouseData@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?ImGui_ImplGlfw_UpdateMouseData@@YAXXZ DD imagerel ?ImGui_ImplGlfw_UpdateMouseData@@YAXXZ+473
	DD	imagerel ?ImGui_ImplGlfw_UpdateMouseData@@YAXXZ+523
	DD	imagerel $chain$8$?ImGui_ImplGlfw_UpdateMouseData@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$?ImGui_ImplGlfw_UpdateMouseData@@YAXXZ DD imagerel ?ImGui_ImplGlfw_UpdateMouseData@@YAXXZ+523
	DD	imagerel ?ImGui_ImplGlfw_UpdateMouseData@@YAXXZ+752
	DD	imagerel $chain$9$?ImGui_ImplGlfw_UpdateMouseData@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImGui_ImplGlfw_Shutdown@@YAXXZ DD imagerel $LN44
	DD	imagerel $LN44+425
	DD	imagerel $unwind$?ImGui_ImplGlfw_Shutdown@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImGui_ImplGlfw_Init@@YA_NPEAUGLFWwindow@@_NW4GlfwClientApi@@@Z DD imagerel ?ImGui_ImplGlfw_Init@@YA_NPEAUGLFWwindow@@_NW4GlfwClientApi@@@Z
	DD	imagerel ?ImGui_ImplGlfw_Init@@YA_NPEAUGLFWwindow@@_NW4GlfwClientApi@@@Z+964
	DD	imagerel $unwind$?ImGui_ImplGlfw_Init@@YA_NPEAUGLFWwindow@@_NW4GlfwClientApi@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImGui_ImplGlfw_RestoreCallbacks@@YAXPEAUGLFWwindow@@@Z DD imagerel $LN9
	DD	imagerel $LN9+237
	DD	imagerel $unwind$?ImGui_ImplGlfw_RestoreCallbacks@@YAXPEAUGLFWwindow@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImGui_ImplGlfw_InstallCallbacks@@YAXPEAUGLFWwindow@@@Z DD imagerel $LN9
	DD	imagerel $LN9+220
	DD	imagerel $unwind$?ImGui_ImplGlfw_InstallCallbacks@@YAXPEAUGLFWwindow@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImGui_ImplGlfw_WndProc@@YA_JPEAUHWND__@@I_K_J@Z DD imagerel ?ImGui_ImplGlfw_WndProc@@YA_JPEAUHWND__@@I_K_J@Z
	DD	imagerel ?ImGui_ImplGlfw_WndProc@@YA_JPEAUHWND__@@I_K_J@Z+320
	DD	imagerel $unwind$?ImGui_ImplGlfw_WndProc@@YA_JPEAUHWND__@@I_K_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetMouseSourceFromMessageExtraInfo@@YA?AW4ImGuiMouseSource@@XZ DD imagerel ?GetMouseSourceFromMessageExtraInfo@@YA?AW4ImGuiMouseSource@@XZ
	DD	imagerel ?GetMouseSourceFromMessageExtraInfo@@YA?AW4ImGuiMouseSource@@XZ+59
	DD	imagerel $unwind$?GetMouseSourceFromMessageExtraInfo@@YA?AW4ImGuiMouseSource@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImGui_ImplGlfw_CharCallback@@YAXPEAUGLFWwindow@@I@Z DD imagerel $LN22
	DD	imagerel $LN22+122
	DD	imagerel $unwind$?ImGui_ImplGlfw_CharCallback@@YAXPEAUGLFWwindow@@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImGui_ImplGlfw_CursorEnterCallback@@YAXPEAUGLFWwindow@@H@Z DD imagerel $LN28
	DD	imagerel $LN28+195
	DD	imagerel $unwind$?ImGui_ImplGlfw_CursorEnterCallback@@YAXPEAUGLFWwindow@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImGui_ImplGlfw_CursorPosCallback@@YAXPEAUGLFWwindow@@NN@Z DD imagerel $LN26
	DD	imagerel $LN26+257
	DD	imagerel $unwind$?ImGui_ImplGlfw_CursorPosCallback@@YAXPEAUGLFWwindow@@NN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImGui_ImplGlfw_WindowFocusCallback@@YAXPEAUGLFWwindow@@H@Z DD imagerel $LN57
	DD	imagerel $LN57+364
	DD	imagerel $unwind$?ImGui_ImplGlfw_WindowFocusCallback@@YAXPEAUGLFWwindow@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImGui_ImplGlfw_KeyCallback@@YAXPEAUGLFWwindow@@HHHH@Z DD imagerel $LN65
	DD	imagerel $LN65+513
	DD	imagerel $unwind$?ImGui_ImplGlfw_KeyCallback@@YAXPEAUGLFWwindow@@HHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImGui_ImplGlfw_TranslateUntranslatedKey@@YAHHH@Z DD imagerel ?ImGui_ImplGlfw_TranslateUntranslatedKey@@YAHHH@Z
	DD	imagerel ?ImGui_ImplGlfw_TranslateUntranslatedKey@@YAHHH@Z+46
	DD	imagerel $unwind$?ImGui_ImplGlfw_TranslateUntranslatedKey@@YAHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?ImGui_ImplGlfw_TranslateUntranslatedKey@@YAHHH@Z DD imagerel ?ImGui_ImplGlfw_TranslateUntranslatedKey@@YAHHH@Z+46
	DD	imagerel ?ImGui_ImplGlfw_TranslateUntranslatedKey@@YAHHH@Z+106
	DD	imagerel $chain$0$?ImGui_ImplGlfw_TranslateUntranslatedKey@@YAHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?ImGui_ImplGlfw_TranslateUntranslatedKey@@YAHHH@Z DD imagerel ?ImGui_ImplGlfw_TranslateUntranslatedKey@@YAHHH@Z+106
	DD	imagerel ?ImGui_ImplGlfw_TranslateUntranslatedKey@@YAHHH@Z+287
	DD	imagerel $chain$1$?ImGui_ImplGlfw_TranslateUntranslatedKey@@YAHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImGui_ImplGlfw_ScrollCallback@@YAXPEAUGLFWwindow@@NN@Z DD imagerel $LN42
	DD	imagerel $LN42+342
	DD	imagerel $unwind$?ImGui_ImplGlfw_ScrollCallback@@YAXPEAUGLFWwindow@@NN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImGui_ImplGlfw_MouseButtonCallback@@YAXPEAUGLFWwindow@@HHH@Z DD imagerel $LN60
	DD	imagerel $LN60+424
	DD	imagerel $unwind$?ImGui_ImplGlfw_MouseButtonCallback@@YAXPEAUGLFWwindow@@HHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImGui_ImplGlfw_UpdateKeyModifiers@@YAXPEAUGLFWwindow@@@Z DD imagerel ?ImGui_ImplGlfw_UpdateKeyModifiers@@YAXPEAUGLFWwindow@@@Z
	DD	imagerel ?ImGui_ImplGlfw_UpdateKeyModifiers@@YAXPEAUGLFWwindow@@@Z+364
	DD	imagerel $unwind$?ImGui_ImplGlfw_UpdateKeyModifiers@@YAXPEAUGLFWwindow@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImGui_ImplGlfw_Data@@QEAA@XZ DD imagerel $LN6
	DD	imagerel $LN6+38
	DD	imagerel $unwind$??0ImGui_ImplGlfw_Data@@QEAA@XZ
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImGui_ImplGlfw_Data@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImGui_ImplGlfw_UpdateKeyModifiers@@YAXPEAUGLFWwindow@@@Z DD 061f01H
	DD	02681fH
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImGui_ImplGlfw_MouseButtonCallback@@YAXPEAUGLFWwindow@@HHH@Z DD 081401H
	DD	0c6414H
	DD	0b5414H
	DD	0a3414H
	DD	070107214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImGui_ImplGlfw_ScrollCallback@@YAXPEAUGLFWwindow@@NN@Z DD 061d01H
	DD	04781dH
	DD	056815H
	DD	03002b206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?ImGui_ImplGlfw_TranslateUntranslatedKey@@YAHHH@Z DD 021H
	DD	imagerel ?ImGui_ImplGlfw_TranslateUntranslatedKey@@YAHHH@Z
	DD	imagerel ?ImGui_ImplGlfw_TranslateUntranslatedKey@@YAHHH@Z+46
	DD	imagerel $unwind$?ImGui_ImplGlfw_TranslateUntranslatedKey@@YAHHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?ImGui_ImplGlfw_TranslateUntranslatedKey@@YAHHH@Z DD 020821H
	DD	0123408H
	DD	imagerel ?ImGui_ImplGlfw_TranslateUntranslatedKey@@YAHHH@Z
	DD	imagerel ?ImGui_ImplGlfw_TranslateUntranslatedKey@@YAHHH@Z+46
	DD	imagerel $unwind$?ImGui_ImplGlfw_TranslateUntranslatedKey@@YAHHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImGui_ImplGlfw_TranslateUntranslatedKey@@YAHHH@Z DD 041919H
	DD	013640aH
	DD	07006d20aH
	DD	imagerel __GSHandlerCheck
	DD	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImGui_ImplGlfw_KeyCallback@@YAXPEAUGLFWwindow@@HHHH@Z DD 081f19H
	DD	0110110H
	DD	0e007f009H
	DD	060047005H
	DD	030025003H
	DD	imagerel __GSHandlerCheck
	DD	070H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImGui_ImplGlfw_WindowFocusCallback@@YAXPEAUGLFWwindow@@H@Z DD 040a01H
	DD	0a340aH
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImGui_ImplGlfw_CursorPosCallback@@YAXPEAUGLFWwindow@@NN@Z DD 082119H
	DD	037812H
	DD	04680dH
	DD	070049208H
	DD	030026003H
	DD	imagerel __GSHandlerCheck
	DD	028H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImGui_ImplGlfw_CursorEnterCallback@@YAXPEAUGLFWwindow@@H@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImGui_ImplGlfw_CharCallback@@YAXPEAUGLFWwindow@@I@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetMouseSourceFromMessageExtraInfo@@YA?AW4ImGuiMouseSource@@XZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImGui_ImplGlfw_WndProc@@YA_JPEAUHWND__@@I_K_J@Z DD 0c1e01H
	DD	0d741eH
	DD	0c641eH
	DD	0b541eH
	DD	0a341eH
	DD	0f01a521eH
	DD	0c016e018H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImGui_ImplGlfw_InstallCallbacks@@YAXPEAUGLFWwindow@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImGui_ImplGlfw_RestoreCallbacks@@YAXPEAUGLFWwindow@@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImGui_ImplGlfw_Init@@YA_NPEAUGLFWwindow@@_NW4GlfwClientApi@@@Z DD 060d01H
	DD	0a340dH
	DD	0e009320dH
	DD	050067007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImGui_ImplGlfw_Shutdown@@YAXXZ DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0e016321aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$?ImGui_ImplGlfw_UpdateMouseData@@YAXXZ DD 020021H
	DD	0183400H
	DD	imagerel ?ImGui_ImplGlfw_UpdateMouseData@@YAXXZ
	DD	imagerel ?ImGui_ImplGlfw_UpdateMouseData@@YAXXZ+27
	DD	imagerel $unwind$?ImGui_ImplGlfw_UpdateMouseData@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?ImGui_ImplGlfw_UpdateMouseData@@YAXXZ DD 021H
	DD	imagerel ?ImGui_ImplGlfw_UpdateMouseData@@YAXXZ+27
	DD	imagerel ?ImGui_ImplGlfw_UpdateMouseData@@YAXXZ+126
	DD	imagerel $chain$5$?ImGui_ImplGlfw_UpdateMouseData@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?ImGui_ImplGlfw_UpdateMouseData@@YAXXZ DD 041021H
	DD	01ac410H
	DD	0196408H
	DD	imagerel ?ImGui_ImplGlfw_UpdateMouseData@@YAXXZ+27
	DD	imagerel ?ImGui_ImplGlfw_UpdateMouseData@@YAXXZ+126
	DD	imagerel $chain$5$?ImGui_ImplGlfw_UpdateMouseData@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?ImGui_ImplGlfw_UpdateMouseData@@YAXXZ DD 0c3c21H
	DD	018343cH
	DD	07781fH
	DD	08681aH
	DD	012f415H
	DD	013e40aH
	DD	014d404H
	DD	imagerel ?ImGui_ImplGlfw_UpdateMouseData@@YAXXZ
	DD	imagerel ?ImGui_ImplGlfw_UpdateMouseData@@YAXXZ+27
	DD	imagerel $unwind$?ImGui_ImplGlfw_UpdateMouseData@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImGui_ImplGlfw_UpdateMouseData@@YAXXZ DD 041b19H
	DD	015010cH
	DD	050047005H
	DD	imagerel __GSHandlerCheck
	DD	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?ImGui_ImplGlfw_UpdateMouseCursor@@YAXXZ DD 021H
	DD	imagerel ?ImGui_ImplGlfw_UpdateMouseCursor@@YAXXZ
	DD	imagerel ?ImGui_ImplGlfw_UpdateMouseCursor@@YAXXZ+68
	DD	imagerel $unwind$?ImGui_ImplGlfw_UpdateMouseCursor@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?ImGui_ImplGlfw_UpdateMouseCursor@@YAXXZ DD 021H
	DD	imagerel ?ImGui_ImplGlfw_UpdateMouseCursor@@YAXXZ+68
	DD	imagerel ?ImGui_ImplGlfw_UpdateMouseCursor@@YAXXZ+104
	DD	imagerel $chain$1$?ImGui_ImplGlfw_UpdateMouseCursor@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?ImGui_ImplGlfw_UpdateMouseCursor@@YAXXZ DD 061221H
	DD	04f412H
	DD	05e40aH
	DD	0cd405H
	DD	imagerel ?ImGui_ImplGlfw_UpdateMouseCursor@@YAXXZ+68
	DD	imagerel ?ImGui_ImplGlfw_UpdateMouseCursor@@YAXXZ+104
	DD	imagerel $chain$1$?ImGui_ImplGlfw_UpdateMouseCursor@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?ImGui_ImplGlfw_UpdateMouseCursor@@YAXXZ DD 041121H
	DD	0bc411H
	DD	0a5405H
	DD	imagerel ?ImGui_ImplGlfw_UpdateMouseCursor@@YAXXZ
	DD	imagerel ?ImGui_ImplGlfw_UpdateMouseCursor@@YAXXZ+68
	DD	imagerel $unwind$?ImGui_ImplGlfw_UpdateMouseCursor@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImGui_ImplGlfw_UpdateMouseCursor@@YAXXZ DD 040801H
	DD	070045208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ DD 021H
	DD	imagerel ?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ
	DD	imagerel ?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ+83
	DD	imagerel $unwind$?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ DD 021H
	DD	imagerel ?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ+83
	DD	imagerel ?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ+130
	DD	imagerel $chain$2$?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ DD 040021H
	DD	05c800H
	DD	06b800H
	DD	imagerel ?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ+83
	DD	imagerel ?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ+130
	DD	imagerel $chain$2$?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ DD 081b21H
	DD	05c81bH
	DD	06b815H
	DD	07a80fH
	DD	089809H
	DD	imagerel ?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ+83
	DD	imagerel ?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ+130
	DD	imagerel $chain$2$?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ DD 062f21H
	DD	09882fH
	DD	0a7813H
	DD	0b6808H
	DD	imagerel ?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ
	DD	imagerel ?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ+83
	DD	imagerel $unwind$?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ DD 052019H
	DD	01a3412H
	DD	0180112H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImGui_ImplGlfw_UpdateMonitors@@YAXXZ DD 092a19H
	DD	016741cH
	DD	015641cH
	DD	014341cH
	DD	012011cH
	DD	05010H
	DD	imagerel __GSHandlerCheck
	DD	080H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?ImGui_ImplGlfw_NewFrame@@YAXXZ DD 021H
	DD	imagerel $LN54
	DD	imagerel $LN54+311
	DD	imagerel $unwind$?ImGui_ImplGlfw_NewFrame@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?ImGui_ImplGlfw_NewFrame@@YAXXZ DD 021H
	DD	imagerel $LN54+311
	DD	imagerel $LN54+347
	DD	imagerel $chain$1$?ImGui_ImplGlfw_NewFrame@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?ImGui_ImplGlfw_NewFrame@@YAXXZ DD 061521H
	DD	08f415H
	DD	09e40dH
	DD	010d408H
	DD	imagerel $LN54+311
	DD	imagerel $LN54+347
	DD	imagerel $chain$1$?ImGui_ImplGlfw_NewFrame@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?ImGui_ImplGlfw_NewFrame@@YAXXZ DD 041121H
	DD	0fc411H
	DD	0e5405H
	DD	imagerel $LN54
	DD	imagerel $LN54+311
	DD	imagerel $unwind$?ImGui_ImplGlfw_NewFrame@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImGui_ImplGlfw_NewFrame@@YAXXZ DD 041719H
	DD	070049208H
	DD	030026003H
	DD	imagerel __GSHandlerCheck
	DD	030H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?ImGui_ImplGlfw_WindowPosCallback@@YAXPEAUGLFWwindow@@HH@Z DD 021H
	DD	imagerel ?ImGui_ImplGlfw_WindowPosCallback@@YAXPEAUGLFWwindow@@HH@Z
	DD	imagerel ?ImGui_ImplGlfw_WindowPosCallback@@YAXPEAUGLFWwindow@@HH@Z+25
	DD	imagerel $unwind$?ImGui_ImplGlfw_WindowPosCallback@@YAXPEAUGLFWwindow@@HH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?ImGui_ImplGlfw_WindowPosCallback@@YAXPEAUGLFWwindow@@HH@Z DD 020021H
	DD	03400H
	DD	imagerel ?ImGui_ImplGlfw_WindowPosCallback@@YAXPEAUGLFWwindow@@HH@Z
	DD	imagerel ?ImGui_ImplGlfw_WindowPosCallback@@YAXPEAUGLFWwindow@@HH@Z+25
	DD	imagerel $unwind$?ImGui_ImplGlfw_WindowPosCallback@@YAXPEAUGLFWwindow@@HH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?ImGui_ImplGlfw_WindowPosCallback@@YAXPEAUGLFWwindow@@HH@Z DD 020421H
	DD	03404H
	DD	imagerel ?ImGui_ImplGlfw_WindowPosCallback@@YAXPEAUGLFWwindow@@HH@Z
	DD	imagerel ?ImGui_ImplGlfw_WindowPosCallback@@YAXPEAUGLFWwindow@@HH@Z+25
	DD	imagerel $unwind$?ImGui_ImplGlfw_WindowPosCallback@@YAXPEAUGLFWwindow@@HH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImGui_ImplGlfw_WindowPosCallback@@YAXPEAUGLFWwindow@@HH@Z DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?ImGui_ImplGlfw_WindowSizeCallback@@YAXPEAUGLFWwindow@@HH@Z DD 021H
	DD	imagerel ?ImGui_ImplGlfw_WindowSizeCallback@@YAXPEAUGLFWwindow@@HH@Z
	DD	imagerel ?ImGui_ImplGlfw_WindowSizeCallback@@YAXPEAUGLFWwindow@@HH@Z+25
	DD	imagerel $unwind$?ImGui_ImplGlfw_WindowSizeCallback@@YAXPEAUGLFWwindow@@HH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?ImGui_ImplGlfw_WindowSizeCallback@@YAXPEAUGLFWwindow@@HH@Z DD 020021H
	DD	03400H
	DD	imagerel ?ImGui_ImplGlfw_WindowSizeCallback@@YAXPEAUGLFWwindow@@HH@Z
	DD	imagerel ?ImGui_ImplGlfw_WindowSizeCallback@@YAXPEAUGLFWwindow@@HH@Z+25
	DD	imagerel $unwind$?ImGui_ImplGlfw_WindowSizeCallback@@YAXPEAUGLFWwindow@@HH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?ImGui_ImplGlfw_WindowSizeCallback@@YAXPEAUGLFWwindow@@HH@Z DD 020421H
	DD	03404H
	DD	imagerel ?ImGui_ImplGlfw_WindowSizeCallback@@YAXPEAUGLFWwindow@@HH@Z
	DD	imagerel ?ImGui_ImplGlfw_WindowSizeCallback@@YAXPEAUGLFWwindow@@HH@Z+25
	DD	imagerel $unwind$?ImGui_ImplGlfw_WindowSizeCallback@@YAXPEAUGLFWwindow@@HH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImGui_ImplGlfw_WindowSizeCallback@@YAXPEAUGLFWwindow@@HH@Z DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImGui_ImplGlfw_CreateWindow@@YAXPEAUImGuiViewport@@@Z DD 081401H
	DD	0b6414H
	DD	0a5414H
	DD	093414H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?ImGui_ImplGlfw_DestroyWindow@@YAXPEAUImGuiViewport@@@Z DD 021H
	DD	imagerel ?ImGui_ImplGlfw_DestroyWindow@@YAXPEAUImGuiViewport@@@Z
	DD	imagerel ?ImGui_ImplGlfw_DestroyWindow@@YAXPEAUImGuiViewport@@@Z+81
	DD	imagerel $unwind$?ImGui_ImplGlfw_DestroyWindow@@YAXPEAUImGuiViewport@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?ImGui_ImplGlfw_DestroyWindow@@YAXPEAUImGuiViewport@@@Z DD 020521H
	DD	083405H
	DD	imagerel ?ImGui_ImplGlfw_DestroyWindow@@YAXPEAUImGuiViewport@@@Z
	DD	imagerel ?ImGui_ImplGlfw_DestroyWindow@@YAXPEAUImGuiViewport@@@Z+81
	DD	imagerel $unwind$?ImGui_ImplGlfw_DestroyWindow@@YAXPEAUImGuiViewport@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImGui_ImplGlfw_DestroyWindow@@YAXPEAUImGuiViewport@@@Z DD 081501H
	DD	0b7415H
	DD	0a6415H
	DD	095415H
	DD	0e0115215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImGui_ImplGlfw_ShowWindow@@YAXPEAUImGuiViewport@@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImGui_ImplGlfw_GetWindowPos@@YA?AUImVec2@@PEAUImGuiViewport@@@Z DD 021519H
	DD	030025206H
	DD	imagerel __GSHandlerCheck
	DD	028H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImGui_ImplGlfw_GetWindowSize@@YA?AUImVec2@@PEAUImGuiViewport@@@Z DD 021519H
	DD	030025206H
	DD	imagerel __GSHandlerCheck
	DD	028H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImGui_ImplGlfw_GetWindowFocus@@YA_NPEAUImGuiViewport@@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImGui_ImplGlfw_GetWindowMinimized@@YA_NPEAUImGuiViewport@@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImGui_ImplGlfw_SwapBuffers@@YAXPEAUImGuiViewport@@PEAX@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImGui_ImplGlfw_InitPlatformInterface@@YAXXZ DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$ImVector@UImGuiPlatformMonitor@@@@QEAAXAEBUImGuiPlatformMonitor@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@UImGuiPlatformMonitor@@@@QEAAXH@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?reserve@?$ImVector@UImGuiPlatformMonitor@@@@QEAAXH@Z DD 021H
	DD	imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImGuiPlatformMonitor@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?reserve@?$ImVector@UImGuiPlatformMonitor@@@@QEAAXH@Z DD 020521H
	DD	066405H
	DD	imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImGuiPlatformMonitor@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImGuiPlatformMonitor@@@@QEAAXH@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ??0ImGui_ImplGlfw_Data@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0ImGui_ImplGlfw_Data@@QEAA@XZ PROC			; ImGui_ImplGlfw_Data::ImGui_ImplGlfw_Data, COMDAT

; 165  :     ImGui_ImplGlfw_Data()   { memset((void*)this, 0, sizeof(*this)); }

$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	xor	edx, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 269  :     constexpr ImVec2()                      : x(0.0f), y(0.0f) { }

	mov	DWORD PTR [rcx+108], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 165  :     ImGui_ImplGlfw_Data()   { memset((void*)this, 0, sizeof(*this)); }

	mov	r8d, 2976				; 00000ba0H
	mov	rbx, rcx
	call	memset
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0ImGui_ImplGlfw_Data@@QEAA@XZ ENDP			; ImGui_ImplGlfw_Data::ImGui_ImplGlfw_Data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?ImGui_ImplGlfw_GetBackendData@@YAPEAUImGui_ImplGlfw_Data@@XZ
_TEXT	SEGMENT
?ImGui_ImplGlfw_GetBackendData@@YAPEAUImGui_ImplGlfw_Data@@XZ PROC ; ImGui_ImplGlfw_GetBackendData, COMDAT

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN3@ImGui_Impl
	mov	rax, QWORD PTR [rax+152]

; 178  : }

	ret	0
$LN3@ImGui_Impl:
	ret	0
?ImGui_ImplGlfw_GetBackendData@@YAPEAUImGui_ImplGlfw_Data@@XZ ENDP ; ImGui_ImplGlfw_GetBackendData
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?ImGui_ImplGlfw_GetClipboardText@@YAPEBDPEAX@Z
_TEXT	SEGMENT
user_data$ = 8
?ImGui_ImplGlfw_GetClipboardText@@YAPEBDPEAX@Z PROC	; ImGui_ImplGlfw_GetClipboardText, COMDAT

; 188  :     return glfwGetClipboardString((GLFWwindow*)user_data);

	jmp	glfwGetClipboardString
?ImGui_ImplGlfw_GetClipboardText@@YAPEBDPEAX@Z ENDP	; ImGui_ImplGlfw_GetClipboardText
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?ImGui_ImplGlfw_SetClipboardText@@YAXPEAXPEBD@Z
_TEXT	SEGMENT
user_data$ = 8
text$ = 16
?ImGui_ImplGlfw_SetClipboardText@@YAXPEAXPEBD@Z PROC	; ImGui_ImplGlfw_SetClipboardText, COMDAT

; 193  :     glfwSetClipboardString((GLFWwindow*)user_data, text);

	jmp	glfwSetClipboardString
?ImGui_ImplGlfw_SetClipboardText@@YAXPEAXPEBD@Z ENDP	; ImGui_ImplGlfw_SetClipboardText
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?ImGui_ImplGlfw_KeyToImGuiKey@@YA?AW4ImGuiKey@@H@Z
_TEXT	SEGMENT
key$ = 8
?ImGui_ImplGlfw_KeyToImGuiKey@@YA?AW4ImGuiKey@@H@Z PROC	; ImGui_ImplGlfw_KeyToImGuiKey, COMDAT

; 198  :     switch (key)

	add	ecx, -32				; ffffffffffffffe0H
	cmp	ecx, 316				; 0000013cH
	ja	$LN109@ImGui_Impl
	movsxd	rax, ecx
	lea	rdx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR $LN111@ImGui_Impl[rdx+rax]
	mov	ecx, DWORD PTR $LN112@ImGui_Impl[rdx+rax*4]
	add	rcx, rdx
	jmp	rcx
$LN4@ImGui_Impl:

; 199  :     {
; 200  :         case GLFW_KEY_TAB: return ImGuiKey_Tab;

	mov	eax, 512				; 00000200H

; 306  :     }
; 307  : }

	ret	0
$LN5@ImGui_Impl:

; 201  :         case GLFW_KEY_LEFT: return ImGuiKey_LeftArrow;

	mov	eax, 513				; 00000201H

; 306  :     }
; 307  : }

	ret	0
$LN6@ImGui_Impl:

; 202  :         case GLFW_KEY_RIGHT: return ImGuiKey_RightArrow;

	mov	eax, 514				; 00000202H

; 306  :     }
; 307  : }

	ret	0
$LN7@ImGui_Impl:

; 203  :         case GLFW_KEY_UP: return ImGuiKey_UpArrow;

	mov	eax, 515				; 00000203H

; 306  :     }
; 307  : }

	ret	0
$LN8@ImGui_Impl:

; 204  :         case GLFW_KEY_DOWN: return ImGuiKey_DownArrow;

	mov	eax, 516				; 00000204H

; 306  :     }
; 307  : }

	ret	0
$LN9@ImGui_Impl:

; 205  :         case GLFW_KEY_PAGE_UP: return ImGuiKey_PageUp;

	mov	eax, 517				; 00000205H

; 306  :     }
; 307  : }

	ret	0
$LN10@ImGui_Impl:

; 206  :         case GLFW_KEY_PAGE_DOWN: return ImGuiKey_PageDown;

	mov	eax, 518				; 00000206H

; 306  :     }
; 307  : }

	ret	0
$LN11@ImGui_Impl:

; 207  :         case GLFW_KEY_HOME: return ImGuiKey_Home;

	mov	eax, 519				; 00000207H

; 306  :     }
; 307  : }

	ret	0
$LN12@ImGui_Impl:

; 208  :         case GLFW_KEY_END: return ImGuiKey_End;

	mov	eax, 520				; 00000208H

; 306  :     }
; 307  : }

	ret	0
$LN13@ImGui_Impl:

; 209  :         case GLFW_KEY_INSERT: return ImGuiKey_Insert;

	mov	eax, 521				; 00000209H

; 306  :     }
; 307  : }

	ret	0
$LN14@ImGui_Impl:

; 210  :         case GLFW_KEY_DELETE: return ImGuiKey_Delete;

	mov	eax, 522				; 0000020aH

; 306  :     }
; 307  : }

	ret	0
$LN15@ImGui_Impl:

; 211  :         case GLFW_KEY_BACKSPACE: return ImGuiKey_Backspace;

	mov	eax, 523				; 0000020bH

; 306  :     }
; 307  : }

	ret	0
$LN16@ImGui_Impl:

; 212  :         case GLFW_KEY_SPACE: return ImGuiKey_Space;

	mov	eax, 524				; 0000020cH

; 306  :     }
; 307  : }

	ret	0
$LN17@ImGui_Impl:

; 213  :         case GLFW_KEY_ENTER: return ImGuiKey_Enter;

	mov	eax, 525				; 0000020dH

; 306  :     }
; 307  : }

	ret	0
$LN18@ImGui_Impl:

; 214  :         case GLFW_KEY_ESCAPE: return ImGuiKey_Escape;

	mov	eax, 526				; 0000020eH

; 306  :     }
; 307  : }

	ret	0
$LN19@ImGui_Impl:

; 215  :         case GLFW_KEY_APOSTROPHE: return ImGuiKey_Apostrophe;

	mov	eax, 584				; 00000248H

; 306  :     }
; 307  : }

	ret	0
$LN20@ImGui_Impl:

; 216  :         case GLFW_KEY_COMMA: return ImGuiKey_Comma;

	mov	eax, 585				; 00000249H

; 306  :     }
; 307  : }

	ret	0
$LN21@ImGui_Impl:

; 217  :         case GLFW_KEY_MINUS: return ImGuiKey_Minus;

	mov	eax, 586				; 0000024aH

; 306  :     }
; 307  : }

	ret	0
$LN22@ImGui_Impl:

; 218  :         case GLFW_KEY_PERIOD: return ImGuiKey_Period;

	mov	eax, 587				; 0000024bH

; 306  :     }
; 307  : }

	ret	0
$LN23@ImGui_Impl:

; 219  :         case GLFW_KEY_SLASH: return ImGuiKey_Slash;

	mov	eax, 588				; 0000024cH

; 306  :     }
; 307  : }

	ret	0
$LN24@ImGui_Impl:

; 220  :         case GLFW_KEY_SEMICOLON: return ImGuiKey_Semicolon;

	mov	eax, 589				; 0000024dH

; 306  :     }
; 307  : }

	ret	0
$LN25@ImGui_Impl:

; 221  :         case GLFW_KEY_EQUAL: return ImGuiKey_Equal;

	mov	eax, 590				; 0000024eH

; 306  :     }
; 307  : }

	ret	0
$LN26@ImGui_Impl:

; 222  :         case GLFW_KEY_LEFT_BRACKET: return ImGuiKey_LeftBracket;

	mov	eax, 591				; 0000024fH

; 306  :     }
; 307  : }

	ret	0
$LN27@ImGui_Impl:

; 223  :         case GLFW_KEY_BACKSLASH: return ImGuiKey_Backslash;

	mov	eax, 592				; 00000250H

; 306  :     }
; 307  : }

	ret	0
$LN28@ImGui_Impl:

; 224  :         case GLFW_KEY_RIGHT_BRACKET: return ImGuiKey_RightBracket;

	mov	eax, 593				; 00000251H

; 306  :     }
; 307  : }

	ret	0
$LN29@ImGui_Impl:

; 225  :         case GLFW_KEY_GRAVE_ACCENT: return ImGuiKey_GraveAccent;

	mov	eax, 594				; 00000252H

; 306  :     }
; 307  : }

	ret	0
$LN30@ImGui_Impl:

; 226  :         case GLFW_KEY_CAPS_LOCK: return ImGuiKey_CapsLock;

	mov	eax, 595				; 00000253H

; 306  :     }
; 307  : }

	ret	0
$LN31@ImGui_Impl:

; 227  :         case GLFW_KEY_SCROLL_LOCK: return ImGuiKey_ScrollLock;

	mov	eax, 596				; 00000254H

; 306  :     }
; 307  : }

	ret	0
$LN32@ImGui_Impl:

; 228  :         case GLFW_KEY_NUM_LOCK: return ImGuiKey_NumLock;

	mov	eax, 597				; 00000255H

; 306  :     }
; 307  : }

	ret	0
$LN33@ImGui_Impl:

; 229  :         case GLFW_KEY_PRINT_SCREEN: return ImGuiKey_PrintScreen;

	mov	eax, 598				; 00000256H

; 306  :     }
; 307  : }

	ret	0
$LN34@ImGui_Impl:

; 230  :         case GLFW_KEY_PAUSE: return ImGuiKey_Pause;

	mov	eax, 599				; 00000257H

; 306  :     }
; 307  : }

	ret	0
$LN35@ImGui_Impl:

; 231  :         case GLFW_KEY_KP_0: return ImGuiKey_Keypad0;

	mov	eax, 600				; 00000258H

; 306  :     }
; 307  : }

	ret	0
$LN36@ImGui_Impl:

; 232  :         case GLFW_KEY_KP_1: return ImGuiKey_Keypad1;

	mov	eax, 601				; 00000259H

; 306  :     }
; 307  : }

	ret	0
$LN37@ImGui_Impl:

; 233  :         case GLFW_KEY_KP_2: return ImGuiKey_Keypad2;

	mov	eax, 602				; 0000025aH

; 306  :     }
; 307  : }

	ret	0
$LN38@ImGui_Impl:

; 234  :         case GLFW_KEY_KP_3: return ImGuiKey_Keypad3;

	mov	eax, 603				; 0000025bH

; 306  :     }
; 307  : }

	ret	0
$LN39@ImGui_Impl:

; 235  :         case GLFW_KEY_KP_4: return ImGuiKey_Keypad4;

	mov	eax, 604				; 0000025cH

; 306  :     }
; 307  : }

	ret	0
$LN40@ImGui_Impl:

; 236  :         case GLFW_KEY_KP_5: return ImGuiKey_Keypad5;

	mov	eax, 605				; 0000025dH

; 306  :     }
; 307  : }

	ret	0
$LN41@ImGui_Impl:

; 237  :         case GLFW_KEY_KP_6: return ImGuiKey_Keypad6;

	mov	eax, 606				; 0000025eH

; 306  :     }
; 307  : }

	ret	0
$LN42@ImGui_Impl:

; 238  :         case GLFW_KEY_KP_7: return ImGuiKey_Keypad7;

	mov	eax, 607				; 0000025fH

; 306  :     }
; 307  : }

	ret	0
$LN43@ImGui_Impl:

; 239  :         case GLFW_KEY_KP_8: return ImGuiKey_Keypad8;

	mov	eax, 608				; 00000260H

; 306  :     }
; 307  : }

	ret	0
$LN44@ImGui_Impl:

; 240  :         case GLFW_KEY_KP_9: return ImGuiKey_Keypad9;

	mov	eax, 609				; 00000261H

; 306  :     }
; 307  : }

	ret	0
$LN45@ImGui_Impl:

; 241  :         case GLFW_KEY_KP_DECIMAL: return ImGuiKey_KeypadDecimal;

	mov	eax, 610				; 00000262H

; 306  :     }
; 307  : }

	ret	0
$LN46@ImGui_Impl:

; 242  :         case GLFW_KEY_KP_DIVIDE: return ImGuiKey_KeypadDivide;

	mov	eax, 611				; 00000263H

; 306  :     }
; 307  : }

	ret	0
$LN47@ImGui_Impl:

; 243  :         case GLFW_KEY_KP_MULTIPLY: return ImGuiKey_KeypadMultiply;

	mov	eax, 612				; 00000264H

; 306  :     }
; 307  : }

	ret	0
$LN48@ImGui_Impl:

; 244  :         case GLFW_KEY_KP_SUBTRACT: return ImGuiKey_KeypadSubtract;

	mov	eax, 613				; 00000265H

; 306  :     }
; 307  : }

	ret	0
$LN49@ImGui_Impl:

; 245  :         case GLFW_KEY_KP_ADD: return ImGuiKey_KeypadAdd;

	mov	eax, 614				; 00000266H

; 306  :     }
; 307  : }

	ret	0
$LN50@ImGui_Impl:

; 246  :         case GLFW_KEY_KP_ENTER: return ImGuiKey_KeypadEnter;

	mov	eax, 615				; 00000267H

; 306  :     }
; 307  : }

	ret	0
$LN51@ImGui_Impl:

; 247  :         case GLFW_KEY_KP_EQUAL: return ImGuiKey_KeypadEqual;

	mov	eax, 616				; 00000268H

; 306  :     }
; 307  : }

	ret	0
$LN52@ImGui_Impl:

; 248  :         case GLFW_KEY_LEFT_SHIFT: return ImGuiKey_LeftShift;

	mov	eax, 528				; 00000210H

; 306  :     }
; 307  : }

	ret	0
$LN53@ImGui_Impl:

; 249  :         case GLFW_KEY_LEFT_CONTROL: return ImGuiKey_LeftCtrl;

	mov	eax, 527				; 0000020fH

; 306  :     }
; 307  : }

	ret	0
$LN54@ImGui_Impl:

; 250  :         case GLFW_KEY_LEFT_ALT: return ImGuiKey_LeftAlt;

	mov	eax, 529				; 00000211H

; 306  :     }
; 307  : }

	ret	0
$LN55@ImGui_Impl:

; 251  :         case GLFW_KEY_LEFT_SUPER: return ImGuiKey_LeftSuper;

	mov	eax, 530				; 00000212H

; 306  :     }
; 307  : }

	ret	0
$LN56@ImGui_Impl:

; 252  :         case GLFW_KEY_RIGHT_SHIFT: return ImGuiKey_RightShift;

	mov	eax, 532				; 00000214H

; 306  :     }
; 307  : }

	ret	0
$LN57@ImGui_Impl:

; 253  :         case GLFW_KEY_RIGHT_CONTROL: return ImGuiKey_RightCtrl;

	mov	eax, 531				; 00000213H

; 306  :     }
; 307  : }

	ret	0
$LN58@ImGui_Impl:

; 254  :         case GLFW_KEY_RIGHT_ALT: return ImGuiKey_RightAlt;

	mov	eax, 533				; 00000215H

; 306  :     }
; 307  : }

	ret	0
$LN59@ImGui_Impl:

; 255  :         case GLFW_KEY_RIGHT_SUPER: return ImGuiKey_RightSuper;

	mov	eax, 534				; 00000216H

; 306  :     }
; 307  : }

	ret	0
$LN60@ImGui_Impl:

; 256  :         case GLFW_KEY_MENU: return ImGuiKey_Menu;

	mov	eax, 535				; 00000217H

; 306  :     }
; 307  : }

	ret	0
$LN61@ImGui_Impl:

; 257  :         case GLFW_KEY_0: return ImGuiKey_0;

	mov	eax, 536				; 00000218H

; 306  :     }
; 307  : }

	ret	0
$LN62@ImGui_Impl:

; 258  :         case GLFW_KEY_1: return ImGuiKey_1;

	mov	eax, 537				; 00000219H

; 306  :     }
; 307  : }

	ret	0
$LN63@ImGui_Impl:

; 259  :         case GLFW_KEY_2: return ImGuiKey_2;

	mov	eax, 538				; 0000021aH

; 306  :     }
; 307  : }

	ret	0
$LN64@ImGui_Impl:

; 260  :         case GLFW_KEY_3: return ImGuiKey_3;

	mov	eax, 539				; 0000021bH

; 306  :     }
; 307  : }

	ret	0
$LN65@ImGui_Impl:

; 261  :         case GLFW_KEY_4: return ImGuiKey_4;

	mov	eax, 540				; 0000021cH

; 306  :     }
; 307  : }

	ret	0
$LN66@ImGui_Impl:

; 262  :         case GLFW_KEY_5: return ImGuiKey_5;

	mov	eax, 541				; 0000021dH

; 306  :     }
; 307  : }

	ret	0
$LN67@ImGui_Impl:

; 263  :         case GLFW_KEY_6: return ImGuiKey_6;

	mov	eax, 542				; 0000021eH

; 306  :     }
; 307  : }

	ret	0
$LN68@ImGui_Impl:

; 264  :         case GLFW_KEY_7: return ImGuiKey_7;

	mov	eax, 543				; 0000021fH

; 306  :     }
; 307  : }

	ret	0
$LN69@ImGui_Impl:

; 265  :         case GLFW_KEY_8: return ImGuiKey_8;

	mov	eax, 544				; 00000220H

; 306  :     }
; 307  : }

	ret	0
$LN70@ImGui_Impl:

; 266  :         case GLFW_KEY_9: return ImGuiKey_9;

	mov	eax, 545				; 00000221H

; 306  :     }
; 307  : }

	ret	0
$LN71@ImGui_Impl:

; 267  :         case GLFW_KEY_A: return ImGuiKey_A;

	mov	eax, 546				; 00000222H

; 306  :     }
; 307  : }

	ret	0
$LN72@ImGui_Impl:

; 268  :         case GLFW_KEY_B: return ImGuiKey_B;

	mov	eax, 547				; 00000223H

; 306  :     }
; 307  : }

	ret	0
$LN73@ImGui_Impl:

; 269  :         case GLFW_KEY_C: return ImGuiKey_C;

	mov	eax, 548				; 00000224H

; 306  :     }
; 307  : }

	ret	0
$LN74@ImGui_Impl:

; 270  :         case GLFW_KEY_D: return ImGuiKey_D;

	mov	eax, 549				; 00000225H

; 306  :     }
; 307  : }

	ret	0
$LN75@ImGui_Impl:

; 271  :         case GLFW_KEY_E: return ImGuiKey_E;

	mov	eax, 550				; 00000226H

; 306  :     }
; 307  : }

	ret	0
$LN76@ImGui_Impl:

; 272  :         case GLFW_KEY_F: return ImGuiKey_F;

	mov	eax, 551				; 00000227H

; 306  :     }
; 307  : }

	ret	0
$LN77@ImGui_Impl:

; 273  :         case GLFW_KEY_G: return ImGuiKey_G;

	mov	eax, 552				; 00000228H

; 306  :     }
; 307  : }

	ret	0
$LN78@ImGui_Impl:

; 274  :         case GLFW_KEY_H: return ImGuiKey_H;

	mov	eax, 553				; 00000229H

; 306  :     }
; 307  : }

	ret	0
$LN79@ImGui_Impl:

; 275  :         case GLFW_KEY_I: return ImGuiKey_I;

	mov	eax, 554				; 0000022aH

; 306  :     }
; 307  : }

	ret	0
$LN80@ImGui_Impl:

; 276  :         case GLFW_KEY_J: return ImGuiKey_J;

	mov	eax, 555				; 0000022bH

; 306  :     }
; 307  : }

	ret	0
$LN81@ImGui_Impl:

; 277  :         case GLFW_KEY_K: return ImGuiKey_K;

	mov	eax, 556				; 0000022cH

; 306  :     }
; 307  : }

	ret	0
$LN82@ImGui_Impl:

; 278  :         case GLFW_KEY_L: return ImGuiKey_L;

	mov	eax, 557				; 0000022dH

; 306  :     }
; 307  : }

	ret	0
$LN83@ImGui_Impl:

; 279  :         case GLFW_KEY_M: return ImGuiKey_M;

	mov	eax, 558				; 0000022eH

; 306  :     }
; 307  : }

	ret	0
$LN84@ImGui_Impl:

; 280  :         case GLFW_KEY_N: return ImGuiKey_N;

	mov	eax, 559				; 0000022fH

; 306  :     }
; 307  : }

	ret	0
$LN85@ImGui_Impl:

; 281  :         case GLFW_KEY_O: return ImGuiKey_O;

	mov	eax, 560				; 00000230H

; 306  :     }
; 307  : }

	ret	0
$LN86@ImGui_Impl:

; 282  :         case GLFW_KEY_P: return ImGuiKey_P;

	mov	eax, 561				; 00000231H

; 306  :     }
; 307  : }

	ret	0
$LN87@ImGui_Impl:

; 283  :         case GLFW_KEY_Q: return ImGuiKey_Q;

	mov	eax, 562				; 00000232H

; 306  :     }
; 307  : }

	ret	0
$LN88@ImGui_Impl:

; 284  :         case GLFW_KEY_R: return ImGuiKey_R;

	mov	eax, 563				; 00000233H

; 306  :     }
; 307  : }

	ret	0
$LN89@ImGui_Impl:

; 285  :         case GLFW_KEY_S: return ImGuiKey_S;

	mov	eax, 564				; 00000234H

; 306  :     }
; 307  : }

	ret	0
$LN90@ImGui_Impl:

; 286  :         case GLFW_KEY_T: return ImGuiKey_T;

	mov	eax, 565				; 00000235H

; 306  :     }
; 307  : }

	ret	0
$LN91@ImGui_Impl:

; 287  :         case GLFW_KEY_U: return ImGuiKey_U;

	mov	eax, 566				; 00000236H

; 306  :     }
; 307  : }

	ret	0
$LN92@ImGui_Impl:

; 288  :         case GLFW_KEY_V: return ImGuiKey_V;

	mov	eax, 567				; 00000237H

; 306  :     }
; 307  : }

	ret	0
$LN93@ImGui_Impl:

; 289  :         case GLFW_KEY_W: return ImGuiKey_W;

	mov	eax, 568				; 00000238H

; 306  :     }
; 307  : }

	ret	0
$LN94@ImGui_Impl:

; 290  :         case GLFW_KEY_X: return ImGuiKey_X;

	mov	eax, 569				; 00000239H

; 306  :     }
; 307  : }

	ret	0
$LN95@ImGui_Impl:

; 291  :         case GLFW_KEY_Y: return ImGuiKey_Y;

	mov	eax, 570				; 0000023aH

; 306  :     }
; 307  : }

	ret	0
$LN96@ImGui_Impl:

; 292  :         case GLFW_KEY_Z: return ImGuiKey_Z;

	mov	eax, 571				; 0000023bH

; 306  :     }
; 307  : }

	ret	0
$LN97@ImGui_Impl:

; 293  :         case GLFW_KEY_F1: return ImGuiKey_F1;

	mov	eax, 572				; 0000023cH

; 306  :     }
; 307  : }

	ret	0
$LN98@ImGui_Impl:

; 294  :         case GLFW_KEY_F2: return ImGuiKey_F2;

	mov	eax, 573				; 0000023dH

; 306  :     }
; 307  : }

	ret	0
$LN99@ImGui_Impl:

; 295  :         case GLFW_KEY_F3: return ImGuiKey_F3;

	mov	eax, 574				; 0000023eH

; 306  :     }
; 307  : }

	ret	0
$LN100@ImGui_Impl:

; 296  :         case GLFW_KEY_F4: return ImGuiKey_F4;

	mov	eax, 575				; 0000023fH

; 306  :     }
; 307  : }

	ret	0
$LN101@ImGui_Impl:

; 297  :         case GLFW_KEY_F5: return ImGuiKey_F5;

	mov	eax, 576				; 00000240H

; 306  :     }
; 307  : }

	ret	0
$LN102@ImGui_Impl:

; 298  :         case GLFW_KEY_F6: return ImGuiKey_F6;

	mov	eax, 577				; 00000241H

; 306  :     }
; 307  : }

	ret	0
$LN103@ImGui_Impl:

; 299  :         case GLFW_KEY_F7: return ImGuiKey_F7;

	mov	eax, 578				; 00000242H

; 306  :     }
; 307  : }

	ret	0
$LN104@ImGui_Impl:

; 300  :         case GLFW_KEY_F8: return ImGuiKey_F8;

	mov	eax, 579				; 00000243H

; 306  :     }
; 307  : }

	ret	0
$LN105@ImGui_Impl:

; 301  :         case GLFW_KEY_F9: return ImGuiKey_F9;

	mov	eax, 580				; 00000244H

; 306  :     }
; 307  : }

	ret	0
$LN106@ImGui_Impl:

; 302  :         case GLFW_KEY_F10: return ImGuiKey_F10;

	mov	eax, 581				; 00000245H

; 306  :     }
; 307  : }

	ret	0
$LN107@ImGui_Impl:

; 303  :         case GLFW_KEY_F11: return ImGuiKey_F11;

	mov	eax, 582				; 00000246H

; 306  :     }
; 307  : }

	ret	0
$LN108@ImGui_Impl:

; 304  :         case GLFW_KEY_F12: return ImGuiKey_F12;

	mov	eax, 583				; 00000247H

; 306  :     }
; 307  : }

	ret	0
$LN109@ImGui_Impl:

; 305  :         default: return ImGuiKey_None;

	xor	eax, eax

; 306  :     }
; 307  : }

	ret	0
	npad	2
$LN112@ImGui_Impl:
	DD	$LN16@ImGui_Impl
	DD	$LN19@ImGui_Impl
	DD	$LN20@ImGui_Impl
	DD	$LN21@ImGui_Impl
	DD	$LN22@ImGui_Impl
	DD	$LN23@ImGui_Impl
	DD	$LN61@ImGui_Impl
	DD	$LN62@ImGui_Impl
	DD	$LN63@ImGui_Impl
	DD	$LN64@ImGui_Impl
	DD	$LN65@ImGui_Impl
	DD	$LN66@ImGui_Impl
	DD	$LN67@ImGui_Impl
	DD	$LN68@ImGui_Impl
	DD	$LN69@ImGui_Impl
	DD	$LN70@ImGui_Impl
	DD	$LN24@ImGui_Impl
	DD	$LN25@ImGui_Impl
	DD	$LN71@ImGui_Impl
	DD	$LN72@ImGui_Impl
	DD	$LN73@ImGui_Impl
	DD	$LN74@ImGui_Impl
	DD	$LN75@ImGui_Impl
	DD	$LN76@ImGui_Impl
	DD	$LN77@ImGui_Impl
	DD	$LN78@ImGui_Impl
	DD	$LN79@ImGui_Impl
	DD	$LN80@ImGui_Impl
	DD	$LN81@ImGui_Impl
	DD	$LN82@ImGui_Impl
	DD	$LN83@ImGui_Impl
	DD	$LN84@ImGui_Impl
	DD	$LN85@ImGui_Impl
	DD	$LN86@ImGui_Impl
	DD	$LN87@ImGui_Impl
	DD	$LN88@ImGui_Impl
	DD	$LN89@ImGui_Impl
	DD	$LN90@ImGui_Impl
	DD	$LN91@ImGui_Impl
	DD	$LN92@ImGui_Impl
	DD	$LN93@ImGui_Impl
	DD	$LN94@ImGui_Impl
	DD	$LN95@ImGui_Impl
	DD	$LN96@ImGui_Impl
	DD	$LN26@ImGui_Impl
	DD	$LN27@ImGui_Impl
	DD	$LN28@ImGui_Impl
	DD	$LN29@ImGui_Impl
	DD	$LN18@ImGui_Impl
	DD	$LN17@ImGui_Impl
	DD	$LN4@ImGui_Impl
	DD	$LN15@ImGui_Impl
	DD	$LN13@ImGui_Impl
	DD	$LN14@ImGui_Impl
	DD	$LN6@ImGui_Impl
	DD	$LN5@ImGui_Impl
	DD	$LN8@ImGui_Impl
	DD	$LN7@ImGui_Impl
	DD	$LN9@ImGui_Impl
	DD	$LN10@ImGui_Impl
	DD	$LN11@ImGui_Impl
	DD	$LN12@ImGui_Impl
	DD	$LN30@ImGui_Impl
	DD	$LN31@ImGui_Impl
	DD	$LN32@ImGui_Impl
	DD	$LN33@ImGui_Impl
	DD	$LN34@ImGui_Impl
	DD	$LN97@ImGui_Impl
	DD	$LN98@ImGui_Impl
	DD	$LN99@ImGui_Impl
	DD	$LN100@ImGui_Impl
	DD	$LN101@ImGui_Impl
	DD	$LN102@ImGui_Impl
	DD	$LN103@ImGui_Impl
	DD	$LN104@ImGui_Impl
	DD	$LN105@ImGui_Impl
	DD	$LN106@ImGui_Impl
	DD	$LN107@ImGui_Impl
	DD	$LN108@ImGui_Impl
	DD	$LN35@ImGui_Impl
	DD	$LN36@ImGui_Impl
	DD	$LN37@ImGui_Impl
	DD	$LN38@ImGui_Impl
	DD	$LN39@ImGui_Impl
	DD	$LN40@ImGui_Impl
	DD	$LN41@ImGui_Impl
	DD	$LN42@ImGui_Impl
	DD	$LN43@ImGui_Impl
	DD	$LN44@ImGui_Impl
	DD	$LN45@ImGui_Impl
	DD	$LN46@ImGui_Impl
	DD	$LN47@ImGui_Impl
	DD	$LN48@ImGui_Impl
	DD	$LN49@ImGui_Impl
	DD	$LN50@ImGui_Impl
	DD	$LN51@ImGui_Impl
	DD	$LN52@ImGui_Impl
	DD	$LN53@ImGui_Impl
	DD	$LN54@ImGui_Impl
	DD	$LN55@ImGui_Impl
	DD	$LN56@ImGui_Impl
	DD	$LN57@ImGui_Impl
	DD	$LN58@ImGui_Impl
	DD	$LN59@ImGui_Impl
	DD	$LN60@ImGui_Impl
	DD	$LN109@ImGui_Impl
$LN111@ImGui_Impl:
	DB	0
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	1
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	2
	DB	3
	DB	4
	DB	5
	DB	6
	DB	7
	DB	8
	DB	9
	DB	10
	DB	11
	DB	12
	DB	13
	DB	14
	DB	15
	DB	105					; 00000069H
	DB	16
	DB	105					; 00000069H
	DB	17
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	18
	DB	19
	DB	20
	DB	21
	DB	22
	DB	23
	DB	24
	DB	25
	DB	26
	DB	27
	DB	28
	DB	29
	DB	30
	DB	31
	DB	32					; 00000020H
	DB	33					; 00000021H
	DB	34					; 00000022H
	DB	35					; 00000023H
	DB	36					; 00000024H
	DB	37					; 00000025H
	DB	38					; 00000026H
	DB	39					; 00000027H
	DB	40					; 00000028H
	DB	41					; 00000029H
	DB	42					; 0000002aH
	DB	43					; 0000002bH
	DB	44					; 0000002cH
	DB	45					; 0000002dH
	DB	46					; 0000002eH
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	47					; 0000002fH
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	48					; 00000030H
	DB	49					; 00000031H
	DB	50					; 00000032H
	DB	51					; 00000033H
	DB	52					; 00000034H
	DB	53					; 00000035H
	DB	54					; 00000036H
	DB	55					; 00000037H
	DB	56					; 00000038H
	DB	57					; 00000039H
	DB	58					; 0000003aH
	DB	59					; 0000003bH
	DB	60					; 0000003cH
	DB	61					; 0000003dH
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	62					; 0000003eH
	DB	63					; 0000003fH
	DB	64					; 00000040H
	DB	65					; 00000041H
	DB	66					; 00000042H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	67					; 00000043H
	DB	68					; 00000044H
	DB	69					; 00000045H
	DB	70					; 00000046H
	DB	71					; 00000047H
	DB	72					; 00000048H
	DB	73					; 00000049H
	DB	74					; 0000004aH
	DB	75					; 0000004bH
	DB	76					; 0000004cH
	DB	77					; 0000004dH
	DB	78					; 0000004eH
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	79					; 0000004fH
	DB	80					; 00000050H
	DB	81					; 00000051H
	DB	82					; 00000052H
	DB	83					; 00000053H
	DB	84					; 00000054H
	DB	85					; 00000055H
	DB	86					; 00000056H
	DB	87					; 00000057H
	DB	88					; 00000058H
	DB	89					; 00000059H
	DB	90					; 0000005aH
	DB	91					; 0000005bH
	DB	92					; 0000005cH
	DB	93					; 0000005dH
	DB	94					; 0000005eH
	DB	95					; 0000005fH
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	105					; 00000069H
	DB	96					; 00000060H
	DB	97					; 00000061H
	DB	98					; 00000062H
	DB	99					; 00000063H
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	102					; 00000066H
	DB	103					; 00000067H
	DB	104					; 00000068H
?ImGui_ImplGlfw_KeyToImGuiKey@@YA?AW4ImGuiKey@@H@Z ENDP	; ImGui_ImplGlfw_KeyToImGuiKey
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?ImGui_ImplGlfw_UpdateKeyModifiers@@YAXPEAUGLFWwindow@@@Z
_TEXT	SEGMENT
window$ = 64
?ImGui_ImplGlfw_UpdateKeyModifiers@@YAXPEAUGLFWwindow@@@Z PROC ; ImGui_ImplGlfw_UpdateKeyModifiers, COMDAT

; 312  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 48					; 00000030H

; 313  :     ImGuiIO& io = ImGui::GetIO();

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 314  :     io.AddKeyEvent(ImGuiMod_Ctrl,  (glfwGetKey(window, GLFW_KEY_LEFT_CONTROL) == GLFW_PRESS) || (glfwGetKey(window, GLFW_KEY_RIGHT_CONTROL) == GLFW_PRESS));

	mov	edx, 341				; 00000155H
	add	rbx, 8
	movaps	XMMWORD PTR [rsp+32], xmm6
	mov	rdi, rcx
	call	glfwGetKey
	cmp	eax, 1
	je	SHORT $LN3@ImGui_Impl
	mov	edx, 345				; 00000159H
	mov	rcx, rdi
	call	glfwGetKey
	cmp	eax, 1
	je	SHORT $LN3@ImGui_Impl
	xor	r8b, r8b
	jmp	SHORT $LN4@ImGui_Impl
$LN3@ImGui_Impl:
	mov	r8b, 1
$LN4@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1513 :     if (!AppAcceptingEvents)

	cmp	BYTE PTR [rbx+14305], 0
	movss	xmm6, DWORD PTR __real@3f800000
	je	SHORT $LN11@ImGui_Impl

; 1514 :         return;
; 1515 :     AddKeyAnalogEvent(key, down, down ? 1.0f : 0.0f);

	test	r8b, r8b
	je	SHORT $LN14@ImGui_Impl
	movaps	xmm3, xmm6
	jmp	SHORT $LN15@ImGui_Impl
$LN14@ImGui_Impl:
	xorps	xmm3, xmm3
$LN15@ImGui_Impl:
	mov	edx, 4096				; 00001000H
	mov	rcx, rbx
	call	?AddKeyAnalogEvent@ImGuiIO@@QEAAXW4ImGuiKey@@_NM@Z ; ImGuiIO::AddKeyAnalogEvent
$LN11@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 315  :     io.AddKeyEvent(ImGuiMod_Shift, (glfwGetKey(window, GLFW_KEY_LEFT_SHIFT)   == GLFW_PRESS) || (glfwGetKey(window, GLFW_KEY_RIGHT_SHIFT)   == GLFW_PRESS));

	mov	edx, 340				; 00000154H
	mov	rcx, rdi
	call	glfwGetKey
	cmp	eax, 1
	je	SHORT $LN5@ImGui_Impl
	mov	edx, 344				; 00000158H
	mov	rcx, rdi
	call	glfwGetKey
	cmp	eax, 1
	je	SHORT $LN5@ImGui_Impl
	xor	r8b, r8b
	jmp	SHORT $LN6@ImGui_Impl
$LN5@ImGui_Impl:
	mov	r8b, 1
$LN6@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1513 :     if (!AppAcceptingEvents)

	cmp	BYTE PTR [rbx+14305], 0
	je	SHORT $LN16@ImGui_Impl

; 1514 :         return;
; 1515 :     AddKeyAnalogEvent(key, down, down ? 1.0f : 0.0f);

	test	r8b, r8b
	je	SHORT $LN19@ImGui_Impl
	movaps	xmm3, xmm6
	jmp	SHORT $LN20@ImGui_Impl
$LN19@ImGui_Impl:
	xorps	xmm3, xmm3
$LN20@ImGui_Impl:
	mov	edx, 8192				; 00002000H
	mov	rcx, rbx
	call	?AddKeyAnalogEvent@ImGuiIO@@QEAAXW4ImGuiKey@@_NM@Z ; ImGuiIO::AddKeyAnalogEvent
$LN16@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 316  :     io.AddKeyEvent(ImGuiMod_Alt,   (glfwGetKey(window, GLFW_KEY_LEFT_ALT)     == GLFW_PRESS) || (glfwGetKey(window, GLFW_KEY_RIGHT_ALT)     == GLFW_PRESS));

	mov	edx, 342				; 00000156H
	mov	rcx, rdi
	call	glfwGetKey
	cmp	eax, 1
	je	SHORT $LN7@ImGui_Impl
	mov	edx, 346				; 0000015aH
	mov	rcx, rdi
	call	glfwGetKey
	cmp	eax, 1
	je	SHORT $LN7@ImGui_Impl
	xor	r8b, r8b
	jmp	SHORT $LN8@ImGui_Impl
$LN7@ImGui_Impl:
	mov	r8b, 1
$LN8@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1513 :     if (!AppAcceptingEvents)

	cmp	BYTE PTR [rbx+14305], 0
	je	SHORT $LN21@ImGui_Impl

; 1514 :         return;
; 1515 :     AddKeyAnalogEvent(key, down, down ? 1.0f : 0.0f);

	test	r8b, r8b
	je	SHORT $LN24@ImGui_Impl
	movaps	xmm3, xmm6
	jmp	SHORT $LN25@ImGui_Impl
$LN24@ImGui_Impl:
	xorps	xmm3, xmm3
$LN25@ImGui_Impl:
	mov	edx, 16384				; 00004000H
	mov	rcx, rbx
	call	?AddKeyAnalogEvent@ImGuiIO@@QEAAXW4ImGuiKey@@_NM@Z ; ImGuiIO::AddKeyAnalogEvent
$LN21@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 317  :     io.AddKeyEvent(ImGuiMod_Super, (glfwGetKey(window, GLFW_KEY_LEFT_SUPER)   == GLFW_PRESS) || (glfwGetKey(window, GLFW_KEY_RIGHT_SUPER)   == GLFW_PRESS));

	mov	edx, 343				; 00000157H
	mov	rcx, rdi
	call	glfwGetKey
	cmp	eax, 1
	je	SHORT $LN9@ImGui_Impl
	mov	edx, 347				; 0000015bH
	mov	rcx, rdi
	call	glfwGetKey
	cmp	eax, 1
	je	SHORT $LN9@ImGui_Impl
	xor	r8b, r8b
	jmp	SHORT $LN10@ImGui_Impl
$LN9@ImGui_Impl:
	mov	r8b, 1
$LN10@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1513 :     if (!AppAcceptingEvents)

	cmp	BYTE PTR [rbx+14305], 0
	je	SHORT $LN26@ImGui_Impl

; 1514 :         return;
; 1515 :     AddKeyAnalogEvent(key, down, down ? 1.0f : 0.0f);

	test	r8b, r8b
	jne	SHORT $LN30@ImGui_Impl
	xorps	xmm6, xmm6
$LN30@ImGui_Impl:
	movaps	xmm3, xmm6
	mov	edx, 32768				; 00008000H
	mov	rcx, rbx
	call	?AddKeyAnalogEvent@ImGuiIO@@QEAAXW4ImGuiKey@@_NM@Z ; ImGuiIO::AddKeyAnalogEvent
$LN26@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 318  : }

	mov	rbx, QWORD PTR [rsp+64]
	movaps	xmm6, XMMWORD PTR [rsp+32]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?ImGui_ImplGlfw_UpdateKeyModifiers@@YAXPEAUGLFWwindow@@@Z ENDP ; ImGui_ImplGlfw_UpdateKeyModifiers
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?ImGui_ImplGlfw_ShouldChainCallback@@YA_NPEAUGLFWwindow@@@Z
_TEXT	SEGMENT
window$ = 8
?ImGui_ImplGlfw_ShouldChainCallback@@YA_NPEAUGLFWwindow@@@Z PROC ; ImGui_ImplGlfw_ShouldChainCallback, COMDAT

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	xor	edx, edx
	test	rax, rax
	je	SHORT $LN7@ImGui_Impl
	mov	rax, QWORD PTR [rax+152]
	jmp	SHORT $LN8@ImGui_Impl
$LN7@ImGui_Impl:
	mov	rax, rdx
$LN8@ImGui_Impl:

; 322  :     ImGui_ImplGlfw_Data* bd = ImGui_ImplGlfw_GetBackendData();
; 323  :     return bd->CallbacksChainForAllWindows ? true : (window == bd->Window);

	cmp	BYTE PTR [rax+2897], dl
	je	SHORT $LN3@ImGui_Impl
	mov	eax, 1

; 324  : }

	ret	0
$LN3@ImGui_Impl:

; 322  :     ImGui_ImplGlfw_Data* bd = ImGui_ImplGlfw_GetBackendData();
; 323  :     return bd->CallbacksChainForAllWindows ? true : (window == bd->Window);

	cmp	rcx, QWORD PTR [rax]
	sete	al

; 324  : }

	ret	0
?ImGui_ImplGlfw_ShouldChainCallback@@YA_NPEAUGLFWwindow@@@Z ENDP ; ImGui_ImplGlfw_ShouldChainCallback
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?ImGui_ImplGlfw_MouseButtonCallback@@YAXPEAUGLFWwindow@@HHH@Z
_TEXT	SEGMENT
e$1 = 32
window$ = 80
button$ = 88
action$ = 96
mods$ = 104
?ImGui_ImplGlfw_MouseButtonCallback@@YAXPEAUGLFWwindow@@HHH@Z PROC ; ImGui_ImplGlfw_MouseButtonCallback, COMDAT

; 327  : {

$LN60:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 64					; 00000040H

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	xor	ebp, ebp

; 327  : {

	movsxd	rdi, edx
	mov	esi, r8d
	mov	rbx, rcx

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	test	rax, rax
	je	SHORT $LN7@ImGui_Impl
	mov	rdx, QWORD PTR [rax+152]
	jmp	SHORT $LN8@ImGui_Impl
$LN7@ImGui_Impl:
	mov	rdx, rbp
$LN8@ImGui_Impl:

; 328  :     ImGui_ImplGlfw_Data* bd = ImGui_ImplGlfw_GetBackendData();
; 329  :     if (bd->PrevUserCallbackMousebutton != nullptr && ImGui_ImplGlfw_ShouldChainCallback(window))

	mov	r10, QWORD PTR [rdx+2928]
	test	r10, r10
	je	SHORT $LN2@ImGui_Impl

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	test	rax, rax
	je	SHORT $LN15@ImGui_Impl
	mov	rcx, QWORD PTR [rax+152]
	jmp	SHORT $LN16@ImGui_Impl
$LN15@ImGui_Impl:
	mov	rcx, rbp
$LN16@ImGui_Impl:

; 323  :     return bd->CallbacksChainForAllWindows ? true : (window == bd->Window);

	cmp	BYTE PTR [rcx+2897], bpl
	je	SHORT $LN11@ImGui_Impl
	mov	eax, 1
	jmp	SHORT $LN12@ImGui_Impl
$LN11@ImGui_Impl:
	cmp	rbx, QWORD PTR [rcx]
	sete	al
$LN12@ImGui_Impl:

; 328  :     ImGui_ImplGlfw_Data* bd = ImGui_ImplGlfw_GetBackendData();
; 329  :     if (bd->PrevUserCallbackMousebutton != nullptr && ImGui_ImplGlfw_ShouldChainCallback(window))

	test	al, al
	je	SHORT $LN2@ImGui_Impl

; 330  :         bd->PrevUserCallbackMousebutton(window, button, action, mods);

	mov	edx, edi
	mov	rcx, rbx
	call	r10
$LN2@ImGui_Impl:

; 331  : 
; 332  :     ImGui_ImplGlfw_UpdateKeyModifiers(window);

	mov	rcx, rbx
	call	?ImGui_ImplGlfw_UpdateKeyModifiers@@YAXPEAUGLFWwindow@@@Z ; ImGui_ImplGlfw_UpdateKeyModifiers

; 333  : 
; 334  :     ImGuiIO& io = ImGui::GetIO();

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 335  :     if (button >= 0 && button < ImGuiMouseButton_COUNT)

	cmp	edi, 4
	ja	$LN17@ImGui_Impl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1579 :     ImGuiContext& g = *Ctx;

	mov	rdx, QWORD PTR [rax+3584]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 336  :         io.AddMouseButtonEvent(button, action == GLFW_PRESS);

	cmp	esi, 1
	sete	r8b
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1581 :     if (!AppAcceptingEvents)

	cmp	BYTE PTR [rax+14313], bpl
	je	$LN17@ImGui_Impl

; 1450 :     for (int n = g.InputEventsQueue.Size - 1; n >= 0; n--)

	lea	rbx, QWORD PTR [rdx+16272]
	mov	r9d, DWORD PTR [rbx]
	lea	eax, DWORD PTR [r9-1]
	test	eax, eax
	js	SHORT $LN46@ImGui_Impl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rcx, eax
	imul	rax, rcx, 28
	add	rax, QWORD PTR [rdx+16280]
	npad	7
$LL26@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1453 :         if (e->Type != type)

	cmp	DWORD PTR [rax], 3
	jne	SHORT $LN24@ImGui_Impl

; 1454 :             continue;
; 1455 :         if (type == ImGuiInputEventType_Key && e->Key.Key != arg)
; 1456 :             continue;
; 1457 :         if (type == ImGuiInputEventType_MouseButton && e->MouseButton.Button != arg)

	cmp	DWORD PTR [rax+12], edi
	je	SHORT $LN23@ImGui_Impl
$LN24@ImGui_Impl:

; 1450 :     for (int n = g.InputEventsQueue.Size - 1; n >= 0; n--)

	sub	rax, 28
	sub	rcx, 1
	jns	SHORT $LL26@ImGui_Impl
$LN46@ImGui_Impl:

; 1586 :     const bool latest_button_down = latest_event ? latest_event->MouseButton.Down : g.IO.MouseDown[mouse_button];

	movzx	ecx, BYTE PTR [rdi+rdx+3600]
$LN22@ImGui_Impl:

; 1587 :     if (latest_button_down == down)

	cmp	cl, r8b
	je	$LN17@ImGui_Impl

; 1593 :     e.EventId = g.InputEventsNextEventId++;

	mov	eax, DWORD PTR [rdx+16308]
	mov	DWORD PTR e$1[rsp+8], eax
	inc	eax
	mov	DWORD PTR [rdx+16308], eax

; 1595 :     e.MouseButton.Down = down;
; 1596 :     e.MouseWheel.MouseSource = g.InputEventsNextMouseSource;

	mov	eax, DWORD PTR [rdx+16304]
	mov	BYTE PTR e$1[rsp+16], r8b
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	r8d, DWORD PTR [rbx+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1353 :     ImGuiInputEvent() { memset(this, 0, sizeof(*this)); }

	mov	WORD PTR e$1[rsp+17], bp
	mov	BYTE PTR e$1[rsp+19], bpl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1591 :     e.Type = ImGuiInputEventType_MouseButton;

	mov	DWORD PTR e$1[rsp], 3

; 1592 :     e.Source = ImGuiInputSource_Mouse;

	mov	DWORD PTR e$1[rsp+4], 1

; 1594 :     e.MouseButton.Button = mouse_button;

	mov	DWORD PTR e$1[rsp+12], edi

; 1595 :     e.MouseButton.Down = down;
; 1596 :     e.MouseWheel.MouseSource = g.InputEventsNextMouseSource;

	mov	DWORD PTR e$1[rsp+20], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	cmp	r9d, r8d
	jne	SHORT $LN36@ImGui_Impl
	lea	ecx, DWORD PTR [r9+1]

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	r8d, r8d
	je	SHORT $LN40@ImGui_Impl
	mov	eax, r8d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r8d
	jmp	SHORT $LN41@ImGui_Impl
$LN23@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1586 :     const bool latest_button_down = latest_event ? latest_event->MouseButton.Down : g.IO.MouseDown[mouse_button];

	movzx	ecx, BYTE PTR [rax+16]
	jmp	SHORT $LN22@ImGui_Impl
$LN40@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	eax, 8
$LN41@ImGui_Impl:
	cmp	eax, ecx
	cmovg	ecx, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, ecx
	mov	rcx, rbx
	call	?reserve@?$ImVector@UImGuiInputEvent@@@@QEAAXH@Z ; ImVector<ImGuiInputEvent>::reserve
$LN36@ImGui_Impl:
	movsxd	rax, DWORD PTR [rbx]
	movups	xmm0, XMMWORD PTR e$1[rsp]
	movsd	xmm1, QWORD PTR e$1[rsp+16]
	imul	rcx, rax, 28
	mov	rax, QWORD PTR [rbx+8]
	movups	XMMWORD PTR [rcx+rax], xmm0
	movsd	QWORD PTR [rcx+rax+16], xmm1
	mov	DWORD PTR [rcx+rax+24], ebp
	inc	DWORD PTR [rbx]
$LN17@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 337  : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?ImGui_ImplGlfw_MouseButtonCallback@@YAXPEAUGLFWwindow@@HHH@Z ENDP ; ImGui_ImplGlfw_MouseButtonCallback
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?ImGui_ImplGlfw_ScrollCallback@@YAXPEAUGLFWwindow@@NN@Z
_TEXT	SEGMENT
e$1 = 32
window$ = 112
xoffset$ = 120
yoffset$ = 128
?ImGui_ImplGlfw_ScrollCallback@@YAXPEAUGLFWwindow@@NN@Z PROC ; ImGui_ImplGlfw_ScrollCallback, COMDAT

; 340  : {

$LN42:
	push	rbx
	sub	rsp, 96					; 00000060H

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 340  : {

	mov	r9, rcx
	movaps	XMMWORD PTR [rsp+80], xmm6
	movaps	xmm6, xmm2
	movaps	XMMWORD PTR [rsp+64], xmm7
	movaps	xmm7, xmm1

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	test	rax, rax
	je	SHORT $LN6@ImGui_Impl
	mov	rdx, QWORD PTR [rax+152]
	jmp	SHORT $LN7@ImGui_Impl
$LN6@ImGui_Impl:
	xor	edx, edx
$LN7@ImGui_Impl:

; 341  :     ImGui_ImplGlfw_Data* bd = ImGui_ImplGlfw_GetBackendData();
; 342  :     if (bd->PrevUserCallbackScroll != nullptr && ImGui_ImplGlfw_ShouldChainCallback(window))

	mov	r8, QWORD PTR [rdx+2936]
	test	r8, r8
	je	SHORT $LN2@ImGui_Impl

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	test	rax, rax
	je	SHORT $LN14@ImGui_Impl
	mov	rcx, QWORD PTR [rax+152]
	jmp	SHORT $LN15@ImGui_Impl
$LN14@ImGui_Impl:
	xor	ecx, ecx
$LN15@ImGui_Impl:

; 323  :     return bd->CallbacksChainForAllWindows ? true : (window == bd->Window);

	cmp	BYTE PTR [rcx+2897], 0
	je	SHORT $LN10@ImGui_Impl
	mov	edx, 1
	jmp	SHORT $LN11@ImGui_Impl
$LN10@ImGui_Impl:
	cmp	r9, QWORD PTR [rcx]
	sete	dl
$LN11@ImGui_Impl:

; 341  :     ImGui_ImplGlfw_Data* bd = ImGui_ImplGlfw_GetBackendData();
; 342  :     if (bd->PrevUserCallbackScroll != nullptr && ImGui_ImplGlfw_ShouldChainCallback(window))

	test	dl, dl
	je	SHORT $LN2@ImGui_Impl

; 343  :         bd->PrevUserCallbackScroll(window, xoffset, yoffset);

	mov	rcx, r9
	call	r8
	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
$LN2@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1607 :     if (!AppAcceptingEvents || (wheel_x == 0.0f && wheel_y == 0.0f))

	cmp	BYTE PTR [rax+14313], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 351  :     io.AddMouseWheelEvent((float)xoffset, (float)yoffset);

	xorps	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1604 :     ImGuiContext& g = *Ctx;

	mov	rbx, QWORD PTR [rax+3584]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 351  :     io.AddMouseWheelEvent((float)xoffset, (float)yoffset);

	xorps	xmm2, xmm2
	cvtsd2ss xmm1, xmm6
	cvtsd2ss xmm2, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1607 :     if (!AppAcceptingEvents || (wheel_x == 0.0f && wheel_y == 0.0f))

	je	$LN18@ImGui_Impl
	xorps	xmm0, xmm0
	ucomiss	xmm2, xmm0
	jp	SHORT $LN29@ImGui_Impl
	jne	SHORT $LN29@ImGui_Impl
	ucomiss	xmm1, xmm0
	jp	SHORT $LN29@ImGui_Impl
	je	$LN18@ImGui_Impl
$LN29@ImGui_Impl:

; 1613 :     e.EventId = g.InputEventsNextEventId++;

	mov	eax, DWORD PTR [rbx+16308]
	mov	DWORD PTR e$1[rsp+8], eax
	inc	eax
	mov	DWORD PTR [rbx+16308], eax

; 1614 :     e.MouseWheel.WheelX = wheel_x;
; 1615 :     e.MouseWheel.WheelY = wheel_y;
; 1616 :     e.MouseWheel.MouseSource = g.InputEventsNextMouseSource;

	mov	eax, DWORD PTR [rbx+16304]

; 1617 :     g.InputEventsQueue.push_back(e);

	add	rbx, 16272				; 00003f90H
	movss	DWORD PTR e$1[rsp+12], xmm2
	movss	DWORD PTR e$1[rsp+16], xmm1
	mov	DWORD PTR e$1[rsp], 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	ecx, DWORD PTR [rbx]
	mov	r8d, DWORD PTR [rbx+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1612 :     e.Source = ImGuiInputSource_Mouse;

	mov	DWORD PTR e$1[rsp+4], 1

; 1614 :     e.MouseWheel.WheelX = wheel_x;
; 1615 :     e.MouseWheel.WheelY = wheel_y;
; 1616 :     e.MouseWheel.MouseSource = g.InputEventsNextMouseSource;

	mov	DWORD PTR e$1[rsp+20], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	cmp	ecx, r8d
	jne	SHORT $LN23@ImGui_Impl
	inc	ecx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	r8d, r8d
	je	SHORT $LN27@ImGui_Impl
	mov	eax, r8d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r8d
	jmp	SHORT $LN28@ImGui_Impl
$LN27@ImGui_Impl:
	mov	eax, 8
$LN28@ImGui_Impl:
	cmp	eax, ecx
	cmovg	ecx, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, ecx
	mov	rcx, rbx
	call	?reserve@?$ImVector@UImGuiInputEvent@@@@QEAAXH@Z ; ImVector<ImGuiInputEvent>::reserve
$LN23@ImGui_Impl:
	movsxd	rax, DWORD PTR [rbx]
	movups	xmm0, XMMWORD PTR e$1[rsp]
	movsd	xmm1, QWORD PTR e$1[rsp+16]
	imul	rcx, rax, 28
	mov	rax, QWORD PTR [rbx+8]
	movups	XMMWORD PTR [rcx+rax], xmm0
	movsd	QWORD PTR [rcx+rax+16], xmm1
	mov	DWORD PTR [rcx+rax+24], 0
	inc	DWORD PTR [rbx]
$LN18@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 352  : }

	movaps	xmm6, XMMWORD PTR [rsp+80]
	movaps	xmm7, XMMWORD PTR [rsp+64]
	add	rsp, 96					; 00000060H
	pop	rbx
	ret	0
?ImGui_ImplGlfw_ScrollCallback@@YAXPEAUGLFWwindow@@NN@Z ENDP ; ImGui_ImplGlfw_ScrollCallback
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?ImGui_ImplGlfw_TranslateUntranslatedKey@@YAHHH@Z
_TEXT	SEGMENT
char_keys$1 = 32
char_names$2 = 80
__$ArrayPad$ = 96
key$ = 128
scancode$ = 136
?ImGui_ImplGlfw_TranslateUntranslatedKey@@YAHHH@Z PROC	; ImGui_ImplGlfw_TranslateUntranslatedKey, COMDAT

; 355  : {

	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 112				; 00000070H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	edi, ecx
	mov	esi, edx

; 356  : #if GLFW_HAS_GETKEYNAME && !defined(__EMSCRIPTEN__)
; 357  :     // GLFW 3.1+ attempts to "untranslate" keys, which goes the opposite of what every other framework does, making using lettered shortcuts difficult.
; 358  :     // (It had reasons to do so: namely GLFW is/was more likely to be used for WASD-type game controls rather than lettered shortcuts, but IHMO the 3.1 change could have been done differently)
; 359  :     // See https://github.com/glfw/glfw/issues/1502 for details.
; 360  :     // Adding a workaround to undo this (so our keys are translated->untranslated->translated, likely a lossy process).
; 361  :     // This won't cover edge cases but this is at least going to cover common cases.
; 362  :     if (key >= GLFW_KEY_KP_0 && key <= GLFW_KEY_KP_EQUAL)

	add	ecx, -320				; fffffec0H
	cmp	ecx, 16
	jbe	$LN10@ImGui_Impl

; 363  :         return key;
; 364  :     GLFWerrorfun prev_error_callback = glfwSetErrorCallback(nullptr);

	xor	ecx, ecx
	mov	QWORD PTR [rsp+144], rbx
	call	glfwSetErrorCallback

; 365  :     const char* key_name = glfwGetKeyName(key, scancode);

	mov	edx, esi
	mov	ecx, edi
	mov	rbx, rax
	call	glfwGetKeyName

; 366  :     glfwSetErrorCallback(prev_error_callback);

	mov	rcx, rbx
	mov	rsi, rax
	call	glfwSetErrorCallback

; 367  : #if GLFW_HAS_GETERROR && !defined(__EMSCRIPTEN__) // Eat errors (see #5908)
; 368  :     (void)glfwGetError(nullptr);

	xor	ecx, ecx
	call	glfwGetError
	mov	rbx, QWORD PTR [rsp+144]

; 369  : #endif
; 370  :     if (key_name && key_name[0] != 0 && key_name[1] == 0)

	test	rsi, rsi
	je	$LN10@ImGui_Impl
	movsx	ecx, BYTE PTR [rsi]
	test	cl, cl
	je	$LN10@ImGui_Impl
	cmp	BYTE PTR [rsi+1], 0
	jne	$LN10@ImGui_Impl

; 371  :     {
; 372  :         const char char_names[] = "`-=[]\\,;\'./";

	movsd	xmm0, QWORD PTR ??_C@_0M@BNJJKMGF@?$GA?9?$DN?$FL?$FN?2?0?$DL?8?4?1@
	mov	eax, DWORD PTR ??_C@_0M@BNJJKMGF@?$GA?9?$DN?$FL?$FN?2?0?$DL?8?4?1@+8

; 373  :         const int char_keys[] = { GLFW_KEY_GRAVE_ACCENT, GLFW_KEY_MINUS, GLFW_KEY_EQUAL, GLFW_KEY_LEFT_BRACKET, GLFW_KEY_RIGHT_BRACKET, GLFW_KEY_BACKSLASH, GLFW_KEY_COMMA, GLFW_KEY_SEMICOLON, GLFW_KEY_APOSTROPHE, GLFW_KEY_PERIOD, GLFW_KEY_SLASH, 0 };

	movdqa	xmm1, XMMWORD PTR __xmm@0000003b0000002c0000005c0000005d
	movsd	QWORD PTR char_names$2[rsp], xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@0000005b0000003d0000002d00000060
	mov	DWORD PTR char_names$2[rsp+8], eax

; 374  :         IM_ASSERT(IM_ARRAYSIZE(char_names) == IM_ARRAYSIZE(char_keys));
; 375  :         if (key_name[0] >= '0' && key_name[0] <= '9')               { key = GLFW_KEY_0 + (key_name[0] - '0'); }

	lea	eax, DWORD PTR [rcx-48]
	movdqu	XMMWORD PTR char_keys$1[rsp], xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@000000000000002f0000002e00000027
	movdqu	XMMWORD PTR char_keys$1[rsp+32], xmm0
	movdqu	XMMWORD PTR char_keys$1[rsp+16], xmm1
	cmp	al, 9
	ja	SHORT $LN4@ImGui_Impl
	mov	edi, ecx
	jmp	SHORT $LN10@ImGui_Impl
$LN4@ImGui_Impl:

; 376  :         else if (key_name[0] >= 'A' && key_name[0] <= 'Z')          { key = GLFW_KEY_A + (key_name[0] - 'A'); }

	lea	eax, DWORD PTR [rcx-65]
	mov	edx, ecx
	cmp	al, 25
	ja	SHORT $LN6@ImGui_Impl
	mov	edi, ecx
	jmp	SHORT $LN10@ImGui_Impl
$LN6@ImGui_Impl:

; 377  :         else if (key_name[0] >= 'a' && key_name[0] <= 'z')          { key = GLFW_KEY_A + (key_name[0] - 'a'); }

	sub	cl, 97					; 00000061H
	cmp	cl, 25
	ja	SHORT $LN8@ImGui_Impl
	lea	edi, DWORD PTR [rdx-32]
	jmp	SHORT $LN10@ImGui_Impl
$LN8@ImGui_Impl:

; 378  :         else if (const char* p = strchr(char_names, key_name[0]))   { key = char_keys[p - char_names]; }

	lea	rcx, QWORD PTR char_names$2[rsp]
	call	QWORD PTR __imp_strchr
	test	rax, rax
	je	SHORT $LN10@ImGui_Impl
	lea	rcx, QWORD PTR char_names$2[rsp]
	sub	rax, rcx
	mov	edi, DWORD PTR char_keys$1[rsp+rax*4]
$LN10@ImGui_Impl:

; 379  :     }
; 380  :     // if (action == GLFW_PRESS) printf("key %d scancode %d name '%s'\n", key, scancode, key_name);
; 381  : #else
; 382  :     IM_UNUSED(scancode);
; 383  : #endif
; 384  :     return key;
; 385  : }

	mov	eax, edi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rsi, QWORD PTR [rsp+152]
	add	rsp, 112				; 00000070H
	pop	rdi
	ret	0
?ImGui_ImplGlfw_TranslateUntranslatedKey@@YAHHH@Z ENDP	; ImGui_ImplGlfw_TranslateUntranslatedKey
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?ImGui_ImplGlfw_KeyCallback@@YAXPEAUGLFWwindow@@HHHH@Z
_TEXT	SEGMENT
char_keys$1 = 48
char_names$2 = 96
__$ArrayPad$ = 112
window$ = 192
keycode$ = 200
scancode$ = 208
action$ = 216
mods$ = 224
?ImGui_ImplGlfw_KeyCallback@@YAXPEAUGLFWwindow@@HHHH@Z PROC ; ImGui_ImplGlfw_KeyCallback, COMDAT

; 388  : {

$LN65:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 136				; 00000088H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	xor	ebx, ebx

; 388  : {

	movsxd	rdi, edx
	mov	ebp, r9d
	mov	r15d, r8d
	mov	r14, rcx

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	test	rax, rax
	je	SHORT $LN8@ImGui_Impl
	mov	rsi, QWORD PTR [rax+152]
	jmp	SHORT $LN9@ImGui_Impl
$LN8@ImGui_Impl:
	mov	rsi, rbx
$LN9@ImGui_Impl:

; 389  :     ImGui_ImplGlfw_Data* bd = ImGui_ImplGlfw_GetBackendData();
; 390  :     if (bd->PrevUserCallbackKey != nullptr && ImGui_ImplGlfw_ShouldChainCallback(window))

	mov	r10, QWORD PTR [rsi+2944]
	test	r10, r10
	je	SHORT $LN2@ImGui_Impl

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	test	rax, rax
	je	SHORT $LN16@ImGui_Impl
	mov	rax, QWORD PTR [rax+152]
	jmp	SHORT $LN17@ImGui_Impl
$LN16@ImGui_Impl:
	mov	rax, rbx
$LN17@ImGui_Impl:

; 323  :     return bd->CallbacksChainForAllWindows ? true : (window == bd->Window);

	cmp	BYTE PTR [rax+2897], bl
	je	SHORT $LN12@ImGui_Impl
	mov	ecx, 1
	jmp	SHORT $LN13@ImGui_Impl
$LN12@ImGui_Impl:
	cmp	r14, QWORD PTR [rax]
	sete	cl
$LN13@ImGui_Impl:

; 389  :     ImGui_ImplGlfw_Data* bd = ImGui_ImplGlfw_GetBackendData();
; 390  :     if (bd->PrevUserCallbackKey != nullptr && ImGui_ImplGlfw_ShouldChainCallback(window))

	test	cl, cl
	je	SHORT $LN2@ImGui_Impl

; 391  :         bd->PrevUserCallbackKey(window, keycode, scancode, action, mods);

	mov	eax, DWORD PTR mods$[rsp]
	mov	edx, edi
	mov	rcx, r14
	mov	DWORD PTR [rsp+32], eax
	call	r10
$LN2@ImGui_Impl:

; 392  : 
; 393  :     if (action != GLFW_PRESS && action != GLFW_RELEASE)

	cmp	ebp, 1
	ja	$LN34@ImGui_Impl

; 394  :         return;
; 395  : 
; 396  :     ImGui_ImplGlfw_UpdateKeyModifiers(window);

	mov	rcx, r14
	call	?ImGui_ImplGlfw_UpdateKeyModifiers@@YAXPEAUGLFWwindow@@@Z ; ImGui_ImplGlfw_UpdateKeyModifiers

; 397  : 
; 398  :     if (keycode >= 0 && keycode < IM_ARRAYSIZE(bd->KeyOwnerWindows))

	cmp	edi, 347				; 0000015bH
	ja	SHORT $LN4@ImGui_Impl

; 399  :         bd->KeyOwnerWindows[keycode] = (action == GLFW_PRESS) ? window : nullptr;

	cmp	ebp, 1
	cmove	rbx, r14
	mov	QWORD PTR [rsi+rdi*8+112], rbx
$LN4@ImGui_Impl:

; 362  :     if (key >= GLFW_KEY_KP_0 && key <= GLFW_KEY_KP_EQUAL)

	lea	eax, DWORD PTR [rdi-320]
	cmp	eax, 16
	jbe	$LN27@ImGui_Impl

; 363  :         return key;
; 364  :     GLFWerrorfun prev_error_callback = glfwSetErrorCallback(nullptr);

	xor	ecx, ecx
	call	glfwSetErrorCallback

; 365  :     const char* key_name = glfwGetKeyName(key, scancode);

	mov	edx, r15d
	mov	ecx, edi
	mov	rbx, rax
	call	glfwGetKeyName

; 366  :     glfwSetErrorCallback(prev_error_callback);

	mov	rcx, rbx
	mov	rsi, rax
	call	glfwSetErrorCallback

; 367  : #if GLFW_HAS_GETERROR && !defined(__EMSCRIPTEN__) // Eat errors (see #5908)
; 368  :     (void)glfwGetError(nullptr);

	xor	ecx, ecx
	call	glfwGetError

; 369  : #endif
; 370  :     if (key_name && key_name[0] != 0 && key_name[1] == 0)

	test	rsi, rsi
	je	$LN27@ImGui_Impl
	movsx	ecx, BYTE PTR [rsi]
	test	cl, cl
	je	$LN27@ImGui_Impl
	cmp	BYTE PTR [rsi+1], 0
	jne	$LN27@ImGui_Impl

; 371  :     {
; 372  :         const char char_names[] = "`-=[]\\,;\'./";

	movsd	xmm0, QWORD PTR ??_C@_0M@BNJJKMGF@?$GA?9?$DN?$FL?$FN?2?0?$DL?8?4?1@
	mov	eax, DWORD PTR ??_C@_0M@BNJJKMGF@?$GA?9?$DN?$FL?$FN?2?0?$DL?8?4?1@+8

; 373  :         const int char_keys[] = { GLFW_KEY_GRAVE_ACCENT, GLFW_KEY_MINUS, GLFW_KEY_EQUAL, GLFW_KEY_LEFT_BRACKET, GLFW_KEY_RIGHT_BRACKET, GLFW_KEY_BACKSLASH, GLFW_KEY_COMMA, GLFW_KEY_SEMICOLON, GLFW_KEY_APOSTROPHE, GLFW_KEY_PERIOD, GLFW_KEY_SLASH, 0 };

	movdqa	xmm1, XMMWORD PTR __xmm@0000003b0000002c0000005c0000005d
	movsd	QWORD PTR char_names$2[rsp], xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@0000005b0000003d0000002d00000060
	mov	DWORD PTR char_names$2[rsp+8], eax

; 374  :         IM_ASSERT(IM_ARRAYSIZE(char_names) == IM_ARRAYSIZE(char_keys));
; 375  :         if (key_name[0] >= '0' && key_name[0] <= '9')               { key = GLFW_KEY_0 + (key_name[0] - '0'); }

	lea	eax, DWORD PTR [rcx-48]
	movdqu	XMMWORD PTR char_keys$1[rsp], xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@000000000000002f0000002e00000027
	movdqu	XMMWORD PTR char_keys$1[rsp+32], xmm0
	movdqu	XMMWORD PTR char_keys$1[rsp+16], xmm1
	cmp	al, 9
	ja	SHORT $LN21@ImGui_Impl
	mov	edi, ecx
	jmp	SHORT $LN27@ImGui_Impl
$LN21@ImGui_Impl:

; 376  :         else if (key_name[0] >= 'A' && key_name[0] <= 'Z')          { key = GLFW_KEY_A + (key_name[0] - 'A'); }

	lea	eax, DWORD PTR [rcx-65]
	mov	edx, ecx
	cmp	al, 25
	ja	SHORT $LN23@ImGui_Impl
	mov	edi, ecx
	jmp	SHORT $LN27@ImGui_Impl
$LN23@ImGui_Impl:

; 377  :         else if (key_name[0] >= 'a' && key_name[0] <= 'z')          { key = GLFW_KEY_A + (key_name[0] - 'a'); }

	sub	cl, 97					; 00000061H
	cmp	cl, 25
	ja	SHORT $LN25@ImGui_Impl
	lea	edi, DWORD PTR [rdx-32]
	jmp	SHORT $LN27@ImGui_Impl
$LN25@ImGui_Impl:

; 378  :         else if (const char* p = strchr(char_names, key_name[0]))   { key = char_keys[p - char_names]; }

	lea	rcx, QWORD PTR char_names$2[rsp]
	call	QWORD PTR __imp_strchr
	test	rax, rax
	je	SHORT $LN27@ImGui_Impl
	lea	rcx, QWORD PTR char_names$2[rsp]
	sub	rax, rcx
	mov	edi, DWORD PTR char_keys$1[rsp+rax*4]
$LN27@ImGui_Impl:

; 400  : 
; 401  :     keycode = ImGui_ImplGlfw_TranslateUntranslatedKey(keycode, scancode);
; 402  : 
; 403  :     ImGuiIO& io = ImGui::GetIO();

	mov	rsi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 404  :     ImGuiKey imgui_key = ImGui_ImplGlfw_KeyToImGuiKey(keycode);

	mov	ecx, edi
	call	?ImGui_ImplGlfw_KeyToImGuiKey@@YA?AW4ImGuiKey@@H@Z ; ImGui_ImplGlfw_KeyToImGuiKey

; 405  :     io.AddKeyEvent(imgui_key, (action == GLFW_PRESS));

	cmp	ebp, 1
	movsxd	rbx, eax
	sete	r8b
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1513 :     if (!AppAcceptingEvents)

	cmp	BYTE PTR [rsi+14313], 0
	je	SHORT $LN29@ImGui_Impl

; 1514 :         return;
; 1515 :     AddKeyAnalogEvent(key, down, down ? 1.0f : 0.0f);

	cmp	ebp, 1
	jne	SHORT $LN32@ImGui_Impl
	movss	xmm3, DWORD PTR __real@3f800000
	jmp	SHORT $LN33@ImGui_Impl
$LN32@ImGui_Impl:
	xorps	xmm3, xmm3
$LN33@ImGui_Impl:
	mov	edx, ebx
	lea	rcx, QWORD PTR [rsi+8]
	call	?AddKeyAnalogEvent@ImGuiIO@@QEAAXW4ImGuiKey@@_NM@Z ; ImGuiIO::AddKeyAnalogEvent
$LN29@ImGui_Impl:

; 1523 :     if (key == ImGuiKey_None)

	test	ebx, ebx
	je	SHORT $LN34@ImGui_Impl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3209 :     inline bool             IsLegacyKey(ImGuiKey key)                                   { return key >= ImGuiKey_LegacyNativeKey_BEGIN && key < ImGuiKey_LegacyNativeKey_END; }

	cmp	edi, 511				; 000001ffH
	ja	SHORT $LN34@ImGui_Impl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1535 :     KeyMap[legacy_key] = key;

	movsxd	rax, edi
	mov	DWORD PTR [rsi+rax*4+256], ebx

; 1536 :     KeyMap[key] = legacy_key;

	mov	DWORD PTR [rsi+rbx*4+256], edi
$LN34@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 407  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 136				; 00000088H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
?ImGui_ImplGlfw_KeyCallback@@YAXPEAUGLFWwindow@@HHHH@Z ENDP ; ImGui_ImplGlfw_KeyCallback
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?ImGui_ImplGlfw_WindowFocusCallback@@YAXPEAUGLFWwindow@@H@Z
_TEXT	SEGMENT
e$1 = 32
window$ = 80
focused$ = 88
?ImGui_ImplGlfw_WindowFocusCallback@@YAXPEAUGLFWwindow@@H@Z PROC ; ImGui_ImplGlfw_WindowFocusCallback, COMDAT

; 410  : {

$LN57:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 64					; 00000040H

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	mov	r8, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	xor	eax, eax

; 410  : {

	mov	edi, edx
	mov	r11, rcx

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	test	r8, r8
	je	SHORT $LN6@ImGui_Impl
	mov	r9, QWORD PTR [r8+152]
	jmp	SHORT $LN7@ImGui_Impl
$LN6@ImGui_Impl:
	mov	r9, rax
$LN7@ImGui_Impl:

; 411  :     ImGui_ImplGlfw_Data* bd = ImGui_ImplGlfw_GetBackendData();
; 412  :     if (bd->PrevUserCallbackWindowFocus != nullptr && ImGui_ImplGlfw_ShouldChainCallback(window))

	mov	r10, QWORD PTR [r9+2904]
	test	r10, r10
	je	SHORT $LN2@ImGui_Impl

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	test	r8, r8
	je	SHORT $LN14@ImGui_Impl
	mov	rcx, QWORD PTR [r8+152]
	jmp	SHORT $LN15@ImGui_Impl
$LN14@ImGui_Impl:
	mov	rcx, rax
$LN15@ImGui_Impl:

; 323  :     return bd->CallbacksChainForAllWindows ? true : (window == bd->Window);

	cmp	BYTE PTR [rcx+2897], al
	je	SHORT $LN10@ImGui_Impl
	mov	eax, 1
	jmp	SHORT $LN11@ImGui_Impl
$LN10@ImGui_Impl:
	cmp	r11, QWORD PTR [rcx]
	sete	al
$LN11@ImGui_Impl:

; 411  :     ImGui_ImplGlfw_Data* bd = ImGui_ImplGlfw_GetBackendData();
; 412  :     if (bd->PrevUserCallbackWindowFocus != nullptr && ImGui_ImplGlfw_ShouldChainCallback(window))

	test	al, al
	je	SHORT $LN2@ImGui_Impl

; 413  :         bd->PrevUserCallbackWindowFocus(window, focused);

	mov	rcx, r11
	call	r10
	mov	r8, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
$LN2@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1653 :     ImGuiContext& g = *Ctx;

	mov	rdx, QWORD PTR [r8+3584]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 416  :     io.AddFocusEvent(focused != 0);

	test	edi, edi
	setne	r10b
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1450 :     for (int n = g.InputEventsQueue.Size - 1; n >= 0; n--)

	lea	rbx, QWORD PTR [rdx+16272]
	mov	r9d, DWORD PTR [rbx]
	lea	eax, DWORD PTR [r9-1]
	test	eax, eax
	js	SHORT $LN20@ImGui_Impl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rcx, eax
	imul	rax, rcx, 28
	add	rax, QWORD PTR [rdx+16280]
	npad	7
$LL25@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1453 :         if (e->Type != type)

	cmp	DWORD PTR [rax], 7
	je	SHORT $LN22@ImGui_Impl

; 1450 :     for (int n = g.InputEventsQueue.Size - 1; n >= 0; n--)

	sub	rax, 28
	sub	rcx, 1
	jns	SHORT $LL25@ImGui_Impl
$LN20@ImGui_Impl:

; 1657 :     const bool latest_focused = latest_event ? latest_event->AppFocused.Focused : !g.IO.AppFocusLost;

	cmp	BYTE PTR [rdx+14312], 0
	sete	cl
$LN21@ImGui_Impl:

; 1658 :     if (latest_focused == focused || (ConfigDebugIgnoreFocusLoss && !focused))

	cmp	cl, r10b
	je	$LN18@ImGui_Impl
	cmp	BYTE PTR [r8+130], 0
	je	SHORT $LN17@ImGui_Impl
	test	edi, edi
	je	$LN18@ImGui_Impl
$LN17@ImGui_Impl:

; 1663 :     e.EventId = g.InputEventsNextEventId++;

	mov	eax, DWORD PTR [rdx+16308]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1353 :     ImGuiInputEvent() { memset(this, 0, sizeof(*this)); }

	xor	edi, edi
	xorps	xmm0, xmm0
	mov	QWORD PTR e$1[rsp+16], rdi
	movups	XMMWORD PTR e$1[rsp], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1663 :     e.EventId = g.InputEventsNextEventId++;

	mov	DWORD PTR e$1[rsp+8], eax
	inc	eax
	mov	DWORD PTR [rdx+16308], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	r8d, DWORD PTR [rbx+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1662 :     e.Type = ImGuiInputEventType_Focus;

	mov	DWORD PTR e$1[rsp], 7

; 1664 :     e.AppFocused.Focused = focused;

	mov	BYTE PTR e$1[rsp+12], r10b
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	cmp	r9d, r8d
	jne	SHORT $LN35@ImGui_Impl
	lea	ecx, DWORD PTR [r9+1]

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	r8d, r8d
	je	SHORT $LN39@ImGui_Impl
	mov	eax, r8d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r8d
	jmp	SHORT $LN40@ImGui_Impl
$LN22@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1657 :     const bool latest_focused = latest_event ? latest_event->AppFocused.Focused : !g.IO.AppFocusLost;

	movzx	ecx, BYTE PTR [rax+12]
	jmp	SHORT $LN21@ImGui_Impl
$LN39@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	eax, 8
$LN40@ImGui_Impl:
	cmp	eax, ecx
	cmovg	ecx, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, ecx
	mov	rcx, rbx
	call	?reserve@?$ImVector@UImGuiInputEvent@@@@QEAAXH@Z ; ImVector<ImGuiInputEvent>::reserve
$LN35@ImGui_Impl:
	movsxd	rax, DWORD PTR [rbx]
	movups	xmm0, XMMWORD PTR e$1[rsp]
	movsd	xmm1, QWORD PTR e$1[rsp+16]
	imul	rcx, rax, 28
	mov	rax, QWORD PTR [rbx+8]
	movups	XMMWORD PTR [rcx+rax], xmm0
	movsd	QWORD PTR [rcx+rax+16], xmm1
	mov	DWORD PTR [rcx+rax+24], edi
	inc	DWORD PTR [rbx]
$LN18@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 417  : }

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?ImGui_ImplGlfw_WindowFocusCallback@@YAXPEAUGLFWwindow@@H@Z ENDP ; ImGui_ImplGlfw_WindowFocusCallback
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?ImGui_ImplGlfw_CursorPosCallback@@YAXPEAUGLFWwindow@@NN@Z
_TEXT	SEGMENT
window_x$2 = 32
window_y$3 = 36
__$ArrayPad$ = 40
window$ = 112
x$ = 120
y$ = 128
?ImGui_ImplGlfw_CursorPosCallback@@YAXPEAUGLFWwindow@@NN@Z PROC ; ImGui_ImplGlfw_CursorPosCallback, COMDAT

; 420  : {

$LN26:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 80					; 00000050H
	movaps	XMMWORD PTR [rsp+64], xmm6
	movaps	XMMWORD PTR [rsp+48], xmm7
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 420  : {

	mov	rsi, rcx

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	xor	ecx, ecx

; 420  : {

	movaps	xmm7, xmm2
	movaps	xmm6, xmm1

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	test	rax, rax
	je	SHORT $LN7@ImGui_Impl
	mov	rbx, QWORD PTR [rax+152]
	jmp	SHORT $LN8@ImGui_Impl
$LN7@ImGui_Impl:
	mov	rbx, rcx
$LN8@ImGui_Impl:

; 421  :     ImGui_ImplGlfw_Data* bd = ImGui_ImplGlfw_GetBackendData();
; 422  :     if (bd->PrevUserCallbackCursorPos != nullptr && ImGui_ImplGlfw_ShouldChainCallback(window))

	mov	r8, QWORD PTR [rbx+2912]
	test	r8, r8
	je	SHORT $LN2@ImGui_Impl

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	test	rax, rax
	je	SHORT $LN15@ImGui_Impl
	mov	rdx, QWORD PTR [rax+152]
	jmp	SHORT $LN16@ImGui_Impl
$LN15@ImGui_Impl:
	mov	rdx, rcx
$LN16@ImGui_Impl:

; 323  :     return bd->CallbacksChainForAllWindows ? true : (window == bd->Window);

	cmp	BYTE PTR [rdx+2897], cl
	je	SHORT $LN11@ImGui_Impl
	mov	ecx, 1
	jmp	SHORT $LN12@ImGui_Impl
$LN11@ImGui_Impl:
	cmp	rsi, QWORD PTR [rdx]
	sete	cl
$LN12@ImGui_Impl:

; 421  :     ImGui_ImplGlfw_Data* bd = ImGui_ImplGlfw_GetBackendData();
; 422  :     if (bd->PrevUserCallbackCursorPos != nullptr && ImGui_ImplGlfw_ShouldChainCallback(window))

	test	cl, cl
	je	SHORT $LN2@ImGui_Impl

; 423  :         bd->PrevUserCallbackCursorPos(window, x, y);

	mov	rcx, rsi
	call	r8
	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
$LN2@ImGui_Impl:

; 424  : 
; 425  :     ImGuiIO& io = ImGui::GetIO();
; 426  :     if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)

	test	DWORD PTR [rax+8], 1024			; 00000400H
	lea	rdi, QWORD PTR [rax+8]
	je	SHORT $LN3@ImGui_Impl

; 427  :     {
; 428  :         int window_x, window_y;
; 429  :         glfwGetWindowPos(window, &window_x, &window_y);

	lea	r8, QWORD PTR window_y$3[rsp]
	mov	rcx, rsi
	lea	rdx, QWORD PTR window_x$2[rsp]
	call	glfwGetWindowPos
	movd	xmm0, DWORD PTR window_x$2[rsp]
	movd	xmm1, DWORD PTR window_y$3[rsp]

; 430  :         x += window_x;

	cvtdq2pd xmm0, xmm0

; 431  :         y += window_y;

	cvtdq2pd xmm1, xmm1
	addsd	xmm6, xmm0
	addsd	xmm7, xmm1
$LN3@ImGui_Impl:

; 432  :     }
; 433  :     io.AddMousePosEvent((float)x, (float)y);

	cvtsd2ss xmm7, xmm7
	mov	rcx, rdi
	cvtsd2ss xmm6, xmm6
	movaps	xmm2, xmm7
	movaps	xmm1, xmm6
	call	?AddMousePosEvent@ImGuiIO@@QEAAXMM@Z	; ImGuiIO::AddMousePosEvent

; 434  :     bd->LastValidMousePos = ImVec2((float)x, (float)y);

	movss	DWORD PTR [rbx+104], xmm6
	movss	DWORD PTR [rbx+108], xmm7

; 435  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	movaps	xmm6, XMMWORD PTR [rsp+64]
	movaps	xmm7, XMMWORD PTR [rsp+48]
	add	rsp, 80					; 00000050H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?ImGui_ImplGlfw_CursorPosCallback@@YAXPEAUGLFWwindow@@NN@Z ENDP ; ImGui_ImplGlfw_CursorPosCallback
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?ImGui_ImplGlfw_CursorEnterCallback@@YAXPEAUGLFWwindow@@H@Z
_TEXT	SEGMENT
window$ = 48
entered$ = 56
?ImGui_ImplGlfw_CursorEnterCallback@@YAXPEAUGLFWwindow@@H@Z PROC ; ImGui_ImplGlfw_CursorEnterCallback, COMDAT

; 440  : {

$LN28:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 440  : {

	mov	esi, edx
	mov	rdi, rcx

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	test	rax, rax
	je	SHORT $LN9@ImGui_Impl
	mov	rbx, QWORD PTR [rax+152]
	jmp	SHORT $LN10@ImGui_Impl
$LN9@ImGui_Impl:
	xor	ebx, ebx
$LN10@ImGui_Impl:

; 441  :     ImGui_ImplGlfw_Data* bd = ImGui_ImplGlfw_GetBackendData();
; 442  :     if (bd->PrevUserCallbackCursorEnter != nullptr && ImGui_ImplGlfw_ShouldChainCallback(window))

	mov	r8, QWORD PTR [rbx+2920]
	test	r8, r8
	je	SHORT $LN2@ImGui_Impl

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	test	rax, rax
	je	SHORT $LN17@ImGui_Impl
	mov	rcx, QWORD PTR [rax+152]
	jmp	SHORT $LN18@ImGui_Impl
$LN17@ImGui_Impl:
	xor	ecx, ecx
$LN18@ImGui_Impl:

; 323  :     return bd->CallbacksChainForAllWindows ? true : (window == bd->Window);

	cmp	BYTE PTR [rcx+2897], 0
	je	SHORT $LN13@ImGui_Impl
	mov	edx, 1
	jmp	SHORT $LN14@ImGui_Impl
$LN13@ImGui_Impl:
	cmp	rdi, QWORD PTR [rcx]
	sete	dl
$LN14@ImGui_Impl:

; 441  :     ImGui_ImplGlfw_Data* bd = ImGui_ImplGlfw_GetBackendData();
; 442  :     if (bd->PrevUserCallbackCursorEnter != nullptr && ImGui_ImplGlfw_ShouldChainCallback(window))

	test	dl, dl
	je	SHORT $LN2@ImGui_Impl

; 443  :         bd->PrevUserCallbackCursorEnter(window, entered);

	mov	edx, esi
	mov	rcx, rdi
	call	r8
	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
$LN2@ImGui_Impl:

; 444  : 
; 445  :     ImGuiIO& io = ImGui::GetIO();

	lea	rcx, QWORD PTR [rax+8]

; 446  :     if (entered)

	test	esi, esi
	je	SHORT $LN3@ImGui_Impl

; 447  :     {
; 448  :         bd->MouseWindow = window;
; 449  :         io.AddMousePosEvent(bd->LastValidMousePos.x, bd->LastValidMousePos.y);

	movss	xmm2, DWORD PTR [rbx+108]
	movss	xmm1, DWORD PTR [rbx+104]
	mov	QWORD PTR [rbx+24], rdi

; 450  :     }

	jmp	SHORT $LN26@ImGui_Impl
$LN3@ImGui_Impl:

; 451  :     else if (!entered && bd->MouseWindow == window)

	cmp	QWORD PTR [rbx+24], rdi
	jne	SHORT $LN5@ImGui_Impl

; 452  :     {
; 453  :         bd->LastValidMousePos = io.MousePos;

	movsd	xmm0, QWORD PTR [rcx+3584]

; 454  :         bd->MouseWindow = nullptr;
; 455  :         io.AddMousePosEvent(-FLT_MAX, -FLT_MAX);

	movss	xmm1, DWORD PTR __real@ff7fffff
	movsd	QWORD PTR [rbx+104], xmm0
	movaps	xmm2, xmm1
	mov	QWORD PTR [rbx+24], 0
$LN26@ImGui_Impl:

; 456  :     }
; 457  : }

	call	?AddMousePosEvent@ImGuiIO@@QEAAXMM@Z	; ImGuiIO::AddMousePosEvent
$LN5@ImGui_Impl:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?ImGui_ImplGlfw_CursorEnterCallback@@YAXPEAUGLFWwindow@@H@Z ENDP ; ImGui_ImplGlfw_CursorEnterCallback
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?ImGui_ImplGlfw_CharCallback@@YAXPEAUGLFWwindow@@I@Z
_TEXT	SEGMENT
window$ = 48
c$ = 56
?ImGui_ImplGlfw_CharCallback@@YAXPEAUGLFWwindow@@I@Z PROC ; ImGui_ImplGlfw_CharCallback, COMDAT

; 460  : {

$LN22:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	r10, rcx

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	xor	eax, eax
	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 460  : {

	mov	ebx, edx

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	test	rcx, rcx
	je	SHORT $LN6@ImGui_Impl
	mov	r8, QWORD PTR [rcx+152]
	jmp	SHORT $LN7@ImGui_Impl
$LN6@ImGui_Impl:
	mov	r8, rax
$LN7@ImGui_Impl:

; 461  :     ImGui_ImplGlfw_Data* bd = ImGui_ImplGlfw_GetBackendData();
; 462  :     if (bd->PrevUserCallbackChar != nullptr && ImGui_ImplGlfw_ShouldChainCallback(window))

	mov	r9, QWORD PTR [r8+2952]
	test	r9, r9
	je	SHORT $LN2@ImGui_Impl

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	test	rcx, rcx
	je	SHORT $LN14@ImGui_Impl
	mov	rdx, QWORD PTR [rcx+152]
	jmp	SHORT $LN15@ImGui_Impl
$LN14@ImGui_Impl:
	mov	rdx, rax
$LN15@ImGui_Impl:

; 323  :     return bd->CallbacksChainForAllWindows ? true : (window == bd->Window);

	cmp	BYTE PTR [rdx+2897], al
	je	SHORT $LN10@ImGui_Impl
	mov	eax, 1
	jmp	SHORT $LN11@ImGui_Impl
$LN10@ImGui_Impl:
	cmp	r10, QWORD PTR [rdx]
	sete	al
$LN11@ImGui_Impl:

; 461  :     ImGui_ImplGlfw_Data* bd = ImGui_ImplGlfw_GetBackendData();
; 462  :     if (bd->PrevUserCallbackChar != nullptr && ImGui_ImplGlfw_ShouldChainCallback(window))

	test	al, al
	je	SHORT $LN2@ImGui_Impl

; 463  :         bd->PrevUserCallbackChar(window, c);

	mov	edx, ebx
	mov	rcx, r10
	call	r9
	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
$LN2@ImGui_Impl:

; 464  : 
; 465  :     ImGuiIO& io = ImGui::GetIO();

	add	rcx, 8

; 466  :     io.AddInputCharacter(c);

	mov	edx, ebx

; 467  : }

	add	rsp, 32					; 00000020H
	pop	rbx

; 466  :     io.AddInputCharacter(c);

	jmp	?AddInputCharacter@ImGuiIO@@QEAAXI@Z	; ImGuiIO::AddInputCharacter
?ImGui_ImplGlfw_CharCallback@@YAXPEAUGLFWwindow@@I@Z ENDP ; ImGui_ImplGlfw_CharCallback
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?ImGui_ImplGlfw_MonitorCallback@@YAXPEAUGLFWmonitor@@H@Z
_TEXT	SEGMENT
__formal$ = 8
__formal$ = 16
?ImGui_ImplGlfw_MonitorCallback@@YAXPEAUGLFWmonitor@@H@Z PROC ; ImGui_ImplGlfw_MonitorCallback, COMDAT

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN5@ImGui_Impl
	mov	rax, QWORD PTR [rax+152]

; 471  :     ImGui_ImplGlfw_Data* bd = ImGui_ImplGlfw_GetBackendData();
; 472  :     bd->WantUpdateMonitors = true;
; 473  : }

	mov	BYTE PTR [rax+2898], 1
	ret	0
$LN5@ImGui_Impl:
	mov	BYTE PTR [rax+2898], 1
	ret	0
?ImGui_ImplGlfw_MonitorCallback@@YAXPEAUGLFWmonitor@@H@Z ENDP ; ImGui_ImplGlfw_MonitorCallback
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?GetMouseSourceFromMessageExtraInfo@@YA?AW4ImGuiMouseSource@@XZ
_TEXT	SEGMENT
?GetMouseSourceFromMessageExtraInfo@@YA?AW4ImGuiMouseSource@@XZ PROC ; GetMouseSourceFromMessageExtraInfo, COMDAT

; 497  : {

	sub	rsp, 40					; 00000028H

; 498  :     LPARAM extra_info = ::GetMessageExtraInfo();

	call	QWORD PTR __imp_GetMessageExtraInfo
	mov	rcx, rax

; 499  :     if ((extra_info & 0xFFFFFF80) == 0xFF515700)

	mov	eax, -128				; ffffffffffffff80H
	and	rcx, rax
	mov	eax, -11446528				; ff515700H
	cmp	rcx, rax
	jne	SHORT $LN2@GetMouseSo

; 500  :         return ImGuiMouseSource_Pen;

	mov	eax, 2

; 502  :         return ImGuiMouseSource_TouchScreen;
; 503  :     return ImGuiMouseSource_Mouse;
; 504  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN2@GetMouseSo:

; 501  :     if ((extra_info & 0xFFFFFF80) == 0xFF515780)

	xor	eax, eax
	mov	edx, -11446400				; ff515780H
	cmp	rcx, rdx
	sete	al

; 502  :         return ImGuiMouseSource_TouchScreen;
; 503  :     return ImGuiMouseSource_Mouse;
; 504  : }

	add	rsp, 40					; 00000028H
	ret	0
?GetMouseSourceFromMessageExtraInfo@@YA?AW4ImGuiMouseSource@@XZ ENDP ; GetMouseSourceFromMessageExtraInfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?ImGui_ImplGlfw_WndProc@@YA_JPEAUHWND__@@I_K_J@Z
_TEXT	SEGMENT
hWnd$ = 80
msg$ = 88
wParam$ = 96
lParam$ = 104
?ImGui_ImplGlfw_WndProc@@YA_JPEAUHWND__@@I_K_J@Z PROC	; ImGui_ImplGlfw_WndProc, COMDAT

; 506  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	mov	rsi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	xor	edi, edi

; 506  : {

	mov	r15, r9
	mov	r12, r8
	mov	ebx, edx
	mov	r14, rcx

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	test	rsi, rsi
	je	SHORT $LN24@ImGui_Impl
	mov	rbp, QWORD PTR [rsi+152]
	jmp	SHORT $LN25@ImGui_Impl
$LN24@ImGui_Impl:
	mov	rbp, rdi
$LN25@ImGui_Impl:

; 507  :     ImGui_ImplGlfw_Data* bd = ImGui_ImplGlfw_GetBackendData();
; 508  :     switch (msg)

	cmp	ebx, 512				; 00000200H
	ja	SHORT $LN21@ImGui_Impl
	je	SHORT $LN4@ImGui_Impl
	mov	eax, ebx
	sub	eax, 132				; 00000084H
	je	SHORT $LN18@ImGui_Impl
	cmp	eax, 28
	jne	SHORT $LN19@ImGui_Impl
$LN4@ImGui_Impl:

; 498  :     LPARAM extra_info = ::GetMessageExtraInfo();

	call	QWORD PTR __imp_GetMessageExtraInfo

; 499  :     if ((extra_info & 0xFFFFFF80) == 0xFF515700)

	mov	ecx, -128				; ffffffffffffff80H
	and	rax, rcx
	mov	ecx, -11446528				; ff515700H
	cmp	rax, rcx
	jne	SHORT $LN27@ImGui_Impl

; 500  :         return ImGuiMouseSource_Pen;

	mov	edi, 2
	jmp	SHORT $LN28@ImGui_Impl
$LN18@ImGui_Impl:

; 509  :     {
; 510  :     case WM_MOUSEMOVE: case WM_NCMOUSEMOVE:
; 511  :     case WM_LBUTTONDOWN: case WM_LBUTTONDBLCLK: case WM_LBUTTONUP:
; 512  :     case WM_RBUTTONDOWN: case WM_RBUTTONDBLCLK: case WM_RBUTTONUP:
; 513  :     case WM_MBUTTONDOWN: case WM_MBUTTONDBLCLK: case WM_MBUTTONUP:
; 514  :     case WM_XBUTTONDOWN: case WM_XBUTTONDBLCLK: case WM_XBUTTONUP:
; 515  :         ImGui::GetIO().AddMouseSourceEvent(GetMouseSourceFromMessageExtraInfo());
; 516  :         break;
; 517  : 
; 518  :     // We have submitted https://github.com/glfw/glfw/pull/1568 to allow GLFW to support "transparent inputs".
; 519  :     // In the meanwhile we implement custom per-platform workarounds here (FIXME-VIEWPORT: Implement same work-around for Linux/OSX!)
; 520  : #if !GLFW_HAS_MOUSE_PASSTHROUGH && GLFW_HAS_WINDOW_HOVERED
; 521  :     case WM_NCHITTEST:
; 522  :     {
; 523  :         // Let mouse pass-through the window. This will allow the backend to call io.AddMouseViewportEvent() properly (which is OPTIONAL).
; 524  :         // The ImGuiViewportFlags_NoInputs flag is set while dragging a viewport, as want to detect the window behind the one we are dragging.
; 525  :         // If you cannot easily access those viewport flags from your windowing/event code: you may manually synchronize its state e.g. in
; 526  :         // your main loop after calling UpdatePlatformWindows(). Iterate all viewports/platform windows and pass the flag to your windowing system.
; 527  :         ImGuiViewport* viewport = (ImGuiViewport*)::GetPropA(hWnd, "IMGUI_VIEWPORT");

	lea	rdx, OFFSET FLAT:??_C@_0P@JJHDDBGF@IMGUI_VIEWPORT@
	call	QWORD PTR __imp_GetPropA

; 528  :         if (viewport && (viewport->Flags & ImGuiViewportFlags_NoInputs))

	test	rax, rax
	je	SHORT $LN19@ImGui_Impl
	test	BYTE PTR [rax+4], 128			; 00000080H
	je	SHORT $LN19@ImGui_Impl

; 529  :             return HTTRANSPARENT;

	mov	rax, -1
	jmp	SHORT $LN1@ImGui_Impl
$LN21@ImGui_Impl:

; 507  :     ImGui_ImplGlfw_Data* bd = ImGui_ImplGlfw_GetBackendData();
; 508  :     switch (msg)

	lea	eax, DWORD PTR [rdx-513]
	cmp	eax, 12
	ja	SHORT $LN19@ImGui_Impl
	lea	rdx, OFFSET FLAT:__ImageBase
	mov	ecx, DWORD PTR $LN32@ImGui_Impl[rdx+rax*4]
	add	rcx, rdx
	jmp	rcx
$LN27@ImGui_Impl:

; 501  :     if ((extra_info & 0xFFFFFF80) == 0xFF515780)

	mov	ecx, -11446400				; ff515780H
	cmp	rax, rcx
	sete	dil
$LN28@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1626 :     g.InputEventsNextMouseSource = source;

	mov	rax, QWORD PTR [rsi+3584]
	mov	DWORD PTR [rax+16304], edi
$LN19@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 534  :     return ::CallWindowProc(bd->GlfwWndProc, hWnd, msg, wParam, lParam);

	mov	rcx, QWORD PTR [rbp+2968]
	mov	r9, r12
	mov	r8d, ebx
	mov	QWORD PTR [rsp+32], r15
	mov	rdx, r14
	call	QWORD PTR __imp_CallWindowProcW
$LN1@ImGui_Impl:

; 535  : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	mov	rdi, QWORD PTR [rsp+104]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r12
	ret	0
$LN32@ImGui_Impl:
	DD	$LN4@ImGui_Impl
	DD	$LN4@ImGui_Impl
	DD	$LN4@ImGui_Impl
	DD	$LN4@ImGui_Impl
	DD	$LN4@ImGui_Impl
	DD	$LN4@ImGui_Impl
	DD	$LN4@ImGui_Impl
	DD	$LN4@ImGui_Impl
	DD	$LN4@ImGui_Impl
	DD	$LN19@ImGui_Impl
	DD	$LN4@ImGui_Impl
	DD	$LN4@ImGui_Impl
	DD	$LN4@ImGui_Impl
?ImGui_ImplGlfw_WndProc@@YA_JPEAUHWND__@@I_K_J@Z ENDP	; ImGui_ImplGlfw_WndProc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?ImGui_ImplGlfw_InstallCallbacks@@YAXPEAUGLFWwindow@@@Z
_TEXT	SEGMENT
window$ = 48
?ImGui_ImplGlfw_InstallCallbacks@@YAXPEAUGLFWwindow@@@Z PROC ; ImGui_ImplGlfw_InstallCallbacks, COMDAT

; 539  : {

$LN9:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 539  : {

	mov	rdi, rcx

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	test	rbx, rbx
	je	SHORT $LN6@ImGui_Impl
	mov	rbx, QWORD PTR [rbx+152]
$LN6@ImGui_Impl:

; 540  :     ImGui_ImplGlfw_Data* bd = ImGui_ImplGlfw_GetBackendData();
; 541  :     IM_ASSERT(bd->InstalledCallbacks == false && "Callbacks already installed!");
; 542  :     IM_ASSERT(bd->Window == window);
; 543  : 
; 544  :     bd->PrevUserCallbackWindowFocus = glfwSetWindowFocusCallback(window, ImGui_ImplGlfw_WindowFocusCallback);

	lea	rdx, OFFSET FLAT:?ImGui_ImplGlfw_WindowFocusCallback@@YAXPEAUGLFWwindow@@H@Z ; ImGui_ImplGlfw_WindowFocusCallback
	call	glfwSetWindowFocusCallback

; 545  :     bd->PrevUserCallbackCursorEnter = glfwSetCursorEnterCallback(window, ImGui_ImplGlfw_CursorEnterCallback);

	lea	rdx, OFFSET FLAT:?ImGui_ImplGlfw_CursorEnterCallback@@YAXPEAUGLFWwindow@@H@Z ; ImGui_ImplGlfw_CursorEnterCallback
	mov	QWORD PTR [rbx+2904], rax
	mov	rcx, rdi
	call	glfwSetCursorEnterCallback

; 546  :     bd->PrevUserCallbackCursorPos = glfwSetCursorPosCallback(window, ImGui_ImplGlfw_CursorPosCallback);

	lea	rdx, OFFSET FLAT:?ImGui_ImplGlfw_CursorPosCallback@@YAXPEAUGLFWwindow@@NN@Z ; ImGui_ImplGlfw_CursorPosCallback
	mov	QWORD PTR [rbx+2920], rax
	mov	rcx, rdi
	call	glfwSetCursorPosCallback

; 547  :     bd->PrevUserCallbackMousebutton = glfwSetMouseButtonCallback(window, ImGui_ImplGlfw_MouseButtonCallback);

	lea	rdx, OFFSET FLAT:?ImGui_ImplGlfw_MouseButtonCallback@@YAXPEAUGLFWwindow@@HHH@Z ; ImGui_ImplGlfw_MouseButtonCallback
	mov	QWORD PTR [rbx+2912], rax
	mov	rcx, rdi
	call	glfwSetMouseButtonCallback

; 548  :     bd->PrevUserCallbackScroll = glfwSetScrollCallback(window, ImGui_ImplGlfw_ScrollCallback);

	lea	rdx, OFFSET FLAT:?ImGui_ImplGlfw_ScrollCallback@@YAXPEAUGLFWwindow@@NN@Z ; ImGui_ImplGlfw_ScrollCallback
	mov	QWORD PTR [rbx+2928], rax
	mov	rcx, rdi
	call	glfwSetScrollCallback

; 549  :     bd->PrevUserCallbackKey = glfwSetKeyCallback(window, ImGui_ImplGlfw_KeyCallback);

	lea	rdx, OFFSET FLAT:?ImGui_ImplGlfw_KeyCallback@@YAXPEAUGLFWwindow@@HHHH@Z ; ImGui_ImplGlfw_KeyCallback
	mov	QWORD PTR [rbx+2936], rax
	mov	rcx, rdi
	call	glfwSetKeyCallback

; 550  :     bd->PrevUserCallbackChar = glfwSetCharCallback(window, ImGui_ImplGlfw_CharCallback);

	lea	rdx, OFFSET FLAT:?ImGui_ImplGlfw_CharCallback@@YAXPEAUGLFWwindow@@I@Z ; ImGui_ImplGlfw_CharCallback
	mov	QWORD PTR [rbx+2944], rax
	mov	rcx, rdi
	call	glfwSetCharCallback

; 551  :     bd->PrevUserCallbackMonitor = glfwSetMonitorCallback(ImGui_ImplGlfw_MonitorCallback);

	lea	rcx, OFFSET FLAT:?ImGui_ImplGlfw_MonitorCallback@@YAXPEAUGLFWmonitor@@H@Z ; ImGui_ImplGlfw_MonitorCallback
	mov	QWORD PTR [rbx+2952], rax
	call	glfwSetMonitorCallback
	mov	QWORD PTR [rbx+2960], rax

; 552  :     bd->InstalledCallbacks = true;

	mov	BYTE PTR [rbx+2896], 1

; 553  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?ImGui_ImplGlfw_InstallCallbacks@@YAXPEAUGLFWwindow@@@Z ENDP ; ImGui_ImplGlfw_InstallCallbacks
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?ImGui_ImplGlfw_RestoreCallbacks@@YAXPEAUGLFWwindow@@@Z
_TEXT	SEGMENT
window$ = 48
?ImGui_ImplGlfw_RestoreCallbacks@@YAXPEAUGLFWwindow@@@Z PROC ; ImGui_ImplGlfw_RestoreCallbacks, COMDAT

; 556  : {

$LN9:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	xor	esi, esi

; 556  : {

	mov	rdi, rcx

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	test	rbx, rbx
	je	SHORT $LN5@ImGui_Impl
	mov	rbx, QWORD PTR [rbx+152]
	jmp	SHORT $LN6@ImGui_Impl
$LN5@ImGui_Impl:
	mov	rbx, rsi
$LN6@ImGui_Impl:

; 557  :     ImGui_ImplGlfw_Data* bd = ImGui_ImplGlfw_GetBackendData();
; 558  :     IM_ASSERT(bd->InstalledCallbacks == true && "Callbacks not installed!");
; 559  :     IM_ASSERT(bd->Window == window);
; 560  : 
; 561  :     glfwSetWindowFocusCallback(window, bd->PrevUserCallbackWindowFocus);

	mov	rdx, QWORD PTR [rbx+2904]
	call	glfwSetWindowFocusCallback

; 562  :     glfwSetCursorEnterCallback(window, bd->PrevUserCallbackCursorEnter);

	mov	rdx, QWORD PTR [rbx+2920]
	mov	rcx, rdi
	call	glfwSetCursorEnterCallback

; 563  :     glfwSetCursorPosCallback(window, bd->PrevUserCallbackCursorPos);

	mov	rdx, QWORD PTR [rbx+2912]
	mov	rcx, rdi
	call	glfwSetCursorPosCallback

; 564  :     glfwSetMouseButtonCallback(window, bd->PrevUserCallbackMousebutton);

	mov	rdx, QWORD PTR [rbx+2928]
	mov	rcx, rdi
	call	glfwSetMouseButtonCallback

; 565  :     glfwSetScrollCallback(window, bd->PrevUserCallbackScroll);

	mov	rdx, QWORD PTR [rbx+2936]
	mov	rcx, rdi
	call	glfwSetScrollCallback

; 566  :     glfwSetKeyCallback(window, bd->PrevUserCallbackKey);

	mov	rdx, QWORD PTR [rbx+2944]
	mov	rcx, rdi
	call	glfwSetKeyCallback

; 567  :     glfwSetCharCallback(window, bd->PrevUserCallbackChar);

	mov	rdx, QWORD PTR [rbx+2952]
	mov	rcx, rdi
	call	glfwSetCharCallback

; 568  :     glfwSetMonitorCallback(bd->PrevUserCallbackMonitor);

	mov	rcx, QWORD PTR [rbx+2960]
	call	glfwSetMonitorCallback

; 569  :     bd->InstalledCallbacks = false;

	mov	BYTE PTR [rbx+2896], sil

; 570  :     bd->PrevUserCallbackWindowFocus = nullptr;

	mov	QWORD PTR [rbx+2904], rsi

; 571  :     bd->PrevUserCallbackCursorEnter = nullptr;

	mov	QWORD PTR [rbx+2920], rsi

; 572  :     bd->PrevUserCallbackCursorPos = nullptr;

	mov	QWORD PTR [rbx+2912], rsi

; 573  :     bd->PrevUserCallbackMousebutton = nullptr;

	mov	QWORD PTR [rbx+2928], rsi

; 574  :     bd->PrevUserCallbackScroll = nullptr;

	mov	QWORD PTR [rbx+2936], rsi

; 575  :     bd->PrevUserCallbackKey = nullptr;

	mov	QWORD PTR [rbx+2944], rsi

; 576  :     bd->PrevUserCallbackChar = nullptr;

	mov	QWORD PTR [rbx+2952], rsi

; 577  :     bd->PrevUserCallbackMonitor = nullptr;

	mov	QWORD PTR [rbx+2960], rsi

; 578  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?ImGui_ImplGlfw_RestoreCallbacks@@YAXPEAUGLFWwindow@@@Z ENDP ; ImGui_ImplGlfw_RestoreCallbacks
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?ImGui_ImplGlfw_Init@@YA_NPEAUGLFWwindow@@_NW4GlfwClientApi@@@Z
_TEXT	SEGMENT
window$ = 64
install_callbacks$dead$ = 72
client_api$dead$ = 80
?ImGui_ImplGlfw_Init@@YA_NPEAUGLFWwindow@@_NW4GlfwClientApi@@@Z PROC ; ImGui_ImplGlfw_Init, COMDAT

; 591  : {

	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 592  :     ImGuiIO& io = ImGui::GetIO();

	mov	rbp, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	r14, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	rbp, rbp
	je	SHORT $LN9@ImGui_Impl

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rbp+244]
$LN9@ImGui_Impl:

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	mov	ecx, 2976				; 00000ba0H
	call	QWORD PTR __imp_malloc
	mov	rdi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 597  :     ImGui_ImplGlfw_Data* bd = IM_NEW(ImGui_ImplGlfw_Data)();

	test	rax, rax
	je	SHORT $LN5@ImGui_Impl

; 165  :     ImGui_ImplGlfw_Data()   { memset((void*)this, 0, sizeof(*this)); }

	xor	edx, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 269  :     constexpr ImVec2()                      : x(0.0f), y(0.0f) { }

	mov	DWORD PTR [rax+108], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 165  :     ImGui_ImplGlfw_Data()   { memset((void*)this, 0, sizeof(*this)); }

	mov	r8d, 2976				; 00000ba0H
	mov	rcx, rax
	call	memset

; 597  :     ImGui_ImplGlfw_Data* bd = IM_NEW(ImGui_ImplGlfw_Data)();

	jmp	SHORT $LN6@ImGui_Impl
$LN5@ImGui_Impl:
	xor	edi, edi
$LN6@ImGui_Impl:

; 598  :     io.BackendPlatformUserData = (void*)bd;
; 599  :     io.BackendPlatformName = "imgui_impl_glfw";
; 600  :     io.BackendFlags |= ImGuiBackendFlags_HasMouseCursors;         // We can honor GetMouseCursor() values (optional)
; 601  :     io.BackendFlags |= ImGuiBackendFlags_HasSetMousePos;          // We can honor io.WantSetMousePos requests (optional, rarely used)
; 602  : #ifndef __EMSCRIPTEN__
; 603  :     io.BackendFlags |= ImGuiBackendFlags_PlatformHasViewports;    // We can create multi-viewports on the Platform side (optional)
; 604  : #endif
; 605  : #if GLFW_HAS_MOUSE_PASSTHROUGH || (GLFW_HAS_WINDOW_HOVERED && defined(_WIN32))
; 606  :     io.BackendFlags |= ImGuiBackendFlags_HasMouseHoveredViewport; // We can call io.AddMouseViewportEvent() with correct data (optional)

	or	DWORD PTR [rbp+12], 3078		; 00000c06H
	lea	rax, OFFSET FLAT:??_C@_0BA@LCLOGKDG@imgui_impl_glfw@
	mov	QWORD PTR [rbp+136], rax

; 607  : #endif
; 608  : 
; 609  :     bd->Window = window;
; 610  :     bd->Time = 0.0;
; 611  :     bd->WantUpdateMonitors = true;
; 612  : 
; 613  :     io.SetClipboardTextFn = ImGui_ImplGlfw_SetClipboardText;
; 614  :     io.GetClipboardTextFn = ImGui_ImplGlfw_GetClipboardText;
; 615  :     io.ClipboardUserData = bd->Window;
; 616  : 
; 617  :     // Create mouse cursors
; 618  :     // (By design, on X11 cursors are user configurable and some cursors may be missing. When a cursor doesn't exist,
; 619  :     // GLFW will emit an error which will often be printed by the app, so we temporarily disable error reporting.
; 620  :     // Missing cursors will return nullptr and our _UpdateMouseCursor() function will use the Arrow cursor instead.)
; 621  :     GLFWerrorfun prev_error_callback = glfwSetErrorCallback(nullptr);

	xor	ecx, ecx
	mov	QWORD PTR [rbp+152], rdi
	lea	rax, OFFSET FLAT:?ImGui_ImplGlfw_SetClipboardText@@YAXPEAXPEBD@Z ; ImGui_ImplGlfw_SetClipboardText
	mov	QWORD PTR [rdi], r14
	mov	QWORD PTR [rdi+16], 0
	mov	BYTE PTR [rdi+2898], 1
	mov	QWORD PTR [rbp+184], rax
	lea	rax, OFFSET FLAT:?ImGui_ImplGlfw_GetClipboardText@@YAPEBDPEAX@Z ; ImGui_ImplGlfw_GetClipboardText
	mov	QWORD PTR [rbp+176], rax
	mov	rax, QWORD PTR [rdi]
	mov	QWORD PTR [rbp+192], rax
	call	glfwSetErrorCallback

; 622  :     bd->MouseCursors[ImGuiMouseCursor_Arrow] = glfwCreateStandardCursor(GLFW_ARROW_CURSOR);

	mov	ecx, 221185				; 00036001H
	mov	rbx, rax
	call	glfwCreateStandardCursor

; 623  :     bd->MouseCursors[ImGuiMouseCursor_TextInput] = glfwCreateStandardCursor(GLFW_IBEAM_CURSOR);

	mov	ecx, 221186				; 00036002H
	mov	QWORD PTR [rdi+32], rax
	call	glfwCreateStandardCursor

; 624  :     bd->MouseCursors[ImGuiMouseCursor_ResizeNS] = glfwCreateStandardCursor(GLFW_VRESIZE_CURSOR);

	mov	ecx, 221190				; 00036006H
	mov	QWORD PTR [rdi+40], rax
	call	glfwCreateStandardCursor

; 625  :     bd->MouseCursors[ImGuiMouseCursor_ResizeEW] = glfwCreateStandardCursor(GLFW_HRESIZE_CURSOR);

	mov	ecx, 221189				; 00036005H
	mov	QWORD PTR [rdi+56], rax
	call	glfwCreateStandardCursor

; 626  :     bd->MouseCursors[ImGuiMouseCursor_Hand] = glfwCreateStandardCursor(GLFW_HAND_CURSOR);

	mov	ecx, 221188				; 00036004H
	mov	QWORD PTR [rdi+64], rax
	call	glfwCreateStandardCursor

; 627  : #if GLFW_HAS_NEW_CURSORS
; 628  :     bd->MouseCursors[ImGuiMouseCursor_ResizeAll] = glfwCreateStandardCursor(GLFW_RESIZE_ALL_CURSOR);
; 629  :     bd->MouseCursors[ImGuiMouseCursor_ResizeNESW] = glfwCreateStandardCursor(GLFW_RESIZE_NESW_CURSOR);
; 630  :     bd->MouseCursors[ImGuiMouseCursor_ResizeNWSE] = glfwCreateStandardCursor(GLFW_RESIZE_NWSE_CURSOR);
; 631  :     bd->MouseCursors[ImGuiMouseCursor_NotAllowed] = glfwCreateStandardCursor(GLFW_NOT_ALLOWED_CURSOR);
; 632  : #else
; 633  :     bd->MouseCursors[ImGuiMouseCursor_ResizeAll] = glfwCreateStandardCursor(GLFW_ARROW_CURSOR);

	mov	ecx, 221185				; 00036001H
	mov	QWORD PTR [rdi+88], rax
	call	glfwCreateStandardCursor

; 634  :     bd->MouseCursors[ImGuiMouseCursor_ResizeNESW] = glfwCreateStandardCursor(GLFW_ARROW_CURSOR);

	mov	ecx, 221185				; 00036001H
	mov	QWORD PTR [rdi+48], rax
	call	glfwCreateStandardCursor

; 635  :     bd->MouseCursors[ImGuiMouseCursor_ResizeNWSE] = glfwCreateStandardCursor(GLFW_ARROW_CURSOR);

	mov	ecx, 221185				; 00036001H
	mov	QWORD PTR [rdi+72], rax
	call	glfwCreateStandardCursor

; 636  :     bd->MouseCursors[ImGuiMouseCursor_NotAllowed] = glfwCreateStandardCursor(GLFW_ARROW_CURSOR);

	mov	ecx, 221185				; 00036001H
	mov	QWORD PTR [rdi+80], rax
	call	glfwCreateStandardCursor

; 637  : #endif
; 638  :     glfwSetErrorCallback(prev_error_callback);

	mov	rcx, rbx
	mov	QWORD PTR [rdi+96], rax
	call	glfwSetErrorCallback

; 639  : #if GLFW_HAS_GETERROR && !defined(__EMSCRIPTEN__) // Eat errors (see #5908)
; 640  :     (void)glfwGetError(nullptr);

	xor	ecx, ecx
	call	glfwGetError

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rbx, rbx
	je	SHORT $LN24@ImGui_Impl
	mov	rbx, QWORD PTR [rbx+152]
$LN24@ImGui_Impl:

; 544  :     bd->PrevUserCallbackWindowFocus = glfwSetWindowFocusCallback(window, ImGui_ImplGlfw_WindowFocusCallback);

	lea	rdx, OFFSET FLAT:?ImGui_ImplGlfw_WindowFocusCallback@@YAXPEAUGLFWwindow@@H@Z ; ImGui_ImplGlfw_WindowFocusCallback
	mov	rcx, r14
	call	glfwSetWindowFocusCallback

; 545  :     bd->PrevUserCallbackCursorEnter = glfwSetCursorEnterCallback(window, ImGui_ImplGlfw_CursorEnterCallback);

	lea	rdx, OFFSET FLAT:?ImGui_ImplGlfw_CursorEnterCallback@@YAXPEAUGLFWwindow@@H@Z ; ImGui_ImplGlfw_CursorEnterCallback
	mov	QWORD PTR [rbx+2904], rax
	mov	rcx, r14
	call	glfwSetCursorEnterCallback

; 546  :     bd->PrevUserCallbackCursorPos = glfwSetCursorPosCallback(window, ImGui_ImplGlfw_CursorPosCallback);

	lea	rdx, OFFSET FLAT:?ImGui_ImplGlfw_CursorPosCallback@@YAXPEAUGLFWwindow@@NN@Z ; ImGui_ImplGlfw_CursorPosCallback
	mov	QWORD PTR [rbx+2920], rax
	mov	rcx, r14
	call	glfwSetCursorPosCallback

; 547  :     bd->PrevUserCallbackMousebutton = glfwSetMouseButtonCallback(window, ImGui_ImplGlfw_MouseButtonCallback);

	lea	rdx, OFFSET FLAT:?ImGui_ImplGlfw_MouseButtonCallback@@YAXPEAUGLFWwindow@@HHH@Z ; ImGui_ImplGlfw_MouseButtonCallback
	mov	QWORD PTR [rbx+2912], rax
	mov	rcx, r14
	call	glfwSetMouseButtonCallback

; 548  :     bd->PrevUserCallbackScroll = glfwSetScrollCallback(window, ImGui_ImplGlfw_ScrollCallback);

	lea	rdx, OFFSET FLAT:?ImGui_ImplGlfw_ScrollCallback@@YAXPEAUGLFWwindow@@NN@Z ; ImGui_ImplGlfw_ScrollCallback
	mov	QWORD PTR [rbx+2928], rax
	mov	rcx, r14
	call	glfwSetScrollCallback

; 549  :     bd->PrevUserCallbackKey = glfwSetKeyCallback(window, ImGui_ImplGlfw_KeyCallback);

	lea	rdx, OFFSET FLAT:?ImGui_ImplGlfw_KeyCallback@@YAXPEAUGLFWwindow@@HHHH@Z ; ImGui_ImplGlfw_KeyCallback
	mov	QWORD PTR [rbx+2936], rax
	mov	rcx, r14
	call	glfwSetKeyCallback

; 550  :     bd->PrevUserCallbackChar = glfwSetCharCallback(window, ImGui_ImplGlfw_CharCallback);

	lea	rdx, OFFSET FLAT:?ImGui_ImplGlfw_CharCallback@@YAXPEAUGLFWwindow@@I@Z ; ImGui_ImplGlfw_CharCallback
	mov	QWORD PTR [rbx+2944], rax
	mov	rcx, r14
	call	glfwSetCharCallback

; 551  :     bd->PrevUserCallbackMonitor = glfwSetMonitorCallback(ImGui_ImplGlfw_MonitorCallback);

	lea	rcx, OFFSET FLAT:?ImGui_ImplGlfw_MonitorCallback@@YAXPEAUGLFWmonitor@@H@Z ; ImGui_ImplGlfw_MonitorCallback
	mov	QWORD PTR [rbx+2952], rax
	call	glfwSetMonitorCallback
	mov	QWORD PTR [rbx+2960], rax

; 552  :     bd->InstalledCallbacks = true;

	mov	BYTE PTR [rbx+2896], 1

; 641  : #endif
; 642  : 
; 643  :     // Chain GLFW callbacks: our callbacks will call the user's previously installed callbacks, if any.
; 644  :     if (install_callbacks)
; 645  :         ImGui_ImplGlfw_InstallCallbacks(window);
; 646  :     // Register Emscripten Wheel callback to workaround issue in Emscripten GLFW Emulation (#6096)
; 647  :     // We intentionally do not check 'if (install_callbacks)' here, as some users may set it to false and call GLFW callback themselves.
; 648  :     // FIXME: May break chaining in case user registered their own Emscripten callback?
; 649  : #ifdef __EMSCRIPTEN__
; 650  :     emscripten_set_wheel_callback(EMSCRIPTEN_EVENT_TARGET_DOCUMENT, nullptr, false, ImGui_ImplEmscripten_WheelCallback);
; 651  : #endif
; 652  : 
; 653  :     // Update monitors the first time (note: monitor callback are broken in GLFW 3.2 and earlier, see github.com/glfw/glfw/issues/784)
; 654  :     ImGui_ImplGlfw_UpdateMonitors();

	call	?ImGui_ImplGlfw_UpdateMonitors@@YAXXZ	; ImGui_ImplGlfw_UpdateMonitors

; 655  :     glfwSetMonitorCallback(ImGui_ImplGlfw_MonitorCallback);

	lea	rcx, OFFSET FLAT:?ImGui_ImplGlfw_MonitorCallback@@YAXPEAUGLFWmonitor@@H@Z ; ImGui_ImplGlfw_MonitorCallback
	call	glfwSetMonitorCallback
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rcx, QWORD PTR [rax+18984]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 659  :     main_viewport->PlatformHandle = (void*)bd->Window;

	mov	rax, QWORD PTR [rdi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 13999:     return g.Viewports[0];

	mov	r14, QWORD PTR [rcx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 659  :     main_viewport->PlatformHandle = (void*)bd->Window;

	mov	QWORD PTR [r14+72], rax

; 660  : #ifdef _WIN32
; 661  :     main_viewport->PlatformHandleRaw = glfwGetWin32Window(bd->Window);

	mov	rcx, QWORD PTR [rdi]
	call	glfwGetWin32Window
	mov	QWORD PTR [r14+80], rax

; 662  : #elif defined(__APPLE__)
; 663  :     main_viewport->PlatformHandleRaw = (void*)glfwGetCocoaWindow(bd->Window);
; 664  : #else
; 665  :     IM_UNUSED(main_viewport);
; 666  : #endif
; 667  :     if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)

	test	DWORD PTR [rbp+8], 1024			; 00000400H
	je	$LN3@ImGui_Impl

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rcx, rcx
	je	SHORT $LN36@ImGui_Impl
	mov	rbx, QWORD PTR [rcx+152]
	jmp	SHORT $LN37@ImGui_Impl
$LN36@ImGui_Impl:
	xor	ebx, ebx
$LN37@ImGui_Impl:

; 1250 :     platform_io.Platform_CreateWindow = ImGui_ImplGlfw_CreateWindow;

	lea	rax, OFFSET FLAT:?ImGui_ImplGlfw_CreateWindow@@YAXPEAUImGuiViewport@@@Z ; ImGui_ImplGlfw_CreateWindow
	mov	QWORD PTR [rcx+14336], rax

; 1251 :     platform_io.Platform_DestroyWindow = ImGui_ImplGlfw_DestroyWindow;

	lea	rax, OFFSET FLAT:?ImGui_ImplGlfw_DestroyWindow@@YAXPEAUImGuiViewport@@@Z ; ImGui_ImplGlfw_DestroyWindow
	mov	QWORD PTR [rcx+14344], rax

; 1252 :     platform_io.Platform_ShowWindow = ImGui_ImplGlfw_ShowWindow;

	lea	rax, OFFSET FLAT:?ImGui_ImplGlfw_ShowWindow@@YAXPEAUImGuiViewport@@@Z ; ImGui_ImplGlfw_ShowWindow
	mov	QWORD PTR [rcx+14352], rax

; 1253 :     platform_io.Platform_SetWindowPos = ImGui_ImplGlfw_SetWindowPos;

	lea	rax, OFFSET FLAT:?ImGui_ImplGlfw_SetWindowPos@@YAXPEAUImGuiViewport@@UImVec2@@@Z ; ImGui_ImplGlfw_SetWindowPos
	mov	QWORD PTR [rcx+14360], rax

; 1254 :     platform_io.Platform_GetWindowPos = ImGui_ImplGlfw_GetWindowPos;

	lea	rax, OFFSET FLAT:?ImGui_ImplGlfw_GetWindowPos@@YA?AUImVec2@@PEAUImGuiViewport@@@Z ; ImGui_ImplGlfw_GetWindowPos
	mov	QWORD PTR [rcx+14368], rax

; 1255 :     platform_io.Platform_SetWindowSize = ImGui_ImplGlfw_SetWindowSize;

	lea	rax, OFFSET FLAT:?ImGui_ImplGlfw_SetWindowSize@@YAXPEAUImGuiViewport@@UImVec2@@@Z ; ImGui_ImplGlfw_SetWindowSize
	mov	QWORD PTR [rcx+14376], rax

; 1256 :     platform_io.Platform_GetWindowSize = ImGui_ImplGlfw_GetWindowSize;

	lea	rax, OFFSET FLAT:?ImGui_ImplGlfw_GetWindowSize@@YA?AUImVec2@@PEAUImGuiViewport@@@Z ; ImGui_ImplGlfw_GetWindowSize
	mov	QWORD PTR [rcx+14384], rax

; 1257 :     platform_io.Platform_SetWindowFocus = ImGui_ImplGlfw_SetWindowFocus;

	lea	rax, OFFSET FLAT:?ImGui_ImplGlfw_SetWindowFocus@@YAXPEAUImGuiViewport@@@Z ; ImGui_ImplGlfw_SetWindowFocus
	mov	QWORD PTR [rcx+14392], rax

; 1258 :     platform_io.Platform_GetWindowFocus = ImGui_ImplGlfw_GetWindowFocus;

	lea	rax, OFFSET FLAT:?ImGui_ImplGlfw_GetWindowFocus@@YA_NPEAUImGuiViewport@@@Z ; ImGui_ImplGlfw_GetWindowFocus
	mov	QWORD PTR [rcx+14400], rax

; 1259 :     platform_io.Platform_GetWindowMinimized = ImGui_ImplGlfw_GetWindowMinimized;

	lea	rax, OFFSET FLAT:?ImGui_ImplGlfw_GetWindowMinimized@@YA_NPEAUImGuiViewport@@@Z ; ImGui_ImplGlfw_GetWindowMinimized
	mov	QWORD PTR [rcx+14408], rax

; 1260 :     platform_io.Platform_SetWindowTitle = ImGui_ImplGlfw_SetWindowTitle;

	lea	rax, OFFSET FLAT:?ImGui_ImplGlfw_SetWindowTitle@@YAXPEAUImGuiViewport@@PEBD@Z ; ImGui_ImplGlfw_SetWindowTitle
	mov	QWORD PTR [rcx+14416], rax

; 1261 :     platform_io.Platform_RenderWindow = ImGui_ImplGlfw_RenderWindow;

	lea	rax, OFFSET FLAT:?ImGui_ImplGlfw_RenderWindow@@YAXPEAUImGuiViewport@@PEAX@Z ; ImGui_ImplGlfw_RenderWindow
	mov	QWORD PTR [rcx+14440], rax

; 1262 :     platform_io.Platform_SwapBuffers = ImGui_ImplGlfw_SwapBuffers;

	lea	rax, OFFSET FLAT:?ImGui_ImplGlfw_SwapBuffers@@YAXPEAUImGuiViewport@@PEAX@Z ; ImGui_ImplGlfw_SwapBuffers
	mov	QWORD PTR [rcx+14448], rax

; 1263 : #if GLFW_HAS_WINDOW_ALPHA
; 1264 :     platform_io.Platform_SetWindowAlpha = ImGui_ImplGlfw_SetWindowAlpha;

	lea	rax, OFFSET FLAT:?ImGui_ImplGlfw_SetWindowAlpha@@YAXPEAUImGuiViewport@@M@Z ; ImGui_ImplGlfw_SetWindowAlpha
	mov	QWORD PTR [rcx+14424], rax

; 1265 : #endif
; 1266 : #if GLFW_HAS_VULKAN
; 1267 :     platform_io.Platform_CreateVkSurface = ImGui_ImplGlfw_CreateVkSurface;

	lea	rax, OFFSET FLAT:?ImGui_ImplGlfw_CreateVkSurface@@YAHPEAUImGuiViewport@@_KPEBXPEA_K@Z ; ImGui_ImplGlfw_CreateVkSurface
	mov	QWORD PTR [rcx+14472], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	rax, QWORD PTR [rcx+18984]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 13999:     return g.Viewports[0];

	mov	rbp, QWORD PTR [rax]

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	rcx, rcx
	je	SHORT $LN43@ImGui_Impl

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rcx+244]
$LN43@ImGui_Impl:

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	mov	ecx, 24
	call	QWORD PTR __imp_malloc
	mov	rcx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 1273 :     ImGui_ImplGlfw_ViewportData* vd = IM_NEW(ImGui_ImplGlfw_ViewportData)();

	test	rax, rax
	je	SHORT $LN31@ImGui_Impl

; 962  :     ImGui_ImplGlfw_ViewportData()  { Window = nullptr; WindowOwned = false; IgnoreWindowSizeEventFrame = IgnoreWindowPosEventFrame = -1; }

	mov	QWORD PTR [rax], 0
	mov	BYTE PTR [rax+8], 0
	mov	QWORD PTR [rax+12], -1

; 1273 :     ImGui_ImplGlfw_ViewportData* vd = IM_NEW(ImGui_ImplGlfw_ViewportData)();

	jmp	SHORT $LN32@ImGui_Impl
$LN31@ImGui_Impl:
	xor	ecx, ecx
$LN32@ImGui_Impl:

; 1274 :     vd->Window = bd->Window;

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rcx], rax

; 1275 :     vd->WindowOwned = false;

	mov	BYTE PTR [rcx+8], 0

; 1276 :     main_viewport->PlatformUserData = vd;

	mov	QWORD PTR [rbp+64], rcx

; 1277 :     main_viewport->PlatformHandle = (void*)bd->Window;

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rbp+72], rax
$LN3@ImGui_Impl:

; 668  :         ImGui_ImplGlfw_InitPlatformInterface();
; 669  : 
; 670  :     // Windows: register a WndProc hook so we can intercept some messages.
; 671  : #ifdef _WIN32
; 672  :     bd->GlfwWndProc = (WNDPROC)::GetWindowLongPtr((HWND)main_viewport->PlatformHandleRaw, GWLP_WNDPROC);

	mov	rcx, QWORD PTR [r14+80]
	mov	edx, -4
	call	QWORD PTR __imp_GetWindowLongPtrW
	mov	QWORD PTR [rdi+2968], rax

; 673  :     IM_ASSERT(bd->GlfwWndProc != nullptr);
; 674  :     ::SetWindowLongPtr((HWND)main_viewport->PlatformHandleRaw, GWLP_WNDPROC, (LONG_PTR)ImGui_ImplGlfw_WndProc);

	lea	r8, OFFSET FLAT:?ImGui_ImplGlfw_WndProc@@YA_JPEAUHWND__@@I_K_J@Z ; ImGui_ImplGlfw_WndProc
	mov	rcx, QWORD PTR [r14+80]
	mov	edx, -4
	call	QWORD PTR __imp_SetWindowLongPtrW

; 675  : #endif
; 676  : 
; 677  :     bd->ClientApi = client_api;
; 678  :     return true;
; 679  : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	al, 1
	mov	DWORD PTR [rdi+8], 1
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rbp
	ret	0
?ImGui_ImplGlfw_Init@@YA_NPEAUGLFWwindow@@_NW4GlfwClientApi@@@Z ENDP ; ImGui_ImplGlfw_Init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?ImGui_ImplGlfw_InitForOpenGL@@YA_NPEAUGLFWwindow@@_N@Z
_TEXT	SEGMENT
window$dead$ = 8
install_callbacks$dead$ = 16
?ImGui_ImplGlfw_InitForOpenGL@@YA_NPEAUGLFWwindow@@_N@Z PROC ; ImGui_ImplGlfw_InitForOpenGL, COMDAT

; 683  :     return ImGui_ImplGlfw_Init(window, install_callbacks, GlfwClientApi_OpenGL);

	mov	rcx, QWORD PTR ?Window@@3PEAUGLFWwindow@@EA ; Window
	jmp	?ImGui_ImplGlfw_Init@@YA_NPEAUGLFWwindow@@_NW4GlfwClientApi@@@Z ; ImGui_ImplGlfw_Init
?ImGui_ImplGlfw_InitForOpenGL@@YA_NPEAUGLFWwindow@@_N@Z ENDP ; ImGui_ImplGlfw_InitForOpenGL
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?ImGui_ImplGlfw_Shutdown@@YAXXZ
_TEXT	SEGMENT
?ImGui_ImplGlfw_Shutdown@@YAXXZ PROC			; ImGui_ImplGlfw_Shutdown, COMDAT

; 697  : {

$LN44:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	mov	rbp, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	xor	r14d, r14d
	test	rbp, rbp
	je	SHORT $LN9@ImGui_Impl
	mov	rsi, QWORD PTR [rbp+152]
	jmp	SHORT $LN10@ImGui_Impl
$LN9@ImGui_Impl:
	mov	rsi, r14
$LN10@ImGui_Impl:

; 1282 :     ImGui::DestroyPlatformWindows();

	call	?DestroyPlatformWindows@ImGui@@YAXXZ	; ImGui::DestroyPlatformWindows

; 698  :     ImGui_ImplGlfw_Data* bd = ImGui_ImplGlfw_GetBackendData();
; 699  :     IM_ASSERT(bd != nullptr && "No platform backend to shutdown, or already shutdown?");
; 700  :     ImGuiIO& io = ImGui::GetIO();
; 701  : 
; 702  :     ImGui_ImplGlfw_ShutdownPlatformInterface();
; 703  : 
; 704  :     if (bd->InstalledCallbacks)

	cmp	BYTE PTR [rsi+2896], r14b
	je	$LN5@ImGui_Impl

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 705  :         ImGui_ImplGlfw_RestoreCallbacks(bd->Window);

	mov	rdi, QWORD PTR [rsi]

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	test	rbx, rbx
	je	SHORT $LN17@ImGui_Impl
	mov	rbx, QWORD PTR [rbx+152]
	jmp	SHORT $LN18@ImGui_Impl
$LN17@ImGui_Impl:
	mov	rbx, r14
$LN18@ImGui_Impl:

; 561  :     glfwSetWindowFocusCallback(window, bd->PrevUserCallbackWindowFocus);

	mov	rdx, QWORD PTR [rbx+2904]
	mov	rcx, rdi
	call	glfwSetWindowFocusCallback

; 562  :     glfwSetCursorEnterCallback(window, bd->PrevUserCallbackCursorEnter);

	mov	rdx, QWORD PTR [rbx+2920]
	mov	rcx, rdi
	call	glfwSetCursorEnterCallback

; 563  :     glfwSetCursorPosCallback(window, bd->PrevUserCallbackCursorPos);

	mov	rdx, QWORD PTR [rbx+2912]
	mov	rcx, rdi
	call	glfwSetCursorPosCallback

; 564  :     glfwSetMouseButtonCallback(window, bd->PrevUserCallbackMousebutton);

	mov	rdx, QWORD PTR [rbx+2928]
	mov	rcx, rdi
	call	glfwSetMouseButtonCallback

; 565  :     glfwSetScrollCallback(window, bd->PrevUserCallbackScroll);

	mov	rdx, QWORD PTR [rbx+2936]
	mov	rcx, rdi
	call	glfwSetScrollCallback

; 566  :     glfwSetKeyCallback(window, bd->PrevUserCallbackKey);

	mov	rdx, QWORD PTR [rbx+2944]
	mov	rcx, rdi
	call	glfwSetKeyCallback

; 567  :     glfwSetCharCallback(window, bd->PrevUserCallbackChar);

	mov	rdx, QWORD PTR [rbx+2952]
	mov	rcx, rdi
	call	glfwSetCharCallback

; 568  :     glfwSetMonitorCallback(bd->PrevUserCallbackMonitor);

	mov	rcx, QWORD PTR [rbx+2960]
	call	glfwSetMonitorCallback

; 569  :     bd->InstalledCallbacks = false;

	mov	BYTE PTR [rbx+2896], r14b

; 570  :     bd->PrevUserCallbackWindowFocus = nullptr;

	mov	QWORD PTR [rbx+2904], r14

; 571  :     bd->PrevUserCallbackCursorEnter = nullptr;

	mov	QWORD PTR [rbx+2920], r14

; 572  :     bd->PrevUserCallbackCursorPos = nullptr;

	mov	QWORD PTR [rbx+2912], r14

; 573  :     bd->PrevUserCallbackMousebutton = nullptr;

	mov	QWORD PTR [rbx+2928], r14

; 574  :     bd->PrevUserCallbackScroll = nullptr;

	mov	QWORD PTR [rbx+2936], r14

; 575  :     bd->PrevUserCallbackKey = nullptr;

	mov	QWORD PTR [rbx+2944], r14

; 576  :     bd->PrevUserCallbackChar = nullptr;

	mov	QWORD PTR [rbx+2952], r14

; 577  :     bd->PrevUserCallbackMonitor = nullptr;

	mov	QWORD PTR [rbx+2960], r14
$LN5@ImGui_Impl:
	lea	rbx, QWORD PTR [rsi+32]
	mov	edi, 9
	npad	1
$LL4@ImGui_Impl:

; 706  : 
; 707  :     for (ImGuiMouseCursor cursor_n = 0; cursor_n < ImGuiMouseCursor_COUNT; cursor_n++)
; 708  :         glfwDestroyCursor(bd->MouseCursors[cursor_n]);

	mov	rcx, QWORD PTR [rbx]
	call	glfwDestroyCursor
	lea	rbx, QWORD PTR [rbx+8]
	sub	rdi, 1
	jne	SHORT $LL4@ImGui_Impl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 713  :     ::SetWindowLongPtr((HWND)main_viewport->PlatformHandleRaw, GWLP_WNDPROC, (LONG_PTR)bd->GlfwWndProc);

	lea	edx, QWORD PTR [rdi-4]
	mov	r8, QWORD PTR [rsi+2968]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	rcx, QWORD PTR [rax+18984]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 713  :     ::SetWindowLongPtr((HWND)main_viewport->PlatformHandleRaw, GWLP_WNDPROC, (LONG_PTR)bd->GlfwWndProc);

	mov	rcx, QWORD PTR [rcx]
	mov	rcx, QWORD PTR [rcx+80]
	call	QWORD PTR __imp_SetWindowLongPtrW
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 714  :     bd->GlfwWndProc = nullptr;

	mov	QWORD PTR [rsi+2968], r14

; 715  : #endif
; 716  : 
; 717  :     io.BackendPlatformName = nullptr;
; 718  :     io.BackendPlatformUserData = nullptr;
; 719  :     io.BackendFlags &= ~(ImGuiBackendFlags_HasMouseCursors | ImGuiBackendFlags_HasSetMousePos | ImGuiBackendFlags_HasGamepad | ImGuiBackendFlags_PlatformHasViewports | ImGuiBackendFlags_HasMouseHoveredViewport);

	and	DWORD PTR [rbp+12], -3080		; fffffffffffff3f8H
	mov	QWORD PTR [rbp+136], r14
	mov	QWORD PTR [rbp+152], r14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN28@ImGui_Impl

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN28@ImGui_Impl:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	mov	rcx, rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 721  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	rex_jmp	QWORD PTR __imp_free
?ImGui_ImplGlfw_Shutdown@@YAXXZ ENDP			; ImGui_ImplGlfw_Shutdown
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?ImGui_ImplGlfw_UpdateMouseData@@YAXXZ
_TEXT	SEGMENT
mouse_viewport_id$1$ = 32
e$2 = 40
mouse_y$3 = 72
mouse_x$4 = 80
window_x$5 = 88
window_y$6 = 92
__$ArrayPad$ = 96
?ImGui_ImplGlfw_UpdateMouseData@@YAXXZ PROC		; ImGui_ImplGlfw_UpdateMouseData, COMDAT

; 724  : {

	mov	r11, rsp
	push	rbp
	push	rdi
	sub	rsp, 168				; 000000a8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	QWORD PTR [r11-24], r13

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	xor	edi, edi

; 724  : {

	mov	QWORD PTR [r11-32], r14

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	mov	r14, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 724  : {

	mov	QWORD PTR [r11-40], r15
	movaps	XMMWORD PTR [r11-56], xmm6
	movaps	XMMWORD PTR [rsp+112], xmm7

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	test	r14, r14
	je	SHORT $LN14@ImGui_Impl
	mov	r13, QWORD PTR [r14+152]
	jmp	SHORT $LN15@ImGui_Impl
$LN14@ImGui_Impl:
	mov	r13, rdi
$LN15@ImGui_Impl:

; 725  :     ImGui_ImplGlfw_Data* bd = ImGui_ImplGlfw_GetBackendData();
; 726  :     ImGuiIO& io = ImGui::GetIO();

	lea	rbp, QWORD PTR [r14+8]
	mov	QWORD PTR [rsp+192], rbx

; 727  :     ImGuiPlatformIO& platform_io = ImGui::GetPlatformIO();
; 728  : 
; 729  : 
; 730  :     ImGuiID mouse_viewport_id = 0;

	mov	r9d, edi

; 731  :     const ImVec2 mouse_pos_prev = io.MousePos;

	movss	xmm6, DWORD PTR [rbp+3584]

; 732  :     for (int n = 0; n < platform_io.Viewports.Size; n++)

	mov	r15d, edi
	movss	xmm7, DWORD PTR [rbp+3588]
	mov	DWORD PTR mouse_viewport_id$1$[rsp], edi
	cmp	DWORD PTR [r14+14536], edi
	jle	$LN3@ImGui_Impl
	mov	QWORD PTR [rsp+200], rsi
	mov	QWORD PTR [rsp+208], r12
	mov	r12, rdi
	npad	15
$LL4@ImGui_Impl:

; 733  :     {
; 734  :         ImGuiViewport* viewport = platform_io.Viewports[n];

	mov	rax, QWORD PTR [r14+14544]

; 735  :         GLFWwindow* window = (GLFWwindow*)viewport->PlatformHandle;
; 736  : 
; 737  : #ifdef __EMSCRIPTEN__
; 738  :         const bool is_window_focused = true;
; 739  : #else
; 740  :         const bool is_window_focused = glfwGetWindowAttrib(window, GLFW_FOCUSED) != 0;

	mov	edx, 131073				; 00020001H
	mov	rdi, QWORD PTR [r12+rax]
	mov	rsi, QWORD PTR [rdi+72]
	mov	rcx, rsi
	call	glfwGetWindowAttrib
	test	eax, eax

; 741  : #endif
; 742  :         if (is_window_focused)

	je	$LN7@ImGui_Impl

; 743  :         {
; 744  :             // (Optional) Set OS mouse position from Dear ImGui if requested (rarely used, only when ImGuiConfigFlags_NavEnableSetMousePos is enabled by user)
; 745  :             // When multi-viewports are enabled, all Dear ImGui positions are same as OS positions.
; 746  :             if (io.WantSetMousePos)

	cmp	BYTE PTR [rbp+211], 0
	je	SHORT $LN6@ImGui_Impl

; 747  :                 glfwSetCursorPos(window, (double)(mouse_pos_prev.x - viewport->Pos.x), (double)(mouse_pos_prev.y - viewport->Pos.y));

	movaps	xmm1, xmm6
	movaps	xmm0, xmm7
	subss	xmm0, DWORD PTR [rdi+12]
	subss	xmm1, DWORD PTR [rdi+8]
	xorps	xmm2, xmm2
	mov	rcx, rsi
	cvtss2sd xmm2, xmm0
	cvtss2sd xmm1, xmm1
	call	glfwSetCursorPos
$LN6@ImGui_Impl:

; 748  : 
; 749  :             // (Optional) Fallback to provide mouse position when focused (ImGui_ImplGlfw_CursorPosCallback already provides this when hovered or captured)
; 750  :             if (bd->MouseWindow == nullptr)

	cmp	QWORD PTR [r13+24], 0
	jne	$LN7@ImGui_Impl

; 751  :             {
; 752  :                 double mouse_x, mouse_y;
; 753  :                 glfwGetCursorPos(window, &mouse_x, &mouse_y);

	lea	r8, QWORD PTR mouse_y$3[rsp]
	mov	rcx, rsi
	lea	rdx, QWORD PTR mouse_x$4[rsp]
	call	glfwGetCursorPos

; 754  :                 if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)

	test	DWORD PTR [rbp], 1024			; 00000400H
	je	SHORT $LN53@ImGui_Impl

; 755  :                 {
; 756  :                     // Single viewport mode: mouse position in client window coordinates (io.MousePos is (0,0) when the mouse is on the upper-left corner of the app window)
; 757  :                     // Multi-viewport mode: mouse position in OS absolute coordinates (io.MousePos is (0,0) when the mouse is on the upper-left of the primary monitor)
; 758  :                     int window_x, window_y;
; 759  :                     glfwGetWindowPos(window, &window_x, &window_y);

	lea	r8, QWORD PTR window_y$6[rsp]
	mov	rcx, rsi
	lea	rdx, QWORD PTR window_x$5[rsp]
	call	glfwGetWindowPos

; 760  :                     mouse_x += window_x;

	movsd	xmm2, QWORD PTR mouse_x$4[rsp]
	movd	xmm0, DWORD PTR window_x$5[rsp]
	movd	xmm1, DWORD PTR window_y$6[rsp]
	cvtdq2pd xmm0, xmm0

; 761  :                     mouse_y += window_y;

	cvtdq2pd xmm1, xmm1
	addsd	xmm2, xmm0
	movsd	xmm0, QWORD PTR mouse_y$3[rsp]
	addsd	xmm0, xmm1
	movsd	QWORD PTR mouse_x$4[rsp], xmm2
	movsd	QWORD PTR mouse_y$3[rsp], xmm0
	jmp	SHORT $LN8@ImGui_Impl
$LN53@ImGui_Impl:

; 754  :                 if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)

	movsd	xmm0, QWORD PTR mouse_y$3[rsp]
	movsd	xmm2, QWORD PTR mouse_x$4[rsp]
$LN8@ImGui_Impl:

; 762  :                 }
; 763  :                 bd->LastValidMousePos = ImVec2((float)mouse_x, (float)mouse_y);

	cvtpd2ps xmm1, xmm2

; 764  :                 io.AddMousePosEvent((float)mouse_x, (float)mouse_y);

	mov	rcx, rbp
	cvtpd2ps xmm2, xmm0
	movss	DWORD PTR [r13+104], xmm1
	movss	DWORD PTR [r13+108], xmm2
	call	?AddMousePosEvent@ImGuiIO@@QEAAXMM@Z	; ImGuiIO::AddMousePosEvent
$LN7@ImGui_Impl:

; 765  :             }
; 766  :         }
; 767  : 
; 768  :         // (Optional) When using multiple viewports: call io.AddMouseViewportEvent() with the viewport the OS mouse cursor is hovering.
; 769  :         // If ImGuiBackendFlags_HasMouseHoveredViewport is not set by the backend, Dear imGui will ignore this field and infer the information using its flawed heuristic.
; 770  :         // - [X] GLFW >= 3.3 backend ON WINDOWS ONLY does correctly ignore viewports with the _NoInputs flag.
; 771  :         // - [!] GLFW <= 3.2 backend CANNOT correctly ignore viewports with the _NoInputs flag, and CANNOT reported Hovered Viewport because of mouse capture.
; 772  :         //       Some backend are not able to handle that correctly. If a backend report an hovered viewport that has the _NoInputs flag (e.g. when dragging a window
; 773  :         //       for docking, the viewport has the _NoInputs flag in order to allow us to find the viewport under), then Dear ImGui is forced to ignore the value reported
; 774  :         //       by the backend, and use its flawed heuristic to guess the viewport behind.
; 775  :         // - [X] GLFW backend correctly reports this regardless of another viewport behind focused and dragged from (we need this to find a useful drag and drop target).
; 776  :         // FIXME: This is currently only correct on Win32. See what we do below with the WM_NCHITTEST, missing an equivalent for other systems.
; 777  :         // See https://github.com/glfw/glfw/issues/1236 if you want to help in making this a GLFW feature.
; 778  : #if GLFW_HAS_MOUSE_PASSTHROUGH || (GLFW_HAS_WINDOW_HOVERED && defined(_WIN32))
; 779  :         const bool window_no_input = (viewport->Flags & ImGuiViewportFlags_NoInputs) != 0;

	mov	ebx, DWORD PTR [rdi+4]

; 780  : #if GLFW_HAS_MOUSE_PASSTHROUGH
; 781  :         glfwSetWindowAttrib(window, GLFW_MOUSE_PASSTHROUGH, window_no_input);
; 782  : #endif
; 783  :         if (glfwGetWindowAttrib(window, GLFW_HOVERED) && !window_no_input)

	mov	edx, 131083				; 0002000bH
	shr	ebx, 7
	mov	rcx, rsi
	and	bl, 1
	call	glfwGetWindowAttrib
	test	eax, eax
	je	SHORT $LN55@ImGui_Impl
	test	bl, bl
	jne	SHORT $LN55@ImGui_Impl

; 784  :             mouse_viewport_id = viewport->ID;

	mov	r9d, DWORD PTR [rdi]
	mov	DWORD PTR mouse_viewport_id$1$[rsp], r9d
	jmp	SHORT $LN2@ImGui_Impl
$LN55@ImGui_Impl:

; 732  :     for (int n = 0; n < platform_io.Viewports.Size; n++)

	mov	r9d, DWORD PTR mouse_viewport_id$1$[rsp]
$LN2@ImGui_Impl:
	inc	r15d
	add	r12, 8
	cmp	r15d, DWORD PTR [r14+14536]
	jl	$LL4@ImGui_Impl
	mov	r12, QWORD PTR [rsp+208]
	xor	edi, edi
	mov	rsi, QWORD PTR [rsp+200]
$LN3@ImGui_Impl:

; 790  :     if (io.BackendFlags & ImGuiBackendFlags_HasMouseHoveredViewport)

	test	DWORD PTR [rbp+4], 2048			; 00000800H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1630 : {

	movaps	xmm7, XMMWORD PTR [rsp+112]
	movaps	xmm6, XMMWORD PTR [rsp+128]
	mov	r15, QWORD PTR [rsp+144]
	mov	r14, QWORD PTR [rsp+152]
	mov	r13, QWORD PTR [rsp+160]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 790  :     if (io.BackendFlags & ImGuiBackendFlags_HasMouseHoveredViewport)

	je	$LN20@ImGui_Impl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1634 :     if (!AppAcceptingEvents)

	cmp	BYTE PTR [rbp+14305], 0
	mov	rdx, QWORD PTR [rbp+3576]
	je	$LN20@ImGui_Impl

; 1450 :     for (int n = g.InputEventsQueue.Size - 1; n >= 0; n--)

	lea	rbx, QWORD PTR [rdx+16272]
	mov	r8d, DWORD PTR [rbx]
	lea	eax, DWORD PTR [r8-1]
	test	eax, eax
	js	SHORT $LN24@ImGui_Impl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rcx, eax
	imul	rax, rcx, 28
	add	rax, QWORD PTR [rdx+16280]
	npad	1
$LL29@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1453 :         if (e->Type != type)

	cmp	DWORD PTR [rax], 4
	je	SHORT $LN26@ImGui_Impl

; 1450 :     for (int n = g.InputEventsQueue.Size - 1; n >= 0; n--)

	sub	rax, 28
	sub	rcx, 1
	jns	SHORT $LL29@ImGui_Impl
$LN24@ImGui_Impl:

; 1639 :     const ImGuiID latest_viewport_id = latest_event ? latest_event->MouseViewport.HoveredViewportID : g.IO.MouseHoveredViewport;

	mov	ecx, DWORD PTR [rdx+3620]
$LN25@ImGui_Impl:

; 1640 :     if (latest_viewport_id == viewport_id)

	cmp	ecx, r9d
	je	SHORT $LN20@ImGui_Impl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	ecx, DWORD PTR [rbx+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1645 :     e.Source = ImGuiInputSource_Mouse;

	mov	QWORD PTR e$2[rsp+4], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1353 :     ImGuiInputEvent() { memset(this, 0, sizeof(*this)); }

	mov	QWORD PTR e$2[rsp+16], rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1644 :     e.Type = ImGuiInputEventType_MouseViewport;

	mov	DWORD PTR e$2[rsp], 4

; 1646 :     e.MouseViewport.HoveredViewportID = viewport_id;

	mov	DWORD PTR e$2[rsp+12], r9d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	cmp	r8d, ecx
	jne	SHORT $LN39@ImGui_Impl
	inc	r8d

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN43@ImGui_Impl
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN44@ImGui_Impl
$LN26@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1639 :     const ImGuiID latest_viewport_id = latest_event ? latest_event->MouseViewport.HoveredViewportID : g.IO.MouseHoveredViewport;

	mov	ecx, DWORD PTR [rax+12]
	jmp	SHORT $LN25@ImGui_Impl
$LN43@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	eax, 8
$LN44@ImGui_Impl:
	cmp	eax, r8d

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rcx, rbx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	r8d, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, r8d
	call	?reserve@?$ImVector@UImGuiInputEvent@@@@QEAAXH@Z ; ImVector<ImGuiInputEvent>::reserve
$LN39@ImGui_Impl:
	movsxd	rax, DWORD PTR [rbx]
	movups	xmm0, XMMWORD PTR e$2[rsp]
	movsd	xmm1, QWORD PTR e$2[rsp+16]
	imul	rcx, rax, 28
	mov	rax, QWORD PTR [rbx+8]
	movups	XMMWORD PTR [rcx+rax], xmm0
	movsd	QWORD PTR [rcx+rax+16], xmm1
	mov	DWORD PTR [rcx+rax+24], edi
	inc	DWORD PTR [rbx]
$LN20@ImGui_Impl:
	mov	rbx, QWORD PTR [rsp+192]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 792  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 168				; 000000a8H
	pop	rdi
	pop	rbp
	ret	0
?ImGui_ImplGlfw_UpdateMouseData@@YAXXZ ENDP		; ImGui_ImplGlfw_UpdateMouseData
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?ImGui_ImplGlfw_UpdateMouseCursor@@YAXXZ
_TEXT	SEGMENT
?ImGui_ImplGlfw_UpdateMouseCursor@@YAXXZ PROC		; ImGui_ImplGlfw_UpdateMouseCursor, COMDAT

; 795  : {

	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 48					; 00000030H

; 796  :     ImGuiIO& io = ImGui::GetIO();

	mov	rsi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	xor	edi, edi
	test	rsi, rsi
	je	SHORT $LN15@ImGui_Impl
	mov	rbx, QWORD PTR [rsi+152]
	jmp	SHORT $LN16@ImGui_Impl
$LN15@ImGui_Impl:
	mov	rbx, rdi
$LN16@ImGui_Impl:

; 797  :     ImGui_ImplGlfw_Data* bd = ImGui_ImplGlfw_GetBackendData();
; 798  :     if ((io.ConfigFlags & ImGuiConfigFlags_NoMouseCursorChange) || glfwGetInputMode(bd->Window, GLFW_CURSOR) == GLFW_CURSOR_DISABLED)

	test	BYTE PTR [rsi+8], 32			; 00000020H
	jne	$LN6@ImGui_Impl
	mov	rcx, QWORD PTR [rbx]
	mov	edx, 208897				; 00033001H
	call	glfwGetInputMode
	cmp	eax, 212995				; 00034003H
	je	$LN6@ImGui_Impl
	mov	QWORD PTR [rsp+80], rbp

; 799  :         return;
; 800  : 
; 801  :     ImGuiMouseCursor imgui_cursor = ImGui::GetMouseCursor();

	mov	rbp, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR [rsp+88], r12
	movsxd	r12, DWORD PTR [rbp+19936]

; 802  :     ImGuiPlatformIO& platform_io = ImGui::GetPlatformIO();
; 803  :     for (int n = 0; n < platform_io.Viewports.Size; n++)

	cmp	DWORD PTR [rbp+14536], edi
	jle	$LN31@ImGui_Impl
	mov	QWORD PTR [rsp+96], r13
	mov	QWORD PTR [rsp+40], r14
	mov	r14, rdi
	mov	QWORD PTR [rsp+32], r15
	npad	6
$LL4@ImGui_Impl:

; 804  :     {
; 805  :         GLFWwindow* window = (GLFWwindow*)platform_io.Viewports[n]->PlatformHandle;

	mov	rax, QWORD PTR [rbp+14544]
	mov	rcx, QWORD PTR [rax+r14]
	mov	r15, QWORD PTR [rcx+72]

; 806  :         if (imgui_cursor == ImGuiMouseCursor_None || io.MouseDrawCursor)

	cmp	r12d, -1
	je	SHORT $LN9@ImGui_Impl
	cmp	BYTE PTR [rsi+96], 0
	jne	SHORT $LN9@ImGui_Impl

; 810  :         }
; 811  :         else
; 812  :         {
; 813  :             // Show OS mouse cursor
; 814  :             // FIXME-PLATFORM: Unfocused windows seems to fail changing the mouse cursor with GLFW 3.2, but 3.3 works here.
; 815  :             glfwSetCursor(window, bd->MouseCursors[imgui_cursor] ? bd->MouseCursors[imgui_cursor] : bd->MouseCursors[ImGuiMouseCursor_Arrow]);

	mov	rdx, QWORD PTR [rbx+r12*8+32]
	test	rdx, rdx
	jne	SHORT $LN12@ImGui_Impl
	mov	rdx, QWORD PTR [rbx+32]
$LN12@ImGui_Impl:
	mov	rcx, r15
	call	glfwSetCursor

; 816  :             glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_NORMAL);

	mov	r8d, 212993				; 00034001H
	jmp	SHORT $LN2@ImGui_Impl
$LN9@ImGui_Impl:

; 807  :         {
; 808  :             // Hide OS mouse cursor if imgui is drawing it or if it wants no cursor
; 809  :             glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_HIDDEN);

	mov	r8d, 212994				; 00034002H
$LN2@ImGui_Impl:

; 802  :     ImGuiPlatformIO& platform_io = ImGui::GetPlatformIO();
; 803  :     for (int n = 0; n < platform_io.Viewports.Size; n++)

	mov	edx, 208897				; 00033001H
	mov	rcx, r15
	call	glfwSetInputMode
	inc	edi
	add	r14, 8
	cmp	edi, DWORD PTR [rbp+14536]
	jl	SHORT $LL4@ImGui_Impl
	mov	r15, QWORD PTR [rsp+32]
	mov	r14, QWORD PTR [rsp+40]
	mov	r13, QWORD PTR [rsp+96]
$LN31@ImGui_Impl:
	mov	rbp, QWORD PTR [rsp+80]
	mov	r12, QWORD PTR [rsp+88]
$LN6@ImGui_Impl:

; 817  :         }
; 818  :     }
; 819  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?ImGui_ImplGlfw_UpdateMouseCursor@@YAXXZ ENDP		; ImGui_ImplGlfw_UpdateMouseCursor
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?Saturate@@YAMM@Z
_TEXT	SEGMENT
v$ = 8
?Saturate@@YAMM@Z PROC					; Saturate, COMDAT

; 822  : static inline float Saturate(float v) { return v < 0.0f ? 0.0f : v  > 1.0f ? 1.0f : v; }

	movaps	xmm1, xmm0
	xorps	xmm0, xmm0
	comiss	xmm0, xmm1
	ja	SHORT $LN6@Saturate
	movss	xmm0, DWORD PTR __real@3f800000
	minss	xmm0, xmm1
$LN6@Saturate:
	ret	0
?Saturate@@YAMM@Z ENDP					; Saturate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ
_TEXT	SEGMENT
gamepad$ = 32
__$ArrayPad$ = 72
?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ PROC		; ImGui_ImplGlfw_UpdateGamepads, COMDAT

; 824  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rbp
	lea	rbp, QWORD PTR [rsp-87]
	sub	rsp, 192				; 000000c0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-105], rax

; 825  :     ImGuiIO& io = ImGui::GetIO();

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	add	rbx, 8

; 826  :     if ((io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) == 0) // FIXME: Technically feeding gamepad shouldn't depend on this now that they are regular inputs.

	test	BYTE PTR [rbx], 2
	je	$LN72@ImGui_Impl

; 827  :         return;
; 828  : 
; 829  :     io.BackendFlags &= ~ImGuiBackendFlags_HasGamepad;

	and	DWORD PTR [rbx+4], -2

; 832  :     if (!glfwGetGamepadState(GLFW_JOYSTICK_1, &gamepad))

	lea	rdx, QWORD PTR gamepad$[rbp-105]
	xor	ecx, ecx
	call	glfwGetGamepadState
	test	eax, eax
	je	$LN72@ImGui_Impl

; 833  :         return;
; 834  :     #define MAP_BUTTON(KEY_NO, BUTTON_NO, _UNUSED)          do { io.AddKeyEvent(KEY_NO, gamepad.buttons[BUTTON_NO] != 0); } while (0)
; 835  :     #define MAP_ANALOG(KEY_NO, AXIS_NO, _UNUSED, V0, V1)    do { float v = gamepad.axes[AXIS_NO]; v = (v - V0) / (V1 - V0); io.AddKeyAnalogEvent(KEY_NO, v > 0.10f, Saturate(v)); } while (0)
; 836  : #else
; 837  :     int axes_count = 0, buttons_count = 0;
; 838  :     const float* axes = glfwGetJoystickAxes(GLFW_JOYSTICK_1, &axes_count);
; 839  :     const unsigned char* buttons = glfwGetJoystickButtons(GLFW_JOYSTICK_1, &buttons_count);
; 840  :     if (axes_count == 0 || buttons_count == 0)
; 841  :         return;
; 842  :     #define MAP_BUTTON(KEY_NO, _UNUSED, BUTTON_NO)          do { io.AddKeyEvent(KEY_NO, (buttons_count > BUTTON_NO && buttons[BUTTON_NO] == GLFW_PRESS)); } while (0)
; 843  :     #define MAP_ANALOG(KEY_NO, _UNUSED, AXIS_NO, V0, V1)    do { float v = (axes_count > AXIS_NO) ? axes[AXIS_NO] : V0; v = (v - V0) / (V1 - V0); io.AddKeyAnalogEvent(KEY_NO, v > 0.10f, Saturate(v)); } while (0)
; 844  : #endif
; 845  :     io.BackendFlags |= ImGuiBackendFlags_HasGamepad;

	or	DWORD PTR [rbx+4], 1

; 846  :     MAP_BUTTON(ImGuiKey_GamepadStart,       GLFW_GAMEPAD_BUTTON_START,          7);

	cmp	BYTE PTR gamepad$[rbp-98], 0
	movaps	XMMWORD PTR [rsp+176], xmm6
	xorps	xmm6, xmm6
	movaps	XMMWORD PTR [rsp+160], xmm7
	setne	r8b
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1513 :     if (!AppAcceptingEvents)

	cmp	BYTE PTR [rbx+14305], 0
	movss	xmm7, DWORD PTR __real@3f800000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 832  :     if (!glfwGetGamepadState(GLFW_JOYSTICK_1, &gamepad))

	movaps	XMMWORD PTR [rsp+144], xmm8
	movaps	XMMWORD PTR [rsp+128], xmm9
	movaps	XMMWORD PTR [rsp+112], xmm10
	movaps	XMMWORD PTR [rsp+96], xmm11
	movaps	XMMWORD PTR [rsp+80], xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1513 :     if (!AppAcceptingEvents)

	je	SHORT $LN2@ImGui_Impl

; 1514 :         return;
; 1515 :     AddKeyAnalogEvent(key, down, down ? 1.0f : 0.0f);

	test	r8b, r8b
	je	SHORT $LN85@ImGui_Impl
	movaps	xmm3, xmm7
	jmp	SHORT $LN86@ImGui_Impl
$LN85@ImGui_Impl:
	xorps	xmm3, xmm3
$LN86@ImGui_Impl:
	mov	edx, 617				; 00000269H
	mov	rcx, rbx
	call	?AddKeyAnalogEvent@ImGuiIO@@QEAAXW4ImGuiKey@@_NM@Z ; ImGuiIO::AddKeyAnalogEvent
$LN2@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 847  :     MAP_BUTTON(ImGuiKey_GamepadBack,        GLFW_GAMEPAD_BUTTON_BACK,           6);

	cmp	BYTE PTR gamepad$[rbp-99], 0
	setne	r8b
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1513 :     if (!AppAcceptingEvents)

	cmp	BYTE PTR [rbx+14305], 0
	je	SHORT $LN5@ImGui_Impl

; 1514 :         return;
; 1515 :     AddKeyAnalogEvent(key, down, down ? 1.0f : 0.0f);

	test	r8b, r8b
	je	SHORT $LN90@ImGui_Impl
	movaps	xmm3, xmm7
	jmp	SHORT $LN91@ImGui_Impl
$LN90@ImGui_Impl:
	xorps	xmm3, xmm3
$LN91@ImGui_Impl:
	mov	edx, 618				; 0000026aH
	mov	rcx, rbx
	call	?AddKeyAnalogEvent@ImGuiIO@@QEAAXW4ImGuiKey@@_NM@Z ; ImGuiIO::AddKeyAnalogEvent
$LN5@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 848  :     MAP_BUTTON(ImGuiKey_GamepadFaceLeft,    GLFW_GAMEPAD_BUTTON_X,              2);     // Xbox X, PS Square

	cmp	BYTE PTR gamepad$[rbp-103], 0
	setne	r8b
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1513 :     if (!AppAcceptingEvents)

	cmp	BYTE PTR [rbx+14305], 0
	je	SHORT $LN8@ImGui_Impl

; 1514 :         return;
; 1515 :     AddKeyAnalogEvent(key, down, down ? 1.0f : 0.0f);

	test	r8b, r8b
	je	SHORT $LN95@ImGui_Impl
	movaps	xmm3, xmm7
	jmp	SHORT $LN96@ImGui_Impl
$LN95@ImGui_Impl:
	xorps	xmm3, xmm3
$LN96@ImGui_Impl:
	mov	edx, 619				; 0000026bH
	mov	rcx, rbx
	call	?AddKeyAnalogEvent@ImGuiIO@@QEAAXW4ImGuiKey@@_NM@Z ; ImGuiIO::AddKeyAnalogEvent
$LN8@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 849  :     MAP_BUTTON(ImGuiKey_GamepadFaceRight,   GLFW_GAMEPAD_BUTTON_B,              1);     // Xbox B, PS Circle

	cmp	BYTE PTR gamepad$[rbp-104], 0
	setne	r8b
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1513 :     if (!AppAcceptingEvents)

	cmp	BYTE PTR [rbx+14305], 0
	je	SHORT $LN11@ImGui_Impl

; 1514 :         return;
; 1515 :     AddKeyAnalogEvent(key, down, down ? 1.0f : 0.0f);

	test	r8b, r8b
	je	SHORT $LN100@ImGui_Impl
	movaps	xmm3, xmm7
	jmp	SHORT $LN101@ImGui_Impl
$LN100@ImGui_Impl:
	xorps	xmm3, xmm3
$LN101@ImGui_Impl:
	mov	edx, 620				; 0000026cH
	mov	rcx, rbx
	call	?AddKeyAnalogEvent@ImGuiIO@@QEAAXW4ImGuiKey@@_NM@Z ; ImGuiIO::AddKeyAnalogEvent
$LN11@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 850  :     MAP_BUTTON(ImGuiKey_GamepadFaceUp,      GLFW_GAMEPAD_BUTTON_Y,              3);     // Xbox Y, PS Triangle

	cmp	BYTE PTR gamepad$[rbp-102], 0
	setne	r8b
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1513 :     if (!AppAcceptingEvents)

	cmp	BYTE PTR [rbx+14305], 0
	je	SHORT $LN14@ImGui_Impl

; 1514 :         return;
; 1515 :     AddKeyAnalogEvent(key, down, down ? 1.0f : 0.0f);

	test	r8b, r8b
	je	SHORT $LN105@ImGui_Impl
	movaps	xmm3, xmm7
	jmp	SHORT $LN106@ImGui_Impl
$LN105@ImGui_Impl:
	xorps	xmm3, xmm3
$LN106@ImGui_Impl:
	mov	edx, 621				; 0000026dH
	mov	rcx, rbx
	call	?AddKeyAnalogEvent@ImGuiIO@@QEAAXW4ImGuiKey@@_NM@Z ; ImGuiIO::AddKeyAnalogEvent
$LN14@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 851  :     MAP_BUTTON(ImGuiKey_GamepadFaceDown,    GLFW_GAMEPAD_BUTTON_A,              0);     // Xbox A, PS Cross

	cmp	BYTE PTR gamepad$[rbp-105], 0
	setne	r8b
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1513 :     if (!AppAcceptingEvents)

	cmp	BYTE PTR [rbx+14305], 0
	je	SHORT $LN17@ImGui_Impl

; 1514 :         return;
; 1515 :     AddKeyAnalogEvent(key, down, down ? 1.0f : 0.0f);

	test	r8b, r8b
	je	SHORT $LN110@ImGui_Impl
	movaps	xmm3, xmm7
	jmp	SHORT $LN111@ImGui_Impl
$LN110@ImGui_Impl:
	xorps	xmm3, xmm3
$LN111@ImGui_Impl:
	mov	edx, 622				; 0000026eH
	mov	rcx, rbx
	call	?AddKeyAnalogEvent@ImGuiIO@@QEAAXW4ImGuiKey@@_NM@Z ; ImGuiIO::AddKeyAnalogEvent
$LN17@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 852  :     MAP_BUTTON(ImGuiKey_GamepadDpadLeft,    GLFW_GAMEPAD_BUTTON_DPAD_LEFT,      13);

	cmp	BYTE PTR gamepad$[rbp-91], 0
	setne	r8b
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1513 :     if (!AppAcceptingEvents)

	cmp	BYTE PTR [rbx+14305], 0
	je	SHORT $LN20@ImGui_Impl

; 1514 :         return;
; 1515 :     AddKeyAnalogEvent(key, down, down ? 1.0f : 0.0f);

	test	r8b, r8b
	je	SHORT $LN115@ImGui_Impl
	movaps	xmm3, xmm7
	jmp	SHORT $LN116@ImGui_Impl
$LN115@ImGui_Impl:
	xorps	xmm3, xmm3
$LN116@ImGui_Impl:
	mov	edx, 623				; 0000026fH
	mov	rcx, rbx
	call	?AddKeyAnalogEvent@ImGuiIO@@QEAAXW4ImGuiKey@@_NM@Z ; ImGuiIO::AddKeyAnalogEvent
$LN20@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 853  :     MAP_BUTTON(ImGuiKey_GamepadDpadRight,   GLFW_GAMEPAD_BUTTON_DPAD_RIGHT,     11);

	cmp	BYTE PTR gamepad$[rbp-93], 0
	setne	r8b
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1513 :     if (!AppAcceptingEvents)

	cmp	BYTE PTR [rbx+14305], 0
	je	SHORT $LN23@ImGui_Impl

; 1514 :         return;
; 1515 :     AddKeyAnalogEvent(key, down, down ? 1.0f : 0.0f);

	test	r8b, r8b
	je	SHORT $LN120@ImGui_Impl
	movaps	xmm3, xmm7
	jmp	SHORT $LN121@ImGui_Impl
$LN120@ImGui_Impl:
	xorps	xmm3, xmm3
$LN121@ImGui_Impl:
	mov	edx, 624				; 00000270H
	mov	rcx, rbx
	call	?AddKeyAnalogEvent@ImGuiIO@@QEAAXW4ImGuiKey@@_NM@Z ; ImGuiIO::AddKeyAnalogEvent
$LN23@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 854  :     MAP_BUTTON(ImGuiKey_GamepadDpadUp,      GLFW_GAMEPAD_BUTTON_DPAD_UP,        10);

	cmp	BYTE PTR gamepad$[rbp-94], 0
	setne	r8b
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1513 :     if (!AppAcceptingEvents)

	cmp	BYTE PTR [rbx+14305], 0
	je	SHORT $LN26@ImGui_Impl

; 1514 :         return;
; 1515 :     AddKeyAnalogEvent(key, down, down ? 1.0f : 0.0f);

	test	r8b, r8b
	je	SHORT $LN125@ImGui_Impl
	movaps	xmm3, xmm7
	jmp	SHORT $LN126@ImGui_Impl
$LN125@ImGui_Impl:
	xorps	xmm3, xmm3
$LN126@ImGui_Impl:
	mov	edx, 625				; 00000271H
	mov	rcx, rbx
	call	?AddKeyAnalogEvent@ImGuiIO@@QEAAXW4ImGuiKey@@_NM@Z ; ImGuiIO::AddKeyAnalogEvent
$LN26@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 855  :     MAP_BUTTON(ImGuiKey_GamepadDpadDown,    GLFW_GAMEPAD_BUTTON_DPAD_DOWN,      12);

	cmp	BYTE PTR gamepad$[rbp-92], 0
	setne	r8b
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1513 :     if (!AppAcceptingEvents)

	cmp	BYTE PTR [rbx+14305], 0
	je	SHORT $LN29@ImGui_Impl

; 1514 :         return;
; 1515 :     AddKeyAnalogEvent(key, down, down ? 1.0f : 0.0f);

	test	r8b, r8b
	je	SHORT $LN130@ImGui_Impl
	movaps	xmm3, xmm7
	jmp	SHORT $LN131@ImGui_Impl
$LN130@ImGui_Impl:
	xorps	xmm3, xmm3
$LN131@ImGui_Impl:
	mov	edx, 626				; 00000272H
	mov	rcx, rbx
	call	?AddKeyAnalogEvent@ImGuiIO@@QEAAXW4ImGuiKey@@_NM@Z ; ImGuiIO::AddKeyAnalogEvent
$LN29@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 856  :     MAP_BUTTON(ImGuiKey_GamepadL1,          GLFW_GAMEPAD_BUTTON_LEFT_BUMPER,    4);

	cmp	BYTE PTR gamepad$[rbp-101], 0
	setne	r8b
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1513 :     if (!AppAcceptingEvents)

	cmp	BYTE PTR [rbx+14305], 0
	je	SHORT $LN32@ImGui_Impl

; 1514 :         return;
; 1515 :     AddKeyAnalogEvent(key, down, down ? 1.0f : 0.0f);

	test	r8b, r8b
	je	SHORT $LN135@ImGui_Impl
	movaps	xmm3, xmm7
	jmp	SHORT $LN136@ImGui_Impl
$LN135@ImGui_Impl:
	xorps	xmm3, xmm3
$LN136@ImGui_Impl:
	mov	edx, 627				; 00000273H
	mov	rcx, rbx
	call	?AddKeyAnalogEvent@ImGuiIO@@QEAAXW4ImGuiKey@@_NM@Z ; ImGuiIO::AddKeyAnalogEvent
$LN32@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 857  :     MAP_BUTTON(ImGuiKey_GamepadR1,          GLFW_GAMEPAD_BUTTON_RIGHT_BUMPER,   5);

	cmp	BYTE PTR gamepad$[rbp-100], 0
	setne	r8b
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1513 :     if (!AppAcceptingEvents)

	cmp	BYTE PTR [rbx+14305], 0
	je	SHORT $LN35@ImGui_Impl

; 1514 :         return;
; 1515 :     AddKeyAnalogEvent(key, down, down ? 1.0f : 0.0f);

	test	r8b, r8b
	je	SHORT $LN140@ImGui_Impl
	movaps	xmm3, xmm7
	jmp	SHORT $LN141@ImGui_Impl
$LN140@ImGui_Impl:
	xorps	xmm3, xmm3
$LN141@ImGui_Impl:
	mov	edx, 628				; 00000274H
	mov	rcx, rbx
	call	?AddKeyAnalogEvent@ImGuiIO@@QEAAXW4ImGuiKey@@_NM@Z ; ImGuiIO::AddKeyAnalogEvent
$LN35@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 858  :     MAP_ANALOG(ImGuiKey_GamepadL2,          GLFW_GAMEPAD_AXIS_LEFT_TRIGGER,     4,      -0.75f,  +1.0f);

	movss	xmm0, DWORD PTR gamepad$[rbp-73]
	movss	xmm10, DWORD PTR __real@bf400000
	movss	xmm9, DWORD PTR __real@3fe00000
	subss	xmm0, xmm10
	divss	xmm0, xmm9

; 822  : static inline float Saturate(float v) { return v < 0.0f ? 0.0f : v  > 1.0f ? 1.0f : v; }

	comiss	xmm6, xmm0
	jbe	SHORT $LN146@ImGui_Impl
	xorps	xmm3, xmm3
	jmp	SHORT $LN147@ImGui_Impl
$LN146@ImGui_Impl:
	movaps	xmm3, xmm7
	minss	xmm3, xmm0
$LN147@ImGui_Impl:

; 858  :     MAP_ANALOG(ImGuiKey_GamepadL2,          GLFW_GAMEPAD_AXIS_LEFT_TRIGGER,     4,      -0.75f,  +1.0f);

	movss	xmm8, DWORD PTR __real@3dcccccd
	mov	edx, 629				; 00000275H
	comiss	xmm0, xmm8
	mov	rcx, rbx
	seta	r8b
	call	?AddKeyAnalogEvent@ImGuiIO@@QEAAXW4ImGuiKey@@_NM@Z ; ImGuiIO::AddKeyAnalogEvent

; 859  :     MAP_ANALOG(ImGuiKey_GamepadR2,          GLFW_GAMEPAD_AXIS_RIGHT_TRIGGER,    5,      -0.75f,  +1.0f);

	movss	xmm0, DWORD PTR gamepad$[rbp-69]
	subss	xmm0, xmm10
	divss	xmm0, xmm9

; 822  : static inline float Saturate(float v) { return v < 0.0f ? 0.0f : v  > 1.0f ? 1.0f : v; }

	comiss	xmm6, xmm0
	jbe	SHORT $LN152@ImGui_Impl
	xorps	xmm3, xmm3
	jmp	SHORT $LN153@ImGui_Impl
$LN152@ImGui_Impl:
	movaps	xmm3, xmm7
	minss	xmm3, xmm0
$LN153@ImGui_Impl:

; 859  :     MAP_ANALOG(ImGuiKey_GamepadR2,          GLFW_GAMEPAD_AXIS_RIGHT_TRIGGER,    5,      -0.75f,  +1.0f);

	comiss	xmm0, xmm8
	mov	edx, 630				; 00000276H
	mov	rcx, rbx
	seta	r8b
	call	?AddKeyAnalogEvent@ImGuiIO@@QEAAXW4ImGuiKey@@_NM@Z ; ImGuiIO::AddKeyAnalogEvent

; 860  :     MAP_BUTTON(ImGuiKey_GamepadL3,          GLFW_GAMEPAD_BUTTON_LEFT_THUMB,     8);

	cmp	BYTE PTR gamepad$[rbp-96], 0
	setne	r8b
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1513 :     if (!AppAcceptingEvents)

	cmp	BYTE PTR [rbx+14305], 0
	je	SHORT $LN44@ImGui_Impl

; 1514 :         return;
; 1515 :     AddKeyAnalogEvent(key, down, down ? 1.0f : 0.0f);

	test	r8b, r8b
	je	SHORT $LN80@ImGui_Impl
	movaps	xmm3, xmm7
	jmp	SHORT $LN81@ImGui_Impl
$LN80@ImGui_Impl:
	xorps	xmm3, xmm3
$LN81@ImGui_Impl:
	mov	edx, 631				; 00000277H
	mov	rcx, rbx
	call	?AddKeyAnalogEvent@ImGuiIO@@QEAAXW4ImGuiKey@@_NM@Z ; ImGuiIO::AddKeyAnalogEvent
$LN44@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 861  :     MAP_BUTTON(ImGuiKey_GamepadR3,          GLFW_GAMEPAD_BUTTON_RIGHT_THUMB,    9);

	cmp	BYTE PTR gamepad$[rbp-95], 0
	setne	r8b
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1513 :     if (!AppAcceptingEvents)

	cmp	BYTE PTR [rbx+14305], 0
	je	SHORT $LN47@ImGui_Impl

; 1514 :         return;
; 1515 :     AddKeyAnalogEvent(key, down, down ? 1.0f : 0.0f);

	test	r8b, r8b
	je	SHORT $LN157@ImGui_Impl
	movaps	xmm3, xmm7
	jmp	SHORT $LN158@ImGui_Impl
$LN157@ImGui_Impl:
	xorps	xmm3, xmm3
$LN158@ImGui_Impl:
	mov	edx, 632				; 00000278H
	mov	rcx, rbx
	call	?AddKeyAnalogEvent@ImGuiIO@@QEAAXW4ImGuiKey@@_NM@Z ; ImGuiIO::AddKeyAnalogEvent
$LN47@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 862  :     MAP_ANALOG(ImGuiKey_GamepadLStickLeft,  GLFW_GAMEPAD_AXIS_LEFT_X,           0,      -0.25f,  -1.0f);

	movss	xmm0, DWORD PTR gamepad$[rbp-89]
	movss	xmm9, DWORD PTR __real@be800000
	subss	xmm0, xmm9
	divss	xmm0, xmm10

; 822  : static inline float Saturate(float v) { return v < 0.0f ? 0.0f : v  > 1.0f ? 1.0f : v; }

	comiss	xmm6, xmm0
	jbe	SHORT $LN163@ImGui_Impl
	xorps	xmm3, xmm3
	jmp	SHORT $LN164@ImGui_Impl
$LN163@ImGui_Impl:
	movaps	xmm3, xmm7
	minss	xmm3, xmm0
$LN164@ImGui_Impl:

; 862  :     MAP_ANALOG(ImGuiKey_GamepadLStickLeft,  GLFW_GAMEPAD_AXIS_LEFT_X,           0,      -0.25f,  -1.0f);

	comiss	xmm0, xmm8
	mov	edx, 633				; 00000279H
	mov	rcx, rbx
	seta	r8b
	call	?AddKeyAnalogEvent@ImGuiIO@@QEAAXW4ImGuiKey@@_NM@Z ; ImGuiIO::AddKeyAnalogEvent

; 863  :     MAP_ANALOG(ImGuiKey_GamepadLStickRight, GLFW_GAMEPAD_AXIS_LEFT_X,           0,      +0.25f,  +1.0f);

	movss	xmm0, DWORD PTR gamepad$[rbp-89]
	movss	xmm11, DWORD PTR __real@3e800000
	movss	xmm12, DWORD PTR __real@3f400000
	subss	xmm0, xmm11
	divss	xmm0, xmm12

; 822  : static inline float Saturate(float v) { return v < 0.0f ? 0.0f : v  > 1.0f ? 1.0f : v; }

	comiss	xmm6, xmm0
	jbe	SHORT $LN169@ImGui_Impl
	xorps	xmm3, xmm3
	jmp	SHORT $LN170@ImGui_Impl
$LN169@ImGui_Impl:
	movaps	xmm3, xmm7
	minss	xmm3, xmm0
$LN170@ImGui_Impl:

; 863  :     MAP_ANALOG(ImGuiKey_GamepadLStickRight, GLFW_GAMEPAD_AXIS_LEFT_X,           0,      +0.25f,  +1.0f);

	comiss	xmm0, xmm8
	mov	edx, 634				; 0000027aH
	mov	rcx, rbx
	seta	r8b
	call	?AddKeyAnalogEvent@ImGuiIO@@QEAAXW4ImGuiKey@@_NM@Z ; ImGuiIO::AddKeyAnalogEvent

; 864  :     MAP_ANALOG(ImGuiKey_GamepadLStickUp,    GLFW_GAMEPAD_AXIS_LEFT_Y,           1,      -0.25f,  -1.0f);

	movss	xmm0, DWORD PTR gamepad$[rbp-85]
	subss	xmm0, xmm9
	divss	xmm0, xmm10

; 822  : static inline float Saturate(float v) { return v < 0.0f ? 0.0f : v  > 1.0f ? 1.0f : v; }

	comiss	xmm6, xmm0
	jbe	SHORT $LN175@ImGui_Impl
	xorps	xmm3, xmm3
	jmp	SHORT $LN176@ImGui_Impl
$LN175@ImGui_Impl:
	movaps	xmm3, xmm7
	minss	xmm3, xmm0
$LN176@ImGui_Impl:

; 864  :     MAP_ANALOG(ImGuiKey_GamepadLStickUp,    GLFW_GAMEPAD_AXIS_LEFT_Y,           1,      -0.25f,  -1.0f);

	comiss	xmm0, xmm8
	mov	edx, 635				; 0000027bH
	mov	rcx, rbx
	seta	r8b
	call	?AddKeyAnalogEvent@ImGuiIO@@QEAAXW4ImGuiKey@@_NM@Z ; ImGuiIO::AddKeyAnalogEvent

; 865  :     MAP_ANALOG(ImGuiKey_GamepadLStickDown,  GLFW_GAMEPAD_AXIS_LEFT_Y,           1,      +0.25f,  +1.0f);

	movss	xmm0, DWORD PTR gamepad$[rbp-85]
	subss	xmm0, xmm11
	divss	xmm0, xmm12

; 822  : static inline float Saturate(float v) { return v < 0.0f ? 0.0f : v  > 1.0f ? 1.0f : v; }

	comiss	xmm6, xmm0
	jbe	SHORT $LN181@ImGui_Impl
	xorps	xmm3, xmm3
	jmp	SHORT $LN182@ImGui_Impl
$LN181@ImGui_Impl:
	movaps	xmm3, xmm7
	minss	xmm3, xmm0
$LN182@ImGui_Impl:

; 865  :     MAP_ANALOG(ImGuiKey_GamepadLStickDown,  GLFW_GAMEPAD_AXIS_LEFT_Y,           1,      +0.25f,  +1.0f);

	comiss	xmm0, xmm8
	mov	edx, 636				; 0000027cH
	mov	rcx, rbx
	seta	r8b
	call	?AddKeyAnalogEvent@ImGuiIO@@QEAAXW4ImGuiKey@@_NM@Z ; ImGuiIO::AddKeyAnalogEvent

; 866  :     MAP_ANALOG(ImGuiKey_GamepadRStickLeft,  GLFW_GAMEPAD_AXIS_RIGHT_X,          2,      -0.25f,  -1.0f);

	movss	xmm0, DWORD PTR gamepad$[rbp-81]
	subss	xmm0, xmm9
	divss	xmm0, xmm10

; 822  : static inline float Saturate(float v) { return v < 0.0f ? 0.0f : v  > 1.0f ? 1.0f : v; }

	comiss	xmm6, xmm0
	jbe	SHORT $LN187@ImGui_Impl
	xorps	xmm3, xmm3
	jmp	SHORT $LN188@ImGui_Impl
$LN187@ImGui_Impl:
	movaps	xmm3, xmm7
	minss	xmm3, xmm0
$LN188@ImGui_Impl:

; 866  :     MAP_ANALOG(ImGuiKey_GamepadRStickLeft,  GLFW_GAMEPAD_AXIS_RIGHT_X,          2,      -0.25f,  -1.0f);

	comiss	xmm0, xmm8
	mov	edx, 637				; 0000027dH
	mov	rcx, rbx
	seta	r8b
	call	?AddKeyAnalogEvent@ImGuiIO@@QEAAXW4ImGuiKey@@_NM@Z ; ImGuiIO::AddKeyAnalogEvent

; 867  :     MAP_ANALOG(ImGuiKey_GamepadRStickRight, GLFW_GAMEPAD_AXIS_RIGHT_X,          2,      +0.25f,  +1.0f);

	movss	xmm0, DWORD PTR gamepad$[rbp-81]
	subss	xmm0, xmm11
	divss	xmm0, xmm12

; 822  : static inline float Saturate(float v) { return v < 0.0f ? 0.0f : v  > 1.0f ? 1.0f : v; }

	comiss	xmm6, xmm0
	jbe	SHORT $LN193@ImGui_Impl
	xorps	xmm3, xmm3
	jmp	SHORT $LN194@ImGui_Impl
$LN193@ImGui_Impl:
	movaps	xmm3, xmm7
	minss	xmm3, xmm0
$LN194@ImGui_Impl:

; 867  :     MAP_ANALOG(ImGuiKey_GamepadRStickRight, GLFW_GAMEPAD_AXIS_RIGHT_X,          2,      +0.25f,  +1.0f);

	comiss	xmm0, xmm8
	mov	edx, 638				; 0000027eH
	mov	rcx, rbx
	seta	r8b
	call	?AddKeyAnalogEvent@ImGuiIO@@QEAAXW4ImGuiKey@@_NM@Z ; ImGuiIO::AddKeyAnalogEvent

; 868  :     MAP_ANALOG(ImGuiKey_GamepadRStickUp,    GLFW_GAMEPAD_AXIS_RIGHT_Y,          3,      -0.25f,  -1.0f);

	movss	xmm0, DWORD PTR gamepad$[rbp-77]
	subss	xmm0, xmm9
	movaps	xmm9, XMMWORD PTR [rsp+128]
	divss	xmm0, xmm10
	movaps	xmm10, XMMWORD PTR [rsp+112]

; 822  : static inline float Saturate(float v) { return v < 0.0f ? 0.0f : v  > 1.0f ? 1.0f : v; }

	comiss	xmm6, xmm0
	jbe	SHORT $LN199@ImGui_Impl
	xorps	xmm3, xmm3
	jmp	SHORT $LN200@ImGui_Impl
$LN199@ImGui_Impl:
	movaps	xmm3, xmm7
	minss	xmm3, xmm0
$LN200@ImGui_Impl:

; 868  :     MAP_ANALOG(ImGuiKey_GamepadRStickUp,    GLFW_GAMEPAD_AXIS_RIGHT_Y,          3,      -0.25f,  -1.0f);

	comiss	xmm0, xmm8
	mov	edx, 639				; 0000027fH
	mov	rcx, rbx
	seta	r8b
	call	?AddKeyAnalogEvent@ImGuiIO@@QEAAXW4ImGuiKey@@_NM@Z ; ImGuiIO::AddKeyAnalogEvent

; 869  :     MAP_ANALOG(ImGuiKey_GamepadRStickDown,  GLFW_GAMEPAD_AXIS_RIGHT_Y,          3,      +0.25f,  +1.0f);

	movss	xmm0, DWORD PTR gamepad$[rbp-77]
	subss	xmm0, xmm11
	movaps	xmm11, XMMWORD PTR [rsp+96]
	divss	xmm0, xmm12
	movaps	xmm12, XMMWORD PTR [rsp+80]

; 822  : static inline float Saturate(float v) { return v < 0.0f ? 0.0f : v  > 1.0f ? 1.0f : v; }

	comiss	xmm6, xmm0
	ja	SHORT $LN206@ImGui_Impl
	minss	xmm7, xmm0
	movaps	xmm6, xmm7
$LN206@ImGui_Impl:

; 869  :     MAP_ANALOG(ImGuiKey_GamepadRStickDown,  GLFW_GAMEPAD_AXIS_RIGHT_Y,          3,      +0.25f,  +1.0f);

	comiss	xmm0, xmm8
	mov	edx, 640				; 00000280H
	mov	rcx, rbx
	movaps	xmm3, xmm6
	seta	r8b
	call	?AddKeyAnalogEvent@ImGuiIO@@QEAAXW4ImGuiKey@@_NM@Z ; ImGuiIO::AddKeyAnalogEvent
	movaps	xmm8, XMMWORD PTR [rsp+144]
	movaps	xmm7, XMMWORD PTR [rsp+160]
	movaps	xmm6, XMMWORD PTR [rsp+176]
$LN72@ImGui_Impl:

; 870  :     #undef MAP_BUTTON
; 871  :     #undef MAP_ANALOG
; 872  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-105]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+208]
	add	rsp, 192				; 000000c0H
	pop	rbp
	ret	0
?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ ENDP		; ImGui_ImplGlfw_UpdateGamepads
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?ImGui_ImplGlfw_UpdateMonitors@@YAXXZ
_TEXT	SEGMENT
monitor$5 = 48
x$6 = 96
y$7 = 100
w$8 = 104
h$9 = 108
monitors_count$ = 112
x_scale$10 = 116
y_scale$11 = 120
__$ArrayPad$ = 128
?ImGui_ImplGlfw_UpdateMonitors@@YAXXZ PROC		; ImGui_ImplGlfw_UpdateMonitors, COMDAT

; 875  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	push	rbp
	lea	rbp, QWORD PTR [rsp-87]
	sub	rsp, 144				; 00000090H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-57], rax

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	mov	rdi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	xor	esi, esi
	test	rdi, rdi
	je	SHORT $LN11@ImGui_Impl
	mov	rax, QWORD PTR [rdi+152]
	jmp	SHORT $LN12@ImGui_Impl
$LN11@ImGui_Impl:
	mov	rax, rsi
$LN12@ImGui_Impl:

; 876  :     ImGui_ImplGlfw_Data* bd = ImGui_ImplGlfw_GetBackendData();
; 877  :     ImGuiPlatformIO& platform_io = ImGui::GetPlatformIO();
; 878  :     bd->WantUpdateMonitors = false;

	mov	BYTE PTR [rax+2898], sil

; 879  : 
; 880  :     int monitors_count = 0;
; 881  :     GLFWmonitor** glfw_monitors = glfwGetMonitors(&monitors_count);

	lea	rcx, QWORD PTR monitors_count$[rbp-57]
	mov	DWORD PTR monitors_count$[rbp-57], esi
	call	glfwGetMonitors
	mov	rbx, rax

; 882  :     if (monitors_count == 0) // Preserve existing monitor list if there are none. Happens on macOS sleeping (#5683)

	mov	eax, DWORD PTR monitors_count$[rbp-57]
	test	eax, eax
	je	$LN3@ImGui_Impl

; 883  :         return;
; 884  : 
; 885  :     platform_io.Monitors.resize(0);

	add	rdi, 14520				; 000038b8H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	ecx, DWORD PTR [rdi+4]
	test	ecx, ecx
	jns	SHORT $LN14@ImGui_Impl

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	eax, ecx
	cdq
	sub	eax, edx
	mov	edx, esi
	sar	eax, 1
	add	eax, ecx

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	rcx, rdi

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	eax, eax
	cmovg	edx, eax

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	call	?reserve@?$ImVector@UImGuiPlatformMonitor@@@@QEAAXH@Z ; ImVector<ImGuiPlatformMonitor>::reserve
	mov	eax, DWORD PTR monitors_count$[rbp-57]
$LN14@ImGui_Impl:
	mov	DWORD PTR [rdi], esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 886  :     for (int n = 0; n < monitors_count; n++)

	test	eax, eax
	jle	$LN3@ImGui_Impl
	npad	8
$LL4@ImGui_Impl:

; 887  :     {
; 888  :         ImGuiPlatformMonitor monitor;
; 889  :         int x, y;
; 890  :         glfwGetMonitorPos(glfw_monitors[n], &x, &y);

	mov	rcx, QWORD PTR [rbx]
	lea	r8, QWORD PTR y$7[rbp-57]
	lea	rdx, QWORD PTR x$6[rbp-57]
	call	glfwGetMonitorPos

; 891  :         const GLFWvidmode* vid_mode = glfwGetVideoMode(glfw_monitors[n]);

	mov	rcx, QWORD PTR [rbx]
	call	glfwGetVideoMode

; 892  :         if (vid_mode == nullptr)

	test	rax, rax
	je	$LN2@ImGui_Impl

; 893  :             continue; // Failed to get Video mode (e.g. Emscripten does not support this function)
; 894  :         monitor.MainPos = monitor.WorkPos = ImVec2((float)x, (float)y);
; 895  :         monitor.MainSize = monitor.WorkSize = ImVec2((float)vid_mode->width, (float)vid_mode->height);
; 896  : #if GLFW_HAS_MONITOR_WORK_AREA
; 897  :         int w, h;
; 898  :         glfwGetMonitorWorkarea(glfw_monitors[n], &x, &y, &w, &h);

	movd	xmm2, DWORD PTR [rax]
	lea	r9, QWORD PTR w$8[rbp-57]
	movd	xmm0, DWORD PTR x$6[rbp-57]
	lea	r8, QWORD PTR y$7[rbp-57]
	movd	xmm1, DWORD PTR y$7[rbp-57]
	lea	rdx, QWORD PTR x$6[rbp-57]
	mov	rcx, QWORD PTR [rbx]
	cvtdq2ps xmm0, xmm0
	cvtdq2ps xmm1, xmm1
	movss	DWORD PTR monitor$5[rbp-41], xmm0
	movss	DWORD PTR monitor$5[rbp-57], xmm0
	movd	xmm0, DWORD PTR [rax+4]
	lea	rax, QWORD PTR h$9[rbp-57]
	cvtdq2ps xmm0, xmm0
	mov	QWORD PTR [rsp+32], rax
	cvtdq2ps xmm2, xmm2
	movss	DWORD PTR monitor$5[rbp-29], xmm0
	movss	DWORD PTR monitor$5[rbp-45], xmm0
	movss	DWORD PTR monitor$5[rbp-37], xmm1
	movss	DWORD PTR monitor$5[rbp-53], xmm1
	movss	DWORD PTR monitor$5[rbp-33], xmm2
	movss	DWORD PTR monitor$5[rbp-49], xmm2
	call	glfwGetMonitorWorkarea

; 899  :         if (w > 0 && h > 0) // Workaround a small GLFW issue reporting zero on monitor changes: https://github.com/glfw/glfw/pull/1761

	mov	ecx, DWORD PTR w$8[rbp-57]
	test	ecx, ecx
	jle	SHORT $LN7@ImGui_Impl
	mov	eax, DWORD PTR h$9[rbp-57]
	test	eax, eax
	jle	SHORT $LN7@ImGui_Impl

; 900  :         {
; 901  :             monitor.WorkPos = ImVec2((float)x, (float)y);

	movd	xmm0, DWORD PTR x$6[rbp-57]
	movd	xmm1, DWORD PTR y$7[rbp-57]
	cvtdq2ps xmm0, xmm0
	movd	xmm2, ecx
	movss	DWORD PTR monitor$5[rbp-41], xmm0
	movd	xmm0, eax

; 902  :             monitor.WorkSize = ImVec2((float)w, (float)h);

	cvtdq2ps xmm0, xmm0
	cvtdq2ps xmm1, xmm1
	cvtdq2ps xmm2, xmm2
	movss	DWORD PTR monitor$5[rbp-29], xmm0
	movss	DWORD PTR monitor$5[rbp-37], xmm1
	movss	DWORD PTR monitor$5[rbp-33], xmm2
$LN7@ImGui_Impl:

; 903  :         }
; 904  : #endif
; 905  : #if GLFW_HAS_PER_MONITOR_DPI
; 906  :         // Warning: the validity of monitor DPI information on Windows depends on the application DPI awareness settings, which generally needs to be set in the manifest or at runtime.
; 907  :         float x_scale, y_scale;
; 908  :         glfwGetMonitorContentScale(glfw_monitors[n], &x_scale, &y_scale);

	mov	rcx, QWORD PTR [rbx]
	lea	r8, QWORD PTR y_scale$11[rbp-57]
	lea	rdx, QWORD PTR x_scale$10[rbp-57]
	call	glfwGetMonitorContentScale

; 909  :         monitor.DpiScale = x_scale;

	movss	xmm0, DWORD PTR x_scale$10[rbp-57]

; 910  : #endif
; 911  :         monitor.PlatformHandle = (void*)glfw_monitors[n]; // [...] GLFW doc states: "guaranteed to be valid only until the monitor configuration changes"

	mov	rax, QWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	ecx, DWORD PTR [rdi]
	mov	r8d, DWORD PTR [rdi+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 909  :         monitor.DpiScale = x_scale;

	movss	DWORD PTR monitor$5[rbp-25], xmm0

; 910  : #endif
; 911  :         monitor.PlatformHandle = (void*)glfw_monitors[n]; // [...] GLFW doc states: "guaranteed to be valid only until the monitor configuration changes"

	mov	QWORD PTR monitor$5[rbp-17], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	cmp	ecx, r8d
	jne	SHORT $LN41@ImGui_Impl
	inc	ecx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	r8d, r8d
	je	SHORT $LN45@ImGui_Impl
	mov	eax, r8d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r8d
	jmp	SHORT $LN46@ImGui_Impl
$LN45@ImGui_Impl:
	mov	eax, 8
$LN46@ImGui_Impl:
	cmp	eax, ecx
	cmovg	ecx, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, ecx
	mov	rcx, rdi
	call	?reserve@?$ImVector@UImGuiPlatformMonitor@@@@QEAAXH@Z ; ImVector<ImGuiPlatformMonitor>::reserve
$LN41@ImGui_Impl:
	movsxd	rax, DWORD PTR [rdi]
	movups	xmm0, XMMWORD PTR monitor$5[rbp-57]
	movups	xmm1, XMMWORD PTR monitor$5[rbp-41]
	lea	rcx, QWORD PTR [rax+rax*2]
	mov	rax, QWORD PTR [rdi+8]
	add	rcx, rcx
	movups	XMMWORD PTR [rax+rcx*8], xmm0
	movups	xmm0, XMMWORD PTR monitor$5[rbp-25]
	movups	XMMWORD PTR [rax+rcx*8+16], xmm1
	movups	XMMWORD PTR [rax+rcx*8+32], xmm0
	inc	DWORD PTR [rdi]
$LN2@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 886  :     for (int n = 0; n < monitors_count; n++)

	inc	esi
	add	rbx, 8
	cmp	esi, DWORD PTR monitors_count$[rbp-57]
	jl	$LL4@ImGui_Impl
$LN3@ImGui_Impl:

; 912  :         platform_io.Monitors.push_back(monitor);
; 913  :     }
; 914  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-57]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+144]
	mov	rbx, QWORD PTR [r11+16]
	mov	rsi, QWORD PTR [r11+24]
	mov	rdi, QWORD PTR [r11+32]
	mov	rsp, r11
	pop	rbp
	ret	0
?ImGui_ImplGlfw_UpdateMonitors@@YAXXZ ENDP		; ImGui_ImplGlfw_UpdateMonitors
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?ImGui_ImplGlfw_NewFrame@@YAXXZ
_TEXT	SEGMENT
w$ = 32
h$ = 36
display_w$ = 40
display_h$ = 44
__$ArrayPad$ = 48
?ImGui_ImplGlfw_NewFrame@@YAXXZ PROC			; ImGui_ImplGlfw_NewFrame, COMDAT

; 917  : {

$LN54:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 918  :     ImGuiIO& io = ImGui::GetIO();

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	xor	esi, esi
	test	rbx, rbx
	je	SHORT $LN10@ImGui_Impl
	mov	rdi, QWORD PTR [rbx+152]
	jmp	SHORT $LN11@ImGui_Impl
$LN10@ImGui_Impl:
	mov	rdi, rsi
$LN11@ImGui_Impl:

; 919  :     ImGui_ImplGlfw_Data* bd = ImGui_ImplGlfw_GetBackendData();
; 920  :     IM_ASSERT(bd != nullptr && "Did you call ImGui_ImplGlfw_InitForXXX()?");
; 921  : 
; 922  :     // Setup display size (every frame to accommodate for window resizing)
; 923  :     int w, h;
; 924  :     int display_w, display_h;
; 925  :     glfwGetWindowSize(bd->Window, &w, &h);

	mov	rcx, QWORD PTR [rdi]
	lea	r8, QWORD PTR h$[rsp]
	lea	rdx, QWORD PTR w$[rsp]
	call	glfwGetWindowSize

; 926  :     glfwGetFramebufferSize(bd->Window, &display_w, &display_h);

	mov	rcx, QWORD PTR [rdi]
	lea	r8, QWORD PTR display_h$[rsp]
	lea	rdx, QWORD PTR display_w$[rsp]
	call	glfwGetFramebufferSize

; 927  :     io.DisplaySize = ImVec2((float)w, (float)h);

	mov	eax, DWORD PTR w$[rsp]
	mov	ecx, DWORD PTR h$[rsp]
	movd	xmm0, eax
	movd	xmm2, ecx
	cvtdq2ps xmm0, xmm0
	cvtdq2ps xmm2, xmm2
	movss	DWORD PTR [rbx+16], xmm0
	movss	DWORD PTR [rbx+20], xmm2

; 928  :     if (w > 0 && h > 0)

	test	eax, eax
	jle	SHORT $LN2@ImGui_Impl
	test	ecx, ecx
	jle	SHORT $LN2@ImGui_Impl

; 929  :         io.DisplayFramebufferScale = ImVec2((float)display_w / (float)w, (float)display_h / (float)h);

	movd	xmm1, DWORD PTR display_w$[rsp]
	cvtdq2ps xmm1, xmm1
	divss	xmm1, xmm0
	movd	xmm0, DWORD PTR display_h$[rsp]
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [rbx+80], xmm1
	divss	xmm0, xmm2
	movss	DWORD PTR [rbx+84], xmm0
$LN2@ImGui_Impl:

; 930  :     if (bd->WantUpdateMonitors)

	cmp	BYTE PTR [rdi+2898], sil
	je	SHORT $LN3@ImGui_Impl

; 931  :         ImGui_ImplGlfw_UpdateMonitors();

	call	?ImGui_ImplGlfw_UpdateMonitors@@YAXXZ	; ImGui_ImplGlfw_UpdateMonitors
$LN3@ImGui_Impl:

; 932  : 
; 933  :     // Setup time step
; 934  :     // (Accept glfwGetTime() not returning a monotonically increasing value. Seems to happens on disconnecting peripherals and probably on VMs and Emscripten, see #6491, #6189, #6114, #3644)
; 935  :     double current_time = glfwGetTime();

	call	glfwGetTime

; 936  :     if (current_time <= bd->Time)

	movsd	xmm2, QWORD PTR [rdi+16]
	movaps	xmm1, xmm0
	comisd	xmm2, xmm0
	jb	SHORT $LN4@ImGui_Impl

; 937  :         current_time = bd->Time + 0.00001f;

	movaps	xmm1, xmm2
	addsd	xmm1, QWORD PTR __real@3ee4f8b580000000
$LN4@ImGui_Impl:

; 938  :     io.DeltaTime = bd->Time > 0.0 ? (float)(current_time - bd->Time) : (float)(1.0f / 60.0f);

	xorps	xmm0, xmm0
	comisd	xmm2, xmm0
	jbe	SHORT $LN6@ImGui_Impl
	movaps	xmm0, xmm1
	xorps	xmm3, xmm3
	subsd	xmm0, xmm2
	cvtsd2ss xmm3, xmm0
	jmp	SHORT $LN7@ImGui_Impl
$LN6@ImGui_Impl:
	movss	xmm3, DWORD PTR __real@3c888889
$LN7@ImGui_Impl:
	movss	DWORD PTR [rbx+24], xmm3

; 939  :     bd->Time = current_time;

	movsd	QWORD PTR [rdi+16], xmm1

; 940  : 
; 941  :     ImGui_ImplGlfw_UpdateMouseData();

	call	?ImGui_ImplGlfw_UpdateMouseData@@YAXXZ	; ImGui_ImplGlfw_UpdateMouseData

; 796  :     ImGuiIO& io = ImGui::GetIO();

	mov	rdi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	test	rdi, rdi
	je	SHORT $LN30@ImGui_Impl
	mov	rbx, QWORD PTR [rdi+152]
	jmp	SHORT $LN31@ImGui_Impl
$LN30@ImGui_Impl:
	mov	rbx, rsi
$LN31@ImGui_Impl:

; 798  :     if ((io.ConfigFlags & ImGuiConfigFlags_NoMouseCursorChange) || glfwGetInputMode(bd->Window, GLFW_CURSOR) == GLFW_CURSOR_DISABLED)

	test	BYTE PTR [rdi+8], 32			; 00000020H
	jne	$LN21@ImGui_Impl
	mov	rcx, QWORD PTR [rbx]
	mov	edx, 208897				; 00033001H
	call	glfwGetInputMode
	cmp	eax, 212995				; 00034003H
	je	$LN21@ImGui_Impl
	mov	QWORD PTR [rsp+112], rbp

; 799  :         return;
; 800  : 
; 801  :     ImGuiMouseCursor imgui_cursor = ImGui::GetMouseCursor();

	mov	rbp, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR [rsp+120], r12
	movsxd	r12, DWORD PTR [rbp+19936]

; 802  :     ImGuiPlatformIO& platform_io = ImGui::GetPlatformIO();
; 803  :     for (int n = 0; n < platform_io.Viewports.Size; n++)

	cmp	DWORD PTR [rbp+14536], esi
	jle	$LN52@ImGui_Impl
	mov	QWORD PTR [rsp+128], r13
	mov	QWORD PTR [rsp+72], r14
	mov	r14, rsi
	mov	QWORD PTR [rsp+64], r15
$LL19@ImGui_Impl:

; 804  :     {
; 805  :         GLFWwindow* window = (GLFWwindow*)platform_io.Viewports[n]->PlatformHandle;

	mov	rax, QWORD PTR [rbp+14544]
	mov	rcx, QWORD PTR [rax+r14]
	mov	r15, QWORD PTR [rcx+72]

; 806  :         if (imgui_cursor == ImGuiMouseCursor_None || io.MouseDrawCursor)

	cmp	r12d, -1
	je	SHORT $LN24@ImGui_Impl
	cmp	BYTE PTR [rdi+96], 0
	jne	SHORT $LN24@ImGui_Impl

; 810  :         }
; 811  :         else
; 812  :         {
; 813  :             // Show OS mouse cursor
; 814  :             // FIXME-PLATFORM: Unfocused windows seems to fail changing the mouse cursor with GLFW 3.2, but 3.3 works here.
; 815  :             glfwSetCursor(window, bd->MouseCursors[imgui_cursor] ? bd->MouseCursors[imgui_cursor] : bd->MouseCursors[ImGuiMouseCursor_Arrow]);

	mov	rdx, QWORD PTR [rbx+r12*8+32]
	test	rdx, rdx
	jne	SHORT $LN27@ImGui_Impl
	mov	rdx, QWORD PTR [rbx+32]
$LN27@ImGui_Impl:
	mov	rcx, r15
	call	glfwSetCursor

; 816  :             glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_NORMAL);

	mov	r8d, 212993				; 00034001H
	jmp	SHORT $LN17@ImGui_Impl
$LN24@ImGui_Impl:

; 807  :         {
; 808  :             // Hide OS mouse cursor if imgui is drawing it or if it wants no cursor
; 809  :             glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_HIDDEN);

	mov	r8d, 212994				; 00034002H
$LN17@ImGui_Impl:

; 802  :     ImGuiPlatformIO& platform_io = ImGui::GetPlatformIO();
; 803  :     for (int n = 0; n < platform_io.Viewports.Size; n++)

	mov	edx, 208897				; 00033001H
	mov	rcx, r15
	call	glfwSetInputMode
	inc	esi
	add	r14, 8
	cmp	esi, DWORD PTR [rbp+14536]
	jl	SHORT $LL19@ImGui_Impl
	mov	r15, QWORD PTR [rsp+64]
	mov	r14, QWORD PTR [rsp+72]
	mov	r13, QWORD PTR [rsp+128]
$LN52@ImGui_Impl:
	mov	rbp, QWORD PTR [rsp+112]
	mov	r12, QWORD PTR [rsp+120]
$LN21@ImGui_Impl:

; 942  :     ImGui_ImplGlfw_UpdateMouseCursor();
; 943  : 
; 944  :     // Update game controllers (if enabled and available)
; 945  :     ImGui_ImplGlfw_UpdateGamepads();

	call	?ImGui_ImplGlfw_UpdateGamepads@@YAXXZ	; ImGui_ImplGlfw_UpdateGamepads

; 946  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 80					; 00000050H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?ImGui_ImplGlfw_NewFrame@@YAXXZ ENDP			; ImGui_ImplGlfw_NewFrame
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ??0ImGui_ImplGlfw_ViewportData@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0ImGui_ImplGlfw_ViewportData@@QEAA@XZ PROC		; ImGui_ImplGlfw_ViewportData::ImGui_ImplGlfw_ViewportData, COMDAT

; 962  :     ImGui_ImplGlfw_ViewportData()  { Window = nullptr; WindowOwned = false; IgnoreWindowSizeEventFrame = IgnoreWindowPosEventFrame = -1; }

	mov	QWORD PTR [rcx], 0
	mov	rax, rcx
	mov	BYTE PTR [rcx+8], 0
	mov	QWORD PTR [rcx+12], -1
	ret	0
??0ImGui_ImplGlfw_ViewportData@@QEAA@XZ ENDP		; ImGui_ImplGlfw_ViewportData::ImGui_ImplGlfw_ViewportData
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ??1ImGui_ImplGlfw_ViewportData@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1ImGui_ImplGlfw_ViewportData@@QEAA@XZ PROC		; ImGui_ImplGlfw_ViewportData::~ImGui_ImplGlfw_ViewportData, COMDAT

; 963  :     ~ImGui_ImplGlfw_ViewportData() { IM_ASSERT(Window == nullptr); }

	ret	0
??1ImGui_ImplGlfw_ViewportData@@QEAA@XZ ENDP		; ImGui_ImplGlfw_ViewportData::~ImGui_ImplGlfw_ViewportData
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?ImGui_ImplGlfw_WindowCloseCallback@@YAXPEAUGLFWwindow@@@Z
_TEXT	SEGMENT
window$ = 8
?ImGui_ImplGlfw_WindowCloseCallback@@YAXPEAUGLFWwindow@@@Z PROC ; ImGui_ImplGlfw_WindowCloseCallback, COMDAT
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 14014:     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 967  : {

	mov	r10, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 14015:     for (int i = 0; i != g.Viewports.Size; i++)

	xor	r8d, r8d
	movsxd	rcx, DWORD PTR [rax+18976]
	test	ecx, ecx
	je	SHORT $LN2@ImGui_Impl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	r11, QWORD PTR [rax+18984]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 14015:     for (int i = 0; i != g.Viewports.Size; i++)

	mov	r9, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	rdx, r11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 14015:     for (int i = 0; i != g.Viewports.Size; i++)

	mov	eax, r8d
	npad	8
$LL7@ImGui_Impl:

; 14016:         if (g.Viewports[i]->PlatformHandle == platform_handle)

	mov	rcx, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx+72], r10
	je	SHORT $LN15@ImGui_Impl

; 14015:     for (int i = 0; i != g.Viewports.Size; i++)

	inc	r8d
	inc	rax
	add	rdx, 8
	cmp	rax, r9
	jne	SHORT $LL7@ImGui_Impl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 970  : }

	ret	0
$LN15@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rax, r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 14017:             return g.Viewports[i];

	mov	rcx, QWORD PTR [r11+rax*8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 968  :     if (ImGuiViewport* viewport = ImGui::FindViewportByPlatformHandle(window))

	test	rcx, rcx
	je	SHORT $LN2@ImGui_Impl

; 969  :         viewport->PlatformRequestClose = true;

	mov	BYTE PTR [rcx+91], 1
$LN2@ImGui_Impl:

; 970  : }

	ret	0
?ImGui_ImplGlfw_WindowCloseCallback@@YAXPEAUGLFWwindow@@@Z ENDP ; ImGui_ImplGlfw_WindowCloseCallback
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?ImGui_ImplGlfw_WindowPosCallback@@YAXPEAUGLFWwindow@@HH@Z
_TEXT	SEGMENT
window$ = 16
__formal$ = 24
__formal$ = 32
?ImGui_ImplGlfw_WindowPosCallback@@YAXPEAUGLFWwindow@@HH@Z PROC ; ImGui_ImplGlfw_WindowPosCallback, COMDAT

; 979  : {

	sub	rsp, 8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 14014:     ImGuiContext& g = *GImGui;

	mov	r11, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 14015:     for (int i = 0; i != g.Viewports.Size; i++)

	xor	r9d, r9d
	movsxd	rax, DWORD PTR [r11+18976]
	test	eax, eax
	je	SHORT $LN2@ImGui_Impl
	mov	QWORD PTR [rsp], rbx
	mov	r10, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	rbx, QWORD PTR [r11+18984]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 14015:     for (int i = 0; i != g.Viewports.Size; i++)

	mov	edx, r9d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	r8, rbx
	npad	3
$LL9@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 14016:         if (g.Viewports[i]->PlatformHandle == platform_handle)

	mov	rax, QWORD PTR [r8]
	cmp	QWORD PTR [rax+72], rcx
	je	SHORT $LN17@ImGui_Impl

; 14015:     for (int i = 0; i != g.Viewports.Size; i++)

	inc	r9d
	inc	rdx
	add	r8, 8
	cmp	rdx, r10
	jne	SHORT $LL9@ImGui_Impl
	mov	rbx, QWORD PTR [rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 991  : }

	add	rsp, 8
	ret	0
$LN17@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rax, r9d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 14017:             return g.Viewports[i];

	mov	rcx, QWORD PTR [rbx+rax*8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 980  :     if (ImGuiViewport* viewport = ImGui::FindViewportByPlatformHandle(window))

	test	rcx, rcx
	je	SHORT $LN25@ImGui_Impl

; 981  :     {
; 982  :         if (ImGui_ImplGlfw_ViewportData* vd = (ImGui_ImplGlfw_ViewportData*)viewport->PlatformUserData)

	mov	rax, QWORD PTR [rcx+64]
	test	rax, rax
	je	SHORT $LN4@ImGui_Impl

; 983  :         {
; 984  :             bool ignore_event = (ImGui::GetFrameCount() <= vd->IgnoreWindowPosEventFrame + 1);

	mov	eax, DWORD PTR [rax+12]
	inc	eax
	cmp	DWORD PTR [r11+16240], eax

; 985  :             //data->IgnoreWindowPosEventFrame = -1;
; 986  :             if (ignore_event)

	jle	SHORT $LN25@ImGui_Impl
$LN4@ImGui_Impl:

; 987  :                 return;
; 988  :         }
; 989  :         viewport->PlatformRequestMove = true;

	mov	BYTE PTR [rcx+89], 1
$LN25@ImGui_Impl:
	mov	rbx, QWORD PTR [rsp]
$LN2@ImGui_Impl:

; 991  : }

	add	rsp, 8
	ret	0
?ImGui_ImplGlfw_WindowPosCallback@@YAXPEAUGLFWwindow@@HH@Z ENDP ; ImGui_ImplGlfw_WindowPosCallback
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?ImGui_ImplGlfw_WindowSizeCallback@@YAXPEAUGLFWwindow@@HH@Z
_TEXT	SEGMENT
window$ = 16
__formal$ = 24
__formal$ = 32
?ImGui_ImplGlfw_WindowSizeCallback@@YAXPEAUGLFWwindow@@HH@Z PROC ; ImGui_ImplGlfw_WindowSizeCallback, COMDAT

; 994  : {

	sub	rsp, 8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 14014:     ImGuiContext& g = *GImGui;

	mov	r11, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 14015:     for (int i = 0; i != g.Viewports.Size; i++)

	xor	r9d, r9d
	movsxd	rax, DWORD PTR [r11+18976]
	test	eax, eax
	je	SHORT $LN2@ImGui_Impl
	mov	QWORD PTR [rsp], rbx
	mov	r10, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	rbx, QWORD PTR [r11+18984]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 14015:     for (int i = 0; i != g.Viewports.Size; i++)

	mov	edx, r9d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	r8, rbx
	npad	3
$LL9@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 14016:         if (g.Viewports[i]->PlatformHandle == platform_handle)

	mov	rax, QWORD PTR [r8]
	cmp	QWORD PTR [rax+72], rcx
	je	SHORT $LN17@ImGui_Impl

; 14015:     for (int i = 0; i != g.Viewports.Size; i++)

	inc	r9d
	inc	rdx
	add	r8, 8
	cmp	rdx, r10
	jne	SHORT $LL9@ImGui_Impl
	mov	rbx, QWORD PTR [rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 1006 : }

	add	rsp, 8
	ret	0
$LN17@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rax, r9d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 14017:             return g.Viewports[i];

	mov	rcx, QWORD PTR [rbx+rax*8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 995  :     if (ImGuiViewport* viewport = ImGui::FindViewportByPlatformHandle(window))

	test	rcx, rcx
	je	SHORT $LN25@ImGui_Impl

; 996  :     {
; 997  :         if (ImGui_ImplGlfw_ViewportData* vd = (ImGui_ImplGlfw_ViewportData*)viewport->PlatformUserData)

	mov	rax, QWORD PTR [rcx+64]
	test	rax, rax
	je	SHORT $LN4@ImGui_Impl

; 998  :         {
; 999  :             bool ignore_event = (ImGui::GetFrameCount() <= vd->IgnoreWindowSizeEventFrame + 1);

	mov	eax, DWORD PTR [rax+16]
	inc	eax
	cmp	DWORD PTR [r11+16240], eax

; 1000 :             //data->IgnoreWindowSizeEventFrame = -1;
; 1001 :             if (ignore_event)

	jle	SHORT $LN25@ImGui_Impl
$LN4@ImGui_Impl:

; 1002 :                 return;
; 1003 :         }
; 1004 :         viewport->PlatformRequestResize = true;

	mov	BYTE PTR [rcx+90], 1
$LN25@ImGui_Impl:
	mov	rbx, QWORD PTR [rsp]
$LN2@ImGui_Impl:

; 1006 : }

	add	rsp, 8
	ret	0
?ImGui_ImplGlfw_WindowSizeCallback@@YAXPEAUGLFWwindow@@HH@Z ENDP ; ImGui_ImplGlfw_WindowSizeCallback
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?ImGui_ImplGlfw_CreateWindow@@YAXPEAUImGuiViewport@@@Z
_TEXT	SEGMENT
viewport$ = 64
?ImGui_ImplGlfw_CreateWindow@@YAXPEAUImGuiViewport@@@Z PROC ; ImGui_ImplGlfw_CreateWindow, COMDAT

; 1009 : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 48					; 00000030H

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	xor	edi, edi

; 1009 : {

	mov	rbp, rcx

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	test	rax, rax
	je	SHORT $LN11@ImGui_Impl
	mov	rsi, QWORD PTR [rax+152]
	jmp	SHORT $LN12@ImGui_Impl
$LN11@ImGui_Impl:
	mov	rsi, rdi
$LN12@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN14@ImGui_Impl

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN14@ImGui_Impl:

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	mov	ecx, 24
	call	QWORD PTR __imp_malloc
	mov	rbx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 1011 :     ImGui_ImplGlfw_ViewportData* vd = IM_NEW(ImGui_ImplGlfw_ViewportData)();

	test	rax, rax
	je	SHORT $LN4@ImGui_Impl

; 962  :     ImGui_ImplGlfw_ViewportData()  { Window = nullptr; WindowOwned = false; IgnoreWindowSizeEventFrame = IgnoreWindowPosEventFrame = -1; }

	mov	QWORD PTR [rax], rdi
	mov	BYTE PTR [rax+8], dil
	mov	QWORD PTR [rax+12], -1

; 1011 :     ImGui_ImplGlfw_ViewportData* vd = IM_NEW(ImGui_ImplGlfw_ViewportData)();

	jmp	SHORT $LN5@ImGui_Impl
$LN4@ImGui_Impl:
	mov	rbx, rdi
$LN5@ImGui_Impl:

; 1012 :     viewport->PlatformUserData = vd;
; 1013 : 
; 1014 :     // GLFW 3.2 unfortunately always set focus on glfwCreateWindow() if GLFW_VISIBLE is set, regardless of GLFW_FOCUSED
; 1015 :     // With GLFW 3.3, the hint GLFW_FOCUS_ON_SHOW fixes this problem
; 1016 :     glfwWindowHint(GLFW_VISIBLE, false);

	xor	edx, edx
	mov	QWORD PTR [rbp+64], rbx
	mov	ecx, 131076				; 00020004H
	call	glfwWindowHint

; 1017 :     glfwWindowHint(GLFW_FOCUSED, false);

	xor	edx, edx
	mov	ecx, 131073				; 00020001H
	call	glfwWindowHint

; 1018 : #if GLFW_HAS_FOCUS_ON_SHOW
; 1019 :     glfwWindowHint(GLFW_FOCUS_ON_SHOW, false);

	xor	edx, edx
	mov	ecx, 131084				; 0002000cH
	call	glfwWindowHint

; 1020 :  #endif
; 1021 :     glfwWindowHint(GLFW_DECORATED, (viewport->Flags & ImGuiViewportFlags_NoDecoration) ? false : true);

	mov	eax, DWORD PTR [rbp+4]
	mov	ecx, 131077				; 00020005H
	shr	eax, 3
	not	al
	and	eax, 1
	mov	edx, eax
	call	glfwWindowHint

; 1022 : #if GLFW_HAS_WINDOW_TOPMOST
; 1023 :     glfwWindowHint(GLFW_FLOATING, (viewport->Flags & ImGuiViewportFlags_TopMost) ? true : false);

	mov	edx, DWORD PTR [rbp+4]
	mov	ecx, 131079				; 00020007H
	shr	edx, 10
	and	edx, 1
	call	glfwWindowHint

; 1024 : #endif
; 1025 :     GLFWwindow* share_window = (bd->ClientApi == GlfwClientApi_OpenGL) ? bd->Window : nullptr;

	cmp	DWORD PTR [rsi+8], 1
	jne	SHORT $LN6@ImGui_Impl
	mov	rdi, QWORD PTR [rsi]
$LN6@ImGui_Impl:

; 1026 :     vd->Window = glfwCreateWindow((int)viewport->Size.x, (int)viewport->Size.y, "No Title Yet", nullptr, share_window);

	cvttss2si edx, DWORD PTR [rbp+20]
	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0N@GFDLLEAC@No?5Title?5Yet@
	mov	QWORD PTR [rsp+32], rdi
	cvttss2si ecx, DWORD PTR [rbp+16]
	call	glfwCreateWindow
	mov	QWORD PTR [rbx], rax

; 1027 :     vd->WindowOwned = true;

	mov	BYTE PTR [rbx+8], 1

; 1028 :     viewport->PlatformHandle = (void*)vd->Window;

	mov	QWORD PTR [rbp+72], rax

; 1029 : #ifdef _WIN32
; 1030 :     viewport->PlatformHandleRaw = glfwGetWin32Window(vd->Window);

	mov	rcx, QWORD PTR [rbx]
	call	glfwGetWin32Window

; 1031 : #elif defined(__APPLE__)
; 1032 :     viewport->PlatformHandleRaw = (void*)glfwGetCocoaWindow(vd->Window);
; 1033 : #endif
; 1034 :     glfwSetWindowPos(vd->Window, (int)viewport->Pos.x, (int)viewport->Pos.y);

	cvttss2si r8d, DWORD PTR [rbp+12]
	mov	QWORD PTR [rbp+80], rax
	mov	rcx, QWORD PTR [rbx]
	cvttss2si edx, DWORD PTR [rbp+8]
	call	glfwSetWindowPos

; 1035 : 
; 1036 :     // Install GLFW callbacks for secondary viewports
; 1037 :     glfwSetWindowFocusCallback(vd->Window, ImGui_ImplGlfw_WindowFocusCallback);

	mov	rcx, QWORD PTR [rbx]
	lea	rdx, OFFSET FLAT:?ImGui_ImplGlfw_WindowFocusCallback@@YAXPEAUGLFWwindow@@H@Z ; ImGui_ImplGlfw_WindowFocusCallback
	call	glfwSetWindowFocusCallback

; 1038 :     glfwSetCursorEnterCallback(vd->Window, ImGui_ImplGlfw_CursorEnterCallback);

	mov	rcx, QWORD PTR [rbx]
	lea	rdx, OFFSET FLAT:?ImGui_ImplGlfw_CursorEnterCallback@@YAXPEAUGLFWwindow@@H@Z ; ImGui_ImplGlfw_CursorEnterCallback
	call	glfwSetCursorEnterCallback

; 1039 :     glfwSetCursorPosCallback(vd->Window, ImGui_ImplGlfw_CursorPosCallback);

	mov	rcx, QWORD PTR [rbx]
	lea	rdx, OFFSET FLAT:?ImGui_ImplGlfw_CursorPosCallback@@YAXPEAUGLFWwindow@@NN@Z ; ImGui_ImplGlfw_CursorPosCallback
	call	glfwSetCursorPosCallback

; 1040 :     glfwSetMouseButtonCallback(vd->Window, ImGui_ImplGlfw_MouseButtonCallback);

	mov	rcx, QWORD PTR [rbx]
	lea	rdx, OFFSET FLAT:?ImGui_ImplGlfw_MouseButtonCallback@@YAXPEAUGLFWwindow@@HHH@Z ; ImGui_ImplGlfw_MouseButtonCallback
	call	glfwSetMouseButtonCallback

; 1041 :     glfwSetScrollCallback(vd->Window, ImGui_ImplGlfw_ScrollCallback);

	mov	rcx, QWORD PTR [rbx]
	lea	rdx, OFFSET FLAT:?ImGui_ImplGlfw_ScrollCallback@@YAXPEAUGLFWwindow@@NN@Z ; ImGui_ImplGlfw_ScrollCallback
	call	glfwSetScrollCallback

; 1042 :     glfwSetKeyCallback(vd->Window, ImGui_ImplGlfw_KeyCallback);

	mov	rcx, QWORD PTR [rbx]
	lea	rdx, OFFSET FLAT:?ImGui_ImplGlfw_KeyCallback@@YAXPEAUGLFWwindow@@HHHH@Z ; ImGui_ImplGlfw_KeyCallback
	call	glfwSetKeyCallback

; 1043 :     glfwSetCharCallback(vd->Window, ImGui_ImplGlfw_CharCallback);

	mov	rcx, QWORD PTR [rbx]
	lea	rdx, OFFSET FLAT:?ImGui_ImplGlfw_CharCallback@@YAXPEAUGLFWwindow@@I@Z ; ImGui_ImplGlfw_CharCallback
	call	glfwSetCharCallback

; 1044 :     glfwSetWindowCloseCallback(vd->Window, ImGui_ImplGlfw_WindowCloseCallback);

	mov	rcx, QWORD PTR [rbx]
	lea	rdx, OFFSET FLAT:?ImGui_ImplGlfw_WindowCloseCallback@@YAXPEAUGLFWwindow@@@Z ; ImGui_ImplGlfw_WindowCloseCallback
	call	glfwSetWindowCloseCallback

; 1045 :     glfwSetWindowPosCallback(vd->Window, ImGui_ImplGlfw_WindowPosCallback);

	mov	rcx, QWORD PTR [rbx]
	lea	rdx, OFFSET FLAT:?ImGui_ImplGlfw_WindowPosCallback@@YAXPEAUGLFWwindow@@HH@Z ; ImGui_ImplGlfw_WindowPosCallback
	call	glfwSetWindowPosCallback

; 1046 :     glfwSetWindowSizeCallback(vd->Window, ImGui_ImplGlfw_WindowSizeCallback);

	mov	rcx, QWORD PTR [rbx]
	lea	rdx, OFFSET FLAT:?ImGui_ImplGlfw_WindowSizeCallback@@YAXPEAUGLFWwindow@@HH@Z ; ImGui_ImplGlfw_WindowSizeCallback
	call	glfwSetWindowSizeCallback

; 1047 :     if (bd->ClientApi == GlfwClientApi_OpenGL)

	cmp	DWORD PTR [rsi+8], 1
	jne	SHORT $LN2@ImGui_Impl

; 1048 :     {
; 1049 :         glfwMakeContextCurrent(vd->Window);

	mov	rcx, QWORD PTR [rbx]
	call	glfwMakeContextCurrent

; 1050 :         glfwSwapInterval(0);

	xor	ecx, ecx
	call	glfwSwapInterval
$LN2@ImGui_Impl:

; 1051 :     }
; 1052 : }

	mov	rbx, QWORD PTR [rsp+72]
	mov	rbp, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?ImGui_ImplGlfw_CreateWindow@@YAXPEAUImGuiViewport@@@Z ENDP ; ImGui_ImplGlfw_CreateWindow
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?ImGui_ImplGlfw_DestroyWindow@@YAXPEAUImGuiViewport@@@Z
_TEXT	SEGMENT
viewport$ = 64
?ImGui_ImplGlfw_DestroyWindow@@YAXPEAUImGuiViewport@@@Z PROC ; ImGui_ImplGlfw_DestroyWindow, COMDAT

; 1055 : {

	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 48					; 00000030H

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	xor	r14d, r14d

; 1055 : {

	mov	rbp, rcx

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	test	rax, rax
	je	SHORT $LN11@ImGui_Impl
	mov	rdi, QWORD PTR [rax+152]
	jmp	SHORT $LN12@ImGui_Impl
$LN11@ImGui_Impl:
	mov	rdi, r14
$LN12@ImGui_Impl:

; 1056 :     ImGui_ImplGlfw_Data* bd = ImGui_ImplGlfw_GetBackendData();
; 1057 :     if (ImGui_ImplGlfw_ViewportData* vd = (ImGui_ImplGlfw_ViewportData*)viewport->PlatformUserData)

	mov	rsi, QWORD PTR [rcx+64]
	test	rsi, rsi
	je	$LN28@ImGui_Impl

; 1058 :     {
; 1059 :         if (vd->WindowOwned)

	cmp	BYTE PTR [rsi+8], r14b
	je	SHORT $LN6@ImGui_Impl

; 1060 :         {
; 1061 : #if !GLFW_HAS_MOUSE_PASSTHROUGH && GLFW_HAS_WINDOW_HOVERED && defined(_WIN32)
; 1062 :             HWND hwnd = (HWND)viewport->PlatformHandleRaw;
; 1063 :             ::RemovePropA(hwnd, "IMGUI_VIEWPORT");

	mov	rcx, QWORD PTR [rcx+80]
	lea	rdx, OFFSET FLAT:??_C@_0P@JJHDDBGF@IMGUI_VIEWPORT@
	mov	QWORD PTR [rsp+64], rbx
	call	QWORD PTR __imp_RemovePropA
	add	rdi, 112				; 00000070H
	mov	ebx, r14d
$LL4@ImGui_Impl:

; 1069 :                 if (bd->KeyOwnerWindows[i] == vd->Window)

	mov	rcx, QWORD PTR [rsi]
	cmp	QWORD PTR [rdi], rcx
	jne	SHORT $LN2@ImGui_Impl

; 1070 :                     ImGui_ImplGlfw_KeyCallback(vd->Window, i, 0, GLFW_RELEASE, 0); // Later params are only used for main viewport, on which this function is never called.

	xor	r9d, r9d
	mov	DWORD PTR [rsp+32], r14d
	xor	r8d, r8d
	mov	edx, ebx
	call	?ImGui_ImplGlfw_KeyCallback@@YAXPEAUGLFWwindow@@HHHH@Z ; ImGui_ImplGlfw_KeyCallback
$LN2@ImGui_Impl:

; 1064 : #endif
; 1065 : 
; 1066 :             // Release any keys that were pressed in the window being destroyed and are still held down,
; 1067 :             // because we will not receive any release events after window is destroyed.
; 1068 :             for (int i = 0; i < IM_ARRAYSIZE(bd->KeyOwnerWindows); i++)

	inc	ebx
	add	rdi, 8
	cmp	ebx, 348				; 0000015cH
	jl	SHORT $LL4@ImGui_Impl

; 1071 : 
; 1072 :             glfwDestroyWindow(vd->Window);

	mov	rcx, QWORD PTR [rsi]
	mov	rbx, QWORD PTR [rsp+64]
	call	glfwDestroyWindow
	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
$LN6@ImGui_Impl:

; 1073 :         }
; 1074 :         vd->Window = nullptr;

	mov	QWORD PTR [rsi], r14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN18@ImGui_Impl

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN18@ImGui_Impl:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	mov	rcx, rsi
	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 1077 :     viewport->PlatformUserData = viewport->PlatformHandle = nullptr;

	mov	QWORD PTR [rbp+72], r14
	mov	QWORD PTR [rbp+64], r14
	jmp	SHORT $LN20@ImGui_Impl
$LN28@ImGui_Impl:
	mov	QWORD PTR [rcx+72], r14
	mov	QWORD PTR [rcx+64], r14
$LN20@ImGui_Impl:

; 1078 : }

	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	r14
	ret	0
?ImGui_ImplGlfw_DestroyWindow@@YAXPEAUImGuiViewport@@@Z ENDP ; ImGui_ImplGlfw_DestroyWindow
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?ImGui_ImplGlfw_ShowWindow@@YAXPEAUImGuiViewport@@@Z
_TEXT	SEGMENT
viewport$ = 48
?ImGui_ImplGlfw_ShowWindow@@YAXPEAUImGuiViewport@@@Z PROC ; ImGui_ImplGlfw_ShowWindow, COMDAT

; 1081 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1082 :     ImGui_ImplGlfw_ViewportData* vd = (ImGui_ImplGlfw_ViewportData*)viewport->PlatformUserData;
; 1083 : 
; 1084 : #if defined(_WIN32)
; 1085 :     // GLFW hack: Hide icon from task bar
; 1086 :     HWND hwnd = (HWND)viewport->PlatformHandleRaw;
; 1087 :     if (viewport->Flags & ImGuiViewportFlags_NoTaskBarIcon)

	test	BYTE PTR [rcx+4], 16
	mov	rbx, rcx
	mov	rsi, QWORD PTR [rcx+64]
	mov	rdi, QWORD PTR [rcx+80]
	je	SHORT $LN2@ImGui_Impl

; 1088 :     {
; 1089 :         LONG ex_style = ::GetWindowLong(hwnd, GWL_EXSTYLE);

	mov	edx, -20
	mov	rcx, rdi
	call	QWORD PTR __imp_GetWindowLongW

; 1090 :         ex_style &= ~WS_EX_APPWINDOW;
; 1091 :         ex_style |= WS_EX_TOOLWINDOW;
; 1092 :         ::SetWindowLong(hwnd, GWL_EXSTYLE, ex_style);

	mov	edx, -20
	mov	rcx, rdi
	btr	eax, 18
	bts	eax, 7
	mov	r8d, eax
	call	QWORD PTR __imp_SetWindowLongW
$LN2@ImGui_Impl:

; 1093 :     }
; 1094 : 
; 1095 :     // GLFW hack: install hook for WM_NCHITTEST message handler
; 1096 : #if !GLFW_HAS_MOUSE_PASSTHROUGH && GLFW_HAS_WINDOW_HOVERED && defined(_WIN32)
; 1097 :     ImGui_ImplGlfw_Data* bd = ImGui_ImplGlfw_GetBackendData();
; 1098 :     ::SetPropA(hwnd, "IMGUI_VIEWPORT", viewport);

	mov	r8, rbx
	lea	rdx, OFFSET FLAT:??_C@_0P@JJHDDBGF@IMGUI_VIEWPORT@
	mov	rcx, rdi
	call	QWORD PTR __imp_SetPropA

; 1099 :     IM_ASSERT(bd->GlfwWndProc == (WNDPROC)::GetWindowLongPtr(hwnd, GWLP_WNDPROC));
; 1100 :     ::SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)ImGui_ImplGlfw_WndProc);

	lea	r8, OFFSET FLAT:?ImGui_ImplGlfw_WndProc@@YA_JPEAUHWND__@@I_K_J@Z ; ImGui_ImplGlfw_WndProc
	mov	edx, -4
	mov	rcx, rdi
	call	QWORD PTR __imp_SetWindowLongPtrW

; 1101 : #endif
; 1102 : 
; 1103 : #if !GLFW_HAS_FOCUS_ON_SHOW
; 1104 :     // GLFW hack: GLFW 3.2 has a bug where glfwShowWindow() also activates/focus the window.
; 1105 :     // The fix was pushed to GLFW repository on 2018/01/09 and should be included in GLFW 3.3 via a GLFW_FOCUS_ON_SHOW window attribute.
; 1106 :     // See https://github.com/glfw/glfw/issues/1189
; 1107 :     // FIXME-VIEWPORT: Implement same work-around for Linux/OSX in the meanwhile.
; 1108 :     if (viewport->Flags & ImGuiViewportFlags_NoFocusOnAppearing)
; 1109 :     {
; 1110 :         ::ShowWindow(hwnd, SW_SHOWNA);
; 1111 :         return;
; 1112 :     }
; 1113 : #endif
; 1114 : #endif
; 1115 : 
; 1116 :     glfwShowWindow(vd->Window);

	mov	rcx, QWORD PTR [rsi]

; 1117 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1101 : #endif
; 1102 : 
; 1103 : #if !GLFW_HAS_FOCUS_ON_SHOW
; 1104 :     // GLFW hack: GLFW 3.2 has a bug where glfwShowWindow() also activates/focus the window.
; 1105 :     // The fix was pushed to GLFW repository on 2018/01/09 and should be included in GLFW 3.3 via a GLFW_FOCUS_ON_SHOW window attribute.
; 1106 :     // See https://github.com/glfw/glfw/issues/1189
; 1107 :     // FIXME-VIEWPORT: Implement same work-around for Linux/OSX in the meanwhile.
; 1108 :     if (viewport->Flags & ImGuiViewportFlags_NoFocusOnAppearing)
; 1109 :     {
; 1110 :         ::ShowWindow(hwnd, SW_SHOWNA);
; 1111 :         return;
; 1112 :     }
; 1113 : #endif
; 1114 : #endif
; 1115 : 
; 1116 :     glfwShowWindow(vd->Window);

	jmp	glfwShowWindow
?ImGui_ImplGlfw_ShowWindow@@YAXPEAUImGuiViewport@@@Z ENDP ; ImGui_ImplGlfw_ShowWindow
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?ImGui_ImplGlfw_GetWindowPos@@YA?AUImVec2@@PEAUImGuiViewport@@@Z
_TEXT	SEGMENT
x$ = 32
y$ = 36
__$ArrayPad$ = 40
__$ReturnUdt$ = 64
viewport$ = 72
?ImGui_ImplGlfw_GetWindowPos@@YA?AUImVec2@@PEAUImGuiViewport@@@Z PROC ; ImGui_ImplGlfw_GetWindowPos, COMDAT

; 1120 : {

	push	rbx
	sub	rsp, 48					; 00000030H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbx, rcx

; 1121 :     ImGui_ImplGlfw_ViewportData* vd = (ImGui_ImplGlfw_ViewportData*)viewport->PlatformUserData;
; 1122 :     int x = 0, y = 0;
; 1123 :     glfwGetWindowPos(vd->Window, &x, &y);

	lea	r8, QWORD PTR y$[rsp]
	mov	rcx, QWORD PTR [rdx+64]
	xor	eax, eax
	mov	DWORD PTR x$[rsp], eax
	lea	rdx, QWORD PTR x$[rsp]
	mov	DWORD PTR y$[rsp], eax
	mov	rcx, QWORD PTR [rcx]
	call	glfwGetWindowPos
	movd	xmm0, DWORD PTR x$[rsp]

; 1124 :     return ImVec2((float)x, (float)y);

	mov	rax, rbx
	movd	xmm1, DWORD PTR y$[rsp]
	cvtdq2ps xmm0, xmm0
	cvtdq2ps xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR [rbx], xmm0
	movss	DWORD PTR [rbx+4], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 1125 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
?ImGui_ImplGlfw_GetWindowPos@@YA?AUImVec2@@PEAUImGuiViewport@@@Z ENDP ; ImGui_ImplGlfw_GetWindowPos
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?ImGui_ImplGlfw_SetWindowPos@@YAXPEAUImGuiViewport@@UImVec2@@@Z
_TEXT	SEGMENT
viewport$ = 8
pos$ = 8
?ImGui_ImplGlfw_SetWindowPos@@YAXPEAUImGuiViewport@@UImVec2@@@Z PROC ; ImGui_ImplGlfw_SetWindowPos, COMDAT

; 1129 :     ImGui_ImplGlfw_ViewportData* vd = (ImGui_ImplGlfw_ViewportData*)viewport->PlatformUserData;

	mov	rcx, QWORD PTR [rcx+64]

; 1130 :     vd->IgnoreWindowPosEventFrame = ImGui::GetFrameCount();

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR pos$[rsp], rdx

; 1131 :     glfwSetWindowPos(vd->Window, (int)pos.x, (int)pos.y);

	cvttss2si r8d, DWORD PTR pos$[rsp+4]
	mov	edx, DWORD PTR [rax+16240]
	mov	DWORD PTR [rcx+12], edx
	mov	rcx, QWORD PTR [rcx]
	cvttss2si edx, DWORD PTR pos$[rsp]
	jmp	glfwSetWindowPos
?ImGui_ImplGlfw_SetWindowPos@@YAXPEAUImGuiViewport@@UImVec2@@@Z ENDP ; ImGui_ImplGlfw_SetWindowPos
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?ImGui_ImplGlfw_GetWindowSize@@YA?AUImVec2@@PEAUImGuiViewport@@@Z
_TEXT	SEGMENT
w$ = 32
h$ = 36
__$ArrayPad$ = 40
__$ReturnUdt$ = 64
viewport$ = 72
?ImGui_ImplGlfw_GetWindowSize@@YA?AUImVec2@@PEAUImGuiViewport@@@Z PROC ; ImGui_ImplGlfw_GetWindowSize, COMDAT

; 1135 : {

	push	rbx
	sub	rsp, 48					; 00000030H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbx, rcx

; 1136 :     ImGui_ImplGlfw_ViewportData* vd = (ImGui_ImplGlfw_ViewportData*)viewport->PlatformUserData;
; 1137 :     int w = 0, h = 0;
; 1138 :     glfwGetWindowSize(vd->Window, &w, &h);

	lea	r8, QWORD PTR h$[rsp]
	mov	rcx, QWORD PTR [rdx+64]
	xor	eax, eax
	mov	DWORD PTR w$[rsp], eax
	lea	rdx, QWORD PTR w$[rsp]
	mov	DWORD PTR h$[rsp], eax
	mov	rcx, QWORD PTR [rcx]
	call	glfwGetWindowSize
	movd	xmm0, DWORD PTR w$[rsp]

; 1139 :     return ImVec2((float)w, (float)h);

	mov	rax, rbx
	movd	xmm1, DWORD PTR h$[rsp]
	cvtdq2ps xmm0, xmm0
	cvtdq2ps xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR [rbx], xmm0
	movss	DWORD PTR [rbx+4], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 1140 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
?ImGui_ImplGlfw_GetWindowSize@@YA?AUImVec2@@PEAUImGuiViewport@@@Z ENDP ; ImGui_ImplGlfw_GetWindowSize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?ImGui_ImplGlfw_SetWindowSize@@YAXPEAUImGuiViewport@@UImVec2@@@Z
_TEXT	SEGMENT
viewport$ = 8
size$ = 8
?ImGui_ImplGlfw_SetWindowSize@@YAXPEAUImGuiViewport@@UImVec2@@@Z PROC ; ImGui_ImplGlfw_SetWindowSize, COMDAT

; 1144 :     ImGui_ImplGlfw_ViewportData* vd = (ImGui_ImplGlfw_ViewportData*)viewport->PlatformUserData;

	mov	rcx, QWORD PTR [rcx+64]

; 1145 : #if __APPLE__ && !GLFW_HAS_OSX_WINDOW_POS_FIX
; 1146 :     // Native OS windows are positioned from the bottom-left corner on macOS, whereas on other platforms they are
; 1147 :     // positioned from the upper-left corner. GLFW makes an effort to convert macOS style coordinates, however it
; 1148 :     // doesn't handle it when changing size. We are manually moving the window in order for changes of size to be based
; 1149 :     // on the upper-left corner.
; 1150 :     int x, y, width, height;
; 1151 :     glfwGetWindowPos(vd->Window, &x, &y);
; 1152 :     glfwGetWindowSize(vd->Window, &width, &height);
; 1153 :     glfwSetWindowPos(vd->Window, x, y - height + size.y);
; 1154 : #endif
; 1155 :     vd->IgnoreWindowSizeEventFrame = ImGui::GetFrameCount();

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR size$[rsp], rdx

; 1156 :     glfwSetWindowSize(vd->Window, (int)size.x, (int)size.y);

	cvttss2si r8d, DWORD PTR size$[rsp+4]
	mov	edx, DWORD PTR [rax+16240]
	mov	DWORD PTR [rcx+16], edx
	mov	rcx, QWORD PTR [rcx]
	cvttss2si edx, DWORD PTR size$[rsp]
	jmp	glfwSetWindowSize
?ImGui_ImplGlfw_SetWindowSize@@YAXPEAUImGuiViewport@@UImVec2@@@Z ENDP ; ImGui_ImplGlfw_SetWindowSize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?ImGui_ImplGlfw_SetWindowTitle@@YAXPEAUImGuiViewport@@PEBD@Z
_TEXT	SEGMENT
viewport$ = 8
title$ = 16
?ImGui_ImplGlfw_SetWindowTitle@@YAXPEAUImGuiViewport@@PEBD@Z PROC ; ImGui_ImplGlfw_SetWindowTitle, COMDAT

; 1161 :     ImGui_ImplGlfw_ViewportData* vd = (ImGui_ImplGlfw_ViewportData*)viewport->PlatformUserData;
; 1162 :     glfwSetWindowTitle(vd->Window, title);

	mov	rcx, QWORD PTR [rcx+64]
	mov	rcx, QWORD PTR [rcx]
	jmp	glfwSetWindowTitle
?ImGui_ImplGlfw_SetWindowTitle@@YAXPEAUImGuiViewport@@PEBD@Z ENDP ; ImGui_ImplGlfw_SetWindowTitle
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?ImGui_ImplGlfw_SetWindowFocus@@YAXPEAUImGuiViewport@@@Z
_TEXT	SEGMENT
viewport$ = 8
?ImGui_ImplGlfw_SetWindowFocus@@YAXPEAUImGuiViewport@@@Z PROC ; ImGui_ImplGlfw_SetWindowFocus, COMDAT

; 1167 : #if GLFW_HAS_FOCUS_WINDOW
; 1168 :     ImGui_ImplGlfw_ViewportData* vd = (ImGui_ImplGlfw_ViewportData*)viewport->PlatformUserData;
; 1169 :     glfwFocusWindow(vd->Window);

	mov	rcx, QWORD PTR [rcx+64]
	mov	rcx, QWORD PTR [rcx]
	jmp	glfwFocusWindow
?ImGui_ImplGlfw_SetWindowFocus@@YAXPEAUImGuiViewport@@@Z ENDP ; ImGui_ImplGlfw_SetWindowFocus
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?ImGui_ImplGlfw_GetWindowFocus@@YA_NPEAUImGuiViewport@@@Z
_TEXT	SEGMENT
viewport$ = 48
?ImGui_ImplGlfw_GetWindowFocus@@YA_NPEAUImGuiViewport@@@Z PROC ; ImGui_ImplGlfw_GetWindowFocus, COMDAT

; 1177 : {

	sub	rsp, 40					; 00000028H

; 1178 :     ImGui_ImplGlfw_ViewportData* vd = (ImGui_ImplGlfw_ViewportData*)viewport->PlatformUserData;

	mov	rcx, QWORD PTR [rcx+64]

; 1179 :     return glfwGetWindowAttrib(vd->Window, GLFW_FOCUSED) != 0;

	mov	edx, 131073				; 00020001H
	mov	rcx, QWORD PTR [rcx]
	call	glfwGetWindowAttrib
	test	eax, eax
	setne	al

; 1180 : }

	add	rsp, 40					; 00000028H
	ret	0
?ImGui_ImplGlfw_GetWindowFocus@@YA_NPEAUImGuiViewport@@@Z ENDP ; ImGui_ImplGlfw_GetWindowFocus
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?ImGui_ImplGlfw_GetWindowMinimized@@YA_NPEAUImGuiViewport@@@Z
_TEXT	SEGMENT
viewport$ = 48
?ImGui_ImplGlfw_GetWindowMinimized@@YA_NPEAUImGuiViewport@@@Z PROC ; ImGui_ImplGlfw_GetWindowMinimized, COMDAT

; 1183 : {

	sub	rsp, 40					; 00000028H

; 1184 :     ImGui_ImplGlfw_ViewportData* vd = (ImGui_ImplGlfw_ViewportData*)viewport->PlatformUserData;

	mov	rcx, QWORD PTR [rcx+64]

; 1185 :     return glfwGetWindowAttrib(vd->Window, GLFW_ICONIFIED) != 0;

	mov	edx, 131074				; 00020002H
	mov	rcx, QWORD PTR [rcx]
	call	glfwGetWindowAttrib
	test	eax, eax
	setne	al

; 1186 : }

	add	rsp, 40					; 00000028H
	ret	0
?ImGui_ImplGlfw_GetWindowMinimized@@YA_NPEAUImGuiViewport@@@Z ENDP ; ImGui_ImplGlfw_GetWindowMinimized
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?ImGui_ImplGlfw_SetWindowAlpha@@YAXPEAUImGuiViewport@@M@Z
_TEXT	SEGMENT
viewport$ = 8
alpha$ = 16
?ImGui_ImplGlfw_SetWindowAlpha@@YAXPEAUImGuiViewport@@M@Z PROC ; ImGui_ImplGlfw_SetWindowAlpha, COMDAT

; 1191 :     ImGui_ImplGlfw_ViewportData* vd = (ImGui_ImplGlfw_ViewportData*)viewport->PlatformUserData;
; 1192 :     glfwSetWindowOpacity(vd->Window, alpha);

	mov	rcx, QWORD PTR [rcx+64]
	mov	rcx, QWORD PTR [rcx]
	jmp	glfwSetWindowOpacity
?ImGui_ImplGlfw_SetWindowAlpha@@YAXPEAUImGuiViewport@@M@Z ENDP ; ImGui_ImplGlfw_SetWindowAlpha
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?ImGui_ImplGlfw_RenderWindow@@YAXPEAUImGuiViewport@@PEAX@Z
_TEXT	SEGMENT
viewport$ = 8
__formal$ = 16
?ImGui_ImplGlfw_RenderWindow@@YAXPEAUImGuiViewport@@PEAX@Z PROC ; ImGui_ImplGlfw_RenderWindow, COMDAT

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN7@ImGui_Impl
	mov	rax, QWORD PTR [rax+152]
$LN7@ImGui_Impl:

; 1198 :     ImGui_ImplGlfw_Data* bd = ImGui_ImplGlfw_GetBackendData();
; 1199 :     ImGui_ImplGlfw_ViewportData* vd = (ImGui_ImplGlfw_ViewportData*)viewport->PlatformUserData;
; 1200 :     if (bd->ClientApi == GlfwClientApi_OpenGL)

	cmp	DWORD PTR [rax+8], 1
	jne	SHORT $LN2@ImGui_Impl

; 1201 :         glfwMakeContextCurrent(vd->Window);

	mov	rcx, QWORD PTR [rcx+64]
	mov	rcx, QWORD PTR [rcx]
	jmp	glfwMakeContextCurrent
$LN2@ImGui_Impl:

; 1202 : }

	ret	0
?ImGui_ImplGlfw_RenderWindow@@YAXPEAUImGuiViewport@@PEAX@Z ENDP ; ImGui_ImplGlfw_RenderWindow
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?ImGui_ImplGlfw_SwapBuffers@@YAXPEAUImGuiViewport@@PEAX@Z
_TEXT	SEGMENT
viewport$ = 48
__formal$ = 56
?ImGui_ImplGlfw_SwapBuffers@@YAXPEAUImGuiViewport@@PEAX@Z PROC ; ImGui_ImplGlfw_SwapBuffers, COMDAT

; 1205 : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN7@ImGui_Impl
	mov	rax, QWORD PTR [rax+152]
$LN7@ImGui_Impl:

; 1206 :     ImGui_ImplGlfw_Data* bd = ImGui_ImplGlfw_GetBackendData();
; 1207 :     ImGui_ImplGlfw_ViewportData* vd = (ImGui_ImplGlfw_ViewportData*)viewport->PlatformUserData;
; 1208 :     if (bd->ClientApi == GlfwClientApi_OpenGL)

	cmp	DWORD PTR [rax+8], 1
	mov	rbx, QWORD PTR [rcx+64]
	jne	SHORT $LN2@ImGui_Impl

; 1209 :     {
; 1210 :         glfwMakeContextCurrent(vd->Window);

	mov	rcx, QWORD PTR [rbx]
	call	glfwMakeContextCurrent

; 1211 :         glfwSwapBuffers(vd->Window);

	mov	rcx, QWORD PTR [rbx]

; 1212 :     }
; 1213 : }

	add	rsp, 32					; 00000020H
	pop	rbx

; 1211 :         glfwSwapBuffers(vd->Window);

	jmp	glfwSwapBuffers
$LN2@ImGui_Impl:

; 1212 :     }
; 1213 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?ImGui_ImplGlfw_SwapBuffers@@YAXPEAUImGuiViewport@@PEAX@Z ENDP ; ImGui_ImplGlfw_SwapBuffers
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?ImGui_ImplGlfw_CreateVkSurface@@YAHPEAUImGuiViewport@@_KPEBXPEA_K@Z
_TEXT	SEGMENT
viewport$ = 8
vk_instance$ = 16
vk_allocator$ = 24
out_vk_surface$ = 32
?ImGui_ImplGlfw_CreateVkSurface@@YAHPEAUImGuiViewport@@_KPEBXPEA_K@Z PROC ; ImGui_ImplGlfw_CreateVkSurface, COMDAT

; 1235 : {

	mov	rax, rdx

; 1236 :     ImGui_ImplGlfw_Data* bd = ImGui_ImplGlfw_GetBackendData();
; 1237 :     ImGui_ImplGlfw_ViewportData* vd = (ImGui_ImplGlfw_ViewportData*)viewport->PlatformUserData;

	mov	rdx, QWORD PTR [rcx+64]

; 1238 :     IM_UNUSED(bd);
; 1239 :     IM_ASSERT(bd->ClientApi == GlfwClientApi_Vulkan);
; 1240 :     VkResult err = glfwCreateWindowSurface((VkInstance)vk_instance, vd->Window, (const VkAllocationCallbacks*)vk_allocator, (VkSurfaceKHR*)out_vk_surface);

	mov	rcx, rax
	mov	rdx, QWORD PTR [rdx]
	jmp	glfwCreateWindowSurface
?ImGui_ImplGlfw_CreateVkSurface@@YAHPEAUImGuiViewport@@_KPEBXPEA_K@Z ENDP ; ImGui_ImplGlfw_CreateVkSurface
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?ImGui_ImplGlfw_InitPlatformInterface@@YAXXZ
_TEXT	SEGMENT
?ImGui_ImplGlfw_InitPlatformInterface@@YAXXZ PROC	; ImGui_ImplGlfw_InitPlatformInterface, COMDAT

; 1246 : {

	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 177  :     return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rcx, rcx
	je	SHORT $LN8@ImGui_Impl
	mov	rbx, QWORD PTR [rcx+152]
	jmp	SHORT $LN9@ImGui_Impl
$LN8@ImGui_Impl:
	xor	ebx, ebx
$LN9@ImGui_Impl:

; 1247 :     // Register platform interface (will be coupled with a renderer interface)
; 1248 :     ImGui_ImplGlfw_Data* bd = ImGui_ImplGlfw_GetBackendData();
; 1249 :     ImGuiPlatformIO& platform_io = ImGui::GetPlatformIO();
; 1250 :     platform_io.Platform_CreateWindow = ImGui_ImplGlfw_CreateWindow;

	lea	rax, OFFSET FLAT:?ImGui_ImplGlfw_CreateWindow@@YAXPEAUImGuiViewport@@@Z ; ImGui_ImplGlfw_CreateWindow
	mov	QWORD PTR [rcx+14336], rax

; 1251 :     platform_io.Platform_DestroyWindow = ImGui_ImplGlfw_DestroyWindow;

	lea	rax, OFFSET FLAT:?ImGui_ImplGlfw_DestroyWindow@@YAXPEAUImGuiViewport@@@Z ; ImGui_ImplGlfw_DestroyWindow
	mov	QWORD PTR [rcx+14344], rax

; 1252 :     platform_io.Platform_ShowWindow = ImGui_ImplGlfw_ShowWindow;

	lea	rax, OFFSET FLAT:?ImGui_ImplGlfw_ShowWindow@@YAXPEAUImGuiViewport@@@Z ; ImGui_ImplGlfw_ShowWindow
	mov	QWORD PTR [rcx+14352], rax

; 1253 :     platform_io.Platform_SetWindowPos = ImGui_ImplGlfw_SetWindowPos;

	lea	rax, OFFSET FLAT:?ImGui_ImplGlfw_SetWindowPos@@YAXPEAUImGuiViewport@@UImVec2@@@Z ; ImGui_ImplGlfw_SetWindowPos
	mov	QWORD PTR [rcx+14360], rax

; 1254 :     platform_io.Platform_GetWindowPos = ImGui_ImplGlfw_GetWindowPos;

	lea	rax, OFFSET FLAT:?ImGui_ImplGlfw_GetWindowPos@@YA?AUImVec2@@PEAUImGuiViewport@@@Z ; ImGui_ImplGlfw_GetWindowPos
	mov	QWORD PTR [rcx+14368], rax

; 1255 :     platform_io.Platform_SetWindowSize = ImGui_ImplGlfw_SetWindowSize;

	lea	rax, OFFSET FLAT:?ImGui_ImplGlfw_SetWindowSize@@YAXPEAUImGuiViewport@@UImVec2@@@Z ; ImGui_ImplGlfw_SetWindowSize
	mov	QWORD PTR [rcx+14376], rax

; 1256 :     platform_io.Platform_GetWindowSize = ImGui_ImplGlfw_GetWindowSize;

	lea	rax, OFFSET FLAT:?ImGui_ImplGlfw_GetWindowSize@@YA?AUImVec2@@PEAUImGuiViewport@@@Z ; ImGui_ImplGlfw_GetWindowSize
	mov	QWORD PTR [rcx+14384], rax

; 1257 :     platform_io.Platform_SetWindowFocus = ImGui_ImplGlfw_SetWindowFocus;

	lea	rax, OFFSET FLAT:?ImGui_ImplGlfw_SetWindowFocus@@YAXPEAUImGuiViewport@@@Z ; ImGui_ImplGlfw_SetWindowFocus
	mov	QWORD PTR [rcx+14392], rax

; 1258 :     platform_io.Platform_GetWindowFocus = ImGui_ImplGlfw_GetWindowFocus;

	lea	rax, OFFSET FLAT:?ImGui_ImplGlfw_GetWindowFocus@@YA_NPEAUImGuiViewport@@@Z ; ImGui_ImplGlfw_GetWindowFocus
	mov	QWORD PTR [rcx+14400], rax

; 1259 :     platform_io.Platform_GetWindowMinimized = ImGui_ImplGlfw_GetWindowMinimized;

	lea	rax, OFFSET FLAT:?ImGui_ImplGlfw_GetWindowMinimized@@YA_NPEAUImGuiViewport@@@Z ; ImGui_ImplGlfw_GetWindowMinimized
	mov	QWORD PTR [rcx+14408], rax

; 1260 :     platform_io.Platform_SetWindowTitle = ImGui_ImplGlfw_SetWindowTitle;

	lea	rax, OFFSET FLAT:?ImGui_ImplGlfw_SetWindowTitle@@YAXPEAUImGuiViewport@@PEBD@Z ; ImGui_ImplGlfw_SetWindowTitle
	mov	QWORD PTR [rcx+14416], rax

; 1261 :     platform_io.Platform_RenderWindow = ImGui_ImplGlfw_RenderWindow;

	lea	rax, OFFSET FLAT:?ImGui_ImplGlfw_RenderWindow@@YAXPEAUImGuiViewport@@PEAX@Z ; ImGui_ImplGlfw_RenderWindow
	mov	QWORD PTR [rcx+14440], rax

; 1262 :     platform_io.Platform_SwapBuffers = ImGui_ImplGlfw_SwapBuffers;

	lea	rax, OFFSET FLAT:?ImGui_ImplGlfw_SwapBuffers@@YAXPEAUImGuiViewport@@PEAX@Z ; ImGui_ImplGlfw_SwapBuffers
	mov	QWORD PTR [rcx+14448], rax

; 1263 : #if GLFW_HAS_WINDOW_ALPHA
; 1264 :     platform_io.Platform_SetWindowAlpha = ImGui_ImplGlfw_SetWindowAlpha;

	lea	rax, OFFSET FLAT:?ImGui_ImplGlfw_SetWindowAlpha@@YAXPEAUImGuiViewport@@M@Z ; ImGui_ImplGlfw_SetWindowAlpha
	mov	QWORD PTR [rcx+14424], rax

; 1265 : #endif
; 1266 : #if GLFW_HAS_VULKAN
; 1267 :     platform_io.Platform_CreateVkSurface = ImGui_ImplGlfw_CreateVkSurface;

	lea	rax, OFFSET FLAT:?ImGui_ImplGlfw_CreateVkSurface@@YAHPEAUImGuiViewport@@_KPEBXPEA_K@Z ; ImGui_ImplGlfw_CreateVkSurface
	mov	QWORD PTR [rcx+14472], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	rax, QWORD PTR [rcx+18984]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 13999:     return g.Viewports[0];

	mov	rdi, QWORD PTR [rax]

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	rcx, rcx
	je	SHORT $LN15@ImGui_Impl

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rcx+244]
$LN15@ImGui_Impl:

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	mov	ecx, 24
	call	QWORD PTR __imp_malloc
	mov	rcx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp

; 1273 :     ImGui_ImplGlfw_ViewportData* vd = IM_NEW(ImGui_ImplGlfw_ViewportData)();

	test	rax, rax
	je	SHORT $LN3@ImGui_Impl

; 962  :     ImGui_ImplGlfw_ViewportData()  { Window = nullptr; WindowOwned = false; IgnoreWindowSizeEventFrame = IgnoreWindowPosEventFrame = -1; }

	mov	QWORD PTR [rax], 0
	mov	BYTE PTR [rax+8], 0
	mov	QWORD PTR [rax+12], -1

; 1273 :     ImGui_ImplGlfw_ViewportData* vd = IM_NEW(ImGui_ImplGlfw_ViewportData)();

	jmp	SHORT $LN4@ImGui_Impl
$LN3@ImGui_Impl:
	xor	ecx, ecx
$LN4@ImGui_Impl:

; 1274 :     vd->Window = bd->Window;

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rcx], rax

; 1275 :     vd->WindowOwned = false;

	mov	BYTE PTR [rcx+8], 0

; 1276 :     main_viewport->PlatformUserData = vd;

	mov	QWORD PTR [rdi+64], rcx

; 1277 :     main_viewport->PlatformHandle = (void*)bd->Window;

	mov	rax, QWORD PTR [rbx]

; 1278 : }

	mov	rbx, QWORD PTR [rsp+56]
	mov	QWORD PTR [rdi+72], rax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?ImGui_ImplGlfw_InitPlatformInterface@@YAXXZ ENDP	; ImGui_ImplGlfw_InitPlatformInterface
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_glfw.cpp
;	COMDAT ?ImGui_ImplGlfw_ShutdownPlatformInterface@@YAXXZ
_TEXT	SEGMENT
?ImGui_ImplGlfw_ShutdownPlatformInterface@@YAXXZ PROC	; ImGui_ImplGlfw_ShutdownPlatformInterface, COMDAT

; 1282 :     ImGui::DestroyPlatformWindows();

	jmp	?DestroyPlatformWindows@ImGui@@YAXXZ	; ImGui::DestroyPlatformWindows
?ImGui_ImplGlfw_ShutdownPlatformInterface@@YAXXZ ENDP	; ImGui_ImplGlfw_ShutdownPlatformInterface
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UImGuiPlatformMonitor@@@@QEAAXAEBUImGuiPlatformMonitor@@@Z
_TEXT	SEGMENT
this$ = 48
v$ = 56
?push_back@?$ImVector@UImGuiPlatformMonitor@@@@QEAAXAEBUImGuiPlatformMonitor@@@Z PROC ; ImVector<ImGuiPlatformMonitor>::push_back, COMDAT

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

$LN11:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	r8d, DWORD PTR [rcx]
	mov	rbx, rcx
	mov	ecx, DWORD PTR [rcx+4]
	mov	rdi, rdx
	cmp	r8d, ecx
	jne	SHORT $LN2@push_back
	inc	r8d

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN6@push_back
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@push_back
$LN6@push_back:
	mov	eax, 8
$LN7@push_back:
	cmp	eax, r8d

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rcx, rbx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	r8d, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, r8d
	call	?reserve@?$ImVector@UImGuiPlatformMonitor@@@@QEAAXH@Z ; ImVector<ImGuiPlatformMonitor>::reserve
$LN2@push_back:
	movsxd	rax, DWORD PTR [rbx]
	movups	xmm0, XMMWORD PTR [rdi]
	lea	rcx, QWORD PTR [rax+rax*2]
	mov	rax, QWORD PTR [rbx+8]
	add	rcx, rcx
	movups	XMMWORD PTR [rax+rcx*8], xmm0
	movups	xmm1, XMMWORD PTR [rdi+16]
	movups	XMMWORD PTR [rax+rcx*8+16], xmm1
	movups	xmm0, XMMWORD PTR [rdi+32]
	movups	XMMWORD PTR [rax+rcx*8+32], xmm0
	inc	DWORD PTR [rbx]
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?push_back@?$ImVector@UImGuiPlatformMonitor@@@@QEAAXAEBUImGuiPlatformMonitor@@@Z ENDP ; ImVector<ImGuiPlatformMonitor>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImGuiPlatformMonitor@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$dead$ = 56
?resize@?$ImVector@UImGuiPlatformMonitor@@@@QEAAXH@Z PROC ; ImVector<ImGuiPlatformMonitor>::resize, COMDAT

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN11:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	ecx, DWORD PTR [rcx+4]
	test	ecx, ecx
	jns	SHORT $LN8@resize

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	eax, ecx
	cdq
	sub	eax, edx
	xor	edx, edx
	sar	eax, 1
	add	eax, ecx

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	rcx, rbx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	eax, eax
	cmovg	edx, eax

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	call	?reserve@?$ImVector@UImGuiPlatformMonitor@@@@QEAAXH@Z ; ImVector<ImGuiPlatformMonitor>::reserve
$LN8@resize:
	mov	DWORD PTR [rbx], 0
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?resize@?$ImVector@UImGuiPlatformMonitor@@@@QEAAXH@Z ENDP ; ImVector<ImGuiPlatformMonitor>::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImGuiPlatformMonitor@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_capacity$ = 56
?reserve@?$ImVector@UImGuiPlatformMonitor@@@@QEAAXH@Z PROC ; ImVector<ImGuiPlatformMonitor>::reserve, COMDAT

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

$LN26:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	movsxd	rdi, edx
	mov	rbx, rcx
	cmp	edi, DWORD PTR [rcx+4]
	jle	SHORT $LN1@reserve
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rsp+48], rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN6@reserve

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN6@reserve:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	lea	rcx, QWORD PTR [rdi+rdi*2]
	shl	rcx, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	rdx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	mov	rsi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	test	rdx, rdx
	je	SHORT $LN16@reserve
	movsxd	rcx, DWORD PTR [rbx]
	lea	r8, QWORD PTR [rcx+rcx*2]
	mov	rcx, rax
	shl	r8, 4
	call	memcpy
	mov	rcx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	test	rcx, rcx
	je	SHORT $LN14@reserve

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN14@reserve

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN14@reserve:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
$LN16@reserve:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rbx+8], rsi
	mov	rsi, QWORD PTR [rsp+48]
	mov	DWORD PTR [rbx+4], edi
$LN1@reserve:
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?reserve@?$ImVector@UImGuiPlatformMonitor@@@@QEAAXH@Z ENDP ; ImVector<ImGuiPlatformMonitor>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImGuiPlatformMonitor@@@@QEBAHH@Z
_TEXT	SEGMENT
this$ = 8
sz$ = 16
?_grow_capacity@?$ImVector@UImGuiPlatformMonitor@@@@QEBAHH@Z PROC ; ImVector<ImGuiPlatformMonitor>::_grow_capacity, COMDAT

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	r9d, DWORD PTR [rcx+4]
	mov	r8d, edx
	test	r9d, r9d
	je	SHORT $LN3@grow_capac
	mov	eax, r9d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r9d
	cmp	eax, r8d
	cmovg	r8d, eax
	mov	eax, r8d
	ret	0
$LN3@grow_capac:
	mov	eax, 8
	cmp	eax, r8d
	cmovg	r8d, eax
	mov	eax, r8d
	ret	0
?_grow_capacity@?$ImVector@UImGuiPlatformMonitor@@@@QEBAHH@Z ENDP ; ImVector<ImGuiPlatformMonitor>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??$IM_DELETE@UImGui_ImplGlfw_Data@@@@YAXPEAUImGui_ImplGlfw_Data@@@Z
_TEXT	SEGMENT
p$ = 8
??$IM_DELETE@UImGui_ImplGlfw_Data@@@@YAXPEAUImGui_ImplGlfw_Data@@@Z PROC ; IM_DELETE<ImGui_ImplGlfw_Data>, COMDAT

; 1876 : template<typename T> void IM_DELETE(T* p)   { if (p) { p->~T(); ImGui::MemFree(p); } }

	test	rcx, rcx
	je	SHORT $LN8@IM_DELETE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN6@IM_DELETE

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN6@IM_DELETE:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	rex_jmp	QWORD PTR __imp_free
$LN8@IM_DELETE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1876 : template<typename T> void IM_DELETE(T* p)   { if (p) { p->~T(); ImGui::MemFree(p); } }

	ret	0
??$IM_DELETE@UImGui_ImplGlfw_Data@@@@YAXPEAUImGui_ImplGlfw_Data@@@Z ENDP ; IM_DELETE<ImGui_ImplGlfw_Data>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??$IM_DELETE@UImGui_ImplGlfw_ViewportData@@@@YAXPEAUImGui_ImplGlfw_ViewportData@@@Z
_TEXT	SEGMENT
p$ = 8
??$IM_DELETE@UImGui_ImplGlfw_ViewportData@@@@YAXPEAUImGui_ImplGlfw_ViewportData@@@Z PROC ; IM_DELETE<ImGui_ImplGlfw_ViewportData>, COMDAT

; 1876 : template<typename T> void IM_DELETE(T* p)   { if (p) { p->~T(); ImGui::MemFree(p); } }

	test	rcx, rcx
	je	SHORT $LN8@IM_DELETE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN6@IM_DELETE

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN6@IM_DELETE:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	rex_jmp	QWORD PTR __imp_free
$LN8@IM_DELETE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1876 : template<typename T> void IM_DELETE(T* p)   { if (p) { p->~T(); ImGui::MemFree(p); } }

	ret	0
??$IM_DELETE@UImGui_ImplGlfw_ViewportData@@@@YAXPEAUImGui_ImplGlfw_ViewportData@@@Z ENDP ; IM_DELETE<ImGui_ImplGlfw_ViewportData>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_GImGui_ImplGlfw_ViewportData@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 8
__flags$dead$ = 16
??_GImGui_ImplGlfw_ViewportData@@QEAAPEAXI@Z PROC	; ImGui_ImplGlfw_ViewportData::`scalar deleting destructor', COMDAT
	mov	rax, rcx
	ret	0
??_GImGui_ImplGlfw_ViewportData@@QEAAPEAXI@Z ENDP	; ImGui_ImplGlfw_ViewportData::`scalar deleting destructor'
_TEXT	ENDS
END
