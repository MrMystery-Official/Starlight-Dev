; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32822.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CL@ODJIEOCJ@Wrong?5node?5type?0?5could?5not?5pars@ ; `string'
PUBLIC	??_C@_0BN@GLAHIIGB@Got?5BYML?5node?5with?5null?5type@ ; `string'
PUBLIC	??_C@_0M@EFFJMBCP@BymlDecoder@			; `string'
PUBLIC	??_C@_0M@ILPEJFEL@BymlEncoder@			; `string'
PUBLIC	??_C@_0BI@HCAOJHPJ@Unsupported?5node?5type?3?5@	; `string'
PUBLIC	??_C@_04NBFCGMPH@root@				; `string'
PUBLIC	??_C@_02KBJMBOFF@YB@				; `string'
PUBLIC	??_C@_0BJ@CILBIDFB@Encoded?5BYML?5data?0?5took?5@ ; `string'
PUBLIC	??_C@_02EEKDFEKL@ms@				; `string'
PUBLIC	??_C@_0CI@PEJJCEAH@Wrong?5version?0?5expected?5v2?5or?5v@ ; `string'
PUBLIC	??_C@_0BP@KCOKJPO@Wrong?5magic?0?5expected?5YB?5or?5BY@ ; `string'
PUBLIC	??_C@_0DF@HGLJMNNH@Expected?5array?5?$CI0xC0?$CJ?5or?5dictio@ ; `string'
EXTRN	__imp__Xtime_get_ticks:PROC
EXTRN	__imp_isdigit:PROC
;	COMDAT ??_C@_0DF@HGLJMNNH@Expected?5array?5?$CI0xC0?$CJ?5or?5dictio@
CONST	SEGMENT
??_C@_0DF@HGLJMNNH@Expected?5array?5?$CI0xC0?$CJ?5or?5dictio@ DB 'Expecte'
	DB	'd array (0xC0) or dictionary (0xC1), but got ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@KCOKJPO@Wrong?5magic?0?5expected?5YB?5or?5BY@
CONST	SEGMENT
??_C@_0BP@KCOKJPO@Wrong?5magic?0?5expected?5YB?5or?5BY@ DB 'Wrong magic, '
	DB	'expected YB or BY', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@PEJJCEAH@Wrong?5version?0?5expected?5v2?5or?5v@
CONST	SEGMENT
??_C@_0CI@PEJJCEAH@Wrong?5version?0?5expected?5v2?5or?5v@ DB 'Wrong versi'
	DB	'on, expected v2 or v7, got v', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02EEKDFEKL@ms@
CONST	SEGMENT
??_C@_02EEKDFEKL@ms@ DB 'ms', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CILBIDFB@Encoded?5BYML?5data?0?5took?5@
CONST	SEGMENT
??_C@_0BJ@CILBIDFB@Encoded?5BYML?5data?0?5took?5@ DB 'Encoded BYML data, '
	DB	'took ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_02KBJMBOFF@YB@
CONST	SEGMENT
??_C@_02KBJMBOFF@YB@ DB 'YB', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04NBFCGMPH@root@
CONST	SEGMENT
??_C@_04NBFCGMPH@root@ DB 'root', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HCAOJHPJ@Unsupported?5node?5type?3?5@
CONST	SEGMENT
??_C@_0BI@HCAOJHPJ@Unsupported?5node?5type?3?5@ DB 'Unsupported node type'
	DB	': ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@ILPEJFEL@BymlEncoder@
CONST	SEGMENT
??_C@_0M@ILPEJFEL@BymlEncoder@ DB 'BymlEncoder', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EFFJMBCP@BymlDecoder@
CONST	SEGMENT
??_C@_0M@EFFJMBCP@BymlDecoder@ DB 'BymlDecoder', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@GLAHIIGB@Got?5BYML?5node?5with?5null?5type@
CONST	SEGMENT
??_C@_0BN@GLAHIIGB@Got?5BYML?5node?5with?5null?5type@ DB 'Got BYML node w'
	DB	'ith null type', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@ODJIEOCJ@Wrong?5node?5type?0?5could?5not?5pars@
CONST	SEGMENT
??_C@_0CL@ODJIEOCJ@Wrong?5node?5type?0?5could?5not?5pars@ DB 'Wrong node '
	DB	'type, could not parse key table', 00H	; `string'
PUBLIC	??$move@AEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@YA$$QEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@0@AEAV10@@Z ; std::move<std::tuple<std::vector<unsigned char,std::allocator<unsigned char> > const &> &>
PUBLIC	??$move@AEAV?$tuple@AEBVNode@BymlFile@@@std@@@std@@YA$$QEAV?$tuple@AEBVNode@BymlFile@@@0@AEAV10@@Z ; std::move<std::tuple<BymlFile::Node const &> &>
PUBLIC	??$move@AEAPEAD@std@@YA$$QEAPEADAEAPEAD@Z	; std::move<char * &>
PUBLIC	??$_Tuple_get@$0A@AEBV?$vector@EV?$allocator@E@std@@@std@@@std@@YA$$QEA_P$$QEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@0@@Z ; std::_Tuple_get<0,std::vector<unsigned char,std::allocator<unsigned char> > const &>
PUBLIC	??$?0V?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@QEAA@AEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z ; std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int><std::tuple<std::vector<unsigned char,std::allocator<unsigned char> > const &>,std::tuple<>,0>
PUBLIC	??$_Tuple_get@$0A@AEBVNode@BymlFile@@@std@@YA$$QEA_P$$QEAV?$tuple@AEBVNode@BymlFile@@@0@@Z ; std::_Tuple_get<0,BymlFile::Node const &>
PUBLIC	??$?0V?$tuple@AEBVNode@BymlFile@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@AEAV?$tuple@AEBVNode@BymlFile@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z ; std::pair<BymlFile::Node const ,unsigned int>::pair<BymlFile::Node const ,unsigned int><std::tuple<BymlFile::Node const &>,std::tuple<>,0>
PUBLIC	??$swap@PEAD$0A@@std@@YAXAEAPEAD0@Z		; std::swap<char *,0>
PUBLIC	??$_Pocs@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z ; std::_Pocs<std::allocator<char> >
PUBLIC	??$construct_at@VNode@BymlFile@@$$V$0A@@std@@YAPEAVNode@BymlFile@@QEAV12@@Z ; std::construct_at<BymlFile::Node,0>
PUBLIC	??$construct_at@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V$0A@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@@Z ; std::construct_at<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,0>
PUBLIC	??$?0AEBV?$vector@EV?$allocator@E@std@@@std@@@?$_Tuple_val@AEBV?$vector@EV?$allocator@E@std@@@std@@@std@@QEAA@AEBV?$vector@EV?$allocator@E@std@@@1@@Z ; std::_Tuple_val<std::vector<unsigned char,std::allocator<unsigned char> > const &>::_Tuple_val<std::vector<unsigned char,std::allocator<unsigned char> > const &><std::vector<unsigned char,std::allocator<unsigned char> > const &>
PUBLIC	??$?0AEBVNode@BymlFile@@@?$_Tuple_val@AEBVNode@BymlFile@@@std@@QEAA@AEBVNode@BymlFile@@@Z ; std::_Tuple_val<BymlFile::Node const &>::_Tuple_val<BymlFile::Node const &><BymlFile::Node const &>
PUBLIC	??$forward@AEAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAEAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAPEAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * &>
PUBLIC	??$?0AEBV?$vector@EV?$allocator@E@std@@@std@@$$Z$$V@?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@V?$tuple@$$V@1@@Z ; std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int><std::vector<unsigned char,std::allocator<unsigned char> > const &>
PUBLIC	??$?0AEBVNode@BymlFile@@$$Z$$V@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBVNode@BymlFile@@@1@V?$tuple@$$V@1@@Z ; std::pair<BymlFile::Node const ,unsigned int>::pair<BymlFile::Node const ,unsigned int><BymlFile::Node const &>
PUBLIC	?_Swap_bx_large_with_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXAEAV?$_String_val@U?$_Simple_types@D@std@@@2@0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_bx_large_with_small
PUBLIC	?_Swap_data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_data
PUBLIC	?swap@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::swap
PUBLIC	??0?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@QEAA@$$QEAU01@@Z ; std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>
PUBLIC	??0?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@std@@QEAA@$$QEAV01@@Z ; std::tuple<std::vector<unsigned char,std::allocator<unsigned char> > const &>::tuple<std::vector<unsigned char,std::allocator<unsigned char> > const &>
PUBLIC	??0?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@$$QEAU01@@Z ; std::pair<BymlFile::Node const ,unsigned int>::pair<BymlFile::Node const ,unsigned int>
PUBLIC	??0?$tuple@AEBVNode@BymlFile@@@std@@QEAA@$$QEAV01@@Z ; std::tuple<BymlFile::Node const &>::tuple<BymlFile::Node const &>
PUBLIC	??$construct@VNode@BymlFile@@$$V@?$_Default_allocator_traits@V?$allocator@VNode@BymlFile@@@std@@@std@@SAXAEAV?$allocator@VNode@BymlFile@@@1@QEAVNode@BymlFile@@@Z ; std::_Default_allocator_traits<std::allocator<BymlFile::Node> >::construct<BymlFile::Node>
PUBLIC	??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$construct_at@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@U12@$0A@@std@@YAPEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@0@QEAU10@$$QEAU10@@Z ; std::construct_at<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,0>
PUBLIC	??$construct_at@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@0@$$QEAV?$tuple@$$V@0@@Z ; std::construct_at<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,std::piecewise_construct_t const &,std::tuple<std::vector<unsigned char,std::allocator<unsigned char> > const &>,std::tuple<>,0>
PUBLIC	??$?0U_Exact_args_t@std@@AEBV?$vector@EV?$allocator@E@std@@@1@$$V$0A@@?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@std@@QEAA@U_Exact_args_t@1@AEBV?$vector@EV?$allocator@E@std@@@1@@Z ; std::tuple<std::vector<unsigned char,std::allocator<unsigned char> > const &>::tuple<std::vector<unsigned char,std::allocator<unsigned char> > const &><std::_Exact_args_t,std::vector<unsigned char,std::allocator<unsigned char> > const &,0>
PUBLIC	??$construct_at@U?$pair@$$CBVNode@BymlFile@@I@std@@U12@$0A@@std@@YAPEAU?$pair@$$CBVNode@BymlFile@@I@0@QEAU10@$$QEAU10@@Z ; std::construct_at<std::pair<BymlFile::Node const ,unsigned int>,std::pair<BymlFile::Node const ,unsigned int>,0>
PUBLIC	??$construct_at@U?$pair@$$CBVNode@BymlFile@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBVNode@BymlFile@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBVNode@BymlFile@@I@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBVNode@BymlFile@@@0@$$QEAV?$tuple@$$V@0@@Z ; std::construct_at<std::pair<BymlFile::Node const ,unsigned int>,std::piecewise_construct_t const &,std::tuple<BymlFile::Node const &>,std::tuple<>,0>
PUBLIC	??$?0U_Exact_args_t@std@@AEBVNode@BymlFile@@$$V$0A@@?$tuple@AEBVNode@BymlFile@@@std@@QEAA@U_Exact_args_t@1@AEBVNode@BymlFile@@@Z ; std::tuple<BymlFile::Node const &>::tuple<BymlFile::Node const &><std::_Exact_args_t,BymlFile::Node const &,0>
PUBLIC	??$?0AEAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAPEAV01@$0A@@?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@std@@QEAA@AEAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *><std::basic_string<char,std::char_traits<char>,std::allocator<char> > * &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > * &,0>
PUBLIC	??$swap@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::swap<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$_Next_iter@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PEAV10@@Z ; std::_Next_iter<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$_Prev_iter@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PEAV10@@Z ; std::_Prev_iter<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$_Move_backward_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PEAV10@00@Z ; std::_Move_backward_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$?RAEBVNode@BymlFile@@AEBV01@@?$equal_to@X@std@@QEBA_NAEBVNode@BymlFile@@0@Z ; std::equal_to<void>::operator()<BymlFile::Node const &,BymlFile::Node const &>
PUBLIC	??$_Adl_verify_range@PEBVNode@BymlFile@@PEBV12@@std@@YAXAEBQEBVNode@BymlFile@@0@Z ; std::_Adl_verify_range<BymlFile::Node const *,BymlFile::Node const *>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAXXZ ; std::_Uninitialized_backout_al<std::allocator<BymlFile::Node> >::_Emplace_back<>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAXXZ ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back<>
PUBLIC	??$construct@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@$$QEAU31@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> > >::construct<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >
PUBLIC	??$construct@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@$$QEAV?$tuple@$$V@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> > >::construct<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,std::piecewise_construct_t const &,std::tuple<std::vector<unsigned char,std::allocator<unsigned char> > const &>,std::tuple<> >
PUBLIC	??$forward@V?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@YA$$QEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@0@AEAV10@@Z ; std::forward<std::tuple<std::vector<unsigned char,std::allocator<unsigned char> > const &> >
PUBLIC	??$?0AEBV?$vector@EV?$allocator@E@std@@@std@@$0A@@?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@std@@QEAA@AEBV?$vector@EV?$allocator@E@std@@@1@@Z ; std::tuple<std::vector<unsigned char,std::allocator<unsigned char> > const &>::tuple<std::vector<unsigned char,std::allocator<unsigned char> > const &><std::vector<unsigned char,std::allocator<unsigned char> > const &,0>
PUBLIC	??$construct@U?$pair@$$CBVNode@BymlFile@@I@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBVNode@BymlFile@@I@1@$$QEAU31@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > >::construct<std::pair<BymlFile::Node const ,unsigned int>,std::pair<BymlFile::Node const ,unsigned int> >
PUBLIC	??$construct@U?$pair@$$CBVNode@BymlFile@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBVNode@BymlFile@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBVNode@BymlFile@@I@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBVNode@BymlFile@@@1@$$QEAV?$tuple@$$V@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > >::construct<std::pair<BymlFile::Node const ,unsigned int>,std::piecewise_construct_t const &,std::tuple<BymlFile::Node const &>,std::tuple<> >
PUBLIC	??$forward@V?$tuple@AEBVNode@BymlFile@@@std@@@std@@YA$$QEAV?$tuple@AEBVNode@BymlFile@@@0@AEAV10@@Z ; std::forward<std::tuple<BymlFile::Node const &> >
PUBLIC	??$?0AEBVNode@BymlFile@@$0A@@?$tuple@AEBVNode@BymlFile@@@std@@QEAA@AEBVNode@BymlFile@@@Z ; std::tuple<BymlFile::Node const &>::tuple<BymlFile::Node const &><BymlFile::Node const &,0>
PUBLIC	??$equal@PEBVNode@BymlFile@@PEBV12@U?$equal_to@X@std@@@std@@YA_NQEBVNode@BymlFile@@00U?$equal_to@X@0@@Z ; std::equal<BymlFile::Node const *,BymlFile::Node const *,std::equal_to<void> >
PUBLIC	??$_Get_unwrapped_n@AEBQEBVNode@BymlFile@@_J@std@@YA?A_TAEBQEBVNode@BymlFile@@_J@Z ; std::_Get_unwrapped_n<BymlFile::Node const * const &,__int64>
PUBLIC	??$_Idl_distance@PEBVNode@BymlFile@@PEBV12@@std@@YA?A_PAEBQEBVNode@BymlFile@@0@Z ; std::_Idl_distance<BymlFile::Node const *,BymlFile::Node const *>
PUBLIC	??$_Get_unwrapped@AEBQEBVNode@BymlFile@@@std@@YA?A_TAEBQEBVNode@BymlFile@@@Z ; std::_Get_unwrapped<BymlFile::Node const * const &>
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@PEAV12@_KAEAV?$allocator@VNode@BymlFile@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<BymlFile::Node> >
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PEAV10@_KAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$?0U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> > ><std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >
PUBLIC	??$forward@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@std@@YA$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@0@AEAU10@@Z ; std::forward<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >
PUBLIC	??$?0PEAU?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@1@$$QEA_N@Z ; std::pair<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> *,bool>::pair<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> *,bool><std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> *,bool,0>
PUBLIC	??$?0AEAPEAU?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@_N@std@@QEAA@AEAPEAU?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@1@$$QEA_N@Z ; std::pair<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> *,bool>::pair<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> *,bool><std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> * &,bool,0>
PUBLIC	??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@$$QEAV?$tuple@$$V@1@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> > ><std::piecewise_construct_t const &,std::tuple<std::vector<unsigned char,std::allocator<unsigned char> > const &>,std::tuple<> >
PUBLIC	??$forward_as_tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@std@@YA?AV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@0@AEBV?$vector@EV?$allocator@E@std@@@0@@Z ; std::forward_as_tuple<std::vector<unsigned char,std::allocator<unsigned char> > const &>
PUBLIC	??$forward@AEBV?$vector@EV?$allocator@E@std@@@std@@@std@@YAAEBV?$vector@EV?$allocator@E@std@@@0@AEBV10@@Z ; std::forward<std::vector<unsigned char,std::allocator<unsigned char> > const &>
PUBLIC	??$?0U?$pair@$$CBVNode@BymlFile@@I@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBVNode@BymlFile@@I@1@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > ><std::pair<BymlFile::Node const ,unsigned int> >
PUBLIC	??$forward@U?$pair@$$CBVNode@BymlFile@@I@std@@@std@@YA$$QEAU?$pair@$$CBVNode@BymlFile@@I@0@AEAU10@@Z ; std::forward<std::pair<BymlFile::Node const ,unsigned int> >
PUBLIC	??$?0PEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@1@$$QEA_N@Z ; std::pair<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> *,bool>::pair<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> *,bool><std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> *,bool,0>
PUBLIC	??$?0AEAPEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@_N@std@@QEAA@AEAPEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@1@$$QEA_N@Z ; std::pair<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> *,bool>::pair<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> *,bool><std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> * &,bool,0>
PUBLIC	??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBVNode@BymlFile@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBVNode@BymlFile@@@1@$$QEAV?$tuple@$$V@1@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > ><std::piecewise_construct_t const &,std::tuple<BymlFile::Node const &>,std::tuple<> >
PUBLIC	??$forward_as_tuple@AEBVNode@BymlFile@@@std@@YA?AV?$tuple@AEBVNode@BymlFile@@@0@AEBVNode@BymlFile@@@Z ; std::forward_as_tuple<BymlFile::Node const &>
PUBLIC	??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000> >::duration<__int64,std::ratio<1,1000> ><__int64,0>
PUBLIC	??$forward@AEAV?$vector@EV?$allocator@E@std@@@std@@@std@@YAAEAV?$vector@EV?$allocator@E@std@@@0@AEAV10@@Z ; std::forward<std::vector<unsigned char,std::allocator<unsigned char> > &>
PUBLIC	??$equal@PEBVNode@BymlFile@@PEBV12@@std@@YA_NQEBVNode@BymlFile@@00@Z ; std::equal<BymlFile::Node const *,BymlFile::Node const *>
PUBLIC	?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Resize<std::_Value_init_tag>
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Resize<std::_Value_init_tag>
PUBLIC	??$emplace@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@@Z ; std::_Hash<std::_Umap_traits<std::vector<unsigned char,std::allocator<unsigned char> >,unsigned int,std::_Uhash_compare<std::vector<unsigned char,std::allocator<unsigned char> >,BymlFile::VectorHasher,std::equal_to<std::vector<unsigned char,std::allocator<unsigned char> > > >,std::allocator<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >,0> >::emplace<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >
PUBLIC	??$move@AEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@std@@YA$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@0@AEAU10@@Z ; std::move<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> &>
PUBLIC	??$_Try_emplace@AEBV?$vector@EV?$allocator@E@std@@@std@@$$V@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@_N@1@AEBV?$vector@EV?$allocator@E@std@@@1@@Z ; std::_Hash<std::_Umap_traits<std::vector<unsigned char,std::allocator<unsigned char> >,unsigned int,std::_Uhash_compare<std::vector<unsigned char,std::allocator<unsigned char> >,BymlFile::VectorHasher,std::equal_to<std::vector<unsigned char,std::allocator<unsigned char> > > >,std::allocator<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >,0> >::_Try_emplace<std::vector<unsigned char,std::allocator<unsigned char> > const &>
PUBLIC	??$emplace@U?$pair@$$CBVNode@BymlFile@@I@std@@@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVNode@BymlFile@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBVNode@BymlFile@@I@1@@Z ; std::_Hash<std::_Umap_traits<BymlFile::Node,unsigned int,std::_Uhash_compare<BymlFile::Node,BymlFile::NodeHasher,BymlFile::NodeEqual>,std::allocator<std::pair<BymlFile::Node const ,unsigned int> >,0> >::emplace<std::pair<BymlFile::Node const ,unsigned int> >
PUBLIC	??$move@AEAU?$pair@$$CBVNode@BymlFile@@I@std@@@std@@YA$$QEAU?$pair@$$CBVNode@BymlFile@@I@0@AEAU10@@Z ; std::move<std::pair<BymlFile::Node const ,unsigned int> &>
PUBLIC	??$_Try_emplace@AEBVNode@BymlFile@@$$V@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@_N@1@AEBVNode@BymlFile@@@Z ; std::_Hash<std::_Umap_traits<BymlFile::Node,unsigned int,std::_Uhash_compare<BymlFile::Node,BymlFile::NodeHasher,BymlFile::NodeEqual>,std::allocator<std::pair<BymlFile::Node const ,unsigned int> >,0> >::_Try_emplace<BymlFile::Node const &>
PUBLIC	??$?G_JU?$ratio@$00$0DOI@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@AEBV201@0@Z ; std::chrono::operator-<__int64,std::ratio<1,1000>,__int64,std::ratio<1,1000> >
PUBLIC	??$duration_cast@V?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000> >,__int64,std::ratio<1,10000000>,0>
PUBLIC	??$?0AEAVNode@BymlFile@@AEAI$0A@@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@AEAVNode@BymlFile@@AEAI@Z ; std::pair<BymlFile::Node const ,unsigned int>::pair<BymlFile::Node const ,unsigned int><BymlFile::Node &,unsigned int &,0>
PUBLIC	??$contains@X@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@QEBA_NAEBVNode@BymlFile@@@Z ; std::_Hash<std::_Umap_traits<BymlFile::Node,unsigned int,std::_Uhash_compare<BymlFile::Node,BymlFile::NodeHasher,BymlFile::NodeEqual>,std::allocator<std::pair<BymlFile::Node const ,unsigned int> >,0> >::contains<void>
PUBLIC	??$?0AEAV?$vector@EV?$allocator@E@std@@@std@@I$0A@@?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@QEAA@AEAV?$vector@EV?$allocator@E@std@@@1@$$QEAI@Z ; std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int><std::vector<unsigned char,std::allocator<unsigned char> > &,unsigned int,0>
PUBLIC	??$contains@X@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@QEBA_NAEBV?$vector@EV?$allocator@E@std@@@1@@Z ; std::_Hash<std::_Umap_traits<std::vector<unsigned char,std::allocator<unsigned char> >,unsigned int,std::_Uhash_compare<std::vector<unsigned char,std::allocator<unsigned char> >,BymlFile::VectorHasher,std::equal_to<std::vector<unsigned char,std::allocator<unsigned char> > > >,std::allocator<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >,0> >::contains<void>
PUBLIC	??$?8VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@YA_NAEBV?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@0@0@Z ; std::operator==<BymlFile::Node,std::allocator<BymlFile::Node> >
PUBLIC	??$?0_J$0A@@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64,0>
PUBLIC	?_Reallocate_exactly@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAX_K@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reallocate_exactly
PUBLIC	?_Unchecked_begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_end
PUBLIC	?clear@?$vector@EV?$allocator@E@std@@@std@@QEAAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::clear
PUBLIC	?resize@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAX_K@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::resize
PUBLIC	??A?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAAEAVNode@BymlFile@@_K@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::operator[]
PUBLIC	?resize@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAX_K@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::resize
PUBLIC	?shrink_to_fit@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::shrink_to_fit
PUBLIC	?clear@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::clear
PUBLIC	??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[]
PUBLIC	?insert@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@std@@@std@@@std@@_N@2@$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@2@@Z ; std::_Hash<std::_Umap_traits<std::vector<unsigned char,std::allocator<unsigned char> >,unsigned int,std::_Uhash_compare<std::vector<unsigned char,std::allocator<unsigned char> >,BymlFile::VectorHasher,std::equal_to<std::vector<unsigned char,std::allocator<unsigned char> > > >,std::allocator<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >,0> >::insert
PUBLIC	??A?$unordered_map@V?$vector@EV?$allocator@E@std@@@std@@IUVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@@std@@QEAAAEAIAEBV?$vector@EV?$allocator@E@std@@@1@@Z ; std::unordered_map<std::vector<unsigned char,std::allocator<unsigned char> >,unsigned int,BymlFile::VectorHasher,std::equal_to<std::vector<unsigned char,std::allocator<unsigned char> > >,std::allocator<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> > >::operator[]
PUBLIC	?insert@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVNode@BymlFile@@I@std@@@std@@@std@@@std@@_N@2@$$QEAU?$pair@$$CBVNode@BymlFile@@I@2@@Z ; std::_Hash<std::_Umap_traits<BymlFile::Node,unsigned int,std::_Uhash_compare<BymlFile::Node,BymlFile::NodeHasher,BymlFile::NodeEqual>,std::allocator<std::pair<BymlFile::Node const ,unsigned int> >,0> >::insert
PUBLIC	??A?$unordered_map@VNode@BymlFile@@IUNodeHasher@2@UNodeEqual@2@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@std@@@std@@QEAAAEAIAEBVNode@BymlFile@@@Z ; std::unordered_map<BymlFile::Node,unsigned int,BymlFile::NodeHasher,BymlFile::NodeEqual,std::allocator<std::pair<BymlFile::Node const ,unsigned int> > >::operator[]
PUBLIC	??0?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >
PUBLIC	?time_since_epoch@?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QEBA?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@XZ ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_since_epoch
PUBLIC	?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000> >::count
PUBLIC	?WriteToFile@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4TableGeneration@1@@Z ; BymlFile::WriteToFile
PUBLIC	?WriteNode@BymlFile@@AEAAXAEAVBinaryVectorWriter@@IIAEAVNode@1@@Z ; BymlFile::WriteNode
PUBLIC	?GetHashKeyTableIndex@BymlFile@@AEAAIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; BymlFile::GetHashKeyTableIndex
PUBLIC	?GetStringTableIndex@BymlFile@@AEAAIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; BymlFile::GetStringTableIndex
PUBLIC	?GenerateStringTable@BymlFile@@QEAAXPEAVNode@1@@Z ; BymlFile::GenerateStringTable
PUBLIC	?GenerateHashKeyTable@BymlFile@@QEAAXPEAVNode@1@@Z ; BymlFile::GenerateHashKeyTable
PUBLIC	?IsNumber@BymlFile@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; BymlFile::IsNumber
PUBLIC	?GetType@BymlFile@@QEAAAEAW4Type@1@XZ		; BymlFile::GetType
PUBLIC	?ParseNode@BymlFile@@AEAAXAEAVBinaryVectorReader@@HW4Type@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVNode@1@I@Z ; BymlFile::ParseNode
PUBLIC	?AlignUp@BymlFile@@AEAAHHH@Z			; BymlFile::AlignUp
PUBLIC	?ParseTable@BymlFile@@AEAAXAEAVBinaryVectorReader@@PEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@H@Z ; BymlFile::ParseTable
PUBLIC	?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ ; std::chrono::system_clock::now
PUBLIC	??0Node@BymlFile@@QEAA@XZ			; BymlFile::Node::Node
PUBLIC	??8Node@BymlFile@@QEBA_NAEBV01@@Z		; BymlFile::Node::operator==
PUBLIC	?AddChild@Node@BymlFile@@QEAAXV12@@Z		; BymlFile::Node::AddChild
PUBLIC	?GetChild@Node@BymlFile@@QEAAPEAV12@H@Z		; BymlFile::Node::GetChild
PUBLIC	??$SetValue@_K@Node@BymlFile@@QEAAX_K@Z		; BymlFile::Node::SetValue<unsigned __int64>
PUBLIC	??$SetValue@I@Node@BymlFile@@QEAAXI@Z		; BymlFile::Node::SetValue<unsigned int>
PUBLIC	??$SetValue@_J@Node@BymlFile@@QEAAX_J@Z		; BymlFile::Node::SetValue<__int64>
PUBLIC	??$SetValue@H@Node@BymlFile@@QEAAXH@Z		; BymlFile::Node::SetValue<int>
PUBLIC	??$SetValue@M@Node@BymlFile@@QEAAXM@Z		; BymlFile::Node::SetValue<float>
PUBLIC	??$SetValue@N@Node@BymlFile@@QEAAXN@Z		; BymlFile::Node::SetValue<double>
PUBLIC	??$SetValue@_N@Node@BymlFile@@QEAAX_N@Z		; BymlFile::Node::SetValue<bool>
PUBLIC	?HasChild@BymlFile@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; BymlFile::HasChild
PUBLIC	?GetNode@BymlFile@@QEAAPEAVNode@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; BymlFile::GetNode
PUBLIC	?GetChildren@Node@BymlFile@@QEAAAEAV?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@XZ ; BymlFile::Node::GetChildren
PUBLIC	?GetChild@Node@BymlFile@@QEAAPEAV12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; BymlFile::Node::GetChild
PUBLIC	?HasChild@Node@BymlFile@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; BymlFile::Node::HasChild
PUBLIC	??$SetValue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Node@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; BymlFile::Node::SetValue<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	?GetKey@Node@BymlFile@@QEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; BymlFile::Node::GetKey
PUBLIC	?GetType@Node@BymlFile@@QEAAAEAW4Type@2@XZ	; BymlFile::Node::GetType
PUBLIC	??0Node@BymlFile@@QEAA@W4Type@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; BymlFile::Node::Node
PUBLIC	?ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@1@@Z ; BymlFile::ToBinary
PUBLIC	?AddStringTableEntry@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; BymlFile::AddStringTableEntry
PUBLIC	?GetNodes@BymlFile@@QEAAAEAV?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@XZ ; BymlFile::GetNodes
PUBLIC	??0BymlFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z ; BymlFile::BymlFile
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@QEAA@AEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z DD imagerel $LN6
	DD	imagerel $LN6+33
	DD	imagerel $unwind$??$?0V?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@QEAA@AEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$tuple@AEBVNode@BymlFile@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@AEAV?$tuple@AEBVNode@BymlFile@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z DD imagerel $LN11
	DD	imagerel $LN11+91
	DD	imagerel $unwind$??$?0V?$tuple@AEBVNode@BymlFile@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@AEAV?$tuple@AEBVNode@BymlFile@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD imagerel ??$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	imagerel ??$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z+394
	DD	imagerel $unwind$??$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Pop_heap_hole_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00$$QEAV10@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD imagerel ??$_Pop_heap_hole_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00$$QEAV10@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	imagerel ??$_Pop_heap_hole_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00$$QEAV10@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z+82
	DD	imagerel $unwind$??$_Pop_heap_hole_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00$$QEAV10@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Push_heap_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD imagerel ??$_Push_heap_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	imagerel ??$_Push_heap_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z+629
	DD	imagerel $unwind$??$_Push_heap_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD imagerel ??$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	imagerel ??$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z+394
	DD	imagerel $unwind$??$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Pop_heap_hole_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00$$QEAV10@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD imagerel ??$_Pop_heap_hole_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00$$QEAV10@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	imagerel ??$_Pop_heap_hole_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00$$QEAV10@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z+82
	DD	imagerel $unwind$??$_Pop_heap_hole_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00$$QEAV10@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Push_heap_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD imagerel ??$_Push_heap_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	imagerel ??$_Push_heap_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z+629
	DD	imagerel $unwind$??$_Push_heap_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBV?$vector@EV?$allocator@E@std@@@std@@$$Z$$V@?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@V?$tuple@$$V@1@@Z DD imagerel $LN9
	DD	imagerel $LN9+33
	DD	imagerel $unwind$??$?0AEBV?$vector@EV?$allocator@E@std@@@std@@$$Z$$V@?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@V?$tuple@$$V@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBVNode@BymlFile@@$$Z$$V@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBVNode@BymlFile@@@1@V?$tuple@$$V@1@@Z DD imagerel $LN14
	DD	imagerel $LN14+91
	DD	imagerel $unwind$??$?0AEBVNode@BymlFile@@$$Z$$V@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBVNode@BymlFile@@@1@V?$tuple@$$V@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@QEAA@$$QEAU01@@Z DD imagerel $LN6
	DD	imagerel $LN6+41
	DD	imagerel $unwind$??0?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@QEAA@$$QEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@$$QEAU01@@Z DD imagerel $LN11
	DD	imagerel $LN11+87
	DD	imagerel $unwind$??0?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@$$QEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@U12@$0A@@std@@YAPEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@0@QEAU10@$$QEAU10@@Z DD imagerel $LN8
	DD	imagerel $LN8+41
	DD	imagerel $unwind$??$construct_at@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@U12@$0A@@std@@YAPEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@0@QEAU10@$$QEAU10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@0@$$QEAV?$tuple@$$V@0@@Z DD imagerel $LN13
	DD	imagerel $LN13+33
	DD	imagerel $unwind$??$construct_at@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@0@$$QEAV?$tuple@$$V@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@U?$pair@$$CBVNode@BymlFile@@I@std@@U12@$0A@@std@@YAPEAU?$pair@$$CBVNode@BymlFile@@I@0@QEAU10@$$QEAU10@@Z DD imagerel $LN13
	DD	imagerel $LN13+82
	DD	imagerel $unwind$??$construct_at@U?$pair@$$CBVNode@BymlFile@@I@std@@U12@$0A@@std@@YAPEAU?$pair@$$CBVNode@BymlFile@@I@0@QEAU10@$$QEAU10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@U?$pair@$$CBVNode@BymlFile@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBVNode@BymlFile@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBVNode@BymlFile@@I@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBVNode@BymlFile@@@0@$$QEAV?$tuple@$$V@0@@Z DD imagerel $LN18
	DD	imagerel $LN18+91
	DD	imagerel $unwind$??$construct_at@U?$pair@$$CBVNode@BymlFile@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBVNode@BymlFile@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBVNode@BymlFile@@I@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBVNode@BymlFile@@@0@$$QEAV?$tuple@$$V@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD imagerel ??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	imagerel ??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z+39
	DD	imagerel $unwind$??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD imagerel ??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z+39
	DD	imagerel ??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z+164
	DD	imagerel $chain$2$??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD imagerel ??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z+164
	DD	imagerel ??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z+178
	DD	imagerel $chain$3$??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Pop_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD imagerel ??$_Pop_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	imagerel ??$_Pop_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z+233
	DD	imagerel $unwind$??$_Pop_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Pop_heap_hole_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD imagerel ??$_Pop_heap_hole_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	imagerel ??$_Pop_heap_hole_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z+716
	DD	imagerel $unwind$??$_Pop_heap_hole_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD imagerel ??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	imagerel ??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z+39
	DD	imagerel $unwind$??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD imagerel ??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z+39
	DD	imagerel ??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z+164
	DD	imagerel $chain$2$??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD imagerel ??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z+164
	DD	imagerel ??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z+178
	DD	imagerel $chain$3$??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Pop_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD imagerel ??$_Pop_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	imagerel ??$_Pop_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z+233
	DD	imagerel $unwind$??$_Pop_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Pop_heap_hole_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD imagerel ??$_Pop_heap_hole_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	imagerel ??$_Pop_heap_hole_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z+716
	DD	imagerel $unwind$??$_Pop_heap_hole_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Move_backward_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PEAV10@00@Z DD imagerel $LN72
	DD	imagerel $LN72+196
	DD	imagerel $unwind$??$_Move_backward_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PEAV10@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@$$QEAU31@@Z DD imagerel $LN10
	DD	imagerel $LN10+44
	DD	imagerel $unwind$??$construct@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@$$QEAU31@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@$$QEAV?$tuple@$$V@1@@Z DD imagerel $LN15
	DD	imagerel $LN15+33
	DD	imagerel $unwind$??$construct@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@$$QEAV?$tuple@$$V@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@U?$pair@$$CBVNode@BymlFile@@I@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBVNode@BymlFile@@I@1@$$QEAU31@@Z DD imagerel $LN15
	DD	imagerel $LN15+90
	DD	imagerel $unwind$??$construct@U?$pair@$$CBVNode@BymlFile@@I@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBVNode@BymlFile@@I@1@$$QEAU31@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@U?$pair@$$CBVNode@BymlFile@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBVNode@BymlFile@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBVNode@BymlFile@@I@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBVNode@BymlFile@@@1@$$QEAV?$tuple@$$V@1@@Z DD imagerel $LN20
	DD	imagerel $LN20+91
	DD	imagerel $unwind$??$construct@U?$pair@$$CBVNode@BymlFile@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBVNode@BymlFile@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBVNode@BymlFile@@I@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBVNode@BymlFile@@@1@$$QEAV?$tuple@$$V@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z DD imagerel ??$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z
	DD	imagerel ??$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z+3696
	DD	imagerel $unwind$??$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Sort_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD imagerel ??$_Sort_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	imagerel ??$_Sort_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z+276
	DD	imagerel $unwind$??$_Sort_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Make_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD imagerel ??$_Make_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	imagerel ??$_Make_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z+245
	DD	imagerel $unwind$??$_Make_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Insertion_sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD imagerel ??$_Insertion_sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	imagerel ??$_Insertion_sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z+1554
	DD	imagerel $unwind$??$_Insertion_sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z DD imagerel ??$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z
	DD	imagerel ??$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z+3696
	DD	imagerel $unwind$??$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Sort_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD imagerel ??$_Sort_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	imagerel ??$_Sort_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z+276
	DD	imagerel $unwind$??$_Sort_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Make_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD imagerel ??$_Make_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	imagerel ??$_Make_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z+245
	DD	imagerel $unwind$??$_Make_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Insertion_sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD imagerel ??$_Insertion_sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	imagerel ??$_Insertion_sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z+1554
	DD	imagerel $unwind$??$_Insertion_sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$equal@PEBVNode@BymlFile@@PEBV12@U?$equal_to@X@std@@@std@@YA_NQEBVNode@BymlFile@@00U?$equal_to@X@0@@Z DD imagerel $LN142
	DD	imagerel $LN142+93
	DD	imagerel $unwind$??$equal@PEBVNode@BymlFile@@PEBV12@U?$equal_to@X@std@@@std@@YA_NQEBVNode@BymlFile@@00U?$equal_to@X@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN88
	DD	imagerel $LN88+33
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN88+33
	DD	imagerel $LN88+142
	DD	imagerel $chain$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN88+142
	DD	imagerel $LN88+262
	DD	imagerel $chain$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN88+262
	DD	imagerel $LN88+268
	DD	imagerel $chain$3$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN77
	DD	imagerel $LN77+33
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN77+33
	DD	imagerel $LN77+122
	DD	imagerel $chain$0$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN77+122
	DD	imagerel $LN77+205
	DD	imagerel $chain$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@@Z DD imagerel $LN47
	DD	imagerel $LN47+87
	DD	imagerel $unwind$??$?0U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@$$QEAV?$tuple@$$V@1@@Z DD imagerel $LN52
	DD	imagerel $LN52+100
	DD	imagerel $unwind$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@$$QEAV?$tuple@$$V@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0U?$pair@$$CBVNode@BymlFile@@I@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBVNode@BymlFile@@I@1@@Z DD imagerel $LN52
	DD	imagerel $LN52+128
	DD	imagerel $unwind$??$?0U?$pair@$$CBVNode@BymlFile@@I@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBVNode@BymlFile@@I@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBVNode@BymlFile@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBVNode@BymlFile@@@1@$$QEAV?$tuple@$$V@1@@Z DD imagerel $LN57
	DD	imagerel $LN57+149
	DD	imagerel $unwind$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBVNode@BymlFile@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBVNode@BymlFile@@@1@$$QEAV?$tuple@$$V@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0_JV<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD imagerel ??$_Sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0_JV<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	imagerel ??$_Sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0_JV<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z+629
	DD	imagerel $unwind$??$_Sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0_JV<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0_JV<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD imagerel ??$_Sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0_JV<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	imagerel ??$_Sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0_JV<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z+629
	DD	imagerel $unwind$??$_Sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0_JV<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$equal@PEBVNode@BymlFile@@PEBV12@@std@@YA_NQEBVNode@BymlFile@@00@Z DD imagerel $LN142
	DD	imagerel $LN142+93
	DD	imagerel $unwind$??$equal@PEBVNode@BymlFile@@PEBV12@@std@@YA_NQEBVNode@BymlFile@@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize@U_Value_init_tag@std@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN150
	DD	imagerel $LN150+50
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Resize@U_Value_init_tag@std@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN150+50
	DD	imagerel $LN150+75
	DD	imagerel $chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Resize@U_Value_init_tag@std@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN150+75
	DD	imagerel $LN150+120
	DD	imagerel $chain$2$??$_Resize@U_Value_init_tag@std@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Resize@U_Value_init_tag@std@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN150+120
	DD	imagerel $LN150+146
	DD	imagerel $chain$3$??$_Resize@U_Value_init_tag@std@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Resize@U_Value_init_tag@std@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN150+146
	DD	imagerel $LN150+214
	DD	imagerel $chain$4$??$_Resize@U_Value_init_tag@std@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN88
	DD	imagerel $LN88+44
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN88+44
	DD	imagerel $LN88+99
	DD	imagerel $chain$0$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN88+99
	DD	imagerel $LN88+187
	DD	imagerel $chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$emplace@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@@Z DD imagerel $LN230
	DD	imagerel $LN230+589
	DD	imagerel $unwind$??$emplace@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Try_emplace@AEBV?$vector@EV?$allocator@E@std@@@std@@$$V@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@_N@1@AEBV?$vector@EV?$allocator@E@std@@@1@@Z DD imagerel $LN227
	DD	imagerel $LN227+589
	DD	imagerel $unwind$??$_Try_emplace@AEBV?$vector@EV?$allocator@E@std@@@std@@$$V@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@_N@1@AEBV?$vector@EV?$allocator@E@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$emplace@U?$pair@$$CBVNode@BymlFile@@I@std@@@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVNode@BymlFile@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBVNode@BymlFile@@I@1@@Z DD imagerel $LN182
	DD	imagerel $LN182+630
	DD	imagerel $unwind$??$emplace@U?$pair@$$CBVNode@BymlFile@@I@std@@@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVNode@BymlFile@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBVNode@BymlFile@@I@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Try_emplace@AEBVNode@BymlFile@@$$V@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@_N@1@AEBVNode@BymlFile@@@Z DD imagerel $LN179
	DD	imagerel $LN179+630
	DD	imagerel $unwind$??$_Try_emplace@AEBVNode@BymlFile@@$$V@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@_N@1@AEBVNode@BymlFile@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD imagerel ??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	imagerel ??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z+34
	DD	imagerel $unwind$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD imagerel ??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	imagerel ??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z+34
	DD	imagerel $unwind$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEAVNode@BymlFile@@AEAI$0A@@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@AEAVNode@BymlFile@@AEAI@Z DD imagerel $LN11
	DD	imagerel $LN11+99
	DD	imagerel $unwind$??$?0AEAVNode@BymlFile@@AEAI$0A@@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@AEAVNode@BymlFile@@AEAI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$contains@X@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@QEBA_NAEBVNode@BymlFile@@@Z DD imagerel $LN26
	DD	imagerel $LN26+122
	DD	imagerel $unwind$??$contains@X@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@QEBA_NAEBVNode@BymlFile@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEAV?$vector@EV?$allocator@E@std@@@std@@I$0A@@?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@QEAA@AEAV?$vector@EV?$allocator@E@std@@@1@$$QEAI@Z DD imagerel $LN6
	DD	imagerel $LN6+40
	DD	imagerel $unwind$??$?0AEAV?$vector@EV?$allocator@E@std@@@std@@I$0A@@?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@QEAA@AEAV?$vector@EV?$allocator@E@std@@@1@$$QEAI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$contains@X@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@QEBA_NAEBV?$vector@EV?$allocator@E@std@@@1@@Z DD imagerel $LN21
	DD	imagerel $LN21+102
	DD	imagerel $unwind$??$contains@X@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@QEBA_NAEBV?$vector@EV?$allocator@E@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?8VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@YA_NAEBV?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@0@0@Z DD imagerel $LN133
	DD	imagerel $LN133+112
	DD	imagerel $unwind$??$?8VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@YA_NAEBV?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Reallocate_exactly@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAX_K@Z DD imagerel $LN92
	DD	imagerel $LN92+155
	DD	imagerel $unwind$?_Reallocate_exactly@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAX_K@Z DD imagerel $LN88
	DD	imagerel $LN88+50
	DD	imagerel $unwind$?resize@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?resize@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAX_K@Z DD imagerel $LN88+50
	DD	imagerel $LN88+75
	DD	imagerel $chain$1$?resize@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?resize@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAX_K@Z DD imagerel $LN88+75
	DD	imagerel $LN88+120
	DD	imagerel $chain$2$?resize@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?resize@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAX_K@Z DD imagerel $LN88+120
	DD	imagerel $LN88+146
	DD	imagerel $chain$3$?resize@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?resize@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAX_K@Z DD imagerel $LN88+146
	DD	imagerel $LN88+214
	DD	imagerel $chain$4$?resize@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAX_K@Z DD imagerel $LN90
	DD	imagerel $LN90+44
	DD	imagerel $unwind$?resize@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?resize@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAX_K@Z DD imagerel $LN90+44
	DD	imagerel $LN90+99
	DD	imagerel $chain$0$?resize@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?resize@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAX_K@Z DD imagerel $LN90+99
	DD	imagerel $LN90+187
	DD	imagerel $chain$1$?resize@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXXZ DD imagerel $LN27
	DD	imagerel $LN27+72
	DD	imagerel $unwind$?clear@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?insert@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@std@@@std@@@std@@_N@2@$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@2@@Z DD imagerel $LN4
	DD	imagerel $LN4+23
	DD	imagerel $unwind$?insert@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@std@@@std@@@std@@_N@2@$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$unordered_map@V?$vector@EV?$allocator@E@std@@@std@@IUVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@@std@@QEAAAEAIAEBV?$vector@EV?$allocator@E@std@@@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+29
	DD	imagerel $unwind$??A?$unordered_map@V?$vector@EV?$allocator@E@std@@@std@@IUVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@@std@@QEAAAEAIAEBV?$vector@EV?$allocator@E@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?insert@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVNode@BymlFile@@I@std@@@std@@@std@@@std@@_N@2@$$QEAU?$pair@$$CBVNode@BymlFile@@I@2@@Z DD imagerel $LN4
	DD	imagerel $LN4+23
	DD	imagerel $unwind$?insert@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVNode@BymlFile@@I@std@@@std@@@std@@@std@@_N@2@$$QEAU?$pair@$$CBVNode@BymlFile@@I@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$unordered_map@VNode@BymlFile@@IUNodeHasher@2@UNodeEqual@2@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@std@@@std@@QEAAAEAIAEBVNode@BymlFile@@@Z DD imagerel $LN4
	DD	imagerel $LN4+29
	DD	imagerel $unwind$??A?$unordered_map@VNode@BymlFile@@IUNodeHasher@2@UNodeEqual@2@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@std@@@std@@QEAAAEAIAEBVNode@BymlFile@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?WriteToFile@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4TableGeneration@1@@Z DD imagerel $LN97
	DD	imagerel $LN97+451
	DD	imagerel $unwind$?WriteToFile@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4TableGeneration@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@2@@Z@QEBA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@1@Z DD imagerel ??R<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@2@@Z@QEBA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@1@Z
	DD	imagerel ??R<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@2@@Z@QEBA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@1@Z+73
	DD	imagerel $unwind$??R<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@2@@Z@QEBA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@2@@Z@QEBA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@1@Z DD imagerel ??R<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@2@@Z@QEBA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@1@Z
	DD	imagerel ??R<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@2@@Z@QEBA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@1@Z+73
	DD	imagerel $unwind$??R<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@2@@Z@QEBA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?WriteNode@BymlFile@@AEAAXAEAVBinaryVectorWriter@@IIAEAVNode@1@@Z DD imagerel $LN578
	DD	imagerel $LN578+2827
	DD	imagerel $unwind$?WriteNode@BymlFile@@AEAAXAEAVBinaryVectorWriter@@IIAEAVNode@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetHashKeyTableIndex@BymlFile@@AEAAIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN51
	DD	imagerel $LN51+168
	DD	imagerel $unwind$?GetHashKeyTableIndex@BymlFile@@AEAAIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetStringTableIndex@BymlFile@@AEAAIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN51
	DD	imagerel $LN51+168
	DD	imagerel $unwind$?GetStringTableIndex@BymlFile@@AEAAIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GenerateStringTable@BymlFile@@QEAAXPEAVNode@1@@Z DD imagerel $LN132
	DD	imagerel $LN132+357
	DD	imagerel $unwind$?GenerateStringTable@BymlFile@@QEAAXPEAVNode@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GenerateHashKeyTable@BymlFile@@QEAAXPEAVNode@1@@Z DD imagerel $LN158
	DD	imagerel $LN158+499
	DD	imagerel $unwind$?GenerateHashKeyTable@BymlFile@@QEAAXPEAVNode@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?IsNumber@BymlFile@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN51
	DD	imagerel $LN51+177
	DD	imagerel $unwind$?IsNumber@BymlFile@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ParseNode@BymlFile@@AEAAXAEAVBinaryVectorReader@@HW4Type@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVNode@1@I@Z DD imagerel $LN375
	DD	imagerel $LN375+1835
	DD	imagerel $unwind$?ParseNode@BymlFile@@AEAAXAEAVBinaryVectorReader@@HW4Type@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVNode@1@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ParseTable@BymlFile@@AEAAXAEAVBinaryVectorReader@@PEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@H@Z DD imagerel $LN133
	DD	imagerel $LN133+621
	DD	imagerel $unwind$?ParseTable@BymlFile@@AEAAXAEAVBinaryVectorReader@@PEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ DD imagerel $LN9
	DD	imagerel $LN9+27
	DD	imagerel $unwind$?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??8Node@BymlFile@@QEBA_NAEBV01@@Z DD imagerel $LN90
	DD	imagerel $LN90+229
	DD	imagerel $unwind$??8Node@BymlFile@@QEBA_NAEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AddChild@Node@BymlFile@@QEAAXV12@@Z DD imagerel $LN6
	DD	imagerel $LN6+66
	DD	imagerel $unwind$?AddChild@Node@BymlFile@@QEAAXV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$SetValue@_K@Node@BymlFile@@QEAAX_K@Z DD imagerel $LN9
	DD	imagerel $LN9+56
	DD	imagerel $unwind$??$SetValue@_K@Node@BymlFile@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$SetValue@I@Node@BymlFile@@QEAAXI@Z DD imagerel $LN9
	DD	imagerel $LN9+54
	DD	imagerel $unwind$??$SetValue@I@Node@BymlFile@@QEAAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$SetValue@_J@Node@BymlFile@@QEAAX_J@Z DD imagerel $LN9
	DD	imagerel $LN9+56
	DD	imagerel $unwind$??$SetValue@_J@Node@BymlFile@@QEAAX_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$SetValue@H@Node@BymlFile@@QEAAXH@Z DD imagerel $LN9
	DD	imagerel $LN9+54
	DD	imagerel $unwind$??$SetValue@H@Node@BymlFile@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$SetValue@M@Node@BymlFile@@QEAAXM@Z DD imagerel $LN9
	DD	imagerel $LN9+52
	DD	imagerel $unwind$??$SetValue@M@Node@BymlFile@@QEAAXM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$SetValue@N@Node@BymlFile@@QEAAXN@Z DD imagerel $LN9
	DD	imagerel $LN9+54
	DD	imagerel $unwind$??$SetValue@N@Node@BymlFile@@QEAAXN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$SetValue@_N@Node@BymlFile@@QEAAX_N@Z DD imagerel $LN9
	DD	imagerel $LN9+56
	DD	imagerel $unwind$??$SetValue@_N@Node@BymlFile@@QEAAX_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?HasChild@BymlFile@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN47
	DD	imagerel $LN47+142
	DD	imagerel $unwind$?HasChild@BymlFile@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetNode@BymlFile@@QEAAPEAVNode@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN47
	DD	imagerel $LN47+143
	DD	imagerel $unwind$?GetNode@BymlFile@@QEAAPEAVNode@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetChild@Node@BymlFile@@QEAAPEAV12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN47
	DD	imagerel $LN47+143
	DD	imagerel $unwind$?GetChild@Node@BymlFile@@QEAAPEAV12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?HasChild@Node@BymlFile@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN47
	DD	imagerel $LN47+142
	DD	imagerel $unwind$?HasChild@Node@BymlFile@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$SetValue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Node@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN21
	DD	imagerel $LN21+116
	DD	imagerel $unwind$??$SetValue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Node@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0Node@BymlFile@@QEAA@W4Type@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN24
	DD	imagerel $LN24+126
	DD	imagerel $unwind$??0Node@BymlFile@@QEAA@W4Type@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@1@@Z DD imagerel $LN1167
	DD	imagerel $LN1167+4523
	DD	imagerel $unwind$?ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AddStringTableEntry@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN20
	DD	imagerel $LN20+109
	DD	imagerel $unwind$?AddStringTableEntry@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0BymlFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z DD imagerel $LN488
	DD	imagerel $LN488+1668
	DD	imagerel $unwind$??0BymlFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0BymlFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z DB '$'
	DB	0e0H
	DB	08H
	DB	01aH
	DB	0aH
	DB	0bcH
	DB	0cH
	DB	'L'
	DB	0eH
	DB	' '
	DB	0cH
	DB	0e8H
	DB	010H
	DB	088H
	DB	012H
	DB	'T'
	DB	010H
	DB	01cH
	DB	0cH
	DB	08dH, 04H
	DB	014H
	DB	084H
	DB	016H
	DB	'L'
	DB	014H
	DB	01aH
	DB	0cH
	DB	'M', 02H
	DB	018H
	DB	'@'
	DB	01aH
	DB	'P'
	DB	01cH
	DB	'1', 05H
	DB	0cH
	DB	'u', 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0BymlFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z DB 01cH
	DB	0cH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	061H
	DB	04H
	DB	03cH
	DD	imagerel ??1?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@XZ
	DB	041H
	DB	03H
	DB	03eH
	DD	imagerel ?dtor$2@?0???0BymlFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$3@?0???0BymlFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$4@?0???0BymlFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$5@?0???0BymlFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA
	DB	02cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0d0H
	DB	05aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	061H
	DB	03H
	DB	03cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	080H
	DB	0c2H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0e1H
	DB	03H
	DB	03cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	080H
	DB	059H
	DB	02H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	080H
	DB	03aH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	0c1H
	DB	04H
	DB	035H
	DB	03H
	DD	imagerel ??1Node@BymlFile@@QEAA@XZ
	DB	0c1H
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0BymlFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0BymlFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z
	DD	imagerel $ip2state$??0BymlFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0BymlFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z DD 0b3019H
	DD	03e341fH
	DD	034011fH
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??0BymlFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z
	DD	0192H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?AddStringTableEntry@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	'j'
	DB	02H
	DB	'0'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?AddStringTableEntry@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?AddStringTableEntry@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?AddStringTableEntry@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$?AddStringTableEntry@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AddStringTableEntry@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 041919H
	DD	0a340aH
	DD	07006520aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?AddStringTableEntry@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	02aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@1@@Z DB '.'
	DB	'u', 03H
	DB	02H
	DB	'u', 0eH
	DB	04H
	DB	0a9H, 0aH
	DB	06H
	DB	'-', 03H
	DB	08H
	DB	'5', 04H
	DB	06H
	DB	'i', 05H
	DB	0aH
	DB	'H'
	DB	0cH
	DB	0acH
	DB	0eH
	DB	'*'
	DB	010H
	DB	01cH
	DB	012H
	DB	'"'
	DB	014H
	DB	'h'
	DB	0eH
	DB	08dH, 0aH
	DB	016H
	DB	084H
	DB	018H
	DB	019H, 02H
	DB	01aH
	DB	'L'
	DB	018H
	DB	01cH
	DB	016H
	DB	'M', 03H
	DB	0eH
	DB	0b8H
	DB	06H
	DB	0cdH, 05H
	DB	00H
	DB	'@'
	DB	0eH
	DB	0cH
	DB	06H
	DB	0cH
	DB	0eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@1@@Z DB 01aH
	DB	0aH
	DD	imagerel ??1BinaryVectorWriter@@QEAA@XZ
	DB	0e1H
	DB	04H
	DB	03aH
	DD	imagerel ??1?$vector@IV?$allocator@I@std@@@std@@QEAA@XZ
	DB	041H
	DB	06H
	DB	03aH
	DD	imagerel ??1?$vector@IV?$allocator@I@std@@@std@@QEAA@XZ
	DB	0e1H
	DB	05H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	061H
	DB	05H
	DB	074H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	080H
	DB	032H
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	0c1H
	DB	06H
	DB	0daH
	DD	imagerel ??1Node@BymlFile@@QEAA@XZ
	DB	0c1H
	DB	06H
	DB	03cH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	080H
	DB	036H
	DD	imagerel ?dtor$30@?0??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@1@@Z@4HA
	DB	094H
	DD	imagerel ??1Node@BymlFile@@QEAA@XZ
	DB	090H
	DB	0c2H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	01H
	DB	03H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	061H
	DB	05H
	DB	03cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$?ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@1@@Z
	DD	imagerel $ip2state$?ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@1@@Z DD 0b3019H
	DD	04e341fH
	DD	044011fH
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@1@@Z
	DD	0212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0Node@BymlFile@@QEAA@W4Type@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	08aH
	DB	04H
	DB	'H'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0Node@BymlFile@@QEAA@W4Type@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	050H
	DB	034H
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0Node@BymlFile@@QEAA@W4Type@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0Node@BymlFile@@QEAA@W4Type@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??0Node@BymlFile@@QEAA@W4Type@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0Node@BymlFile@@QEAA@W4Type@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 061e19H
	DD	0d640fH
	DD	0b340fH
	DD	0700b720fH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??0Node@BymlFile@@QEAA@W4Type@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	032H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$SetValue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Node@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	'j'
	DB	02H
	DB	'^'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$SetValue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Node@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$SetValue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Node@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$SetValue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Node@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??$SetValue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Node@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$SetValue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Node@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 041919H
	DD	0a340aH
	DD	07006520aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$SetValue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Node@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	02aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?HasChild@Node@BymlFile@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 081201H
	DD	0a5412H
	DD	083412H
	DD	0e00e3212H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetChild@Node@BymlFile@@QEAAPEAV12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 081201H
	DD	0a5412H
	DD	083412H
	DD	0e00e3212H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetNode@BymlFile@@QEAAPEAVNode@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 081201H
	DD	0a5412H
	DD	083412H
	DD	0e00e3212H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?HasChild@BymlFile@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 081201H
	DD	0a5412H
	DD	083412H
	DD	0e00e3212H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$SetValue@_N@Node@BymlFile@@QEAAX_N@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$SetValue@N@Node@BymlFile@@QEAAXN@Z DD 020b01H
	DD	03007320bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$SetValue@M@Node@BymlFile@@QEAAXM@Z DD 020b01H
	DD	03007320bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$SetValue@H@Node@BymlFile@@QEAAXH@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$SetValue@_J@Node@BymlFile@@QEAAX_J@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$SetValue@I@Node@BymlFile@@QEAAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$SetValue@_K@Node@BymlFile@@QEAAX_K@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?AddChild@Node@BymlFile@@QEAAXV12@@Z DB 04H
	DB	'B'
	DB	02H
	DB	','
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?AddChild@Node@BymlFile@@QEAAXV12@@Z DB 02H
	DB	0cH
	DD	imagerel ??1Node@BymlFile@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?AddChild@Node@BymlFile@@QEAAXV12@@Z DB 028H
	DD	imagerel $stateUnwindMap$?AddChild@Node@BymlFile@@QEAAXV12@@Z
	DD	imagerel $ip2state$?AddChild@Node@BymlFile@@QEAAXV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AddChild@Node@BymlFile@@QEAAXV12@@Z DD 021519H
	DD	030025206H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?AddChild@Node@BymlFile@@QEAAXV12@@Z
	DD	02aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??8Node@BymlFile@@QEBA_NAEBV01@@Z DD 073c01H
	DD	04743cH
	DD	0a6437H
	DD	0e0044208H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?ParseTable@BymlFile@@AEAAXAEAVBinaryVectorReader@@PEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@H@Z DB 06H
	DB	0e2H
	DB	00H
	DB	'P'
	DB	02H
	DB	' '
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?ParseTable@BymlFile@@AEAAXAEAVBinaryVectorReader@@PEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@H@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	050H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?ParseTable@BymlFile@@AEAAXAEAVBinaryVectorReader@@PEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@H@Z DB 028H
	DD	imagerel $stateUnwindMap$?ParseTable@BymlFile@@AEAAXAEAVBinaryVectorReader@@PEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@H@Z
	DD	imagerel $ip2state$?ParseTable@BymlFile@@AEAAXAEAVBinaryVectorReader@@PEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ParseTable@BymlFile@@AEAAXAEAVBinaryVectorReader@@PEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@H@Z DD 0a1411H
	DD	0163414H
	DD	0f010d214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?ParseTable@BymlFile@@AEAAXAEAVBinaryVectorReader@@PEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?ParseNode@BymlFile@@AEAAXAEAVBinaryVectorReader@@HW4Type@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVNode@1@I@Z DB 01aH
	DB	'5', 02H
	DB	02H
	DB	'L'
	DB	04H
	DB	' '
	DB	02H
	DB	'n'
	DB	06H
	DB	'.'
	DB	08H
	DB	05H, 02H
	DB	0aH
	DB	'=', 0bH
	DB	02H
	DB	09H, 02H
	DB	0aH
	DB	'}', 03H
	DB	0cH
	DB	088H
	DB	0eH
	DB	'T'
	DB	0cH
	DB	01cH
	DB	0aH
	DB	0ceH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?ParseNode@BymlFile@@AEAAXAEAVBinaryVectorReader@@HW4Type@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVNode@1@I@Z DB 0eH
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	061H
	DB	03H
	DB	03cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
	DB	06cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	081H
	DB	03H
	DB	03aH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	0c1H
	DB	03H
	DB	0daH
	DD	imagerel ??1Node@BymlFile@@QEAA@XZ
	DB	0c1H
	DB	03H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	041H
	DB	02H
	DB	03cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	081H
	DB	03H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?ParseNode@BymlFile@@AEAAXAEAVBinaryVectorReader@@HW4Type@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVNode@1@I@Z DB 028H
	DD	imagerel $stateUnwindMap$?ParseNode@BymlFile@@AEAAXAEAVBinaryVectorReader@@HW4Type@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVNode@1@I@Z
	DD	imagerel $ip2state$?ParseNode@BymlFile@@AEAAXAEAVBinaryVectorReader@@HW4Type@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVNode@1@I@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ParseNode@BymlFile@@AEAAXAEAVBinaryVectorReader@@HW4Type@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVNode@1@I@Z DD 0b2a19H
	DD	036341cH
	DD	02c011cH
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?ParseNode@BymlFile@@AEAAXAEAVBinaryVectorReader@@HW4Type@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVNode@1@I@Z
	DD	0152H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?IsNumber@BymlFile@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0f0143218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?GenerateHashKeyTable@BymlFile@@QEAAXPEAVNode@1@@Z DB 06H
	DB	'r'
	DB	00H
	DB	0d5H, 03H
	DB	02H
	DB	0ccH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?GenerateHashKeyTable@BymlFile@@QEAAXPEAVNode@1@@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?GenerateHashKeyTable@BymlFile@@QEAAXPEAVNode@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$?GenerateHashKeyTable@BymlFile@@QEAAXPEAVNode@1@@Z
	DD	imagerel $ip2state$?GenerateHashKeyTable@BymlFile@@QEAAXPEAVNode@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GenerateHashKeyTable@BymlFile@@QEAAXPEAVNode@1@@Z DD 0a2319H
	DD	0163414H
	DD	0f010b214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?GenerateHashKeyTable@BymlFile@@QEAAXPEAVNode@1@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?GenerateStringTable@BymlFile@@QEAAXPEAVNode@1@@Z DB 06H
	DB	'n'
	DB	00H
	DB	'D'
	DB	02H
	DB	015H, 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?GenerateStringTable@BymlFile@@QEAAXPEAVNode@1@@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?GenerateStringTable@BymlFile@@QEAAXPEAVNode@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$?GenerateStringTable@BymlFile@@QEAAXPEAVNode@1@@Z
	DD	imagerel $ip2state$?GenerateStringTable@BymlFile@@QEAAXPEAVNode@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GenerateStringTable@BymlFile@@QEAAXPEAVNode@1@@Z DD 081f19H
	DD	0123410H
	DD	0f00c9210H
	DD	07008e00aH
	DD	050066007H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?GenerateStringTable@BymlFile@@QEAAXPEAVNode@1@@Z
	DD	042H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetStringTableIndex@BymlFile@@AEAAIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0a1801H
	DD	0b6418H
	DD	0a5418H
	DD	083418H
	DD	0f0143218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetHashKeyTableIndex@BymlFile@@AEAAIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0a1801H
	DD	0b6418H
	DD	0a5418H
	DD	083418H
	DD	0f0143218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?WriteNode@BymlFile@@AEAAXAEAVBinaryVectorWriter@@IIAEAVNode@1@@Z DB '*'
	DB	0ceH
	DB	00H
	DB	']', 07H
	DB	02H
	DB	'('
	DB	00H
	DB	019H, 03H
	DB	02H
	DB	'('
	DB	00H
	DB	'=', 03H
	DB	02H
	DB	'('
	DB	00H
	DB	'a', 08H
	DB	04H
	DB	'0'
	DB	06H
	DB	01aH
	DB	00H
	DB	','
	DB	08H
	DB	'F'
	DB	00H
	DB	'A', 0bH
	DB	04H
	DB	'0'
	DB	0aH
	DB	01aH
	DB	00H
	DB	'('
	DB	08H
	DB	'\'
	DB	00H
	DB	','
	DB	0cH
	DB	0acH
	DB	0eH
	DB	01cH
	DB	0cH
	DB	0b0H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?WriteNode@BymlFile@@AEAAXAEAVBinaryVectorWriter@@IIAEAVNode@1@@Z DB 0eH
	DB	0aH
	DD	imagerel ??1?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@QEAA@XZ
	DB	0a0H
	DB	03cH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	060H
	DB	036H
	DD	imagerel ?dtor$12@?0??WriteNode@BymlFile@@AEAAXAEAVBinaryVectorWriter@@IIAEAVNode@1@@Z@4HA
	DB	092H
	DD	imagerel ??1?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@XZ
	DB	041H
	DB	03H
	DB	096H
	DD	imagerel ?dtor$27@?0??WriteNode@BymlFile@@AEAAXAEAVBinaryVectorWriter@@IIAEAVNode@1@@Z@4HA
	DB	0f2H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	021H
	DB	02H
	DB	03cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?WriteNode@BymlFile@@AEAAXAEAVBinaryVectorWriter@@IIAEAVNode@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$?WriteNode@BymlFile@@AEAAXAEAVBinaryVectorWriter@@IIAEAVNode@1@@Z
	DD	imagerel $ip2state$?WriteNode@BymlFile@@AEAAXAEAVBinaryVectorWriter@@IIAEAVNode@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?WriteNode@BymlFile@@AEAAXAEAVBinaryVectorWriter@@IIAEAVNode@1@@Z DD 0a2719H
	DD	0290119H
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	050023003H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?WriteNode@BymlFile@@AEAAXAEAVBinaryVectorWriter@@IIAEAVNode@1@@Z
	DD	013aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@2@@Z@QEBA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@1@Z DD 060f01H
	DD	09640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@2@@Z@QEBA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@1@Z DD 060f01H
	DD	09640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?WriteToFile@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4TableGeneration@1@@Z DB 0aH
	DB	0baH
	DB	02H
	DB	092H
	DB	04H
	DB	'D'
	DB	06H
	DB	'v'
	DB	04H
	DB	08dH, 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?WriteToFile@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4TableGeneration@1@@Z DB 06H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	060H
	DB	032H
	DD	imagerel ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	DB	0a0H
	DB	032H
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	070H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?WriteToFile@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4TableGeneration@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$?WriteToFile@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4TableGeneration@1@@Z
	DD	imagerel $ip2state$?WriteToFile@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4TableGeneration@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?WriteToFile@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4TableGeneration@1@@Z DD 092819H
	DD	035641aH
	DD	034341aH
	DD	02e011aH
	DD	0700ce00eH
	DD	0500bH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?WriteToFile@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4TableGeneration@1@@Z
	DD	0162H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$unordered_map@VNode@BymlFile@@IUNodeHasher@2@UNodeEqual@2@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@std@@@std@@QEAAAEAIAEBVNode@BymlFile@@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?insert@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVNode@BymlFile@@I@std@@@std@@@std@@@std@@_N@2@$$QEAU?$pair@$$CBVNode@BymlFile@@I@2@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$unordered_map@V?$vector@EV?$allocator@E@std@@@std@@IUVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@@std@@QEAAAEAIAEBV?$vector@EV?$allocator@E@std@@@1@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?insert@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@std@@@std@@@std@@_N@2@$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@2@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXXZ DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?resize@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAX_K@Z DD 021H
	DD	imagerel $LN90
	DD	imagerel $LN90+44
	DD	imagerel $unwind$?resize@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?resize@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAX_K@Z DD 020521H
	DD	0a7405H
	DD	imagerel $LN90
	DD	imagerel $LN90+44
	DD	imagerel $unwind$?resize@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAX_K@Z DD 040901H
	DD	0e0053209H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?resize@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAX_K@Z DD 021H
	DD	imagerel $LN88
	DD	imagerel $LN88+50
	DD	imagerel $unwind$?resize@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?resize@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAX_K@Z DD 021H
	DD	imagerel $LN88+50
	DD	imagerel $LN88+75
	DD	imagerel $chain$1$?resize@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?resize@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAX_K@Z DD 020521H
	DD	087405H
	DD	imagerel $LN88+50
	DD	imagerel $LN88+75
	DD	imagerel $chain$1$?resize@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?resize@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAX_K@Z DD 040a21H
	DD	07540aH
	DD	063405H
	DD	imagerel $LN88
	DD	imagerel $LN88+50
	DD	imagerel $unwind$?resize@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAX_K@Z DD 040b01H
	DD	09640bH
	DD	0e007320bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Reallocate_exactly@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAX_K@Z DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?8VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@YA_NAEBV?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@0@0@Z DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$contains@X@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@QEBA_NAEBV?$vector@EV?$allocator@E@std@@@1@@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEAV?$vector@EV?$allocator@E@std@@@std@@I$0A@@?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@QEAA@AEAV?$vector@EV?$allocator@E@std@@@1@$$QEAI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$contains@X@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@QEBA_NAEBVNode@BymlFile@@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0AEAVNode@BymlFile@@AEAI$0A@@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@AEAVNode@BymlFile@@AEAI@Z DB 06H
	DB	'D'
	DB	00H
	DB	'*'
	DB	02H
	DB	01cH
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0AEAVNode@BymlFile@@AEAI$0A@@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@AEAVNode@BymlFile@@AEAI@Z DB 04H
	DB	0cH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	060H
	DB	036H
	DD	imagerel ?dtor$2@?0???$?0AEAVNode@BymlFile@@AEAI$0A@@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@AEAVNode@BymlFile@@AEAI@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0AEAVNode@BymlFile@@AEAI$0A@@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@AEAVNode@BymlFile@@AEAI@Z DB 028H
	DD	imagerel $stateUnwindMap$??$?0AEAVNode@BymlFile@@AEAI$0A@@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@AEAVNode@BymlFile@@AEAI@Z
	DD	imagerel $ip2state$??$?0AEAVNode@BymlFile@@AEAI$0A@@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@AEAVNode@BymlFile@@AEAI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEAVNode@BymlFile@@AEAI$0A@@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@AEAVNode@BymlFile@@AEAI@Z DD 061411H
	DD	086414H
	DD	073414H
	DD	070103214H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0AEAVNode@BymlFile@@AEAI$0A@@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@AEAVNode@BymlFile@@AEAI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Try_emplace@AEBVNode@BymlFile@@$$V@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@_N@1@AEBVNode@BymlFile@@@Z DB 0eH
	DB	'@'
	DB	00H
	DB	0b9H, 02H
	DB	02H
	DB	'`'
	DB	04H
	DB	','
	DB	06H
	DB	01cH
	DB	02H
	DB	0f2H
	DB	08H
	DB	'Y', 03H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Try_emplace@AEBVNode@BymlFile@@$$V@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@_N@1@AEBVNode@BymlFile@@@Z DB 08H
	DB	0aH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	070H
	DB	034H
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	040H
	DB	036H
	DD	imagerel ?dtor$5@?0???$_Try_emplace@AEBVNode@BymlFile@@$$V@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@_N@1@AEBVNode@BymlFile@@@Z@4HA
	DB	092H
	DD	imagerel ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	070H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Try_emplace@AEBVNode@BymlFile@@$$V@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@_N@1@AEBVNode@BymlFile@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Try_emplace@AEBVNode@BymlFile@@$$V@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@_N@1@AEBVNode@BymlFile@@@Z
	DD	imagerel $ip2state$??$_Try_emplace@AEBVNode@BymlFile@@$$V@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@_N@1@AEBVNode@BymlFile@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Try_emplace@AEBVNode@BymlFile@@$$V@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@_N@1@AEBVNode@BymlFile@@@Z DD 0a1411H
	DD	0153414H
	DD	0f0109214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Try_emplace@AEBVNode@BymlFile@@$$V@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@_N@1@AEBVNode@BymlFile@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$emplace@U?$pair@$$CBVNode@BymlFile@@I@std@@@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVNode@BymlFile@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBVNode@BymlFile@@I@1@@Z DB 0eH
	DB	'@'
	DB	00H
	DB	0b9H, 02H
	DB	02H
	DB	'`'
	DB	04H
	DB	','
	DB	06H
	DB	01cH
	DB	02H
	DB	0f8H
	DB	08H
	DB	'M', 03H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$emplace@U?$pair@$$CBVNode@BymlFile@@I@std@@@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVNode@BymlFile@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBVNode@BymlFile@@I@1@@Z DB 08H
	DB	0aH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	070H
	DB	034H
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	040H
	DB	036H
	DD	imagerel ?dtor$4@?0???$emplace@U?$pair@$$CBVNode@BymlFile@@I@std@@@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVNode@BymlFile@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBVNode@BymlFile@@I@1@@Z@4HA
	DB	092H
	DD	imagerel ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	070H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$emplace@U?$pair@$$CBVNode@BymlFile@@I@std@@@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVNode@BymlFile@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBVNode@BymlFile@@I@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$emplace@U?$pair@$$CBVNode@BymlFile@@I@std@@@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVNode@BymlFile@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBVNode@BymlFile@@I@1@@Z
	DD	imagerel $ip2state$??$emplace@U?$pair@$$CBVNode@BymlFile@@I@std@@@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVNode@BymlFile@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBVNode@BymlFile@@I@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$emplace@U?$pair@$$CBVNode@BymlFile@@I@std@@@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVNode@BymlFile@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBVNode@BymlFile@@I@1@@Z DD 0a1411H
	DD	0153414H
	DD	0f0109214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$emplace@U?$pair@$$CBVNode@BymlFile@@I@std@@@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVNode@BymlFile@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBVNode@BymlFile@@I@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Try_emplace@AEBV?$vector@EV?$allocator@E@std@@@std@@$$V@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@_N@1@AEBV?$vector@EV?$allocator@E@std@@@1@@Z DB 08H
	DB	'Y', 02H
	DB	00H
	DB	'8'
	DB	02H
	DB	':'
	DB	04H
	DB	08dH, 05H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Try_emplace@AEBV?$vector@EV?$allocator@E@std@@@std@@$$V@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@_N@1@AEBV?$vector@EV?$allocator@E@std@@@1@@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	060H
	DB	03aH
	DD	imagerel ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Try_emplace@AEBV?$vector@EV?$allocator@E@std@@@std@@$$V@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@_N@1@AEBV?$vector@EV?$allocator@E@std@@@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Try_emplace@AEBV?$vector@EV?$allocator@E@std@@@std@@$$V@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@_N@1@AEBV?$vector@EV?$allocator@E@std@@@1@@Z
	DD	imagerel $ip2state$??$_Try_emplace@AEBV?$vector@EV?$allocator@E@std@@@std@@$$V@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@_N@1@AEBV?$vector@EV?$allocator@E@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Try_emplace@AEBV?$vector@EV?$allocator@E@std@@@std@@$$V@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@_N@1@AEBV?$vector@EV?$allocator@E@std@@@1@@Z DD 0a1411H
	DD	0133414H
	DD	0f0107214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Try_emplace@AEBV?$vector@EV?$allocator@E@std@@@std@@$$V@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@_N@1@AEBV?$vector@EV?$allocator@E@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$emplace@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@@Z DB 08H
	DB	'M', 02H
	DB	00H
	DB	'<'
	DB	02H
	DB	'>'
	DB	04H
	DB	089H, 05H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$emplace@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	060H
	DB	03aH
	DD	imagerel ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$emplace@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$emplace@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@@Z
	DD	imagerel $ip2state$??$emplace@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$emplace@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@@Z DD 0a1411H
	DD	0133414H
	DD	0f0107214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$emplace@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN88
	DD	imagerel $LN88+44
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 020521H
	DD	0a7405H
	DD	imagerel $LN88
	DD	imagerel $LN88+44
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040901H
	DD	0e0053209H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Resize@U_Value_init_tag@std@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN150
	DD	imagerel $LN150+50
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Resize@U_Value_init_tag@std@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN150+50
	DD	imagerel $LN150+75
	DD	imagerel $chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Resize@U_Value_init_tag@std@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 020521H
	DD	087405H
	DD	imagerel $LN150+50
	DD	imagerel $LN150+75
	DD	imagerel $chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040a21H
	DD	07540aH
	DD	063405H
	DD	imagerel $LN150
	DD	imagerel $LN150+50
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040b01H
	DD	09640bH
	DD	0e007320bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$equal@PEBVNode@BymlFile@@PEBV12@@std@@YA_NQEBVNode@BymlFile@@00@Z DD 060f01H
	DD	09640fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0_JV<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 08H
	DB	0b2H
	DB	00H
	DB	'}', 03H
	DB	02H
	DB	'N'
	DB	00H
	DB	0d5H, 02H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0_JV<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0_JV<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0_JV<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	imagerel $ip2state$??$_Sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0_JV<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0_JV<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD 081e19H
	DD	0f00bb20fH
	DD	0c007e009H
	DD	060047005H
	DD	030025003H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0_JV<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0_JV<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 08H
	DB	0b2H
	DB	00H
	DB	'}', 03H
	DB	02H
	DB	'N'
	DB	00H
	DB	0d5H, 02H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0_JV<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0_JV<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0_JV<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	imagerel $ip2state$??$_Sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0_JV<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0_JV<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD 081e19H
	DD	0f00bb20fH
	DD	0c007e009H
	DD	060047005H
	DD	030025003H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0_JV<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBVNode@BymlFile@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBVNode@BymlFile@@@1@$$QEAV?$tuple@$$V@1@@Z DB 08H
	DB	'n'
	DB	02H
	DB	'B'
	DB	04H
	DB	'*'
	DB	06H
	DB	01cH
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBVNode@BymlFile@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBVNode@BymlFile@@@1@$$QEAV?$tuple@$$V@1@@Z DB 06H
	DB	0cH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	060H
	DB	034H
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	080H
	DB	036H
	DD	imagerel ?dtor$4@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBVNode@BymlFile@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBVNode@BymlFile@@@1@$$QEAV?$tuple@$$V@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBVNode@BymlFile@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBVNode@BymlFile@@@1@$$QEAV?$tuple@$$V@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBVNode@BymlFile@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBVNode@BymlFile@@@1@$$QEAV?$tuple@$$V@1@@Z
	DD	imagerel $ip2state$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBVNode@BymlFile@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBVNode@BymlFile@@@1@$$QEAV?$tuple@$$V@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBVNode@BymlFile@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBVNode@BymlFile@@@1@$$QEAV?$tuple@$$V@1@@Z DD 061911H
	DD	096419H
	DD	073419H
	DD	070153219H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBVNode@BymlFile@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBVNode@BymlFile@@@1@$$QEAV?$tuple@$$V@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0U?$pair@$$CBVNode@BymlFile@@I@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBVNode@BymlFile@@I@1@@Z DB 08H
	DB	'L'
	DB	02H
	DB	'<'
	DB	04H
	DB	'*'
	DB	06H
	DB	01cH
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0U?$pair@$$CBVNode@BymlFile@@I@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBVNode@BymlFile@@I@1@@Z DB 06H
	DB	0cH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	060H
	DB	034H
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	070H
	DB	036H
	DD	imagerel ?dtor$3@?0???$?0U?$pair@$$CBVNode@BymlFile@@I@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBVNode@BymlFile@@I@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0U?$pair@$$CBVNode@BymlFile@@I@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBVNode@BymlFile@@I@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$?0U?$pair@$$CBVNode@BymlFile@@I@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBVNode@BymlFile@@I@1@@Z
	DD	imagerel $ip2state$??$?0U?$pair@$$CBVNode@BymlFile@@I@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBVNode@BymlFile@@I@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0U?$pair@$$CBVNode@BymlFile@@I@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBVNode@BymlFile@@I@1@@Z DD 061411H
	DD	096414H
	DD	083414H
	DD	070103214H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0U?$pair@$$CBVNode@BymlFile@@I@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBVNode@BymlFile@@I@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@$$QEAV?$tuple@$$V@1@@Z DB 04H
	DB	'd'
	DB	02H
	DB	'>'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@$$QEAV?$tuple@$$V@1@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@$$QEAV?$tuple@$$V@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@$$QEAV?$tuple@$$V@1@@Z
	DD	imagerel $ip2state$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@$$QEAV?$tuple@$$V@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@$$QEAV?$tuple@$$V@1@@Z DD 061411H
	DD	086414H
	DD	073414H
	DD	070103214H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@$$QEAV?$tuple@$$V@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@@Z DB 04H
	DB	'L'
	DB	02H
	DB	'<'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$?0U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@@Z
	DD	imagerel $ip2state$??$?0U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@@Z DD 061411H
	DD	086414H
	DD	073414H
	DD	070103214H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN77
	DD	imagerel $LN77+33
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 020521H
	DD	0a5405H
	DD	imagerel $LN77
	DD	imagerel $LN77+33
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040801H
	DD	070043208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN88
	DD	imagerel $LN88+33
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 020021H
	DD	0be400H
	DD	imagerel $LN88
	DD	imagerel $LN88+33
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 043821H
	DD	0be438H
	DD	0a5405H
	DD	imagerel $LN88
	DD	imagerel $LN88+33
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040801H
	DD	070043208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$equal@PEBVNode@BymlFile@@PEBV12@U?$equal_to@X@std@@@std@@YA_NQEBVNode@BymlFile@@00U?$equal_to@X@0@@Z DD 060f01H
	DD	09640fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Insertion_sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 0eH
	DB	']', 04H
	DB	02H
	DB	0e5H, 02H
	DB	04H
	DB	095H, 07H
	DB	02H
	DB	'5', 02H
	DB	04H
	DB	'a', 06H
	DB	00H
	DB	'L'
	DB	02H
	DB	018H
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Insertion_sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	01H
	DB	03H
	DB	03cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	041H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Insertion_sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Insertion_sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	imagerel $ip2state$??$_Insertion_sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Insertion_sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD 0d3219H
	DD	0277424H
	DD	0266424H
	DD	0253424H
	DD	01e0124H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Insertion_sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	0e2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Make_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 04H
	DB	'%', 02H
	DB	02H
	DB	098H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Make_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Make_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Make_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	imagerel $ip2state$??$_Make_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Make_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD 081f19H
	DD	0143410H
	DD	0f00cb210H
	DD	07008e00aH
	DD	050066007H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Make_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Sort_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 04H
	DB	']', 02H
	DB	02H
	DB	0baH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Sort_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Sort_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Sort_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	imagerel $ip2state$??$_Sort_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Sort_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD 081f19H
	DD	0143410H
	DD	0f00cb210H
	DD	07008e00aH
	DD	050066007H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Sort_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z DB '@'
	DB	0e0H
	DB	00H
	DB	'E', 04H
	DB	02H
	DB	0f8H
	DB	00H
	DB	'9', 03H
	DB	04H
	DB	01dH, 02H
	DB	00H
	DB	'Y', 04H
	DB	04H
	DB	011H, 02H
	DB	00H
	DB	'5', 03H
	DB	04H
	DB	0dH, 02H
	DB	00H
	DB	01dH, 04H
	DB	04H
	DB	'9', 02H
	DB	00H
	DB	'u', 03H
	DB	06H
	DB	'9', 02H
	DB	00H
	DB	0a1H, 04H
	DB	06H
	DB	'=', 02H
	DB	00H
	DB	'y', 03H
	DB	06H
	DB	'=', 02H
	DB	00H
	DB	0d9H, 06H
	DB	04H
	DB	0cH
	DB	00H
	DB	0cH
	DB	02H
	DB	0cH
	DB	00H
	DB	0cH
	DB	04H
	DB	0cH
	DB	00H
	DB	0cH
	DB	04H
	DB	0cH
	DB	00H
	DB	0cH
	DB	06H
	DB	0cH
	DB	00H
	DB	0cH
	DB	04H
	DB	0cH
	DB	00H
	DB	0cH
	DB	06H
	DB	0cH
	DB	00H
	DB	0cH
	DB	06H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z DB 06H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0c0H
	DB	03cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0d0H
	DB	06cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	01H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z
	DD	imagerel $ip2state$??$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z DD 0b1c11H
	DD	01d341cH
	DD	012011cH
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Insertion_sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 0eH
	DB	']', 04H
	DB	02H
	DB	0e5H, 02H
	DB	04H
	DB	095H, 07H
	DB	02H
	DB	'5', 02H
	DB	04H
	DB	'a', 06H
	DB	00H
	DB	'L'
	DB	02H
	DB	018H
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Insertion_sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	01H
	DB	03H
	DB	03cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	041H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Insertion_sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Insertion_sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	imagerel $ip2state$??$_Insertion_sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Insertion_sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD 0d3219H
	DD	0277424H
	DD	0266424H
	DD	0253424H
	DD	01e0124H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Insertion_sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	0e2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Make_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 04H
	DB	'%', 02H
	DB	02H
	DB	098H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Make_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Make_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Make_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	imagerel $ip2state$??$_Make_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Make_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD 081f19H
	DD	0143410H
	DD	0f00cb210H
	DD	07008e00aH
	DD	050066007H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Make_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Sort_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 04H
	DB	']', 02H
	DB	02H
	DB	0baH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Sort_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Sort_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Sort_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	imagerel $ip2state$??$_Sort_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Sort_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD 081f19H
	DD	0143410H
	DD	0f00cb210H
	DD	07008e00aH
	DD	050066007H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Sort_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z DB '@'
	DB	0e0H
	DB	00H
	DB	'E', 04H
	DB	02H
	DB	0f8H
	DB	00H
	DB	'9', 03H
	DB	04H
	DB	01dH, 02H
	DB	00H
	DB	'Y', 04H
	DB	04H
	DB	011H, 02H
	DB	00H
	DB	'5', 03H
	DB	04H
	DB	0dH, 02H
	DB	00H
	DB	01dH, 04H
	DB	04H
	DB	'9', 02H
	DB	00H
	DB	'u', 03H
	DB	06H
	DB	'9', 02H
	DB	00H
	DB	0a1H, 04H
	DB	06H
	DB	'=', 02H
	DB	00H
	DB	'y', 03H
	DB	06H
	DB	'=', 02H
	DB	00H
	DB	0d9H, 06H
	DB	04H
	DB	0cH
	DB	00H
	DB	0cH
	DB	02H
	DB	0cH
	DB	00H
	DB	0cH
	DB	04H
	DB	0cH
	DB	00H
	DB	0cH
	DB	04H
	DB	0cH
	DB	00H
	DB	0cH
	DB	06H
	DB	0cH
	DB	00H
	DB	0cH
	DB	04H
	DB	0cH
	DB	00H
	DB	0cH
	DB	06H
	DB	0cH
	DB	00H
	DB	0cH
	DB	06H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z DB 06H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0c0H
	DB	03cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0d0H
	DB	06cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	01H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z
	DD	imagerel $ip2state$??$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z DD 0b1c11H
	DD	01d341cH
	DD	012011cH
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$construct@U?$pair@$$CBVNode@BymlFile@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBVNode@BymlFile@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBVNode@BymlFile@@I@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBVNode@BymlFile@@@1@$$QEAV?$tuple@$$V@1@@Z DB 06H
	DB	'@'
	DB	00H
	DB	'*'
	DB	02H
	DB	01cH
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$construct@U?$pair@$$CBVNode@BymlFile@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBVNode@BymlFile@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBVNode@BymlFile@@I@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBVNode@BymlFile@@@1@$$QEAV?$tuple@$$V@1@@Z DB 04H
	DB	0cH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	080H
	DB	036H
	DD	imagerel ?dtor$3@?0???$construct@U?$pair@$$CBVNode@BymlFile@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBVNode@BymlFile@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBVNode@BymlFile@@I@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBVNode@BymlFile@@@1@$$QEAV?$tuple@$$V@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$construct@U?$pair@$$CBVNode@BymlFile@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBVNode@BymlFile@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBVNode@BymlFile@@I@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBVNode@BymlFile@@@1@$$QEAV?$tuple@$$V@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$construct@U?$pair@$$CBVNode@BymlFile@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBVNode@BymlFile@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBVNode@BymlFile@@I@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBVNode@BymlFile@@@1@$$QEAV?$tuple@$$V@1@@Z
	DD	imagerel $ip2state$??$construct@U?$pair@$$CBVNode@BymlFile@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBVNode@BymlFile@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBVNode@BymlFile@@I@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBVNode@BymlFile@@@1@$$QEAV?$tuple@$$V@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@U?$pair@$$CBVNode@BymlFile@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBVNode@BymlFile@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBVNode@BymlFile@@I@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBVNode@BymlFile@@@1@$$QEAV?$tuple@$$V@1@@Z DD 040f11H
	DD	06340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$construct@U?$pair@$$CBVNode@BymlFile@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBVNode@BymlFile@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBVNode@BymlFile@@I@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBVNode@BymlFile@@@1@$$QEAV?$tuple@$$V@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$construct@U?$pair@$$CBVNode@BymlFile@@I@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBVNode@BymlFile@@I@1@$$QEAU31@@Z DB 06H
	DB	'@'
	DB	00H
	DB	'*'
	DB	02H
	DB	01cH
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$construct@U?$pair@$$CBVNode@BymlFile@@I@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBVNode@BymlFile@@I@1@$$QEAU31@@Z DB 04H
	DB	0cH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	060H
	DB	036H
	DD	imagerel ?dtor$2@?0???$construct@U?$pair@$$CBVNode@BymlFile@@I@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBVNode@BymlFile@@I@1@$$QEAU31@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$construct@U?$pair@$$CBVNode@BymlFile@@I@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBVNode@BymlFile@@I@1@$$QEAU31@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$construct@U?$pair@$$CBVNode@BymlFile@@I@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBVNode@BymlFile@@I@1@$$QEAU31@@Z
	DD	imagerel $ip2state$??$construct@U?$pair@$$CBVNode@BymlFile@@I@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBVNode@BymlFile@@I@1@$$QEAU31@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@U?$pair@$$CBVNode@BymlFile@@I@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBVNode@BymlFile@@I@1@$$QEAU31@@Z DD 040f11H
	DD	07340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$construct@U?$pair@$$CBVNode@BymlFile@@I@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBVNode@BymlFile@@I@1@$$QEAU31@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@$$QEAV?$tuple@$$V@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@$$QEAU31@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Move_backward_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PEAV10@00@Z DD 081201H
	DD	0b5412H
	DD	083412H
	DD	0e00e3212H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Pop_heap_hole_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 06H
	DB	095H, 03H
	DB	00H
	DB	'a', 02H
	DB	02H
	DB	'%', 05H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Pop_heap_hole_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	061H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Pop_heap_hole_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Pop_heap_hole_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	imagerel $ip2state$??$_Pop_heap_hole_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Pop_heap_hole_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD 0a1911H
	DD	0170119H
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	050023003H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Pop_heap_hole_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Pop_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 04H
	DB	011H, 02H
	DB	02H
	DB	09cH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Pop_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Pop_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Pop_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	imagerel $ip2state$??$_Pop_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Pop_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD 061e19H
	DD	011640fH
	DD	010340fH
	DD	0700bb20fH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Pop_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD 021H
	DD	imagerel ??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	imagerel ??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z+39
	DD	imagerel $unwind$??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD 061321H
	DD	0a6413H
	DD	09540eH
	DD	083405H
	DD	imagerel ??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	imagerel ??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z+39
	DD	imagerel $unwind$??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD 040a01H
	DD	0f006320aH
	DD	07002e004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Pop_heap_hole_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 06H
	DB	095H, 03H
	DB	00H
	DB	'a', 02H
	DB	02H
	DB	'%', 05H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Pop_heap_hole_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	061H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Pop_heap_hole_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Pop_heap_hole_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	imagerel $ip2state$??$_Pop_heap_hole_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Pop_heap_hole_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD 0a1911H
	DD	0170119H
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	050023003H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Pop_heap_hole_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Pop_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 04H
	DB	011H, 02H
	DB	02H
	DB	09cH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Pop_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Pop_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Pop_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	imagerel $ip2state$??$_Pop_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Pop_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD 061e19H
	DD	011640fH
	DD	010340fH
	DD	0700bb20fH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Pop_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD 021H
	DD	imagerel ??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	imagerel ??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z+39
	DD	imagerel $unwind$??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD 061321H
	DD	0a6413H
	DD	09540eH
	DD	083405H
	DD	imagerel ??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	imagerel ??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z+39
	DD	imagerel $unwind$??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD 040a01H
	DD	0f006320aH
	DD	07002e004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$construct_at@U?$pair@$$CBVNode@BymlFile@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBVNode@BymlFile@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBVNode@BymlFile@@I@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBVNode@BymlFile@@@0@$$QEAV?$tuple@$$V@0@@Z DB 06H
	DB	':'
	DB	00H
	DB	'*'
	DB	02H
	DB	01cH
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$construct_at@U?$pair@$$CBVNode@BymlFile@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBVNode@BymlFile@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBVNode@BymlFile@@I@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBVNode@BymlFile@@@0@$$QEAV?$tuple@$$V@0@@Z DB 04H
	DB	0cH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	090H
	DB	036H
	DD	imagerel ?dtor$3@?0???$construct_at@U?$pair@$$CBVNode@BymlFile@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBVNode@BymlFile@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBVNode@BymlFile@@I@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBVNode@BymlFile@@@0@$$QEAV?$tuple@$$V@0@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$construct_at@U?$pair@$$CBVNode@BymlFile@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBVNode@BymlFile@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBVNode@BymlFile@@I@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBVNode@BymlFile@@@0@$$QEAV?$tuple@$$V@0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$construct_at@U?$pair@$$CBVNode@BymlFile@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBVNode@BymlFile@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBVNode@BymlFile@@I@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBVNode@BymlFile@@@0@$$QEAV?$tuple@$$V@0@@Z
	DD	imagerel $ip2state$??$construct_at@U?$pair@$$CBVNode@BymlFile@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBVNode@BymlFile@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBVNode@BymlFile@@I@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBVNode@BymlFile@@@0@$$QEAV?$tuple@$$V@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@U?$pair@$$CBVNode@BymlFile@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBVNode@BymlFile@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBVNode@BymlFile@@I@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBVNode@BymlFile@@@0@$$QEAV?$tuple@$$V@0@@Z DD 040f11H
	DD	06340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$construct_at@U?$pair@$$CBVNode@BymlFile@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBVNode@BymlFile@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBVNode@BymlFile@@I@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBVNode@BymlFile@@@0@$$QEAV?$tuple@$$V@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$construct_at@U?$pair@$$CBVNode@BymlFile@@I@std@@U12@$0A@@std@@YAPEAU?$pair@$$CBVNode@BymlFile@@I@0@QEAU10@$$QEAU10@@Z DB 06H
	DB	'*'
	DB	00H
	DB	'*'
	DB	02H
	DB	01cH
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$construct_at@U?$pair@$$CBVNode@BymlFile@@I@std@@U12@$0A@@std@@YAPEAU?$pair@$$CBVNode@BymlFile@@I@0@QEAU10@$$QEAU10@@Z DB 04H
	DB	0cH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	060H
	DB	036H
	DD	imagerel ?dtor$2@?0???$construct_at@U?$pair@$$CBVNode@BymlFile@@I@std@@U12@$0A@@std@@YAPEAU?$pair@$$CBVNode@BymlFile@@I@0@QEAU10@$$QEAU10@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$construct_at@U?$pair@$$CBVNode@BymlFile@@I@std@@U12@$0A@@std@@YAPEAU?$pair@$$CBVNode@BymlFile@@I@0@QEAU10@$$QEAU10@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$construct_at@U?$pair@$$CBVNode@BymlFile@@I@std@@U12@$0A@@std@@YAPEAU?$pair@$$CBVNode@BymlFile@@I@0@QEAU10@$$QEAU10@@Z
	DD	imagerel $ip2state$??$construct_at@U?$pair@$$CBVNode@BymlFile@@I@std@@U12@$0A@@std@@YAPEAU?$pair@$$CBVNode@BymlFile@@I@0@QEAU10@$$QEAU10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@U?$pair@$$CBVNode@BymlFile@@I@std@@U12@$0A@@std@@YAPEAU?$pair@$$CBVNode@BymlFile@@I@0@QEAU10@$$QEAU10@@Z DD 040a11H
	DD	07340aH
	DD	07006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$construct_at@U?$pair@$$CBVNode@BymlFile@@I@std@@U12@$0A@@std@@YAPEAU?$pair@$$CBVNode@BymlFile@@I@0@QEAU10@$$QEAU10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@0@$$QEAV?$tuple@$$V@0@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@U12@$0A@@std@@YAPEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@0@QEAU10@$$QEAU10@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@$$QEAU01@@Z DB 06H
	DB	'4'
	DB	00H
	DB	'*'
	DB	02H
	DB	01cH
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@$$QEAU01@@Z DB 04H
	DB	0cH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	060H
	DB	036H
	DD	imagerel ?dtor$2@?0???0?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@$$QEAU01@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@$$QEAU01@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@$$QEAU01@@Z
	DD	imagerel $ip2state$??0?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@$$QEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@$$QEAU01@@Z DD 040f11H
	DD	07340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@$$QEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@QEAA@$$QEAU01@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0AEBVNode@BymlFile@@$$Z$$V@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBVNode@BymlFile@@@1@V?$tuple@$$V@1@@Z DB 06H
	DB	':'
	DB	00H
	DB	'*'
	DB	02H
	DB	01cH
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0AEBVNode@BymlFile@@$$Z$$V@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBVNode@BymlFile@@@1@V?$tuple@$$V@1@@Z DB 04H
	DB	0cH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	090H
	DB	036H
	DD	imagerel ?dtor$3@?0???$?0AEBVNode@BymlFile@@$$Z$$V@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBVNode@BymlFile@@@1@V?$tuple@$$V@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0AEBVNode@BymlFile@@$$Z$$V@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBVNode@BymlFile@@@1@V?$tuple@$$V@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$?0AEBVNode@BymlFile@@$$Z$$V@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBVNode@BymlFile@@@1@V?$tuple@$$V@1@@Z
	DD	imagerel $ip2state$??$?0AEBVNode@BymlFile@@$$Z$$V@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBVNode@BymlFile@@@1@V?$tuple@$$V@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBVNode@BymlFile@@$$Z$$V@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBVNode@BymlFile@@@1@V?$tuple@$$V@1@@Z DD 040f11H
	DD	06340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0AEBVNode@BymlFile@@$$Z$$V@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBVNode@BymlFile@@@1@V?$tuple@$$V@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBV?$vector@EV?$allocator@E@std@@@std@@$$Z$$V@?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@V?$tuple@$$V@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Push_heap_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 06H
	DB	011H, 03H
	DB	00H
	DB	081H, 02H
	DB	02H
	DB	'-', 04H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Push_heap_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0e0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Push_heap_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Push_heap_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	imagerel $ip2state$??$_Push_heap_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Push_heap_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD 0a1a11H
	DD	01a341aH
	DD	0f010f21aH
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Push_heap_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Pop_heap_hole_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00$$QEAV10@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 0cH
	DB	'V'
	DB	00H
	DB	' '
	DB	02H
	DB	0c6H
	DB	00H
	DB	' '
	DB	04H
	DB	0ceH
	DB	00H
	DB	' '
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 04H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	040H
	DB	03cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	050H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	imagerel $ip2state$??$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD 081011H
	DD	0173410H
	DD	0f00cd210H
	DD	07008e00aH
	DD	050066007H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Push_heap_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 06H
	DB	011H, 03H
	DB	00H
	DB	081H, 02H
	DB	02H
	DB	'-', 04H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Push_heap_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0e0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Push_heap_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Push_heap_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	imagerel $ip2state$??$_Push_heap_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Push_heap_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD 0a1a11H
	DD	01a341aH
	DD	0f010f21aH
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Push_heap_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Pop_heap_hole_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00$$QEAV10@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 0cH
	DB	'V'
	DB	00H
	DB	' '
	DB	02H
	DB	0c6H
	DB	00H
	DB	' '
	DB	04H
	DB	0ceH
	DB	00H
	DB	' '
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 04H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	040H
	DB	03cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	050H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
	DD	imagerel $ip2state$??$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z DD 081011H
	DD	0173410H
	DD	0f00cd210H
	DD	07008e00aH
	DD	050066007H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0V?$tuple@AEBVNode@BymlFile@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@AEAV?$tuple@AEBVNode@BymlFile@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z DB 06H
	DB	':'
	DB	00H
	DB	'*'
	DB	02H
	DB	01cH
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0V?$tuple@AEBVNode@BymlFile@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@AEAV?$tuple@AEBVNode@BymlFile@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z DB 04H
	DB	0cH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	080H
	DB	036H
	DD	imagerel ?dtor$2@?0???$?0V?$tuple@AEBVNode@BymlFile@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@AEAV?$tuple@AEBVNode@BymlFile@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0V?$tuple@AEBVNode@BymlFile@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@AEAV?$tuple@AEBVNode@BymlFile@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$?0V?$tuple@AEBVNode@BymlFile@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@AEAV?$tuple@AEBVNode@BymlFile@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z
	DD	imagerel $ip2state$??$?0V?$tuple@AEBVNode@BymlFile@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@AEAV?$tuple@AEBVNode@BymlFile@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$tuple@AEBVNode@BymlFile@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@AEAV?$tuple@AEBVNode@BymlFile@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z DD 040f11H
	DD	06340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0V?$tuple@AEBVNode@BymlFile@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@AEAV?$tuple@AEBVNode@BymlFile@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@QEAA@AEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
;	COMDAT ??0BymlFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z
_TEXT	SEGMENT
$T1 = 64
$T2 = 64
$T3 = 64
$T4 = 72
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 112
$T9 = 112
$T10 = 144
$T11 = 144
$T12 = 176
this$GSCopy$ = 208
$T13 = 216
$T14 = 248
Bytes$GSCopy$ = 280
Reader$ = 288
RootNode$ = 304
__$ArrayPad$ = 400
this$ = 480
Bytes$ = 488
??0BymlFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z PROC ; BymlFile::BymlFile, COMDAT

; 619  : {

$LN488:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-160]
	sub	rsp, 416				; 000001a0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	r15, rdx
	mov	rsi, rcx
	mov	QWORD PTR this$GSCopy$[rbp-256], rcx
	mov	QWORD PTR Bytes$GSCopy$[rbp-256], rdx
	xor	r13d, r13d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx], r13
	mov	QWORD PTR [rcx+8], r13
	mov	QWORD PTR [rcx+16], r13
	mov	QWORD PTR [rcx+24], r13
	mov	QWORD PTR [rcx+32], r13
	mov	QWORD PTR [rcx+40], r13
	mov	QWORD PTR [rcx+48], r13
	mov	QWORD PTR [rcx+56], r13
	mov	QWORD PTR [rcx+64], r13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h

; 182  :     BymlFile::Type m_Type = BymlFile::Type::Null;

	mov	BYTE PTR [rcx+72], 255			; 000000ffH

; 183  :     uint32_t m_WriterLastOffset = 0;

	mov	QWORD PTR [rcx+76], r13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 619  : {

	add	rcx, 88					; 00000058H
	call	??0?$unordered_map@V?$vector@EV?$allocator@E@std@@@std@@IUVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@@std@@QEAA@XZ ; std::unordered_map<std::vector<unsigned char,std::allocator<unsigned char> >,unsigned int,BymlFile::VectorHasher,std::equal_to<std::vector<unsigned char,std::allocator<unsigned char> > >,std::allocator<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> > >::unordered_map<std::vector<unsigned char,std::allocator<unsigned char> >,unsigned int,BymlFile::VectorHasher,std::equal_to<std::vector<unsigned char,std::allocator<unsigned char> > >,std::allocator<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> > >
	npad	1
	lea	rcx, QWORD PTR [rsi+152]
	call	??0?$unordered_map@VNode@BymlFile@@IUNodeHasher@2@UNodeEqual@2@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@std@@@std@@QEAA@XZ ; std::unordered_map<BymlFile::Node,unsigned int,BymlFile::NodeHasher,BymlFile::NodeEqual,std::allocator<std::pair<BymlFile::Node const ,unsigned int> > >::unordered_map<BymlFile::Node,unsigned int,BymlFile::NodeHasher,BymlFile::NodeEqual,std::allocator<std::pair<BymlFile::Node const ,unsigned int> > >
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h

; 187  :     bool mBigEndian = false;

	mov	BYTE PTR [rsi+216], r13b
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 6    : BinaryVectorReader::BinaryVectorReader(std::vector<unsigned char>& Bytes, bool BigEndian) : m_Bytes(Bytes) {}

	mov	QWORD PTR Reader$[rbp-256], r15
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r15]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 38   : 		Data[i] = this->m_Bytes[this->m_Offset];

	movzx	r8d, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 624  :     if ((Magic[0] != 'Y' && Magic[0] != 'B') && (Magic[1] != 'Y' && Magic[1] != 'B'))

	cmp	r8b, 89					; 00000059H
	je	SHORT $LN5@BymlFile
	cmp	r8b, 66					; 00000042H
	je	SHORT $LN482@BymlFile
	cmp	cl, 89					; 00000059H
	je	SHORT $LN5@BymlFile
	cmp	cl, 66					; 00000042H
	je	SHORT $LN5@BymlFile

; 626  :         Logger::Error("BymlDecoder", "Wrong magic, expected YB or BY");

	lea	rax, QWORD PTR $T6[rsp]
	mov	QWORD PTR $T7[rsp], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T6[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T6[rsp+16], r13

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T6[rsp+24], r13

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [r13+30]
	lea	rdx, OFFSET FLAT:??_C@_0BP@KCOKJPO@Wrong?5magic?0?5expected?5YB?5or?5BY@
	lea	rcx, QWORD PTR $T6[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T9[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T9[rbp-240], r13

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T9[rbp-232], r13

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [r13+11]
	lea	rdx, OFFSET FLAT:??_C@_0M@EFFJMBCP@BymlDecoder@
	lea	rcx, QWORD PTR $T9[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 626  :         Logger::Error("BymlDecoder", "Wrong magic, expected YB or BY");

	lea	rdx, QWORD PTR $T6[rsp]
	lea	rcx, QWORD PTR $T9[rsp]
	call	?Error@Logger@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; Logger::Error

; 627  :         return;

	jmp	$LN77@BymlFile
$LN5@BymlFile:

; 628  :     }
; 629  : 
; 630  :     if (Magic[0] == 'B' && Magic[1] == 'Y')

	xor	dl, dl
	cmp	r8b, 66					; 00000042H
	jne	SHORT $LN6@BymlFile
$LN482@BymlFile:
	xor	dl, dl
	cmp	cl, 89					; 00000059H
	jne	SHORT $LN6@BymlFile

; 631  :     {
; 632  :         mBigEndian = true;

	mov	BYTE PTR [rsi+216], 1
	mov	dl, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r15]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 57   : 	return !BigEndian ? ((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)) : _byteswap_ushort(((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)));

	movzx	ecx, BYTE PTR [rax+3]
	shl	cx, 8
	movzx	eax, BYTE PTR [rax+2]
	or	cx, ax
	ror	cx, 8
	jmp	SHORT $LN147@BymlFile
$LN6@BymlFile:
	movzx	ecx, BYTE PTR [rax+3]
	shl	cx, 8
	movzx	eax, BYTE PTR [rax+2]
	or	cx, ax
$LN147@BymlFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 636  :     if (Version != 0x07 && Version != 0x02)

	cmp	cx, 7
	je	$LN7@BymlFile
	cmp	cx, 2
	je	$LN7@BymlFile

; 638  :         Logger::Error("BymlDecoder", "Wrong version, expected v2 or v7, got v" + std::to_string(Version));

	lea	rbx, QWORD PTR $T8[rsp]
	mov	QWORD PTR $T3[rsp], rbx
	movzx	edx, cx
	lea	rcx, QWORD PTR $T13[rbp-256]
	call	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ; std::to_string
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3537 :         return insert(_Off, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r9d, 39					; 00000027H
	lea	r8, OFFSET FLAT:??_C@_0CI@PEJJCEAH@Wrong?5version?0?5expected?5v2?5or?5v@
	mov	rcx, rax
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T8[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T8[rbp-240], r13

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T8[rbp-232], r13

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T8[rsp], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T8[rbp-240], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 638  :         Logger::Error("BymlDecoder", "Wrong version, expected v2 or v7, got v" + std::to_string(Version));

	mov	QWORD PTR [rax+16], r13
	mov	QWORD PTR [rax+24], 15
	mov	BYTE PTR [rax], 0
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T5[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T5[rsp+16], r13

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T5[rsp+24], r13

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 11
	lea	rdx, OFFSET FLAT:??_C@_0M@EFFJMBCP@BymlDecoder@
	lea	rcx, QWORD PTR $T5[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 638  :         Logger::Error("BymlDecoder", "Wrong version, expected v2 or v7, got v" + std::to_string(Version));

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T5[rsp]
	call	?Error@Logger@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; Logger::Error
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T13[rbp-232]
	cmp	rdx, 16
	jb	$LN77@BymlFile

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T13[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	$LN89@BymlFile

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	$LN89@BymlFile
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN7@BymlFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	mov	rcx, QWORD PTR [r15]
	movzx	r9d, BYTE PTR [rcx+6]
	movzx	eax, BYTE PTR [rcx+5]
	movzx	ebx, BYTE PTR [rcx+10]
	shl	r9d, 8
	shl	ebx, 8
	or	r9d, eax
	shl	r9d, 8
	movzx	eax, BYTE PTR [rcx+7]
	shl	eax, 24
	or	r9d, eax
	movzx	eax, BYTE PTR [rcx+4]
	or	r9d, eax
	movzx	eax, BYTE PTR [rcx+9]
	or	ebx, eax
	shl	ebx, 8
	movzx	eax, BYTE PTR [rcx+11]
	shl	eax, 24
	or	ebx, eax
	movzx	eax, BYTE PTR [rcx+8]
	or	ebx, eax
	mov	DWORD PTR Reader$[rbp-248], 15
	mov	rcx, QWORD PTR [r15]
	movzx	edi, BYTE PTR [rcx+14]
	movzx	eax, BYTE PTR [rcx+13]
	shl	edi, 8
	or	edi, eax
	shl	edi, 8
	movzx	eax, BYTE PTR [rcx+15]
	shl	eax, 24
	or	edi, eax
	movzx	eax, BYTE PTR [rcx+12]
	or	edi, eax
	test	dl, dl
	je	SHORT $LN171@BymlFile
	bswap	r9d
	bswap	ebx
	bswap	edi
$LN171@BymlFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 646  :     if (KeyTableOffset != 0) //If equal to 0, there is no Key Table

	test	r9d, r9d
	je	SHORT $LN8@BymlFile

; 647  :     {
; 648  :         this->ParseTable(Reader, &this->m_HashKeyTable, KeyTableOffset);

	lea	r8, QWORD PTR [rsi+24]
	lea	rdx, QWORD PTR Reader$[rbp-256]
	mov	rcx, rsi
	call	?ParseTable@BymlFile@@AEAAXAEAVBinaryVectorReader@@PEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@H@Z ; BymlFile::ParseTable
$LN8@BymlFile:

; 649  :     }
; 650  : 
; 651  :     if (StringTableOffset != 0) //If equal to 0, there is no String Table

	test	ebx, ebx
	je	SHORT $LN9@BymlFile

; 652  :     {
; 653  :         this->ParseTable(Reader, &this->m_StringTable, StringTableOffset);

	mov	r9d, ebx
	lea	r8, QWORD PTR [rsi+48]
	lea	rdx, QWORD PTR Reader$[rbp-256]
	mov	rcx, rsi
	call	?ParseTable@BymlFile@@AEAAXAEAVBinaryVectorReader@@PEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@H@Z ; BymlFile::ParseTable
$LN9@BymlFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 44   : 	this->m_Offset++;

	mov	DWORD PTR Reader$[rbp-248], edi
	movsxd	rcx, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR Reader$[rbp-256]
	add	rcx, QWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 45   : 	return this->m_Bytes[this->m_Offset];

	movzx	ebx, BYTE PTR [rcx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 659  :     if (RootNodeType != (uint8_t)BymlFile::Type::Array && RootNodeType != (uint8_t)BymlFile::Type::Dictionary)

	cmp	bl, 192					; 000000c0H
	je	$LN10@BymlFile
	cmp	bl, 193					; 000000c1H
	je	$LN10@BymlFile

; 661  :         Logger::Error("BymlDecoder", "Expected array (0xC0) or dictionary (0xC1), but got " + std::to_string((int)RootNodeType));

	lea	rdi, QWORD PTR $T12[rbp-256]
	mov	QWORD PTR $T2[rsp], rdi
	mov	edx, ebx
	lea	rcx, QWORD PTR $T14[rbp-256]
	call	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ; std::to_string
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3537 :         return insert(_Off, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r9d, 52					; 00000034H
	lea	r8, OFFSET FLAT:??_C@_0DF@HGLJMNNH@Expected?5array?5?$CI0xC0?$CJ?5or?5dictio@
	mov	rcx, rax
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T12[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T12[rbp-240], r13

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T12[rbp-232], r13

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T12[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T12[rbp-240], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 661  :         Logger::Error("BymlDecoder", "Expected array (0xC0) or dictionary (0xC1), but got " + std::to_string((int)RootNodeType));

	mov	QWORD PTR [rax+16], r13
	mov	QWORD PTR [rax+24], 15
	mov	BYTE PTR [rax], 0
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T11[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T11[rbp-240], r13

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T11[rbp-232], r13

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 11
	lea	rdx, OFFSET FLAT:??_C@_0M@EFFJMBCP@BymlDecoder@
	lea	rcx, QWORD PTR $T11[rbp-256]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 661  :         Logger::Error("BymlDecoder", "Expected array (0xC0) or dictionary (0xC1), but got " + std::to_string((int)RootNodeType));

	mov	rdx, rdi
	lea	rcx, QWORD PTR $T11[rbp-256]
	call	?Error@Logger@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; Logger::Error
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T14[rbp-232]
	cmp	rdx, 16
	jb	$LN77@BymlFile

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T14[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	$LN89@BymlFile

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	$LN89@BymlFile
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN10@BymlFile:
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR RootNode$[rbp-256], xmm0
	movups	XMMWORD PTR RootNode$[rbp-240], xmm0
	movups	XMMWORD PTR RootNode$[rbp-224], xmm0
	movups	XMMWORD PTR RootNode$[rbp-208], xmm0
	movups	XMMWORD PTR RootNode$[rbp-192], xmm0
	mov	QWORD PTR RootNode$[rbp-176], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T4[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T4[rsp+16], r13

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T4[rsp+24], r13

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rax+4]
	lea	rdx, OFFSET FLAT:??_C@_04NBFCGMPH@root@
	lea	rcx, QWORD PTR $T4[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 665  :     BymlFile::Node RootNode(RootNodeType == 0xC0 ? BymlFile::Type::Array : BymlFile::Type::Dictionary, "root");

	lea	rax, QWORD PTR $T4[rsp]
	mov	QWORD PTR $T1[rsp], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqa	XMMWORD PTR RootNode$[rbp-256], xmm0
	mov	QWORD PTR RootNode$[rbp-240], r13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 665  :     BymlFile::Node RootNode(RootNodeType == 0xC0 ? BymlFile::Type::Array : BymlFile::Type::Dictionary, "root");

	cmp	bl, 192					; 000000c0H
	setne	al
	add	al, 192					; 000000c0H

; 9    : BymlFile::Node::Node(BymlFile::Type Type, std::string Key) : m_Type(Type), m_Key(Key)

	mov	BYTE PTR RootNode$[rbp-232], al
	lea	rdx, QWORD PTR $T4[rsp]
	lea	rcx, QWORD PTR RootNode$[rbp-224]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqa	XMMWORD PTR RootNode$[rbp-192], xmm0
	mov	QWORD PTR RootNode$[rbp-176], r13
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T4[rsp]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 666  :     RootNode.GetChildren().resize(1);

	mov	edx, 1
	lea	rcx, QWORD PTR RootNode$[rbp-192]
	call	?resize@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAX_K@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::resize
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T10[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T10[rbp-240], r13

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T10[rbp-232], r13

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 4
	lea	rdx, OFFSET FLAT:??_C@_04NBFCGMPH@root@
	lea	rcx, QWORD PTR $T10[rbp-256]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 667  :     this->ParseNode(Reader, 12, RootNode.GetType(), "root", &RootNode, 0);

	mov	DWORD PTR [rsp+48], r13d
	lea	rax, QWORD PTR RootNode$[rbp-256]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR $T10[rbp-256]
	mov	QWORD PTR [rsp+32], rax
	movzx	r9d, BYTE PTR RootNode$[rbp-232]
	mov	r8d, 12
	lea	rdx, QWORD PTR Reader$[rbp-256]
	mov	rcx, rsi
	call	?ParseNode@BymlFile@@AEAAXAEAVBinaryVectorReader@@HW4Type@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVNode@1@I@Z ; BymlFile::ParseNode

; 669  :     this->m_Nodes.resize(RootNode.GetChildren()[0].GetChildren().size());

	mov	rax, QWORD PTR RootNode$[rbp-192]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [rax+72]
	sub	rdx, QWORD PTR [rax+64]
	sar	rdx, 3
	mov	rbx, 3353953467947191203		; 2e8ba2e8ba2e8ba3H
	imul	rdx, rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 669  :     this->m_Nodes.resize(RootNode.GetChildren()[0].GetChildren().size());

	mov	rcx, rsi
	call	?resize@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAX_K@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::resize

; 670  :     for (int i = 0; i < RootNode.GetChildren()[0].GetChildren().size(); i++)

	mov	r12d, r13d
	mov	rdx, QWORD PTR RootNode$[rbp-192]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [rdx+72]
	sub	rax, QWORD PTR [rdx+64]
	sar	rax, 3
	imul	rax, rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 670  :     for (int i = 0; i < RootNode.GetChildren()[0].GetChildren().size(); i++)

	test	rax, rax
	je	$LN3@BymlFile
	mov	r14, r13
	mov	r13, rbx
	npad	8
$LL4@BymlFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rbx, QWORD PTR [rdx+64]
	add	rbx, r14
	mov	rdi, QWORD PTR [rsi]
	add	rdi, r14

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rdi, rbx
	je	SHORT $LN97@BymlFile

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [rbx]
	mov	r8, QWORD PTR [rbx+8]
	sub	r8, rdx
	mov	rcx, rdi
	call	??$_Assign_counted_range@PEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAXPEAE_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Assign_counted_range<unsigned char *>
$LN97@BymlFile:
	movzx	eax, BYTE PTR [rbx+24]
	mov	BYTE PTR [rdi+24], al
	lea	rdx, QWORD PTR [rbx+32]
	lea	rcx, QWORD PTR [rdi+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3156 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN100@BymlFile

; 3157 :             return *this;
; 3158 :         }
; 3159 : 
; 3160 :         auto& _Al             = _Getal();
; 3161 :         const auto& _Right_al = _Right._Getal();
; 3162 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 3163 :             if (_Al != _Right_al) {
; 3164 :                 auto&& _Alproxy       = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 3165 :                 auto&& _Right_alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Right_al);
; 3166 :                 _Container_proxy_ptr<_Alty> _New_proxy(_Right_alproxy, _Leave_proxy_unbound{}); // throws
; 3167 : 
; 3168 :                 if (_Right._Mypair._Myval2._Large_string_engaged()) {
; 3169 :                     const auto _New_size     = _Right._Mypair._Myval2._Mysize;
; 3170 :                     const auto _New_capacity = _Calculate_growth(_New_size, 0, _Right.max_size());
; 3171 :                     auto _Right_al_non_const = _Right_al;
; 3172 :                     const auto _New_ptr      = _Right_al_non_const.allocate(_New_capacity + 1); // throws
; 3173 : 
; 3174 :                     _Start_element_lifetimes(_Unfancy(_New_ptr), _New_size + 1);
; 3175 : 
; 3176 :                     _Traits::copy(_Unfancy(_New_ptr), _Unfancy(_Right._Mypair._Myval2._Bx._Ptr), _New_size + 1);
; 3177 :                     _Tidy_deallocate();
; 3178 :                     _Mypair._Myval2._Bx._Ptr = _New_ptr;
; 3179 :                     _Mypair._Myval2._Mysize  = _New_size;
; 3180 :                     _Mypair._Myval2._Myres   = _New_capacity;
; 3181 :                 } else {
; 3182 :                     _Copy_assign_val_from_small(_Right);
; 3183 :                 }
; 3184 : 
; 3185 :                 _Pocca(_Al, _Right_al);
; 3186 :                 _New_proxy._Bind(_Alproxy, _STD addressof(_Mypair._Myval2));
; 3187 :                 return *this;
; 3188 :             }
; 3189 :         }
; 3190 : 
; 3191 :         _Pocca(_Al, _Right_al);
; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rdx+16]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rdx+24], 16
	jb	SHORT $LN104@BymlFile

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN104@BymlFile:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN100@BymlFile:
	lea	r8, QWORD PTR [rbx+64]
	lea	rcx, QWORD PTR [rdi+64]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, r8
	je	SHORT $LN2@BymlFile

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [r8]
	mov	r8, QWORD PTR [r8+8]
	sub	r8, rdx
	sar	r8, 3
	imul	r8, r13
	call	??$_Assign_counted_range@PEAVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAXPEAVNode@BymlFile@@_K@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Assign_counted_range<BymlFile::Node *>
$LN2@BymlFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 670  :     for (int i = 0; i < RootNode.GetChildren()[0].GetChildren().size(); i++)

	inc	r12d
	add	r14, 88					; 00000058H
	mov	rdx, QWORD PTR RootNode$[rbp-192]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rdx+72]
	sub	rcx, QWORD PTR [rdx+64]
	sar	rcx, 3
	imul	rcx, r13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 670  :     for (int i = 0; i < RootNode.GetChildren()[0].GetChildren().size(); i++)

	movsxd	rax, r12d
	cmp	rax, rcx
	jb	$LL4@BymlFile
	xor	r13d, r13d
$LN3@BymlFile:

; 671  :     {
; 672  :         this->m_Nodes[i] = RootNode.GetChildren()[0].GetChildren()[i];
; 673  :     }
; 674  : 
; 675  :     this->m_Type = RootNode.GetType();

	movzx	eax, BYTE PTR RootNode$[rbp-232]
	mov	BYTE PTR [rsi+72], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	lea	rcx, QWORD PTR RootNode$[rbp-192]
	call	?_Tidy@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAXXZ ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR RootNode$[rbp-224]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR RootNode$[rbp-256]
	test	rcx, rcx
	je	SHORT $LN77@BymlFile

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR RootNode$[rbp-240]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN89@BymlFile

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN89@BymlFile
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN89@BymlFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 676  : }

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN77@BymlFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [r15]
	test	rcx, rcx
	je	SHORT $LN36@BymlFile

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [r15+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN54@BymlFile

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN51@BymlFile

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN54@BymlFile:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	mov	QWORD PTR [r15], r13

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [r15+8], r13

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [r15+16], r13
$LN36@BymlFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 676  : }

	mov	rax, rsi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+496]
	add	rsp, 416				; 000001a0H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN51@BymlFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN485@BymlFile:
??0BymlFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z ENDP ; BymlFile::BymlFile
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
$T2 = 64
$T3 = 64
$T4 = 72
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 112
$T9 = 112
$T10 = 144
$T11 = 144
$T12 = 176
this$GSCopy$ = 208
$T13 = 216
$T14 = 248
Bytes$GSCopy$ = 280
Reader$ = 288
RootNode$ = 304
__$ArrayPad$ = 400
this$ = 480
Bytes$ = 488
?dtor$0@?0???0BymlFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA PROC ; `BymlFile::BymlFile'::`1'::dtor$0
	mov	rcx, QWORD PTR Bytes$GSCopy$[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$0@?0???0BymlFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA ENDP ; `BymlFile::BymlFile'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
$T2 = 64
$T3 = 64
$T4 = 72
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 112
$T9 = 112
$T10 = 144
$T11 = 144
$T12 = 176
this$GSCopy$ = 208
$T13 = 216
$T14 = 248
Bytes$GSCopy$ = 280
Reader$ = 288
RootNode$ = 304
__$ArrayPad$ = 400
this$ = 480
Bytes$ = 488
?dtor$1@?0???0BymlFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA PROC ; `BymlFile::BymlFile'::`1'::dtor$1
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	jmp	??1?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@XZ ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::~vector<BymlFile::Node,std::allocator<BymlFile::Node> >
?dtor$1@?0???0BymlFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA ENDP ; `BymlFile::BymlFile'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
$T2 = 64
$T3 = 64
$T4 = 72
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 112
$T9 = 112
$T10 = 144
$T11 = 144
$T12 = 176
this$GSCopy$ = 208
$T13 = 216
$T14 = 248
Bytes$GSCopy$ = 280
Reader$ = 288
RootNode$ = 304
__$ArrayPad$ = 400
this$ = 480
Bytes$ = 488
?dtor$2@?0???0BymlFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA PROC ; `BymlFile::BymlFile'::`1'::dtor$2
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 24
	jmp	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
?dtor$2@?0???0BymlFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA ENDP ; `BymlFile::BymlFile'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
$T2 = 64
$T3 = 64
$T4 = 72
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 112
$T9 = 112
$T10 = 144
$T11 = 144
$T12 = 176
this$GSCopy$ = 208
$T13 = 216
$T14 = 248
Bytes$GSCopy$ = 280
Reader$ = 288
RootNode$ = 304
__$ArrayPad$ = 400
this$ = 480
Bytes$ = 488
?dtor$3@?0???0BymlFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA PROC ; `BymlFile::BymlFile'::`1'::dtor$3
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 48					; 00000030H
	jmp	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
?dtor$3@?0???0BymlFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA ENDP ; `BymlFile::BymlFile'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
$T2 = 64
$T3 = 64
$T4 = 72
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 112
$T9 = 112
$T10 = 144
$T11 = 144
$T12 = 176
this$GSCopy$ = 208
$T13 = 216
$T14 = 248
Bytes$GSCopy$ = 280
Reader$ = 288
RootNode$ = 304
__$ArrayPad$ = 400
this$ = 480
Bytes$ = 488
?dtor$4@?0???0BymlFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA PROC ; `BymlFile::BymlFile'::`1'::dtor$4
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 88					; 00000058H
	jmp	??1?$unordered_map@V?$vector@EV?$allocator@E@std@@@std@@IUVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@@std@@QEAA@XZ
?dtor$4@?0???0BymlFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA ENDP ; `BymlFile::BymlFile'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
$T2 = 64
$T3 = 64
$T4 = 72
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 112
$T9 = 112
$T10 = 144
$T11 = 144
$T12 = 176
this$GSCopy$ = 208
$T13 = 216
$T14 = 248
Bytes$GSCopy$ = 280
Reader$ = 288
RootNode$ = 304
__$ArrayPad$ = 400
this$ = 480
Bytes$ = 488
?dtor$5@?0???0BymlFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA PROC ; `BymlFile::BymlFile'::`1'::dtor$5
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 152				; 00000098H
	jmp	??1?$unordered_map@VNode@BymlFile@@IUNodeHasher@2@UNodeEqual@2@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@std@@@std@@QEAA@XZ
?dtor$5@?0???0BymlFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA ENDP ; `BymlFile::BymlFile'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
$T2 = 64
$T3 = 64
$T4 = 72
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 112
$T9 = 112
$T10 = 144
$T11 = 144
$T12 = 176
this$GSCopy$ = 208
$T13 = 216
$T14 = 248
Bytes$GSCopy$ = 280
Reader$ = 288
RootNode$ = 304
__$ArrayPad$ = 400
this$ = 480
Bytes$ = 488
?dtor$6@?0???0BymlFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA PROC ; `BymlFile::BymlFile'::`1'::dtor$6
	mov	rcx, QWORD PTR $T7[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$6@?0???0BymlFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA ENDP ; `BymlFile::BymlFile'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
$T2 = 64
$T3 = 64
$T4 = 72
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 112
$T9 = 112
$T10 = 144
$T11 = 144
$T12 = 176
this$GSCopy$ = 208
$T13 = 216
$T14 = 248
Bytes$GSCopy$ = 280
Reader$ = 288
RootNode$ = 304
__$ArrayPad$ = 400
this$ = 480
Bytes$ = 488
?dtor$8@?0???0BymlFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA PROC ; `BymlFile::BymlFile'::`1'::dtor$8
	lea	rcx, QWORD PTR $T13[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$8@?0???0BymlFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA ENDP ; `BymlFile::BymlFile'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
$T2 = 64
$T3 = 64
$T4 = 72
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 112
$T9 = 112
$T10 = 144
$T11 = 144
$T12 = 176
this$GSCopy$ = 208
$T13 = 216
$T14 = 248
Bytes$GSCopy$ = 280
Reader$ = 288
RootNode$ = 304
__$ArrayPad$ = 400
this$ = 480
Bytes$ = 488
?dtor$9@?0???0BymlFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA PROC ; `BymlFile::BymlFile'::`1'::dtor$9
	mov	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$9@?0???0BymlFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA ENDP ; `BymlFile::BymlFile'::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
$T2 = 64
$T3 = 64
$T4 = 72
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 112
$T9 = 112
$T10 = 144
$T11 = 144
$T12 = 176
this$GSCopy$ = 208
$T13 = 216
$T14 = 248
Bytes$GSCopy$ = 280
Reader$ = 288
RootNode$ = 304
__$ArrayPad$ = 400
this$ = 480
Bytes$ = 488
?dtor$11@?0???0BymlFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA PROC ; `BymlFile::BymlFile'::`1'::dtor$11
	lea	rcx, QWORD PTR $T14[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$11@?0???0BymlFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA ENDP ; `BymlFile::BymlFile'::`1'::dtor$11
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
$T2 = 64
$T3 = 64
$T4 = 72
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 112
$T9 = 112
$T10 = 144
$T11 = 144
$T12 = 176
this$GSCopy$ = 208
$T13 = 216
$T14 = 248
Bytes$GSCopy$ = 280
Reader$ = 288
RootNode$ = 304
__$ArrayPad$ = 400
this$ = 480
Bytes$ = 488
?dtor$12@?0???0BymlFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA PROC ; `BymlFile::BymlFile'::`1'::dtor$12
	mov	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$12@?0???0BymlFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA ENDP ; `BymlFile::BymlFile'::`1'::dtor$12
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
$T2 = 64
$T3 = 64
$T4 = 72
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 112
$T9 = 112
$T10 = 144
$T11 = 144
$T12 = 176
this$GSCopy$ = 208
$T13 = 216
$T14 = 248
Bytes$GSCopy$ = 280
Reader$ = 288
RootNode$ = 304
__$ArrayPad$ = 400
this$ = 480
Bytes$ = 488
?dtor$21@?0???0BymlFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA PROC ; `BymlFile::BymlFile'::`1'::dtor$21
	mov	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$21@?0???0BymlFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA ENDP ; `BymlFile::BymlFile'::`1'::dtor$21
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
$T2 = 64
$T3 = 64
$T4 = 72
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 112
$T9 = 112
$T10 = 144
$T11 = 144
$T12 = 176
this$GSCopy$ = 208
$T13 = 216
$T14 = 248
Bytes$GSCopy$ = 280
Reader$ = 288
RootNode$ = 304
__$ArrayPad$ = 400
this$ = 480
Bytes$ = 488
?dtor$22@?0???0BymlFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA PROC ; `BymlFile::BymlFile'::`1'::dtor$22
	lea	rcx, QWORD PTR RootNode$[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$22@?0???0BymlFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA ENDP ; `BymlFile::BymlFile'::`1'::dtor$22
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
$T2 = 64
$T3 = 64
$T4 = 72
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 112
$T9 = 112
$T10 = 144
$T11 = 144
$T12 = 176
this$GSCopy$ = 208
$T13 = 216
$T14 = 248
Bytes$GSCopy$ = 280
Reader$ = 288
RootNode$ = 304
__$ArrayPad$ = 400
this$ = 480
Bytes$ = 488
?dtor$15@?0???0BymlFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA PROC ; `BymlFile::BymlFile'::`1'::dtor$15
	lea	rcx, QWORD PTR RootNode$[rdx]
	jmp	??1Node@BymlFile@@QEAA@XZ
?dtor$15@?0???0BymlFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA ENDP ; `BymlFile::BymlFile'::`1'::dtor$15
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
;	COMDAT ?GetNodes@BymlFile@@QEAAAEAV?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@XZ
_TEXT	SEGMENT
this$ = 8
?GetNodes@BymlFile@@QEAAAEAV?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@XZ PROC ; BymlFile::GetNodes, COMDAT

; 223  :     return this->m_Nodes;

	mov	rax, rcx

; 224  : }

	ret	0
?GetNodes@BymlFile@@QEAAAEAV?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@XZ ENDP ; BymlFile::GetNodes
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
;	COMDAT ?AddStringTableEntry@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
String$GSCopy$ = 32
__$ArrayPad$ = 40
this$ = 64
String$ = 72
?AddStringTableEntry@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; BymlFile::AddStringTableEntry, COMDAT

; 250  : {

$LN20:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbx, rdx
	mov	rdi, rcx

; 249  : void BymlFile::AddStringTableEntry(std::string String)

	mov	QWORD PTR String$GSCopy$[rsp], rdx

; 251  :     this->m_StringTable.push_back(String);

	add	rcx, 48					; 00000030H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rax, QWORD PTR [rdi+56]
	cmp	rax, QWORD PTR [rdi+64]
	je	SHORT $LN7@AddStringT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, rax
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 806  :         ++_Mylast;

	add	QWORD PTR [rdi+56], 32			; 00000020H

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN6@AddStringT
$LN7@AddStringT:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	r8, rbx
	mov	rdx, rax
	call	??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
	npad	1
$LN6@AddStringT:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 252  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?AddStringTableEntry@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; BymlFile::AddStringTableEntry
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
String$GSCopy$ = 32
__$ArrayPad$ = 40
this$ = 64
String$ = 72
?dtor$0@?0??AddStringTableEntry@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `BymlFile::AddStringTableEntry'::`1'::dtor$0
	mov	rcx, QWORD PTR String$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??AddStringTableEntry@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `BymlFile::AddStringTableEntry'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\__msvc_chrono.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\__msvc_chrono.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
;	COMDAT ?ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@1@@Z
_TEXT	SEGMENT
$T2 = 48
$T3 = 48
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 56
<end>$L2$1$ = 64
__$ReturnUdt$GSCopy$ = 64
$T9 = 64
$T10 = 64
this$GSCopy$1$ = 72
$T11 = 72
$T12 = 72
__$ReturnUdt$GSCopy$1$ = 88
$T13 = 96
$T14 = 128
$T15 = 160
$T16 = 192
$T17 = 224
Writer$ = 312
$T18 = 344
String$19 = 344
StringOffsets$ = 376
HashKeyOffsets$ = 400
RootNode$ = 432
__$ArrayPad$ = 528
this$ = 608
__$ReturnUdt$ = 616
TableGeneration$ = 624
?ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@1@@Z PROC ; BymlFile::ToBinary, COMDAT

; 501  : {

$LN1167:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-288]
	sub	rsp, 544				; 00000220H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	movzx	edi, r8b
	mov	QWORD PTR __$ReturnUdt$GSCopy$1$[rsp], rdx
	mov	r15, rcx
	mov	QWORD PTR this$GSCopy$1$[rsp], rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rdx
	xor	r13d, r13d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\__msvc_chrono.hpp

; 643  :             return time_point(duration(_Xtime_get_ticks()));

	call	QWORD PTR __imp__Xtime_get_ticks
	mov	rcx, rax

; 441  :                 return static_cast<_To>(

	mov	rax, 3777893186295716171		; 346dc5d63886594bH
	imul	rcx
	mov	rbx, rdx
	sar	rbx, 11
	mov	rax, rbx
	shr	rax, 63					; 0000003fH
	add	rbx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 506  :     this->m_WriterLastOffset = 0;

	mov	QWORD PTR [r15+76], r13
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1159 :         if (_Oldsize == 0) {

	cmp	QWORD PTR [r15+104], r13
	je	SHORT $LN837@ToBinary
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 1490 :         _Node::_Free_non_head(_Getal(), _My_data._Myhead);

	mov	rdx, QWORD PTR [r15+96]
	call	??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> > >

; 1491 :         _My_data._Myhead->_Next = _My_data._Myhead;

	mov	rax, QWORD PTR [r15+96]
	mov	QWORD PTR [rax], rax

; 1492 :         _My_data._Myhead->_Prev = _My_data._Myhead;

	mov	rax, QWORD PTR [r15+96]
	mov	QWORD PTR [rax+8], rax

; 1493 :         _My_data._Mysize        = 0;

	mov	QWORD PTR [r15+104], r13

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rax, QWORD PTR [r15+96]
	mov	QWORD PTR $T4[rsp], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1176 :         _STD fill(_Vec._Mypair._Myval2._Myfirst, _Vec._Mypair._Myval2._Mylast, _Unchecked_end());

	lea	r8, QWORD PTR $T4[rsp]
	mov	rdx, QWORD PTR [r15+120]
	mov	rcx, QWORD PTR [r15+112]
	call	??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@std@@@std@@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> > > > >
$LN837@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 509  :     this->m_CachedNodes.clear();

	lea	rcx, QWORD PTR [r15+152]
	call	?clear@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<BymlFile::Node,unsigned int,std::_Uhash_compare<BymlFile::Node,BymlFile::NodeHasher,BymlFile::NodeEqual>,std::allocator<std::pair<BymlFile::Node const ,unsigned int> >,0> >::clear
	xorps	xmm0, xmm0
	movups	XMMWORD PTR Writer$[rbp-240], xmm0
	xorps	xmm1, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR Writer$[rbp-256], xmm1
	mov	QWORD PTR Writer$[rbp-240], r13
	mov	DWORD PTR Writer$[rbp-232], r13d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 46   : 		this->m_Data.resize(this->m_Data.size() + strlen(Bytes));

	mov	edx, 2
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	mov	r9d, r13d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 509  :     this->m_CachedNodes.clear();

	lea	r8, OFFSET FLAT:??_C@_02KBJMBOFF@YB@+1
	mov	eax, DWORD PTR Writer$[rbp-232]
	npad	1
$LL920@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8-1]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-232]
	inc	eax
	mov	DWORD PTR Writer$[rbp-232], eax

; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movzx	edx, BYTE PTR [r8]
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-232]
	inc	eax
	mov	DWORD PTR Writer$[rbp-232], eax

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	add	r9d, 2
	lea	r8, QWORD PTR [r8+2]
	cmp	r9d, 2
	jb	SHORT $LL920@ToBinary
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
	add	eax, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN907@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 2
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN907@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], 7

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-232]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], 7
	movzx	edx, BYTE PTR [r8+1]
	mov	eax, DWORD PTR Writer$[rbp-232]
	inc	eax
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 2
	mov	DWORD PTR Writer$[rbp-232], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
	add	eax, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN893@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN893@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], 16

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-232]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], 16
	mov	eax, DWORD PTR Writer$[rbp-232]
	inc	eax
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 2
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r8+3]
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	r8d, DWORD PTR Writer$[rbp-232]
	add	r8d, 4
	mov	DWORD PTR Writer$[rbp-232], r8d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
	lea	eax, DWORD PTR [r8+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 30   : 		if (this->m_Offset + Offset >= this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jb	SHORT $LN880@ToBinary

; 31   : 		{
; 32   : 			this->m_Data.resize(Offset + this->m_Offset + 1);

	lea	eax, DWORD PTR [r8+9]
	movsxd	rdx, eax
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	r8d, DWORD PTR Writer$[rbp-232]
$LN880@ToBinary:

; 34   : 		this->m_Offset += Offset;

	add	r8d, 8
	mov	DWORD PTR Writer$[rbp-232], r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 519  :     if (TableGeneration == BymlFile::TableGeneration::Auto)

	test	dil, dil
	jne	$LN3@ToBinary
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1766 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

	mov	rsi, QWORD PTR [r15+32]
	mov	rdi, QWORD PTR [r15+24]
	cmp	rdi, rsi
	je	SHORT $LN958@ToBinary
$LL964@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rdi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rdi, 32					; 00000020H
	cmp	rdi, rsi
	jne	SHORT $LL964@ToBinary
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1776 :         _Mylast = _Myfirst;

	mov	rax, QWORD PTR [r15+24]
	mov	QWORD PTR [r15+32], rax
$LN958@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 522  :         this->m_HashKeyTable.resize(0);

	xor	edx, edx
	lea	rcx, QWORD PTR [r15+24]
	call	?resize@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAX_K@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::resize
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1766 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

	mov	rsi, QWORD PTR [r15+56]
	mov	rdi, QWORD PTR [r15+48]
	cmp	rdi, rsi
	je	SHORT $LN940@ToBinary
	npad	7
$LL946@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rdi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rdi, 32					; 00000020H
	cmp	rdi, rsi
	jne	SHORT $LL946@ToBinary
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1776 :         _Mylast = _Myfirst;

	mov	rax, QWORD PTR [r15+48]
	mov	QWORD PTR [r15+56], rax
$LN940@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 525  :         this->m_StringTable.resize(0);

	xor	edx, edx
	lea	rcx, QWORD PTR [r15+48]
	call	?resize@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAX_K@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::resize

; 526  : 
; 527  :         for (BymlFile::Node& Node : this->m_Nodes)

	mov	rsi, QWORD PTR [r15+8]

; 525  :         this->m_StringTable.resize(0);

	mov	rdi, QWORD PTR [r15]

; 526  : 
; 527  :         for (BymlFile::Node& Node : this->m_Nodes)

	cmp	rdi, rsi
	je	SHORT $LN3@ToBinary
$LL4@ToBinary:

; 528  :         {
; 529  :             this->GenerateHashKeyTable(&Node);

	mov	rdx, rdi
	mov	rcx, r15
	call	?GenerateHashKeyTable@BymlFile@@QEAAXPEAVNode@1@@Z ; BymlFile::GenerateHashKeyTable

; 530  :             this->GenerateStringTable(&Node);

	mov	rdx, rdi
	mov	rcx, r15
	call	?GenerateStringTable@BymlFile@@QEAAXPEAVNode@1@@Z ; BymlFile::GenerateStringTable

; 526  : 
; 527  :         for (BymlFile::Node& Node : this->m_Nodes)

	add	rdi, 88					; 00000058H
	cmp	rdi, rsi
	jne	SHORT $LL4@ToBinary
$LN3@ToBinary:

; 531  :         }
; 532  :     }
; 533  :     this->m_HashKeyTable.shrink_to_fit();

	lea	rsi, QWORD PTR [r15+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1691 :         const pointer _Oldlast = _My_data._Mylast;

	mov	rdx, QWORD PTR [rsi+8]

; 1692 :         if (_Oldlast != _My_data._Myend) { // something to do

	cmp	rdx, QWORD PTR [rsi+16]
	je	SHORT $LN780@ToBinary

; 1693 :             const pointer _Oldfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR [rsi]

; 1694 :             if (_Oldfirst == _Oldlast) {

	mov	rcx, rsi
	cmp	rax, rdx
	jne	SHORT $LN779@ToBinary

; 1695 :                 _Tidy();

	call	?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy

; 1696 :             } else {

	jmp	SHORT $LN780@ToBinary
$LN779@ToBinary:

; 1697 :                 _Reallocate_exactly(static_cast<size_type>(_Oldlast - _Oldfirst));

	sub	rdx, rax
	sar	rdx, 5
	call	?_Reallocate_exactly@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAX_K@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reallocate_exactly
$LN780@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 534  :     this->m_StringTable.shrink_to_fit();

	lea	r14, QWORD PTR [r15+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1691 :         const pointer _Oldlast = _My_data._Mylast;

	mov	rdx, QWORD PTR [r14+8]

; 1692 :         if (_Oldlast != _My_data._Myend) { // something to do

	cmp	rdx, QWORD PTR [r14+16]
	je	SHORT $LN775@ToBinary

; 1693 :             const pointer _Oldfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR [r14]

; 1694 :             if (_Oldfirst == _Oldlast) {

	mov	rcx, r14
	cmp	rax, rdx
	jne	SHORT $LN774@ToBinary

; 1695 :                 _Tidy();

	call	?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy

; 1696 :             } else {

	jmp	SHORT $LN775@ToBinary
$LN774@ToBinary:

; 1697 :                 _Reallocate_exactly(static_cast<size_type>(_Oldlast - _Oldfirst));

	sub	rdx, rax
	sar	rdx, 5
	call	?_Reallocate_exactly@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAX_K@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reallocate_exactly
$LN775@ToBinary:

; 43   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	rdx, QWORD PTR [rsi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8065 :     const auto _UFirst = _Get_unwrapped(_First);

	mov	rcx, QWORD PTR [rsi]

; 8066 :     const auto _ULast  = _Get_unwrapped(_Last);
; 8067 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

	mov	r8, rdx
	sub	r8, rcx
	sar	r8, 5
	movzx	r9d, BYTE PTR $T3[rsp]
	call	??$_Sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0_JV<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ; std::_Sort_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 43   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	rdx, QWORD PTR [r14+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8065 :     const auto _UFirst = _Get_unwrapped(_First);

	mov	rcx, QWORD PTR [r14]

; 8066 :     const auto _ULast  = _Get_unwrapped(_Last);
; 8067 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

	mov	r8, rdx
	sub	r8, rcx
	sar	r8, 5
	movzx	r9d, BYTE PTR $T2[rsp]
	call	??$_Sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0_JV<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ; std::_Sort_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rbp-232]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 194			; 000000c2H

; 14   : 	this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-232]
	inc	eax
	mov	DWORD PTR Writer$[rbp-232], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdi, QWORD PTR [rsi+8]
	sub	rdi, QWORD PTR [rsi]
	sar	rdi, 5
	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
	add	eax, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN817@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 3
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN817@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], rdi

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-232]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dil
	mov	eax, DWORD PTR Writer$[rbp-232]
	inc	eax
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r8+2]
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 2
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	edx, DWORD PTR Writer$[rbp-232]
	add	edx, 3
	mov	DWORD PTR Writer$[rbp-232], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [rsi+8]
	sub	rax, QWORD PTR [rsi]
	sar	rax, 5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 540  :     Writer.Seek(this->m_HashKeyTable.size() * 4 + 4, BinaryVectorWriter::Position::Current);

	lea	edi, DWORD PTR [rax*4+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR Writer$[rbp-248]
	sub	rcx, QWORD PTR Writer$[rbp-256]
	lea	r8d, DWORD PTR [rdi+rdx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 30   : 		if (this->m_Offset + Offset >= this->m_Data.size())

	movsxd	rax, r8d
	cmp	rax, rcx
	jb	SHORT $LN788@ToBinary

; 31   : 		{
; 32   : 			this->m_Data.resize(Offset + this->m_Offset + 1);

	lea	eax, DWORD PTR [r8+1]
	movsxd	rdx, eax
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	edx, DWORD PTR Writer$[rbp-232]
$LN788@ToBinary:

; 34   : 		this->m_Offset += Offset;

	add	edx, edi
	mov	DWORD PTR Writer$[rbp-232], edx
	xorps	xmm1, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR HashKeyOffsets$[rbp-256], xmm1
	mov	rcx, r13
	mov	QWORD PTR HashKeyOffsets$[rbp-240], rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 544  :     for (std::string& HashKey : this->m_HashKeyTable)

	mov	r15, QWORD PTR [rsi+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 34   : 		this->m_Offset += Offset;

	mov	rsi, QWORD PTR [rsi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 544  :     for (std::string& HashKey : this->m_HashKeyTable)

	mov	r12, -1
	cmp	rsi, r15
	je	$LN6@ToBinary
$LL7@ToBinary:

; 545  :     {
; 546  :         HashKeyOffsets.push_back(Writer.GetPosition() - 16);

	lea	eax, DWORD PTR [rdx-16]
	mov	DWORD PTR $T8[rsp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR HashKeyOffsets$[rbp-248]
	cmp	rdx, rcx
	je	SHORT $LN704@ToBinary

; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [rdx], eax

; 798  :         } else {
; 799  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 800  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 801  :             _ASAN_VECTOR_RELEASE_GUARD;
; 802  :         }
; 803  : 
; 804  :         _Orphan_range(_Mylast, _Mylast);
; 805  :         _Ty& _Result = *_Mylast;
; 806  :         ++_Mylast;

	add	QWORD PTR HashKeyOffsets$[rbp-248], 4

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN703@ToBinary
$LN704@ToBinary:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T8[rsp]
	lea	rcx, QWORD PTR HashKeyOffsets$[rbp-256]
	call	??$_Emplace_reallocate@I@?$vector@IV?$allocator@I@std@@@std@@AEAAPEAIQEAI$$QEAI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Emplace_reallocate<unsigned int>
$LN703@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rdi, rsi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rsi+24], 16
	jb	SHORT $LN711@ToBinary

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdi, QWORD PTR [rsi]
$LN711@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r9, QWORD PTR Writer$[rbp-248]
	sub	r9, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 44   : 	if (this->m_Offset + strlen(Bytes) > this->m_Data.size())

	mov	rcx, r12
	npad	7
$LL1131@ToBinary:
	inc	rcx
	cmp	BYTE PTR [rdi+rcx], 0
	jne	SHORT $LL1131@ToBinary
	movsxd	r8, DWORD PTR Writer$[rbp-232]
	add	rcx, r8
	cmp	rcx, r9
	jbe	SHORT $LN685@ToBinary

; 46   : 		this->m_Data.resize(this->m_Data.size() + strlen(Bytes));

	mov	rdx, r12
	npad	8
$LL1130@ToBinary:
	inc	rdx
	cmp	BYTE PTR [rdi+rdx], 0
	jne	SHORT $LL1130@ToBinary
	add	rdx, r9
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	r8d, DWORD PTR Writer$[rbp-232]
$LN685@ToBinary:

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	mov	r9d, r13d
	mov	rax, r12
	npad	1
$LL1129@ToBinary:
	inc	rax
	cmp	BYTE PTR [rdi+rax], r9b
	jne	SHORT $LL1129@ToBinary
	test	rax, rax
	je	SHORT $LN1156@ToBinary
	mov	r10, rdi
$LL684@ToBinary:

; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movzx	edx, BYTE PTR [r10]
	movsxd	rcx, r8d
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl

; 51   : 		this->m_Offset++;

	mov	r8d, DWORD PTR Writer$[rbp-232]
	inc	r8d
	mov	DWORD PTR Writer$[rbp-232], r8d

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	inc	r9d
	lea	r10, QWORD PTR [r10+1]
	mov	rax, r12
$LL1128@ToBinary:
	inc	rax
	cmp	BYTE PTR [rdi+rax], 0
	jne	SHORT $LL1128@ToBinary
	movsxd	rcx, r9d
	cmp	rcx, rax
	jb	SHORT $LL684@ToBinary
$LN1156@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rcx, DWORD PTR Writer$[rbp-232]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], 0

; 14   : 	this->m_Offset++;

	mov	edx, DWORD PTR Writer$[rbp-232]
	inc	edx
	mov	DWORD PTR Writer$[rbp-232], edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 544  :     for (std::string& HashKey : this->m_HashKeyTable)

	add	rsi, 32					; 00000020H
	mov	rcx, QWORD PTR HashKeyOffsets$[rbp-240]
	cmp	rsi, r15
	jne	$LL7@ToBinary
$LN6@ToBinary:

; 547  :         Writer.WriteBytes(HashKey.c_str());
; 548  :         Writer.WriteByte(0xC00);
; 549  :     }
; 550  :     HashKeyOffsets.push_back(Writer.GetPosition() - 16);

	lea	eax, DWORD PTR [rdx-16]
	mov	DWORD PTR $T7[rsp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR HashKeyOffsets$[rbp-248]
	cmp	rdx, rcx
	je	SHORT $LN724@ToBinary

; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [rdx], eax

; 798  :         } else {
; 799  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 800  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 801  :             _ASAN_VECTOR_RELEASE_GUARD;
; 802  :         }
; 803  : 
; 804  :         _Orphan_range(_Mylast, _Mylast);
; 805  :         _Ty& _Result = *_Mylast;
; 806  :         ++_Mylast;

	add	QWORD PTR HashKeyOffsets$[rbp-248], 4

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN985@ToBinary
$LN724@ToBinary:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T7[rsp]
	lea	rcx, QWORD PTR HashKeyOffsets$[rbp-256]
	call	??$_Emplace_reallocate@I@?$vector@IV?$allocator@I@std@@@std@@AEAAPEAIQEAI$$QEAI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Emplace_reallocate<unsigned int>
$LN985@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 551  :     while (Writer.GetPosition() % 4 != 0) //Align

	mov	eax, DWORD PTR Writer$[rbp-232]
	and	eax, -2147483645			; ffffffff80000003H
	jge	SHORT $LN1127@ToBinary
	dec	eax
	or	eax, -4
	inc	eax
$LN1127@ToBinary:
	test	eax, eax
	je	SHORT $LN9@ToBinary
	npad	10
$LL8@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rcx, DWORD PTR Writer$[rbp-232]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], 0

; 14   : 	this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-232]
	inc	eax
	mov	DWORD PTR Writer$[rbp-232], eax
	and	eax, -2147483645			; ffffffff80000003H
	jge	SHORT $LN1126@ToBinary
	dec	eax
	or	eax, -4
	inc	eax
$LN1126@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 551  :     while (Writer.GetPosition() % 4 != 0) //Align

	test	eax, eax
	jne	SHORT $LL8@ToBinary
$LN9@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rbp-232]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 194			; 000000c2H

; 14   : 	this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-232]
	inc	eax
	mov	DWORD PTR Writer$[rbp-232], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdi, QWORD PTR [r14+8]
	sub	rdi, QWORD PTR [r14]
	sar	rdi, 5
	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
	add	eax, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN740@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 3
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN740@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], rdi

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-232]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dil
	mov	eax, DWORD PTR Writer$[rbp-232]
	inc	eax
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r8+2]
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 2
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	edx, DWORD PTR Writer$[rbp-232]
	add	edx, 3
	mov	DWORD PTR Writer$[rbp-232], edx
	movsxd	r13, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [r14+8]
	sub	rax, QWORD PTR [r14]
	sar	rax, 5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 560  :     Writer.Seek(this->m_StringTable.size() * 4 + 4, BinaryVectorWriter::Position::Current);

	lea	edi, DWORD PTR [rax*4+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR Writer$[rbp-248]
	sub	rcx, QWORD PTR Writer$[rbp-256]
	lea	r8d, DWORD PTR [rdi+r13]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 30   : 		if (this->m_Offset + Offset >= this->m_Data.size())

	movsxd	rax, r8d
	cmp	rax, rcx
	jb	SHORT $LN672@ToBinary

; 31   : 		{
; 32   : 			this->m_Data.resize(Offset + this->m_Offset + 1);

	lea	eax, DWORD PTR [r8+1]
	movsxd	rdx, eax
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	edx, DWORD PTR Writer$[rbp-232]
$LN672@ToBinary:

; 34   : 		this->m_Offset += Offset;

	add	edx, edi
	mov	DWORD PTR Writer$[rbp-232], edx
	xorps	xmm1, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR StringOffsets$[rbp-256], xmm1
	xor	ecx, ecx
	mov	QWORD PTR StringOffsets$[rbp-240], rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 562  :     for (std::string String : this->m_StringTable)

	mov	r12, QWORD PTR [r14]
	mov	rax, QWORD PTR [r14+8]
	mov	QWORD PTR <end>$L2$1$[rsp], rax
	mov	r8, 9223372036854775807			; 7fffffffffffffffH
	cmp	r12, rax
	je	$LN11@ToBinary
	lea	eax, QWORD PTR [rcx+22]
	npad	10
$LL12@ToBinary:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR String$19[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR String$19[rbp-240], rcx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR String$19[rbp-232], rcx

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rdi, QWORD PTR [r12+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r14, r12

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [r12+24], 16
	jb	SHORT $LN541@ToBinary

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r14, QWORD PTR [r12]
$LN541@ToBinary:

; 2620 :         if (_Count > max_size()) {

	cmp	rdi, r8
	ja	$LN1004@ToBinary

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	cmp	rdi, 16
	jae	SHORT $LN547@ToBinary

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR String$19[rbp-240], rdi

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	esi, 15
	mov	QWORD PTR String$19[rbp-232], rsi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR String$19[rbp-256], xmm0

; 2647 :             return;

	movq	r15, xmm0
	jmp	SHORT $LN563@ToBinary
$LN547@ToBinary:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rsi, rdi
	or	rsi, 15
	cmp	rsi, r8

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN558@ToBinary

; 4716 :             return _Max;

	mov	rsi, r8
	jmp	SHORT $LN557@ToBinary
$LN558@ToBinary:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rsi, 22
	cmovb	rsi, rax
$LN557@ToBinary:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rsi
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate
	mov	r15, rax

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR String$19[rbp-256], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR String$19[rbp-240], rdi

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR String$19[rbp-232], rsi

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rdi+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14
	mov	rcx, rax
	call	memcpy
	mov	edx, DWORD PTR Writer$[rbp-232]
$LN563@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 564  :         StringOffsets.push_back(Writer.GetPosition() - StringTableJumpback + 4); //-16 because it is a relative offset

	sub	edx, r13d
	add	edx, 4
	mov	DWORD PTR $T6[rsp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rax, QWORD PTR StringOffsets$[rbp-248]
	cmp	rax, QWORD PTR StringOffsets$[rbp-240]
	je	SHORT $LN526@ToBinary

; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [rax], edx

; 798  :         } else {
; 799  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 800  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 801  :             _ASAN_VECTOR_RELEASE_GUARD;
; 802  :         }
; 803  : 
; 804  :         _Orphan_range(_Mylast, _Mylast);
; 805  :         _Ty& _Result = *_Mylast;
; 806  :         ++_Mylast;

	add	QWORD PTR StringOffsets$[rbp-248], 4

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN525@ToBinary
$LN526@ToBinary:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T6[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR StringOffsets$[rbp-256]
	call	??$_Emplace_reallocate@I@?$vector@IV?$allocator@I@std@@@std@@AEAAPEAIQEAI$$QEAI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Emplace_reallocate<unsigned int>
$LN525@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rdi, QWORD PTR String$19[rbp-256]

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	rsi, 16
	setae	r14b

; 2236 :         if (_Large_string_engaged()) {

	cmovae	rdi, r15
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 44   : 	if (this->m_Offset + strlen(Bytes) > this->m_Data.size())

	mov	r11, -1
	mov	rcx, r11
	npad	8
$LL1125@ToBinary:
	inc	rcx
	cmp	BYTE PTR [rdi+rcx], 0
	jne	SHORT $LL1125@ToBinary
	movsxd	r8, DWORD PTR Writer$[rbp-232]
	lea	rax, QWORD PTR [rcx+r8]
	cmp	rax, rdx
	jbe	SHORT $LN651@ToBinary

; 46   : 		this->m_Data.resize(this->m_Data.size() + strlen(Bytes));

	add	rdx, rcx
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	r8d, DWORD PTR Writer$[rbp-232]
	mov	r11, -1
$LN651@ToBinary:

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	xor	r10d, r10d
	mov	rax, r11
$LL1124@ToBinary:
	inc	rax
	cmp	BYTE PTR [rdi+rax], r10b
	jne	SHORT $LL1124@ToBinary
	test	rax, rax
	je	SHORT $LN1158@ToBinary
	mov	r9, rdi
	npad	12
$LL650@ToBinary:

; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movzx	edx, BYTE PTR [r9]
	movsxd	rcx, r8d
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl

; 51   : 		this->m_Offset++;

	mov	r8d, DWORD PTR Writer$[rbp-232]
	inc	r8d
	mov	DWORD PTR Writer$[rbp-232], r8d

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	inc	r10d
	lea	r9, QWORD PTR [r9+1]
	mov	rcx, r11
$LL1123@ToBinary:
	inc	rcx
	cmp	BYTE PTR [rdi+rcx], 0
	jne	SHORT $LL1123@ToBinary
	movsxd	rax, r10d
	cmp	rax, rcx
	jb	SHORT $LL650@ToBinary
$LN1158@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rcx, DWORD PTR Writer$[rbp-232]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], 0

; 14   : 	this->m_Offset++;

	mov	edx, DWORD PTR Writer$[rbp-232]
	inc	edx
	mov	DWORD PTR Writer$[rbp-232], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	test	r14b, r14b
	je	SHORT $LN624@ToBinary

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	lea	rdx, QWORD PTR [rsi+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, r15

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN636@ToBinary

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r15, QWORD PTR [r15-8]
	sub	rax, r15

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN369@ToBinary
$LN636@ToBinary:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, r15
	call	??3@YAXPEAX_K@Z				; operator delete
	mov	edx, DWORD PTR Writer$[rbp-232]
$LN624@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 562  :     for (std::string String : this->m_StringTable)

	add	r12, 32					; 00000020H
	cmp	r12, QWORD PTR <end>$L2$1$[rsp]
	mov	ecx, 0
	lea	eax, QWORD PTR [rcx+22]
	mov	r8, 9223372036854775807			; 7fffffffffffffffH
	jne	$LL12@ToBinary
$LN11@ToBinary:

; 565  :         Writer.WriteBytes(String.c_str());
; 566  :         Writer.WriteByte(0x00);
; 567  :     }
; 568  :     StringOffsets.push_back(Writer.GetPosition() - StringTableJumpback + 4); //For the last string in the table

	sub	edx, r13d
	add	edx, 4
	mov	DWORD PTR $T5[rsp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rax, QWORD PTR StringOffsets$[rbp-248]
	cmp	rax, QWORD PTR StringOffsets$[rbp-240]
	je	SHORT $LN573@ToBinary

; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [rax], edx

; 798  :         } else {
; 799  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 800  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 801  :             _ASAN_VECTOR_RELEASE_GUARD;
; 802  :         }
; 803  : 
; 804  :         _Orphan_range(_Mylast, _Mylast);
; 805  :         _Ty& _Result = *_Mylast;
; 806  :         ++_Mylast;

	add	QWORD PTR StringOffsets$[rbp-248], 4

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN991@ToBinary
$LN573@ToBinary:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T5[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR StringOffsets$[rbp-256]
	call	??$_Emplace_reallocate@I@?$vector@IV?$allocator@I@std@@@std@@AEAAPEAIQEAI$$QEAI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Emplace_reallocate<unsigned int>
$LN991@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 569  :     while (Writer.GetPosition() % 4 != 0) //Align

	mov	esi, DWORD PTR Writer$[rbp-232]
	mov	eax, esi
	and	eax, -2147483645			; ffffffff80000003H
	jge	SHORT $LN1122@ToBinary
	dec	eax
	or	eax, -4
	inc	eax
$LN1122@ToBinary:
	test	eax, eax
	je	SHORT $LN14@ToBinary
	npad	12
$LL13@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rcx, DWORD PTR Writer$[rbp-232]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], 0

; 14   : 	this->m_Offset++;

	mov	esi, DWORD PTR Writer$[rbp-232]
	inc	esi
	mov	DWORD PTR Writer$[rbp-232], esi
	mov	eax, esi
	and	eax, -2147483645			; ffffffff80000003H
	jge	SHORT $LN1121@ToBinary
	dec	eax
	or	eax, -4
	inc	eax
$LN1121@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 569  :     while (Writer.GetPosition() % 4 != 0) //Align

	test	eax, eax
	jne	SHORT $LL13@ToBinary
$LN14@ToBinary:
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR RootNode$[rbp-256], xmm0
	movups	XMMWORD PTR RootNode$[rbp-240], xmm0
	movups	XMMWORD PTR RootNode$[rbp-224], xmm0
	movups	XMMWORD PTR RootNode$[rbp-208], xmm0
	movups	XMMWORD PTR RootNode$[rbp-192], xmm0
	mov	QWORD PTR RootNode$[rbp-176], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T13[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	r12d, r12d
	mov	QWORD PTR $T13[rsp+16], r12

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T13[rsp+24], r12

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rax+4]
	lea	rdx, OFFSET FLAT:??_C@_04NBFCGMPH@root@
	lea	rcx, QWORD PTR $T13[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 577  :     BymlFile::Node RootNode(this->m_Type, "root");

	lea	rax, QWORD PTR $T13[rsp]
	mov	QWORD PTR $T9[rsp], rax
	mov	r15, QWORD PTR this$GSCopy$1$[rsp]
	movzx	eax, BYTE PTR [r15+72]
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqa	XMMWORD PTR RootNode$[rbp-256], xmm0
	mov	QWORD PTR RootNode$[rbp-240], r12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 9    : BymlFile::Node::Node(BymlFile::Type Type, std::string Key) : m_Type(Type), m_Key(Key)

	mov	BYTE PTR RootNode$[rbp-232], al
	lea	rdx, QWORD PTR $T13[rsp]
	lea	rcx, QWORD PTR RootNode$[rbp-224]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqa	XMMWORD PTR RootNode$[rbp-192], xmm0
	mov	QWORD PTR RootNode$[rbp-176], r12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T13[rsp]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 578  :     for (BymlFile::Node& Node : this->m_Nodes)

	mov	rdi, QWORD PTR [r15]
	mov	r14, QWORD PTR [r15+8]
	cmp	rdi, r14
	je	SHORT $LN16@ToBinary

; 579  :     {
; 580  :         RootNode.AddChild(Node);

	lea	rax, QWORD PTR $T17[rbp-256]
	mov	QWORD PTR $T11[rsp], rax
	npad	15
$LL17@ToBinary:
	lea	rax, QWORD PTR $T17[rbp-256]
	mov	QWORD PTR $T10[rsp], rax
	mov	rdx, rdi
	lea	rcx, QWORD PTR $T17[rbp-256]
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	npad	1
	movzx	eax, BYTE PTR [rdi+24]
	mov	BYTE PTR $T17[rbp-232], al
	lea	rdx, QWORD PTR [rdi+32]
	lea	rcx, QWORD PTR $T17[rbp-224]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rdx, QWORD PTR [rdi+64]
	lea	rcx, QWORD PTR $T17[rbp-192]
	call	??0?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@AEBV01@@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::vector<BymlFile::Node,std::allocator<BymlFile::Node> >
	npad	1

; 44   :     this->m_Children.push_back(Node);

	lea	rdx, QWORD PTR $T17[rbp-256]
	lea	rcx, QWORD PTR RootNode$[rbp-192]
	call	?push_back@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAXAEBVNode@BymlFile@@@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::push_back
	npad	1

; 45   : }

	lea	rcx, QWORD PTR $T17[rbp-256]
	call	??1Node@BymlFile@@QEAA@XZ

; 578  :     for (BymlFile::Node& Node : this->m_Nodes)

	add	rdi, 88					; 00000058H
	cmp	rdi, r14
	jne	SHORT $LL17@ToBinary
$LN16@ToBinary:

; 581  :     }
; 582  :     this->WriteNode(Writer, DataOffset, 12, RootNode);

	lea	rax, QWORD PTR RootNode$[rbp-256]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, 12
	mov	r8d, esi
	lea	rdx, QWORD PTR Writer$[rbp-256]
	mov	rcx, r15
	call	?WriteNode@BymlFile@@AEAAXAEAVBinaryVectorWriter@@IIAEAVNode@1@@Z ; BymlFile::WriteNode
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	mov	rax, rdx
	mov	rcx, QWORD PTR Writer$[rbp-256]
	sub	rax, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 22   : 		if (Offset > this->m_Data.size())

	cmp	rax, 8
	jae	SHORT $LN497@ToBinary

; 23   : 		{
; 24   : 			this->m_Data.resize(Offset + 1);

	mov	edx, 9
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	rdx, QWORD PTR Writer$[rbp-248]
	mov	rcx, QWORD PTR Writer$[rbp-256]
$LN497@ToBinary:

; 25   : 		}
; 26   : 		this->m_Offset = Offset;

	mov	DWORD PTR Writer$[rbp-232], 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rdx, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	cmp	rdx, 12
	jae	SHORT $LN484@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN484@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 585  :     Writer.WriteInteger(StringTableJumpback - 4, sizeof(uint32_t));

	lea	edx, DWORD PTR [r13-4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], rdx

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-232]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl
	mov	eax, DWORD PTR Writer$[rbp-232]
	inc	eax
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 2
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r8+3]
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	add	DWORD PTR Writer$[rbp-232], 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR Writer$[rbp-248]
	sub	rax, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 22   : 		if (Offset > this->m_Data.size())

	cmp	rax, 20
	jae	SHORT $LN468@ToBinary

; 23   : 		{
; 24   : 			this->m_Data.resize(Offset + 1);

	mov	edx, 21
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN468@ToBinary:

; 25   : 		}
; 26   : 		this->m_Offset = Offset;

	mov	eax, 20
	mov	DWORD PTR Writer$[rbp-232], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 588  :     for (uint32_t HashKeyOffset : HashKeyOffsets)

	mov	rdi, QWORD PTR HashKeyOffsets$[rbp-256]
	mov	r14, QWORD PTR HashKeyOffsets$[rbp-248]
	cmp	rdi, r14
	je	$LN1160@ToBinary
	npad	8
$LL20@ToBinary:
	mov	esi, DWORD PTR [rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	add	eax, 4
	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN449@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN449@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	rdx, rsi
	mov	QWORD PTR [rax], rdx

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-232]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl
	mov	eax, DWORD PTR Writer$[rbp-232]
	inc	eax
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 2
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r8+3]
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 4
	mov	DWORD PTR Writer$[rbp-232], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 588  :     for (uint32_t HashKeyOffset : HashKeyOffsets)

	add	rdi, 4
	cmp	rdi, r14
	jne	$LL20@ToBinary
$LN1160@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR Writer$[rbp-248]
	sub	rcx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 22   : 		if (Offset > this->m_Data.size())

	cmp	r13, rcx
	jbe	SHORT $LN433@ToBinary

; 23   : 		{
; 24   : 			this->m_Data.resize(Offset + 1);

	lea	eax, DWORD PTR [r13+1]
	movsxd	rdx, eax
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN433@ToBinary:

; 25   : 		}
; 26   : 		this->m_Offset = Offset;

	mov	DWORD PTR Writer$[rbp-232], r13d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 594  :     for (uint32_t StringOffset : StringOffsets)

	mov	rdi, QWORD PTR StringOffsets$[rbp-256]
	mov	r14, QWORD PTR StringOffsets$[rbp-248]
	cmp	rdi, r14
	je	$LN1161@ToBinary
$LL23@ToBinary:
	mov	esi, DWORD PTR [rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	lea	eax, DWORD PTR [r13+4]
	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN109@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN109@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	rdx, rsi
	mov	QWORD PTR [rax], rdx

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-232]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl
	mov	eax, DWORD PTR Writer$[rbp-232]
	inc	eax
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 2
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r8+3]
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	r13d, DWORD PTR Writer$[rbp-232]
	add	r13d, 4
	mov	DWORD PTR Writer$[rbp-232], r13d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 594  :     for (uint32_t StringOffset : StringOffsets)

	add	rdi, 4
	cmp	rdi, r14
	jne	$LL23@ToBinary
$LN1161@ToBinary:

; 602  :     Logger::Info("BymlEncoder", "Encoded BYML data, took " + std::to_string((duration_cast<std::chrono::milliseconds>(

	lea	rcx, QWORD PTR $T14[rbp-256]
	mov	QWORD PTR $T12[rsp], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\__msvc_chrono.hpp

; 643  :             return time_point(duration(_Xtime_get_ticks()));

	call	QWORD PTR __imp__Xtime_get_ticks
	mov	rcx, rax

; 441  :                 return static_cast<_To>(

	mov	rax, 3777893186295716171		; 346dc5d63886594bH
	imul	rcx
	sar	rdx, 11
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax

; 292  :         return _CD(_CD(_Left).count() - _CD(_Right).count());

	sub	rdx, rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 602  :     Logger::Info("BymlEncoder", "Encoded BYML data, took " + std::to_string((duration_cast<std::chrono::milliseconds>(

	lea	rcx, QWORD PTR $T16[rbp-256]
	call	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_J@Z ; std::to_string
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3537 :         return insert(_Off, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r9d, 24
	lea	r8, OFFSET FLAT:??_C@_0BJ@CILBIDFB@Encoded?5BYML?5data?0?5took?5@
	mov	rcx, rax
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T18[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T18[rbp-240], r12

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T18[rbp-232], r12

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T18[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T18[rbp-240], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rax+16], r12

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rax+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rax], 0

; 3270 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rdx, QWORD PTR $T18[rbp-240]
	mov	r8, QWORD PTR $T18[rbp-232]
	mov	rax, r8
	sub	rax, rdx

; 3271 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	lea	rcx, QWORD PTR $T18[rbp-256]
	cmp	rax, 2
	jb	SHORT $LN171@ToBinary

; 3272 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 3273 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	rax, QWORD PTR [rdx+2]
	mov	QWORD PTR $T18[rbp-240], rax

; 2227 :         if (_Large_string_engaged()) {

	cmp	r8, 16
	cmovae	rcx, QWORD PTR $T18[rbp-256]

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	movzx	eax, WORD PTR ??_C@_02EEKDFEKL@ms@
	mov	WORD PTR [rcx+rdx], ax

; 3276 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [rcx+rdx+2], 0

; 3277 :             return *this;

	lea	rax, QWORD PTR $T18[rbp-256]
	jmp	SHORT $LN170@ToBinary
$LN171@ToBinary:

; 3278 :         }
; 3279 : 
; 3280 :         return _Reallocate_grow_by(

	mov	QWORD PTR [rsp+32], 2
	lea	r9, OFFSET FLAT:??_C@_02EEKDFEKL@ms@
	mov	edx, 2
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned __int64>
$LN170@ToBinary:
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T14[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T14[rbp-240], r12

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T14[rbp-232], r12

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T14[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T14[rbp-240], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rax+16], r12

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rax+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rax], 0
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T15[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T15[rbp-240], r12

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T15[rbp-232], r12

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 11
	lea	rdx, OFFSET FLAT:??_C@_0M@ILPEJFEL@BymlEncoder@
	lea	rcx, QWORD PTR $T15[rbp-256]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 602  :     Logger::Info("BymlEncoder", "Encoded BYML data, took " + std::to_string((duration_cast<std::chrono::milliseconds>(

	lea	rdx, QWORD PTR $T14[rbp-256]
	lea	rcx, QWORD PTR $T15[rbp-256]
	call	?Info@Logger@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; Logger::Info
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T18[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN264@ToBinary

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T18[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN276@ToBinary

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN276@ToBinary
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN276@ToBinary:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN264@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T18[rbp-240], r12

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T18[rbp-232], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T18[rbp-256], 0

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T16[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN235@ToBinary

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T16[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN247@ToBinary

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN247@ToBinary
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN247@ToBinary:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN235@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	r14, QWORD PTR __$ReturnUdt$GSCopy$1$[rsp]
	mov	QWORD PTR [r14], r12
	mov	QWORD PTR [r14+8], r12
	mov	QWORD PTR [r14+16], r12

; 685  :         const auto _Count       = static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst);

	mov	rbx, QWORD PTR Writer$[rbp-248]
	sub	rbx, QWORD PTR Writer$[rbp-256]

; 2065 :         if (_Count != 0) {

	je	$LN340@ToBinary

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	rbx, rax
	ja	$LN1164@ToBinary
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rbx, 4096				; 00001000H
	jb	SHORT $LN300@ToBinary

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rbx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rbx
	jbe	$LN1165@ToBinary

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN309@ToBinary

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rsi, QWORD PTR [rax+39]
	and	rsi, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rsi-8], rax

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN298@ToBinary
$LN309@ToBinary:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN300@ToBinary:

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new
	mov	rsi, rax
$LN298@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [r14], rsi

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [r14+8], rsi

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [rsi+rbx]
	mov	QWORD PTR [r14+16], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1825 :     auto _UFirst = _RANGES _Unwrap_iter<_Se>(_STD move(_First));

	mov	rbx, QWORD PTR Writer$[rbp-256]

; 1826 :     auto _ULast  = _RANGES _Unwrap_sent<_InIt>(_STD move(_Last));

	mov	rdi, QWORD PTR Writer$[rbp-248]
	mov	r8, rdi
	sub	r8, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rbx
	mov	rcx, rsi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1850 :             return _Dest;

	sub	rdi, rbx

; 1827 : #else // ^^^ __cpp_lib_concepts / !__cpp_lib_concepts vvv
; 1828 :     // In pre-concepts world, _Uninitialized_copy should only ever be called with an iterator
; 1829 :     // and sentinel of the same type, so `_Get_unwrapped` is fine to call.
; 1830 :     auto _UFirst = _Get_unwrapped(_STD move(_First));
; 1831 :     auto _ULast  = _Get_unwrapped(_STD move(_Last));
; 1832 : #endif // ^^^ !__cpp_lib_concepts ^^^
; 1833 : 
; 1834 :     constexpr bool _Can_memmove = _Sent_copy_cat<decltype(_UFirst), decltype(_ULast), _Ptrval>::_Bitcopy_constructible
; 1835 :                                && _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>::value;
; 1836 : 
; 1837 :     if constexpr (_Can_memmove) {
; 1838 : #if _HAS_CXX20
; 1839 :         if (!_STD is_constant_evaluated())
; 1840 : #endif // _HAS_CXX20
; 1841 :         {
; 1842 :             if constexpr (is_same_v<decltype(_UFirst), decltype(_ULast)>) {
; 1843 :                 _Copy_memmove(_To_address(_UFirst), _To_address(_ULast), _Unfancy(_Dest));
; 1844 :                 _Dest += _ULast - _UFirst;

	add	rdi, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	QWORD PTR [r14+8], rdi
$LN340@ToBinary:

; 767  :         _Tidy();

	lea	rcx, QWORD PTR RootNode$[rbp-192]
	call	?_Tidy@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAXXZ ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR RootNode$[rbp-224]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR RootNode$[rbp-256]
	test	rcx, rcx
	je	SHORT $LN354@ToBinary

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR RootNode$[rbp-240]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN372@ToBinary

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN372@ToBinary
$LN369@ToBinary:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN372@ToBinary:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	movdqa	XMMWORD PTR RootNode$[rbp-256], xmm0

; 2050 :             _Mylast  = nullptr;
; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR RootNode$[rbp-240], r12
$LN354@ToBinary:

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR StringOffsets$[rbp-256]
	test	rcx, rcx
	je	SHORT $LN381@ToBinary

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR StringOffsets$[rbp-240]
	sub	rax, rcx
	sar	rax, 2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax*4]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN399@ToBinary

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN399@ToBinary
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN399@ToBinary:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR StringOffsets$[rbp-256], xmm0

; 2050 :             _Mylast  = nullptr;
; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR StringOffsets$[rbp-240], r12
$LN381@ToBinary:

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR HashKeyOffsets$[rbp-256]
	test	rcx, rcx
	je	SHORT $LN407@ToBinary

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR HashKeyOffsets$[rbp-240]
	sub	rax, rcx
	sar	rax, 2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax*4]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN425@ToBinary

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN425@ToBinary
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN425@ToBinary:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR HashKeyOffsets$[rbp-256], xmm0

; 2050 :             _Mylast  = nullptr;
; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR HashKeyOffsets$[rbp-240], r12
$LN407@ToBinary:

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR Writer$[rbp-256]
	test	rcx, rcx
	je	SHORT $LN125@ToBinary

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR Writer$[rbp-240]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN143@ToBinary

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN143@ToBinary
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN143@ToBinary:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN125@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 606  :     return Writer.GetData();

	mov	rax, r14

; 607  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+624]
	add	rsp, 544				; 00000220H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN1165@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN1004@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1164@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
	int	3
$LN1162@ToBinary:
?ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@1@@Z ENDP ; BymlFile::ToBinary
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 48
$T3 = 48
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 56
<end>$L2$1$ = 64
__$ReturnUdt$GSCopy$ = 64
$T9 = 64
$T10 = 64
this$GSCopy$1$ = 72
$T11 = 72
$T12 = 72
__$ReturnUdt$GSCopy$1$ = 88
$T13 = 96
$T14 = 128
$T15 = 160
$T16 = 192
$T17 = 224
Writer$ = 312
$T18 = 344
String$19 = 344
StringOffsets$ = 376
HashKeyOffsets$ = 400
RootNode$ = 432
__$ArrayPad$ = 528
this$ = 608
__$ReturnUdt$ = 616
TableGeneration$ = 624
?dtor$0@?0??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@1@@Z@4HA PROC ; `BymlFile::ToBinary'::`1'::dtor$0
	lea	rcx, QWORD PTR Writer$[rdx]
	jmp	??1BinaryVectorWriter@@QEAA@XZ
?dtor$0@?0??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@1@@Z@4HA ENDP ; `BymlFile::ToBinary'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 48
$T3 = 48
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 56
<end>$L2$1$ = 64
__$ReturnUdt$GSCopy$ = 64
$T9 = 64
$T10 = 64
this$GSCopy$1$ = 72
$T11 = 72
$T12 = 72
__$ReturnUdt$GSCopy$1$ = 88
$T13 = 96
$T14 = 128
$T15 = 160
$T16 = 192
$T17 = 224
Writer$ = 312
$T18 = 344
String$19 = 344
StringOffsets$ = 376
HashKeyOffsets$ = 400
RootNode$ = 432
__$ArrayPad$ = 528
this$ = 608
__$ReturnUdt$ = 616
TableGeneration$ = 624
?dtor$1@?0??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@1@@Z@4HA PROC ; `BymlFile::ToBinary'::`1'::dtor$1
	lea	rcx, QWORD PTR HashKeyOffsets$[rdx]
	jmp	??1?$vector@IV?$allocator@I@std@@@std@@QEAA@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
?dtor$1@?0??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@1@@Z@4HA ENDP ; `BymlFile::ToBinary'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 48
$T3 = 48
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 56
<end>$L2$1$ = 64
__$ReturnUdt$GSCopy$ = 64
$T9 = 64
$T10 = 64
this$GSCopy$1$ = 72
$T11 = 72
$T12 = 72
__$ReturnUdt$GSCopy$1$ = 88
$T13 = 96
$T14 = 128
$T15 = 160
$T16 = 192
$T17 = 224
Writer$ = 312
$T18 = 344
String$19 = 344
StringOffsets$ = 376
HashKeyOffsets$ = 400
RootNode$ = 432
__$ArrayPad$ = 528
this$ = 608
__$ReturnUdt$ = 616
TableGeneration$ = 624
?dtor$2@?0??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@1@@Z@4HA PROC ; `BymlFile::ToBinary'::`1'::dtor$2
	lea	rcx, QWORD PTR StringOffsets$[rdx]
	jmp	??1?$vector@IV?$allocator@I@std@@@std@@QEAA@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
?dtor$2@?0??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@1@@Z@4HA ENDP ; `BymlFile::ToBinary'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 48
$T3 = 48
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 56
<end>$L2$1$ = 64
__$ReturnUdt$GSCopy$ = 64
$T9 = 64
$T10 = 64
this$GSCopy$1$ = 72
$T11 = 72
$T12 = 72
__$ReturnUdt$GSCopy$1$ = 88
$T13 = 96
$T14 = 128
$T15 = 160
$T16 = 192
$T17 = 224
Writer$ = 312
$T18 = 344
String$19 = 344
StringOffsets$ = 376
HashKeyOffsets$ = 400
RootNode$ = 432
__$ArrayPad$ = 528
this$ = 608
__$ReturnUdt$ = 616
TableGeneration$ = 624
?dtor$3@?0??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@1@@Z@4HA PROC ; `BymlFile::ToBinary'::`1'::dtor$3
	lea	rcx, QWORD PTR String$19[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@1@@Z@4HA ENDP ; `BymlFile::ToBinary'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 48
$T3 = 48
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 56
<end>$L2$1$ = 64
__$ReturnUdt$GSCopy$ = 64
$T9 = 64
$T10 = 64
this$GSCopy$1$ = 72
$T11 = 72
$T12 = 72
__$ReturnUdt$GSCopy$1$ = 88
$T13 = 96
$T14 = 128
$T15 = 160
$T16 = 192
$T17 = 224
Writer$ = 312
$T18 = 344
String$19 = 344
StringOffsets$ = 376
HashKeyOffsets$ = 400
RootNode$ = 432
__$ArrayPad$ = 528
this$ = 608
__$ReturnUdt$ = 616
TableGeneration$ = 624
?dtor$34@?0??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@1@@Z@4HA PROC ; `BymlFile::ToBinary'::`1'::dtor$34
	mov	rcx, QWORD PTR $T9[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$34@?0??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@1@@Z@4HA ENDP ; `BymlFile::ToBinary'::`1'::dtor$34
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 48
$T3 = 48
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 56
<end>$L2$1$ = 64
__$ReturnUdt$GSCopy$ = 64
$T9 = 64
$T10 = 64
this$GSCopy$1$ = 72
$T11 = 72
$T12 = 72
__$ReturnUdt$GSCopy$1$ = 88
$T13 = 96
$T14 = 128
$T15 = 160
$T16 = 192
$T17 = 224
Writer$ = 312
$T18 = 344
String$19 = 344
StringOffsets$ = 376
HashKeyOffsets$ = 400
RootNode$ = 432
__$ArrayPad$ = 528
this$ = 608
__$ReturnUdt$ = 616
TableGeneration$ = 624
?dtor$35@?0??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@1@@Z@4HA PROC ; `BymlFile::ToBinary'::`1'::dtor$35
	lea	rcx, QWORD PTR RootNode$[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$35@?0??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@1@@Z@4HA ENDP ; `BymlFile::ToBinary'::`1'::dtor$35
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 48
$T3 = 48
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 56
<end>$L2$1$ = 64
__$ReturnUdt$GSCopy$ = 64
$T9 = 64
$T10 = 64
this$GSCopy$1$ = 72
$T11 = 72
$T12 = 72
__$ReturnUdt$GSCopy$1$ = 88
$T13 = 96
$T14 = 128
$T15 = 160
$T16 = 192
$T17 = 224
Writer$ = 312
$T18 = 344
String$19 = 344
StringOffsets$ = 376
HashKeyOffsets$ = 400
RootNode$ = 432
__$ArrayPad$ = 528
this$ = 608
__$ReturnUdt$ = 616
TableGeneration$ = 624
?dtor$5@?0??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@1@@Z@4HA PROC ; `BymlFile::ToBinary'::`1'::dtor$5
	lea	rcx, QWORD PTR RootNode$[rdx]
	jmp	??1Node@BymlFile@@QEAA@XZ
?dtor$5@?0??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@1@@Z@4HA ENDP ; `BymlFile::ToBinary'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 48
$T3 = 48
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 56
<end>$L2$1$ = 64
__$ReturnUdt$GSCopy$ = 64
$T9 = 64
$T10 = 64
this$GSCopy$1$ = 72
$T11 = 72
$T12 = 72
__$ReturnUdt$GSCopy$1$ = 88
$T13 = 96
$T14 = 128
$T15 = 160
$T16 = 192
$T17 = 224
Writer$ = 312
$T18 = 344
String$19 = 344
StringOffsets$ = 376
HashKeyOffsets$ = 400
RootNode$ = 432
__$ArrayPad$ = 528
this$ = 608
__$ReturnUdt$ = 616
TableGeneration$ = 624
?dtor$29@?0??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@1@@Z@4HA PROC ; `BymlFile::ToBinary'::`1'::dtor$29
	mov	rcx, QWORD PTR $T10[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$29@?0??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@1@@Z@4HA ENDP ; `BymlFile::ToBinary'::`1'::dtor$29
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 48
$T3 = 48
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 56
<end>$L2$1$ = 64
__$ReturnUdt$GSCopy$ = 64
$T9 = 64
$T10 = 64
this$GSCopy$1$ = 72
$T11 = 72
$T12 = 72
__$ReturnUdt$GSCopy$1$ = 88
$T13 = 96
$T14 = 128
$T15 = 160
$T16 = 192
$T17 = 224
Writer$ = 312
$T18 = 344
String$19 = 344
StringOffsets$ = 376
HashKeyOffsets$ = 400
RootNode$ = 432
__$ArrayPad$ = 528
this$ = 608
__$ReturnUdt$ = 616
TableGeneration$ = 624
?dtor$30@?0??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@1@@Z@4HA PROC ; `BymlFile::ToBinary'::`1'::dtor$30
	mov	rcx, QWORD PTR $T10[rdx]
	add	rcx, 32					; 00000020H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$30@?0??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@1@@Z@4HA ENDP ; `BymlFile::ToBinary'::`1'::dtor$30
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 48
$T3 = 48
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 56
<end>$L2$1$ = 64
__$ReturnUdt$GSCopy$ = 64
$T9 = 64
$T10 = 64
this$GSCopy$1$ = 72
$T11 = 72
$T12 = 72
__$ReturnUdt$GSCopy$1$ = 88
$T13 = 96
$T14 = 128
$T15 = 160
$T16 = 192
$T17 = 224
Writer$ = 312
$T18 = 344
String$19 = 344
StringOffsets$ = 376
HashKeyOffsets$ = 400
RootNode$ = 432
__$ArrayPad$ = 528
this$ = 608
__$ReturnUdt$ = 616
TableGeneration$ = 624
?dtor$28@?0??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@1@@Z@4HA PROC ; `BymlFile::ToBinary'::`1'::dtor$28
	mov	rcx, QWORD PTR $T11[rdx]
	jmp	??1Node@BymlFile@@QEAA@XZ
?dtor$28@?0??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@1@@Z@4HA ENDP ; `BymlFile::ToBinary'::`1'::dtor$28
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 48
$T3 = 48
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 56
<end>$L2$1$ = 64
__$ReturnUdt$GSCopy$ = 64
$T9 = 64
$T10 = 64
this$GSCopy$1$ = 72
$T11 = 72
$T12 = 72
__$ReturnUdt$GSCopy$1$ = 88
$T13 = 96
$T14 = 128
$T15 = 160
$T16 = 192
$T17 = 224
Writer$ = 312
$T18 = 344
String$19 = 344
StringOffsets$ = 376
HashKeyOffsets$ = 400
RootNode$ = 432
__$ArrayPad$ = 528
this$ = 608
__$ReturnUdt$ = 616
TableGeneration$ = 624
?dtor$7@?0??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@1@@Z@4HA PROC ; `BymlFile::ToBinary'::`1'::dtor$7
	lea	rcx, QWORD PTR $T16[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$7@?0??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@1@@Z@4HA ENDP ; `BymlFile::ToBinary'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 48
$T3 = 48
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 56
<end>$L2$1$ = 64
__$ReturnUdt$GSCopy$ = 64
$T9 = 64
$T10 = 64
this$GSCopy$1$ = 72
$T11 = 72
$T12 = 72
__$ReturnUdt$GSCopy$1$ = 88
$T13 = 96
$T14 = 128
$T15 = 160
$T16 = 192
$T17 = 224
Writer$ = 312
$T18 = 344
String$19 = 344
StringOffsets$ = 376
HashKeyOffsets$ = 400
RootNode$ = 432
__$ArrayPad$ = 528
this$ = 608
__$ReturnUdt$ = 616
TableGeneration$ = 624
?dtor$8@?0??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@1@@Z@4HA PROC ; `BymlFile::ToBinary'::`1'::dtor$8
	lea	rcx, QWORD PTR $T18[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$8@?0??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@1@@Z@4HA ENDP ; `BymlFile::ToBinary'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 48
$T3 = 48
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 56
<end>$L2$1$ = 64
__$ReturnUdt$GSCopy$ = 64
$T9 = 64
$T10 = 64
this$GSCopy$1$ = 72
$T11 = 72
$T12 = 72
__$ReturnUdt$GSCopy$1$ = 88
$T13 = 96
$T14 = 128
$T15 = 160
$T16 = 192
$T17 = 224
Writer$ = 312
$T18 = 344
String$19 = 344
StringOffsets$ = 376
HashKeyOffsets$ = 400
RootNode$ = 432
__$ArrayPad$ = 528
this$ = 608
__$ReturnUdt$ = 616
TableGeneration$ = 624
?dtor$9@?0??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@1@@Z@4HA PROC ; `BymlFile::ToBinary'::`1'::dtor$9
	mov	rcx, QWORD PTR $T12[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$9@?0??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@1@@Z@4HA ENDP ; `BymlFile::ToBinary'::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
;	COMDAT ??0Node@BymlFile@@QEAA@W4Type@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
this$GSCopy$ = 32
Key$GSCopy$ = 40
__$ArrayPad$ = 48
this$ = 80
Type$ = 88
Key$ = 96
??0Node@BymlFile@@QEAA@W4Type@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; BymlFile::Node::Node, COMDAT

; 10   : {

$LN24:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, r8
	mov	rbx, rcx

; 9    : BymlFile::Node::Node(BymlFile::Type Type, std::string Key) : m_Type(Type), m_Key(Key)

	mov	QWORD PTR this$GSCopy$[rsp], rcx
	mov	QWORD PTR Key$GSCopy$[rsp], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	esi, esi
	mov	QWORD PTR [rcx], rsi
	mov	QWORD PTR [rcx+8], rsi
	mov	QWORD PTR [rcx+16], rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 9    : BymlFile::Node::Node(BymlFile::Type Type, std::string Key) : m_Type(Type), m_Key(Key)

	mov	BYTE PTR [rcx+24], dl
	add	rcx, 32					; 00000020H
	mov	rdx, r8
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rbx+64], rsi
	mov	QWORD PTR [rbx+72], rsi
	mov	QWORD PTR [rbx+80], rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rdi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 11   : }

	mov	rax, rbx
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+104]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
??0Node@BymlFile@@QEAA@W4Type@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; BymlFile::Node::Node
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$GSCopy$ = 32
Key$GSCopy$ = 40
__$ArrayPad$ = 48
this$ = 80
Type$ = 88
Key$ = 96
?dtor$0@?0???0Node@BymlFile@@QEAA@W4Type@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `BymlFile::Node::Node'::`1'::dtor$0
	mov	rcx, QWORD PTR Key$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???0Node@BymlFile@@QEAA@W4Type@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `BymlFile::Node::Node'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$GSCopy$ = 32
Key$GSCopy$ = 40
__$ArrayPad$ = 48
this$ = 80
Type$ = 88
Key$ = 96
?dtor$1@?0???0Node@BymlFile@@QEAA@W4Type@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `BymlFile::Node::Node'::`1'::dtor$1
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$1@?0???0Node@BymlFile@@QEAA@W4Type@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `BymlFile::Node::Node'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
;	COMDAT ?GetType@Node@BymlFile@@QEAAAEAW4Type@2@XZ
_TEXT	SEGMENT
this$ = 8
?GetType@Node@BymlFile@@QEAAAEAW4Type@2@XZ PROC		; BymlFile::Node::GetType, COMDAT

; 15   :     return this->m_Type;

	lea	rax, QWORD PTR [rcx+24]

; 16   : }

	ret	0
?GetType@Node@BymlFile@@QEAAAEAW4Type@2@XZ ENDP		; BymlFile::Node::GetType
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
;	COMDAT ?GetKey@Node@BymlFile@@QEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
this$ = 8
?GetKey@Node@BymlFile@@QEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; BymlFile::Node::GetKey, COMDAT

; 20   :     return this->m_Key;

	lea	rax, QWORD PTR [rcx+32]

; 21   : }

	ret	0
?GetKey@Node@BymlFile@@QEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; BymlFile::Node::GetKey
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
;	COMDAT ??$SetValue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Node@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
Value$GSCopy$ = 32
__$ArrayPad$ = 40
this$ = 64
Value$ = 72
??$SetValue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Node@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; BymlFile::Node::SetValue<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 24   : {

$LN21:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbx, rdx
	mov	rdi, rcx

; 23   : template<> void BymlFile::Node::SetValue(std::string Value) //Value is a string

	mov	QWORD PTR Value$GSCopy$[rsp], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1766 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

	mov	rax, QWORD PTR [rcx]
	cmp	rax, QWORD PTR [rcx+8]
	je	SHORT $LN4@SetValue

; 1767 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1768 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1769 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1770 :             return;
; 1771 :         }
; 1772 : 
; 1773 :         _My_data._Orphan_all();
; 1774 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1775 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1776 :         _Mylast = _Myfirst;

	mov	QWORD PTR [rcx+8], rax
$LN4@SetValue:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 26   :     this->m_Value.resize(Value.length());

	mov	rdx, QWORD PTR [rdx+16]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	rdx, rbx

; 2227 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rbx+24], 16
	jb	SHORT $LN12@SetValue

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rbx]
$LN12@SetValue:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 27   :     memcpy(this->m_Value.data(), Value.data(), Value.length());

	mov	r8, QWORD PTR [rbx+16]
	mov	rcx, QWORD PTR [rdi]
	call	memcpy
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 28   : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??$SetValue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Node@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; BymlFile::Node::SetValue<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
Value$GSCopy$ = 32
__$ArrayPad$ = 40
this$ = 64
Value$ = 72
?dtor$0@?0???$SetValue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Node@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `BymlFile::Node::SetValue<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`1'::dtor$0
	mov	rcx, QWORD PTR Value$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$SetValue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Node@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `BymlFile::Node::SetValue<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
;	COMDAT ?HasChild@Node@BymlFile@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
this$ = 64
Key$ = 72
?HasChild@Node@BymlFile@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; BymlFile::Node::HasChild, COMDAT

; 48   : {

$LN47:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 49   :     for (BymlFile::Node& Node : this->m_Children)

	mov	rbx, QWORD PTR [rcx+64]
	mov	rdi, rdx
	mov	rsi, QWORD PTR [rcx+72]
	cmp	rbx, rsi
	je	SHORT $LN3@HasChild
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rbp, QWORD PTR [rdx+24]

; 4584 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	r14, QWORD PTR [rdx+16]
	npad	6
$LL4@HasChild:

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rdx, rdi

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	rbp, 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN12@HasChild

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdi]
$LN12@HasChild:

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rbx+56], 16

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR [rbx+32]

; 4584 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	r8, QWORD PTR [rbx+48]

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN17@HasChild

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rcx]
$LN17@HasChild:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	r8, r14
	jne	SHORT $LN23@HasChild

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	je	SHORT $LN34@HasChild
$LN23@HasChild:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 49   :     for (BymlFile::Node& Node : this->m_Children)

	add	rbx, 88					; 00000058H
	cmp	rbx, rsi
	jne	SHORT $LL4@HasChild
$LN3@HasChild:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rdi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 56   :     return false;

	xor	al, al
$LN1@HasChild:

; 57   : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN34@HasChild:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rdi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 53   :             return true;

	mov	al, 1
	jmp	SHORT $LN1@HasChild
?HasChild@Node@BymlFile@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; BymlFile::Node::HasChild
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
;	COMDAT ?GetChild@Node@BymlFile@@QEAAPEAV12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
this$ = 64
Key$ = 72
?GetChild@Node@BymlFile@@QEAAPEAV12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; BymlFile::Node::GetChild, COMDAT

; 60   : {

$LN47:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 61   :     for (BymlFile::Node& Node : this->m_Children)

	mov	rbx, QWORD PTR [rcx+64]
	mov	rdi, rdx
	mov	rsi, QWORD PTR [rcx+72]
	cmp	rbx, rsi
	je	SHORT $LN3@GetChild
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rbp, QWORD PTR [rdx+24]

; 4584 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	r14, QWORD PTR [rdx+16]
	npad	6
$LL4@GetChild:

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rdx, rdi

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	rbp, 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN12@GetChild

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdi]
$LN12@GetChild:

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rbx+56], 16

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR [rbx+32]

; 4584 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	r8, QWORD PTR [rbx+48]

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN17@GetChild

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rcx]
$LN17@GetChild:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	r8, r14
	jne	SHORT $LN23@GetChild

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	je	SHORT $LN34@GetChild
$LN23@GetChild:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 61   :     for (BymlFile::Node& Node : this->m_Children)

	add	rbx, 88					; 00000058H
	cmp	rbx, rsi
	jne	SHORT $LL4@GetChild
$LN3@GetChild:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rdi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 69   :     return nullptr;

	xor	eax, eax
$LN1@GetChild:

; 70   : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN34@GetChild:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rdi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 65   :             return &Node;

	mov	rax, rbx
	jmp	SHORT $LN1@GetChild
?GetChild@Node@BymlFile@@QEAAPEAV12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; BymlFile::Node::GetChild
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
;	COMDAT ?GetChildren@Node@BymlFile@@QEAAAEAV?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@XZ
_TEXT	SEGMENT
this$ = 8
?GetChildren@Node@BymlFile@@QEAAAEAV?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@XZ PROC ; BymlFile::Node::GetChildren, COMDAT

; 39   :     return this->m_Children;

	lea	rax, QWORD PTR [rcx+64]

; 40   : }

	ret	0
?GetChildren@Node@BymlFile@@QEAAAEAV?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@XZ ENDP ; BymlFile::Node::GetChildren
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
;	COMDAT ?GetNode@BymlFile@@QEAAPEAVNode@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
this$ = 64
Key$ = 72
?GetNode@BymlFile@@QEAAPEAVNode@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; BymlFile::GetNode, COMDAT

; 232  : {

$LN47:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 233  :     for (BymlFile::Node& Node : this->m_Nodes)

	mov	rbx, QWORD PTR [rcx]
	mov	rdi, rdx
	mov	rsi, QWORD PTR [rcx+8]
	cmp	rbx, rsi
	je	SHORT $LN3@GetNode
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rbp, QWORD PTR [rdx+24]

; 4584 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	r14, QWORD PTR [rdx+16]
	npad	7
$LL4@GetNode:

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rdx, rdi

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	rbp, 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN12@GetNode

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdi]
$LN12@GetNode:

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rbx+56], 16

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR [rbx+32]

; 4584 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	r8, QWORD PTR [rbx+48]

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN17@GetNode

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rcx]
$LN17@GetNode:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	r8, r14
	jne	SHORT $LN23@GetNode

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	je	SHORT $LN34@GetNode
$LN23@GetNode:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 233  :     for (BymlFile::Node& Node : this->m_Nodes)

	add	rbx, 88					; 00000058H
	cmp	rbx, rsi
	jne	SHORT $LL4@GetNode
$LN3@GetNode:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rdi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 241  :     return nullptr;

	xor	eax, eax
$LN1@GetNode:

; 242  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN34@GetNode:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rdi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 237  :             return &Node;

	mov	rax, rbx
	jmp	SHORT $LN1@GetNode
?GetNode@BymlFile@@QEAAPEAVNode@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; BymlFile::GetNode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
;	COMDAT ?HasChild@BymlFile@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
this$ = 64
Key$ = 72
?HasChild@BymlFile@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; BymlFile::HasChild, COMDAT

; 88   : {

$LN47:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 89   :     for (BymlFile::Node& Node : this->m_Nodes)

	mov	rbx, QWORD PTR [rcx]
	mov	rdi, rdx
	mov	rsi, QWORD PTR [rcx+8]
	cmp	rbx, rsi
	je	SHORT $LN3@HasChild
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rbp, QWORD PTR [rdx+24]

; 4584 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	r14, QWORD PTR [rdx+16]
	npad	7
$LL4@HasChild:

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rdx, rdi

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	rbp, 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN12@HasChild

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdi]
$LN12@HasChild:

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rbx+56], 16

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR [rbx+32]

; 4584 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	r8, QWORD PTR [rbx+48]

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN17@HasChild

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rcx]
$LN17@HasChild:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	r8, r14
	jne	SHORT $LN23@HasChild

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	je	SHORT $LN34@HasChild
$LN23@HasChild:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 89   :     for (BymlFile::Node& Node : this->m_Nodes)

	add	rbx, 88					; 00000058H
	cmp	rbx, rsi
	jne	SHORT $LL4@HasChild
$LN3@HasChild:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rdi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 96   :     return false;

	xor	al, al
$LN1@HasChild:

; 97   : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN34@HasChild:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rdi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 93   :             return true;

	mov	al, 1
	jmp	SHORT $LN1@HasChild
?HasChild@BymlFile@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; BymlFile::HasChild
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
;	COMDAT ??$SetValue@_N@Node@BymlFile@@QEAAX_N@Z
_TEXT	SEGMENT
this$ = 48
Value$ = 56
??$SetValue@_N@Node@BymlFile@@QEAAX_N@Z PROC		; BymlFile::Node::SetValue<bool>, COMDAT

; 31   : {

$LN9:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1766 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

	mov	rax, QWORD PTR [rcx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 31   : {

	movzx	edi, dl
	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1766 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

	cmp	rax, QWORD PTR [rcx+8]
	je	SHORT $LN3@SetValue

; 1767 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1768 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1769 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1770 :             return;
; 1771 :         }
; 1772 : 
; 1773 :         _My_data._Orphan_all();
; 1774 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1775 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1776 :         _Mylast = _Myfirst;

	mov	QWORD PTR [rcx+8], rax
$LN3@SetValue:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 33   :     this->m_Value.resize(sizeof(Value));

	mov	edx, 1
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 34   :     memcpy(this->m_Value.data(), &Value, sizeof(Value));

	mov	rax, QWORD PTR [rbx]

; 35   : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	BYTE PTR [rax], dil
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$SetValue@_N@Node@BymlFile@@QEAAX_N@Z ENDP		; BymlFile::Node::SetValue<bool>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
;	COMDAT ??$SetValue@N@Node@BymlFile@@QEAAXN@Z
_TEXT	SEGMENT
this$ = 48
Value$ = 56
??$SetValue@N@Node@BymlFile@@QEAAXN@Z PROC		; BymlFile::Node::SetValue<double>, COMDAT

; 31   : {

$LN9:
	movsd	QWORD PTR [rsp+16], xmm1
	push	rbx
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1766 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

	mov	rax, QWORD PTR [rcx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 31   : {

	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1766 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

	cmp	rax, QWORD PTR [rcx+8]
	je	SHORT $LN3@SetValue

; 1767 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1768 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1769 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1770 :             return;
; 1771 :         }
; 1772 : 
; 1773 :         _My_data._Orphan_all();
; 1774 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1775 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1776 :         _Mylast = _Myfirst;

	mov	QWORD PTR [rcx+8], rax
$LN3@SetValue:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 33   :     this->m_Value.resize(sizeof(Value));

	mov	edx, 8
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 34   :     memcpy(this->m_Value.data(), &Value, sizeof(Value));

	mov	rcx, QWORD PTR [rbx]
	mov	rax, QWORD PTR Value$[rsp]
	mov	QWORD PTR [rcx], rax

; 35   : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$SetValue@N@Node@BymlFile@@QEAAXN@Z ENDP		; BymlFile::Node::SetValue<double>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
;	COMDAT ??$SetValue@M@Node@BymlFile@@QEAAXM@Z
_TEXT	SEGMENT
this$ = 48
Value$ = 56
??$SetValue@M@Node@BymlFile@@QEAAXM@Z PROC		; BymlFile::Node::SetValue<float>, COMDAT

; 31   : {

$LN9:
	movss	DWORD PTR [rsp+16], xmm1
	push	rbx
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1766 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

	mov	rax, QWORD PTR [rcx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 31   : {

	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1766 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

	cmp	rax, QWORD PTR [rcx+8]
	je	SHORT $LN3@SetValue

; 1767 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1768 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1769 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1770 :             return;
; 1771 :         }
; 1772 : 
; 1773 :         _My_data._Orphan_all();
; 1774 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1775 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1776 :         _Mylast = _Myfirst;

	mov	QWORD PTR [rcx+8], rax
$LN3@SetValue:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 33   :     this->m_Value.resize(sizeof(Value));

	mov	edx, 4
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 34   :     memcpy(this->m_Value.data(), &Value, sizeof(Value));

	mov	rcx, QWORD PTR [rbx]
	mov	eax, DWORD PTR Value$[rsp]
	mov	DWORD PTR [rcx], eax

; 35   : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$SetValue@M@Node@BymlFile@@QEAAXM@Z ENDP		; BymlFile::Node::SetValue<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
;	COMDAT ??$SetValue@H@Node@BymlFile@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
Value$ = 56
??$SetValue@H@Node@BymlFile@@QEAAXH@Z PROC		; BymlFile::Node::SetValue<int>, COMDAT

; 31   : {

$LN9:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1766 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

	mov	rax, QWORD PTR [rcx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 31   : {

	mov	edi, edx
	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1766 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

	cmp	rax, QWORD PTR [rcx+8]
	je	SHORT $LN3@SetValue

; 1767 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1768 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1769 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1770 :             return;
; 1771 :         }
; 1772 : 
; 1773 :         _My_data._Orphan_all();
; 1774 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1775 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1776 :         _Mylast = _Myfirst;

	mov	QWORD PTR [rcx+8], rax
$LN3@SetValue:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 33   :     this->m_Value.resize(sizeof(Value));

	mov	edx, 4
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 34   :     memcpy(this->m_Value.data(), &Value, sizeof(Value));

	mov	rax, QWORD PTR [rbx]

; 35   : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	DWORD PTR [rax], edi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$SetValue@H@Node@BymlFile@@QEAAXH@Z ENDP		; BymlFile::Node::SetValue<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
;	COMDAT ??$SetValue@_J@Node@BymlFile@@QEAAX_J@Z
_TEXT	SEGMENT
this$ = 48
Value$ = 56
??$SetValue@_J@Node@BymlFile@@QEAAX_J@Z PROC		; BymlFile::Node::SetValue<__int64>, COMDAT

; 31   : {

$LN9:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1766 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

	mov	rax, QWORD PTR [rcx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 31   : {

	mov	rdi, rdx
	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1766 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

	cmp	rax, QWORD PTR [rcx+8]
	je	SHORT $LN3@SetValue

; 1767 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1768 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1769 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1770 :             return;
; 1771 :         }
; 1772 : 
; 1773 :         _My_data._Orphan_all();
; 1774 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1775 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1776 :         _Mylast = _Myfirst;

	mov	QWORD PTR [rcx+8], rax
$LN3@SetValue:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 33   :     this->m_Value.resize(sizeof(Value));

	mov	edx, 8
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 34   :     memcpy(this->m_Value.data(), &Value, sizeof(Value));

	mov	rax, QWORD PTR [rbx]

; 35   : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [rax], rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$SetValue@_J@Node@BymlFile@@QEAAX_J@Z ENDP		; BymlFile::Node::SetValue<__int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
;	COMDAT ??$SetValue@I@Node@BymlFile@@QEAAXI@Z
_TEXT	SEGMENT
this$ = 48
Value$ = 56
??$SetValue@I@Node@BymlFile@@QEAAXI@Z PROC		; BymlFile::Node::SetValue<unsigned int>, COMDAT

; 31   : {

$LN9:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1766 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

	mov	rax, QWORD PTR [rcx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 31   : {

	mov	edi, edx
	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1766 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

	cmp	rax, QWORD PTR [rcx+8]
	je	SHORT $LN3@SetValue

; 1767 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1768 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1769 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1770 :             return;
; 1771 :         }
; 1772 : 
; 1773 :         _My_data._Orphan_all();
; 1774 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1775 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1776 :         _Mylast = _Myfirst;

	mov	QWORD PTR [rcx+8], rax
$LN3@SetValue:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 33   :     this->m_Value.resize(sizeof(Value));

	mov	edx, 4
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 34   :     memcpy(this->m_Value.data(), &Value, sizeof(Value));

	mov	rax, QWORD PTR [rbx]

; 35   : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	DWORD PTR [rax], edi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$SetValue@I@Node@BymlFile@@QEAAXI@Z ENDP		; BymlFile::Node::SetValue<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
;	COMDAT ??$SetValue@_K@Node@BymlFile@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
Value$ = 56
??$SetValue@_K@Node@BymlFile@@QEAAX_K@Z PROC		; BymlFile::Node::SetValue<unsigned __int64>, COMDAT

; 31   : {

$LN9:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1766 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

	mov	rax, QWORD PTR [rcx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 31   : {

	mov	rdi, rdx
	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1766 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

	cmp	rax, QWORD PTR [rcx+8]
	je	SHORT $LN3@SetValue

; 1767 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1768 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1769 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1770 :             return;
; 1771 :         }
; 1772 : 
; 1773 :         _My_data._Orphan_all();
; 1774 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1775 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1776 :         _Mylast = _Myfirst;

	mov	QWORD PTR [rcx+8], rax
$LN3@SetValue:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 33   :     this->m_Value.resize(sizeof(Value));

	mov	edx, 8
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 34   :     memcpy(this->m_Value.data(), &Value, sizeof(Value));

	mov	rax, QWORD PTR [rbx]

; 35   : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [rax], rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$SetValue@_K@Node@BymlFile@@QEAAX_K@Z ENDP		; BymlFile::Node::SetValue<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
;	COMDAT ?GetChild@Node@BymlFile@@QEAAPEAV12@H@Z
_TEXT	SEGMENT
this$ = 8
Index$ = 16
?GetChild@Node@BymlFile@@QEAAPEAV12@H@Z PROC		; BymlFile::Node::GetChild, COMDAT

; 74   :     return &this->m_Children[Index];

	movsxd	rax, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	imul	rax, rax, 88				; 00000058H
	add	rax, QWORD PTR [rcx+64]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 75   : }

	ret	0
?GetChild@Node@BymlFile@@QEAAPEAV12@H@Z ENDP		; BymlFile::Node::GetChild
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
;	COMDAT ?AddChild@Node@BymlFile@@QEAAXV12@@Z
_TEXT	SEGMENT
Node$GSCopy$ = 32
__$ArrayPad$ = 40
this$ = 64
Node$ = 72
?AddChild@Node@BymlFile@@QEAAXV12@@Z PROC		; BymlFile::Node::AddChild, COMDAT

; 43   : {

$LN6:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbx, rdx

; 42   : void BymlFile::Node::AddChild(BymlFile::Node Node)

	mov	QWORD PTR Node$GSCopy$[rsp], rdx

; 44   :     this->m_Children.push_back(Node);

	add	rcx, 64					; 00000040H
	call	?push_back@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAXAEBVNode@BymlFile@@@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::push_back
	npad	1

; 45   : }

	mov	rcx, rbx
	call	??1Node@BymlFile@@QEAA@XZ
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
?AddChild@Node@BymlFile@@QEAAXV12@@Z ENDP		; BymlFile::Node::AddChild
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
Node$GSCopy$ = 32
__$ArrayPad$ = 40
this$ = 64
Node$ = 72
?dtor$0@?0??AddChild@Node@BymlFile@@QEAAXV12@@Z@4HA PROC ; `BymlFile::Node::AddChild'::`1'::dtor$0
	mov	rcx, QWORD PTR Node$GSCopy$[rdx]
	jmp	??1Node@BymlFile@@QEAA@XZ
?dtor$0@?0??AddChild@Node@BymlFile@@QEAAXV12@@Z@4HA ENDP ; `BymlFile::Node::AddChild'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
;	COMDAT ??8Node@BymlFile@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 64
Comp$ = 72
??8Node@BymlFile@@QEBA_NAEBV01@@Z PROC			; BymlFile::Node::operator==, COMDAT

; 78   : {

$LN90:
	push	rbx
	push	r14
	sub	rsp, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4584 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	rax, QWORD PTR [rdx+48]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 78   : {

	mov	r14, rdx

; 79   :     return m_Key == Comp.m_Key &&

	add	rdx, 32					; 00000020H
	mov	rbx, rcx
	add	rcx, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN10@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN10@operator:

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 16

; 4584 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	r8, QWORD PTR [rcx+16]

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN15@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rcx]
$LN15@operator:
	mov	QWORD PTR [rsp+80], rsi
	mov	QWORD PTR [rsp+32], rdi

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	r8, rax
	jne	$LN3@operator

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	jne	$LN3@operator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [r14]
	mov	rcx, QWORD PTR [rbx]
	mov	r8, QWORD PTR [rbx+8]
	mov	rax, QWORD PTR [r14+8]
	sub	r8, rcx
	sub	rax, rdx

; 2222 :     if (_Left.size() != _Right.size()) {

	cmp	r8, rax
	jne	SHORT $LN3@operator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 5246 :     return _CSTD memcmp(_First1_ch, _First2_ch, static_cast<size_t>(_Last1_ch - _First1_ch));

	call	memcmp

; 5269 :             return _Memcmp_ranges(_UFirst1, _ULast1, _UFirst2) == 0;

	test	eax, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 79   :     return m_Key == Comp.m_Key &&

	jne	SHORT $LN3@operator
	movzx	eax, BYTE PTR [r14+24]
	cmp	BYTE PTR [rbx+24], al
	jne	SHORT $LN3@operator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rsi, QWORD PTR [rbx+72]
	mov	rdi, QWORD PTR [r14+64]
	mov	rax, rsi
	mov	rbx, QWORD PTR [rbx+64]
	mov	rcx, QWORD PTR [r14+72]
	sub	rax, rbx
	sub	rcx, rdi

; 2222 :     if (_Left.size() != _Right.size()) {

	cmp	rax, rcx
	jne	SHORT $LN3@operator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 5273 :     for (; _UFirst1 != _ULast1; ++_UFirst1, (void) ++_UFirst2) {

	cmp	rbx, rsi
	je	SHORT $LN77@operator
$LL59@operator:

; 486  :         return static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right);

	mov	rdx, rdi
	mov	rcx, rbx
	call	??8Node@BymlFile@@QEBA_NAEBV01@@Z	; BymlFile::Node::operator==

; 5274 :         if (!_Pred(*_UFirst1, *_UFirst2)) {

	test	al, al
	je	SHORT $LN3@operator

; 5273 :     for (; _UFirst1 != _ULast1; ++_UFirst1, (void) ++_UFirst2) {

	add	rbx, 88					; 00000058H
	add	rdi, 88					; 00000058H
	cmp	rbx, rsi
	jne	SHORT $LL59@operator
$LN77@operator:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 79   :     return m_Key == Comp.m_Key &&

	mov	al, 1
	mov	rdi, QWORD PTR [rsp+32]

; 80   :         m_Value == Comp.m_Value &&
; 81   :         m_Type == Comp.m_Type &&
; 82   :         m_Children == Comp.m_Children;
; 83   : }

	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 40					; 00000028H
	pop	r14
	pop	rbx
	ret	0
$LN3@operator:
	mov	rdi, QWORD PTR [rsp+32]

; 79   :     return m_Key == Comp.m_Key &&

	xor	al, al

; 80   :         m_Value == Comp.m_Value &&
; 81   :         m_Type == Comp.m_Type &&
; 82   :         m_Children == Comp.m_Children;
; 83   : }

	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 40					; 00000028H
	pop	r14
	pop	rbx
	ret	0
??8Node@BymlFile@@QEBA_NAEBV01@@Z ENDP			; BymlFile::Node::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h
;	COMDAT ??0Node@BymlFile@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0Node@BymlFile@@QEAA@XZ PROC				; BymlFile::Node::Node, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	xorps	xmm0, xmm0
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx+32], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+48], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+56], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx+32], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+64], rax
	mov	QWORD PTR [rcx+72], rax
	mov	QWORD PTR [rcx+80], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h

; 44   :         Node() {}

	mov	rax, rcx
	ret	0
??0Node@BymlFile@@QEAA@XZ ENDP				; BymlFile::Node::Node
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\__msvc_chrono.hpp
;	COMDAT ?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ
_TEXT	SEGMENT
__$ReturnUdt$ = 48
?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ PROC ; std::chrono::system_clock::now, COMDAT

; 642  :         _NODISCARD static time_point now() noexcept { // get current time

$LN9:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 643  :             return time_point(duration(_Xtime_get_ticks()));

	call	QWORD PTR __imp__Xtime_get_ticks

; 204  :             : _MyDur(_Other) {}

	mov	QWORD PTR [rbx], rax

; 643  :             return time_point(duration(_Xtime_get_ticks()));

	mov	rax, rbx

; 644  :         }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ ENDP ; std::chrono::system_clock::now
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
;	COMDAT ?ParseTable@BymlFile@@AEAAXAEAVBinaryVectorReader@@PEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@H@Z
_TEXT	SEGMENT
tv1094 = 32
this$1$ = 40
$T1 = 40
$T2 = 48
$T3 = 80
this$ = 176
Reader$ = 184
Dest$ = 192
TableOffset$ = 200
?ParseTable@BymlFile@@AEAAXAEAVBinaryVectorReader@@PEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@H@Z PROC ; BymlFile::ParseTable, COMDAT

; 100  : {

$LN133:
	mov	QWORD PTR [rsp+8], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 112				; 00000070H
	mov	rsi, r8
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR this$1$[rsp], rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 12   : 		this->m_Offset = Offset - 1;

	lea	ebp, DWORD PTR [r9-1]
	mov	DWORD PTR tv1094[rsp], ebp

; 44   : 	this->m_Offset++;

	mov	DWORD PTR [rdx+8], r9d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1883 :         auto& _My_data = _Mypair._Myval2;

	mov	rdx, QWORD PTR [rdx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 45   : 	return this->m_Bytes[this->m_Offset];

	movsxd	r10, r9d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rdx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 102  :     if (Reader.ReadUInt8() != (uint8_t)BymlFile::Type::KeyTable)

	cmp	BYTE PTR [r10+rax], 194			; 000000c2H
	je	$LN7@ParseTable

; 104  :         Logger::Error("BymlDecoder", "Wrong node type, could not parse key table");

	lea	rax, QWORD PTR $T2[rsp]
	mov	QWORD PTR $T1[rsp], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T2[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	r15d, r15d
	mov	QWORD PTR $T2[rsp+16], r15

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T2[rsp+24], r15

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [r15+42]
	lea	rdx, OFFSET FLAT:??_C@_0CL@ODJIEOCJ@Wrong?5node?5type?0?5could?5not?5pars@
	lea	rcx, QWORD PTR $T2[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T3[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T3[rsp+16], r15

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T3[rsp+24], r15

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [r15+11]
	lea	rdx, OFFSET FLAT:??_C@_0M@EFFJMBCP@BymlDecoder@
	lea	rcx, QWORD PTR $T3[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 104  :         Logger::Error("BymlDecoder", "Wrong node type, could not parse key table");

	lea	rdx, QWORD PTR $T2[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	call	?Error@Logger@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; Logger::Error
$LN3@ParseTable:

; 122  : }

	mov	rbx, QWORD PTR [rsp+176]
	add	rsp, 112				; 00000070H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN7@ParseTable:

; 105  :         return;
; 106  :     }
; 107  :     uint32_t TableSize = Reader.ReadUInt24(mBigEndian);

	movzx	r8d, BYTE PTR [rcx+216]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 67   : 	this->m_Offset += 3;

	lea	r13d, DWORD PTR [r9+3]
	mov	DWORD PTR [rdi+8], r13d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rdx, QWORD PTR [rdx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 68   : 	uint32_t Value = (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 2])) |

	movzx	r12d, BYTE PTR [rdx+r10+3]
	shl	r12d, 8
	movzx	eax, BYTE PTR [rdx+r10+2]
	or	r12d, eax
	shl	r12d, 8
	lea	eax, DWORD PTR [r9+1]
	movsxd	rcx, eax
	movzx	eax, BYTE PTR [rcx+rdx]
	or	r12d, eax

; 69   : 		(static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 1]) << 8) |
; 70   : 		(static_cast<uint32_t>(this->m_Bytes[this->m_Offset]) << 16);
; 71   : 	return !BigEndian ? Value : (_byteswap_ulong(Value) >> 8);

	test	r8b, r8b
	je	SHORT $LN113@ParseTable
	bswap	r12d
	shr	r12d, 8
$LN113@ParseTable:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 108  :     Dest->resize(TableSize);

	mov	edx, r12d
	mov	rcx, rsi
	call	?resize@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAX_K@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::resize

; 109  :     for (uint32_t i = 0; i < TableSize; i++)

	xor	r15d, r15d
	test	r12d, r12d
	je	SHORT $LN3@ParseTable
	npad	3
$LL4@ParseTable:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 12   : 		this->m_Offset = Offset - 1;

	mov	DWORD PTR [rdi+8], r13d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 112  :         Reader.Seek(TableOffset + Reader.ReadUInt32(mBigEndian), BinaryVectorReader::Position::Begin);

	movzx	edx, BYTE PTR [rbx+216]
	mov	rcx, rdi
	call	?ReadUInt32@BinaryVectorReader@@QEAAI_N@Z ; BinaryVectorReader::ReadUInt32
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 12   : 		this->m_Offset = Offset - 1;

	lea	ecx, DWORD PTR [rax+rbp]

; 50   : 	this->m_Offset++;

	lea	eax, DWORD PTR [rcx+1]
	mov	DWORD PTR [rdi+8], eax

; 51   : 	return this->m_Bytes[this->m_Offset];

	movsxd	rdx, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rdi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 51   : 	return this->m_Bytes[this->m_Offset];

	mov	rcx, QWORD PTR [rax]
	movzx	ebx, BYTE PTR [rdx+rcx+1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 114  :         Dest->at(i) += CurrentCharacter;

	mov	ebp, r15d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1904 :         if (static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst) <= _Pos) {

	mov	rcx, QWORD PTR [rsi]
	mov	rax, QWORD PTR [rsi+8]
	sub	rax, rcx
	sar	rax, 5
	cmp	rax, rbp
	jbe	$LN124@ParseTable

; 1906 :         }
; 1907 : 
; 1908 :         return _My_data._Myfirst[_Pos];

	mov	r14d, ebp
	shl	r14, 5
	add	rcx, r14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4046 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rdx, QWORD PTR [rcx+16]

; 4047 :         if (_Old_size < _Mypair._Myval2._Myres) {

	mov	r8, QWORD PTR [rcx+24]
	cmp	rdx, r8
	jae	SHORT $LN55@ParseTable

; 4048 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 4049 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rdx+1]
	mov	QWORD PTR [rcx+16], rax

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	r8, 16

; 2227 :         if (_Large_string_engaged()) {

	jb	SHORT $LN58@ParseTable

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rcx]
$LN58@ParseTable:

; 4051 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	BYTE PTR [rcx+rdx], bl

; 4052 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [rcx+rdx+1], 0

; 4053 :             return;

	jmp	SHORT $LN121@ParseTable
$LN55@ParseTable:

; 4054 :         }
; 4055 : 
; 4056 :         _Reallocate_grow_by(

	movzx	r9d, bl
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
$LN121@ParseTable:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 115  :         while (CurrentCharacter != 0x00)

	test	bl, bl
	je	SHORT $LN6@ParseTable
	npad	13
$LL5@ParseTable:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 50   : 	this->m_Offset++;

	movsxd	rcx, DWORD PTR [rdi+8]
	lea	eax, DWORD PTR [rcx+1]
	mov	DWORD PTR [rdi+8], eax

; 51   : 	return this->m_Bytes[this->m_Offset];

	mov	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rdi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 51   : 	return this->m_Bytes[this->m_Offset];

	mov	rcx, QWORD PTR [rax]
	movzx	ebx, BYTE PTR [rdx+rcx+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1904 :         if (static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst) <= _Pos) {

	mov	rcx, QWORD PTR [rsi]
	mov	rax, QWORD PTR [rsi+8]
	sub	rax, rcx
	sar	rax, 5
	cmp	rax, rbp
	jbe	$LN124@ParseTable

; 1906 :         }
; 1907 : 
; 1908 :         return _My_data._Myfirst[_Pos];

	add	rcx, r14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4046 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rdx, QWORD PTR [rcx+16]

; 4047 :         if (_Old_size < _Mypair._Myval2._Myres) {

	mov	r8, QWORD PTR [rcx+24]
	cmp	rdx, r8
	jae	SHORT $LN22@ParseTable

; 4048 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 4049 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rdx+1]
	mov	QWORD PTR [rcx+16], rax

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	r8, 16

; 2227 :         if (_Large_string_engaged()) {

	jb	SHORT $LN25@ParseTable

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rcx]
$LN25@ParseTable:

; 4051 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	BYTE PTR [rcx+rdx], bl

; 4052 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [rcx+rdx+1], 0

; 4053 :             return;

	jmp	SHORT $LN21@ParseTable
$LN22@ParseTable:

; 4054 :         }
; 4055 : 
; 4056 :         _Reallocate_grow_by(

	movzx	r9d, bl
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
$LN21@ParseTable:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 115  :         while (CurrentCharacter != 0x00)

	test	bl, bl
	jne	SHORT $LL5@ParseTable
$LN6@ParseTable:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1904 :         if (static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst) <= _Pos) {

	mov	rcx, QWORD PTR [rsi]
	mov	rax, QWORD PTR [rsi+8]
	sub	rax, rcx
	sar	rax, 5
	cmp	rax, rbp
	jbe	SHORT $LN124@ParseTable

; 1906 :         }
; 1907 : 
; 1908 :         return _My_data._Myfirst[_Pos];

	lea	rax, QWORD PTR [r14+rcx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4067 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	lea	rdx, QWORD PTR [rax+16]

; 4068 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 4069 :         _STL_VERIFY(_Old_size != 0, "invalid to pop_back empty string");
; 4070 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 4071 :         _Eos(_Old_size - 1);

	mov	rcx, QWORD PTR [rdx]
	dec	rcx

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rax+24], 16

; 2227 :         if (_Large_string_engaged()) {

	jb	SHORT $LN70@ParseTable

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rax]
$LN70@ParseTable:

; 4815 :         _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _New_size], _Elem());

	mov	QWORD PTR [rdx], rcx
	mov	BYTE PTR [rax+rcx], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 109  :     for (uint32_t i = 0; i < TableSize; i++)

	inc	r15d
	add	r13d, 4
	cmp	r15d, r12d
	mov	rbx, QWORD PTR this$1$[rsp]
	mov	ebp, DWORD PTR tv1094[rsp]
	jb	$LL4@ParseTable
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1904 :         if (static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst) <= _Pos) {

	jmp	$LN3@ParseTable
$LN124@ParseTable:

; 1905 :             _Xrange();

	call	?_Xrange@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xrange
	int	3
$LN130@ParseTable:
?ParseTable@BymlFile@@AEAAXAEAVBinaryVectorReader@@PEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@H@Z ENDP ; BymlFile::ParseTable
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv1094 = 32
this$1$ = 40
$T1 = 40
$T2 = 48
$T3 = 80
this$ = 176
Reader$ = 184
Dest$ = 192
TableOffset$ = 200
?dtor$0@?0??ParseTable@BymlFile@@AEAAXAEAVBinaryVectorReader@@PEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@H@Z@4HA PROC ; `BymlFile::ParseTable'::`1'::dtor$0
	mov	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??ParseTable@BymlFile@@AEAAXAEAVBinaryVectorReader@@PEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@H@Z@4HA ENDP ; `BymlFile::ParseTable'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
;	COMDAT ?AlignUp@BymlFile@@AEAAHHH@Z
_TEXT	SEGMENT
this$dead$ = 8
Value$ = 16
Size$dead$ = 24
?AlignUp@BymlFile@@AEAAHHH@Z PROC			; BymlFile::AlignUp, COMDAT

; 126  :     return Value + (Size - Value % Size) % Size;

	mov	ecx, edx
	and	ecx, -2147483645			; ffffffff80000003H
	jge	SHORT $LN4@AlignUp
	dec	ecx
	or	ecx, -4
	inc	ecx
$LN4@AlignUp:
	mov	eax, 4
	sub	eax, ecx
	and	eax, -2147483645			; ffffffff80000003H
	jge	SHORT $LN3@AlignUp
	dec	eax
	or	eax, -4
	inc	eax
$LN3@AlignUp:
	add	eax, edx

; 127  : }

	ret	0
?AlignUp@BymlFile@@AEAAHHH@Z ENDP			; BymlFile::AlignUp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
;	COMDAT ?ParseNode@BymlFile@@AEAAXAEAVBinaryVectorReader@@HW4Type@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVNode@1@I@Z
_TEXT	SEGMENT
ChildIndex$GSCopy$1$ = 64
Parent$GSCopy$1$ = 72
$T1 = 72
$T2 = 80
$T3 = 80
$T4 = 112
$T5 = 112
$T6 = 144
$T7 = 144
$T8 = 144
$T9 = 144
$T10 = 184
Key$GSCopy$ = 216
Temp$11 = 224
Value$ = 224
$T12 = 224
$T13 = 224
Node$ = 240
__$ArrayPad$ = 336
this$ = 416
Reader$ = 424
Offset$ = 432
Type$ = 440
Key$ = 448
Parent$ = 456
ChildIndex$ = 464
?ParseNode@BymlFile@@AEAAXAEAVBinaryVectorReader@@HW4Type@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVNode@1@I@Z PROC ; BymlFile::ParseNode, COMDAT

; 130  : {

$LN375:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-96]
	sub	rsp, 352				; 00000160H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	movzx	r14d, r9b
	mov	r15d, r8d
	mov	rdi, rdx
	mov	rsi, rcx
	mov	r12, QWORD PTR Key$[rbp-256]
	mov	QWORD PTR Key$GSCopy$[rbp-256], r12
	mov	rax, QWORD PTR Parent$[rbp-256]
	mov	QWORD PTR Parent$GSCopy$1$[rsp], rax
	mov	eax, DWORD PTR ChildIndex$[rbp-256]
	mov	DWORD PTR ChildIndex$GSCopy$1$[rsp], eax
	xor	r13d, r13d

; 131  :     if (Type == BymlFile::Type::Null)

	xorps	xmm0, xmm0
	cmp	r14b, 255				; 000000ffH
	jne	SHORT $LN10@ParseNode

; 133  :         Logger::Error("BymlDecoder", "Got BYML node with null type");

	lea	rax, QWORD PTR $T3[rsp]
	mov	QWORD PTR $T1[rsp], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T3[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T3[rsp+16], r13

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T3[rsp+24], r13

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [r13+28]
	lea	rdx, OFFSET FLAT:??_C@_0BN@GLAHIIGB@Got?5BYML?5node?5with?5null?5type@
	lea	rcx, QWORD PTR $T3[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T5[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T5[rbp-240], r13

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T5[rbp-232], r13

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [r13+11]
	lea	rdx, OFFSET FLAT:??_C@_0M@EFFJMBCP@BymlDecoder@
	lea	rcx, QWORD PTR $T5[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 133  :         Logger::Error("BymlDecoder", "Got BYML node with null type");

	lea	rdx, QWORD PTR $T3[rsp]
	lea	rcx, QWORD PTR $T5[rsp]
	call	?Error@Logger@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; Logger::Error

; 134  :         return;

	jmp	$LN48@ParseNode
$LN10@ParseNode:
	xor	eax, eax
	movups	XMMWORD PTR Node$[rbp-256], xmm0
	movups	XMMWORD PTR Node$[rbp-240], xmm0
	movups	XMMWORD PTR Node$[rbp-224], xmm0
	movups	XMMWORD PTR Node$[rbp-208], xmm0
	movups	XMMWORD PTR Node$[rbp-192], xmm0
	mov	QWORD PTR Node$[rbp-176], rax

; 135  :     }
; 136  : 
; 137  :     BymlFile::Node Node(Type, Key);

	mov	rdx, r12
	lea	rcx, QWORD PTR $T10[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rbx, rax
	mov	QWORD PTR $T12[rbp-256], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqa	XMMWORD PTR Node$[rbp-256], xmm0
	mov	QWORD PTR Node$[rbp-240], r13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 9    : BymlFile::Node::Node(BymlFile::Type Type, std::string Key) : m_Type(Type), m_Key(Key)

	mov	BYTE PTR Node$[rbp-232], r14b
	mov	rdx, rax
	lea	rcx, QWORD PTR Node$[rbp-224]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqa	XMMWORD PTR Node$[rbp-192], xmm0
	mov	QWORD PTR Node$[rbp-176], r13
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 12   : 		this->m_Offset = Offset - 1;

	lea	eax, DWORD PTR [r15-1]
	mov	DWORD PTR [rdi+8], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 140  :     switch (Type)

	lea	eax, DWORD PTR [r14-160]
	cmp	eax, 54					; 00000036H
	ja	$LN21@ParseNode
	cdqe
	lea	rcx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR $LN363@ParseNode[rcx+rax]
	mov	edx, DWORD PTR $LN364@ParseNode[rcx+rax*4]
	add	rdx, rcx
	jmp	rdx
$LN11@ParseNode:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 137  : 	uint32_t Temp = this->ReadUInt64(BigEndian);

	movzx	edx, BYTE PTR [rsi+216]
	mov	rcx, rdi
	call	?ReadUInt64@BinaryVectorReader@@QEAA_K_N@Z ; BinaryVectorReader::ReadUInt64
	mov	DWORD PTR Temp$11[rbp-256], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 144  :         Node.SetValue<double>(Reader.ReadDouble(mBigEndian));

	movsd	xmm0, QWORD PTR Temp$11[rbp-256]
	movsd	QWORD PTR Value$[rbp-256], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1766 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

	mov	rax, QWORD PTR Node$[rbp-256]
	cmp	rax, QWORD PTR Node$[rbp-248]
	je	SHORT $LN276@ParseNode

; 1767 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1768 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1769 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1770 :             return;
; 1771 :         }
; 1772 : 
; 1773 :         _My_data._Orphan_all();
; 1774 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1775 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1776 :         _Mylast = _Myfirst;

	mov	QWORD PTR Node$[rbp-248], rax
$LN276@ParseNode:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 33   :     this->m_Value.resize(sizeof(Value));

	mov	edx, 8
	lea	rcx, QWORD PTR Node$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 34   :     memcpy(this->m_Value.data(), &Value, sizeof(Value));

	mov	rcx, QWORD PTR Value$[rbp-256]
	mov	rax, QWORD PTR Node$[rbp-256]
	mov	QWORD PTR [rax], rcx

; 145  :         break;

	jmp	$LN161@ParseNode
$LN12@ParseNode:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 129  : 	uint32_t Temp = this->ReadUInt32(BigEndian);

	movzx	edx, BYTE PTR [rsi+216]
	mov	rcx, rdi
	call	?ReadUInt32@BinaryVectorReader@@QEAAI_N@Z ; BinaryVectorReader::ReadUInt32
	mov	ebx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1766 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

	mov	rax, QWORD PTR Node$[rbp-256]
	cmp	rax, QWORD PTR Node$[rbp-248]
	je	SHORT $LN322@ParseNode

; 1767 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1768 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1769 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1770 :             return;
; 1771 :         }
; 1772 : 
; 1773 :         _My_data._Orphan_all();
; 1774 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1775 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1776 :         _Mylast = _Myfirst;

	mov	QWORD PTR Node$[rbp-248], rax
$LN322@ParseNode:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 33   :     this->m_Value.resize(sizeof(Value));

	mov	edx, 4
	lea	rcx, QWORD PTR Node$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 34   :     memcpy(this->m_Value.data(), &Value, sizeof(Value));

	mov	rax, QWORD PTR Node$[rbp-256]
	mov	DWORD PTR [rax], ebx

; 146  :     }
; 147  :     case BymlFile::Type::Float:
; 148  :     {
; 149  :         Node.SetValue<float>(Reader.ReadFloat(mBigEndian));
; 150  :         break;

	jmp	$LN161@ParseNode
$LN13@ParseNode:

; 151  :     }
; 152  :     case BymlFile::Type::UInt32:
; 153  :     {
; 154  :         Node.SetValue<uint32_t>(Reader.ReadUInt32(mBigEndian));

	movzx	edx, BYTE PTR [rsi+216]
	mov	rcx, rdi
	call	?ReadUInt32@BinaryVectorReader@@QEAAI_N@Z ; BinaryVectorReader::ReadUInt32
$LN370@ParseNode:

; 216  :     }
; 217  : 
; 218  :     Parent->GetChildren()[ChildIndex] = Node;

	mov	rcx, QWORD PTR Node$[rbp-256]
	cmp	rcx, QWORD PTR Node$[rbp-248]
	mov	ebx, eax
	je	SHORT $LN307@ParseNode
	mov	QWORD PTR Node$[rbp-248], rcx
$LN307@ParseNode:
	mov	edx, 4
	lea	rcx, QWORD PTR Node$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	rcx, QWORD PTR Node$[rbp-256]
	mov	DWORD PTR [rcx], ebx
	jmp	$LN161@ParseNode
$LN14@ParseNode:

; 155  :         break;
; 156  :     }
; 157  :     case BymlFile::Type::Int32:
; 158  :     {
; 159  :         Node.SetValue<int32_t>(Reader.ReadInt32(mBigEndian));

	movzx	edx, BYTE PTR [rsi+216]
	mov	rcx, rdi
	call	?ReadInt32@BinaryVectorReader@@QEAAH_N@Z ; BinaryVectorReader::ReadInt32

; 160  :         break;

	jmp	SHORT $LN370@ParseNode
$LN15@ParseNode:

; 161  :     }
; 162  :     case BymlFile::Type::UInt64:
; 163  :     {
; 164  :         Reader.Seek(Reader.ReadUInt32(mBigEndian), BinaryVectorReader::Position::Begin);

	movzx	edx, BYTE PTR [rsi+216]
	mov	rcx, rdi
	call	?ReadUInt32@BinaryVectorReader@@QEAAI_N@Z ; BinaryVectorReader::ReadUInt32
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 12   : 		this->m_Offset = Offset - 1;

	dec	eax
	mov	DWORD PTR [rdi+8], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 165  :         Node.SetValue<uint64_t>(Reader.ReadUInt64(mBigEndian));

	movzx	edx, BYTE PTR [rsi+216]
	mov	rcx, rdi
	call	?ReadUInt64@BinaryVectorReader@@QEAA_K_N@Z ; BinaryVectorReader::ReadUInt64
$LN372@ParseNode:

; 216  :     }
; 217  : 
; 218  :     Parent->GetChildren()[ChildIndex] = Node;

	mov	rcx, QWORD PTR Node$[rbp-256]
	cmp	rcx, QWORD PTR Node$[rbp-248]
	mov	rbx, rax
	je	SHORT $LN294@ParseNode
	mov	QWORD PTR Node$[rbp-248], rcx
$LN294@ParseNode:
	mov	edx, 8
	lea	rcx, QWORD PTR Node$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	rcx, QWORD PTR Node$[rbp-256]
	mov	QWORD PTR [rcx], rbx
	jmp	$LN161@ParseNode
$LN16@ParseNode:

; 166  :         break;
; 167  :     }
; 168  :     case BymlFile::Type::Int64:
; 169  :     {
; 170  :         Reader.Seek(Reader.ReadUInt32(mBigEndian), BinaryVectorReader::Position::Begin);

	movzx	edx, BYTE PTR [rsi+216]
	mov	rcx, rdi
	call	?ReadUInt32@BinaryVectorReader@@QEAAI_N@Z ; BinaryVectorReader::ReadUInt32
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 12   : 		this->m_Offset = Offset - 1;

	dec	eax
	mov	DWORD PTR [rdi+8], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 171  :         Node.SetValue<int64_t>(Reader.ReadInt64(mBigEndian));

	movzx	edx, BYTE PTR [rsi+216]
	mov	rcx, rdi
	call	?ReadInt64@BinaryVectorReader@@QEAA_J_N@Z ; BinaryVectorReader::ReadInt64

; 172  :         break;

	jmp	SHORT $LN372@ParseNode
$LN17@ParseNode:

; 173  :     }
; 174  :     case BymlFile::Type::Bool:
; 175  :     {
; 176  :         Node.SetValue<bool>(Reader.ReadUInt32(mBigEndian));

	movzx	edx, BYTE PTR [rsi+216]
	mov	rcx, rdi
	call	?ReadUInt32@BinaryVectorReader@@QEAAI_N@Z ; BinaryVectorReader::ReadUInt32
	test	eax, eax
	setne	bl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1766 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

	mov	rax, QWORD PTR Node$[rbp-256]
	cmp	rax, QWORD PTR Node$[rbp-248]
	je	SHORT $LN344@ParseNode

; 1767 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1768 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1769 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1770 :             return;
; 1771 :         }
; 1772 : 
; 1773 :         _My_data._Orphan_all();
; 1774 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1775 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1776 :         _Mylast = _Myfirst;

	mov	QWORD PTR Node$[rbp-248], rax
$LN344@ParseNode:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 33   :     this->m_Value.resize(sizeof(Value));

	mov	edx, 1
	lea	rcx, QWORD PTR Node$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 34   :     memcpy(this->m_Value.data(), &Value, sizeof(Value));

	mov	rax, QWORD PTR Node$[rbp-256]
	mov	BYTE PTR [rax], bl

; 177  :         break;

	jmp	$LN161@ParseNode
$LN18@ParseNode:

; 181  :         Node.SetValue<std::string>(this->m_StringTable[Reader.ReadUInt32(mBigEndian)]);

	movzx	edx, BYTE PTR [rsi+216]
	mov	rcx, rdi
	call	?ReadUInt32@BinaryVectorReader@@QEAAI_N@Z ; BinaryVectorReader::ReadUInt32
	mov	edx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	shl	rdx, 5
	add	rdx, QWORD PTR [rsi+48]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 181  :         Node.SetValue<std::string>(this->m_StringTable[Reader.ReadUInt32(mBigEndian)]);

	lea	rcx, QWORD PTR $T9[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	lea	rcx, QWORD PTR Node$[rbp-256]
	call	??$SetValue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Node@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; BymlFile::Node::SetValue<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 182  :         break;

	jmp	$LN161@ParseNode
$LN19@ParseNode:

; 183  :     }
; 184  :     case BymlFile::Type::Array:
; 185  :     {
; 186  :         uint32_t LocalOffset = Reader.ReadUInt32(mBigEndian);

	movzx	edx, BYTE PTR [rsi+216]
	mov	rcx, rdi
	call	?ReadUInt32@BinaryVectorReader@@QEAAI_N@Z ; BinaryVectorReader::ReadUInt32
	mov	r13d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 12   : 		this->m_Offset = Offset - 1;

	mov	DWORD PTR [rdi+8], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 188  :         uint32_t Size = Reader.ReadUInt24(mBigEndian);

	movzx	edx, BYTE PTR [rsi+216]
	mov	rcx, rdi
	call	?ReadUInt24@BinaryVectorReader@@QEAAI_N@Z ; BinaryVectorReader::ReadUInt24
	mov	r14d, eax

; 126  :     return Value + (Size - Value % Size) % Size;

	mov	ecx, eax
	and	ecx, -2147483645			; ffffffff80000003H
	jge	SHORT $LN362@ParseNode
	dec	ecx
	or	ecx, -4
	inc	ecx
$LN362@ParseNode:
	mov	eax, 4
	sub	eax, ecx
	and	eax, -2147483645			; ffffffff80000003H
	jge	SHORT $LN361@ParseNode
	dec	eax
	or	eax, -4
	inc	eax
$LN361@ParseNode:

; 189  :         uint32_t ValueArrayOffset = LocalOffset + 4 + this->AlignUp(Size, 4);

	lea	r15d, DWORD PTR [r14+rax]
	add	r15d, 4
	add	r15d, r13d

; 190  :         Node.GetChildren().resize(Size);

	mov	rdx, r14
	lea	rcx, QWORD PTR Node$[rbp-192]
	call	?resize@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAX_K@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::resize

; 191  :         for (uint32_t i = 0; i < Size; i++)

	xor	ebx, ebx
	test	r14d, r14d
	je	SHORT $LN365@ParseNode

; 183  :     }
; 184  :     case BymlFile::Type::Array:
; 185  :     {
; 186  :         uint32_t LocalOffset = Reader.ReadUInt32(mBigEndian);

	add	r13d, 3
	npad	8
$LL6@ParseNode:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 12   : 		this->m_Offset = Offset - 1;

	lea	eax, DWORD PTR [rbx+r13]
	mov	DWORD PTR [rdi+8], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 194  :             this->ParseNode(Reader, ValueArrayOffset + 4 * i, static_cast<BymlFile::Type>(Reader.ReadUInt8()), std::to_string(i), &Node, i);

	mov	edx, ebx
	lea	rcx, QWORD PTR $T8[rbp-256]
	call	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z ; std::to_string
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 44   : 	this->m_Offset++;

	movsxd	rdx, DWORD PTR [rdi+8]
	lea	ecx, DWORD PTR [rdx+1]
	mov	DWORD PTR [rdi+8], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1883 :         auto& _My_data = _Mypair._Myval2;

	mov	rcx, QWORD PTR [rdi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 45   : 	return this->m_Bytes[this->m_Offset];

	mov	r8, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rdx, QWORD PTR [rcx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 194  :             this->ParseNode(Reader, ValueArrayOffset + 4 * i, static_cast<BymlFile::Type>(Reader.ReadUInt8()), std::to_string(i), &Node, i);

	mov	DWORD PTR [rsp+48], ebx
	lea	rcx, QWORD PTR Node$[rbp-256]
	mov	QWORD PTR [rsp+40], rcx
	mov	QWORD PTR [rsp+32], rax
	movzx	r9d, BYTE PTR [r8+rdx+1]
	mov	r8d, r15d
	mov	rdx, rdi
	mov	rcx, rsi
	call	?ParseNode@BymlFile@@AEAAXAEAVBinaryVectorReader@@HW4Type@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVNode@1@I@Z ; BymlFile::ParseNode

; 191  :         for (uint32_t i = 0; i < Size; i++)

	inc	ebx
	add	r15d, 4
	cmp	ebx, r14d
	jb	SHORT $LL6@ParseNode
$LN365@ParseNode:

; 216  :     }
; 217  : 
; 218  :     Parent->GetChildren()[ChildIndex] = Node;

	xor	r13d, r13d
$LN161@ParseNode:
	mov	eax, DWORD PTR ChildIndex$GSCopy$1$[rsp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	imul	rbx, rax, 88				; 00000058H
	mov	rax, QWORD PTR Parent$GSCopy$1$[rsp]
	add	rbx, QWORD PTR [rax+64]

; 1483 :         if (this == _STD addressof(_Right)) {

	lea	rax, QWORD PTR Node$[rbp-256]
	cmp	rbx, rax
	je	SHORT $LN75@ParseNode

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	r8, QWORD PTR Node$[rbp-248]
	mov	rdx, QWORD PTR Node$[rbp-256]
	sub	r8, rdx
	mov	rcx, rbx
	call	??$_Assign_counted_range@PEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAXPEAE_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Assign_counted_range<unsigned char *>
$LN75@ParseNode:
	movzx	eax, BYTE PTR Node$[rbp-232]
	mov	BYTE PTR [rbx+24], al
	lea	rcx, QWORD PTR [rbx+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3156 :         if (this == _STD addressof(_Right)) {

	lea	rax, QWORD PTR Node$[rbp-224]
	cmp	rcx, rax
	je	SHORT $LN78@ParseNode

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR Node$[rbp-224]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR Node$[rbp-200], 16
	cmovae	rdx, QWORD PTR Node$[rbp-224]

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR Node$[rbp-208]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN78@ParseNode:
	lea	rcx, QWORD PTR [rbx+64]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1483 :         if (this == _STD addressof(_Right)) {

	lea	rax, QWORD PTR Node$[rbp-192]
	cmp	rcx, rax
	je	SHORT $LN86@ParseNode

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	r8, QWORD PTR Node$[rbp-184]
	mov	rdx, QWORD PTR Node$[rbp-192]
	sub	r8, rdx
	sar	r8, 3
	mov	rax, 3353953467947191203		; 2e8ba2e8ba2e8ba3H
	imul	r8, rax
	call	??$_Assign_counted_range@PEAVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAXPEAVNode@BymlFile@@_K@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Assign_counted_range<BymlFile::Node *>
	npad	1
$LN86@ParseNode:

; 767  :         _Tidy();

	lea	rcx, QWORD PTR Node$[rbp-192]
	call	?_Tidy@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAXXZ ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR Node$[rbp-224]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR Node$[rbp-256]
	test	rcx, rcx
	je	$LN48@ParseNode

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR Node$[rbp-240]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	$LN66@ParseNode

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	$LN66@ParseNode
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN20@ParseNode:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 200  :         uint32_t LocalOffset = Reader.ReadUInt32(mBigEndian);

	movzx	edx, BYTE PTR [rsi+216]
	mov	rcx, rdi
	call	?ReadUInt32@BinaryVectorReader@@QEAAI_N@Z ; BinaryVectorReader::ReadUInt32
	mov	ebx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 12   : 		this->m_Offset = Offset - 1;

	mov	DWORD PTR [rdi+8], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 202  :         uint32_t Size = Reader.ReadUInt24(mBigEndian);

	movzx	edx, BYTE PTR [rsi+216]
	mov	rcx, rdi
	call	?ReadUInt24@BinaryVectorReader@@QEAAI_N@Z ; BinaryVectorReader::ReadUInt24
	mov	r15d, eax

; 203  :         Node.GetChildren().resize(Size);

	mov	edx, eax
	lea	rcx, QWORD PTR Node$[rbp-192]
	call	?resize@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAX_K@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::resize

; 204  :         for (uint32_t i = 0; i < Size; i++)

	mov	r14d, r13d
	test	r15d, r15d
	je	$LN161@ParseNode

; 200  :         uint32_t LocalOffset = Reader.ReadUInt32(mBigEndian);

	add	ebx, 5
	npad	9
$LL9@ParseNode:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 12   : 		this->m_Offset = Offset - 1;

	lea	ecx, DWORD PTR [rbx-2]
	mov	DWORD PTR [rdi+8], ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 208  :             uint32_t StringOffset = Reader.ReadUInt24(mBigEndian);

	movzx	r8d, BYTE PTR [rsi+216]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 67   : 	this->m_Offset += 3;

	lea	eax, DWORD PTR [rbx+1]
	mov	DWORD PTR [rdi+8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1883 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR [rdi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 68   : 	uint32_t Value = (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 2])) |

	movsxd	rdx, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 68   : 	uint32_t Value = (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 2])) |

	movsxd	rax, ebx
	movzx	r9d, BYTE PTR [rdx+rcx+1]
	shl	r9d, 8
	movzx	eax, BYTE PTR [rax+rcx]
	or	r9d, eax
	shl	r9d, 8
	movzx	eax, BYTE PTR [rdx+rcx-1]
	or	r9d, eax

; 69   : 		(static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 1]) << 8) |
; 70   : 		(static_cast<uint32_t>(this->m_Bytes[this->m_Offset]) << 16);
; 71   : 	return !BigEndian ? Value : (_byteswap_ulong(Value) >> 8);

	test	r8b, r8b
	je	SHORT $LN243@ParseNode
	bswap	r9d
	shr	r9d, 8
$LN243@ParseNode:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 210  :             this->ParseNode(Reader, EntryOffset + 4, static_cast<BymlFile::Type>(Reader.ReadUInt8()), this->m_HashKeyTable[StringOffset], &Node, i);

	mov	edx, r9d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	shl	rdx, 5
	add	rdx, QWORD PTR [rsi+24]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 210  :             this->ParseNode(Reader, EntryOffset + 4, static_cast<BymlFile::Type>(Reader.ReadUInt8()), this->m_HashKeyTable[StringOffset], &Node, i);

	lea	rcx, QWORD PTR $T7[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 44   : 	this->m_Offset++;

	movsxd	rdx, DWORD PTR [rdi+8]
	lea	ecx, DWORD PTR [rdx+1]
	mov	DWORD PTR [rdi+8], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1883 :         auto& _My_data = _Mypair._Myval2;

	mov	rcx, QWORD PTR [rdi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 45   : 	return this->m_Bytes[this->m_Offset];

	mov	r8, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rdx, QWORD PTR [rcx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 45   : 	return this->m_Bytes[this->m_Offset];

	movzx	r9d, BYTE PTR [r8+rdx+1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 210  :             this->ParseNode(Reader, EntryOffset + 4, static_cast<BymlFile::Type>(Reader.ReadUInt8()), this->m_HashKeyTable[StringOffset], &Node, i);

	lea	r8d, DWORD PTR [rbx+3]
	mov	DWORD PTR [rsp+48], r14d
	lea	rcx, QWORD PTR Node$[rbp-256]
	mov	QWORD PTR [rsp+40], rcx
	mov	QWORD PTR [rsp+32], rax
	mov	rdx, rdi
	mov	rcx, rsi
	call	?ParseNode@BymlFile@@AEAAXAEAVBinaryVectorReader@@HW4Type@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVNode@1@I@Z ; BymlFile::ParseNode

; 204  :         for (uint32_t i = 0; i < Size; i++)

	inc	r14d
	add	ebx, 8
	cmp	r14d, r15d
	jb	$LL9@ParseNode

; 211  :         }
; 212  :         break;

	jmp	$LN161@ParseNode
$LN21@ParseNode:

; 215  :         Logger::Error("BymlDecoder", "Unsupported node type: " + std::to_string((int)Type));

	lea	rbx, QWORD PTR $T4[rsp]
	mov	QWORD PTR $T13[rbp-256], rbx
	mov	edx, r14d
	lea	rcx, QWORD PTR $T6[rbp-256]
	call	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ; std::to_string
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3537 :         return insert(_Off, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r9d, 23
	lea	r8, OFFSET FLAT:??_C@_0BI@HCAOJHPJ@Unsupported?5node?5type?3?5@
	mov	rcx, rax
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T4[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T4[rbp-240], r13

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T4[rbp-232], r13

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T4[rsp], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T4[rbp-240], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 215  :         Logger::Error("BymlDecoder", "Unsupported node type: " + std::to_string((int)Type));

	mov	QWORD PTR [rax+16], r13
	mov	QWORD PTR [rax+24], 15
	mov	BYTE PTR [rax], 0
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T2[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T2[rsp+16], r13

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T2[rsp+24], r13

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 11
	lea	rdx, OFFSET FLAT:??_C@_0M@EFFJMBCP@BymlDecoder@
	lea	rcx, QWORD PTR $T2[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 215  :         Logger::Error("BymlDecoder", "Unsupported node type: " + std::to_string((int)Type));

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T2[rsp]
	call	?Error@Logger@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; Logger::Error
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T6[rbp-232]
	cmp	rdx, 16
	jb	$LN161@ParseNode

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T6[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN173@ParseNode

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN173@ParseNode
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN173@ParseNode:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 191  :         for (uint32_t i = 0; i < Size; i++)

	jmp	$LN161@ParseNode
$LN66@ParseNode:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	movdqa	XMMWORD PTR Node$[rbp-256], xmm0

; 2050 :             _Mylast  = nullptr;
; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR Node$[rbp-240], r13
$LN48@ParseNode:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 219  : }

	mov	rcx, r12
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+432]
	add	rsp, 352				; 00000160H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN366@ParseNode:
	npad	3
$LN364@ParseNode:
	DD	$LN18@ParseNode
	DD	$LN19@ParseNode
	DD	$LN20@ParseNode
	DD	$LN17@ParseNode
	DD	$LN14@ParseNode
	DD	$LN12@ParseNode
	DD	$LN13@ParseNode
	DD	$LN16@ParseNode
	DD	$LN15@ParseNode
	DD	$LN11@ParseNode
	DD	$LN21@ParseNode
$LN363@ParseNode:
	DB	0
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	1
	DB	2
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	3
	DB	4
	DB	5
	DB	6
	DB	7
	DB	8
	DB	9
?ParseNode@BymlFile@@AEAAXAEAVBinaryVectorReader@@HW4Type@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVNode@1@I@Z ENDP ; BymlFile::ParseNode
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
ChildIndex$GSCopy$1$ = 64
Parent$GSCopy$1$ = 72
$T1 = 72
$T2 = 80
$T3 = 80
$T4 = 112
$T5 = 112
$T6 = 144
$T7 = 144
$T8 = 144
$T9 = 144
$T10 = 184
Key$GSCopy$ = 216
Temp$11 = 224
Value$ = 224
$T12 = 224
$T13 = 224
Node$ = 240
__$ArrayPad$ = 336
this$ = 416
Reader$ = 424
Offset$ = 432
Type$ = 440
Key$ = 448
Parent$ = 456
ChildIndex$ = 464
?dtor$0@?0??ParseNode@BymlFile@@AEAAXAEAVBinaryVectorReader@@HW4Type@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVNode@1@I@Z@4HA PROC ; `BymlFile::ParseNode'::`1'::dtor$0
	mov	rcx, QWORD PTR Key$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??ParseNode@BymlFile@@AEAAXAEAVBinaryVectorReader@@HW4Type@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVNode@1@I@Z@4HA ENDP ; `BymlFile::ParseNode'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
ChildIndex$GSCopy$1$ = 64
Parent$GSCopy$1$ = 72
$T1 = 72
$T2 = 80
$T3 = 80
$T4 = 112
$T5 = 112
$T6 = 144
$T7 = 144
$T8 = 144
$T9 = 144
$T10 = 184
Key$GSCopy$ = 216
Temp$11 = 224
Value$ = 224
$T12 = 224
$T13 = 224
Node$ = 240
__$ArrayPad$ = 336
this$ = 416
Reader$ = 424
Offset$ = 432
Type$ = 440
Key$ = 448
Parent$ = 456
ChildIndex$ = 464
?dtor$1@?0??ParseNode@BymlFile@@AEAAXAEAVBinaryVectorReader@@HW4Type@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVNode@1@I@Z@4HA PROC ; `BymlFile::ParseNode'::`1'::dtor$1
	mov	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??ParseNode@BymlFile@@AEAAXAEAVBinaryVectorReader@@HW4Type@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVNode@1@I@Z@4HA ENDP ; `BymlFile::ParseNode'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
ChildIndex$GSCopy$1$ = 64
Parent$GSCopy$1$ = 72
$T1 = 72
$T2 = 80
$T3 = 80
$T4 = 112
$T5 = 112
$T6 = 144
$T7 = 144
$T8 = 144
$T9 = 144
$T10 = 184
Key$GSCopy$ = 216
Temp$11 = 224
Value$ = 224
$T12 = 224
$T13 = 224
Node$ = 240
__$ArrayPad$ = 336
this$ = 416
Reader$ = 424
Offset$ = 432
Type$ = 440
Key$ = 448
Parent$ = 456
ChildIndex$ = 464
?dtor$19@?0??ParseNode@BymlFile@@AEAAXAEAVBinaryVectorReader@@HW4Type@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVNode@1@I@Z@4HA PROC ; `BymlFile::ParseNode'::`1'::dtor$19
	mov	rcx, QWORD PTR $T12[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$19@?0??ParseNode@BymlFile@@AEAAXAEAVBinaryVectorReader@@HW4Type@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVNode@1@I@Z@4HA ENDP ; `BymlFile::ParseNode'::`1'::dtor$19
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
ChildIndex$GSCopy$1$ = 64
Parent$GSCopy$1$ = 72
$T1 = 72
$T2 = 80
$T3 = 80
$T4 = 112
$T5 = 112
$T6 = 144
$T7 = 144
$T8 = 144
$T9 = 144
$T10 = 184
Key$GSCopy$ = 216
Temp$11 = 224
Value$ = 224
$T12 = 224
$T13 = 224
Node$ = 240
__$ArrayPad$ = 336
this$ = 416
Reader$ = 424
Offset$ = 432
Type$ = 440
Key$ = 448
Parent$ = 456
ChildIndex$ = 464
?dtor$20@?0??ParseNode@BymlFile@@AEAAXAEAVBinaryVectorReader@@HW4Type@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVNode@1@I@Z@4HA PROC ; `BymlFile::ParseNode'::`1'::dtor$20
	lea	rcx, QWORD PTR Node$[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$20@?0??ParseNode@BymlFile@@AEAAXAEAVBinaryVectorReader@@HW4Type@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVNode@1@I@Z@4HA ENDP ; `BymlFile::ParseNode'::`1'::dtor$20
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
ChildIndex$GSCopy$1$ = 64
Parent$GSCopy$1$ = 72
$T1 = 72
$T2 = 80
$T3 = 80
$T4 = 112
$T5 = 112
$T6 = 144
$T7 = 144
$T8 = 144
$T9 = 144
$T10 = 184
Key$GSCopy$ = 216
Temp$11 = 224
Value$ = 224
$T12 = 224
$T13 = 224
Node$ = 240
__$ArrayPad$ = 336
this$ = 416
Reader$ = 424
Offset$ = 432
Type$ = 440
Key$ = 448
Parent$ = 456
ChildIndex$ = 464
?dtor$4@?0??ParseNode@BymlFile@@AEAAXAEAVBinaryVectorReader@@HW4Type@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVNode@1@I@Z@4HA PROC ; `BymlFile::ParseNode'::`1'::dtor$4
	lea	rcx, QWORD PTR Node$[rdx]
	jmp	??1Node@BymlFile@@QEAA@XZ
?dtor$4@?0??ParseNode@BymlFile@@AEAAXAEAVBinaryVectorReader@@HW4Type@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVNode@1@I@Z@4HA ENDP ; `BymlFile::ParseNode'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
ChildIndex$GSCopy$1$ = 64
Parent$GSCopy$1$ = 72
$T1 = 72
$T2 = 80
$T3 = 80
$T4 = 112
$T5 = 112
$T6 = 144
$T7 = 144
$T8 = 144
$T9 = 144
$T10 = 184
Key$GSCopy$ = 216
Temp$11 = 224
Value$ = 224
$T12 = 224
$T13 = 224
Node$ = 240
__$ArrayPad$ = 336
this$ = 416
Reader$ = 424
Offset$ = 432
Type$ = 440
Key$ = 448
Parent$ = 456
ChildIndex$ = 464
?dtor$8@?0??ParseNode@BymlFile@@AEAAXAEAVBinaryVectorReader@@HW4Type@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVNode@1@I@Z@4HA PROC ; `BymlFile::ParseNode'::`1'::dtor$8
	lea	rcx, QWORD PTR $T6[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$8@?0??ParseNode@BymlFile@@AEAAXAEAVBinaryVectorReader@@HW4Type@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVNode@1@I@Z@4HA ENDP ; `BymlFile::ParseNode'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
ChildIndex$GSCopy$1$ = 64
Parent$GSCopy$1$ = 72
$T1 = 72
$T2 = 80
$T3 = 80
$T4 = 112
$T5 = 112
$T6 = 144
$T7 = 144
$T8 = 144
$T9 = 144
$T10 = 184
Key$GSCopy$ = 216
Temp$11 = 224
Value$ = 224
$T12 = 224
$T13 = 224
Node$ = 240
__$ArrayPad$ = 336
this$ = 416
Reader$ = 424
Offset$ = 432
Type$ = 440
Key$ = 448
Parent$ = 456
ChildIndex$ = 464
?dtor$9@?0??ParseNode@BymlFile@@AEAAXAEAVBinaryVectorReader@@HW4Type@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVNode@1@I@Z@4HA PROC ; `BymlFile::ParseNode'::`1'::dtor$9
	mov	rcx, QWORD PTR $T13[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$9@?0??ParseNode@BymlFile@@AEAAXAEAVBinaryVectorReader@@HW4Type@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVNode@1@I@Z@4HA ENDP ; `BymlFile::ParseNode'::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
;	COMDAT ?GetType@BymlFile@@QEAAAEAW4Type@1@XZ
_TEXT	SEGMENT
this$ = 8
?GetType@BymlFile@@QEAAAEAW4Type@1@XZ PROC		; BymlFile::GetType, COMDAT

; 228  :     return this->m_Type;

	lea	rax, QWORD PTR [rcx+72]

; 229  : }

	ret	0
?GetType@BymlFile@@QEAAAEAW4Type@1@XZ ENDP		; BymlFile::GetType
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
;	COMDAT ?IsNumber@BymlFile@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
this$dead$ = 64
str$ = 72
?IsNumber@BymlFile@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; BymlFile::IsNumber, COMDAT

; 255  : {

$LN51:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4228 :         return _Mypair._Myval2._Mysize == 0;

	mov	rax, QWORD PTR [rdx+16]
	test	rax, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 256  :     if (str.empty())

	je	SHORT $LN10@IsNumber

; 257  :     {
; 258  :         return false;
; 259  :     }
; 260  : 
; 261  :     bool hasDigit = false;

	xor	sil, sil

; 262  :     bool hasDecimal = false;

	xor	r14b, r14b

; 263  :     bool hasSign = false;

	xor	bpl, bpl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN36@IsNumber

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdi, QWORD PTR [rdx]
	mov	rcx, rdi
	mov	rdx, rdi
	jmp	SHORT $LN26@IsNumber
$LN36@IsNumber:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 256  :     if (str.empty())

	mov	rdi, rdx
	mov	rcx, rdx
$LN26@IsNumber:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3949 :         return _Mypair._Myval2._Myptr() + _Mypair._Myval2._Mysize;

	lea	r15, QWORD PTR [rax+rcx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 265  :     for (char c : str)

	cmp	rdx, r15
	je	SHORT $LN3@IsNumber
	npad	5
$LL4@IsNumber:
	movsx	ebx, BYTE PTR [rdi]

; 266  :     {
; 267  :         if (isdigit(c))

	mov	ecx, ebx
	call	QWORD PTR __imp_isdigit
	test	eax, eax
	je	SHORT $LN6@IsNumber

; 268  :         {
; 269  :             hasDigit = true;

	mov	sil, 1

; 270  :         }

	jmp	SHORT $LN2@IsNumber
$LN6@IsNumber:

; 271  :         else if (c == '.' && !hasDecimal)

	cmp	bl, 46					; 0000002eH
	jne	SHORT $LN8@IsNumber
	test	r14b, r14b
	jne	SHORT $LN10@IsNumber

; 272  :         {
; 273  :             hasDecimal = true;

	mov	r14b, 1

; 274  :         }

	jmp	SHORT $LN2@IsNumber
$LN8@IsNumber:

; 275  :         else if ((c == '-' || c == '+') && !hasSign && !hasDigit)

	sub	bl, 43					; 0000002bH
	test	bl, 253					; 000000fdH
	jne	SHORT $LN10@IsNumber
	test	bpl, bpl
	jne	SHORT $LN10@IsNumber
	test	sil, sil
	jne	SHORT $LN10@IsNumber

; 276  :         {
; 277  :             hasSign = true;

	mov	bpl, 1
$LN2@IsNumber:

; 265  :     for (char c : str)

	inc	rdi
	cmp	rdi, r15
	jne	SHORT $LL4@IsNumber
$LN3@IsNumber:

; 282  :         }
; 283  :     }
; 284  : 
; 285  :     return hasDigit;

	movzx	eax, sil
	jmp	SHORT $LN1@IsNumber
$LN10@IsNumber:

; 278  :         }
; 279  :         else
; 280  :         {
; 281  :             return false;

	xor	al, al
$LN1@IsNumber:

; 286  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
?IsNumber@BymlFile@@AEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; BymlFile::IsNumber
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
;	COMDAT ?GenerateHashKeyTable@BymlFile@@QEAAXPEAVNode@1@@Z
_TEXT	SEGMENT
this$GSCopy$1$ = 32
Node$GSCopy$1$ = 40
str$ = 48
__$ArrayPad$ = 80
this$ = 160
Node$ = 168
?GenerateHashKeyTable@BymlFile@@QEAAXPEAVNode@1@@Z PROC	; BymlFile::GenerateHashKeyTable, COMDAT

; 289  : {

$LN158:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	QWORD PTR Node$GSCopy$1$[rsp], rdx
	mov	rbx, rcx
	mov	QWORD PTR this$GSCopy$1$[rsp], rcx

; 290  :     std::string str = Node->GetKey();

	add	rdx, 32					; 00000020H
	lea	rcx, QWORD PTR str$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4228 :         return _Mypair._Myval2._Mysize == 0;

	mov	r12, QWORD PTR str$[rsp+16]
	test	r12, r12
	sete	sil
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 291  :     if (!str.empty())

	mov	r13, QWORD PTR str$[rsp+24]
	mov	rbp, QWORD PTR str$[rsp]
	test	r12, r12
	je	$LN151@GenerateHa
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 43   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	rdi, QWORD PTR [rbx+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 5851 :         _Seek_wrapped(_First, _STD _Find_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val));

	mov	rbx, QWORD PTR [rbx+24]
$LN154@GenerateHa:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	cmp	rbx, rdi
	je	SHORT $LN142@GenerateHa
	lea	rdx, QWORD PTR str$[rsp]

; 2236 :         if (_Large_string_engaged()) {

	cmp	r13, 16
	cmovae	rdx, rbp

; 4584 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	r8, QWORD PTR [rbx+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rbx

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rbx+24], 16
	jb	SHORT $LN41@GenerateHa

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rbx]
$LN41@GenerateHa:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	r8, r12
	jne	SHORT $LN47@GenerateHa

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	je	SHORT $LN132@GenerateHa
$LN47@GenerateHa:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 5836 :     for (; _First != _Last; ++_First) {

	add	rbx, 32					; 00000020H
	jmp	SHORT $LN154@GenerateHa
$LN132@GenerateHa:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 293  :         if (std::find(this->m_HashKeyTable.begin(), this->m_HashKeyTable.end(), str) == this->m_HashKeyTable.end() && !this->IsNumber(str))

	cmp	rbx, rdi
	jne	$LN151@GenerateHa
$LN142@GenerateHa:

; 256  :     if (str.empty())

	test	sil, sil
	jne	SHORT $LN144@GenerateHa

; 257  :     {
; 258  :         return false;
; 259  :     }
; 260  : 
; 261  :     bool hasDigit = false;
; 262  :     bool hasDecimal = false;

	xor	r15b, r15b

; 263  :     bool hasSign = false;

	xor	r14b, r14b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rdi, QWORD PTR str$[rsp]

; 2236 :         if (_Large_string_engaged()) {

	cmp	r13, 16
	cmovae	rdi, rbp

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR str$[rsp]

; 2236 :         if (_Large_string_engaged()) {

	cmovae	rax, rbp

; 3949 :         return _Mypair._Myval2._Myptr() + _Mypair._Myval2._Mysize;

	add	r12, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 265  :     for (char c : str)

	cmp	rdi, r12
	je	SHORT $LN144@GenerateHa
	npad	1
$LL62@GenerateHa:
	movsx	ebx, BYTE PTR [rdi]

; 266  :     {
; 267  :         if (isdigit(c))

	mov	ecx, ebx
	call	QWORD PTR __imp_isdigit
	test	eax, eax
	je	SHORT $LN64@GenerateHa

; 268  :         {
; 269  :             hasDigit = true;

	mov	sil, 1

; 270  :         }

	jmp	SHORT $LN60@GenerateHa
$LN64@GenerateHa:

; 271  :         else if (c == '.' && !hasDecimal)

	cmp	bl, 46					; 0000002eH
	jne	SHORT $LN66@GenerateHa
	test	r15b, r15b
	jne	SHORT $LN144@GenerateHa

; 272  :         {
; 273  :             hasDecimal = true;

	mov	r15b, 1

; 274  :         }

	jmp	SHORT $LN60@GenerateHa
$LN66@GenerateHa:

; 275  :         else if ((c == '-' || c == '+') && !hasSign && !hasDigit)

	sub	bl, 43					; 0000002bH
	test	bl, 253					; 000000fdH
	jne	SHORT $LN144@GenerateHa
	test	r14b, r14b
	jne	SHORT $LN144@GenerateHa
	test	sil, sil
	jne	SHORT $LN144@GenerateHa

; 276  :         {
; 277  :             hasSign = true;

	mov	r14b, 1
$LN60@GenerateHa:

; 265  :     for (char c : str)

	inc	rdi
	cmp	rdi, r12
	jne	SHORT $LL62@GenerateHa

; 293  :         if (std::find(this->m_HashKeyTable.begin(), this->m_HashKeyTable.end(), str) == this->m_HashKeyTable.end() && !this->IsNumber(str))

	test	sil, sil
	jne	SHORT $LN151@GenerateHa
$LN144@GenerateHa:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	r12, QWORD PTR this$GSCopy$1$[rsp]
	mov	rax, QWORD PTR [r12+32]
	cmp	rax, QWORD PTR [r12+40]
	je	SHORT $LN91@GenerateHa
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	lea	rdx, QWORD PTR str$[rsp]
	mov	rcx, rax
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 806  :         ++_Mylast;

	add	QWORD PTR [r12+32], 32			; 00000020H

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	mov	r13, QWORD PTR str$[rsp+24]
	mov	rbp, QWORD PTR str$[rsp]
	jmp	SHORT $LN90@GenerateHa
$LN91@GenerateHa:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR str$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR [r12+24]
	call	??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 291  :     if (!str.empty())

	mov	r13, QWORD PTR str$[rsp+24]
	mov	rbp, QWORD PTR str$[rsp]

; 293  :         if (std::find(this->m_HashKeyTable.begin(), this->m_HashKeyTable.end(), str) == this->m_HashKeyTable.end() && !this->IsNumber(str))

	jmp	SHORT $LN90@GenerateHa
$LN151@GenerateHa:

; 294  :         {
; 295  :             this->m_HashKeyTable.push_back(str);
; 296  :         }
; 297  :     }
; 298  : 
; 299  :     for (BymlFile::Node& Nodes : Node->GetChildren())

	mov	r12, QWORD PTR this$GSCopy$1$[rsp]
$LN90@GenerateHa:
	mov	rbx, QWORD PTR Node$GSCopy$1$[rsp]
	mov	rdi, QWORD PTR [rbx+72]
	mov	rbx, QWORD PTR [rbx+64]
	cmp	rbx, rdi
	je	SHORT $LN3@GenerateHa
	npad	6
$LL4@GenerateHa:

; 300  :     {
; 301  :         this->GenerateHashKeyTable(&Nodes);

	mov	rdx, rbx
	mov	rcx, r12
	call	?GenerateHashKeyTable@BymlFile@@QEAAXPEAVNode@1@@Z ; BymlFile::GenerateHashKeyTable

; 294  :         {
; 295  :             this->m_HashKeyTable.push_back(str);
; 296  :         }
; 297  :     }
; 298  : 
; 299  :     for (BymlFile::Node& Nodes : Node->GetChildren())

	add	rbx, 88					; 00000058H
	cmp	rbx, rdi
	jne	SHORT $LL4@GenerateHa
$LN3@GenerateHa:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	r13, 16

; 4832 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN111@GenerateHa

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	lea	rdx, QWORD PTR [r13+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rbp

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN123@GenerateHa

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rbp, QWORD PTR [rbp-8]
	sub	rax, rbp

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN123@GenerateHa
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN123@GenerateHa:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rbp
	call	??3@YAXPEAX_K@Z				; operator delete
$LN111@GenerateHa:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 303  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+176]
	add	rsp, 96					; 00000060H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN152@GenerateHa:
?GenerateHashKeyTable@BymlFile@@QEAAXPEAVNode@1@@Z ENDP	; BymlFile::GenerateHashKeyTable
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$GSCopy$1$ = 32
Node$GSCopy$1$ = 40
str$ = 48
__$ArrayPad$ = 80
this$ = 160
Node$ = 168
?dtor$0@?0??GenerateHashKeyTable@BymlFile@@QEAAXPEAVNode@1@@Z@4HA PROC ; `BymlFile::GenerateHashKeyTable'::`1'::dtor$0
	lea	rcx, QWORD PTR str$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??GenerateHashKeyTable@BymlFile@@QEAAXPEAVNode@1@@Z@4HA ENDP ; `BymlFile::GenerateHashKeyTable'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
;	COMDAT ?GenerateStringTable@BymlFile@@QEAAXPEAVNode@1@@Z
_TEXT	SEGMENT
str$1 = 32
__$ArrayPad$ = 64
this$ = 128
Node$ = 136
?GenerateStringTable@BymlFile@@QEAAXPEAVNode@1@@Z PROC	; BymlFile::GenerateStringTable, COMDAT

; 306  : {

$LN132:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r15, rdx
	mov	rsi, rcx

; 307  :     if (Node->GetType() == BymlFile::Type::StringIndex)

	cmp	BYTE PTR [rdx+24], 160			; 000000a0H
	jne	$LN95@GenerateSt

; 308  :     {
; 309  :         std::string str = Node->GetValue<std::string>();

	lea	rdx, QWORD PTR str$1[rsp]
	mov	rcx, r15
	call	??$GetValue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Node@BymlFile@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; BymlFile::Node::GetValue<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	npad	1

; 310  :         if (str.empty())

	mov	rbp, QWORD PTR str$1[rsp+16]
	test	rbp, rbp
	jne	SHORT $LN6@GenerateSt
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rax, QWORD PTR [rsi+56]
	cmp	rax, QWORD PTR [rsi+64]
	je	SHORT $LN16@GenerateSt
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	lea	rdx, QWORD PTR str$1[rsp]
	mov	rcx, rax
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 806  :         ++_Mylast;

	add	QWORD PTR [rsi+56], 32			; 00000020H

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN74@GenerateSt
$LN16@GenerateSt:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	rdx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 313  :         }

	jmp	SHORT $LN127@GenerateSt
$LN6@GenerateSt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 43   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	rdi, QWORD PTR [rsi+56]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 5851 :         _Seek_wrapped(_First, _STD _Find_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val));

	mov	rbx, QWORD PTR [rsi+48]
$LN129@GenerateSt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	cmp	rbx, rdi
	je	SHORT $LN122@GenerateSt
	lea	rdx, QWORD PTR str$1[rsp]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR str$1[rsp+24], 16
	cmovae	rdx, QWORD PTR str$1[rsp]

; 4584 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	r8, QWORD PTR [rbx+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rbx

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rbx+24], 16
	jb	SHORT $LN54@GenerateSt

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rbx]
$LN54@GenerateSt:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	r8, rbp
	jne	SHORT $LN60@GenerateSt

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	je	SHORT $LN115@GenerateSt
$LN60@GenerateSt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 5836 :     for (; _First != _Last; ++_First) {

	add	rbx, 32					; 00000020H
	jmp	SHORT $LN129@GenerateSt
$LN115@GenerateSt:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 314  :         else if (std::find(this->m_StringTable.begin(), this->m_StringTable.end(), str) == this->m_StringTable.end())

	cmp	rbx, rdi
	jne	SHORT $LN74@GenerateSt
$LN122@GenerateSt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	cmp	rdi, QWORD PTR [rsi+64]
	je	SHORT $LN75@GenerateSt
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	lea	rdx, QWORD PTR str$1[rsp]
	mov	rcx, rdi
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 806  :         ++_Mylast;

	add	QWORD PTR [rsi+56], 32			; 00000020H

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN74@GenerateSt
$LN75@GenerateSt:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	rdx, rdi
$LN127@GenerateSt:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 318  :     }

	lea	r8, QWORD PTR str$1[rsp]
	lea	rcx, QWORD PTR [rsi+48]
	call	??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
	npad	1
$LN74@GenerateSt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR str$1[rsp+24]
	cmp	rdx, 16

; 4832 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN95@GenerateSt

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR str$1[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN107@GenerateSt

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN107@GenerateSt
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN107@GenerateSt:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN95@GenerateSt:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 320  :     for (BymlFile::Node& Nodes : Node->GetChildren())

	mov	rdi, QWORD PTR [r15+72]
	mov	rbx, QWORD PTR [r15+64]
	cmp	rbx, rdi
	je	SHORT $LN3@GenerateSt
	npad	5
$LL4@GenerateSt:

; 321  :     {
; 322  :         this->GenerateStringTable(&Nodes);

	mov	rdx, rbx
	mov	rcx, rsi
	call	?GenerateStringTable@BymlFile@@QEAAXPEAVNode@1@@Z ; BymlFile::GenerateStringTable

; 320  :     for (BymlFile::Node& Nodes : Node->GetChildren())

	add	rbx, 88					; 00000058H
	cmp	rbx, rdi
	jne	SHORT $LL4@GenerateSt
$LN3@GenerateSt:

; 323  :     }
; 324  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+144]
	add	rsp, 80					; 00000050H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN126@GenerateSt:
?GenerateStringTable@BymlFile@@QEAAXPEAVNode@1@@Z ENDP	; BymlFile::GenerateStringTable
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
str$1 = 32
__$ArrayPad$ = 64
this$ = 128
Node$ = 136
?dtor$0@?0??GenerateStringTable@BymlFile@@QEAAXPEAVNode@1@@Z@4HA PROC ; `BymlFile::GenerateStringTable'::`1'::dtor$0
	lea	rcx, QWORD PTR str$1[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??GenerateStringTable@BymlFile@@QEAAXPEAVNode@1@@Z@4HA ENDP ; `BymlFile::GenerateStringTable'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
;	COMDAT ?GetStringTableIndex@BymlFile@@AEAAIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
this$ = 64
Value$ = 72
?GetStringTableIndex@BymlFile@@AEAAIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; BymlFile::GetStringTableIndex, COMDAT

; 327  : {

$LN51:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rbx, QWORD PTR [rcx+48]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 328  :     for (int i = 0; i < this->m_StringTable.size(); i++)

	xor	edi, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rbp, QWORD PTR [rcx+56]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 327  : {

	mov	rsi, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rbp, rbx
	sar	rbp, 5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 328  :     for (int i = 0; i < this->m_StringTable.size(); i++)

	test	rbp, rbp
	je	SHORT $LN3@GetStringT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	r14, QWORD PTR [rdx+24]

; 4584 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	r15, QWORD PTR [rdx+16]
	npad	7
$LL4@GetStringT:

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rdx, rsi

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	r14, 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN16@GetStringT

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rsi]
$LN16@GetStringT:

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rbx+24], 16

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rbx

; 4584 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	r8, QWORD PTR [rbx+16]

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN21@GetStringT

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rbx]
$LN21@GetStringT:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	r8, r15
	jne	SHORT $LN27@GetStringT

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	je	SHORT $LN38@GetStringT
$LN27@GetStringT:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 328  :     for (int i = 0; i < this->m_StringTable.size(); i++)

	inc	edi
	add	rbx, 32					; 00000020H
	movsxd	rax, edi
	cmp	rax, rbp
	jb	SHORT $LL4@GetStringT
$LN3@GetStringT:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rsi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 335  :     return 0;

	xor	eax, eax
$LN1@GetStringT:

; 336  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
$LN38@GetStringT:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rsi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 332  :             return i;

	mov	eax, edi
	jmp	SHORT $LN1@GetStringT
?GetStringTableIndex@BymlFile@@AEAAIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; BymlFile::GetStringTableIndex
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
;	COMDAT ?GetHashKeyTableIndex@BymlFile@@AEAAIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
this$ = 64
Value$ = 72
?GetHashKeyTableIndex@BymlFile@@AEAAIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; BymlFile::GetHashKeyTableIndex, COMDAT

; 339  : {

$LN51:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rbx, QWORD PTR [rcx+24]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 340  :     for (int i = 0; i < this->m_HashKeyTable.size(); i++)

	xor	edi, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rbp, QWORD PTR [rcx+32]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 339  : {

	mov	rsi, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rbp, rbx
	sar	rbp, 5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 340  :     for (int i = 0; i < this->m_HashKeyTable.size(); i++)

	test	rbp, rbp
	je	SHORT $LN3@GetHashKey
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	r14, QWORD PTR [rdx+24]

; 4584 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	r15, QWORD PTR [rdx+16]
	npad	7
$LL4@GetHashKey:

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rdx, rsi

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	r14, 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN16@GetHashKey

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rsi]
$LN16@GetHashKey:

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rbx+24], 16

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rbx

; 4584 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	r8, QWORD PTR [rbx+16]

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN21@GetHashKey

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rbx]
$LN21@GetHashKey:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	r8, r15
	jne	SHORT $LN27@GetHashKey

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	je	SHORT $LN38@GetHashKey
$LN27@GetHashKey:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 340  :     for (int i = 0; i < this->m_HashKeyTable.size(); i++)

	inc	edi
	add	rbx, 32					; 00000020H
	movsxd	rax, edi
	cmp	rax, rbp
	jb	SHORT $LL4@GetHashKey
$LN3@GetHashKey:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rsi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 347  :     return 0;

	xor	eax, eax
$LN1@GetHashKey:

; 348  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
$LN38@GetHashKey:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rsi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 344  :             return i;

	mov	eax, edi
	jmp	SHORT $LN1@GetHashKey
?GetHashKeyTableIndex@BymlFile@@AEAAIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; BymlFile::GetHashKeyTableIndex
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
;	COMDAT ?WriteNode@BymlFile@@AEAAXAEAVBinaryVectorWriter@@IIAEAVNode@1@@Z
_TEXT	SEGMENT
tv3589 = 48
$T1 = 48
$T2 = 48
$T3 = 48
$T4 = 48
$T5 = 48
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 48
$T10 = 48
DataOffset$GSCopy$1$ = 64
tv3646 = 68
$T11 = 72
LocalOffset$1$ = 76
$T12 = 80
$T13 = 80
$T14 = 80
$T15 = 80
Node$GSCopy$1$ = 112
Value$16 = 112
tv3573 = 120
_My_data$2$ = 128
$T17 = 136
$T18 = 136
$T19 = 136
$T20 = 168
$T21 = 208
$T22 = 208
i$1$ = 304
LocalOffset$1$ = 304
Value$23 = 304
__$ArrayPad$ = 312
this$ = 400
Writer$ = 408
DataOffset$ = 416
Offset$ = 424
Node$ = 432
?WriteNode@BymlFile@@AEAAXAEAVBinaryVectorWriter@@IIAEAVNode@1@@Z PROC ; BymlFile::WriteNode, COMDAT

; 351  : {

$LN578:
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-72]
	sub	rsp, 328				; 00000148H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	movsxd	rbx, r9d
	mov	r14d, r8d
	mov	DWORD PTR DataOffset$GSCopy$1$[rsp], r8d
	mov	rdi, rdx
	mov	r13, rcx
	mov	r12, QWORD PTR Node$[rbp-256]
	mov	QWORD PTR Node$GSCopy$1$[rsp], r12
	xor	esi, esi

; 352  :     if (Node.GetType() == BymlFile::Type::Null)

	cmp	BYTE PTR [r12+24], 255			; 000000ffH
	je	$LN36@WriteNode
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rdx+8]
	sub	rcx, QWORD PTR [rdx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 22   : 		if (Offset > this->m_Data.size())

	cmp	rbx, rcx
	jbe	SHORT $LN63@WriteNode

; 23   : 		{
; 24   : 			this->m_Data.resize(Offset + 1);

	lea	eax, DWORD PTR [rbx+1]
	movsxd	rdx, eax
	mov	rcx, rdi
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN63@WriteNode:

; 26   : 		this->m_Offset = Offset;

	mov	DWORD PTR [rdi+24], ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 359  :     switch (Node.GetType())

	movzx	edx, BYTE PTR [r12+24]
	lea	eax, DWORD PTR [rdx-160]
	cmp	eax, 54					; 00000036H
	ja	$LN35@WriteNode
	cdqe
	lea	r8, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR $LN571@WriteNode[r8+rax]
	mov	ecx, DWORD PTR $LN572@WriteNode[r8+rax*4]
	add	rcx, r8
	jmp	rcx
$LN18@WriteNode:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h

; 52   :             memcpy(&Value, this->m_Value.data(), sizeof(Value));

	mov	rax, QWORD PTR [r12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 363  :         float Value = Node.GetValue<float>();

	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR Value$23[rbp-256], xmm0

; 364  :         Writer.WriteRawUnsafeFixed(reinterpret_cast<const char*>(&Value), sizeof(float));

	mov	r8d, 4
	lea	rdx, QWORD PTR Value$23[rbp-256]
	mov	rcx, rdi
	call	?WriteRawUnsafeFixed@BinaryVectorWriter@@QEAAXPEBDH@Z ; BinaryVectorWriter::WriteRawUnsafeFixed

; 365  :         break;

	jmp	$LN106@WriteNode
$LN19@WriteNode:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h

; 52   :             memcpy(&Value, this->m_Value.data(), sizeof(Value));

	mov	rax, QWORD PTR [r12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 369  :         Writer.WriteInteger(Node.GetValue<uint32_t>(), sizeof(uint32_t));

	mov	edx, DWORD PTR [rax]
	mov	r8d, 4
	mov	rcx, rdi
	call	?WriteInteger@BinaryVectorWriter@@QEAAX_JH@Z ; BinaryVectorWriter::WriteInteger

; 370  :         break;

	jmp	$LN106@WriteNode
$LN20@WriteNode:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h

; 52   :             memcpy(&Value, this->m_Value.data(), sizeof(Value));

	mov	rax, QWORD PTR [r12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 374  :         Writer.WriteInteger(Node.GetValue<int32_t>(), sizeof(int32_t));

	movsxd	rdx, DWORD PTR [rax]
	mov	r8d, 4
	mov	rcx, rdi
	call	?WriteInteger@BinaryVectorWriter@@QEAAX_JH@Z ; BinaryVectorWriter::WriteInteger

; 375  :         break;

	jmp	$LN106@WriteNode
$LN21@WriteNode:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h

; 98   :             return this->m_Value[0];

	cmp	BYTE PTR [rax], sil
	setne	sil
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 379  :         Writer.WriteInteger(Node.GetValue<bool>(), sizeof(uint32_t));

	mov	r8d, 4
	mov	rdx, rsi
	mov	rcx, rdi
	call	?WriteInteger@BinaryVectorWriter@@QEAAX_JH@Z ; BinaryVectorWriter::WriteInteger

; 380  :         break;

	jmp	$LN106@WriteNode
$LN22@WriteNode:

; 381  :     }
; 382  :     case BymlFile::Type::StringIndex:
; 383  :     {
; 384  :         Writer.WriteInteger(GetStringTableIndex(Node.GetValue<std::string>()), sizeof(uint32_t));

	lea	rdx, QWORD PTR $T19[rbp-256]
	mov	rcx, r12
	call	??$GetValue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Node@BymlFile@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; BymlFile::Node::GetValue<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	r14, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rbx, QWORD PTR [r13+48]
	mov	r15, QWORD PTR [r13+56]
	sub	r15, rbx
	sar	r15, 5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 328  :     for (int i = 0; i < this->m_StringTable.size(); i++)

	test	r15, r15
	je	SHORT $LN274@WriteNode
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	r12, QWORD PTR [rax+24]
$LL275@WriteNode:

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rdx, r14

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	r12, 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN287@WriteNode

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [r14]
$LN287@WriteNode:

; 4584 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	r8, QWORD PTR [rbx+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rbx

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rbx+24], 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN292@WriteNode

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rbx]
$LN292@WriteNode:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	r8, QWORD PTR [r14+16]
	jne	SHORT $LN298@WriteNode

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	je	SHORT $LN272@WriteNode
$LN298@WriteNode:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 328  :     for (int i = 0; i < this->m_StringTable.size(); i++)

	inc	esi
	add	rbx, 32					; 00000020H
	movsxd	rax, esi
	cmp	rax, r15
	jb	SHORT $LL275@WriteNode
$LN274@WriteNode:

; 329  :     {
; 330  :         if (this->m_StringTable[i] == Value)
; 331  :         {
; 332  :             return i;
; 333  :         }
; 334  :     }
; 335  :     return 0;

	xor	esi, esi
$LN272@WriteNode:

; 381  :     }
; 382  :     case BymlFile::Type::StringIndex:
; 383  :     {
; 384  :         Writer.WriteInteger(GetStringTableIndex(Node.GetValue<std::string>()), sizeof(uint32_t));

	mov	rcx, r14
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	mov	edx, esi
	mov	r8d, 4
	mov	rcx, rdi
	call	?WriteInteger@BinaryVectorWriter@@QEAAX_JH@Z ; BinaryVectorWriter::WriteInteger

; 385  :         break;

	jmp	$LN106@WriteNode
$LN23@WriteNode:

; 386  :     }
; 387  :     case BymlFile::Type::UInt64:
; 388  :     {
; 389  :         if (this->m_CachedValues.contains(Node.m_Value))

	mov	rdx, r12
	lea	rcx, QWORD PTR [r13+88]
	call	??$contains@X@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@QEBA_NAEBV?$vector@EV?$allocator@E@std@@@1@@Z ; std::_Hash<std::_Umap_traits<std::vector<unsigned char,std::allocator<unsigned char> >,unsigned int,std::_Uhash_compare<std::vector<unsigned char,std::allocator<unsigned char> >,BymlFile::VectorHasher,std::equal_to<std::vector<unsigned char,std::allocator<unsigned char> > > >,std::allocator<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >,0> >::contains<void>
	test	al, al
	je	SHORT $LN24@WriteNode
$LN574@WriteNode:

; 494  :     if (Writer.GetPosition() > this->m_WriterLastOffset)

	mov	r8, r12
	lea	rdx, QWORD PTR $T2[rsp]
	lea	rcx, QWORD PTR [r13+88]
	call	??$_Try_emplace@AEBV?$vector@EV?$allocator@E@std@@@std@@$$V@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@_N@1@AEBV?$vector@EV?$allocator@E@std@@@1@@Z ; std::_Hash<std::_Umap_traits<std::vector<unsigned char,std::allocator<unsigned char> >,unsigned int,std::_Uhash_compare<std::vector<unsigned char,std::allocator<unsigned char> >,BymlFile::VectorHasher,std::equal_to<std::vector<unsigned char,std::allocator<unsigned char> > > >,std::allocator<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >,0> >::_Try_emplace<std::vector<unsigned char,std::allocator<unsigned char> > const &>
	mov	rcx, QWORD PTR [rax]
	mov	edx, DWORD PTR [rcx+40]
	mov	r8d, 4
	mov	rcx, rdi
	call	?WriteInteger@BinaryVectorWriter@@QEAAX_JH@Z ; BinaryVectorWriter::WriteInteger
	jmp	$LN106@WriteNode
$LN24@WriteNode:

; 390  :         {
; 391  :             Writer.WriteInteger(this->m_CachedValues[Node.m_Value], sizeof(uint32_t));
; 392  :             break;
; 393  :         }
; 394  :         Writer.WriteInteger(DataOffset + this->m_WriterReservedDataOffset, sizeof(uint32_t));

	mov	edx, DWORD PTR [r13+80]
	add	edx, r14d
	mov	r8d, 4
	mov	rcx, rdi
	call	?WriteInteger@BinaryVectorWriter@@QEAAX_JH@Z ; BinaryVectorWriter::WriteInteger

; 395  :         Writer.Seek(DataOffset + this->m_WriterReservedDataOffset, BinaryVectorWriter::Position::Begin);

	mov	ebx, DWORD PTR [r13+80]
	add	ebx, r14d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rdi+8]
	sub	rcx, QWORD PTR [rdi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 22   : 		if (Offset > this->m_Data.size())

	movsxd	rax, ebx
	cmp	rax, rcx
	jbe	SHORT $LN510@WriteNode

; 23   : 		{
; 24   : 			this->m_Data.resize(Offset + 1);

	lea	eax, DWORD PTR [rbx+1]
	movsxd	rdx, eax
	mov	rcx, rdi
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN510@WriteNode:

; 26   : 		this->m_Offset = Offset;

	mov	DWORD PTR [rdi+24], ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h

; 52   :             memcpy(&Value, this->m_Value.data(), sizeof(Value));

	mov	rax, QWORD PTR [r12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 396  :         Writer.WriteInteger(Node.GetValue<uint64_t>(), sizeof(uint64_t));

	mov	r8d, 8
	mov	rdx, QWORD PTR [rax]
	mov	rcx, rdi
	call	?WriteInteger@BinaryVectorWriter@@QEAAX_JH@Z ; BinaryVectorWriter::WriteInteger

; 397  :         this->m_CachedValues.insert({ Node.m_Value, DataOffset + this->m_WriterReservedDataOffset });

	mov	ebx, DWORD PTR [r13+80]
	add	ebx, r14d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rdx, r12
	lea	rcx, QWORD PTR $T15[rsp]
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	mov	DWORD PTR $T15[rsp+24], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 938  :         return emplace(_STD move(_Val));

	lea	r8, QWORD PTR $T15[rsp]
	lea	rdx, QWORD PTR $T10[rsp]
	lea	rcx, QWORD PTR [r13+88]
	call	??$emplace@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@@Z ; std::_Hash<std::_Umap_traits<std::vector<unsigned char,std::allocator<unsigned char> >,unsigned int,std::_Uhash_compare<std::vector<unsigned char,std::allocator<unsigned char> >,BymlFile::VectorHasher,std::equal_to<std::vector<unsigned char,std::allocator<unsigned char> > > >,std::allocator<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >,0> >::emplace<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR $T15[rsp]
	test	rcx, rcx
	je	SHORT $LN458@WriteNode

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR $T15[rsp+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN470@WriteNode

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN470@WriteNode
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN470@WriteNode:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 494  :     if (Writer.GetPosition() > this->m_WriterLastOffset)

	call	??3@YAXPEAX_K@Z				; operator delete
$LN458@WriteNode:
	add	DWORD PTR [r13+80], 8
	jmp	$LN106@WriteNode
$LN25@WriteNode:

; 398  :         this->m_WriterReservedDataOffset += 8;
; 399  :         break;
; 400  :     }
; 401  :     case BymlFile::Type::Int64:
; 402  :     {
; 403  :         if (this->m_CachedValues.contains(Node.m_Value))

	mov	rdx, r12
	lea	rcx, QWORD PTR [r13+88]
	call	??$contains@X@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@QEBA_NAEBV?$vector@EV?$allocator@E@std@@@1@@Z ; std::_Hash<std::_Umap_traits<std::vector<unsigned char,std::allocator<unsigned char> >,unsigned int,std::_Uhash_compare<std::vector<unsigned char,std::allocator<unsigned char> >,BymlFile::VectorHasher,std::equal_to<std::vector<unsigned char,std::allocator<unsigned char> > > >,std::allocator<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >,0> >::contains<void>
	test	al, al
	jne	$LN574@WriteNode

; 404  :         {
; 405  :             Writer.WriteInteger(this->m_CachedValues[Node.m_Value], sizeof(uint32_t));
; 406  :             break;
; 407  :         }
; 408  :         Writer.WriteInteger(DataOffset + this->m_WriterReservedDataOffset, sizeof(uint32_t));

	mov	edx, DWORD PTR [r13+80]
	add	edx, r14d
	mov	r8d, 4
	mov	rcx, rdi
	call	?WriteInteger@BinaryVectorWriter@@QEAAX_JH@Z ; BinaryVectorWriter::WriteInteger

; 409  :         Writer.Seek(DataOffset + this->m_WriterReservedDataOffset, BinaryVectorWriter::Position::Begin);

	mov	ebx, DWORD PTR [r13+80]
	add	ebx, r14d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rdi+8]
	sub	rcx, QWORD PTR [rdi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 22   : 		if (Offset > this->m_Data.size())

	movsxd	rax, ebx
	cmp	rax, rcx
	jbe	SHORT $LN402@WriteNode

; 23   : 		{
; 24   : 			this->m_Data.resize(Offset + 1);

	lea	eax, DWORD PTR [rbx+1]
	movsxd	rdx, eax
	mov	rcx, rdi
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN402@WriteNode:

; 26   : 		this->m_Offset = Offset;

	mov	DWORD PTR [rdi+24], ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h

; 52   :             memcpy(&Value, this->m_Value.data(), sizeof(Value));

	mov	rax, QWORD PTR [r12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 410  :         Writer.WriteInteger(Node.GetValue<int64_t>(), sizeof(int64_t));

	mov	r8d, 8
	mov	rdx, QWORD PTR [rax]
	mov	rcx, rdi
	call	?WriteInteger@BinaryVectorWriter@@QEAAX_JH@Z ; BinaryVectorWriter::WriteInteger

; 411  :         this->m_CachedValues.insert({ Node.m_Value, DataOffset + this->m_WriterReservedDataOffset });

	mov	ebx, DWORD PTR [r13+80]
	add	ebx, r14d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rdx, r12
	lea	rcx, QWORD PTR $T14[rsp]
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	mov	DWORD PTR $T14[rsp+24], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 938  :         return emplace(_STD move(_Val));

	lea	r8, QWORD PTR $T14[rsp]
	lea	rdx, QWORD PTR $T9[rsp]
	lea	rcx, QWORD PTR [r13+88]
	call	??$emplace@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@@Z ; std::_Hash<std::_Umap_traits<std::vector<unsigned char,std::allocator<unsigned char> >,unsigned int,std::_Uhash_compare<std::vector<unsigned char,std::allocator<unsigned char> >,BymlFile::VectorHasher,std::equal_to<std::vector<unsigned char,std::allocator<unsigned char> > > >,std::allocator<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >,0> >::emplace<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR $T14[rsp]
	test	rcx, rcx
	je	$LN458@WriteNode

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR $T14[rsp+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	$LN470@WriteNode

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	$LN470@WriteNode
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN27@WriteNode:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 417  :         if (this->m_CachedValues.contains(Node.m_Value))

	mov	rdx, r12
	lea	rcx, QWORD PTR [r13+88]
	call	??$contains@X@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@QEBA_NAEBV?$vector@EV?$allocator@E@std@@@1@@Z ; std::_Hash<std::_Umap_traits<std::vector<unsigned char,std::allocator<unsigned char> >,unsigned int,std::_Uhash_compare<std::vector<unsigned char,std::allocator<unsigned char> >,BymlFile::VectorHasher,std::equal_to<std::vector<unsigned char,std::allocator<unsigned char> > > >,std::allocator<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >,0> >::contains<void>
	test	al, al
	jne	$LN574@WriteNode

; 418  :         {
; 419  :             Writer.WriteInteger(this->m_CachedValues[Node.m_Value], sizeof(uint32_t));
; 420  :             break;
; 421  :         }
; 422  :         Writer.WriteInteger(DataOffset + this->m_WriterReservedDataOffset, sizeof(uint32_t));

	mov	edx, DWORD PTR [r13+80]
	add	edx, r14d
	mov	r8d, 4
	mov	rcx, rdi
	call	?WriteInteger@BinaryVectorWriter@@QEAAX_JH@Z ; BinaryVectorWriter::WriteInteger

; 423  :         Writer.Seek(DataOffset + this->m_WriterReservedDataOffset, BinaryVectorWriter::Position::Begin);

	mov	ebx, DWORD PTR [r13+80]
	add	ebx, r14d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rdi+8]
	sub	rcx, QWORD PTR [rdi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 22   : 		if (Offset > this->m_Data.size())

	movsxd	rax, ebx
	cmp	rax, rcx
	jbe	SHORT $LN490@WriteNode

; 23   : 		{
; 24   : 			this->m_Data.resize(Offset + 1);

	lea	eax, DWORD PTR [rbx+1]
	movsxd	rdx, eax
	mov	rcx, rdi
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN490@WriteNode:

; 26   : 		this->m_Offset = Offset;

	mov	DWORD PTR [rdi+24], ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h

; 52   :             memcpy(&Value, this->m_Value.data(), sizeof(Value));

	mov	rax, QWORD PTR [r12]
	mov	rcx, QWORD PTR [rax]
	mov	QWORD PTR Value$16[rsp], rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 424  :         Writer.WriteInteger(Node.GetValue<double>(), sizeof(double));

	cvttsd2si rdx, QWORD PTR Value$16[rsp]
	mov	r8d, 8
	mov	rcx, rdi
	call	?WriteInteger@BinaryVectorWriter@@QEAAX_JH@Z ; BinaryVectorWriter::WriteInteger

; 425  :         this->m_CachedValues.insert({ Node.m_Value, DataOffset + this->m_WriterReservedDataOffset });

	mov	ebx, DWORD PTR [r13+80]
	add	ebx, r14d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rdx, r12
	lea	rcx, QWORD PTR $T13[rsp]
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	mov	DWORD PTR $T13[rsp+24], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 938  :         return emplace(_STD move(_Val));

	lea	r8, QWORD PTR $T13[rsp]
	lea	rdx, QWORD PTR $T8[rsp]
	lea	rcx, QWORD PTR [r13+88]
	call	??$emplace@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@@Z ; std::_Hash<std::_Umap_traits<std::vector<unsigned char,std::allocator<unsigned char> >,unsigned int,std::_Uhash_compare<std::vector<unsigned char,std::allocator<unsigned char> >,BymlFile::VectorHasher,std::equal_to<std::vector<unsigned char,std::allocator<unsigned char> > > >,std::allocator<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >,0> >::emplace<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR $T13[rsp]
	test	rcx, rcx
	je	$LN458@WriteNode

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR $T13[rsp+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	$LN470@WriteNode

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	$LN470@WriteNode
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN29@WriteNode:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 431  :         if (!this->m_CachedNodes.contains(Node))

	mov	rdx, r12
	lea	rcx, QWORD PTR [r13+152]
	call	??$contains@X@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@QEBA_NAEBVNode@BymlFile@@@Z ; std::_Hash<std::_Umap_traits<BymlFile::Node,unsigned int,std::_Uhash_compare<BymlFile::Node,BymlFile::NodeHasher,BymlFile::NodeEqual>,std::allocator<std::pair<BymlFile::Node const ,unsigned int> >,0> >::contains<void>
	test	al, al
	jne	$LN30@WriteNode

; 432  :         {
; 433  :             Writer.WriteInteger(DataOffset + this->m_WriterReservedDataOffset, sizeof(uint32_t));

	mov	edx, DWORD PTR [r13+80]
	add	edx, r14d
	mov	r8d, 4
	mov	rcx, rdi
	call	?WriteInteger@BinaryVectorWriter@@QEAAX_JH@Z ; BinaryVectorWriter::WriteInteger

; 434  :             Writer.Seek(DataOffset + this->m_WriterReservedDataOffset, BinaryVectorWriter::Position::Begin);

	mov	ebx, DWORD PTR [r13+80]
	add	ebx, r14d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rdi+8]
	sub	rcx, QWORD PTR [rdi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 22   : 		if (Offset > this->m_Data.size())

	movsxd	rax, ebx
	cmp	rax, rcx
	jbe	SHORT $LN317@WriteNode

; 23   : 		{
; 24   : 			this->m_Data.resize(Offset + 1);

	lea	eax, DWORD PTR [rbx+1]
	movsxd	rdx, eax
	mov	rcx, rdi
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN317@WriteNode:

; 26   : 		this->m_Offset = Offset;

	mov	DWORD PTR [rdi+24], ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 435  :             uint32_t LocalOffset = DataOffset + this->m_WriterReservedDataOffset;

	mov	eax, DWORD PTR [r13+80]
	add	eax, r14d
	mov	DWORD PTR LocalOffset$1$[rbp-256], eax

; 436  :             Writer.WriteByte(0xC0);

	mov	dl, -64					; ffffffffffffffc0H
	mov	rcx, rdi
	call	?WriteByte@BinaryVectorWriter@@QEAAXD@Z	; BinaryVectorWriter::WriteByte
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1868 :         auto& _My_data = _Mypair._Myval2;

	lea	r14, QWORD PTR [r12+64]

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [r14+8]
	sub	rdx, QWORD PTR [r14]
	sar	rdx, 3
	mov	rax, 3353953467947191203		; 2e8ba2e8ba2e8ba3H
	imul	rdx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 437  :             Writer.WriteInteger(Node.GetChildren().size(), 3); //3 = uint24

	mov	r8d, 3
	mov	rcx, rdi
	call	?WriteInteger@BinaryVectorWriter@@QEAAX_JH@Z ; BinaryVectorWriter::WriteInteger

; 438  :             for (BymlFile::Node& Child : Node.GetChildren())

	mov	r15, QWORD PTR [r14+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 26   : 		this->m_Offset = Offset;

	mov	rsi, QWORD PTR [r14]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 438  :             for (BymlFile::Node& Child : Node.GetChildren())

	cmp	rsi, r15
	je	SHORT $LN565@WriteNode
	npad	12
$LL6@WriteNode:

; 439  :             {
; 440  :                 Writer.WriteByte((uint8_t)Child.GetType());

	movzx	ebx, BYTE PTR [rsi+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [rdi+8]
	sub	rdx, QWORD PTR [rdi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	mov	rcx, rdi
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR [rdi+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR [rdi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], bl

; 14   : 	this->m_Offset++;

	inc	DWORD PTR [rdi+24]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 438  :             for (BymlFile::Node& Child : Node.GetChildren())

	add	rsi, 88					; 00000058H
	cmp	rsi, r15
	jne	SHORT $LL6@WriteNode
$LN565@WriteNode:

; 442  :             while (Writer.GetPosition() % 4 != 0) //Aligning up after array content by 4 bytes

	mov	ecx, DWORD PTR [rdi+24]
	mov	eax, ecx
	and	eax, -2147483645			; ffffffff80000003H
	jge	SHORT $LN570@WriteNode
	dec	eax
	or	eax, -4
	inc	eax
$LN570@WriteNode:
	test	eax, eax
	je	SHORT $LN8@WriteNode
$LL7@WriteNode:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [rdi+8]
	sub	rdx, QWORD PTR [rdi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	mov	rcx, rdi
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR [rdi+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR [rdi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 0

; 14   : 	this->m_Offset++;

	mov	ecx, DWORD PTR [rdi+24]
	inc	ecx
	mov	DWORD PTR [rdi+24], ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 442  :             while (Writer.GetPosition() % 4 != 0) //Aligning up after array content by 4 bytes

	mov	eax, ecx
	and	eax, -2147483645			; ffffffff80000003H
	jge	SHORT $LN569@WriteNode
	dec	eax
	or	eax, -4
	inc	eax
$LN569@WriteNode:
	test	eax, eax
	jne	SHORT $LL7@WriteNode
$LN8@WriteNode:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [r14+8]
	sub	rax, QWORD PTR [r14]
	sar	rax, 3
	mov	r15, 3353953467947191203		; 2e8ba2e8ba2e8ba3H
	imul	rax, r15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 446  :             this->m_WriterReservedDataOffset = Writer.GetPosition() - DataOffset + 4 * Node.GetChildren().size();

	lea	eax, DWORD PTR [rax*4]
	sub	eax, DWORD PTR DataOffset$GSCopy$1$[rsp]
	add	eax, ecx
	mov	DWORD PTR [r13+80], eax

; 447  :             uint32_t EntryOffset = Writer.GetPosition();

	mov	ebx, DWORD PTR [rdi+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [r14]
	mov	rax, QWORD PTR [r14+8]
	sub	rax, rcx
	sar	rax, 3
	imul	rax, r15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 448  :             for (int i = 0; i < Node.GetChildren().size(); i++)

	test	rax, rax
	je	SHORT $LN10@WriteNode
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1868 :         auto& _My_data = _Mypair._Myval2;

	xor	esi, esi
	mov	edx, esi
	mov	r12d, DWORD PTR DataOffset$GSCopy$1$[rsp]
	npad	9
$LL11@WriteNode:

; 1889 :         return _My_data._Myfirst[_Pos];

	imul	rax, rdx, 88				; 00000058H
	add	rcx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 450  :                 this->WriteNode(Writer, DataOffset, EntryOffset + 4 * i, *Node.GetChild(i));

	mov	QWORD PTR [rsp+32], rcx
	mov	r9d, ebx
	mov	r8d, r12d
	mov	rdx, rdi
	mov	rcx, r13
	call	?WriteNode@BymlFile@@AEAAXAEAVBinaryVectorWriter@@IIAEAVNode@1@@Z ; BymlFile::WriteNode

; 448  :             for (int i = 0; i < Node.GetChildren().size(); i++)

	inc	esi
	add	ebx, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [r14]
	mov	rax, QWORD PTR [r14+8]
	sub	rax, rcx
	sar	rax, 3
	imul	rax, r15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 448  :             for (int i = 0; i < Node.GetChildren().size(); i++)

	movsxd	rdx, esi
	cmp	rdx, rax
	jb	SHORT $LL11@WriteNode
	mov	r12, QWORD PTR Node$GSCopy$1$[rsp]
$LN10@WriteNode:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	lea	rax, QWORD PTR $T22[rbp-256]
	mov	QWORD PTR $T4[rsp], rax
	mov	rdx, r12
	lea	rcx, QWORD PTR $T22[rbp-256]
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	npad	1
	movzx	eax, BYTE PTR [r12+24]
	mov	BYTE PTR $T22[rbp-232], al
	lea	rdx, QWORD PTR [r12+32]
	lea	rcx, QWORD PTR $T22[rbp-224]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rdx, r14
	lea	rcx, QWORD PTR $T22[rbp-192]
	call	??0?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@AEBV01@@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::vector<BymlFile::Node,std::allocator<BymlFile::Node> >
	npad	1
	mov	eax, DWORD PTR LocalOffset$1$[rbp-256]
	mov	DWORD PTR $T22[rbp-168], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 938  :         return emplace(_STD move(_Val));

	lea	r8, QWORD PTR $T22[rbp-256]
	lea	rdx, QWORD PTR $T7[rsp]
	lea	rcx, QWORD PTR [r13+152]
	call	??$emplace@U?$pair@$$CBVNode@BymlFile@@I@std@@@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVNode@BymlFile@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBVNode@BymlFile@@I@1@@Z ; std::_Hash<std::_Umap_traits<BymlFile::Node,unsigned int,std::_Uhash_compare<BymlFile::Node,BymlFile::NodeHasher,BymlFile::NodeEqual>,std::allocator<std::pair<BymlFile::Node const ,unsigned int> >,0> >::emplace<std::pair<BymlFile::Node const ,unsigned int> >
	npad	1
	lea	rcx, QWORD PTR $T22[rbp-256]
	call	??1Node@BymlFile@@QEAA@XZ
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 453  :         }

	jmp	$LN106@WriteNode
$LN30@WriteNode:

; 494  :     if (Writer.GetPosition() > this->m_WriterLastOffset)

	mov	r8, r12
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR [r13+152]
	call	??$_Try_emplace@AEBVNode@BymlFile@@$$V@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@_N@1@AEBVNode@BymlFile@@@Z ; std::_Hash<std::_Umap_traits<BymlFile::Node,unsigned int,std::_Uhash_compare<BymlFile::Node,BymlFile::NodeHasher,BymlFile::NodeEqual>,std::allocator<std::pair<BymlFile::Node const ,unsigned int> >,0> >::_Try_emplace<BymlFile::Node const &>
	mov	rcx, QWORD PTR [rax]
	mov	edx, DWORD PTR [rcx+104]
	mov	r8d, 4
	mov	rcx, rdi
	call	?WriteInteger@BinaryVectorWriter@@QEAAX_JH@Z ; BinaryVectorWriter::WriteInteger
	jmp	$LN106@WriteNode
$LN32@WriteNode:

; 454  :         else
; 455  :         {
; 456  :             Writer.WriteInteger(this->m_CachedNodes[Node], sizeof(uint32_t));
; 457  :         }
; 458  :         break;
; 459  :     }
; 460  :     case BymlFile::Type::Dictionary:
; 461  :     {
; 462  :         if (!this->m_CachedNodes.contains(Node))

	mov	rdx, r12
	lea	rcx, QWORD PTR [r13+152]
	call	??$contains@X@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@QEBA_NAEBVNode@BymlFile@@@Z ; std::_Hash<std::_Umap_traits<BymlFile::Node,unsigned int,std::_Uhash_compare<BymlFile::Node,BymlFile::NodeHasher,BymlFile::NodeEqual>,std::allocator<std::pair<BymlFile::Node const ,unsigned int> >,0> >::contains<void>
	test	al, al
	jne	SHORT $LN30@WriteNode

; 463  :         {
; 464  :             uint32_t LocalOffset = DataOffset + this->m_WriterReservedDataOffset;

	mov	r15d, DWORD PTR [r13+80]
	add	r15d, r14d
	mov	DWORD PTR LocalOffset$1$[rsp], r15d

; 465  :             Writer.WriteInteger(LocalOffset, sizeof(uint32_t));

	mov	edx, r15d
	mov	r8d, 4
	mov	rcx, rdi
	call	?WriteInteger@BinaryVectorWriter@@QEAAX_JH@Z ; BinaryVectorWriter::WriteInteger

; 466  :             this->m_WriterReservedDataOffset += 4 + 8 * Node.GetChildren().size();

	lea	r14, QWORD PTR [r12+64]
	mov	QWORD PTR _My_data$2$[rbp-256], r14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [r14+8]
	sub	rcx, QWORD PTR [r14]
	sar	rcx, 3
	mov	rbx, 3353953467947191203		; 2e8ba2e8ba2e8ba3H
	imul	rcx, rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 466  :             this->m_WriterReservedDataOffset += 4 + 8 * Node.GetChildren().size();

	lea	ecx, DWORD PTR [rcx*8+4]
	add	DWORD PTR [r13+80], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rdi+8]
	sub	rcx, QWORD PTR [rdi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 22   : 		if (Offset > this->m_Data.size())

	movsxd	rax, r15d
	cmp	rax, rcx
	jbe	SHORT $LN334@WriteNode

; 23   : 		{
; 24   : 			this->m_Data.resize(Offset + 1);

	lea	eax, DWORD PTR [r15+1]
	movsxd	rdx, eax
	mov	rcx, rdi
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN334@WriteNode:

; 26   : 		this->m_Offset = Offset;

	mov	DWORD PTR [rdi+24], r15d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [rdi+8]
	sub	rdx, QWORD PTR [rdi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	mov	rcx, rdi
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR [rdi+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR [rdi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 193			; 000000c1H

; 14   : 	this->m_Offset++;

	inc	DWORD PTR [rdi+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [r14+8]
	sub	rdx, QWORD PTR [r14]
	sar	rdx, 3
	imul	rdx, rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 469  :             Writer.WriteInteger(Node.GetChildren().size(), 3); // 3 = uint24

	mov	r8d, 3
	mov	rcx, rdi
	call	?WriteInteger@BinaryVectorWriter@@QEAAX_JH@Z ; BinaryVectorWriter::WriteInteger

; 470  :             for (int i = 0; i < Node.GetChildren().size(); i++)

	mov	DWORD PTR i$1$[rbp-256], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [r14+8]
	sub	rax, QWORD PTR [r14]
	sar	rax, 3
	imul	rax, rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 470  :             for (int i = 0; i < Node.GetChildren().size(); i++)

	test	rax, rax
	je	$LN13@WriteNode
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1868 :         auto& _My_data = _Mypair._Myval2;

	xor	r12d, r12d
	mov	ebx, r12d
	mov	QWORD PTR tv3573[rsp], r12
	lea	esi, DWORD PTR [r15+4]
	mov	DWORD PTR tv3646[rsp], esi
	npad	4
$LL14@WriteNode:

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rdi+8]
	sub	rcx, QWORD PTR [rdi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 22   : 		if (Offset > this->m_Data.size())

	lea	edx, DWORD PTR [rsi+1]
	mov	DWORD PTR $T11[rsp], edx
	movsxd	rax, esi
	cmp	rax, rcx
	jbe	SHORT $LN566@WriteNode

; 23   : 		{
; 24   : 			this->m_Data.resize(Offset + 1);

	movsxd	rdx, edx
	mov	rcx, rdi
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	jmp	SHORT $LN238@WriteNode
$LN566@WriteNode:
	mov	DWORD PTR $T11[rsp], edx
$LN238@WriteNode:

; 26   : 		this->m_Offset = Offset;

	mov	DWORD PTR [rdi+24], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	imul	rcx, rbx, 88				; 00000058H
	mov	QWORD PTR tv3589[rsp], rcx
	mov	rdx, QWORD PTR [r14]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 474  :                 Writer.WriteInteger(GetHashKeyTableIndex(Node.GetChild(i)->GetKey()), 3);

	add	rcx, 32					; 00000020H
	add	rdx, rcx
	lea	rcx, QWORD PTR $T18[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	r14, rax

; 340  :     for (int i = 0; i < this->m_HashKeyTable.size(); i++)

	mov	esi, r12d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rbx, QWORD PTR [r13+24]
	mov	r15, QWORD PTR [r13+32]
	sub	r15, rbx
	sar	r15, 5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 340  :     for (int i = 0; i < this->m_HashKeyTable.size(); i++)

	test	r15, r15
	je	SHORT $LN195@WriteNode
$LL196@WriteNode:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rdx, r14

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [r14+24], 16
	jb	SHORT $LN208@WriteNode

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [r14]
$LN208@WriteNode:

; 4584 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	r8, QWORD PTR [rbx+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rbx

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rbx+24], 16
	jb	SHORT $LN213@WriteNode

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rbx]
$LN213@WriteNode:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	r8, QWORD PTR [r14+16]
	jne	SHORT $LN219@WriteNode

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	je	$LN531@WriteNode
$LN219@WriteNode:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 340  :     for (int i = 0; i < this->m_HashKeyTable.size(); i++)

	inc	esi
	add	rbx, 32					; 00000020H
	movsxd	rax, esi
	cmp	rax, r15
	jb	SHORT $LL196@WriteNode
$LN195@WriteNode:

; 345  :         }
; 346  :     }
; 347  :     return 0;

	mov	esi, r12d
	mov	r15d, DWORD PTR $T11[rsp]
$LN193@WriteNode:

; 474  :                 Writer.WriteInteger(GetHashKeyTableIndex(Node.GetChild(i)->GetKey()), 3);

	mov	rcx, r14
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	mov	edx, esi
	mov	r8d, 3
	mov	rcx, rdi
	call	?WriteInteger@BinaryVectorWriter@@QEAAX_JH@Z ; BinaryVectorWriter::WriteInteger
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r14, QWORD PTR _My_data$2$[rbp-256]
	mov	rax, QWORD PTR [r14]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 475  :                 Writer.WriteByte((char)Node.GetChild(i)->GetType());

	mov	rbx, QWORD PTR tv3573[rsp]
	movzx	ebx, BYTE PTR [rbx+rax+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [rdi+8]
	sub	rdx, QWORD PTR [rdi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	mov	rcx, rdi
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR [rdi+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR [rdi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], bl

; 14   : 	this->m_Offset++;

	inc	DWORD PTR [rdi+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR tv3589[rsp]
	add	rcx, QWORD PTR [r14]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 476  :                 this->WriteNode(Writer, DataOffset, EntryOffset + 4, *Node.GetChild(i));

	lea	r9d, DWORD PTR [r15+3]
	mov	QWORD PTR [rsp+32], rcx
	mov	r8d, DWORD PTR DataOffset$GSCopy$1$[rsp]
	mov	rdx, rdi
	mov	rcx, r13
	call	?WriteNode@BymlFile@@AEAAXAEAVBinaryVectorWriter@@IIAEAVNode@1@@Z ; BymlFile::WriteNode

; 477  :                 while (Writer.GetPosition() % 4 != 0) //Aligning up after dict content by 4 bytes

	mov	eax, DWORD PTR [rdi+24]
	and	eax, -2147483645			; ffffffff80000003H
	jge	SHORT $LN568@WriteNode
	dec	eax
	or	eax, -4
	inc	eax
$LN568@WriteNode:
	test	eax, eax
	je	SHORT $LN12@WriteNode
	npad	12
$LL15@WriteNode:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [rdi+8]
	sub	rdx, QWORD PTR [rdi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	mov	rcx, rdi
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR [rdi+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR [rdi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], r12b

; 14   : 	this->m_Offset++;

	inc	DWORD PTR [rdi+24]
	mov	eax, DWORD PTR [rdi+24]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 477  :                 while (Writer.GetPosition() % 4 != 0) //Aligning up after dict content by 4 bytes

	and	eax, -2147483645			; ffffffff80000003H
	jge	SHORT $LN567@WriteNode
	dec	eax
	or	eax, -4
	inc	eax
$LN567@WriteNode:
	test	eax, eax
	jne	SHORT $LL15@WriteNode
$LN12@WriteNode:

; 470  :             for (int i = 0; i < Node.GetChildren().size(); i++)

	mov	r8d, DWORD PTR i$1$[rbp-256]
	inc	r8d
	mov	DWORD PTR i$1$[rbp-256], r8d
	mov	esi, DWORD PTR tv3646[rsp]
	add	esi, 8
	mov	DWORD PTR tv3646[rsp], esi
	add	QWORD PTR tv3573[rsp], 88		; 00000058H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [r14+8]
	sub	rax, QWORD PTR [r14]
	sar	rax, 3
	mov	rcx, 3353953467947191203		; 2e8ba2e8ba2e8ba3H
	imul	rax, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 470  :             for (int i = 0; i < Node.GetChildren().size(); i++)

	movsxd	rbx, r8d
	cmp	rbx, rax
	jb	$LL14@WriteNode
	mov	r12, QWORD PTR Node$GSCopy$1$[rsp]
	mov	r15d, DWORD PTR LocalOffset$1$[rsp]
$LN13@WriteNode:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	lea	rax, QWORD PTR $T21[rbp-256]
	mov	QWORD PTR $T3[rsp], rax
	mov	rdx, r12
	lea	rcx, QWORD PTR $T21[rbp-256]
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	npad	1
	movzx	eax, BYTE PTR [r12+24]
	mov	BYTE PTR $T21[rbp-232], al
	lea	rdx, QWORD PTR [r12+32]
	lea	rcx, QWORD PTR $T21[rbp-224]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rdx, r14
	lea	rcx, QWORD PTR $T21[rbp-192]
	call	??0?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@AEBV01@@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::vector<BymlFile::Node,std::allocator<BymlFile::Node> >
	npad	1
	mov	DWORD PTR $T21[rbp-168], r15d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 938  :         return emplace(_STD move(_Val));

	lea	r8, QWORD PTR $T21[rbp-256]
	lea	rdx, QWORD PTR $T6[rsp]
	lea	rcx, QWORD PTR [r13+152]
	call	??$emplace@U?$pair@$$CBVNode@BymlFile@@I@std@@@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVNode@BymlFile@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBVNode@BymlFile@@I@1@@Z ; std::_Hash<std::_Umap_traits<BymlFile::Node,unsigned int,std::_Uhash_compare<BymlFile::Node,BymlFile::NodeHasher,BymlFile::NodeEqual>,std::allocator<std::pair<BymlFile::Node const ,unsigned int> >,0> >::emplace<std::pair<BymlFile::Node const ,unsigned int> >
	npad	1
	lea	rcx, QWORD PTR $T21[rbp-256]
	call	??1Node@BymlFile@@QEAA@XZ
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 483  :         }

	jmp	$LN106@WriteNode
$LN531@WriteNode:

; 344  :             return i;

	mov	r15d, DWORD PTR tv3646[rsp]
	inc	r15d
	jmp	$LN193@WriteNode
$LN35@WriteNode:

; 491  :         Logger::Error("BymlEncoder", "Unsupported node type: " + std::to_string((int)Node.GetType()));

	lea	rbx, QWORD PTR $T20[rbp-256]
	mov	QWORD PTR $T5[rsp], rbx
	lea	rcx, QWORD PTR $T17[rbp-256]
	call	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ; std::to_string
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3537 :         return insert(_Off, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r9d, 23
	lea	r8, OFFSET FLAT:??_C@_0BI@HCAOJHPJ@Unsupported?5node?5type?3?5@
	mov	rcx, rax
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T20[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T20[rbp-240], rsi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T20[rbp-232], rsi

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T20[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T20[rbp-240], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 491  :         Logger::Error("BymlEncoder", "Unsupported node type: " + std::to_string((int)Node.GetType()));

	mov	QWORD PTR [rax+16], rsi
	mov	QWORD PTR [rax+24], 15
	mov	BYTE PTR [rax], 0
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T12[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T12[rsp+16], rsi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T12[rsp+24], rsi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 11
	lea	rdx, OFFSET FLAT:??_C@_0M@ILPEJFEL@BymlEncoder@
	lea	rcx, QWORD PTR $T12[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 491  :         Logger::Error("BymlEncoder", "Unsupported node type: " + std::to_string((int)Node.GetType()));

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T12[rsp]
	call	?Error@Logger@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; Logger::Error
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR $T17[rbp-232]
	cmp	rdx, 16

; 4832 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN106@WriteNode

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T17[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN118@WriteNode

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN118@WriteNode
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN118@WriteNode:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN106@WriteNode:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 494  :     if (Writer.GetPosition() > this->m_WriterLastOffset)

	mov	eax, DWORD PTR [rdi+24]
	cmp	eax, DWORD PTR [r13+76]
	jbe	SHORT $LN36@WriteNode

; 495  :     {
; 496  :         this->m_WriterLastOffset = Writer.GetPosition();

	mov	DWORD PTR [r13+76], eax
$LN36@WriteNode:

; 497  :     }
; 498  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 328				; 00000148H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
$LN573@WriteNode:
	npad	1
$LN572@WriteNode:
	DD	$LN22@WriteNode
	DD	$LN29@WriteNode
	DD	$LN32@WriteNode
	DD	$LN21@WriteNode
	DD	$LN20@WriteNode
	DD	$LN18@WriteNode
	DD	$LN19@WriteNode
	DD	$LN25@WriteNode
	DD	$LN23@WriteNode
	DD	$LN27@WriteNode
	DD	$LN35@WriteNode
$LN571@WriteNode:
	DB	0
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	1
	DB	2
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	3
	DB	4
	DB	5
	DB	6
	DB	7
	DB	8
	DB	9
?WriteNode@BymlFile@@AEAAXAEAVBinaryVectorWriter@@IIAEAVNode@1@@Z ENDP ; BymlFile::WriteNode
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv3589 = 48
$T1 = 48
$T2 = 48
$T3 = 48
$T4 = 48
$T5 = 48
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 48
$T10 = 48
DataOffset$GSCopy$1$ = 64
tv3646 = 68
$T11 = 72
LocalOffset$1$ = 76
$T12 = 80
$T13 = 80
$T14 = 80
$T15 = 80
Node$GSCopy$1$ = 112
Value$16 = 112
tv3573 = 120
_My_data$2$ = 128
$T17 = 136
$T18 = 136
$T19 = 136
$T20 = 168
$T21 = 208
$T22 = 208
i$1$ = 304
LocalOffset$1$ = 304
Value$23 = 304
__$ArrayPad$ = 312
this$ = 400
Writer$ = 408
DataOffset$ = 416
Offset$ = 424
Node$ = 432
?dtor$1@?0??WriteNode@BymlFile@@AEAAXAEAVBinaryVectorWriter@@IIAEAVNode@1@@Z@4HA PROC ; `BymlFile::WriteNode'::`1'::dtor$1
	lea	rcx, QWORD PTR $T15[rdx]
	jmp	??1?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@QEAA@XZ
?dtor$1@?0??WriteNode@BymlFile@@AEAAXAEAVBinaryVectorWriter@@IIAEAVNode@1@@Z@4HA ENDP ; `BymlFile::WriteNode'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv3589 = 48
$T1 = 48
$T2 = 48
$T3 = 48
$T4 = 48
$T5 = 48
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 48
$T10 = 48
DataOffset$GSCopy$1$ = 64
tv3646 = 68
$T11 = 72
LocalOffset$1$ = 76
$T12 = 80
$T13 = 80
$T14 = 80
$T15 = 80
Node$GSCopy$1$ = 112
Value$16 = 112
tv3573 = 120
_My_data$2$ = 128
$T17 = 136
$T18 = 136
$T19 = 136
$T20 = 168
$T21 = 208
$T22 = 208
i$1$ = 304
LocalOffset$1$ = 304
Value$23 = 304
__$ArrayPad$ = 312
this$ = 400
Writer$ = 408
DataOffset$ = 416
Offset$ = 424
Node$ = 432
?dtor$2@?0??WriteNode@BymlFile@@AEAAXAEAVBinaryVectorWriter@@IIAEAVNode@1@@Z@4HA PROC ; `BymlFile::WriteNode'::`1'::dtor$2
	lea	rcx, QWORD PTR $T14[rdx]
	jmp	??1?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@QEAA@XZ
?dtor$2@?0??WriteNode@BymlFile@@AEAAXAEAVBinaryVectorWriter@@IIAEAVNode@1@@Z@4HA ENDP ; `BymlFile::WriteNode'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv3589 = 48
$T1 = 48
$T2 = 48
$T3 = 48
$T4 = 48
$T5 = 48
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 48
$T10 = 48
DataOffset$GSCopy$1$ = 64
tv3646 = 68
$T11 = 72
LocalOffset$1$ = 76
$T12 = 80
$T13 = 80
$T14 = 80
$T15 = 80
Node$GSCopy$1$ = 112
Value$16 = 112
tv3573 = 120
_My_data$2$ = 128
$T17 = 136
$T18 = 136
$T19 = 136
$T20 = 168
$T21 = 208
$T22 = 208
i$1$ = 304
LocalOffset$1$ = 304
Value$23 = 304
__$ArrayPad$ = 312
this$ = 400
Writer$ = 408
DataOffset$ = 416
Offset$ = 424
Node$ = 432
?dtor$3@?0??WriteNode@BymlFile@@AEAAXAEAVBinaryVectorWriter@@IIAEAVNode@1@@Z@4HA PROC ; `BymlFile::WriteNode'::`1'::dtor$3
	lea	rcx, QWORD PTR $T13[rdx]
	jmp	??1?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@QEAA@XZ
?dtor$3@?0??WriteNode@BymlFile@@AEAAXAEAVBinaryVectorWriter@@IIAEAVNode@1@@Z@4HA ENDP ; `BymlFile::WriteNode'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv3589 = 48
$T1 = 48
$T2 = 48
$T3 = 48
$T4 = 48
$T5 = 48
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 48
$T10 = 48
DataOffset$GSCopy$1$ = 64
tv3646 = 68
$T11 = 72
LocalOffset$1$ = 76
$T12 = 80
$T13 = 80
$T14 = 80
$T15 = 80
Node$GSCopy$1$ = 112
Value$16 = 112
tv3573 = 120
_My_data$2$ = 128
$T17 = 136
$T18 = 136
$T19 = 136
$T20 = 168
$T21 = 208
$T22 = 208
i$1$ = 304
LocalOffset$1$ = 304
Value$23 = 304
__$ArrayPad$ = 312
this$ = 400
Writer$ = 408
DataOffset$ = 416
Offset$ = 424
Node$ = 432
?dtor$11@?0??WriteNode@BymlFile@@AEAAXAEAVBinaryVectorWriter@@IIAEAVNode@1@@Z@4HA PROC ; `BymlFile::WriteNode'::`1'::dtor$11
	mov	rcx, QWORD PTR $T4[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$11@?0??WriteNode@BymlFile@@AEAAXAEAVBinaryVectorWriter@@IIAEAVNode@1@@Z@4HA ENDP ; `BymlFile::WriteNode'::`1'::dtor$11
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv3589 = 48
$T1 = 48
$T2 = 48
$T3 = 48
$T4 = 48
$T5 = 48
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 48
$T10 = 48
DataOffset$GSCopy$1$ = 64
tv3646 = 68
$T11 = 72
LocalOffset$1$ = 76
$T12 = 80
$T13 = 80
$T14 = 80
$T15 = 80
Node$GSCopy$1$ = 112
Value$16 = 112
tv3573 = 120
_My_data$2$ = 128
$T17 = 136
$T18 = 136
$T19 = 136
$T20 = 168
$T21 = 208
$T22 = 208
i$1$ = 304
LocalOffset$1$ = 304
Value$23 = 304
__$ArrayPad$ = 312
this$ = 400
Writer$ = 408
DataOffset$ = 416
Offset$ = 424
Node$ = 432
?dtor$12@?0??WriteNode@BymlFile@@AEAAXAEAVBinaryVectorWriter@@IIAEAVNode@1@@Z@4HA PROC ; `BymlFile::WriteNode'::`1'::dtor$12
	mov	rcx, QWORD PTR $T4[rdx]
	add	rcx, 32					; 00000020H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$12@?0??WriteNode@BymlFile@@AEAAXAEAVBinaryVectorWriter@@IIAEAVNode@1@@Z@4HA ENDP ; `BymlFile::WriteNode'::`1'::dtor$12
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv3589 = 48
$T1 = 48
$T2 = 48
$T3 = 48
$T4 = 48
$T5 = 48
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 48
$T10 = 48
DataOffset$GSCopy$1$ = 64
tv3646 = 68
$T11 = 72
LocalOffset$1$ = 76
$T12 = 80
$T13 = 80
$T14 = 80
$T15 = 80
Node$GSCopy$1$ = 112
Value$16 = 112
tv3573 = 120
_My_data$2$ = 128
$T17 = 136
$T18 = 136
$T19 = 136
$T20 = 168
$T21 = 208
$T22 = 208
i$1$ = 304
LocalOffset$1$ = 304
Value$23 = 304
__$ArrayPad$ = 312
this$ = 400
Writer$ = 408
DataOffset$ = 416
Offset$ = 424
Node$ = 432
?dtor$4@?0??WriteNode@BymlFile@@AEAAXAEAVBinaryVectorWriter@@IIAEAVNode@1@@Z@4HA PROC ; `BymlFile::WriteNode'::`1'::dtor$4
	lea	rcx, QWORD PTR $T22[rdx]
	jmp	??1?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@XZ
?dtor$4@?0??WriteNode@BymlFile@@AEAAXAEAVBinaryVectorWriter@@IIAEAVNode@1@@Z@4HA ENDP ; `BymlFile::WriteNode'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv3589 = 48
$T1 = 48
$T2 = 48
$T3 = 48
$T4 = 48
$T5 = 48
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 48
$T10 = 48
DataOffset$GSCopy$1$ = 64
tv3646 = 68
$T11 = 72
LocalOffset$1$ = 76
$T12 = 80
$T13 = 80
$T14 = 80
$T15 = 80
Node$GSCopy$1$ = 112
Value$16 = 112
tv3573 = 120
_My_data$2$ = 128
$T17 = 136
$T18 = 136
$T19 = 136
$T20 = 168
$T21 = 208
$T22 = 208
i$1$ = 304
LocalOffset$1$ = 304
Value$23 = 304
__$ArrayPad$ = 312
this$ = 400
Writer$ = 408
DataOffset$ = 416
Offset$ = 424
Node$ = 432
?dtor$26@?0??WriteNode@BymlFile@@AEAAXAEAVBinaryVectorWriter@@IIAEAVNode@1@@Z@4HA PROC ; `BymlFile::WriteNode'::`1'::dtor$26
	mov	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$26@?0??WriteNode@BymlFile@@AEAAXAEAVBinaryVectorWriter@@IIAEAVNode@1@@Z@4HA ENDP ; `BymlFile::WriteNode'::`1'::dtor$26
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv3589 = 48
$T1 = 48
$T2 = 48
$T3 = 48
$T4 = 48
$T5 = 48
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 48
$T10 = 48
DataOffset$GSCopy$1$ = 64
tv3646 = 68
$T11 = 72
LocalOffset$1$ = 76
$T12 = 80
$T13 = 80
$T14 = 80
$T15 = 80
Node$GSCopy$1$ = 112
Value$16 = 112
tv3573 = 120
_My_data$2$ = 128
$T17 = 136
$T18 = 136
$T19 = 136
$T20 = 168
$T21 = 208
$T22 = 208
i$1$ = 304
LocalOffset$1$ = 304
Value$23 = 304
__$ArrayPad$ = 312
this$ = 400
Writer$ = 408
DataOffset$ = 416
Offset$ = 424
Node$ = 432
?dtor$27@?0??WriteNode@BymlFile@@AEAAXAEAVBinaryVectorWriter@@IIAEAVNode@1@@Z@4HA PROC ; `BymlFile::WriteNode'::`1'::dtor$27
	mov	rcx, QWORD PTR $T3[rdx]
	add	rcx, 32					; 00000020H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$27@?0??WriteNode@BymlFile@@AEAAXAEAVBinaryVectorWriter@@IIAEAVNode@1@@Z@4HA ENDP ; `BymlFile::WriteNode'::`1'::dtor$27
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv3589 = 48
$T1 = 48
$T2 = 48
$T3 = 48
$T4 = 48
$T5 = 48
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 48
$T10 = 48
DataOffset$GSCopy$1$ = 64
tv3646 = 68
$T11 = 72
LocalOffset$1$ = 76
$T12 = 80
$T13 = 80
$T14 = 80
$T15 = 80
Node$GSCopy$1$ = 112
Value$16 = 112
tv3573 = 120
_My_data$2$ = 128
$T17 = 136
$T18 = 136
$T19 = 136
$T20 = 168
$T21 = 208
$T22 = 208
i$1$ = 304
LocalOffset$1$ = 304
Value$23 = 304
__$ArrayPad$ = 312
this$ = 400
Writer$ = 408
DataOffset$ = 416
Offset$ = 424
Node$ = 432
?dtor$6@?0??WriteNode@BymlFile@@AEAAXAEAVBinaryVectorWriter@@IIAEAVNode@1@@Z@4HA PROC ; `BymlFile::WriteNode'::`1'::dtor$6
	lea	rcx, QWORD PTR $T21[rdx]
	jmp	??1?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@XZ
?dtor$6@?0??WriteNode@BymlFile@@AEAAXAEAVBinaryVectorWriter@@IIAEAVNode@1@@Z@4HA ENDP ; `BymlFile::WriteNode'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv3589 = 48
$T1 = 48
$T2 = 48
$T3 = 48
$T4 = 48
$T5 = 48
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 48
$T10 = 48
DataOffset$GSCopy$1$ = 64
tv3646 = 68
$T11 = 72
LocalOffset$1$ = 76
$T12 = 80
$T13 = 80
$T14 = 80
$T15 = 80
Node$GSCopy$1$ = 112
Value$16 = 112
tv3573 = 120
_My_data$2$ = 128
$T17 = 136
$T18 = 136
$T19 = 136
$T20 = 168
$T21 = 208
$T22 = 208
i$1$ = 304
LocalOffset$1$ = 304
Value$23 = 304
__$ArrayPad$ = 312
this$ = 400
Writer$ = 408
DataOffset$ = 416
Offset$ = 424
Node$ = 432
?dtor$7@?0??WriteNode@BymlFile@@AEAAXAEAVBinaryVectorWriter@@IIAEAVNode@1@@Z@4HA PROC ; `BymlFile::WriteNode'::`1'::dtor$7
	lea	rcx, QWORD PTR $T17[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$7@?0??WriteNode@BymlFile@@AEAAXAEAVBinaryVectorWriter@@IIAEAVNode@1@@Z@4HA ENDP ; `BymlFile::WriteNode'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv3589 = 48
$T1 = 48
$T2 = 48
$T3 = 48
$T4 = 48
$T5 = 48
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 48
$T10 = 48
DataOffset$GSCopy$1$ = 64
tv3646 = 68
$T11 = 72
LocalOffset$1$ = 76
$T12 = 80
$T13 = 80
$T14 = 80
$T15 = 80
Node$GSCopy$1$ = 112
Value$16 = 112
tv3573 = 120
_My_data$2$ = 128
$T17 = 136
$T18 = 136
$T19 = 136
$T20 = 168
$T21 = 208
$T22 = 208
i$1$ = 304
LocalOffset$1$ = 304
Value$23 = 304
__$ArrayPad$ = 312
this$ = 400
Writer$ = 408
DataOffset$ = 416
Offset$ = 424
Node$ = 432
?dtor$8@?0??WriteNode@BymlFile@@AEAAXAEAVBinaryVectorWriter@@IIAEAVNode@1@@Z@4HA PROC ; `BymlFile::WriteNode'::`1'::dtor$8
	mov	rcx, QWORD PTR $T5[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$8@?0??WriteNode@BymlFile@@AEAAXAEAVBinaryVectorWriter@@IIAEAVNode@1@@Z@4HA ENDP ; `BymlFile::WriteNode'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\compare
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
;	COMDAT ??R<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@2@@Z@QEBA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@1@Z
_TEXT	SEGMENT
this$dead$ = 48
A$ = 56
B$ = 64
??R<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@2@@Z@QEBA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@1@Z PROC ; `BymlFile::ToBinary'::`2'::<lambda_1>::operator(), COMDAT

; 535  :     std::sort(this->m_HashKeyTable.begin(), this->m_HashKeyTable.end(), [](std::string A, std::string B) { return A < B; });

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx
	mov	rsi, r8
	mov	rcx, rdi
	mov	rdx, r8
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 535  :     std::sort(this->m_HashKeyTable.begin(), this->m_HashKeyTable.end(), [](std::string A, std::string B) { return A < B; });

	movzx	ebx, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	mov	rcx, rsi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 535  :     std::sort(this->m_HashKeyTable.begin(), this->m_HashKeyTable.end(), [](std::string A, std::string B) { return A < B; });

	mov	rsi, QWORD PTR [rsp+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\compare

; 197  :         return _Val._Value < 0;

	shr	bl, 7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 535  :     std::sort(this->m_HashKeyTable.begin(), this->m_HashKeyTable.end(), [](std::string A, std::string B) { return A < B; });

	movzx	eax, bl
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??R<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@2@@Z@QEBA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@1@Z ENDP ; `BymlFile::ToBinary'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\compare
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
;	COMDAT ??R<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@2@@Z@QEBA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@1@Z
_TEXT	SEGMENT
this$dead$ = 48
A$ = 56
B$ = 64
??R<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@2@@Z@QEBA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@1@Z PROC ; `BymlFile::ToBinary'::`2'::<lambda_2>::operator(), COMDAT

; 536  :     std::sort(this->m_StringTable.begin(), this->m_StringTable.end(), [](std::string A, std::string B) { return A < B; });

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx
	mov	rsi, r8
	mov	rcx, rdi
	mov	rdx, r8
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 536  :     std::sort(this->m_StringTable.begin(), this->m_StringTable.end(), [](std::string A, std::string B) { return A < B; });

	movzx	ebx, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	mov	rcx, rsi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 536  :     std::sort(this->m_StringTable.begin(), this->m_StringTable.end(), [](std::string A, std::string B) { return A < B; });

	mov	rsi, QWORD PTR [rsp+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\compare

; 197  :         return _Val._Value < 0;

	shr	bl, 7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 536  :     std::sort(this->m_StringTable.begin(), this->m_StringTable.end(), [](std::string A, std::string B) { return A < B; });

	movzx	eax, bl
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??R<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@2@@Z@QEBA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@1@Z ENDP ; `BymlFile::ToBinary'::`2'::<lambda_2>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\fstream
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\fstream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\fstream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
;	COMDAT ?WriteToFile@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4TableGeneration@1@@Z
_TEXT	SEGMENT
Path$GSCopy$ = 48
Binary$ = 56
File$ = 80
__$ArrayPad$ = 352
this$ = 400
Path$ = 408
TableGeneration$dead$ = 416
?WriteToFile@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4TableGeneration@1@@Z PROC ; BymlFile::WriteToFile, COMDAT

; 610  : {

$LN97:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rbp
	push	rdi
	push	r14
	lea	rbp, QWORD PTR [rsp-112]
	sub	rsp, 368				; 00000170H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	rdi, rdx
	mov	rbx, rcx

; 609  : void BymlFile::WriteToFile(std::string Path, BymlFile::TableGeneration TableGeneration)

	mov	QWORD PTR Path$GSCopy$[rsp], rdx
	xor	edx, edx
	mov	r8d, 264				; 00000108H
	lea	rcx, QWORD PTR File$[rsp]
	call	memset
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rdx, rdi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rdi+24], 16
	jb	SHORT $LN14@WriteToFil

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdi]
$LN14@WriteToFil:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\fstream

; 226  :         : basic_ofstream(_Str.c_str(), _Mode, _Prot) {} // _Prot is an extension

	mov	r8d, 32					; 00000020H
	lea	rcx, QWORD PTR File$[rsp]
	call	??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
	mov	rax, QWORD PTR File$[rsp]
	movsxd	rdx, DWORD PTR [rax+4]
	lea	r14, OFFSET FLAT:??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
	mov	QWORD PTR File$[rsp+rdx], r14
	mov	rax, QWORD PTR File$[rsp]
	movsxd	rdx, DWORD PTR [rax+4]
	lea	r8d, DWORD PTR [rdx-168]
	mov	DWORD PTR File$[rsp+rdx-4], r8d
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR Binary$[rsp], xmm0
	mov	QWORD PTR Binary$[rsp+16], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 612  :     std::vector<unsigned char> Binary = this->ToBinary(TableGeneration);

	xor	r8d, r8d
	lea	rdx, QWORD PTR Binary$[rsp]
	mov	rcx, rbx
	call	?ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@1@@Z ; BymlFile::ToBinary
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4624 :     _Seek_wrapped(_Dest, _STD _Copy_unchecked(_UFirst, _ULast, _UDest));

	mov	rsi, QWORD PTR Binary$[rsp+8]
	mov	rbx, QWORD PTR Binary$[rsp]
	cmp	rbx, rsi

; 4611 :     for (; _First != _Last; ++_Dest, (void) ++_First) {

	je	SHORT $LN42@WriteToFil
	npad	5
$LL43@WriteToFil:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream

; 948  :     return _Ostr << static_cast<char>(_Ch);

	movzx	edx, BYTE PTR [rbx]
	lea	rcx, QWORD PTR File$[rsp]
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4611 :     for (; _First != _Last; ++_Dest, (void) ++_First) {

	inc	rbx
	cmp	rbx, rsi
	jne	SHORT $LL43@WriteToFil
$LN42@WriteToFil:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\fstream

; 376  :         if (!_Filebuffer.close()) {

	lea	rcx, QWORD PTR File$[rsp+8]
	call	?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
	test	rax, rax
	jne	SHORT $LN53@WriteToFil

; 377  :             _Myios::setstate(ios_base::failbit);

	mov	rax, QWORD PTR File$[rsp]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	rax, QWORD PTR File$[rsp]
	add	rcx, rax
	xor	r8d, r8d
	lea	edx, QWORD PTR [r8+2]
	call	QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
	npad	1
$LN53@WriteToFil:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR Binary$[rsp]
	test	rcx, rcx
	je	SHORT $LN58@WriteToFil

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR Binary$[rsp+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN76@WriteToFil

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN76@WriteToFil
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN76@WriteToFil:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR Binary$[rsp], xmm0

; 2050 :             _Mylast  = nullptr;
; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR Binary$[rsp+16], 0
$LN58@WriteToFil:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\fstream

; 344  :     __CLR_OR_THIS_CALL ~basic_ofstream() noexcept override {}

	mov	rax, QWORD PTR File$[rsp]
	movsxd	rdx, DWORD PTR [rax+4]
	mov	QWORD PTR File$[rsp+rdx], r14
	mov	rax, QWORD PTR File$[rsp]
	movsxd	rdx, DWORD PTR [rax+4]
	lea	r8d, DWORD PTR [rdx-168]
	mov	DWORD PTR File$[rsp+rdx-4], r8d
	lea	rcx, QWORD PTR File$[rsp+8]
	call	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
	lea	rcx, QWORD PTR File$[rsp+16]
	call	QWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
	lea	rcx, QWORD PTR File$[rbp-88]
	call	QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rdi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 616  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+368]
	mov	rbx, QWORD PTR [r11+48]
	mov	rsi, QWORD PTR [r11+56]
	mov	rsp, r11
	pop	r14
	pop	rdi
	pop	rbp
	ret	0
$LN94@WriteToFil:
?WriteToFile@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4TableGeneration@1@@Z ENDP ; BymlFile::WriteToFile
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
Path$GSCopy$ = 48
Binary$ = 56
File$ = 80
__$ArrayPad$ = 352
this$ = 400
Path$ = 408
TableGeneration$dead$ = 416
?dtor$0@?0??WriteToFile@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4TableGeneration@1@@Z@4HA PROC ; `BymlFile::WriteToFile'::`1'::dtor$0
	mov	rcx, QWORD PTR Path$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??WriteToFile@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4TableGeneration@1@@Z@4HA ENDP ; `BymlFile::WriteToFile'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
Path$GSCopy$ = 48
Binary$ = 56
File$ = 80
__$ArrayPad$ = 352
this$ = 400
Path$ = 408
TableGeneration$dead$ = 416
?dtor$1@?0??WriteToFile@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4TableGeneration@1@@Z@4HA PROC ; `BymlFile::WriteToFile'::`1'::dtor$1
	lea	rcx, QWORD PTR File$[rdx]
	jmp	??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
?dtor$1@?0??WriteToFile@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4TableGeneration@1@@Z@4HA ENDP ; `BymlFile::WriteToFile'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
Path$GSCopy$ = 48
Binary$ = 56
File$ = 80
__$ArrayPad$ = 352
this$ = 400
Path$ = 408
TableGeneration$dead$ = 416
?dtor$2@?0??WriteToFile@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4TableGeneration@1@@Z@4HA PROC ; `BymlFile::WriteToFile'::`1'::dtor$2
	lea	rcx, QWORD PTR Binary$[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$2@?0??WriteToFile@BymlFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4TableGeneration@1@@Z@4HA ENDP ; `BymlFile::WriteToFile'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\__msvc_chrono.hpp
;	COMDAT ?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QEBA_JXZ PROC ; std::chrono::duration<__int64,std::ratio<1,1000> >::count, COMDAT

; 110  :             return _MyRep;

	mov	rax, QWORD PTR [rcx]

; 111  :         }

	ret	0
?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QEBA_JXZ ENDP ; std::chrono::duration<__int64,std::ratio<1,1000> >::count
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\__msvc_chrono.hpp
;	COMDAT ?time_since_epoch@?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QEBA?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?time_since_epoch@?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QEBA?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@XZ PROC ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_since_epoch, COMDAT

; 212  :             return _MyDur;

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax
	mov	rax, rdx

; 213  :         }

	ret	0
?time_since_epoch@?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QEBA?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@XZ ENDP ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_since_epoch
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\__msvc_chrono.hpp
;	COMDAT ??0?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z
_TEXT	SEGMENT
this$ = 8
_Other$ = 16
??0?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z PROC ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >, COMDAT

; 204  :             : _MyDur(_Other) {}

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??0?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z ENDP ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\unordered_map
;	COMDAT ??A?$unordered_map@VNode@BymlFile@@IUNodeHasher@2@UNodeEqual@2@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@std@@@std@@QEAAAEAIAEBVNode@BymlFile@@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Keyval$ = 72
??A?$unordered_map@VNode@BymlFile@@IUNodeHasher@2@UNodeEqual@2@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@std@@@std@@QEAAAEAIAEBVNode@BymlFile@@@Z PROC ; std::unordered_map<BymlFile::Node,unsigned int,BymlFile::NodeHasher,BymlFile::NodeEqual,std::allocator<std::pair<BymlFile::Node const ,unsigned int> > >::operator[], COMDAT

; 437  :     mapped_type& operator[](const key_type& _Keyval) {

$LN4:
	sub	rsp, 56					; 00000038H

; 438  :         return this->_Try_emplace(_Keyval).first->_Myval.second;

	mov	r8, rdx
	lea	rdx, QWORD PTR $T1[rsp]
	call	??$_Try_emplace@AEBVNode@BymlFile@@$$V@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@_N@1@AEBVNode@BymlFile@@@Z ; std::_Hash<std::_Umap_traits<BymlFile::Node,unsigned int,std::_Uhash_compare<BymlFile::Node,BymlFile::NodeHasher,BymlFile::NodeEqual>,std::allocator<std::pair<BymlFile::Node const ,unsigned int> >,0> >::_Try_emplace<BymlFile::Node const &>
	mov	rax, QWORD PTR [rax]
	add	rax, 104				; 00000068H

; 439  :     }

	add	rsp, 56					; 00000038H
	ret	0
??A?$unordered_map@VNode@BymlFile@@IUNodeHasher@2@UNodeEqual@2@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@std@@@std@@QEAAAEAIAEBVNode@BymlFile@@@Z ENDP ; std::unordered_map<BymlFile::Node,unsigned int,BymlFile::NodeHasher,BymlFile::NodeEqual,std::allocator<std::pair<BymlFile::Node const ,unsigned int> > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?insert@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVNode@BymlFile@@I@std@@@std@@@std@@@std@@_N@2@$$QEAU?$pair@$$CBVNode@BymlFile@@I@2@@Z
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
_Val$ = 64
?insert@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVNode@BymlFile@@I@std@@@std@@@std@@@std@@_N@2@$$QEAU?$pair@$$CBVNode@BymlFile@@I@2@@Z PROC ; std::_Hash<std::_Umap_traits<BymlFile::Node,unsigned int,std::_Uhash_compare<BymlFile::Node,BymlFile::NodeHasher,BymlFile::NodeEqual>,std::allocator<std::pair<BymlFile::Node const ,unsigned int> >,0> >::insert, COMDAT

; 937  :     conditional_t<_Multi, iterator, pair<iterator, bool>> insert(value_type&& _Val) {

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx

; 938  :         return emplace(_STD move(_Val));

	call	??$emplace@U?$pair@$$CBVNode@BymlFile@@I@std@@@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVNode@BymlFile@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBVNode@BymlFile@@I@1@@Z ; std::_Hash<std::_Umap_traits<BymlFile::Node,unsigned int,std::_Uhash_compare<BymlFile::Node,BymlFile::NodeHasher,BymlFile::NodeEqual>,std::allocator<std::pair<BymlFile::Node const ,unsigned int> >,0> >::emplace<std::pair<BymlFile::Node const ,unsigned int> >
	mov	rax, rbx

; 939  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?insert@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVNode@BymlFile@@I@std@@@std@@@std@@@std@@_N@2@$$QEAU?$pair@$$CBVNode@BymlFile@@I@2@@Z ENDP ; std::_Hash<std::_Umap_traits<BymlFile::Node,unsigned int,std::_Uhash_compare<BymlFile::Node,BymlFile::NodeHasher,BymlFile::NodeEqual>,std::allocator<std::pair<BymlFile::Node const ,unsigned int> >,0> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\unordered_map
;	COMDAT ??A?$unordered_map@V?$vector@EV?$allocator@E@std@@@std@@IUVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@@std@@QEAAAEAIAEBV?$vector@EV?$allocator@E@std@@@1@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Keyval$ = 72
??A?$unordered_map@V?$vector@EV?$allocator@E@std@@@std@@IUVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@@std@@QEAAAEAIAEBV?$vector@EV?$allocator@E@std@@@1@@Z PROC ; std::unordered_map<std::vector<unsigned char,std::allocator<unsigned char> >,unsigned int,BymlFile::VectorHasher,std::equal_to<std::vector<unsigned char,std::allocator<unsigned char> > >,std::allocator<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> > >::operator[], COMDAT

; 437  :     mapped_type& operator[](const key_type& _Keyval) {

$LN4:
	sub	rsp, 56					; 00000038H

; 438  :         return this->_Try_emplace(_Keyval).first->_Myval.second;

	mov	r8, rdx
	lea	rdx, QWORD PTR $T1[rsp]
	call	??$_Try_emplace@AEBV?$vector@EV?$allocator@E@std@@@std@@$$V@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@_N@1@AEBV?$vector@EV?$allocator@E@std@@@1@@Z ; std::_Hash<std::_Umap_traits<std::vector<unsigned char,std::allocator<unsigned char> >,unsigned int,std::_Uhash_compare<std::vector<unsigned char,std::allocator<unsigned char> >,BymlFile::VectorHasher,std::equal_to<std::vector<unsigned char,std::allocator<unsigned char> > > >,std::allocator<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >,0> >::_Try_emplace<std::vector<unsigned char,std::allocator<unsigned char> > const &>
	mov	rax, QWORD PTR [rax]
	add	rax, 40					; 00000028H

; 439  :     }

	add	rsp, 56					; 00000038H
	ret	0
??A?$unordered_map@V?$vector@EV?$allocator@E@std@@@std@@IUVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@@std@@QEAAAEAIAEBV?$vector@EV?$allocator@E@std@@@1@@Z ENDP ; std::unordered_map<std::vector<unsigned char,std::allocator<unsigned char> >,unsigned int,BymlFile::VectorHasher,std::equal_to<std::vector<unsigned char,std::allocator<unsigned char> > >,std::allocator<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?insert@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@std@@@std@@@std@@_N@2@$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@2@@Z
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
_Val$ = 64
?insert@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@std@@@std@@@std@@_N@2@$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@2@@Z PROC ; std::_Hash<std::_Umap_traits<std::vector<unsigned char,std::allocator<unsigned char> >,unsigned int,std::_Uhash_compare<std::vector<unsigned char,std::allocator<unsigned char> >,BymlFile::VectorHasher,std::equal_to<std::vector<unsigned char,std::allocator<unsigned char> > > >,std::allocator<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >,0> >::insert, COMDAT

; 937  :     conditional_t<_Multi, iterator, pair<iterator, bool>> insert(value_type&& _Val) {

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx

; 938  :         return emplace(_STD move(_Val));

	call	??$emplace@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@@Z ; std::_Hash<std::_Umap_traits<std::vector<unsigned char,std::allocator<unsigned char> >,unsigned int,std::_Uhash_compare<std::vector<unsigned char,std::allocator<unsigned char> >,BymlFile::VectorHasher,std::equal_to<std::vector<unsigned char,std::allocator<unsigned char> > > >,std::allocator<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >,0> >::emplace<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >
	mov	rax, rbx

; 939  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?insert@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@std@@@std@@@std@@_N@2@$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@2@@Z ENDP ; std::_Hash<std::_Umap_traits<std::vector<unsigned char,std::allocator<unsigned char> >,unsigned int,std::_Uhash_compare<std::vector<unsigned char,std::allocator<unsigned char> >,BymlFile::VectorHasher,std::equal_to<std::vector<unsigned char,std::allocator<unsigned char> > > >,std::allocator<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >,0> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[], COMDAT

; 1883 :         auto& _My_data = _Mypair._Myval2;
; 1884 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1885 :         _STL_VERIFY(
; 1886 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1887 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1888 : 
; 1889 :         return _My_data._Myfirst[_Pos];

	shl	rdx, 5
	add	rdx, QWORD PTR [rcx]
	mov	rax, rdx

; 1890 :     }

	ret	0
??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?clear@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::clear, COMDAT

; 1761 :     _CONSTEXPR20 void clear() noexcept { // erase all

$LN27:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1762 :         auto& _My_data    = _Mypair._Myval2;
; 1763 :         pointer& _Myfirst = _My_data._Myfirst;
; 1764 :         pointer& _Mylast  = _My_data._Mylast;
; 1765 : 
; 1766 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

	mov	rbx, QWORD PTR [rcx]
	mov	rsi, rcx
	mov	rdi, QWORD PTR [rcx+8]
	cmp	rbx, rdi
	je	SHORT $LN1@clear
	npad	2
$LL7@clear:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 32					; 00000020H
	cmp	rbx, rdi
	jne	SHORT $LL7@clear
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1776 :         _Mylast = _Myfirst;

	mov	rax, QWORD PTR [rsi]
	mov	QWORD PTR [rsi+8], rax
$LN1@clear:

; 1777 :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?clear@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?shrink_to_fit@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?shrink_to_fit@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::shrink_to_fit, COMDAT

; 1690 :         auto& _My_data         = _Mypair._Myval2;
; 1691 :         const pointer _Oldlast = _My_data._Mylast;

	mov	rdx, QWORD PTR [rcx+8]

; 1692 :         if (_Oldlast != _My_data._Myend) { // something to do

	cmp	rdx, QWORD PTR [rcx+16]
	je	SHORT $LN4@shrink_to_

; 1693 :             const pointer _Oldfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR [rcx]

; 1694 :             if (_Oldfirst == _Oldlast) {

	cmp	rax, rdx
	je	?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
$LN3@shrink_to_:

; 1695 :                 _Tidy();
; 1696 :             } else {
; 1697 :                 _Reallocate_exactly(static_cast<size_type>(_Oldlast - _Oldfirst));

	sub	rdx, rax
	sar	rdx, 5
	jmp	?_Reallocate_exactly@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAX_K@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reallocate_exactly
$LN4@shrink_to_:

; 1698 :             }
; 1699 :         }
; 1700 :     }

	ret	0
?shrink_to_fit@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::shrink_to_fit
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?resize@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 64
_Newsize$ = 72
?resize@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAX_K@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::resize, COMDAT

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

$LN90:
	push	rbx
	push	rsi
	push	r14
	sub	rsp, 32					; 00000020H

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rbx, QWORD PTR [rcx+8]

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	mov	r14, rcx
	mov	rsi, rdx

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rdx, QWORD PTR [rcx]
	mov	rcx, rbx
	sub	rcx, rdx
	sar	rcx, 5

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rsi, rcx
	jae	SHORT $LN4@resize

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	shl	rsi, 5
	add	rsi, rdx
	mov	QWORD PTR [rsp+80], rdi

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rdi, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rsi, rbx
	je	SHORT $LN10@resize
	npad	7
$LL11@resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rdi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rdi, 32					; 00000020H
	cmp	rdi, rbx
	jne	SHORT $LL11@resize
$LN10@resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1563 :             _Mylast = _Newlast;

	mov	rdi, QWORD PTR [rsp+80]
	mov	QWORD PTR [r14+8], rsi

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	add	rsp, 32					; 00000020H
	pop	r14
	pop	rsi
	pop	rbx
	ret	0
$LN4@resize:

; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN5@resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [r14+16]
	sub	rax, rdx
	sar	rax, 5

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rsi, rax
	jbe	SHORT $LN6@resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rdx, rsi
	mov	rcx, r14

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	add	rsp, 32					; 00000020H
	pop	r14
	pop	rsi
	pop	rbx

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Resize_reallocate<std::_Value_init_tag>
$LN6@resize:

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rsi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2041 :     for (; 0 < _Count; --_Count) {

	je	SHORT $LN25@resize
	xor	eax, eax
	npad	1
$LL26@resize:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rbx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rbx, 32					; 00000020H

; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rsi, 1
	jne	SHORT $LL26@resize
$LN25@resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	mov	QWORD PTR [r14+8], rbx
$LN5@resize:

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	add	rsp, 32					; 00000020H
	pop	r14
	pop	rsi
	pop	rbx
	ret	0
?resize@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAX_K@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??A?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAAEAVNode@BymlFile@@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAAEAVNode@BymlFile@@_K@Z PROC ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::operator[], COMDAT

; 1883 :         auto& _My_data = _Mypair._Myval2;
; 1884 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1885 :         _STL_VERIFY(
; 1886 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1887 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1888 : 
; 1889 :         return _My_data._Myfirst[_Pos];

	imul	rax, rdx, 88				; 00000058H
	add	rax, QWORD PTR [rcx]

; 1890 :     }

	ret	0
??A?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAAEAVNode@BymlFile@@_K@Z ENDP ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?resize@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
?resize@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAX_K@Z PROC ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::resize, COMDAT

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

$LN88:
	mov	QWORD PTR [rsp+32], rsi
	push	r14
	sub	rsp, 32					; 00000020H

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rsi, QWORD PTR [rcx+8]

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	mov	r14, rcx

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rcx, QWORD PTR [rcx]
	mov	r8, rsi
	sub	r8, rcx
	mov	r9, 3353953467947191203			; 2e8ba2e8ba2e8ba3H
	sar	r8, 3
	imul	r8, r9

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdx, r8
	jae	SHORT $LN4@resize
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rbp

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	imul	rbp, rdx, 88				; 00000058H
	add	rbp, rcx

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rbx, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbp, rsi
	je	SHORT $LN10@resize
	mov	QWORD PTR [rsp+64], rdi
$LL11@resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	lea	rcx, QWORD PTR [rbx+64]
	call	?_Tidy@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAXXZ ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx+32]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	mov	rcx, rbx
	call	?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AEAAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 88					; 00000058H
	cmp	rbx, rsi
	jne	SHORT $LL11@resize
	mov	rdi, QWORD PTR [rsp+64]
$LN10@resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1563 :             _Mylast = _Newlast;

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [r14+8], rbp
	mov	rbp, QWORD PTR [rsp+56]

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN4@resize:

; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN5@resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [r14+16]
	sub	rax, rcx
	sar	rax, 3
	imul	rax, r9

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN6@resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, r14

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Resize_reallocate<std::_Value_init_tag>
$LN6@resize:

; 1571 :                 return;
; 1572 :             }
; 1573 : 
; 1574 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1575 :             const pointer _Oldlast = _Mylast;
; 1576 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1577 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1578 :             } else {
; 1579 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, r8
	mov	rcx, rsi
	call	??$_Uninitialized_value_construct_n@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@PEAV12@_KAEAV?$allocator@VNode@BymlFile@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<BymlFile::Node> >
	mov	QWORD PTR [r14+8], rax
$LN5@resize:

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
?resize@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAX_K@Z ENDP ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?clear@?$vector@EV?$allocator@E@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?clear@?$vector@EV?$allocator@E@std@@@std@@QEAAXXZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::clear, COMDAT

; 1762 :         auto& _My_data    = _Mypair._Myval2;
; 1763 :         pointer& _Myfirst = _My_data._Myfirst;
; 1764 :         pointer& _Mylast  = _My_data._Mylast;
; 1765 : 
; 1766 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

	mov	rax, QWORD PTR [rcx]
	cmp	rax, QWORD PTR [rcx+8]
	je	SHORT $LN1@clear

; 1767 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1768 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1769 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1770 :             return;
; 1771 :         }
; 1772 : 
; 1773 :         _My_data._Orphan_all();
; 1774 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1775 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1776 :         _Mylast = _Myfirst;

	mov	QWORD PTR [rcx+8], rax
$LN1@clear:

; 1777 :     }

	ret	0
?clear@?$vector@EV?$allocator@E@std@@@std@@QEAAXXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?_Unchecked_end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_end, COMDAT

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 16

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rdx, rcx

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN4@Unchecked_

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rcx]
$LN4@Unchecked_:

; 3949 :         return _Mypair._Myval2._Myptr() + _Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR [rcx+16]
	add	rax, rdx

; 3950 :     }

	ret	0
?_Unchecked_end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?_Unchecked_begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_begin, COMDAT

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN8@Unchecked_

; 3941 :         return _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR [rcx]

; 3942 :     }

	ret	0
$LN8@Unchecked_:

; 3941 :         return _Mypair._Myval2._Myptr();

	mov	rax, rcx

; 3942 :     }

	ret	0
?_Unchecked_begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Reallocate_exactly@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$ = 56
?_Reallocate_exactly@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAX_K@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reallocate_exactly, COMDAT

; 1601 :     _CONSTEXPR20 void _Reallocate_exactly(const size_type _Newcapacity) {

$LN92:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1602 :         // set capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1603 :         auto& _Al         = _Getal();
; 1604 :         auto& _My_data    = _Mypair._Myval2;
; 1605 :         pointer& _Myfirst = _My_data._Myfirst;
; 1606 :         pointer& _Mylast  = _My_data._Mylast;
; 1607 : 
; 1608 :         const auto _Size = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rdi, QWORD PTR [rcx+8]
	mov	rsi, rdx
	sub	rdi, QWORD PTR [rcx]
	mov	rbx, rcx
	sar	rdi, 5

; 1609 : 
; 1610 :         const pointer _Newvec = _Al.allocate(_Newcapacity);

	call	?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1932 :     const auto _ULast = _Get_unwrapped(_Last);

	mov	r11, QWORD PTR [rbx+8]

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	r10, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1601 :     _CONSTEXPR20 void _Reallocate_exactly(const size_type _Newcapacity) {

	mov	rdx, QWORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rdx, r11
	je	SHORT $LN10@Reallocate
	xor	ecx, ecx
	npad	10
$LL11@Reallocate:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [r10], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [r10+16], rcx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [r10+24], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	lea	r10, QWORD PTR [r10+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [r10-32], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [r10-16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	mov	QWORD PTR [rdx+16], rcx
	mov	QWORD PTR [rdx+24], 15
	mov	BYTE PTR [rdx], cl

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	rdx, 32					; 00000020H
	cmp	rdx, r11
	jne	SHORT $LL11@Reallocate
$LN10@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1623 :         _Change_array(_Newvec, _Size, _Newcapacity);

	mov	r9, rsi
	mov	r8, rdi
	mov	rdx, rax
	mov	rcx, rbx

; 1624 :     }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1623 :         _Change_array(_Newvec, _Size, _Newcapacity);

	jmp	?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K1@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Change_array
?_Reallocate_exactly@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAX_K@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reallocate_exactly
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\__msvc_chrono.hpp
;	COMDAT ??$?0_J$0A@@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEAA@AEB_J@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
??$?0_J$0A@@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEAA@AEB_J@Z PROC ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64,0>, COMDAT

; 99   :             : _MyRep(static_cast<_Rep>(_Val)) {}

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??$?0_J$0A@@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEAA@AEB_J@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$?8VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@YA_NAEBV?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@0@0@Z
_TEXT	SEGMENT
_Left$ = 48
_Right$ = 56
??$?8VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@YA_NAEBV?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@0@0@Z PROC ; std::operator==<BymlFile::Node,std::allocator<BymlFile::Node> >, COMDAT

; 2221 : _NODISCARD _CONSTEXPR20 bool operator==(const vector<_Ty, _Alloc>& _Left, const vector<_Ty, _Alloc>& _Right) {

$LN133:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rsi, QWORD PTR [rcx+8]
	mov	rbx, QWORD PTR [rcx]
	mov	rax, rsi
	mov	rdi, QWORD PTR [rdx]
	sub	rax, rbx
	mov	rcx, QWORD PTR [rdx+8]
	sub	rcx, rdi

; 2222 :     if (_Left.size() != _Right.size()) {

	cmp	rax, rcx
	jne	SHORT $LN124@operator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 5273 :     for (; _UFirst1 != _ULast1; ++_UFirst1, (void) ++_UFirst2) {

	cmp	rbx, rsi
	je	SHORT $LN12@operator
$LL13@operator:

; 486  :         return static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right);

	mov	rdx, rdi
	mov	rcx, rbx
	call	??8Node@BymlFile@@QEBA_NAEBV01@@Z	; BymlFile::Node::operator==

; 5274 :         if (!_Pred(*_UFirst1, *_UFirst2)) {

	test	al, al
	je	SHORT $LN124@operator

; 5273 :     for (; _UFirst1 != _ULast1; ++_UFirst1, (void) ++_UFirst2) {

	add	rbx, 88					; 00000058H
	add	rdi, 88					; 00000058H
	cmp	rbx, rsi
	jne	SHORT $LL13@operator
$LN12@operator:

; 5275 :             return false;
; 5276 :         }
; 5277 :     }
; 5278 : 
; 5279 :     return true;

	mov	al, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2232 : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN124@operator:
	mov	rbx, QWORD PTR [rsp+64]
	xor	al, al
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$?8VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@YA_NAEBV?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@0@0@Z ENDP ; std::operator==<BymlFile::Node,std::allocator<BymlFile::Node> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ??$contains@X@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@QEBA_NAEBV?$vector@EV?$allocator@E@std@@@1@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Keyval$ = 72
??$contains@X@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@QEBA_NAEBV?$vector@EV?$allocator@E@std@@@1@@Z PROC ; std::_Hash<std::_Umap_traits<std::vector<unsigned char,std::allocator<unsigned char> >,unsigned int,std::_Uhash_compare<std::vector<unsigned char,std::allocator<unsigned char> >,BymlFile::VectorHasher,std::equal_to<std::vector<unsigned char,std::allocator<unsigned char> > > >,std::allocator<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >,0> >::contains<void>, COMDAT

; 1238 :     _NODISCARD bool contains(typename _Traits::template _Deduce_key<_Keyty> _Keyval) const {

$LN21:
	push	rbx
	sub	rsp, 48					; 00000030H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r8d, DWORD PTR [rdx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1238 :     _NODISCARD bool contains(typename _Traits::template _Deduce_key<_Keyty> _Keyval) const {

	mov	r11, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	r8d, DWORD PTR [rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1238 :     _NODISCARD bool contains(typename _Traits::template _Deduce_key<_Keyty> _Keyval) const {

	mov	rbx, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h

; 164  :             for (auto& i : V) {

	mov	r10, QWORD PTR [rdx+8]
	mov	r9, QWORD PTR [rdx]
	cmp	r9, r10
	je	SHORT $LN7@contains
	npad	1
$LL14@contains:

; 165  :                 Hash ^= i + 0x9e3779b9 + (Hash << 6) + (Hash >> 2);

	movzx	ecx, BYTE PTR [r9]
	mov	edx, r8d
	mov	eax, r8d
	shl	edx, 6
	sar	eax, 2
	add	ecx, -1640531527			; ffffffff9e3779b9H
	add	edx, eax
	inc	r9
	add	ecx, edx
	xor	r8d, ecx
	cmp	r9, r10
	jne	SHORT $LL14@contains
$LN7@contains:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 147  :         return static_cast<size_t>(_Mypair._Get_first()(_Keyval));

	movsxd	r9, r8d

; 1239 :         return static_cast<bool>(_Find_last(_Keyval, _Traitsobj(_Keyval))._Duplicate);

	lea	rdx, QWORD PTR $T1[rsp]
	mov	r8, r11
	mov	rcx, rbx
	call	??$_Find_last@V?$vector@EV?$allocator@E@std@@@std@@@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@AEBV?$vector@EV?$allocator@E@std@@@1@_K@Z ; std::_Hash<std::_Umap_traits<std::vector<unsigned char,std::allocator<unsigned char> >,unsigned int,std::_Uhash_compare<std::vector<unsigned char,std::allocator<unsigned char> >,BymlFile::VectorHasher,std::equal_to<std::vector<unsigned char,std::allocator<unsigned char> > > >,std::allocator<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >,0> >::_Find_last<std::vector<unsigned char,std::allocator<unsigned char> > >
	cmp	QWORD PTR [rax+8], 0
	setne	al

; 1240 :     }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
??$contains@X@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@QEBA_NAEBV?$vector@EV?$allocator@E@std@@@1@@Z ENDP ; std::_Hash<std::_Umap_traits<std::vector<unsigned char,std::allocator<unsigned char> >,unsigned int,std::_Uhash_compare<std::vector<unsigned char,std::allocator<unsigned char> >,BymlFile::VectorHasher,std::equal_to<std::vector<unsigned char,std::allocator<unsigned char> > > >,std::allocator<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >,0> >::contains<void>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0AEAV?$vector@EV?$allocator@E@std@@@std@@I$0A@@?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@QEAA@AEAV?$vector@EV?$allocator@E@std@@@1@$$QEAI@Z
_TEXT	SEGMENT
this$ = 48
_Val1$ = 56
_Val2$ = 64
??$?0AEAV?$vector@EV?$allocator@E@std@@@std@@I$0A@@?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@QEAA@AEAV?$vector@EV?$allocator@E@std@@@1@$$QEAI@Z PROC ; std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int><std::vector<unsigned char,std::allocator<unsigned char> > &,unsigned int,0>, COMDAT

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

$LN6:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, r8
	mov	rdi, rcx
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	mov	eax, DWORD PTR [rbx]

; 243  :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	DWORD PTR [rdi+24], eax
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$?0AEAV?$vector@EV?$allocator@E@std@@@std@@I$0A@@?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@QEAA@AEAV?$vector@EV?$allocator@E@std@@@1@$$QEAI@Z ENDP ; std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int><std::vector<unsigned char,std::allocator<unsigned char> > &,unsigned int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ??$contains@X@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@QEBA_NAEBVNode@BymlFile@@@Z
_TEXT	SEGMENT
this$ = 48
_Keyval$ = 56
??$contains@X@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@QEBA_NAEBVNode@BymlFile@@@Z PROC ; std::_Hash<std::_Umap_traits<BymlFile::Node,unsigned int,std::_Uhash_compare<BymlFile::Node,BymlFile::NodeHasher,BymlFile::NodeEqual>,std::allocator<std::pair<BymlFile::Node const ,unsigned int> >,0> >::contains<void>, COMDAT

; 1238 :     _NODISCARD bool contains(typename _Traits::template _Deduce_key<_Keyty> _Keyval) const {

$LN26:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, rdx
	mov	rdi, rcx

; 1239 :         return static_cast<bool>(_Find_last(_Keyval, _Traitsobj(_Keyval))._Duplicate);

	call	??$?RVNode@BymlFile@@@?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@QEBA_KAEBVNode@BymlFile@@@Z ; std::_Uhash_compare<BymlFile::Node,BymlFile::NodeHasher,BymlFile::NodeEqual>::operator()<BymlFile::Node>

; 1567 :         const size_type _Bucket = _Hashval & _Mask;

	mov	r8, QWORD PTR [rdi+48]
	and	r8, rax

; 1568 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

	mov	rax, QWORD PTR [rdi+24]
	add	r8, r8
	mov	rbx, QWORD PTR [rax+r8*8+8]

; 1569 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;
; 1570 :         if (_Where == _End) {

	cmp	rbx, QWORD PTR [rdi+8]
	je	SHORT $LN18@contains

; 1571 :             return {_End, _Nodeptr{}};
; 1572 :         }
; 1573 : 
; 1574 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	rdi, QWORD PTR [rax+r8*8]

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	lea	rdx, QWORD PTR [rbx+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h

; 175  :             return Node1 == Node2;

	mov	rcx, rsi
	call	??8Node@BymlFile@@QEBA_NAEBV01@@Z	; BymlFile::Node::operator==
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 154  :         return !static_cast<bool>(_Mypair._Myval2._Get_first()(_Keyval1, _Keyval2));

	test	al, al

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	jne	SHORT $LN17@contains
$LL4@contains:

; 1578 :                 if constexpr (!_Traits::_Standard) {
; 1579 :                     if (_Traitsobj(_Traits::_Kfn(_Where->_Myval), _Keyval)) {
; 1580 :                         return {_Where->_Next, _Nodeptr{}};
; 1581 :                     }
; 1582 :                 }
; 1583 : 
; 1584 :                 return {_Where->_Next, _Where};
; 1585 :             }
; 1586 : 
; 1587 :             if (_Where == _Bucket_lo) {

	cmp	rbx, rdi
	je	SHORT $LN18@contains

; 1588 :                 return {_Where, _Nodeptr{}};
; 1589 :             }
; 1590 : 
; 1591 :             _Where = _Where->_Prev;

	mov	rbx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h

; 175  :             return Node1 == Node2;

	mov	rcx, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	lea	rdx, QWORD PTR [rbx+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h

; 175  :             return Node1 == Node2;

	call	??8Node@BymlFile@@QEBA_NAEBV01@@Z	; BymlFile::Node::operator==
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 154  :         return !static_cast<bool>(_Mypair._Myval2._Get_first()(_Keyval1, _Keyval2));

	test	al, al

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	je	SHORT $LL4@contains
	jmp	SHORT $LN17@contains
$LN18@contains:

; 1239 :         return static_cast<bool>(_Find_last(_Keyval, _Traitsobj(_Keyval))._Duplicate);

	xor	ebx, ebx
$LN17@contains:

; 1240 :     }

	mov	rsi, QWORD PTR [rsp+56]
	test	rbx, rbx
	mov	rbx, QWORD PTR [rsp+48]
	setne	al
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$contains@X@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@QEBA_NAEBVNode@BymlFile@@@Z ENDP ; std::_Hash<std::_Umap_traits<BymlFile::Node,unsigned int,std::_Uhash_compare<BymlFile::Node,BymlFile::NodeHasher,BymlFile::NodeEqual>,std::allocator<std::pair<BymlFile::Node const ,unsigned int> >,0> >::contains<void>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0AEAVNode@BymlFile@@AEAI$0A@@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@AEAVNode@BymlFile@@AEAI@Z
_TEXT	SEGMENT
$T1 = 48
this$ = 48
_Val1$ = 56
_Val2$ = 64
??$?0AEAVNode@BymlFile@@AEAI$0A@@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@AEAVNode@BymlFile@@AEAI@Z PROC ; std::pair<BymlFile::Node const ,unsigned int>::pair<BymlFile::Node const ,unsigned int><BymlFile::Node &,unsigned int &,0>, COMDAT

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

$LN11:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, r8
	mov	rbx, rdx
	mov	rsi, rcx
	mov	QWORD PTR $T1[rsp], rcx
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	npad	1
	movzx	eax, BYTE PTR [rbx+24]
	mov	BYTE PTR [rsi+24], al
	lea	rcx, QWORD PTR [rsi+32]
	lea	rdx, QWORD PTR [rbx+32]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rsi+64]
	lea	rdx, QWORD PTR [rbx+64]
	call	??0?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@AEBV01@@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::vector<BymlFile::Node,std::allocator<BymlFile::Node> >
	npad	1
	mov	eax, DWORD PTR [rdi]
	mov	DWORD PTR [rsi+88], eax

; 243  :     }

	mov	rax, rsi
	mov	rbx, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$?0AEAVNode@BymlFile@@AEAI$0A@@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@AEAVNode@BymlFile@@AEAI@Z ENDP ; std::pair<BymlFile::Node const ,unsigned int>::pair<BymlFile::Node const ,unsigned int><BymlFile::Node &,unsigned int &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
this$ = 48
_Val1$ = 56
_Val2$ = 64
?dtor$1@?0???$?0AEAVNode@BymlFile@@AEAI$0A@@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@AEAVNode@BymlFile@@AEAI@Z@4HA PROC ; `std::pair<BymlFile::Node const ,unsigned int>::pair<BymlFile::Node const ,unsigned int><BymlFile::Node &,unsigned int &,0>'::`1'::dtor$1
	mov	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$1@?0???$?0AEAVNode@BymlFile@@AEAI$0A@@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@AEAVNode@BymlFile@@AEAI@Z@4HA ENDP ; `std::pair<BymlFile::Node const ,unsigned int>::pair<BymlFile::Node const ,unsigned int><BymlFile::Node &,unsigned int &,0>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
this$ = 48
_Val1$ = 56
_Val2$ = 64
?dtor$2@?0???$?0AEAVNode@BymlFile@@AEAI$0A@@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@AEAVNode@BymlFile@@AEAI@Z@4HA PROC ; `std::pair<BymlFile::Node const ,unsigned int>::pair<BymlFile::Node const ,unsigned int><BymlFile::Node &,unsigned int &,0>'::`1'::dtor$2
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 32					; 00000020H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0???$?0AEAVNode@BymlFile@@AEAI$0A@@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@AEAVNode@BymlFile@@AEAI@Z@4HA ENDP ; `std::pair<BymlFile::Node const ,unsigned int>::pair<BymlFile::Node const ,unsigned int><BymlFile::Node &,unsigned int &,0>'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\__msvc_chrono.hpp
;	COMDAT ??$duration_cast@V?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Dur$ = 16
??$duration_cast@V?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z PROC ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000> >,__int64,std::ratio<1,10000000>,0>, COMDAT

; 423  :         // convert duration to another duration; truncate
; 424  :         using _CF = ratio_divide<_Period, typename _To::period>;
; 425  : 
; 426  :         using _ToRep = typename _To::rep;
; 427  :         using _CR    = common_type_t<_ToRep, _Rep, intmax_t>;
; 428  : 
; 429  :         constexpr bool _Num_is_one = _CF::num == 1;
; 430  :         constexpr bool _Den_is_one = _CF::den == 1;
; 431  : 
; 432  :         if (_Den_is_one) {
; 433  :             if (_Num_is_one) {
; 434  :                 return static_cast<_To>(static_cast<_ToRep>(_Dur.count()));
; 435  :             } else {
; 436  :                 return static_cast<_To>(
; 437  :                     static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)));
; 438  :             }
; 439  :         } else {
; 440  :             if (_Num_is_one) {
; 441  :                 return static_cast<_To>(

	mov	rax, 3777893186295716171		; 346dc5d63886594bH
	imul	QWORD PTR [rdx]
	sar	rdx, 11
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
	mov	rax, rcx

; 99   :             : _MyRep(static_cast<_Rep>(_Val)) {}

	mov	QWORD PTR [rcx], rdx

; 442  :                     static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) / static_cast<_CR>(_CF::den)));
; 443  :             } else {
; 444  :                 return static_cast<_To>(static_cast<_ToRep>(
; 445  :                     static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num) / static_cast<_CR>(_CF::den)));
; 446  :             }
; 447  :         }
; 448  :     }

	ret	0
??$duration_cast@V?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z ENDP ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000> >,__int64,std::ratio<1,10000000>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Pred$dead$ = 64
$T1 = 64
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z PROC ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,`BymlFile::ToBinary'::`2'::<lambda_1> >, COMDAT

; 8063 : _CONSTEXPR20 void sort(const _RanIt _First, const _RanIt _Last, _Pr _Pred) { // order [_First, _Last)

	mov	BYTE PTR [rsp+24], r8b
	sub	rsp, 40					; 00000028H

; 8064 :     _Adl_verify_range(_First, _Last);
; 8065 :     const auto _UFirst = _Get_unwrapped(_First);
; 8066 :     const auto _ULast  = _Get_unwrapped(_Last);
; 8067 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

	movzx	r9d, BYTE PTR $T1[rsp]
	mov	r8, rdx
	sub	r8, rcx
	sar	r8, 5

; 8068 : }

	add	rsp, 40					; 00000028H

; 8064 :     _Adl_verify_range(_First, _Last);
; 8065 :     const auto _UFirst = _Get_unwrapped(_First);
; 8066 :     const auto _ULast  = _Get_unwrapped(_Last);
; 8067 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

	jmp	??$_Sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0_JV<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ; std::_Sort_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ENDP ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,`BymlFile::ToBinary'::`2'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Pass_fn@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@3@@Z@@std@@YA?A_PAEAV<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@3@@Z@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Func$dead$ = 16
??$_Pass_fn@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@3@@Z@@std@@YA?A_PAEAV<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@3@@Z@@Z PROC ; std::_Pass_fn<`BymlFile::ToBinary'::`2'::<lambda_1> >, COMDAT

; 556  :     constexpr bool _Pass_by_value = conjunction_v<bool_constant<sizeof(_Fn) <= sizeof(void*)>,
; 557  :         is_trivially_copy_constructible<_Fn>, is_trivially_destructible<_Fn>>;
; 558  :     if constexpr (_Pass_by_value) {
; 559  :         return _Func;

	mov	rax, rcx

; 560  :     } else {
; 561  :         return _Ref_fn<_Fn>{_Func}; // pass functor by "reference"
; 562  :     }
; 563  : }

	ret	0
??$_Pass_fn@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@3@@Z@@std@@YA?A_PAEAV<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@3@@Z@@Z ENDP ; std::_Pass_fn<`BymlFile::ToBinary'::`2'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Pred$dead$ = 64
$T1 = 64
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z PROC ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,`BymlFile::ToBinary'::`2'::<lambda_2> >, COMDAT

; 8063 : _CONSTEXPR20 void sort(const _RanIt _First, const _RanIt _Last, _Pr _Pred) { // order [_First, _Last)

	mov	BYTE PTR [rsp+24], r8b
	sub	rsp, 40					; 00000028H

; 8064 :     _Adl_verify_range(_First, _Last);
; 8065 :     const auto _UFirst = _Get_unwrapped(_First);
; 8066 :     const auto _ULast  = _Get_unwrapped(_Last);
; 8067 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

	movzx	r9d, BYTE PTR $T1[rsp]
	mov	r8, rdx
	sub	r8, rcx
	sar	r8, 5

; 8068 : }

	add	rsp, 40					; 00000028H

; 8064 :     _Adl_verify_range(_First, _Last);
; 8065 :     const auto _UFirst = _Get_unwrapped(_First);
; 8066 :     const auto _ULast  = _Get_unwrapped(_Last);
; 8067 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

	jmp	??$_Sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0_JV<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ; std::_Sort_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ENDP ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,`BymlFile::ToBinary'::`2'::<lambda_2> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Pass_fn@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@3@@Z@@std@@YA?A_PAEAV<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@3@@Z@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Func$dead$ = 16
??$_Pass_fn@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@3@@Z@@std@@YA?A_PAEAV<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@3@@Z@@Z PROC ; std::_Pass_fn<`BymlFile::ToBinary'::`2'::<lambda_2> >, COMDAT

; 556  :     constexpr bool _Pass_by_value = conjunction_v<bool_constant<sizeof(_Fn) <= sizeof(void*)>,
; 557  :         is_trivially_copy_constructible<_Fn>, is_trivially_destructible<_Fn>>;
; 558  :     if constexpr (_Pass_by_value) {
; 559  :         return _Func;

	mov	rax, rcx

; 560  :     } else {
; 561  :         return _Ref_fn<_Fn>{_Func}; // pass functor by "reference"
; 562  :     }
; 563  : }

	ret	0
??$_Pass_fn@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@3@@Z@@std@@YA?A_PAEAV<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@3@@Z@@Z ENDP ; std::_Pass_fn<`BymlFile::ToBinary'::`2'::<lambda_2> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\__msvc_chrono.hpp
;	COMDAT ??$?G_JU?$ratio@$00$0DOI@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@AEBV201@0@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Left$ = 16
_Right$ = 24
??$?G_JU?$ratio@$00$0DOI@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@AEBV201@0@Z PROC ; std::chrono::operator-<__int64,std::ratio<1,1000>,__int64,std::ratio<1,1000> >, COMDAT

; 291  :         using _CD = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
; 292  :         return _CD(_CD(_Left).count() - _CD(_Right).count());

	mov	rax, QWORD PTR [rdx]
	sub	rax, QWORD PTR [r8]

; 99   :             : _MyRep(static_cast<_Rep>(_Val)) {}

	mov	QWORD PTR [rcx], rax

; 291  :         using _CD = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
; 292  :         return _CD(_CD(_Left).count() - _CD(_Right).count());

	mov	rax, rcx

; 293  :     }

	ret	0
??$?G_JU?$ratio@$00$0DOI@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@AEBV201@0@Z ENDP ; std::chrono::operator-<__int64,std::ratio<1,1000>,__int64,std::ratio<1,1000> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ??$_Try_emplace@AEBVNode@BymlFile@@$$V@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@_N@1@AEBVNode@BymlFile@@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
_Hashval$1$ = 48
_Newnode$ = 56
this$ = 144
__$ReturnUdt$ = 152
_Keyval_arg$ = 160
??$_Try_emplace@AEBVNode@BymlFile@@$$V@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@_N@1@AEBVNode@BymlFile@@@Z PROC ; std::_Hash<std::_Umap_traits<BymlFile::Node,unsigned int,std::_Uhash_compare<BymlFile::Node,BymlFile::NodeHasher,BymlFile::NodeEqual>,std::allocator<std::pair<BymlFile::Node const ,unsigned int> >,0> >::_Try_emplace<BymlFile::Node const &>, COMDAT

; 693  :     pair<_Nodeptr, bool> _Try_emplace(_Keyty&& _Keyval_arg, _Mappedty&&... _Mapval) {

$LN179:
	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H
	mov	rdi, r8
	mov	r14, rdx
	mov	r15, rcx

; 694  :         const auto& _Keyval = _Keyval_arg;
; 695  :         const auto _Hashval = _Traitsobj(_Keyval);

	mov	rdx, r8
	call	??$?RVNode@BymlFile@@@?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@QEBA_KAEBVNode@BymlFile@@@Z ; std::_Uhash_compare<BymlFile::Node,BymlFile::NodeHasher,BymlFile::NodeEqual>::operator()<BymlFile::Node>
	mov	QWORD PTR _Hashval$1$[rsp], rax

; 1567 :         const size_type _Bucket = _Hashval & _Mask;

	mov	rsi, rax
	and	rsi, QWORD PTR [r15+48]

; 1568 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

	add	rsi, rsi
	mov	rax, QWORD PTR [r15+24]
	mov	rbx, QWORD PTR [rax+rsi*8+8]

; 1569 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;

	lea	rcx, QWORD PTR [r15+8]
	mov	r12, QWORD PTR [rcx]

; 1570 :         if (_Where == _End) {

	cmp	rbx, r12
	jne	SHORT $LN10@Try_emplac

; 1571 :             return {_End, _Nodeptr{}};

	mov	rbx, r12
	mov	rbp, r12
	jmp	SHORT $LN2@Try_emplac
$LN10@Try_emplac:

; 1572 :         }
; 1573 : 
; 1574 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	rsi, QWORD PTR [rax+rsi*8]

; 1575 :         for (;;) {
; 1576 :             // Search backwards to maintain sorted [_Bucket_lo, _Bucket_hi] when !_Standard
; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	lea	rdx, QWORD PTR [rbx+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h

; 175  :             return Node1 == Node2;

	mov	rcx, rdi
	call	??8Node@BymlFile@@QEBA_NAEBV01@@Z	; BymlFile::Node::operator==
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 154  :         return !static_cast<bool>(_Mypair._Myval2._Get_first()(_Keyval1, _Keyval2));

	test	al, al

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	jne	SHORT $LN157@Try_emplac
$LL7@Try_emplac:

; 1585 :             }
; 1586 : 
; 1587 :             if (_Where == _Bucket_lo) {

	cmp	rbx, rsi
	je	SHORT $LN158@Try_emplac

; 1589 :             }
; 1590 : 
; 1591 :             _Where = _Where->_Prev;

	mov	rbx, QWORD PTR [rbx+8]

; 1575 :         for (;;) {
; 1576 :             // Search backwards to maintain sorted [_Bucket_lo, _Bucket_hi] when !_Standard
; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	lea	rdx, QWORD PTR [rbx+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h

; 175  :             return Node1 == Node2;

	mov	rcx, rdi
	call	??8Node@BymlFile@@QEBA_NAEBV01@@Z	; BymlFile::Node::operator==
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 154  :         return !static_cast<bool>(_Mypair._Myval2._Get_first()(_Keyval1, _Keyval2));

	test	al, al

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	je	SHORT $LL7@Try_emplac
$LN157@Try_emplac:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR [r14], rbx
	mov	BYTE PTR [r14+8], 0
$LN176@Try_emplac:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 711  :     }

	mov	rax, r14
	mov	rbx, QWORD PTR [rsp+168]
	add	rsp, 80					; 00000050H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN158@Try_emplac:

; 1588 :                 return {_Where, _Nodeptr{}};

	mov	r12, rbx
	mov	rbp, rbx
	lea	rcx, QWORD PTR [r15+8]
$LN2@Try_emplac:

; 1647 :         if (_Oldsize == _List.max_size()) {

	mov	rax, 164703072086692425			; 0249249249249249H
	cmp	QWORD PTR [r15+16], rax
	jne	SHORT $LN21@Try_emplac

; 1648 :             _Xlength_error("unordered_map/set too long");

	lea	rcx, OFFSET FLAT:??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN21@Try_emplac:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1144 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR _Newnode$[rsp], rcx

; 1151 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR _Newnode$[rsp+8], 0

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 112				; 00000070H
	call	??2@YAPEAX_K@Z				; operator new
	mov	rsi, rax

; 1152 :         _Ptr = _Al.allocate(1);

	mov	QWORD PTR _Newnode$[rsp+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 586  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

	lea	r13, QWORD PTR [rax+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	QWORD PTR $T1[rsp], r13
	mov	rdx, rdi
	mov	rcx, r13
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	npad	1
	movzx	eax, BYTE PTR [rdi+24]
	mov	BYTE PTR [r13+24], al
	lea	rcx, QWORD PTR [r13+32]
	lea	rdx, QWORD PTR [rdi+32]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [r13+64]
	lea	rdx, QWORD PTR [rdi+64]
	call	??0?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@AEBV01@@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::vector<BymlFile::Node,std::allocator<BymlFile::Node> >
	npad	1
	mov	DWORD PTR [r13+88], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1653 :         const size_type _Oldsize = _List._Mypair._Myval2._Mysize;

	mov	rdx, QWORD PTR [r15+16]

; 1654 :         const auto _Newsize      = _Oldsize + 1;

	add	rdx, 1

; 1655 :         return max_load_factor() < static_cast<float>(_Newsize) / static_cast<float>(bucket_count());

	xorps	xmm0, xmm0
	js	SHORT $LN170@Try_emplac
	cvtsi2ss xmm0, rdx
	jmp	SHORT $LN171@Try_emplac
$LN170@Try_emplac:
	mov	rcx, rdx
	shr	rcx, 1
	mov	rax, rdx
	and	eax, 1
	or	rcx, rax
	cvtsi2ss xmm0, rcx
	addss	xmm0, xmm0
$LN171@Try_emplac:
	mov	rcx, QWORD PTR [r15+56]
	xorps	xmm1, xmm1
	test	rcx, rcx
	js	SHORT $LN168@Try_emplac
	cvtsi2ss xmm1, rcx
	jmp	SHORT $LN169@Try_emplac
$LN168@Try_emplac:
	mov	rax, rcx
	shr	rax, 1
	and	ecx, 1
	or	rax, rcx
	cvtsi2ss xmm1, rax
	addss	xmm1, xmm1
$LN169@Try_emplac:
	divss	xmm0, xmm1
	comiss	xmm0, DWORD PTR [r15]
	seta	al

; 696  :         auto _Target        = _Find_last(_Keyval, _Hashval);
; 697  :         if (_Target._Duplicate) {
; 698  :             return {_Target._Duplicate, false};
; 699  :         }
; 700  : 
; 701  :         _Check_max_size();
; 702  :         _List_node_emplace_op2<_Alnode> _Newnode(_List._Getal(), piecewise_construct,
; 703  :             _STD forward_as_tuple(_STD forward<_Keyty>(_Keyval_arg)),
; 704  :             _STD forward_as_tuple(_STD forward<_Mappedty>(_Mapval)...));
; 705  :         if (_Check_rehash_required_1()) {

	test	al, al
	je	SHORT $LN3@Try_emplac

; 1661 :         _Forced_rehash(_Desired_grow_bucket_count(_Newsize));

	mov	rcx, r15
	call	?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@IEBA_K_K@Z ; std::_Hash<std::_Umap_traits<BymlFile::Node,unsigned int,std::_Uhash_compare<BymlFile::Node,BymlFile::NodeHasher,BymlFile::NodeEqual>,std::allocator<std::pair<BymlFile::Node const ,unsigned int> >,0> >::_Desired_grow_bucket_count
	mov	rdx, rax
	mov	rcx, r15
	call	?_Forced_rehash@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@IEAAX_K@Z ; std::_Hash<std::_Umap_traits<BymlFile::Node,unsigned int,std::_Uhash_compare<BymlFile::Node,BymlFile::NodeHasher,BymlFile::NodeEqual>,std::allocator<std::pair<BymlFile::Node const ,unsigned int> >,0> >::_Forced_rehash

; 1567 :         const size_type _Bucket = _Hashval & _Mask;

	mov	rbp, QWORD PTR [r15+48]
	and	rbp, QWORD PTR _Hashval$1$[rsp]

; 1568 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

	add	rbp, rbp
	mov	rax, QWORD PTR [r15+24]
	mov	rdi, QWORD PTR [rax+rbp*8+8]

; 1569 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;

	mov	rbx, QWORD PTR [r15+8]

; 1570 :         if (_Where == _End) {

	cmp	rdi, rbx
	jne	SHORT $LN146@Try_emplac

; 1571 :             return {_End, _Nodeptr{}};

	mov	QWORD PTR $T2[rsp+8], 0
	jmp	SHORT $LN173@Try_emplac
$LN146@Try_emplac:

; 1572 :         }
; 1573 : 
; 1574 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	rbp, QWORD PTR [rax+rbp*8]

; 1575 :         for (;;) {
; 1576 :             // Search backwards to maintain sorted [_Bucket_lo, _Bucket_hi] when !_Standard
; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	lea	rdx, QWORD PTR [rdi+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h

; 175  :             return Node1 == Node2;

	mov	rcx, r13
	call	??8Node@BymlFile@@QEBA_NAEBV01@@Z	; BymlFile::Node::operator==
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 154  :         return !static_cast<bool>(_Mypair._Myval2._Get_first()(_Keyval1, _Keyval2));

	test	al, al

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	jne	SHORT $LN159@Try_emplac
	npad	3
$LL143@Try_emplac:

; 1585 :             }
; 1586 : 
; 1587 :             if (_Where == _Bucket_lo) {

	mov	rbx, rdi
	cmp	rdi, rbp
	je	SHORT $LN160@Try_emplac

; 1589 :             }
; 1590 : 
; 1591 :             _Where = _Where->_Prev;

	mov	rdi, QWORD PTR [rdi+8]

; 1575 :         for (;;) {
; 1576 :             // Search backwards to maintain sorted [_Bucket_lo, _Bucket_hi] when !_Standard
; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	lea	rdx, QWORD PTR [rdi+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h

; 175  :             return Node1 == Node2;

	mov	rcx, r13
	call	??8Node@BymlFile@@QEBA_NAEBV01@@Z	; BymlFile::Node::operator==
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 154  :         return !static_cast<bool>(_Mypair._Myval2._Get_first()(_Keyval1, _Keyval2));

	test	al, al

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	je	SHORT $LL143@Try_emplac
$LN159@Try_emplac:

; 1578 :                 if constexpr (!_Traits::_Standard) {
; 1579 :                     if (_Traitsobj(_Traits::_Kfn(_Where->_Myval), _Keyval)) {
; 1580 :                         return {_Where->_Next, _Nodeptr{}};
; 1581 :                     }
; 1582 :                 }
; 1583 : 
; 1584 :                 return {_Where->_Next, _Where};

	mov	rbx, QWORD PTR [rdi]
$LN173@Try_emplac:

; 706  :             _Rehash_for_1();
; 707  :             _Target = _Find_last(_Traits::_Kfn(_Newnode._Ptr->_Myval), _Hashval);

	mov	QWORD PTR $T2[rsp], rbx
$LN174@Try_emplac:
	mov	rbp, rbx
	mov	r12, QWORD PTR $T2[rsp]
$LN3@Try_emplac:

; 1615 :         const _Nodeptr _Insert_after = _Insert_before->_Prev;

	mov	rdx, QWORD PTR [rbx+8]

; 1616 :         ++_List._Mypair._Myval2._Mysize;

	inc	QWORD PTR [r15+16]

; 1617 :         _Construct_in_place(_Newnode->_Next, _Insert_before);

	mov	QWORD PTR [rsi], r12

; 1618 :         _Construct_in_place(_Newnode->_Prev, _Insert_after);

	mov	QWORD PTR [rsi+8], rdx

; 1619 :         _Insert_after->_Next  = _Newnode;

	mov	QWORD PTR [rdx], rsi

; 1620 :         _Insert_before->_Prev = _Newnode;

	mov	QWORD PTR [rbx+8], rsi

; 1621 : 
; 1622 :         const auto _Head                = _List._Mypair._Myval2._Myhead;
; 1623 :         const auto _Bucket_array        = _Vec._Mypair._Myval2._Myfirst;

	mov	rcx, QWORD PTR [r15+24]

; 1624 :         const size_type _Bucket         = _Hashval & _Mask;

	mov	rax, QWORD PTR [r15+48]
	and	rax, QWORD PTR _Hashval$1$[rsp]

; 1625 :         _Unchecked_iterator& _Bucket_lo = _Bucket_array[_Bucket << 1];

	add	rax, rax

; 1626 :         _Unchecked_iterator& _Bucket_hi = _Bucket_array[(_Bucket << 1) + 1];
; 1627 :         if (_Bucket_lo._Ptr == _Head) {

	mov	r8, QWORD PTR [rcx+rax*8]
	cmp	r8, QWORD PTR [r15+8]
	jne	SHORT $LN94@Try_emplac

; 1628 :             // bucket is empty, set both
; 1629 :             _Bucket_lo._Ptr = _Newnode;

	mov	QWORD PTR [rcx+rax*8], rsi

; 1630 :             _Bucket_hi._Ptr = _Newnode;

	jmp	SHORT $LN175@Try_emplac
$LN160@Try_emplac:

; 1588 :                 return {_Where, _Nodeptr{}};

	mov	QWORD PTR $T2[rsp], rdi
	mov	QWORD PTR $T2[rsp+8], 0
	jmp	SHORT $LN174@Try_emplac
$LN94@Try_emplac:

; 1631 :         } else if (_Bucket_lo._Ptr == _Insert_before) {

	cmp	r8, rbp
	jne	SHORT $LN96@Try_emplac

; 1632 :             // new node is the lowest element in the bucket
; 1633 :             _Bucket_lo._Ptr = _Newnode;

	mov	QWORD PTR [rcx+rax*8], rsi
	jmp	SHORT $LN98@Try_emplac
$LN96@Try_emplac:

; 1634 :         } else if (_Bucket_hi._Ptr == _Insert_after) {

	cmp	QWORD PTR [rcx+rax*8+8], rdx
	jne	SHORT $LN98@Try_emplac
$LN175@Try_emplac:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR [rcx+rax*8+8], rsi
$LN98@Try_emplac:
	mov	QWORD PTR [r14], rsi
	mov	BYTE PTR [r14+8], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 710  :         return {_Insert_new_node_before(_Hashval, _Target._Insert_before, _Newnode._Release()), true};

	jmp	$LN176@Try_emplac
$LN172@Try_emplac:
??$_Try_emplace@AEBVNode@BymlFile@@$$V@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@_N@1@AEBVNode@BymlFile@@@Z ENDP ; std::_Hash<std::_Umap_traits<BymlFile::Node,unsigned int,std::_Uhash_compare<BymlFile::Node,BymlFile::NodeHasher,BymlFile::NodeEqual>,std::allocator<std::pair<BymlFile::Node const ,unsigned int> >,0> >::_Try_emplace<BymlFile::Node const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
_Hashval$1$ = 48
_Newnode$ = 56
this$ = 144
__$ReturnUdt$ = 152
_Keyval_arg$ = 160
?dtor$1@?0???$_Try_emplace@AEBVNode@BymlFile@@$$V@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@_N@1@AEBVNode@BymlFile@@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<BymlFile::Node,unsigned int,std::_Uhash_compare<BymlFile::Node,BymlFile::NodeHasher,BymlFile::NodeEqual>,std::allocator<std::pair<BymlFile::Node const ,unsigned int> >,0> >::_Try_emplace<BymlFile::Node const &>'::`1'::dtor$1
	lea	rcx, QWORD PTR _Newnode$[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > >
?dtor$1@?0???$_Try_emplace@AEBVNode@BymlFile@@$$V@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@_N@1@AEBVNode@BymlFile@@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<BymlFile::Node,unsigned int,std::_Uhash_compare<BymlFile::Node,BymlFile::NodeHasher,BymlFile::NodeEqual>,std::allocator<std::pair<BymlFile::Node const ,unsigned int> >,0> >::_Try_emplace<BymlFile::Node const &>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
_Hashval$1$ = 48
_Newnode$ = 56
this$ = 144
__$ReturnUdt$ = 152
_Keyval_arg$ = 160
?dtor$4@?0???$_Try_emplace@AEBVNode@BymlFile@@$$V@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@_N@1@AEBVNode@BymlFile@@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<BymlFile::Node,unsigned int,std::_Uhash_compare<BymlFile::Node,BymlFile::NodeHasher,BymlFile::NodeEqual>,std::allocator<std::pair<BymlFile::Node const ,unsigned int> >,0> >::_Try_emplace<BymlFile::Node const &>'::`1'::dtor$4
	mov	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$4@?0???$_Try_emplace@AEBVNode@BymlFile@@$$V@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@_N@1@AEBVNode@BymlFile@@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<BymlFile::Node,unsigned int,std::_Uhash_compare<BymlFile::Node,BymlFile::NodeHasher,BymlFile::NodeEqual>,std::allocator<std::pair<BymlFile::Node const ,unsigned int> >,0> >::_Try_emplace<BymlFile::Node const &>'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
_Hashval$1$ = 48
_Newnode$ = 56
this$ = 144
__$ReturnUdt$ = 152
_Keyval_arg$ = 160
?dtor$5@?0???$_Try_emplace@AEBVNode@BymlFile@@$$V@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@_N@1@AEBVNode@BymlFile@@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<BymlFile::Node,unsigned int,std::_Uhash_compare<BymlFile::Node,BymlFile::NodeHasher,BymlFile::NodeEqual>,std::allocator<std::pair<BymlFile::Node const ,unsigned int> >,0> >::_Try_emplace<BymlFile::Node const &>'::`1'::dtor$5
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 32					; 00000020H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$5@?0???$_Try_emplace@AEBVNode@BymlFile@@$$V@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@_N@1@AEBVNode@BymlFile@@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<BymlFile::Node,unsigned int,std::_Uhash_compare<BymlFile::Node,BymlFile::NodeHasher,BymlFile::NodeEqual>,std::allocator<std::pair<BymlFile::Node const ,unsigned int> >,0> >::_Try_emplace<BymlFile::Node const &>'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
_Hashval$1$ = 48
_Newnode$ = 56
this$ = 144
__$ReturnUdt$ = 152
_Keyval_arg$ = 160
?dtor$0@?0???$_Try_emplace@AEBVNode@BymlFile@@$$V@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@_N@1@AEBVNode@BymlFile@@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<BymlFile::Node,unsigned int,std::_Uhash_compare<BymlFile::Node,BymlFile::NodeHasher,BymlFile::NodeEqual>,std::allocator<std::pair<BymlFile::Node const ,unsigned int> >,0> >::_Try_emplace<BymlFile::Node const &>'::`1'::dtor$0
	lea	rcx, QWORD PTR _Newnode$[rdx]
	jmp	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > >
?dtor$0@?0???$_Try_emplace@AEBVNode@BymlFile@@$$V@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@_N@1@AEBVNode@BymlFile@@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<BymlFile::Node,unsigned int,std::_Uhash_compare<BymlFile::Node,BymlFile::NodeHasher,BymlFile::NodeEqual>,std::allocator<std::pair<BymlFile::Node const ,unsigned int> >,0> >::_Try_emplace<BymlFile::Node const &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAU?$pair@$$CBVNode@BymlFile@@I@std@@@std@@YA$$QEAU?$pair@$$CBVNode@BymlFile@@I@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAU?$pair@$$CBVNode@BymlFile@@I@std@@@std@@YA$$QEAU?$pair@$$CBVNode@BymlFile@@I@0@AEAU10@@Z PROC ; std::move<std::pair<BymlFile::Node const ,unsigned int> &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAU?$pair@$$CBVNode@BymlFile@@I@std@@@std@@YA$$QEAU?$pair@$$CBVNode@BymlFile@@I@0@AEAU10@@Z ENDP ; std::move<std::pair<BymlFile::Node const ,unsigned int> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ??$emplace@U?$pair@$$CBVNode@BymlFile@@I@std@@@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVNode@BymlFile@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBVNode@BymlFile@@I@1@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
_Hashval$1$ = 48
_Newnode$3 = 56
this$ = 144
__$ReturnUdt$ = 152
<_Vals_0>$ = 160
??$emplace@U?$pair@$$CBVNode@BymlFile@@I@std@@@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVNode@BymlFile@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBVNode@BymlFile@@I@1@@Z PROC ; std::_Hash<std::_Umap_traits<BymlFile::Node,unsigned int,std::_Uhash_compare<BymlFile::Node,BymlFile::NodeHasher,BymlFile::NodeEqual>,std::allocator<std::pair<BymlFile::Node const ,unsigned int> >,0> >::emplace<std::pair<BymlFile::Node const ,unsigned int> >, COMDAT

; 589  :     conditional_t<_Multi, iterator, pair<iterator, bool>> emplace(_Valtys&&... _Vals) {

$LN182:
	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H
	mov	rdi, r8
	mov	r14, rdx
	mov	r15, rcx

; 590  :         // try to insert value_type(_Vals...)
; 591  :         using _In_place_key_extractor = typename _Traits::template _In_place_key_extractor<_Remove_cvref_t<_Valtys>...>;
; 592  :         if constexpr (_Multi) {
; 593  :             _Check_max_size();
; 594  :             _List_node_emplace_op2<_Alnode> _Newnode(_List._Getal(), _STD forward<_Valtys>(_Vals)...);
; 595  :             const auto& _Keyval = _Traits::_Kfn(_Newnode._Ptr->_Myval);
; 596  :             const auto _Hashval = _Traitsobj(_Keyval);
; 597  :             if (_Check_rehash_required_1()) {
; 598  :                 _Rehash_for_1();
; 599  :             }
; 600  : 
; 601  :             const auto _Target = _Find_last(_Keyval, _Hashval);
; 602  :             return _List._Make_iter(_Insert_new_node_before(_Hashval, _Target._Insert_before, _Newnode._Release()));
; 603  :         } else if constexpr (_In_place_key_extractor::_Extractable) {
; 604  :             const auto& _Keyval = _In_place_key_extractor::_Extract(_Vals...);
; 605  :             const auto _Hashval = _Traitsobj(_Keyval);

	mov	rdx, r8
	call	??$?RVNode@BymlFile@@@?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@QEBA_KAEBVNode@BymlFile@@@Z ; std::_Uhash_compare<BymlFile::Node,BymlFile::NodeHasher,BymlFile::NodeEqual>::operator()<BymlFile::Node>
	mov	QWORD PTR _Hashval$1$[rsp], rax

; 1567 :         const size_type _Bucket = _Hashval & _Mask;

	mov	rsi, rax
	and	rsi, QWORD PTR [r15+48]

; 1568 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

	add	rsi, rsi
	mov	rax, QWORD PTR [r15+24]
	mov	rbx, QWORD PTR [rax+rsi*8+8]

; 1569 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;

	lea	rcx, QWORD PTR [r15+8]
	mov	r12, QWORD PTR [rcx]

; 1570 :         if (_Where == _End) {

	cmp	rbx, r12
	jne	SHORT $LN10@emplace

; 1571 :             return {_End, _Nodeptr{}};

	mov	rbx, r12
	mov	rbp, r12
	jmp	SHORT $LN2@emplace
$LN10@emplace:

; 1572 :         }
; 1573 : 
; 1574 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	rsi, QWORD PTR [rax+rsi*8]

; 1575 :         for (;;) {
; 1576 :             // Search backwards to maintain sorted [_Bucket_lo, _Bucket_hi] when !_Standard
; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	lea	rdx, QWORD PTR [rbx+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h

; 175  :             return Node1 == Node2;

	mov	rcx, rdi
	call	??8Node@BymlFile@@QEBA_NAEBV01@@Z	; BymlFile::Node::operator==
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 154  :         return !static_cast<bool>(_Mypair._Myval2._Get_first()(_Keyval1, _Keyval2));

	test	al, al

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	jne	SHORT $LN160@emplace
$LL7@emplace:

; 1585 :             }
; 1586 : 
; 1587 :             if (_Where == _Bucket_lo) {

	cmp	rbx, rsi
	je	SHORT $LN161@emplace

; 1589 :             }
; 1590 : 
; 1591 :             _Where = _Where->_Prev;

	mov	rbx, QWORD PTR [rbx+8]

; 1575 :         for (;;) {
; 1576 :             // Search backwards to maintain sorted [_Bucket_lo, _Bucket_hi] when !_Standard
; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	lea	rdx, QWORD PTR [rbx+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h

; 175  :             return Node1 == Node2;

	mov	rcx, rdi
	call	??8Node@BymlFile@@QEBA_NAEBV01@@Z	; BymlFile::Node::operator==
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 154  :         return !static_cast<bool>(_Mypair._Myval2._Get_first()(_Keyval1, _Keyval2));

	test	al, al

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	je	SHORT $LL7@emplace
$LN160@emplace:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR [r14], rbx
	mov	BYTE PTR [r14+8], 0
$LN179@emplace:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 639  :     }

	mov	rax, r14
	mov	rbx, QWORD PTR [rsp+168]
	add	rsp, 80					; 00000050H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN161@emplace:

; 1588 :                 return {_Where, _Nodeptr{}};

	mov	r12, rbx
	mov	rbp, rbx
	lea	rcx, QWORD PTR [r15+8]
$LN2@emplace:

; 1647 :         if (_Oldsize == _List.max_size()) {

	mov	rax, 164703072086692425			; 0249249249249249H
	cmp	QWORD PTR [r15+16], rax
	jne	SHORT $LN29@emplace

; 1648 :             _Xlength_error("unordered_map/set too long");

	lea	rcx, OFFSET FLAT:??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN29@emplace:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1144 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR _Newnode$3[rsp], rcx

; 1151 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR _Newnode$3[rsp+8], 0

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 112				; 00000070H
	call	??2@YAPEAX_K@Z				; operator new
	mov	rsi, rax

; 1152 :         _Ptr = _Al.allocate(1);

	mov	QWORD PTR _Newnode$3[rsp+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 586  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

	lea	r13, QWORD PTR [rax+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 246  :     pair(pair&&)      = default;

	mov	QWORD PTR $T1[rsp], r13
	mov	rdx, rdi
	mov	rcx, r13
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	npad	1
	movzx	eax, BYTE PTR [rdi+24]
	mov	BYTE PTR [r13+24], al
	lea	rcx, QWORD PTR [r13+32]
	lea	rdx, QWORD PTR [rdi+32]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [r13+64]
	lea	rdx, QWORD PTR [rdi+64]
	call	??0?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@AEBV01@@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::vector<BymlFile::Node,std::allocator<BymlFile::Node> >
	npad	1
	mov	eax, DWORD PTR [rdi+88]
	mov	DWORD PTR [r13+88], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1653 :         const size_type _Oldsize = _List._Mypair._Myval2._Mysize;

	mov	rdx, QWORD PTR [r15+16]

; 1654 :         const auto _Newsize      = _Oldsize + 1;

	add	rdx, 1

; 1655 :         return max_load_factor() < static_cast<float>(_Newsize) / static_cast<float>(bucket_count());

	xorps	xmm0, xmm0
	js	SHORT $LN173@emplace
	cvtsi2ss xmm0, rdx
	jmp	SHORT $LN174@emplace
$LN173@emplace:
	mov	rcx, rdx
	shr	rcx, 1
	mov	rax, rdx
	and	eax, 1
	or	rcx, rax
	cvtsi2ss xmm0, rcx
	addss	xmm0, xmm0
$LN174@emplace:
	mov	rcx, QWORD PTR [r15+56]
	xorps	xmm1, xmm1
	test	rcx, rcx
	js	SHORT $LN171@emplace
	cvtsi2ss xmm1, rcx
	jmp	SHORT $LN172@emplace
$LN171@emplace:
	mov	rax, rcx
	shr	rax, 1
	and	ecx, 1
	or	rax, rcx
	cvtsi2ss xmm1, rax
	addss	xmm1, xmm1
$LN172@emplace:
	divss	xmm0, xmm1
	comiss	xmm0, DWORD PTR [r15]
	seta	al

; 606  :             auto _Target        = _Find_last(_Keyval, _Hashval);
; 607  :             if (_Target._Duplicate) {
; 608  :                 return {_List._Make_iter(_Target._Duplicate), false};
; 609  :             }
; 610  : 
; 611  :             _Check_max_size();
; 612  :             // invalidates _Keyval:
; 613  :             _List_node_emplace_op2<_Alnode> _Newnode(_List._Getal(), _STD forward<_Valtys>(_Vals)...);
; 614  :             if (_Check_rehash_required_1()) {

	test	al, al
	je	$LN3@emplace

; 1661 :         _Forced_rehash(_Desired_grow_bucket_count(_Newsize));

	mov	rcx, r15
	call	?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@IEBA_K_K@Z ; std::_Hash<std::_Umap_traits<BymlFile::Node,unsigned int,std::_Uhash_compare<BymlFile::Node,BymlFile::NodeHasher,BymlFile::NodeEqual>,std::allocator<std::pair<BymlFile::Node const ,unsigned int> >,0> >::_Desired_grow_bucket_count
	mov	rdx, rax
	mov	rcx, r15
	call	?_Forced_rehash@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@IEAAX_K@Z ; std::_Hash<std::_Umap_traits<BymlFile::Node,unsigned int,std::_Uhash_compare<BymlFile::Node,BymlFile::NodeHasher,BymlFile::NodeEqual>,std::allocator<std::pair<BymlFile::Node const ,unsigned int> >,0> >::_Forced_rehash

; 1567 :         const size_type _Bucket = _Hashval & _Mask;

	mov	rbp, QWORD PTR [r15+48]
	and	rbp, QWORD PTR _Hashval$1$[rsp]

; 1568 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

	add	rbp, rbp
	mov	rax, QWORD PTR [r15+24]
	mov	rdi, QWORD PTR [rax+rbp*8+8]

; 1569 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;

	mov	rbx, QWORD PTR [r15+8]

; 1570 :         if (_Where == _End) {

	cmp	rdi, rbx
	jne	SHORT $LN149@emplace

; 1571 :             return {_End, _Nodeptr{}};

	mov	QWORD PTR $T2[rsp+8], 0
	jmp	SHORT $LN176@emplace
$LN149@emplace:

; 1572 :         }
; 1573 : 
; 1574 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	rbp, QWORD PTR [rax+rbp*8]

; 1575 :         for (;;) {
; 1576 :             // Search backwards to maintain sorted [_Bucket_lo, _Bucket_hi] when !_Standard
; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	lea	rdx, QWORD PTR [rdi+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h

; 175  :             return Node1 == Node2;

	mov	rcx, r13
	call	??8Node@BymlFile@@QEBA_NAEBV01@@Z	; BymlFile::Node::operator==
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 154  :         return !static_cast<bool>(_Mypair._Myval2._Get_first()(_Keyval1, _Keyval2));

	test	al, al

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	jne	SHORT $LN162@emplace
$LL146@emplace:

; 1585 :             }
; 1586 : 
; 1587 :             if (_Where == _Bucket_lo) {

	mov	rbx, rdi
	cmp	rdi, rbp
	je	SHORT $LN163@emplace

; 1589 :             }
; 1590 : 
; 1591 :             _Where = _Where->_Prev;

	mov	rdi, QWORD PTR [rdi+8]

; 1575 :         for (;;) {
; 1576 :             // Search backwards to maintain sorted [_Bucket_lo, _Bucket_hi] when !_Standard
; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	lea	rdx, QWORD PTR [rdi+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h

; 175  :             return Node1 == Node2;

	mov	rcx, r13
	call	??8Node@BymlFile@@QEBA_NAEBV01@@Z	; BymlFile::Node::operator==
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 154  :         return !static_cast<bool>(_Mypair._Myval2._Get_first()(_Keyval1, _Keyval2));

	test	al, al

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	je	SHORT $LL146@emplace
$LN162@emplace:

; 1578 :                 if constexpr (!_Traits::_Standard) {
; 1579 :                     if (_Traitsobj(_Traits::_Kfn(_Where->_Myval), _Keyval)) {
; 1580 :                         return {_Where->_Next, _Nodeptr{}};
; 1581 :                     }
; 1582 :                 }
; 1583 : 
; 1584 :                 return {_Where->_Next, _Where};

	mov	rbx, QWORD PTR [rdi]
$LN176@emplace:

; 615  :                 _Rehash_for_1();
; 616  :                 _Target = _Find_last(_Traits::_Kfn(_Newnode._Ptr->_Myval), _Hashval);

	mov	QWORD PTR $T2[rsp], rbx
$LN177@emplace:
	mov	rbp, rbx
	mov	r12, QWORD PTR $T2[rsp]
$LN3@emplace:

; 1615 :         const _Nodeptr _Insert_after = _Insert_before->_Prev;

	mov	rdx, QWORD PTR [rbx+8]

; 1616 :         ++_List._Mypair._Myval2._Mysize;

	inc	QWORD PTR [r15+16]

; 1617 :         _Construct_in_place(_Newnode->_Next, _Insert_before);

	mov	QWORD PTR [rsi], r12

; 1618 :         _Construct_in_place(_Newnode->_Prev, _Insert_after);

	mov	QWORD PTR [rsi+8], rdx

; 1619 :         _Insert_after->_Next  = _Newnode;

	mov	QWORD PTR [rdx], rsi

; 1620 :         _Insert_before->_Prev = _Newnode;

	mov	QWORD PTR [rbx+8], rsi

; 1621 : 
; 1622 :         const auto _Head                = _List._Mypair._Myval2._Myhead;
; 1623 :         const auto _Bucket_array        = _Vec._Mypair._Myval2._Myfirst;

	mov	rcx, QWORD PTR [r15+24]

; 1624 :         const size_type _Bucket         = _Hashval & _Mask;

	mov	rax, QWORD PTR [r15+48]
	and	rax, QWORD PTR _Hashval$1$[rsp]

; 1625 :         _Unchecked_iterator& _Bucket_lo = _Bucket_array[_Bucket << 1];

	add	rax, rax

; 1626 :         _Unchecked_iterator& _Bucket_hi = _Bucket_array[(_Bucket << 1) + 1];
; 1627 :         if (_Bucket_lo._Ptr == _Head) {

	mov	r8, QWORD PTR [rcx+rax*8]
	cmp	r8, QWORD PTR [r15+8]
	jne	SHORT $LN89@emplace

; 1628 :             // bucket is empty, set both
; 1629 :             _Bucket_lo._Ptr = _Newnode;

	mov	QWORD PTR [rcx+rax*8], rsi

; 1630 :             _Bucket_hi._Ptr = _Newnode;

	jmp	SHORT $LN178@emplace
$LN163@emplace:

; 1588 :                 return {_Where, _Nodeptr{}};

	mov	QWORD PTR $T2[rsp], rdi
	mov	QWORD PTR $T2[rsp+8], 0
	jmp	SHORT $LN177@emplace
$LN89@emplace:

; 1631 :         } else if (_Bucket_lo._Ptr == _Insert_before) {

	cmp	r8, rbp
	jne	SHORT $LN91@emplace

; 1632 :             // new node is the lowest element in the bucket
; 1633 :             _Bucket_lo._Ptr = _Newnode;

	mov	QWORD PTR [rcx+rax*8], rsi
	jmp	SHORT $LN93@emplace
$LN91@emplace:

; 1634 :         } else if (_Bucket_hi._Ptr == _Insert_after) {

	cmp	QWORD PTR [rcx+rax*8+8], rdx
	jne	SHORT $LN93@emplace
$LN178@emplace:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR [rcx+rax*8+8], rsi
$LN93@emplace:
	mov	QWORD PTR [r14], rsi
	mov	BYTE PTR [r14+8], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 619  :             return {

	jmp	$LN179@emplace
$LN175@emplace:
??$emplace@U?$pair@$$CBVNode@BymlFile@@I@std@@@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVNode@BymlFile@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBVNode@BymlFile@@I@1@@Z ENDP ; std::_Hash<std::_Umap_traits<BymlFile::Node,unsigned int,std::_Uhash_compare<BymlFile::Node,BymlFile::NodeHasher,BymlFile::NodeEqual>,std::allocator<std::pair<BymlFile::Node const ,unsigned int> >,0> >::emplace<std::pair<BymlFile::Node const ,unsigned int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
_Hashval$1$ = 48
_Newnode$3 = 56
this$ = 144
__$ReturnUdt$ = 152
<_Vals_0>$ = 160
?dtor$1@?0???$emplace@U?$pair@$$CBVNode@BymlFile@@I@std@@@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVNode@BymlFile@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBVNode@BymlFile@@I@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<BymlFile::Node,unsigned int,std::_Uhash_compare<BymlFile::Node,BymlFile::NodeHasher,BymlFile::NodeEqual>,std::allocator<std::pair<BymlFile::Node const ,unsigned int> >,0> >::emplace<std::pair<BymlFile::Node const ,unsigned int> >'::`1'::dtor$1
	lea	rcx, QWORD PTR _Newnode$3[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > >
?dtor$1@?0???$emplace@U?$pair@$$CBVNode@BymlFile@@I@std@@@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVNode@BymlFile@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBVNode@BymlFile@@I@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<BymlFile::Node,unsigned int,std::_Uhash_compare<BymlFile::Node,BymlFile::NodeHasher,BymlFile::NodeEqual>,std::allocator<std::pair<BymlFile::Node const ,unsigned int> >,0> >::emplace<std::pair<BymlFile::Node const ,unsigned int> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
_Hashval$1$ = 48
_Newnode$3 = 56
this$ = 144
__$ReturnUdt$ = 152
<_Vals_0>$ = 160
?dtor$3@?0???$emplace@U?$pair@$$CBVNode@BymlFile@@I@std@@@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVNode@BymlFile@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBVNode@BymlFile@@I@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<BymlFile::Node,unsigned int,std::_Uhash_compare<BymlFile::Node,BymlFile::NodeHasher,BymlFile::NodeEqual>,std::allocator<std::pair<BymlFile::Node const ,unsigned int> >,0> >::emplace<std::pair<BymlFile::Node const ,unsigned int> >'::`1'::dtor$3
	mov	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$3@?0???$emplace@U?$pair@$$CBVNode@BymlFile@@I@std@@@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVNode@BymlFile@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBVNode@BymlFile@@I@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<BymlFile::Node,unsigned int,std::_Uhash_compare<BymlFile::Node,BymlFile::NodeHasher,BymlFile::NodeEqual>,std::allocator<std::pair<BymlFile::Node const ,unsigned int> >,0> >::emplace<std::pair<BymlFile::Node const ,unsigned int> >'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
_Hashval$1$ = 48
_Newnode$3 = 56
this$ = 144
__$ReturnUdt$ = 152
<_Vals_0>$ = 160
?dtor$4@?0???$emplace@U?$pair@$$CBVNode@BymlFile@@I@std@@@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVNode@BymlFile@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBVNode@BymlFile@@I@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<BymlFile::Node,unsigned int,std::_Uhash_compare<BymlFile::Node,BymlFile::NodeHasher,BymlFile::NodeEqual>,std::allocator<std::pair<BymlFile::Node const ,unsigned int> >,0> >::emplace<std::pair<BymlFile::Node const ,unsigned int> >'::`1'::dtor$4
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 32					; 00000020H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0???$emplace@U?$pair@$$CBVNode@BymlFile@@I@std@@@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVNode@BymlFile@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBVNode@BymlFile@@I@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<BymlFile::Node,unsigned int,std::_Uhash_compare<BymlFile::Node,BymlFile::NodeHasher,BymlFile::NodeEqual>,std::allocator<std::pair<BymlFile::Node const ,unsigned int> >,0> >::emplace<std::pair<BymlFile::Node const ,unsigned int> >'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
_Hashval$1$ = 48
_Newnode$3 = 56
this$ = 144
__$ReturnUdt$ = 152
<_Vals_0>$ = 160
?dtor$0@?0???$emplace@U?$pair@$$CBVNode@BymlFile@@I@std@@@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVNode@BymlFile@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBVNode@BymlFile@@I@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<BymlFile::Node,unsigned int,std::_Uhash_compare<BymlFile::Node,BymlFile::NodeHasher,BymlFile::NodeEqual>,std::allocator<std::pair<BymlFile::Node const ,unsigned int> >,0> >::emplace<std::pair<BymlFile::Node const ,unsigned int> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Newnode$3[rdx]
	jmp	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > >
?dtor$0@?0???$emplace@U?$pair@$$CBVNode@BymlFile@@I@std@@@?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVNode@BymlFile@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBVNode@BymlFile@@I@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<BymlFile::Node,unsigned int,std::_Uhash_compare<BymlFile::Node,BymlFile::NodeHasher,BymlFile::NodeEqual>,std::allocator<std::pair<BymlFile::Node const ,unsigned int> >,0> >::emplace<std::pair<BymlFile::Node const ,unsigned int> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ??$_Try_emplace@AEBV?$vector@EV?$allocator@E@std@@@std@@$$V@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@_N@1@AEBV?$vector@EV?$allocator@E@std@@@1@@Z
_TEXT	SEGMENT
$T1 = 32
_Target$ = 32
_Newnode$ = 48
this$ = 128
__$ReturnUdt$ = 136
_Keyval_arg$ = 144
??$_Try_emplace@AEBV?$vector@EV?$allocator@E@std@@@std@@$$V@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@_N@1@AEBV?$vector@EV?$allocator@E@std@@@1@@Z PROC ; std::_Hash<std::_Umap_traits<std::vector<unsigned char,std::allocator<unsigned char> >,unsigned int,std::_Uhash_compare<std::vector<unsigned char,std::allocator<unsigned char> >,BymlFile::VectorHasher,std::equal_to<std::vector<unsigned char,std::allocator<unsigned char> > > >,std::allocator<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >,0> >::_Try_emplace<std::vector<unsigned char,std::allocator<unsigned char> > const &>, COMDAT

; 693  :     pair<_Nodeptr, bool> _Try_emplace(_Keyty&& _Keyval_arg, _Mappedty&&... _Mapval) {

$LN227:
	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 64					; 00000040H
	mov	rbx, r8
	mov	r14, rdx
	mov	rbp, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r9, QWORD PTR [r8+8]
	mov	r8, QWORD PTR [r8]
	mov	rdx, r9
	sub	rdx, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h

; 164  :             for (auto& i : V) {

	cmp	r8, r9
	je	SHORT $LN10@Try_emplac
	npad	1
$LL206@Try_emplac:

; 165  :                 Hash ^= i + 0x9e3779b9 + (Hash << 6) + (Hash >> 2);

	mov	ecx, edx
	shl	ecx, 6
	mov	eax, edx
	sar	eax, 2
	add	ecx, eax
	movzx	eax, BYTE PTR [r8]
	add	ecx, -1640531527			; ffffffff9e3779b9H
	add	ecx, eax
	xor	edx, ecx

; 164  :             for (auto& i : V) {

	inc	r8
	cmp	r8, r9
	jne	SHORT $LL206@Try_emplac
$LN10@Try_emplac:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 147  :         return static_cast<size_t>(_Mypair._Get_first()(_Keyval));

	movsxd	r13, edx

; 694  :         const auto& _Keyval = _Keyval_arg;
; 695  :         const auto _Hashval = _Traitsobj(_Keyval);
; 696  :         auto _Target        = _Find_last(_Keyval, _Hashval);

	mov	r9, r13
	mov	r8, rbx
	lea	rdx, QWORD PTR _Target$[rsp]
	mov	rcx, rbp
	call	??$_Find_last@V?$vector@EV?$allocator@E@std@@@std@@@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@AEBV?$vector@EV?$allocator@E@std@@@1@_K@Z ; std::_Hash<std::_Umap_traits<std::vector<unsigned char,std::allocator<unsigned char> >,unsigned int,std::_Uhash_compare<std::vector<unsigned char,std::allocator<unsigned char> >,BymlFile::VectorHasher,std::equal_to<std::vector<unsigned char,std::allocator<unsigned char> > > >,std::allocator<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >,0> >::_Find_last<std::vector<unsigned char,std::allocator<unsigned char> > >

; 697  :         if (_Target._Duplicate) {

	mov	rax, QWORD PTR _Target$[rsp+8]
	test	rax, rax
	je	SHORT $LN2@Try_emplac
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR [r14], rax
	mov	BYTE PTR [r14+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 698  :             return {_Target._Duplicate, false};

	jmp	$LN222@Try_emplac
$LN2@Try_emplac:

; 1647 :         if (_Oldsize == _List.max_size()) {

	mov	rax, 384307168202282325			; 0555555555555555H
	cmp	QWORD PTR [rbp+16], rax
	jne	SHORT $LN18@Try_emplac

; 1648 :             _Xlength_error("unordered_map/set too long");

	lea	rcx, OFFSET FLAT:??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN18@Try_emplac:

; 699  :         }
; 700  : 
; 701  :         _Check_max_size();
; 702  :         _List_node_emplace_op2<_Alnode> _Newnode(_List._Getal(), piecewise_construct,

	lea	r12, QWORD PTR [rbp+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1144 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR _Newnode$[rsp], r12

; 1151 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	xor	r15d, r15d
	mov	QWORD PTR _Newnode$[rsp+8], r15

; 87   :         return ::operator new(_Bytes);

	lea	ecx, QWORD PTR [r15+48]
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax

; 1152 :         _Ptr = _Al.allocate(1);

	mov	QWORD PTR _Newnode$[rsp+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	rdx, rbx
	lea	rcx, QWORD PTR [rax+16]
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	mov	DWORD PTR [rdi+40], r15d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1653 :         const size_type _Oldsize = _List._Mypair._Myval2._Mysize;

	mov	rdx, QWORD PTR [rbp+16]

; 1654 :         const auto _Newsize      = _Oldsize + 1;

	add	rdx, 1

; 1655 :         return max_load_factor() < static_cast<float>(_Newsize) / static_cast<float>(bucket_count());

	xorps	xmm0, xmm0
	js	SHORT $LN219@Try_emplac
	cvtsi2ss xmm0, rdx
	jmp	SHORT $LN220@Try_emplac
$LN219@Try_emplac:
	mov	rcx, rdx
	shr	rcx, 1
	mov	rax, rdx
	and	eax, 1
	or	rcx, rax
	cvtsi2ss xmm0, rcx
	addss	xmm0, xmm0
$LN220@Try_emplac:
	mov	rcx, QWORD PTR [rbp+56]
	xorps	xmm1, xmm1
	test	rcx, rcx
	js	SHORT $LN217@Try_emplac
	cvtsi2ss xmm1, rcx
	jmp	SHORT $LN218@Try_emplac
$LN217@Try_emplac:
	mov	rax, rcx
	shr	rax, 1
	and	ecx, 1
	or	rax, rcx
	cvtsi2ss xmm1, rax
	addss	xmm1, xmm1
$LN218@Try_emplac:
	divss	xmm0, xmm1
	comiss	xmm0, DWORD PTR [rbp]
	seta	al

; 703  :             _STD forward_as_tuple(_STD forward<_Keyty>(_Keyval_arg)),
; 704  :             _STD forward_as_tuple(_STD forward<_Mappedty>(_Mapval)...));
; 705  :         if (_Check_rehash_required_1()) {

	test	al, al
	je	$LN3@Try_emplac

; 1661 :         _Forced_rehash(_Desired_grow_bucket_count(_Newsize));

	mov	rcx, rbp
	call	?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z ; std::_Hash<std::_Umap_traits<std::vector<unsigned char,std::allocator<unsigned char> >,unsigned int,std::_Uhash_compare<std::vector<unsigned char,std::allocator<unsigned char> >,BymlFile::VectorHasher,std::equal_to<std::vector<unsigned char,std::allocator<unsigned char> > > >,std::allocator<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >,0> >::_Desired_grow_bucket_count
	mov	rdx, rax
	mov	rcx, rbp
	call	?_Forced_rehash@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@IEAAX_K@Z ; std::_Hash<std::_Umap_traits<std::vector<unsigned char,std::allocator<unsigned char> >,unsigned int,std::_Uhash_compare<std::vector<unsigned char,std::allocator<unsigned char> >,BymlFile::VectorHasher,std::equal_to<std::vector<unsigned char,std::allocator<unsigned char> > > >,std::allocator<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >,0> >::_Forced_rehash

; 1567 :         const size_type _Bucket = _Hashval & _Mask;

	mov	r15, QWORD PTR [rbp+48]
	and	r15, r13

; 1568 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

	add	r15, r15
	mov	rcx, QWORD PTR [rbp+24]
	mov	rbx, QWORD PTR [rcx+r15*8+8]

; 1569 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;

	mov	rax, QWORD PTR [r12]

; 1570 :         if (_Where == _End) {

	cmp	rbx, rax
	jne	SHORT $LN168@Try_emplac

; 1571 :             return {_End, _Nodeptr{}};

	mov	QWORD PTR $T1[rsp], rax
	jmp	SHORT $LN223@Try_emplac
$LN168@Try_emplac:

; 1572 :         }
; 1573 : 
; 1574 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	r15, QWORD PTR [rcx+r15*8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r12, QWORD PTR [rdi+16]
	mov	rsi, QWORD PTR [rdi+24]
	sub	rsi, r12
	npad	5
$LL165@Try_emplac:
	mov	rdx, QWORD PTR [rbx+16]
	mov	rax, QWORD PTR [rbx+24]
	sub	rax, rdx

; 2222 :     if (_Left.size() != _Right.size()) {

	cmp	rsi, rax
	jne	SHORT $LN215@Try_emplac
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 5246 :     return _CSTD memcmp(_First1_ch, _First2_ch, static_cast<size_t>(_Last1_ch - _First1_ch));

	mov	r8, rsi
	mov	rcx, r12
	call	memcmp

; 5269 :             return _Memcmp_ranges(_UFirst1, _ULast1, _UFirst2) == 0;

	test	eax, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	je	SHORT $LN202@Try_emplac
$LN215@Try_emplac:

; 1585 :             }
; 1586 : 
; 1587 :             if (_Where == _Bucket_lo) {

	cmp	rbx, r15
	je	SHORT $LN203@Try_emplac

; 1589 :             }
; 1590 : 
; 1591 :             _Where = _Where->_Prev;

	mov	rbx, QWORD PTR [rbx+8]

; 1592 :         }

	jmp	SHORT $LL165@Try_emplac
$LN202@Try_emplac:

; 1578 :                 if constexpr (!_Traits::_Standard) {
; 1579 :                     if (_Traitsobj(_Traits::_Kfn(_Where->_Myval), _Keyval)) {
; 1580 :                         return {_Where->_Next, _Nodeptr{}};
; 1581 :                     }
; 1582 :                 }
; 1583 : 
; 1584 :                 return {_Where->_Next, _Where};

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR $T1[rsp], rax
	mov	QWORD PTR $T1[rsp+8], rbx
	lea	r12, QWORD PTR [rbp+8]
	jmp	SHORT $LN166@Try_emplac
$LN203@Try_emplac:

; 1588 :                 return {_Where, _Nodeptr{}};

	mov	QWORD PTR $T1[rsp], rbx
	lea	r12, QWORD PTR [rbp+8]
$LN223@Try_emplac:

; 706  :             _Rehash_for_1();
; 707  :             _Target = _Find_last(_Traits::_Kfn(_Newnode._Ptr->_Myval), _Hashval);

	mov	QWORD PTR $T1[rsp+8], 0
$LN166@Try_emplac:
	movaps	xmm0, XMMWORD PTR $T1[rsp]
	movdqa	XMMWORD PTR _Target$[rsp], xmm0
$LN3@Try_emplac:

; 1615 :         const _Nodeptr _Insert_after = _Insert_before->_Prev;

	mov	rdx, QWORD PTR _Target$[rsp]
	mov	r8, QWORD PTR [rdx+8]

; 1616 :         ++_List._Mypair._Myval2._Mysize;

	inc	QWORD PTR [rbp+16]

; 1617 :         _Construct_in_place(_Newnode->_Next, _Insert_before);

	mov	QWORD PTR [rdi], rdx

; 1618 :         _Construct_in_place(_Newnode->_Prev, _Insert_after);

	mov	QWORD PTR [rdi+8], r8

; 1619 :         _Insert_after->_Next  = _Newnode;

	mov	QWORD PTR [r8], rdi

; 1620 :         _Insert_before->_Prev = _Newnode;

	mov	QWORD PTR [rdx+8], rdi

; 1621 : 
; 1622 :         const auto _Head                = _List._Mypair._Myval2._Myhead;
; 1623 :         const auto _Bucket_array        = _Vec._Mypair._Myval2._Myfirst;

	mov	rcx, QWORD PTR [rbp+24]

; 1624 :         const size_type _Bucket         = _Hashval & _Mask;

	mov	rax, QWORD PTR [rbp+48]
	and	rax, r13

; 1625 :         _Unchecked_iterator& _Bucket_lo = _Bucket_array[_Bucket << 1];

	add	rax, rax

; 1626 :         _Unchecked_iterator& _Bucket_hi = _Bucket_array[(_Bucket << 1) + 1];
; 1627 :         if (_Bucket_lo._Ptr == _Head) {

	mov	r9, QWORD PTR [rcx+rax*8]
	cmp	r9, QWORD PTR [r12]
	jne	SHORT $LN86@Try_emplac

; 1628 :             // bucket is empty, set both
; 1629 :             _Bucket_lo._Ptr = _Newnode;

	mov	QWORD PTR [rcx+rax*8], rdi

; 1630 :             _Bucket_hi._Ptr = _Newnode;

	jmp	SHORT $LN224@Try_emplac
$LN86@Try_emplac:

; 1631 :         } else if (_Bucket_lo._Ptr == _Insert_before) {

	cmp	r9, rdx
	jne	SHORT $LN88@Try_emplac

; 1632 :             // new node is the lowest element in the bucket
; 1633 :             _Bucket_lo._Ptr = _Newnode;

	mov	QWORD PTR [rcx+rax*8], rdi
	jmp	SHORT $LN90@Try_emplac
$LN88@Try_emplac:

; 1634 :         } else if (_Bucket_hi._Ptr == _Insert_after) {

	cmp	QWORD PTR [rcx+rax*8+8], r8
	jne	SHORT $LN90@Try_emplac
$LN224@Try_emplac:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR [rcx+rax*8+8], rdi
$LN90@Try_emplac:
	mov	QWORD PTR [r14], rdi
	mov	BYTE PTR [r14+8], 1
$LN222@Try_emplac:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 711  :     }

	mov	rax, r14
	mov	rbx, QWORD PTR [rsp+152]
	add	rsp, 64					; 00000040H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN221@Try_emplac:
??$_Try_emplace@AEBV?$vector@EV?$allocator@E@std@@@std@@$$V@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@_N@1@AEBV?$vector@EV?$allocator@E@std@@@1@@Z ENDP ; std::_Hash<std::_Umap_traits<std::vector<unsigned char,std::allocator<unsigned char> >,unsigned int,std::_Uhash_compare<std::vector<unsigned char,std::allocator<unsigned char> >,BymlFile::VectorHasher,std::equal_to<std::vector<unsigned char,std::allocator<unsigned char> > > >,std::allocator<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >,0> >::_Try_emplace<std::vector<unsigned char,std::allocator<unsigned char> > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Target$ = 32
_Newnode$ = 48
this$ = 128
__$ReturnUdt$ = 136
_Keyval_arg$ = 144
?dtor$1@?0???$_Try_emplace@AEBV?$vector@EV?$allocator@E@std@@@std@@$$V@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@_N@1@AEBV?$vector@EV?$allocator@E@std@@@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<std::vector<unsigned char,std::allocator<unsigned char> >,unsigned int,std::_Uhash_compare<std::vector<unsigned char,std::allocator<unsigned char> >,BymlFile::VectorHasher,std::equal_to<std::vector<unsigned char,std::allocator<unsigned char> > > >,std::allocator<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >,0> >::_Try_emplace<std::vector<unsigned char,std::allocator<unsigned char> > const &>'::`1'::dtor$1
	lea	rcx, QWORD PTR _Newnode$[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> > >
?dtor$1@?0???$_Try_emplace@AEBV?$vector@EV?$allocator@E@std@@@std@@$$V@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@_N@1@AEBV?$vector@EV?$allocator@E@std@@@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<std::vector<unsigned char,std::allocator<unsigned char> >,unsigned int,std::_Uhash_compare<std::vector<unsigned char,std::allocator<unsigned char> >,BymlFile::VectorHasher,std::equal_to<std::vector<unsigned char,std::allocator<unsigned char> > > >,std::allocator<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >,0> >::_Try_emplace<std::vector<unsigned char,std::allocator<unsigned char> > const &>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Target$ = 32
_Newnode$ = 48
this$ = 128
__$ReturnUdt$ = 136
_Keyval_arg$ = 144
?dtor$0@?0???$_Try_emplace@AEBV?$vector@EV?$allocator@E@std@@@std@@$$V@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@_N@1@AEBV?$vector@EV?$allocator@E@std@@@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<std::vector<unsigned char,std::allocator<unsigned char> >,unsigned int,std::_Uhash_compare<std::vector<unsigned char,std::allocator<unsigned char> >,BymlFile::VectorHasher,std::equal_to<std::vector<unsigned char,std::allocator<unsigned char> > > >,std::allocator<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >,0> >::_Try_emplace<std::vector<unsigned char,std::allocator<unsigned char> > const &>'::`1'::dtor$0
	lea	rcx, QWORD PTR _Newnode$[rdx]
	jmp	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> > >
?dtor$0@?0???$_Try_emplace@AEBV?$vector@EV?$allocator@E@std@@@std@@$$V@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@_N@1@AEBV?$vector@EV?$allocator@E@std@@@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<std::vector<unsigned char,std::allocator<unsigned char> >,unsigned int,std::_Uhash_compare<std::vector<unsigned char,std::allocator<unsigned char> >,BymlFile::VectorHasher,std::equal_to<std::vector<unsigned char,std::allocator<unsigned char> > > >,std::allocator<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >,0> >::_Try_emplace<std::vector<unsigned char,std::allocator<unsigned char> > const &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@std@@YA$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@std@@YA$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@0@AEAU10@@Z PROC ; std::move<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@std@@YA$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@0@AEAU10@@Z ENDP ; std::move<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ??$emplace@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@@Z
_TEXT	SEGMENT
$T1 = 32
_Target$2 = 32
_Newnode$3 = 48
this$ = 128
__$ReturnUdt$ = 136
<_Vals_0>$ = 144
??$emplace@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@@Z PROC ; std::_Hash<std::_Umap_traits<std::vector<unsigned char,std::allocator<unsigned char> >,unsigned int,std::_Uhash_compare<std::vector<unsigned char,std::allocator<unsigned char> >,BymlFile::VectorHasher,std::equal_to<std::vector<unsigned char,std::allocator<unsigned char> > > >,std::allocator<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >,0> >::emplace<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >, COMDAT

; 589  :     conditional_t<_Multi, iterator, pair<iterator, bool>> emplace(_Valtys&&... _Vals) {

$LN230:
	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 64					; 00000040H
	mov	rbx, r8
	mov	r14, rdx
	mov	rbp, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r10, QWORD PTR [r8+8]
	mov	r9, QWORD PTR [r8]
	mov	rdx, r10
	sub	rdx, r9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h

; 164  :             for (auto& i : V) {

	cmp	r9, r10
	je	SHORT $LN10@emplace
	npad	1
$LL209@emplace:

; 165  :                 Hash ^= i + 0x9e3779b9 + (Hash << 6) + (Hash >> 2);

	mov	ecx, edx
	shl	ecx, 6
	mov	eax, edx
	sar	eax, 2
	add	ecx, eax
	movzx	eax, BYTE PTR [r9]
	add	ecx, -1640531527			; ffffffff9e3779b9H
	add	ecx, eax
	xor	edx, ecx

; 164  :             for (auto& i : V) {

	inc	r9
	cmp	r9, r10
	jne	SHORT $LL209@emplace
$LN10@emplace:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 147  :         return static_cast<size_t>(_Mypair._Get_first()(_Keyval));

	movsxd	r13, edx

; 590  :         // try to insert value_type(_Vals...)
; 591  :         using _In_place_key_extractor = typename _Traits::template _In_place_key_extractor<_Remove_cvref_t<_Valtys>...>;
; 592  :         if constexpr (_Multi) {
; 593  :             _Check_max_size();
; 594  :             _List_node_emplace_op2<_Alnode> _Newnode(_List._Getal(), _STD forward<_Valtys>(_Vals)...);
; 595  :             const auto& _Keyval = _Traits::_Kfn(_Newnode._Ptr->_Myval);
; 596  :             const auto _Hashval = _Traitsobj(_Keyval);
; 597  :             if (_Check_rehash_required_1()) {
; 598  :                 _Rehash_for_1();
; 599  :             }
; 600  : 
; 601  :             const auto _Target = _Find_last(_Keyval, _Hashval);
; 602  :             return _List._Make_iter(_Insert_new_node_before(_Hashval, _Target._Insert_before, _Newnode._Release()));
; 603  :         } else if constexpr (_In_place_key_extractor::_Extractable) {
; 604  :             const auto& _Keyval = _In_place_key_extractor::_Extract(_Vals...);
; 605  :             const auto _Hashval = _Traitsobj(_Keyval);
; 606  :             auto _Target        = _Find_last(_Keyval, _Hashval);

	mov	r9, r13
	lea	rdx, QWORD PTR _Target$2[rsp]
	mov	rcx, rbp
	call	??$_Find_last@V?$vector@EV?$allocator@E@std@@@std@@@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@AEBV?$vector@EV?$allocator@E@std@@@1@_K@Z ; std::_Hash<std::_Umap_traits<std::vector<unsigned char,std::allocator<unsigned char> >,unsigned int,std::_Uhash_compare<std::vector<unsigned char,std::allocator<unsigned char> >,BymlFile::VectorHasher,std::equal_to<std::vector<unsigned char,std::allocator<unsigned char> > > >,std::allocator<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >,0> >::_Find_last<std::vector<unsigned char,std::allocator<unsigned char> > >

; 607  :             if (_Target._Duplicate) {

	mov	rax, QWORD PTR _Target$2[rsp+8]
	test	rax, rax
	je	SHORT $LN2@emplace
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR [r14], rax
	mov	BYTE PTR [r14+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 608  :                 return {_List._Make_iter(_Target._Duplicate), false};

	jmp	$LN225@emplace
$LN2@emplace:

; 1647 :         if (_Oldsize == _List.max_size()) {

	mov	rax, 384307168202282325			; 0555555555555555H
	cmp	QWORD PTR [rbp+16], rax
	jne	SHORT $LN26@emplace

; 1648 :             _Xlength_error("unordered_map/set too long");

	lea	rcx, OFFSET FLAT:??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN26@emplace:

; 609  :             }
; 610  : 
; 611  :             _Check_max_size();
; 612  :             // invalidates _Keyval:
; 613  :             _List_node_emplace_op2<_Alnode> _Newnode(_List._Getal(), _STD forward<_Valtys>(_Vals)...);

	lea	r12, QWORD PTR [rbp+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1144 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR _Newnode$3[rsp], r12

; 1151 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR _Newnode$3[rsp+8], 0

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 48					; 00000030H
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax

; 1152 :         _Ptr = _Al.allocate(1);

	mov	QWORD PTR _Newnode$3[rsp+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 246  :     pair(pair&&)      = default;

	mov	rdx, rbx
	lea	rcx, QWORD PTR [rax+16]
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	mov	ecx, DWORD PTR [rbx+24]
	mov	DWORD PTR [rdi+40], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1653 :         const size_type _Oldsize = _List._Mypair._Myval2._Mysize;

	mov	rdx, QWORD PTR [rbp+16]

; 1654 :         const auto _Newsize      = _Oldsize + 1;

	add	rdx, 1

; 1655 :         return max_load_factor() < static_cast<float>(_Newsize) / static_cast<float>(bucket_count());

	xorps	xmm0, xmm0
	js	SHORT $LN222@emplace
	cvtsi2ss xmm0, rdx
	jmp	SHORT $LN223@emplace
$LN222@emplace:
	mov	rcx, rdx
	shr	rcx, 1
	mov	rax, rdx
	and	eax, 1
	or	rcx, rax
	cvtsi2ss xmm0, rcx
	addss	xmm0, xmm0
$LN223@emplace:
	mov	rcx, QWORD PTR [rbp+56]
	xorps	xmm1, xmm1
	test	rcx, rcx
	js	SHORT $LN220@emplace
	cvtsi2ss xmm1, rcx
	jmp	SHORT $LN221@emplace
$LN220@emplace:
	mov	rax, rcx
	shr	rax, 1
	and	ecx, 1
	or	rax, rcx
	cvtsi2ss xmm1, rax
	addss	xmm1, xmm1
$LN221@emplace:
	divss	xmm0, xmm1
	comiss	xmm0, DWORD PTR [rbp]
	seta	al

; 614  :             if (_Check_rehash_required_1()) {

	test	al, al
	je	$LN3@emplace

; 1661 :         _Forced_rehash(_Desired_grow_bucket_count(_Newsize));

	mov	rcx, rbp
	call	?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z ; std::_Hash<std::_Umap_traits<std::vector<unsigned char,std::allocator<unsigned char> >,unsigned int,std::_Uhash_compare<std::vector<unsigned char,std::allocator<unsigned char> >,BymlFile::VectorHasher,std::equal_to<std::vector<unsigned char,std::allocator<unsigned char> > > >,std::allocator<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >,0> >::_Desired_grow_bucket_count
	mov	rdx, rax
	mov	rcx, rbp
	call	?_Forced_rehash@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@IEAAX_K@Z ; std::_Hash<std::_Umap_traits<std::vector<unsigned char,std::allocator<unsigned char> >,unsigned int,std::_Uhash_compare<std::vector<unsigned char,std::allocator<unsigned char> >,BymlFile::VectorHasher,std::equal_to<std::vector<unsigned char,std::allocator<unsigned char> > > >,std::allocator<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >,0> >::_Forced_rehash

; 1567 :         const size_type _Bucket = _Hashval & _Mask;

	mov	r15, QWORD PTR [rbp+48]
	and	r15, r13

; 1568 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

	add	r15, r15
	mov	rcx, QWORD PTR [rbp+24]
	mov	rbx, QWORD PTR [rcx+r15*8+8]

; 1569 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;

	mov	rax, QWORD PTR [r12]

; 1570 :         if (_Where == _End) {

	cmp	rbx, rax
	jne	SHORT $LN171@emplace

; 1571 :             return {_End, _Nodeptr{}};

	mov	QWORD PTR $T1[rsp], rax
	jmp	SHORT $LN226@emplace
$LN171@emplace:

; 1572 :         }
; 1573 : 
; 1574 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	r15, QWORD PTR [rcx+r15*8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r12, QWORD PTR [rdi+16]
	mov	rsi, QWORD PTR [rdi+24]
	sub	rsi, r12
	npad	4
$LL168@emplace:
	mov	rdx, QWORD PTR [rbx+16]
	mov	rax, QWORD PTR [rbx+24]
	sub	rax, rdx

; 2222 :     if (_Left.size() != _Right.size()) {

	cmp	rsi, rax
	jne	SHORT $LN218@emplace
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 5246 :     return _CSTD memcmp(_First1_ch, _First2_ch, static_cast<size_t>(_Last1_ch - _First1_ch));

	mov	r8, rsi
	mov	rcx, r12
	call	memcmp

; 5269 :             return _Memcmp_ranges(_UFirst1, _ULast1, _UFirst2) == 0;

	test	eax, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	je	SHORT $LN205@emplace
$LN218@emplace:

; 1585 :             }
; 1586 : 
; 1587 :             if (_Where == _Bucket_lo) {

	cmp	rbx, r15
	je	SHORT $LN206@emplace

; 1589 :             }
; 1590 : 
; 1591 :             _Where = _Where->_Prev;

	mov	rbx, QWORD PTR [rbx+8]

; 1592 :         }

	jmp	SHORT $LL168@emplace
$LN205@emplace:

; 1578 :                 if constexpr (!_Traits::_Standard) {
; 1579 :                     if (_Traitsobj(_Traits::_Kfn(_Where->_Myval), _Keyval)) {
; 1580 :                         return {_Where->_Next, _Nodeptr{}};
; 1581 :                     }
; 1582 :                 }
; 1583 : 
; 1584 :                 return {_Where->_Next, _Where};

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR $T1[rsp], rax
	mov	QWORD PTR $T1[rsp+8], rbx
	lea	r12, QWORD PTR [rbp+8]
	jmp	SHORT $LN169@emplace
$LN206@emplace:

; 1588 :                 return {_Where, _Nodeptr{}};

	mov	QWORD PTR $T1[rsp], rbx
	lea	r12, QWORD PTR [rbp+8]
$LN226@emplace:

; 615  :                 _Rehash_for_1();
; 616  :                 _Target = _Find_last(_Traits::_Kfn(_Newnode._Ptr->_Myval), _Hashval);

	mov	QWORD PTR $T1[rsp+8], 0
$LN169@emplace:
	movaps	xmm0, XMMWORD PTR $T1[rsp]
	movdqa	XMMWORD PTR _Target$2[rsp], xmm0
$LN3@emplace:

; 1615 :         const _Nodeptr _Insert_after = _Insert_before->_Prev;

	mov	rdx, QWORD PTR _Target$2[rsp]
	mov	r8, QWORD PTR [rdx+8]

; 1616 :         ++_List._Mypair._Myval2._Mysize;

	inc	QWORD PTR [rbp+16]

; 1617 :         _Construct_in_place(_Newnode->_Next, _Insert_before);

	mov	QWORD PTR [rdi], rdx

; 1618 :         _Construct_in_place(_Newnode->_Prev, _Insert_after);

	mov	QWORD PTR [rdi+8], r8

; 1619 :         _Insert_after->_Next  = _Newnode;

	mov	QWORD PTR [r8], rdi

; 1620 :         _Insert_before->_Prev = _Newnode;

	mov	QWORD PTR [rdx+8], rdi

; 1621 : 
; 1622 :         const auto _Head                = _List._Mypair._Myval2._Myhead;
; 1623 :         const auto _Bucket_array        = _Vec._Mypair._Myval2._Myfirst;

	mov	rcx, QWORD PTR [rbp+24]

; 1624 :         const size_type _Bucket         = _Hashval & _Mask;

	mov	rax, QWORD PTR [rbp+48]
	and	rax, r13

; 1625 :         _Unchecked_iterator& _Bucket_lo = _Bucket_array[_Bucket << 1];

	add	rax, rax

; 1626 :         _Unchecked_iterator& _Bucket_hi = _Bucket_array[(_Bucket << 1) + 1];
; 1627 :         if (_Bucket_lo._Ptr == _Head) {

	mov	r9, QWORD PTR [rcx+rax*8]
	cmp	r9, QWORD PTR [r12]
	jne	SHORT $LN81@emplace

; 1628 :             // bucket is empty, set both
; 1629 :             _Bucket_lo._Ptr = _Newnode;

	mov	QWORD PTR [rcx+rax*8], rdi

; 1630 :             _Bucket_hi._Ptr = _Newnode;

	jmp	SHORT $LN227@emplace
$LN81@emplace:

; 1631 :         } else if (_Bucket_lo._Ptr == _Insert_before) {

	cmp	r9, rdx
	jne	SHORT $LN83@emplace

; 1632 :             // new node is the lowest element in the bucket
; 1633 :             _Bucket_lo._Ptr = _Newnode;

	mov	QWORD PTR [rcx+rax*8], rdi
	jmp	SHORT $LN85@emplace
$LN83@emplace:

; 1634 :         } else if (_Bucket_hi._Ptr == _Insert_after) {

	cmp	QWORD PTR [rcx+rax*8+8], r8
	jne	SHORT $LN85@emplace
$LN227@emplace:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR [rcx+rax*8+8], rdi
$LN85@emplace:
	mov	QWORD PTR [r14], rdi
	mov	BYTE PTR [r14+8], 1
$LN225@emplace:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 639  :     }

	mov	rax, r14
	mov	rbx, QWORD PTR [rsp+152]
	add	rsp, 64					; 00000040H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN224@emplace:
??$emplace@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@@Z ENDP ; std::_Hash<std::_Umap_traits<std::vector<unsigned char,std::allocator<unsigned char> >,unsigned int,std::_Uhash_compare<std::vector<unsigned char,std::allocator<unsigned char> >,BymlFile::VectorHasher,std::equal_to<std::vector<unsigned char,std::allocator<unsigned char> > > >,std::allocator<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >,0> >::emplace<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Target$2 = 32
_Newnode$3 = 48
this$ = 128
__$ReturnUdt$ = 136
<_Vals_0>$ = 144
?dtor$1@?0???$emplace@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<std::vector<unsigned char,std::allocator<unsigned char> >,unsigned int,std::_Uhash_compare<std::vector<unsigned char,std::allocator<unsigned char> >,BymlFile::VectorHasher,std::equal_to<std::vector<unsigned char,std::allocator<unsigned char> > > >,std::allocator<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >,0> >::emplace<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >'::`1'::dtor$1
	lea	rcx, QWORD PTR _Newnode$3[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> > >
?dtor$1@?0???$emplace@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<std::vector<unsigned char,std::allocator<unsigned char> >,unsigned int,std::_Uhash_compare<std::vector<unsigned char,std::allocator<unsigned char> >,BymlFile::VectorHasher,std::equal_to<std::vector<unsigned char,std::allocator<unsigned char> > > >,std::allocator<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >,0> >::emplace<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Target$2 = 32
_Newnode$3 = 48
this$ = 128
__$ReturnUdt$ = 136
<_Vals_0>$ = 144
?dtor$0@?0???$emplace@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<std::vector<unsigned char,std::allocator<unsigned char> >,unsigned int,std::_Uhash_compare<std::vector<unsigned char,std::allocator<unsigned char> >,BymlFile::VectorHasher,std::equal_to<std::vector<unsigned char,std::allocator<unsigned char> > > >,std::allocator<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >,0> >::emplace<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Newnode$3[rdx]
	jmp	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> > >
?dtor$0@?0???$emplace@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<std::vector<unsigned char,std::allocator<unsigned char> >,unsigned int,std::_Uhash_compare<std::vector<unsigned char,std::allocator<unsigned char> >,BymlFile::VectorHasher,std::equal_to<std::vector<unsigned char,std::allocator<unsigned char> > > >,std::allocator<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >,0> >::emplace<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 64
_Newsize$ = 72
_Val$dead$ = 80
??$_Resize@U_Value_init_tag@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Resize<std::_Value_init_tag>, COMDAT

; 1551 :     _CONSTEXPR20 void _Resize(const size_type _Newsize, const _Ty2& _Val) {

$LN88:
	push	rbx
	push	rsi
	push	r14
	sub	rsp, 32					; 00000020H

; 1552 :         // trim or append elements, provide strong guarantee
; 1553 :         auto& _Al           = _Getal();
; 1554 :         auto& _My_data      = _Mypair._Myval2;
; 1555 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1556 :         pointer& _Mylast    = _My_data._Mylast;
; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rbx, QWORD PTR [rcx+8]
	mov	r14, rcx
	mov	rsi, rdx
	mov	rdx, QWORD PTR [rcx]
	mov	rcx, rbx
	sub	rcx, rdx
	sar	rcx, 5

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rsi, rcx
	jae	SHORT $LN2@Resize

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	shl	rsi, 5
	add	rsi, rdx
	mov	QWORD PTR [rsp+80], rdi

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rdi, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rsi, rbx
	je	SHORT $LN8@Resize
	npad	7
$LL9@Resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rdi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rdi, 32					; 00000020H
	cmp	rdi, rbx
	jne	SHORT $LL9@Resize
$LN8@Resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1563 :             _Mylast = _Newlast;

	mov	rdi, QWORD PTR [rsp+80]
	mov	QWORD PTR [r14+8], rsi

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	add	rsp, 32					; 00000020H
	pop	r14
	pop	rsi
	pop	rbx
	ret	0
$LN2@Resize:

; 1564 :             return;
; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN3@Resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [r14+16]
	sub	rax, rdx
	sar	rax, 5

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rsi, rax
	jbe	SHORT $LN4@Resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rdx, rsi
	mov	rcx, r14

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	add	rsp, 32					; 00000020H
	pop	r14
	pop	rsi
	pop	rbx

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Resize_reallocate<std::_Value_init_tag>
$LN4@Resize:

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rsi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2041 :     for (; 0 < _Count; --_Count) {

	je	SHORT $LN23@Resize
	xor	eax, eax
	npad	1
$LL24@Resize:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rbx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rbx, 32					; 00000020H

; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rsi, 1
	jne	SHORT $LL24@Resize
$LN23@Resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	mov	QWORD PTR [r14+8], rbx
$LN3@Resize:

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	add	rsp, 32					; 00000020H
	pop	r14
	pop	rsi
	pop	rbx
	ret	0
??$_Resize@U_Value_init_tag@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
_Val$dead$ = 64
??$_Resize@U_Value_init_tag@std@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Resize<std::_Value_init_tag>, COMDAT

; 1551 :     _CONSTEXPR20 void _Resize(const size_type _Newsize, const _Ty2& _Val) {

$LN150:
	mov	QWORD PTR [rsp+32], rsi
	push	r14
	sub	rsp, 32					; 00000020H

; 1552 :         // trim or append elements, provide strong guarantee
; 1553 :         auto& _Al           = _Getal();
; 1554 :         auto& _My_data      = _Mypair._Myval2;
; 1555 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1556 :         pointer& _Mylast    = _My_data._Mylast;
; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rsi, QWORD PTR [rcx+8]
	mov	r14, rcx
	mov	r8, QWORD PTR [rcx]
	mov	r9, 3353953467947191203			; 2e8ba2e8ba2e8ba3H
	mov	rcx, rsi
	sub	rcx, r8
	sar	rcx, 3
	imul	rcx, r9

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdx, rcx
	jae	SHORT $LN2@Resize
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rbp

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	imul	rbp, rdx, 88				; 00000058H
	add	rbp, r8

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rbx, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbp, rsi
	je	SHORT $LN8@Resize
	mov	QWORD PTR [rsp+64], rdi
$LL9@Resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	lea	rcx, QWORD PTR [rbx+64]
	call	?_Tidy@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAXXZ ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx+32]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	mov	rcx, rbx
	call	?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AEAAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 88					; 00000058H
	cmp	rbx, rsi
	jne	SHORT $LL9@Resize
	mov	rdi, QWORD PTR [rsp+64]
$LN8@Resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1563 :             _Mylast = _Newlast;

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [r14+8], rbp
	mov	rbp, QWORD PTR [rsp+56]

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN2@Resize:

; 1564 :             return;
; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN3@Resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [r14+16]
	sub	rax, r8
	sar	rax, 3
	imul	rax, r9

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN4@Resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, r14

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Resize_reallocate<std::_Value_init_tag>
$LN4@Resize:

; 1571 :                 return;
; 1572 :             }
; 1573 : 
; 1574 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1575 :             const pointer _Oldlast = _Mylast;
; 1576 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1577 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1578 :             } else {
; 1579 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, rcx
	mov	rcx, rsi
	call	??$_Uninitialized_value_construct_n@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@PEAV12@_KAEAV?$allocator@VNode@BymlFile@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<BymlFile::Node> >
	mov	QWORD PTR [r14+8], rax
$LN3@Resize:

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
??$_Resize@U_Value_init_tag@std@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\__msvc_chrono.hpp
;	COMDAT ?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEBA_JXZ PROC ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count, COMDAT

; 110  :             return _MyRep;

	mov	rax, QWORD PTR [rcx]

; 111  :         }

	ret	0
?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEBA_JXZ ENDP ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$equal@PEBVNode@BymlFile@@PEBV12@@std@@YA_NQEBVNode@BymlFile@@00@Z
_TEXT	SEGMENT
_First1$ = 48
_Last1$ = 56
_First2$ = 64
??$equal@PEBVNode@BymlFile@@PEBV12@@std@@YA_NQEBVNode@BymlFile@@00@Z PROC ; std::equal<BymlFile::Node const *,BymlFile::Node const *>, COMDAT

; 5289 : _NODISCARD _CONSTEXPR20 bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2) {

$LN142:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, r8
	mov	rdi, rdx
	mov	rbx, rcx

; 5273 :     for (; _UFirst1 != _ULast1; ++_UFirst1, (void) ++_UFirst2) {

	cmp	rcx, rdx
	je	SHORT $LN5@equal

; 5289 : _NODISCARD _CONSTEXPR20 bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2) {

	sub	rsi, rcx
$LL6@equal:

; 486  :         return static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right);

	lea	rdx, QWORD PTR [rsi+rbx]
	mov	rcx, rbx
	call	??8Node@BymlFile@@QEBA_NAEBV01@@Z	; BymlFile::Node::operator==

; 5274 :         if (!_Pred(*_UFirst1, *_UFirst2)) {

	test	al, al
	je	SHORT $LN135@equal

; 487  :     }
; 488  : 
; 489  :     using is_transparent = int;
; 490  : };
; 491  : 
; 492  : template <>
; 493  : struct not_equal_to<void> {
; 494  :     template <class _Ty1, class _Ty2>
; 495  :     _NODISCARD constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
; 496  :         noexcept(noexcept(static_cast<_Ty1&&>(_Left) != static_cast<_Ty2&&>(_Right))) // strengthened
; 497  :         -> decltype(static_cast<_Ty1&&>(_Left) != static_cast<_Ty2&&>(_Right)) {
; 498  :         return static_cast<_Ty1&&>(_Left) != static_cast<_Ty2&&>(_Right);
; 499  :     }
; 500  : 
; 501  :     using is_transparent = int;
; 502  : };
; 503  : 
; 504  : template <>
; 505  : struct greater<void> {
; 506  :     template <class _Ty1, class _Ty2>
; 507  :     _NODISCARD constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
; 508  :         noexcept(noexcept(static_cast<_Ty1&&>(_Left) > static_cast<_Ty2&&>(_Right))) // strengthened
; 509  :         -> decltype(static_cast<_Ty1&&>(_Left) > static_cast<_Ty2&&>(_Right)) {
; 510  :         return static_cast<_Ty1&&>(_Left) > static_cast<_Ty2&&>(_Right);
; 511  :     }
; 512  : 
; 513  :     using is_transparent = int;
; 514  : };
; 515  : 
; 516  : template <>
; 517  : struct greater_equal<void> {
; 518  :     template <class _Ty1, class _Ty2>
; 519  :     _NODISCARD constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
; 520  :         noexcept(noexcept(static_cast<_Ty1&&>(_Left) >= static_cast<_Ty2&&>(_Right))) // strengthened
; 521  :         -> decltype(static_cast<_Ty1&&>(_Left) >= static_cast<_Ty2&&>(_Right)) {
; 522  :         return static_cast<_Ty1&&>(_Left) >= static_cast<_Ty2&&>(_Right);
; 523  :     }
; 524  : 
; 525  :     using is_transparent = int;
; 526  : };
; 527  : 
; 528  : template <>
; 529  : struct less_equal<void> {
; 530  :     template <class _Ty1, class _Ty2>
; 531  :     _NODISCARD constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
; 532  :         noexcept(noexcept(static_cast<_Ty1&&>(_Left) <= static_cast<_Ty2&&>(_Right))) // strengthened
; 533  :         -> decltype(static_cast<_Ty1&&>(_Left) <= static_cast<_Ty2&&>(_Right)) {
; 534  :         return static_cast<_Ty1&&>(_Left) <= static_cast<_Ty2&&>(_Right);
; 535  :     }
; 536  : 
; 537  :     using is_transparent = int;
; 538  : };
; 539  : 
; 540  : template <class _Fx>
; 541  : struct _Ref_fn { // pass function object by value as a reference
; 542  :     template <class... _Args>
; 543  :     constexpr decltype(auto) operator()(_Args&&... _Vals) { // forward function call operator
; 544  :         if constexpr (is_member_pointer_v<_Fx>) {
; 545  :             return _STD invoke(_Fn, _STD forward<_Args>(_Vals)...);
; 546  :         } else {
; 547  :             return _Fn(_STD forward<_Args>(_Vals)...);
; 548  :         }
; 549  :     }
; 550  : 
; 551  :     _Fx& _Fn;
; 552  : };
; 553  : 
; 554  : template <class _Fn>
; 555  : _NODISCARD constexpr auto _Pass_fn(_Fn& _Func) noexcept {
; 556  :     constexpr bool _Pass_by_value = conjunction_v<bool_constant<sizeof(_Fn) <= sizeof(void*)>,
; 557  :         is_trivially_copy_constructible<_Fn>, is_trivially_destructible<_Fn>>;
; 558  :     if constexpr (_Pass_by_value) {
; 559  :         return _Func;
; 560  :     } else {
; 561  :         return _Ref_fn<_Fn>{_Func}; // pass functor by "reference"
; 562  :     }
; 563  : }
; 564  : 
; 565  : #if _HAS_CXX23
; 566  : _EXPORT_STD template <class _Result_type, class _Callable, class... _Types,
; 567  :     enable_if_t<is_invocable_r_v<_Result_type, _Callable, _Types...>, int> = 0>
; 568  : _NODISCARD constexpr _Result_type invoke_r(_Callable&& _Obj, _Types&&... _Args) noexcept(
; 569  :     is_nothrow_invocable_r_v<_Result_type, _Callable, _Types...>) {
; 570  :     if constexpr (is_void_v<_Result_type>) {
; 571  :         (void) _STD invoke(static_cast<_Callable&&>(_Obj), static_cast<_Types&&>(_Args)...);
; 572  :     } else {
; 573  :         return _STD invoke(static_cast<_Callable&&>(_Obj), static_cast<_Types&&>(_Args)...);
; 574  :     }
; 575  : }
; 576  : #endif // _HAS_CXX23
; 577  : 
; 578  : struct _Unused_parameter { // generic unused parameter struct
; 579  :     constexpr _Unused_parameter() noexcept = default;
; 580  :     template <class _Ty>
; 581  :     constexpr _Unused_parameter(_Ty&&) noexcept {}
; 582  : };
; 583  : 
; 584  : template <class _Ty>
; 585  : using _Algorithm_int_t = conditional_t<is_integral_v<_Ty>, _Ty, ptrdiff_t>;
; 586  : 
; 587  : #ifdef __cpp_lib_concepts
; 588  : template <class _Ty>
; 589  : concept _Destructible_object = is_object_v<_Ty> && destructible<_Ty>;
; 590  : 
; 591  : template <template <class...> class _Template, class... _Args>
; 592  : void _Derived_from_specialization_impl(const _Template<_Args...>&);
; 593  : 
; 594  : template <class _Ty, template <class...> class _Template>
; 595  : concept _Derived_from_specialization_of = requires(const _Ty& _Obj) {
; 596  :     _STD _Derived_from_specialization_impl<_Template>(_Obj); // qualified: avoid ADL, handle incomplete types
; 597  : };
; 598  : 
; 599  : namespace ranges {
; 600  :     namespace _Iter_move {
; 601  : #if defined(__clang__) || defined(__EDG__) // TRANSITION, VSO-1681199
; 602  :         void iter_move() = delete; // Block unqualified name lookup
; 603  : #else // ^^^ no workaround / workaround vvv
; 604  :         void iter_move();
; 605  : #endif // ^^^ workaround ^^^
; 606  : 
; 607  :         // clang-format off
; 608  :         template <class _Ty>
; 609  :         concept _Has_ADL = _Has_class_or_enum_type<_Ty> && requires(_Ty&& __t) {
; 610  :             iter_move(static_cast<_Ty&&>(__t)); // intentional ADL
; 611  :         };
; 612  : 
; 613  :         template <class _Ty>
; 614  :         concept _Can_deref = requires(_Ty&& __t) {
; 615  :             *static_cast<_Ty&&>(__t);
; 616  :         };
; 617  :         // clang-format on
; 618  : 
; 619  :         class _Cpo {
; 620  :         private:
; 621  :             enum class _St { _None, _Custom, _Fallback };
; 622  : 
; 623  :             template <class _Ty>
; 624  :             _NODISCARD static consteval _Choice_t<_St> _Choose() noexcept {
; 625  :                 if constexpr (_Has_ADL<_Ty>) {
; 626  :                     return {_St::_Custom, noexcept(iter_move(_STD declval<_Ty>()))}; // intentional ADL
; 627  :                 } else if constexpr (_Can_deref<_Ty>) {
; 628  :                     return {_St::_Fallback, noexcept(*_STD declval<_Ty>())};
; 629  :                 } else {
; 630  :                     return {_St::_None};
; 631  :                 }
; 632  :             }
; 633  : 
; 634  :             template <class _Ty>
; 635  :             static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();
; 636  : 
; 637  :         public:
; 638  :             template <class _Ty>
; 639  :                 requires (_Choice<_Ty>._Strategy != _St::_None)
; 640  :             _NODISCARD constexpr decltype(auto) operator()(_Ty&& _Val) const noexcept(_Choice<_Ty>._No_throw) {
; 641  :                 constexpr _St _Strat = _Choice<_Ty>._Strategy;
; 642  : 
; 643  :                 if constexpr (_Strat == _St::_Custom) {
; 644  :                     return iter_move(static_cast<_Ty&&>(_Val)); // intentional ADL
; 645  :                 } else if constexpr (_Strat == _St::_Fallback) {
; 646  :                     using _Ref = decltype(*static_cast<_Ty&&>(_Val));
; 647  :                     if constexpr (is_lvalue_reference_v<_Ref>) {
; 648  :                         return _STD move(*static_cast<_Ty&&>(_Val));
; 649  :                     } else {
; 650  :                         return *static_cast<_Ty&&>(_Val);
; 651  :                     }
; 652  :                 } else {
; 653  :                     static_assert(_Always_false<_Ty>, "should be unreachable");
; 654  :                 }
; 655  :             }
; 656  :         };
; 657  :     } // namespace _Iter_move
; 658  : 
; 659  :     inline namespace _Cpos {
; 660  :         _EXPORT_STD inline constexpr _Iter_move::_Cpo iter_move;
; 661  :     }
; 662  : } // namespace ranges
; 663  : 
; 664  : // iter_swap defined below since it depends on indirectly_movable_storable
; 665  : 
; 666  : // clang-format off
; 667  : _EXPORT_STD template <class _Ty>
; 668  :     requires _Dereferenceable<_Ty> && requires(_Ty& __t) {
; 669  :         { _RANGES iter_move(__t) } -> _Can_reference;
; 670  :     }
; 671  : using iter_rvalue_reference_t = decltype(_RANGES iter_move(_STD declval<_Ty&>()));
; 672  : // clang-format on
; 673  : 
; 674  : template <class _It>
; 675  : concept _Indirectly_readable_impl =
; 676  :     requires(const _It __i) {
; 677  :         typename iter_value_t<_It>;
; 678  :         typename iter_reference_t<_It>;
; 679  :         typename iter_rvalue_reference_t<_It>;
; 680  :         { *__i } -> same_as<iter_reference_t<_It>>;
; 681  :         { _RANGES iter_move(__i) } -> same_as<iter_rvalue_reference_t<_It>>;
; 682  :     } && common_reference_with<iter_reference_t<_It>&&, iter_value_t<_It>&>
; 683  :     && common_reference_with<iter_reference_t<_It>&&, iter_rvalue_reference_t<_It>&&>
; 684  :     && common_reference_with<iter_rvalue_reference_t<_It>&&, const iter_value_t<_It>&>;
; 685  : 
; 686  : _EXPORT_STD template <class _It>
; 687  : concept indirectly_readable = _Indirectly_readable_impl<remove_cvref_t<_It>>;
; 688  : 
; 689  : template <class _Ty>
; 690  : struct _Indirect_value_impl {
; 691  :     using type = iter_value_t<_Ty>&;
; 692  : };
; 693  : 
; 694  : template <indirectly_readable _It>
; 695  : using _Indirect_value_t = typename _Indirect_value_impl<_It>::type;
; 696  : 
; 697  : _EXPORT_STD template <indirectly_readable _Ty>
; 698  : using iter_common_reference_t = common_reference_t<iter_reference_t<_Ty>, _Indirect_value_t<_Ty>>;
; 699  : 
; 700  : _EXPORT_STD template <class _It, class _Ty>
; 701  : concept indirectly_writable = requires(_It&& __i, _Ty&& __t) {
; 702  :     *__i                                                                = static_cast<_Ty&&>(__t);
; 703  :     *static_cast<_It&&>(__i)                                            = static_cast<_Ty&&>(__t);
; 704  :     const_cast<const iter_reference_t<_It>&&>(*__i)                     = static_cast<_Ty&&>(__t);
; 705  :     const_cast<const iter_reference_t<_It>&&>(*static_cast<_It&&>(__i)) = static_cast<_Ty&&>(__t);
; 706  : };
; 707  : 
; 708  : template <bool _Is_integer_class>
; 709  : struct _Make_unsigned_like_impl {
; 710  :     template <class _Ty>
; 711  :     using _Apply = typename _Ty::_Unsigned_type;
; 712  : };
; 713  : template <>
; 714  : struct _Make_unsigned_like_impl<false> {
; 715  :     template <class _Ty>
; 716  :     using _Apply = make_unsigned_t<_Ty>;
; 717  : };
; 718  : 
; 719  : template <class _Ty>
; 720  : using _Make_unsigned_like_t = typename _Make_unsigned_like_impl<_Integer_class<_Ty>>::template _Apply<_Ty>;
; 721  : 
; 722  : template <_Integer_like _Ty>
; 723  : _NODISCARD constexpr auto _To_unsigned_like(const _Ty _Value) noexcept {
; 724  :     return static_cast<_Make_unsigned_like_t<_Ty>>(_Value);
; 725  : }
; 726  : 
; 727  : template <bool _Is_integer_class>
; 728  : struct _Make_signed_like_impl {
; 729  :     template <class _Ty>
; 730  :     using _Apply = typename _Ty::_Signed_type;
; 731  : };
; 732  : template <>
; 733  : struct _Make_signed_like_impl<false> {
; 734  :     template <class _Ty>
; 735  :     using _Apply = make_signed_t<_Ty>;
; 736  : };
; 737  : 
; 738  : template <class _Ty>
; 739  : using _Make_signed_like_t = typename _Make_signed_like_impl<_Integer_class<_Ty>>::template _Apply<_Ty>;
; 740  : 
; 741  : _EXPORT_STD template <class _Ty>
; 742  : concept incrementable = regular<_Ty> && weakly_incrementable<_Ty> && requires(_Ty __t) {
; 743  :     { __t++ } -> same_as<_Ty>;
; 744  : };
; 745  : 
; 746  : template <bool _Iterator_category_present>
; 747  : struct _Iter_concept_impl2 {
; 748  :     template <class _It, class _Traits>
; 749  :     using _Apply = typename _Traits::iterator_category;
; 750  : };
; 751  : template <>
; 752  : struct _Iter_concept_impl2<false> {
; 753  :     template <class _It, class _Traits>
; 754  :         requires _Is_from_primary<iterator_traits<_It>>
; 755  :     using _Apply = random_access_iterator_tag;
; 756  : };
; 757  : 
; 758  : template <bool _Iterator_concept_present>
; 759  : struct _Iter_concept_impl1 {
; 760  :     template <class _It, class _Traits>
; 761  :     using _Apply = typename _Traits::iterator_concept;
; 762  : };
; 763  : template <>
; 764  : struct _Iter_concept_impl1<false> {
; 765  :     template <class _It, class _Traits>
; 766  :     using _Apply = typename _Iter_concept_impl2<_Has_member_iterator_category<_Traits>>::template _Apply<_It, _Traits>;
; 767  : };
; 768  : 
; 769  : template <class _It, class _Traits = conditional_t<_Is_from_primary<iterator_traits<_It>>, _It, iterator_traits<_It>>>
; 770  : using _Iter_concept =
; 771  :     typename _Iter_concept_impl1<_Has_member_iterator_concept<_Traits>>::template _Apply<_It, _Traits>;
; 772  : 
; 773  : // clang-format off
; 774  : _EXPORT_STD template <class _It>
; 775  : concept input_iterator = input_or_output_iterator<_It> && indirectly_readable<_It>
; 776  :     && requires { typename _Iter_concept<_It>; }
; 777  :     && derived_from<_Iter_concept<_It>, input_iterator_tag>;
; 778  : 
; 779  : _EXPORT_STD template <class _It, class _Ty>
; 780  : concept output_iterator = input_or_output_iterator<_It> && indirectly_writable<_It, _Ty>
; 781  :     && requires(_It __i, _Ty&& __t) {
; 782  :         *__i++ = static_cast<_Ty&&>(__t);
; 783  :     };
; 784  : 
; 785  : _EXPORT_STD template <class _It>
; 786  : concept forward_iterator = input_iterator<_It> && derived_from<_Iter_concept<_It>, forward_iterator_tag>
; 787  :     && incrementable<_It> && sentinel_for<_It, _It>;
; 788  : 
; 789  : _EXPORT_STD template <class _It>
; 790  : concept bidirectional_iterator = forward_iterator<_It> && derived_from<_Iter_concept<_It>, bidirectional_iterator_tag>
; 791  :     && requires(_It __i) {
; 792  :         { --__i } -> same_as<_It&>;
; 793  :         { __i-- } -> same_as<_It>;
; 794  :     };
; 795  : 
; 796  : _EXPORT_STD template <class _It>
; 797  : concept random_access_iterator = bidirectional_iterator<_It>
; 798  :     && derived_from<_Iter_concept<_It>, random_access_iterator_tag> && totally_ordered<_It>
; 799  :     && sized_sentinel_for<_It, _It> && requires(_It __i, const _It __j, const iter_difference_t<_It> __n) {
; 800  :         { __i += __n } -> same_as<_It&>;
; 801  :         { __j + __n } -> same_as<_It>;
; 802  :         { __n + __j } -> same_as<_It>;
; 803  :         { __i -= __n } -> same_as<_It&>;
; 804  :         { __j - __n } -> same_as<_It>;
; 805  :         { __j[__n] } -> same_as<iter_reference_t<_It>>;
; 806  :     };
; 807  : 
; 808  : _EXPORT_STD template <class _It>
; 809  : concept contiguous_iterator = random_access_iterator<_It>
; 810  :     && derived_from<_Iter_concept<_It>, contiguous_iterator_tag>
; 811  :     && is_lvalue_reference_v<iter_reference_t<_It>>
; 812  :     && same_as<iter_value_t<_It>, remove_cvref_t<iter_reference_t<_It>>>
; 813  :     && requires(const _It& __i) {
; 814  :         { _STD to_address(__i) } -> same_as<add_pointer_t<iter_reference_t<_It>>>;
; 815  :     };
; 816  : // clang-format on
; 817  : 
; 818  : _EXPORT_STD template <class _Fn, class _It>
; 819  : concept indirectly_unary_invocable =
; 820  :     indirectly_readable<_It> && copy_constructible<_Fn> && invocable<_Fn&, _Indirect_value_t<_It>>
; 821  :     && invocable<_Fn&, iter_reference_t<_It>> && invocable<_Fn&, iter_common_reference_t<_It>>
; 822  :     && common_reference_with<invoke_result_t<_Fn&, _Indirect_value_t<_It>>,
; 823  :         invoke_result_t<_Fn&, iter_reference_t<_It>>>;
; 824  : 
; 825  : _EXPORT_STD template <class _Fn, class _It>
; 826  : concept indirectly_regular_unary_invocable =
; 827  :     indirectly_readable<_It> && copy_constructible<_Fn> && regular_invocable<_Fn&, _Indirect_value_t<_It>>
; 828  :     && regular_invocable<_Fn&, iter_reference_t<_It>> && regular_invocable<_Fn&, iter_common_reference_t<_It>>
; 829  :     && common_reference_with<invoke_result_t<_Fn&, _Indirect_value_t<_It>>,
; 830  :         invoke_result_t<_Fn&, iter_reference_t<_It>>>;
; 831  : 
; 832  : _EXPORT_STD template <class _Fn, class _It>
; 833  : concept indirect_unary_predicate =
; 834  :     indirectly_readable<_It> && copy_constructible<_Fn> && predicate<_Fn&, _Indirect_value_t<_It>>
; 835  :     && predicate<_Fn&, iter_reference_t<_It>> && predicate<_Fn&, iter_common_reference_t<_It>>;
; 836  : 
; 837  : _EXPORT_STD template <class _Fn, class _It1, class _It2>
; 838  : concept indirect_binary_predicate = indirectly_readable<_It1> && indirectly_readable<_It2> && copy_constructible<_Fn>
; 839  :                                  && predicate<_Fn&, _Indirect_value_t<_It1>, _Indirect_value_t<_It2>>
; 840  :                                  && predicate<_Fn&, _Indirect_value_t<_It1>, iter_reference_t<_It2>>
; 841  :                                  && predicate<_Fn&, iter_reference_t<_It1>, _Indirect_value_t<_It2>>
; 842  :                                  && predicate<_Fn&, iter_reference_t<_It1>, iter_reference_t<_It2>>
; 843  :                                  && predicate<_Fn&, iter_common_reference_t<_It1>, iter_common_reference_t<_It2>>;
; 844  : 
; 845  : _EXPORT_STD template <class _Fn, class _It1, class _It2 = _It1>
; 846  : concept indirect_equivalence_relation =
; 847  :     indirectly_readable<_It1> && indirectly_readable<_It2> && copy_constructible<_Fn>
; 848  :     && equivalence_relation<_Fn&, _Indirect_value_t<_It1>, _Indirect_value_t<_It2>>
; 849  :     && equivalence_relation<_Fn&, _Indirect_value_t<_It1>, iter_reference_t<_It2>>
; 850  :     && equivalence_relation<_Fn&, iter_reference_t<_It1>, _Indirect_value_t<_It2>>
; 851  :     && equivalence_relation<_Fn&, iter_reference_t<_It1>, iter_reference_t<_It2>>
; 852  :     && equivalence_relation<_Fn&, iter_common_reference_t<_It1>, iter_common_reference_t<_It2>>;
; 853  : 
; 854  : _EXPORT_STD template <class _Fn, class _It1, class _It2 = _It1>
; 855  : concept indirect_strict_weak_order =
; 856  :     indirectly_readable<_It1> && indirectly_readable<_It2> && copy_constructible<_Fn>
; 857  :     && strict_weak_order<_Fn&, _Indirect_value_t<_It1>, _Indirect_value_t<_It2>>
; 858  :     && strict_weak_order<_Fn&, _Indirect_value_t<_It1>, iter_reference_t<_It2>>
; 859  :     && strict_weak_order<_Fn&, iter_reference_t<_It1>, _Indirect_value_t<_It2>>
; 860  :     && strict_weak_order<_Fn&, iter_reference_t<_It1>, iter_reference_t<_It2>>
; 861  :     && strict_weak_order<_Fn&, iter_common_reference_t<_It1>, iter_common_reference_t<_It2>>;
; 862  : 
; 863  : _EXPORT_STD template <class _Fn, class... _Its>
; 864  :     requires (indirectly_readable<_Its> && ...) && invocable<_Fn, iter_reference_t<_Its>...>
; 865  : using indirect_result_t = invoke_result_t<_Fn, iter_reference_t<_Its>...>;
; 866  : 
; 867  : _EXPORT_STD template <indirectly_readable _It, indirectly_regular_unary_invocable<_It> _Proj>
; 868  : struct projected {
; 869  :     using value_type = remove_cvref_t<indirect_result_t<_Proj&, _It>>;
; 870  :     indirect_result_t<_Proj&, _It> operator*() const {
; 871  :         _CSTD abort();
; 872  :     }
; 873  : };
; 874  : 
; 875  : template <class _It, class _Proj>
; 876  : struct _Indirect_value_impl<projected<_It, _Proj>> {
; 877  :     using type = invoke_result_t<_Proj&, _Indirect_value_t<_It>>;
; 878  : };
; 879  : 
; 880  : template <weakly_incrementable _It, class _Proj>
; 881  : struct incrementable_traits<projected<_It, _Proj>> {
; 882  :     using difference_type = iter_difference_t<_It>;
; 883  : };
; 884  : 
; 885  : _EXPORT_STD template <class _In, class _Out>
; 886  : concept indirectly_movable = indirectly_readable<_In> && indirectly_writable<_Out, iter_rvalue_reference_t<_In>>;
; 887  : 
; 888  : // clang-format off
; 889  : _EXPORT_STD template <class _In, class _Out>
; 890  : concept indirectly_movable_storable = indirectly_movable<_In, _Out>
; 891  :     && indirectly_writable<_Out, iter_value_t<_In>>
; 892  :     && movable<iter_value_t<_In>>
; 893  :     && constructible_from<iter_value_t<_In>, iter_rvalue_reference_t<_In>>
; 894  :     && assignable_from<iter_value_t<_In>&, iter_rvalue_reference_t<_In> >;
; 895  : // clang-format on
; 896  : 
; 897  : _EXPORT_STD template <class _In, class _Out>
; 898  : concept indirectly_copyable = indirectly_readable<_In> && indirectly_writable<_Out, iter_reference_t<_In>>;
; 899  : 
; 900  : // clang-format off
; 901  : _EXPORT_STD template <class _In, class _Out>
; 902  : concept indirectly_copyable_storable = indirectly_copyable<_In, _Out>
; 903  :     && indirectly_writable<_Out, iter_value_t<_In>&>
; 904  :     && indirectly_writable<_Out, const iter_value_t<_In>&>
; 905  :     && indirectly_writable<_Out, iter_value_t<_In>&&>
; 906  :     && indirectly_writable<_Out, const iter_value_t<_In>&&>
; 907  :     && copyable<iter_value_t<_In>>
; 908  :     && constructible_from<iter_value_t<_In>, iter_reference_t<_In>>
; 909  :     && assignable_from<iter_value_t<_In>&, iter_reference_t<_In>>;
; 910  : // clang-format on
; 911  : 
; 912  : namespace ranges {
; 913  :     namespace _Iter_swap {
; 914  :         template <class _Ty1, class _Ty2>
; 915  :         void iter_swap(_Ty1, _Ty2) = delete;
; 916  : 
; 917  :         // clang-format off
; 918  :         template <class _Ty1, class _Ty2>
; 919  :         concept _Has_ADL = (_Has_class_or_enum_type<_Ty1> || _Has_class_or_enum_type<_Ty2>)
; 920  :             && requires(_Ty1&& __t1, _Ty2&& __t2) {
; 921  :                 iter_swap(static_cast<_Ty1&&>(__t1), static_cast<_Ty2&&>(__t2)); // intentional ADL
; 922  :             };
; 923  : 
; 924  :         template <class _Ty1, class _Ty2>
; 925  :         concept _Can_swap_references = indirectly_readable<remove_reference_t<_Ty1>>
; 926  :             && indirectly_readable<remove_reference_t<_Ty2>>
; 927  :             && swappable_with<iter_reference_t<_Ty1>, iter_reference_t<_Ty2>>;
; 928  : 
; 929  :         template <class _Ty1, class _Ty2>
; 930  :         concept _Symmetric_indirectly_movable_storable =
; 931  :                indirectly_movable_storable<remove_reference_t<_Ty1>, remove_reference_t<_Ty2>>
; 932  :             && indirectly_movable_storable<remove_reference_t<_Ty2>, remove_reference_t<_Ty1>>;
; 933  :         // clang-format on
; 934  : 
; 935  :         template <class _Xty, class _Yty>
; 936  :         _NODISCARD constexpr iter_value_t<remove_reference_t<_Xty>> _Iter_exchange_move(_Xty&& _XVal,
; 937  :             _Yty&& _YVal) noexcept(noexcept(iter_value_t<remove_reference_t<_Xty>>(_RANGES iter_move(_XVal)))) {
; 938  :             iter_value_t<remove_reference_t<_Xty>> _Tmp(_RANGES iter_move(_XVal));
; 939  :             *_XVal = _RANGES iter_move(_YVal);
; 940  :             return _Tmp;
; 941  :         }
; 942  : 
; 943  :         class _Cpo {
; 944  :         private:
; 945  :             enum class _St { _None, _Custom, _Swap, _Exchange };
; 946  : 
; 947  :             template <class _Ty1, class _Ty2>
; 948  :             _NODISCARD static consteval _Choice_t<_St> _Choose() noexcept {
; 949  :                 if constexpr (_Has_ADL<_Ty1, _Ty2>) {
; 950  :                     return {_St::_Custom,
; 951  :                         noexcept(iter_swap(_STD declval<_Ty1>(), _STD declval<_Ty2>()))}; // intentional ADL
; 952  :                 } else if constexpr (_Can_swap_references<_Ty1, _Ty2>) {
; 953  :                     return {_St::_Swap, noexcept(_RANGES swap(*_STD declval<_Ty1>(), *_STD declval<_Ty2>()))};
; 954  :                 } else if constexpr (_Symmetric_indirectly_movable_storable<_Ty1, _Ty2>) {
; 955  :                     constexpr auto _Nothrow = noexcept(*_STD declval<_Ty1>() = _Iter_swap::_Iter_exchange_move(
; 956  :                                                            _STD declval<_Ty2>(), _STD declval<_Ty1>()));
; 957  :                     return {_St::_Exchange, _Nothrow};
; 958  :                 } else {
; 959  :                     return {_St::_None};
; 960  :                 }
; 961  :             }
; 962  : 
; 963  :             template <class _Ty1, class _Ty2>
; 964  :             static constexpr _Choice_t<_St> _Choice = _Choose<_Ty1, _Ty2>();
; 965  : 
; 966  :         public:
; 967  :             template <class _Ty1, class _Ty2>
; 968  :                 requires (_Choice<_Ty1, _Ty2>._Strategy != _St::_None)
; 969  :             constexpr void operator()(_Ty1&& _Val1, _Ty2&& _Val2) const noexcept(_Choice<_Ty1, _Ty2>._No_throw) {
; 970  :                 constexpr _St _Strat = _Choice<_Ty1, _Ty2>._Strategy;
; 971  : 
; 972  :                 if constexpr (_Strat == _St::_Custom) {
; 973  :                     (void) iter_swap(static_cast<_Ty1&&>(_Val1), static_cast<_Ty2&&>(_Val2)); // intentional ADL
; 974  :                 } else if constexpr (_Strat == _St::_Swap) {
; 975  :                     _RANGES swap(*static_cast<_Ty1&&>(_Val1), *static_cast<_Ty2&&>(_Val2));
; 976  :                 } else if constexpr (_Strat == _St::_Exchange) {
; 977  :                     *static_cast<_Ty1&&>(_Val1) =
; 978  :                         _Iter_swap::_Iter_exchange_move(static_cast<_Ty2&&>(_Val2), static_cast<_Ty1&&>(_Val1));
; 979  :                 } else {
; 980  :                     static_assert(_Always_false<_Ty1>, "should be unreachable");
; 981  :                 }
; 982  :             }
; 983  :         };
; 984  :     } // namespace _Iter_swap
; 985  : 
; 986  :     inline namespace _Cpos {
; 987  :         _EXPORT_STD inline constexpr _Iter_swap::_Cpo iter_swap;
; 988  :     }
; 989  : } // namespace ranges
; 990  : 
; 991  : // clang-format off
; 992  : _EXPORT_STD template <class _It1, class _It2 = _It1>
; 993  : concept indirectly_swappable = indirectly_readable<_It1> && indirectly_readable<_It2>
; 994  :     && requires(const _It1 __i1, const _It2 __i2) {
; 995  :         _RANGES iter_swap(__i1, __i1);
; 996  :         _RANGES iter_swap(__i2, __i2);
; 997  :         _RANGES iter_swap(__i1, __i2);
; 998  :         _RANGES iter_swap(__i2, __i1);
; 999  :     };
; 1000 : // clang-format on
; 1001 : 
; 1002 : _EXPORT_STD template <class _It1, class _It2, class _Rel, class _Proj1 = identity, class _Proj2 = identity>
; 1003 : concept indirectly_comparable = indirect_binary_predicate<_Rel, projected<_It1, _Proj1>, projected<_It2, _Proj2>>;
; 1004 : 
; 1005 : _EXPORT_STD template <class _It>
; 1006 : concept permutable = forward_iterator<_It> && indirectly_movable_storable<_It, _It> && indirectly_swappable<_It, _It>;
; 1007 : 
; 1008 : namespace ranges {
; 1009 :     _EXPORT_STD struct less;
; 1010 : } // namespace ranges
; 1011 : 
; 1012 : _EXPORT_STD template <class _It1, class _It2, class _Out, class _Pr = ranges::less, class _Pj1 = identity,
; 1013 :     class _Pj2 = identity>
; 1014 : concept mergeable = input_iterator<_It1> && input_iterator<_It2> //
; 1015 :                  && weakly_incrementable<_Out> //
; 1016 :                  && indirectly_copyable<_It1, _Out> //
; 1017 :                  && indirectly_copyable<_It2, _Out> //
; 1018 :                  && indirect_strict_weak_order<_Pr, projected<_It1, _Pj1>, projected<_It2, _Pj2>>;
; 1019 : 
; 1020 : _EXPORT_STD template <class _It, class _Pr = ranges::less, class _Proj = identity>
; 1021 : concept sortable = permutable<_It> && indirect_strict_weak_order<_Pr, projected<_It, _Proj>>;
; 1022 : 
; 1023 : template <class _Iter>
; 1024 : using _Iter_ref_t = iter_reference_t<_Iter>;
; 1025 : 
; 1026 : template <class _Iter>
; 1027 : using _Iter_value_t = iter_value_t<_Iter>;
; 1028 : 
; 1029 : template <class _Iter>
; 1030 : using _Iter_diff_t = iter_difference_t<_Iter>;
; 1031 : 
; 1032 : #else // ^^^ __cpp_lib_concepts / !__cpp_lib_concepts vvv
; 1033 : template <class _Iter>
; 1034 : using _Iter_ref_t = typename iterator_traits<_Iter>::reference;
; 1035 : 
; 1036 : template <class _Iter>
; 1037 : using _Iter_value_t = typename iterator_traits<_Iter>::value_type;
; 1038 : 
; 1039 : template <class _Iter>
; 1040 : using _Iter_diff_t = typename iterator_traits<_Iter>::difference_type;
; 1041 : 
; 1042 : template <class _Ty>
; 1043 : using _Make_unsigned_like_t = make_unsigned_t<_Ty>;
; 1044 : #endif // __cpp_lib_concepts
; 1045 : 
; 1046 : template <class... _Iters>
; 1047 : using _Common_diff_t = common_type_t<_Iter_diff_t<_Iters>...>;
; 1048 : 
; 1049 : template <class _Iter>
; 1050 : using _Iter_cat_t = typename iterator_traits<_Iter>::iterator_category;
; 1051 : 
; 1052 : template <class _Ty, class = void>
; 1053 : _INLINE_VAR constexpr bool _Is_iterator_v = false;
; 1054 : 
; 1055 : template <class _Ty>
; 1056 : _INLINE_VAR constexpr bool _Is_iterator_v<_Ty, void_t<_Iter_cat_t<_Ty>>> = true;
; 1057 : 
; 1058 : template <class _Ty>
; 1059 : struct _Is_iterator : bool_constant<_Is_iterator_v<_Ty>> {};
; 1060 : 
; 1061 : template <class _Iter>
; 1062 : _INLINE_VAR constexpr bool _Is_cpp17_input_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, input_iterator_tag>;
; 1063 : 
; 1064 : template <class _Iter>
; 1065 : _INLINE_VAR constexpr bool _Is_ranges_input_iter_v =
; 1066 : #ifdef __cpp_lib_concepts
; 1067 :     (input_iterator<_Iter> && sentinel_for<_Iter, _Iter>) ||
; 1068 : #endif
; 1069 :     _Is_cpp17_input_iter_v<_Iter>;
; 1070 : 
; 1071 : template <class _Iter>
; 1072 : _INLINE_VAR constexpr bool _Is_cpp17_fwd_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, forward_iterator_tag>;
; 1073 : 
; 1074 : template <class _Iter>
; 1075 : _INLINE_VAR constexpr bool _Is_ranges_fwd_iter_v =
; 1076 : #ifdef __cpp_lib_concepts
; 1077 :     forward_iterator<_Iter> ||
; 1078 : #endif
; 1079 :     _Is_cpp17_fwd_iter_v<_Iter>;
; 1080 : 
; 1081 : template <class _Iter>
; 1082 : _INLINE_VAR constexpr bool _Is_cpp17_bidi_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, bidirectional_iterator_tag>;
; 1083 : 
; 1084 : template <class _Iter>
; 1085 : _INLINE_VAR constexpr bool _Is_ranges_bidi_iter_v =
; 1086 : #ifdef __cpp_lib_concepts
; 1087 :     bidirectional_iterator<_Iter> ||
; 1088 : #endif
; 1089 :     _Is_cpp17_bidi_iter_v<_Iter>;
; 1090 : 
; 1091 : template <class _Iter>
; 1092 : _INLINE_VAR constexpr bool _Is_cpp17_random_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, random_access_iterator_tag>;
; 1093 : 
; 1094 : template <class _Iter>
; 1095 : _INLINE_VAR constexpr bool _Is_ranges_random_iter_v =
; 1096 : #ifdef __cpp_lib_concepts
; 1097 :     random_access_iterator<_Iter> ||
; 1098 : #endif
; 1099 :     _Is_cpp17_random_iter_v<_Iter>;
; 1100 : 
; 1101 : #define _REQUIRE_CPP17_MUTABLE_ITERATOR(_Iter) \
; 1102 :     static_assert(_Is_cpp17_fwd_iter_v<_Iter>, \
; 1103 :         "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.")
; 1104 : 
; 1105 : template <class, class = void>
; 1106 : struct _Is_checked_helper {}; // default definition, no longer used, retained due to pseudo-documentation
; 1107 : 
; 1108 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1109 : template <class _Ty>
; 1110 : constexpr void _Verify_range(const _Ty* const _First, const _Ty* const _Last) noexcept {
; 1111 :     // special case range verification for pointers
; 1112 :     _STL_VERIFY(_First <= _Last, "transposed pointer range");
; 1113 : }
; 1114 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1115 : 
; 1116 : template <class _Iter, class = void>
; 1117 : _INLINE_VAR constexpr bool _Allow_inheriting_unwrap_v = true;
; 1118 : 
; 1119 : template <class _Iter>
; 1120 : _INLINE_VAR constexpr bool _Allow_inheriting_unwrap_v<_Iter, void_t<typename _Iter::_Prevent_inheriting_unwrap>> =
; 1121 :     is_same_v<_Iter, typename _Iter::_Prevent_inheriting_unwrap>;
; 1122 : 
; 1123 : template <class _Iter, class _Sentinel = _Iter, class = void>
; 1124 : _INLINE_VAR constexpr bool _Range_verifiable_v = false;
; 1125 : 
; 1126 : template <class _Iter, class _Sentinel>
; 1127 : _INLINE_VAR constexpr bool _Range_verifiable_v<_Iter, _Sentinel,
; 1128 :     void_t<decltype(_Verify_range(_STD declval<const _Iter&>(), _STD declval<const _Sentinel&>()))>> =
; 1129 :     _Allow_inheriting_unwrap_v<_Iter>;
; 1130 : 
; 1131 : template <class _Iter, class _Sentinel>
; 1132 : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {
; 1133 :     // check that [_First, _Last) forms an iterator range
; 1134 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1135 :         _Verify_range(_First, _Last);
; 1136 :     }
; 1137 : }
; 1138 : 
; 1139 : template <class _Iter, class = void>
; 1140 : _INLINE_VAR constexpr bool _Unwrappable_v = false;
; 1141 : 
; 1142 : template <class _Iter>
; 1143 : _INLINE_VAR constexpr bool _Unwrappable_v<_Iter,
; 1144 :     void_t<decltype(_STD declval<_Remove_cvref_t<_Iter>&>()._Seek_to(_STD declval<_Iter>()._Unwrapped()))>> =
; 1145 :     _Allow_inheriting_unwrap_v<_Remove_cvref_t<_Iter>>;
; 1146 : 
; 1147 : template <class _Iter, class = void>
; 1148 : _INLINE_VAR constexpr bool _Has_nothrow_unwrapped = false;
; 1149 : template <class _Iter>
; 1150 : _INLINE_VAR constexpr bool _Has_nothrow_unwrapped<_Iter, void_t<decltype(_STD declval<_Iter>()._Unwrapped())>> =
; 1151 :     noexcept(_STD declval<_Iter>()._Unwrapped());
; 1152 : 
; 1153 : template <class _Iter>
; 1154 : _NODISCARD constexpr decltype(auto) _Get_unwrapped(_Iter&& _It) noexcept(
; 1155 :     !_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {
; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;
; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }
; 1165 : 
; 1166 : template <class _Iter>
; 1167 : using _Unwrapped_t = _Remove_cvref_t<decltype(_Get_unwrapped(_STD declval<_Iter>()))>;
; 1168 : 
; 1169 : template <class _Iter, class = bool>
; 1170 : _INLINE_VAR constexpr bool _Do_unwrap_when_unverified_v = false;
; 1171 : 
; 1172 : template <class _Iter>
; 1173 : _INLINE_VAR constexpr bool
; 1174 :     _Do_unwrap_when_unverified_v<_Iter, decltype(static_cast<bool>(_Iter::_Unwrap_when_unverified))> =
; 1175 :         static_cast<bool>(_Iter::_Unwrap_when_unverified);
; 1176 : 
; 1177 : template <class _Iter>
; 1178 : _INLINE_VAR constexpr bool _Unwrappable_for_unverified_v =
; 1179 :     _Unwrappable_v<_Iter> && _Do_unwrap_when_unverified_v<_Remove_cvref_t<_Iter>>;
; 1180 : 
; 1181 : template <class _Iter>
; 1182 : _NODISCARD constexpr decltype(auto) _Get_unwrapped_unverified(_Iter&& _It) {
; 1183 :     // unwrap an iterator not previously subjected to _Adl_verify_range
; 1184 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1185 :         return _It + 0;
; 1186 :     } else if constexpr (_Unwrappable_for_unverified_v<_Iter>) {
; 1187 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1188 :     } else {
; 1189 :         return static_cast<_Iter&&>(_It);
; 1190 :     }
; 1191 : }
; 1192 : 
; 1193 : template <class _Iter>
; 1194 : using _Unwrapped_unverified_t = _Remove_cvref_t<decltype(_Get_unwrapped_unverified(_STD declval<_Iter>()))>;
; 1195 : 
; 1196 : struct _Distance_unknown {
; 1197 :     constexpr _Distance_unknown operator-() const noexcept {
; 1198 :         return {};
; 1199 :     }
; 1200 : };
; 1201 : 
; 1202 : template <class _Diff>
; 1203 : _INLINE_VAR constexpr _Diff _Max_possible_v{static_cast<_Make_unsigned_like_t<_Diff>>(-1) >> 1};
; 1204 : 
; 1205 : template <class _Diff>
; 1206 : _INLINE_VAR constexpr _Diff _Min_possible_v{-_Max_possible_v<_Diff> - 1};
; 1207 : 
; 1208 : template <class _Iter, class = void>
; 1209 : _INLINE_VAR constexpr bool _Offset_verifiable_v = false;
; 1210 : 
; 1211 : template <class _Iter>
; 1212 : _INLINE_VAR constexpr bool
; 1213 :     _Offset_verifiable_v<_Iter, void_t<decltype(_STD declval<const _Iter&>()._Verify_offset(_Iter_diff_t<_Iter>{}))>> =
; 1214 :         true;
; 1215 : 
; 1216 : template <class _Iter>
; 1217 : _INLINE_VAR constexpr bool _Unwrappable_for_offset_v =
; 1218 :     _Unwrappable_v<_Iter> && _Offset_verifiable_v<_Remove_cvref_t<_Iter>>;
; 1219 : 
; 1220 : template <class _Iter, class _Diff>
; 1221 : _NODISCARD constexpr decltype(auto) _Get_unwrapped_n(_Iter&& _It, const _Diff _Off) {
; 1222 :     if constexpr (is_pointer_v<decay_t<_Iter>>) {
; 1223 :         return _It + 0;
; 1224 :     } else if constexpr (_Unwrappable_for_offset_v<_Iter> && is_integral_v<_Diff>) {
; 1225 :         // ask an iterator to assert that the iterator moved _Off positions is valid, and unwrap
; 1226 :         using _IDiff     = _Iter_diff_t<_Remove_cvref_t<_Iter>>;
; 1227 :         using _CDiff     = common_type_t<_Diff, _IDiff>;
; 1228 :         const auto _COff = static_cast<_CDiff>(_Off);
; 1229 : 
; 1230 :         _STL_ASSERT(_COff <= static_cast<_CDiff>(_Max_possible_v<_IDiff>)
; 1231 :                         && (is_unsigned_v<_Diff> || static_cast<_CDiff>(_Min_possible_v<_IDiff>) <= _COff),
; 1232 :             "integer overflow");
; 1233 :         (void) _COff;
; 1234 : 
; 1235 :         _It._Verify_offset(static_cast<_IDiff>(_Off));
; 1236 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1237 :     } else if constexpr (_Unwrappable_for_unverified_v<_Iter>) {
; 1238 :         // iterator doesn't support offset-based asserts, or offset unknown; defer to unverified unwrap
; 1239 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1240 :     } else {
; 1241 :         // pass through iterator that doesn't participate in checking
; 1242 :         return static_cast<_Iter&&>(_It);
; 1243 :     }
; 1244 : }
; 1245 : 
; 1246 : template <class _Iter, class _UIter, class = void>
; 1247 : _INLINE_VAR constexpr bool _Wrapped_seekable_v = false;
; 1248 : 
; 1249 : template <class _Iter, class _UIter>
; 1250 : _INLINE_VAR constexpr bool
; 1251 :     _Wrapped_seekable_v<_Iter, _UIter, void_t<decltype(_STD declval<_Iter&>()._Seek_to(_STD declval<_UIter>()))>> =
; 1252 :         true;
; 1253 : 
; 1254 : template <class _Iter, class _UIter>
; 1255 : constexpr void _Seek_wrapped(_Iter& _It, _UIter&& _UIt) {
; 1256 :     if constexpr (_Wrapped_seekable_v<_Iter, _UIter>) {
; 1257 :         _It._Seek_to(_STD forward<_UIter>(_UIt));
; 1258 :     } else {
; 1259 :         _It = _STD forward<_UIter>(_UIt);
; 1260 :     }
; 1261 : }
; 1262 : 
; 1263 : #if _HAS_CXX17
; 1264 : template <class _Ty, class = void>
; 1265 : struct _Is_allocator : false_type {}; // selected when _Ty can't possibly be an allocator
; 1266 : 
; 1267 : template <class _Ty>
; 1268 : struct _Is_allocator<_Ty, void_t<typename _Ty::value_type, decltype(_STD declval<_Ty&>().deallocate(
; 1269 :                                                                _STD declval<_Ty&>().allocate(size_t{1}), size_t{1}))>>
; 1270 :     : true_type {}; // selected when _Ty resembles an allocator, N4950 [container.reqmts]/69
; 1271 : 
; 1272 : // deduction guide utilities (N4950 [associative.general]/2)
; 1273 : template <class _Iter>
; 1274 : using _Guide_key_t =
; 1275 : #if _HAS_CXX23
; 1276 :     remove_const_t<tuple_element_t<0, typename iterator_traits<_Iter>::value_type>>;
; 1277 : #else // ^^^ C++23 / C++20 vvv
; 1278 :     remove_const_t<typename iterator_traits<_Iter>::value_type::first_type>;
; 1279 : #endif // C++20
; 1280 : 
; 1281 : template <class _Iter>
; 1282 : using _Guide_val_t =
; 1283 : #if _HAS_CXX23
; 1284 :     tuple_element_t<1, typename iterator_traits<_Iter>::value_type>;
; 1285 : #else // ^^^ C++23 / C++20 vvv
; 1286 :     typename iterator_traits<_Iter>::value_type::second_type;
; 1287 : #endif // C++20
; 1288 : 
; 1289 : template <class _Iter>
; 1290 : using _Guide_pair_t =
; 1291 : #if _HAS_CXX23
; 1292 :     pair<add_const_t<tuple_element_t<0, typename iterator_traits<_Iter>::value_type>>,
; 1293 :         tuple_element_t<1, typename iterator_traits<_Iter>::value_type>>;
; 1294 : #else // ^^^ C++23 / C++20 vvv
; 1295 :     pair<add_const_t<typename iterator_traits<_Iter>::value_type::first_type>,
; 1296 :         typename iterator_traits<_Iter>::value_type::second_type>;
; 1297 : #endif // C++20
; 1298 : 
; 1299 : _EXPORT_STD template <class _Ty>
; 1300 : struct is_execution_policy : false_type {};
; 1301 : 
; 1302 : _EXPORT_STD template <class _Ty>
; 1303 : inline constexpr bool is_execution_policy_v = is_execution_policy<_Ty>::value;
; 1304 : 
; 1305 : // Note: The noexcept specifiers on all parallel algorithm overloads enforce termination as per
; 1306 : // N4950 [execpol.seq]/2, [execpol.par]/2, [execpol.parunseq]/2, and [execpol.unseq]/2
; 1307 : template <class _ExPo>
; 1308 : using _Enable_if_execution_policy_t = typename remove_reference_t<_ExPo>::_Standard_execution_policy;
; 1309 : 
; 1310 : #define _REQUIRE_PARALLEL_ITERATOR(_Iter) \
; 1311 :     static_assert(_Is_ranges_fwd_iter_v<_Iter>, "Parallel algorithms require forward iterators or stronger.")
; 1312 : 
; 1313 : #endif // _HAS_CXX17
; 1314 : 
; 1315 : template <class _Checked, class _Iter>
; 1316 : _NODISCARD constexpr auto _Idl_distance(const _Iter& _First, const _Iter& _Last) {
; 1317 :     // tries to get the distance between _First and _Last if they are random-access iterators
; 1318 :     if constexpr (_Is_ranges_random_iter_v<_Iter>) {
; 1319 :         return static_cast<_Iter_diff_t<_Checked>>(_Last - _First);
; 1320 :     } else {
; 1321 :         return _Distance_unknown{};
; 1322 :     }
; 1323 : }
; 1324 : 
; 1325 : template <class _Elem, bool _Is_enum = is_enum_v<_Elem>>
; 1326 : struct _Unwrap_enum { // if _Elem is an enum, gets its underlying type; otherwise leaves _Elem unchanged
; 1327 :     using type = underlying_type_t<_Elem>;
; 1328 : };
; 1329 : 
; 1330 : template <class _Elem>
; 1331 : struct _Unwrap_enum<_Elem, false> { // passthrough non-enum type
; 1332 :     using type = _Elem;
; 1333 : };
; 1334 : 
; 1335 : template <class _Elem>
; 1336 : using _Unwrap_enum_t = typename _Unwrap_enum<_Elem>::type;
; 1337 : 
; 1338 : #if _ITERATOR_DEBUG_LEVEL < 2
; 1339 : #define _DEBUG_LT_PRED(pred, x, y) static_cast<bool>(pred(x, y))
; 1340 : #define _DEBUG_ORDER_UNWRAPPED(first, last, pred)
; 1341 : #define _DEBUG_ORDER_SET_UNWRAPPED(otherIter, first, last, pred)
; 1342 : 
; 1343 : #else // _ITERATOR_DEBUG_LEVEL < 2
; 1344 : #define _DEBUG_LT_PRED(pred, x, y)                _Debug_lt_pred(pred, x, y)
; 1345 : #define _DEBUG_ORDER_UNWRAPPED(first, last, pred) _Debug_order_unchecked(first, last, pred)
; 1346 : #define _DEBUG_ORDER_SET_UNWRAPPED(otherIter, first, last, pred) \
; 1347 :     _Debug_order_set_unchecked<otherIter>(first, last, pred)
; 1348 : 
; 1349 : template <class _Pr, class _Ty1, class _Ty2,
; 1350 :     enable_if_t<is_same_v<_Remove_cvref_t<_Ty1>, _Remove_cvref_t<_Ty2>>, int> = 0>
; 1351 : constexpr bool _Debug_lt_pred(_Pr&& _Pred, _Ty1&& _Left, _Ty2&& _Right) noexcept(
; 1352 :     noexcept(_Pred(_Left, _Right)) && noexcept(_Pred(_Right, _Left))) {
; 1353 :     // test if _Pred(_Left, _Right) and _Pred is strict weak ordering, when the arguments are the cv-same-type
; 1354 :     const auto _Result = static_cast<bool>(_Pred(_Left, _Right));
; 1355 :     if (_Result) {
; 1356 :         _STL_VERIFY(!_Pred(_Right, _Left), "invalid comparator");
; 1357 :     }
; 1358 : 
; 1359 :     return _Result;
; 1360 : }
; 1361 : 
; 1362 : template <class _Pr, class _Ty1, class _Ty2,
; 1363 :     enable_if_t<!is_same_v<_Remove_cvref_t<_Ty1>, _Remove_cvref_t<_Ty2>>, int> = 0>
; 1364 : constexpr bool _Debug_lt_pred(_Pr&& _Pred, _Ty1&& _Left, _Ty2&& _Right) noexcept(noexcept(_Pred(_Left, _Right))) {
; 1365 :     // test if _Pred(_Left, _Right); no debug checks as the types differ
; 1366 :     return static_cast<bool>(_Pred(_Left, _Right));
; 1367 : }
; 1368 : 
; 1369 : template <class _InIt, class _Sentinel, class _Pr>
; 1370 : constexpr void _Debug_order_unchecked(_InIt _First, _Sentinel _Last, _Pr&& _Pred) {
; 1371 :     // test if range is ordered by predicate
; 1372 :     if constexpr (_Is_ranges_fwd_iter_v<_InIt>) {
; 1373 :         if (_First != _Last) {
; 1374 :             for (auto _Next = _First; ++_Next != _Last; _First = _Next) {
; 1375 :                 _STL_VERIFY(!static_cast<bool>(_Pred(*_Next, *_First)), "sequence not ordered");
; 1376 :             }
; 1377 :         }
; 1378 :     }
; 1379 : }
; 1380 : 
; 1381 : template <class _OtherIt, class _InIt, class _Pr>
; 1382 : constexpr void _Debug_order_set_unchecked(_InIt _First, _InIt _Last, _Pr&& _Pred) {
; 1383 :     // test if range is ordered by predicate
; 1384 :     if constexpr (is_same_v<_Iter_value_t<_OtherIt>, _Iter_value_t<_InIt>>) {
; 1385 :         _Debug_order_unchecked(_First, _Last, _Pred);
; 1386 :     }
; 1387 : }
; 1388 : #endif // _ITERATOR_DEBUG_LEVEL < 2
; 1389 : 
; 1390 : // from <iterator>
; 1391 : _EXPORT_STD template <class _InIt, class _Diff>
; 1392 : _CONSTEXPR17 void advance(_InIt& _Where, _Diff _Off) { // increment iterator by offset
; 1393 :     if constexpr (_Is_ranges_random_iter_v<_InIt>) {
; 1394 :         _Where += _Off;
; 1395 :     } else {
; 1396 :         if constexpr (is_signed_v<_Diff> && !_Is_ranges_bidi_iter_v<_InIt>) {
; 1397 :             _STL_ASSERT(_Off >= 0, "negative advance of non-bidirectional iterator");
; 1398 :         }
; 1399 : 
; 1400 :         decltype(auto) _UWhere      = _Get_unwrapped_n(_STD move(_Where), _Off);
; 1401 :         constexpr bool _Need_rewrap = !is_reference_v<decltype(_Get_unwrapped_n(_STD move(_Where), _Off))>;
; 1402 : 
; 1403 :         if constexpr (is_signed_v<_Diff> && _Is_ranges_bidi_iter_v<_InIt>) {
; 1404 :             for (; _Off < 0; ++_Off) {
; 1405 :                 --_UWhere;
; 1406 :             }
; 1407 :         }
; 1408 : 
; 1409 :         for (; 0 < _Off; --_Off) {
; 1410 :             ++_UWhere;
; 1411 :         }
; 1412 : 
; 1413 :         if constexpr (_Need_rewrap) {
; 1414 :             _Seek_wrapped(_Where, _STD move(_UWhere));
; 1415 :         }
; 1416 :     }
; 1417 : }
; 1418 : 
; 1419 : _EXPORT_STD template <class _InIt>
; 1420 : _NODISCARD _CONSTEXPR17 _Iter_diff_t<_InIt> distance(_InIt _First, _InIt _Last) {
; 1421 :     if constexpr (_Is_ranges_random_iter_v<_InIt>) {
; 1422 :         return _Last - _First; // assume the iterator will do debug checking
; 1423 :     } else {
; 1424 :         _Adl_verify_range(_First, _Last);
; 1425 :         auto _UFirst             = _Get_unwrapped(_First);
; 1426 :         const auto _ULast        = _Get_unwrapped(_Last);
; 1427 :         _Iter_diff_t<_InIt> _Off = 0;
; 1428 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1429 :             ++_Off;
; 1430 :         }
; 1431 : 
; 1432 :         return _Off;
; 1433 :     }
; 1434 : }
; 1435 : 
; 1436 : template <class _InIt>
; 1437 : constexpr _InIt _Next_iter(_InIt _First) { // increment iterator
; 1438 :     return ++_First;
; 1439 : }
; 1440 : 
; 1441 : _EXPORT_STD template <class _InIt>
; 1442 : _NODISCARD _CONSTEXPR17 _InIt next(_InIt _First, _Iter_diff_t<_InIt> _Off = 1) { // increment iterator
; 1443 :     static_assert(_Is_ranges_input_iter_v<_InIt>, "next requires input iterator");
; 1444 : 
; 1445 :     _STD advance(_First, _Off);
; 1446 :     return _First;
; 1447 : }
; 1448 : 
; 1449 : template <class _BidIt>
; 1450 : constexpr _BidIt _Prev_iter(_BidIt _First) { // decrement iterator
; 1451 :     return --_First;
; 1452 : }
; 1453 : 
; 1454 : _EXPORT_STD template <class _BidIt>
; 1455 : _NODISCARD _CONSTEXPR17 _BidIt prev(_BidIt _First, _Iter_diff_t<_BidIt> _Off = 1) { // decrement iterator
; 1456 :     static_assert(_Is_ranges_bidi_iter_v<_BidIt>, "prev requires bidirectional iterator");
; 1457 : 
; 1458 :     _STD advance(_First, -_Off);
; 1459 :     return _First;
; 1460 : }
; 1461 : 
; 1462 : template <class _Iter, class _Pointer, bool = is_pointer_v<_Remove_cvref_t<_Iter>>>
; 1463 : _INLINE_VAR constexpr bool _Has_nothrow_operator_arrow = _Is_nothrow_convertible_v<_Iter, _Pointer>;
; 1464 : 
; 1465 : template <class _Iter, class _Pointer>
; 1466 : _INLINE_VAR constexpr bool _Has_nothrow_operator_arrow<_Iter, _Pointer, false> =
; 1467 :     noexcept(_Fake_copy_init<_Pointer>(_STD declval<_Iter>().operator->()));
; 1468 : 
; 1469 : _EXPORT_STD template <class _BidIt>
; 1470 : class reverse_iterator {
; 1471 : public:
; 1472 :     using iterator_type = _BidIt;
; 1473 : 
; 1474 : #ifdef __cpp_lib_concepts
; 1475 :     using iterator_concept =
; 1476 :         conditional_t<random_access_iterator<_BidIt>, random_access_iterator_tag, bidirectional_iterator_tag>;
; 1477 :     using iterator_category = conditional_t<derived_from<_Iter_cat_t<_BidIt>, random_access_iterator_tag>,
; 1478 :         random_access_iterator_tag, _Iter_cat_t<_BidIt>>;
; 1479 : #else // ^^^ __cpp_lib_concepts / !__cpp_lib_concepts vvv
; 1480 :     using iterator_category = _Iter_cat_t<_BidIt>;
; 1481 : #endif // __cpp_lib_concepts
; 1482 :     using value_type      = _Iter_value_t<_BidIt>;
; 1483 :     using difference_type = _Iter_diff_t<_BidIt>;
; 1484 :     using pointer         = typename iterator_traits<_BidIt>::pointer;
; 1485 :     using reference       = _Iter_ref_t<_BidIt>;
; 1486 : 
; 1487 :     template <class>
; 1488 :     friend class reverse_iterator;
; 1489 : 
; 1490 :     _CONSTEXPR17 reverse_iterator() = default;
; 1491 : 
; 1492 :     _CONSTEXPR17 explicit reverse_iterator(_BidIt _Right) noexcept(
; 1493 :         is_nothrow_move_constructible_v<_BidIt>) // strengthened
; 1494 :         : current(_STD move(_Right)) {}
; 1495 : 
; 1496 :     // clang-format off
; 1497 :     template <class _Other>
; 1498 : #ifdef __cpp_lib_concepts
; 1499 :         requires (!is_same_v<_Other, _BidIt>) && convertible_to<const _Other&, _BidIt>
; 1500 : #endif // __cpp_lib_concepts
; 1501 :     _CONSTEXPR17 reverse_iterator(const reverse_iterator<_Other>& _Right) noexcept(
; 1502 :         is_nothrow_constructible_v<_BidIt, const _Other&>) // strengthened
; 1503 :         : current(_Right.current) {}
; 1504 : 
; 1505 :     template <class _Other>
; 1506 : #ifdef __cpp_lib_concepts
; 1507 :         requires (!is_same_v<_Other, _BidIt>) && convertible_to<const _Other&, _BidIt>
; 1508 :             && assignable_from<_BidIt&, const _Other&>
; 1509 : #endif // __cpp_lib_concepts
; 1510 :     _CONSTEXPR17 reverse_iterator& operator=(const reverse_iterator<_Other>& _Right) noexcept(
; 1511 :         is_nothrow_assignable_v<_BidIt&, const _Other&>) /* strengthened */ {
; 1512 :         current = _Right.current;
; 1513 :         return *this;
; 1514 :     }
; 1515 :     // clang-format on
; 1516 : 
; 1517 :     _NODISCARD _CONSTEXPR17 _BidIt base() const noexcept(is_nothrow_copy_constructible_v<_BidIt>) /* strengthened */ {
; 1518 :         return current;
; 1519 :     }
; 1520 : 
; 1521 :     _NODISCARD _CONSTEXPR17 reference operator*() const
; 1522 :         noexcept(is_nothrow_copy_constructible_v<_BidIt>&& noexcept(*--(_STD declval<_BidIt&>()))) /* strengthened */ {
; 1523 :         _BidIt _Tmp = current;
; 1524 :         return *--_Tmp;
; 1525 :     }
; 1526 : 
; 1527 :     _NODISCARD _CONSTEXPR17 pointer operator->() const
; 1528 :         noexcept(is_nothrow_copy_constructible_v<_BidIt>&& noexcept(--(_STD declval<_BidIt&>()))
; 1529 :                  && _Has_nothrow_operator_arrow<_BidIt&, pointer>) /* strengthened */
; 1530 : #ifdef __cpp_lib_concepts
; 1531 :         requires (is_pointer_v<_BidIt> || requires(const _BidIt __i) { __i.operator->(); })
; 1532 : #endif
; 1533 :     {
; 1534 :         _BidIt _Tmp = current;
; 1535 :         --_Tmp;
; 1536 :         if constexpr (is_pointer_v<_BidIt>) {
; 1537 :             return _Tmp;
; 1538 :         } else {
; 1539 :             return _Tmp.operator->();
; 1540 :         }
; 1541 :     }
; 1542 : 
; 1543 :     _CONSTEXPR17 reverse_iterator& operator++() noexcept(noexcept(--current)) /* strengthened */ {
; 1544 :         --current;
; 1545 :         return *this;
; 1546 :     }
; 1547 : 
; 1548 :     _CONSTEXPR17 reverse_iterator operator++(int) noexcept(
; 1549 :         is_nothrow_copy_constructible_v<_BidIt>&& noexcept(--current)) /* strengthened */ {
; 1550 :         reverse_iterator _Tmp = *this;
; 1551 :         --current;
; 1552 :         return _Tmp;
; 1553 :     }
; 1554 : 
; 1555 :     _CONSTEXPR17 reverse_iterator& operator--() noexcept(noexcept(++current)) /* strengthened */ {
; 1556 :         ++current;
; 1557 :         return *this;
; 1558 :     }
; 1559 : 
; 1560 :     _CONSTEXPR17 reverse_iterator operator--(int) noexcept(
; 1561 :         is_nothrow_copy_constructible_v<_BidIt>&& noexcept(++current)) /* strengthened */ {
; 1562 :         reverse_iterator _Tmp = *this;
; 1563 :         ++current;
; 1564 :         return _Tmp;
; 1565 :     }
; 1566 : 
; 1567 :     _NODISCARD _CONSTEXPR17 reverse_iterator operator+(const difference_type _Off) const
; 1568 :         noexcept(noexcept(reverse_iterator(current - _Off))) /* strengthened */ {
; 1569 :         return reverse_iterator(current - _Off);
; 1570 :     }
; 1571 : 
; 1572 :     _CONSTEXPR17 reverse_iterator& operator+=(const difference_type _Off) noexcept(
; 1573 :         noexcept(current -= _Off)) /* strengthened */ {
; 1574 :         current -= _Off;
; 1575 :         return *this;
; 1576 :     }
; 1577 : 
; 1578 :     _NODISCARD _CONSTEXPR17 reverse_iterator operator-(const difference_type _Off) const
; 1579 :         noexcept(noexcept(reverse_iterator(current + _Off))) /* strengthened */ {
; 1580 :         return reverse_iterator(current + _Off);
; 1581 :     }
; 1582 : 
; 1583 :     _CONSTEXPR17 reverse_iterator& operator-=(const difference_type _Off) noexcept(
; 1584 :         noexcept(current += _Off)) /* strengthened */ {
; 1585 :         current += _Off;
; 1586 :         return *this;
; 1587 :     }
; 1588 : 
; 1589 :     _NODISCARD _CONSTEXPR17 reference operator[](const difference_type _Off) const
; 1590 :         noexcept(noexcept(_Fake_copy_init<reference>(current[_Off]))) /* strengthened */ {
; 1591 :         return current[static_cast<difference_type>(-_Off - 1)];
; 1592 :     }
; 1593 : 
; 1594 : #ifdef __cpp_lib_concepts
; 1595 :     _NODISCARD_FRIEND constexpr iter_rvalue_reference_t<_BidIt> iter_move(const reverse_iterator& _It) noexcept(
; 1596 :         is_nothrow_copy_constructible_v<_BidIt>&& noexcept(_RANGES iter_move(--_STD declval<_BidIt&>()))) {
; 1597 :         auto _Tmp = _It.current;
; 1598 :         --_Tmp;
; 1599 :         return _RANGES iter_move(_Tmp);
; 1600 :     }
; 1601 : 
; 1602 :     template <indirectly_swappable<_BidIt> _BidIt2>
; 1603 :     friend constexpr void iter_swap(const reverse_iterator& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
; 1604 :         is_nothrow_copy_constructible_v<_BidIt>&& is_nothrow_copy_constructible_v<_BidIt2>&& noexcept(
; 1605 :             _RANGES iter_swap(--_STD declval<_BidIt&>(), --_STD declval<_BidIt2&>()))) {
; 1606 :         auto _LTmp = _Left.current;
; 1607 :         auto _RTmp = _Right.base();
; 1608 :         --_LTmp;
; 1609 :         --_RTmp;
; 1610 :         _RANGES iter_swap(_LTmp, _RTmp);
; 1611 :     }
; 1612 : #endif // __cpp_lib_concepts
; 1613 : 
; 1614 :     using _Prevent_inheriting_unwrap = reverse_iterator;
; 1615 : 
; 1616 :     template <class _BidIt2, enable_if_t<_Range_verifiable_v<_BidIt, _BidIt2>, int> = 0>
; 1617 :     friend constexpr void _Verify_range(
; 1618 :         const reverse_iterator& _First, const reverse_iterator<_BidIt2>& _Last) noexcept {
; 1619 :         _Verify_range(_Last._Get_current(), _First.current); // note reversed parameters
; 1620 :     }
; 1621 : 
; 1622 :     template <class _BidIt2 = _BidIt, enable_if_t<_Offset_verifiable_v<_BidIt2>, int> = 0>
; 1623 :     constexpr void _Verify_offset(const difference_type _Off) const noexcept {
; 1624 :         _STL_VERIFY(_Off != _Min_possible_v<difference_type>, "integer overflow");
; 1625 :         current._Verify_offset(-_Off);
; 1626 :     }
; 1627 : 
; 1628 :     template <class _BidIt2 = _BidIt, enable_if_t<_Unwrappable_v<const _BidIt2&>, int> = 0>
; 1629 :     _NODISCARD constexpr reverse_iterator<_Unwrapped_t<const _BidIt2&>> _Unwrapped() const& noexcept(
; 1630 :         noexcept(static_cast<reverse_iterator<_Unwrapped_t<const _BidIt2&>>>(current._Unwrapped()))) {
; 1631 :         return static_cast<reverse_iterator<_Unwrapped_t<const _BidIt2&>>>(current._Unwrapped());
; 1632 :     }
; 1633 :     template <class _BidIt2 = _BidIt, enable_if_t<_Unwrappable_v<_BidIt2>, int> = 0>
; 1634 :     _NODISCARD constexpr reverse_iterator<_Unwrapped_t<_BidIt2>> _Unwrapped() && noexcept(
; 1635 :         noexcept(static_cast<reverse_iterator<_Unwrapped_t<_BidIt2>>>(_STD move(current)._Unwrapped()))) {
; 1636 :         return static_cast<reverse_iterator<_Unwrapped_t<_BidIt2>>>(_STD move(current)._Unwrapped());
; 1637 :     }
; 1638 : 
; 1639 :     static constexpr bool _Unwrap_when_unverified = _Do_unwrap_when_unverified_v<_BidIt>;
; 1640 : 
; 1641 :     template <class _Src, enable_if_t<_Wrapped_seekable_v<_BidIt, const _Src&>, int> = 0>
; 1642 :     constexpr void _Seek_to(const reverse_iterator<_Src>& _It) noexcept(noexcept(current._Seek_to(_It.current))) {
; 1643 :         current._Seek_to(_It.current);
; 1644 :     }
; 1645 : 
; 1646 :     _NODISCARD constexpr const _BidIt& _Get_current() const noexcept {
; 1647 :         return current;
; 1648 :     }
; 1649 : 
; 1650 : protected:
; 1651 :     _BidIt current{};
; 1652 : };
; 1653 : 
; 1654 : _EXPORT_STD template <class _BidIt1, class _BidIt2>
; 1655 : _NODISCARD _CONSTEXPR17 bool
; 1656 :     operator==(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
; 1657 :         noexcept(_Fake_copy_init<bool>(_Left._Get_current() == _Right._Get_current()))) /* strengthened */
; 1658 : #ifdef __cpp_lib_concepts
; 1659 :     // clang-format off
; 1660 :     requires requires {
; 1661 :         { _Left._Get_current() == _Right._Get_current() } -> _Implicitly_convertible_to<bool>;
; 1662 :     }
; 1663 : // clang-format on
; 1664 : #endif // __cpp_lib_concepts
; 1665 : {
; 1666 :     return _Left._Get_current() == _Right._Get_current();
; 1667 : }
; 1668 : 
; 1669 : _EXPORT_STD template <class _BidIt1, class _BidIt2>
; 1670 : _NODISCARD _CONSTEXPR17 bool
; 1671 :     operator!=(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
; 1672 :         noexcept(_Fake_copy_init<bool>(_Left._Get_current() != _Right._Get_current()))) /* strengthened */
; 1673 : #ifdef __cpp_lib_concepts
; 1674 :     // clang-format off
; 1675 :     requires requires {
; 1676 :         { _Left._Get_current() != _Right._Get_current() } -> _Implicitly_convertible_to<bool>;
; 1677 :     }
; 1678 : // clang-format on
; 1679 : #endif // __cpp_lib_concepts
; 1680 : {
; 1681 :     return _Left._Get_current() != _Right._Get_current();
; 1682 : }
; 1683 : 
; 1684 : _EXPORT_STD template <class _BidIt1, class _BidIt2>
; 1685 : _NODISCARD _CONSTEXPR17 bool
; 1686 :     operator<(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
; 1687 :         noexcept(_Fake_copy_init<bool>(_Left._Get_current() > _Right._Get_current()))) /* strengthened */
; 1688 : #ifdef __cpp_lib_concepts
; 1689 :     // clang-format off
; 1690 :     requires requires {
; 1691 :         { _Left._Get_current() > _Right._Get_current() } -> _Implicitly_convertible_to<bool>;
; 1692 :     }
; 1693 : // clang-format on
; 1694 : #endif // __cpp_lib_concepts
; 1695 : {
; 1696 :     return _Left._Get_current() > _Right._Get_current();
; 1697 : }
; 1698 : 
; 1699 : _EXPORT_STD template <class _BidIt1, class _BidIt2>
; 1700 : _NODISCARD _CONSTEXPR17 bool
; 1701 :     operator>(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
; 1702 :         noexcept(_Fake_copy_init<bool>(_Left._Get_current() < _Right._Get_current()))) /* strengthened */
; 1703 : #ifdef __cpp_lib_concepts
; 1704 :     // clang-format off
; 1705 :     requires requires {
; 1706 :         { _Left._Get_current() < _Right._Get_current() } -> _Implicitly_convertible_to<bool>;
; 1707 :     }
; 1708 : // clang-format on
; 1709 : #endif // __cpp_lib_concepts
; 1710 : {
; 1711 :     return _Left._Get_current() < _Right._Get_current();
; 1712 : }
; 1713 : 
; 1714 : _EXPORT_STD template <class _BidIt1, class _BidIt2>
; 1715 : _NODISCARD _CONSTEXPR17 bool
; 1716 :     operator<=(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
; 1717 :         noexcept(_Fake_copy_init<bool>(_Left._Get_current() >= _Right._Get_current()))) /* strengthened */
; 1718 : #ifdef __cpp_lib_concepts
; 1719 :     // clang-format off
; 1720 :     requires requires {
; 1721 :         { _Left._Get_current() >= _Right._Get_current() } -> _Implicitly_convertible_to<bool>;
; 1722 :     }
; 1723 : // clang-format on
; 1724 : #endif // __cpp_lib_concepts
; 1725 : {
; 1726 :     return _Left._Get_current() >= _Right._Get_current();
; 1727 : }
; 1728 : 
; 1729 : _EXPORT_STD template <class _BidIt1, class _BidIt2>
; 1730 : _NODISCARD _CONSTEXPR17 bool
; 1731 :     operator>=(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
; 1732 :         noexcept(_Fake_copy_init<bool>(_Left._Get_current() <= _Right._Get_current()))) /* strengthened */
; 1733 : #ifdef __cpp_lib_concepts
; 1734 :     // clang-format off
; 1735 :     requires requires {
; 1736 :         { _Left._Get_current() <= _Right._Get_current() } -> _Implicitly_convertible_to<bool>;
; 1737 :     }
; 1738 : // clang-format on
; 1739 : #endif // __cpp_lib_concepts
; 1740 : {
; 1741 :     return _Left._Get_current() <= _Right._Get_current();
; 1742 : }
; 1743 : 
; 1744 : #ifdef __cpp_lib_concepts
; 1745 : _EXPORT_STD template <class _BidIt1, three_way_comparable_with<_BidIt1> _BidIt2>
; 1746 : _NODISCARD constexpr compare_three_way_result_t<_BidIt1, _BidIt2>
; 1747 :     operator<=>(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
; 1748 :         noexcept(_Right._Get_current() <=> _Left._Get_current())) /* strengthened */ {
; 1749 :     return _Right._Get_current() <=> _Left._Get_current();
; 1750 : }
; 1751 : #endif // __cpp_lib_concepts
; 1752 : 
; 1753 : _EXPORT_STD template <class _BidIt1, class _BidIt2>
; 1754 : _NODISCARD _CONSTEXPR17 auto
; 1755 :     operator-(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
; 1756 :         noexcept(_Right._Get_current() - _Left._Get_current())) /* strengthened */
; 1757 :     -> decltype(_Right._Get_current() - _Left._Get_current()) {
; 1758 :     return _Right._Get_current() - _Left._Get_current();
; 1759 : }
; 1760 : 
; 1761 : _EXPORT_STD template <class _BidIt>
; 1762 : _NODISCARD _CONSTEXPR17 reverse_iterator<_BidIt> operator+(typename reverse_iterator<_BidIt>::difference_type _Off,
; 1763 :     const reverse_iterator<_BidIt>& _Right) noexcept(noexcept(_Right + _Off)) /* strengthened */ {
; 1764 :     return _Right + _Off;
; 1765 : }
; 1766 : 
; 1767 : _EXPORT_STD template <class _BidIt>
; 1768 : _NODISCARD _CONSTEXPR17 reverse_iterator<_BidIt> make_reverse_iterator(_BidIt _Iter) noexcept(
; 1769 :     is_nothrow_move_constructible_v<_BidIt>) /* strengthened */ {
; 1770 :     return reverse_iterator<_BidIt>(_STD move(_Iter));
; 1771 : }
; 1772 : 
; 1773 : #ifdef __cpp_lib_concepts
; 1774 : template <class _BidIt1, class _BidIt2>
; 1775 :     requires (!sized_sentinel_for<_BidIt1, _BidIt2>)
; 1776 : inline constexpr bool disable_sized_sentinel_for<reverse_iterator<_BidIt1>, reverse_iterator<_BidIt2>> = true;
; 1777 : #endif // __cpp_lib_concepts
; 1778 : 
; 1779 : _EXPORT_STD template <class _Container>
; 1780 : _NODISCARD _CONSTEXPR17 auto begin(_Container& _Cont) noexcept(noexcept(_Cont.begin())) /* strengthened */
; 1781 :     -> decltype(_Cont.begin()) {
; 1782 :     return _Cont.begin();
; 1783 : }
; 1784 : 
; 1785 : _EXPORT_STD template <class _Container>
; 1786 : _NODISCARD _CONSTEXPR17 auto begin(const _Container& _Cont) noexcept(noexcept(_Cont.begin())) /* strengthened */
; 1787 :     -> decltype(_Cont.begin()) {
; 1788 :     return _Cont.begin();
; 1789 : }
; 1790 : 
; 1791 : _EXPORT_STD template <class _Container>
; 1792 : _NODISCARD _CONSTEXPR17 auto end(_Container& _Cont) noexcept(noexcept(_Cont.end())) /* strengthened */
; 1793 :     -> decltype(_Cont.end()) {
; 1794 :     return _Cont.end();
; 1795 : }
; 1796 : 
; 1797 : _EXPORT_STD template <class _Container>
; 1798 : _NODISCARD _CONSTEXPR17 auto end(const _Container& _Cont) noexcept(noexcept(_Cont.end())) /* strengthened */
; 1799 :     -> decltype(_Cont.end()) {
; 1800 :     return _Cont.end();
; 1801 : }
; 1802 : 
; 1803 : _EXPORT_STD template <class _Ty, size_t _Size>
; 1804 : _NODISCARD constexpr _Ty* begin(_Ty (&_Array)[_Size]) noexcept {
; 1805 :     return _Array;
; 1806 : }
; 1807 : 
; 1808 : _EXPORT_STD template <class _Ty, size_t _Size>
; 1809 : _NODISCARD constexpr _Ty* end(_Ty (&_Array)[_Size]) noexcept {
; 1810 :     return _Array + _Size;
; 1811 : }
; 1812 : 
; 1813 : _EXPORT_STD template <class _Container>
; 1814 : _NODISCARD constexpr auto cbegin(const _Container& _Cont) noexcept(noexcept(_STD begin(_Cont)))
; 1815 :     -> decltype(_STD begin(_Cont)) {
; 1816 :     return _STD begin(_Cont);
; 1817 : }
; 1818 : 
; 1819 : _EXPORT_STD template <class _Container>
; 1820 : _NODISCARD constexpr auto cend(const _Container& _Cont) noexcept(noexcept(_STD end(_Cont)))
; 1821 :     -> decltype(_STD end(_Cont)) {
; 1822 :     return _STD end(_Cont);
; 1823 : }
; 1824 : 
; 1825 : _EXPORT_STD template <class _Container>
; 1826 : _NODISCARD _CONSTEXPR17 auto rbegin(_Container& _Cont) noexcept(noexcept(_Cont.rbegin())) /* strengthened */
; 1827 :     -> decltype(_Cont.rbegin()) {
; 1828 :     return _Cont.rbegin();
; 1829 : }
; 1830 : 
; 1831 : _EXPORT_STD template <class _Container>
; 1832 : _NODISCARD _CONSTEXPR17 auto rbegin(const _Container& _Cont) noexcept(noexcept(_Cont.rbegin())) /* strengthened */
; 1833 :     -> decltype(_Cont.rbegin()) {
; 1834 :     return _Cont.rbegin();
; 1835 : }
; 1836 : 
; 1837 : _EXPORT_STD template <class _Container>
; 1838 : _NODISCARD _CONSTEXPR17 auto rend(_Container& _Cont) noexcept(noexcept(_Cont.rend())) /* strengthened */
; 1839 :     -> decltype(_Cont.rend()) {
; 1840 :     return _Cont.rend();
; 1841 : }
; 1842 : 
; 1843 : _EXPORT_STD template <class _Container>
; 1844 : _NODISCARD _CONSTEXPR17 auto rend(const _Container& _Cont) noexcept(noexcept(_Cont.rend())) /* strengthened */
; 1845 :     -> decltype(_Cont.rend()) {
; 1846 :     return _Cont.rend();
; 1847 : }
; 1848 : 
; 1849 : _EXPORT_STD template <class _Ty, size_t _Size>
; 1850 : _NODISCARD _CONSTEXPR17 reverse_iterator<_Ty*> rbegin(_Ty (&_Array)[_Size]) noexcept /* strengthened */ {
; 1851 :     return reverse_iterator<_Ty*>(_Array + _Size);
; 1852 : }
; 1853 : 
; 1854 : _EXPORT_STD template <class _Ty, size_t _Size>
; 1855 : _NODISCARD _CONSTEXPR17 reverse_iterator<_Ty*> rend(_Ty (&_Array)[_Size]) noexcept /* strengthened */ {
; 1856 :     return reverse_iterator<_Ty*>(_Array);
; 1857 : }
; 1858 : 
; 1859 : _EXPORT_STD template <class _Elem>
; 1860 : _NODISCARD _CONSTEXPR17 reverse_iterator<const _Elem*> rbegin(initializer_list<_Elem> _Ilist) noexcept
; 1861 : /* strengthened */ {
; 1862 :     return reverse_iterator<const _Elem*>(_Ilist.end());
; 1863 : }
; 1864 : 
; 1865 : _EXPORT_STD template <class _Elem>
; 1866 : _NODISCARD _CONSTEXPR17 reverse_iterator<const _Elem*> rend(initializer_list<_Elem> _Ilist) noexcept
; 1867 : /* strengthened */ {
; 1868 :     return reverse_iterator<const _Elem*>(_Ilist.begin());
; 1869 : }
; 1870 : 
; 1871 : _EXPORT_STD template <class _Container>
; 1872 : _NODISCARD _CONSTEXPR17 auto crbegin(const _Container& _Cont) noexcept(noexcept(_STD rbegin(_Cont))) /* strengthened */
; 1873 :     -> decltype(_STD rbegin(_Cont)) {
; 1874 :     return _STD rbegin(_Cont);
; 1875 : }
; 1876 : 
; 1877 : _EXPORT_STD template <class _Container>
; 1878 : _NODISCARD _CONSTEXPR17 auto crend(const _Container& _Cont) noexcept(noexcept(_STD rend(_Cont))) /* strengthened */
; 1879 :     -> decltype(_STD rend(_Cont)) {
; 1880 :     return _STD rend(_Cont);
; 1881 : }
; 1882 : 
; 1883 : _EXPORT_STD template <class _Container>
; 1884 : _NODISCARD constexpr auto size(const _Container& _Cont) noexcept(noexcept(_Cont.size())) /* strengthened */
; 1885 :     -> decltype(_Cont.size()) {
; 1886 :     return _Cont.size();
; 1887 : }
; 1888 : 
; 1889 : _EXPORT_STD template <class _Ty, size_t _Size>
; 1890 : _NODISCARD constexpr size_t size(const _Ty (&)[_Size]) noexcept {
; 1891 :     return _Size;
; 1892 : }
; 1893 : 
; 1894 : #if _HAS_CXX20
; 1895 : _EXPORT_STD template <class _Container>
; 1896 : _NODISCARD constexpr auto ssize(const _Container& _Cont) noexcept(noexcept(
; 1897 :     static_cast<common_type_t<ptrdiff_t, make_signed_t<decltype(_Cont.size())>>>(_Cont.size()))) /* strengthened */
; 1898 :     -> common_type_t<ptrdiff_t, make_signed_t<decltype(_Cont.size())>> {
; 1899 :     using _Common = common_type_t<ptrdiff_t, make_signed_t<decltype(_Cont.size())>>;
; 1900 :     return static_cast<_Common>(_Cont.size());
; 1901 : }
; 1902 : 
; 1903 : _EXPORT_STD template <class _Ty, ptrdiff_t _Size>
; 1904 : _NODISCARD constexpr ptrdiff_t ssize(const _Ty (&)[_Size]) noexcept {
; 1905 :     return _Size;
; 1906 : }
; 1907 : #endif // _HAS_CXX20
; 1908 : 
; 1909 : _EXPORT_STD template <class _Container>
; 1910 : _NODISCARD_EMPTY_NON_MEMBER constexpr auto empty(const _Container& _Cont) noexcept(
; 1911 :     noexcept(_Cont.empty())) /* strengthened */
; 1912 :     -> decltype(_Cont.empty()) {
; 1913 :     return _Cont.empty();
; 1914 : }
; 1915 : 
; 1916 : _EXPORT_STD template <class _Ty, size_t _Size>
; 1917 : _NODISCARD_EMPTY_NON_MEMBER constexpr bool empty(const _Ty (&)[_Size]) noexcept {
; 1918 :     return false;
; 1919 : }
; 1920 : 
; 1921 : _EXPORT_STD template <class _Elem>
; 1922 : _NODISCARD_EMPTY_NON_MEMBER constexpr bool empty(initializer_list<_Elem> _Ilist) noexcept {
; 1923 :     return _Ilist.size() == 0;
; 1924 : }
; 1925 : 
; 1926 : _EXPORT_STD template <class _Container>
; 1927 : _NODISCARD constexpr auto data(_Container& _Cont) noexcept(noexcept(_Cont.data())) /* strengthened */
; 1928 :     -> decltype(_Cont.data()) {
; 1929 :     return _Cont.data();
; 1930 : }
; 1931 : 
; 1932 : _EXPORT_STD template <class _Container>
; 1933 : _NODISCARD constexpr auto data(const _Container& _Cont) noexcept(noexcept(_Cont.data())) /* strengthened */
; 1934 :     -> decltype(_Cont.data()) {
; 1935 :     return _Cont.data();
; 1936 : }
; 1937 : 
; 1938 : _EXPORT_STD template <class _Ty, size_t _Size>
; 1939 : _NODISCARD constexpr _Ty* data(_Ty (&_Array)[_Size]) noexcept {
; 1940 :     return _Array;
; 1941 : }
; 1942 : 
; 1943 : _EXPORT_STD template <class _Elem>
; 1944 : _NODISCARD constexpr const _Elem* data(initializer_list<_Elem> _Ilist) noexcept {
; 1945 :     return _Ilist.begin();
; 1946 : }
; 1947 : 
; 1948 : #ifdef __cpp_lib_concepts
; 1949 : #if _HAS_CXX23
; 1950 : _EXPORT_STD template <indirectly_readable _Ty>
; 1951 : using iter_const_reference_t = common_reference_t<const iter_value_t<_Ty>&&, iter_reference_t<_Ty>>;
; 1952 : 
; 1953 : template <indirectly_readable _Iter>
; 1954 : using _Iter_const_rvalue_reference_t = common_reference_t<const iter_value_t<_Iter>&&, iter_rvalue_reference_t<_Iter>>;
; 1955 : 
; 1956 : template <class _Ty>
; 1957 : concept _Constant_iterator = input_iterator<_Ty> && same_as<iter_const_reference_t<_Ty>, iter_reference_t<_Ty>>;
; 1958 : 
; 1959 : _EXPORT_STD template <input_iterator _Iter>
; 1960 : class basic_const_iterator;
; 1961 : 
; 1962 : _EXPORT_STD template <input_iterator _Iter>
; 1963 : using const_iterator = conditional_t<_Constant_iterator<_Iter>, _Iter, basic_const_iterator<_Iter>>;
; 1964 : 
; 1965 : template <class _Sent>
; 1966 : struct _Const_sentinel {
; 1967 :     using type = _Sent;
; 1968 : };
; 1969 : 
; 1970 : template <input_iterator _Sent>
; 1971 : struct _Const_sentinel<_Sent> {
; 1972 :     using type = const_iterator<_Sent>;
; 1973 : };
; 1974 : 
; 1975 : _EXPORT_STD template <semiregular _Sent>
; 1976 : using const_sentinel = typename _Const_sentinel<_Sent>::type;
; 1977 : 
; 1978 : // clang-format off
; 1979 : template <class _Ty>
; 1980 : concept _Not_a_const_iterator = !_Is_specialization_v<_Ty, basic_const_iterator>;
; 1981 : // clang-format on
; 1982 : 
; 1983 : template <class>
; 1984 : struct _Basic_const_iterator_category {};
; 1985 : 
; 1986 : template <forward_iterator _Iter>
; 1987 : struct _Basic_const_iterator_category<_Iter> {
; 1988 :     using iterator_category = typename iterator_traits<_Iter>::iterator_category;
; 1989 : };
; 1990 : 
; 1991 : // TRANSITION, LLVM-55945: These are distinct concepts as a workaround
; 1992 : template <class _Ty, class _Iter>
; 1993 : concept _Bci_order = _Different_from<_Ty, basic_const_iterator<_Iter>> && random_access_iterator<_Iter>
; 1994 :                   && totally_ordered_with<_Iter, _Ty>;
; 1995 : 
; 1996 : template <class _Ty, class _Iter>
; 1997 : concept _Bci_order_3way = _Bci_order<_Ty, _Iter> && three_way_comparable_with<_Iter, _Ty>;
; 1998 : 
; 1999 : template <class _Ty, class _Iter>
; 2000 : concept _Not_bci_order =
; 2001 :     _Not_a_const_iterator<_Ty> && random_access_iterator<_Iter> && totally_ordered_with<_Iter, _Ty>;
; 2002 : 
; 2003 : _EXPORT_STD template <input_iterator _Iter>
; 2004 : class basic_const_iterator : public _Basic_const_iterator_category<_Iter> {
; 2005 : private:
; 2006 :     /* [[no_unique_address]] */ _Iter _Current{};
; 2007 : 
; 2008 :     using _Reference        = iter_const_reference_t<_Iter>;
; 2009 :     using _Rvalue_reference = _Iter_const_rvalue_reference_t<_Iter>;
; 2010 : 
; 2011 :     _NODISCARD static consteval auto _Get_iter_concept() noexcept {
; 2012 :         if constexpr (contiguous_iterator<_Iter>) {
; 2013 :             return contiguous_iterator_tag{};
; 2014 :         } else if constexpr (random_access_iterator<_Iter>) {
; 2015 :             return random_access_iterator_tag{};
; 2016 :         } else if constexpr (bidirectional_iterator<_Iter>) {
; 2017 :             return bidirectional_iterator_tag{};
; 2018 :         } else if constexpr (forward_iterator<_Iter>) {
; 2019 :             return forward_iterator_tag{};
; 2020 :         } else {
; 2021 :             return input_iterator_tag{};
; 2022 :         }
; 2023 :     }
; 2024 : 
; 2025 : public:
; 2026 :     using iterator_concept = decltype(_Get_iter_concept());
; 2027 :     using value_type       = iter_value_t<_Iter>;
; 2028 :     using difference_type  = iter_difference_t<_Iter>;
; 2029 : 
; 2030 :     // clang-format off
; 2031 :     basic_const_iterator() requires default_initializable<_Iter> = default;
; 2032 :     // clang-format on
; 2033 : 
; 2034 :     constexpr basic_const_iterator(_Iter _Current_) noexcept(is_nothrow_move_constructible_v<_Iter>) // strengthened
; 2035 :         : _Current(_STD move(_Current_)) {}
; 2036 : 
; 2037 :     template <convertible_to<_Iter> _Other>
; 2038 :     constexpr basic_const_iterator(basic_const_iterator<_Other> _Current_) noexcept(
; 2039 :         is_nothrow_constructible_v<_Iter, _Other>) // strengthened
; 2040 :         : _Current(_STD move(_Current_._Current)) {}
; 2041 : 
; 2042 :     template <_Different_from<basic_const_iterator> _Other>
; 2043 :         requires convertible_to<_Other, _Iter>
; 2044 :     constexpr basic_const_iterator(_Other&& _Current_) noexcept(
; 2045 :         is_nothrow_constructible_v<_Iter, _Other>) // strengthened
; 2046 :         : _Current(_STD forward<_Other>(_Current_)) {}
; 2047 : 
; 2048 :     _NODISCARD constexpr const _Iter& base() const& noexcept {
; 2049 :         return _Current;
; 2050 :     }
; 2051 : 
; 2052 :     _NODISCARD constexpr _Iter base() && noexcept(is_nothrow_move_constructible_v<_Iter>) /* strengthened */ {
; 2053 :         return _STD move(_Current);
; 2054 :     }
; 2055 : 
; 2056 :     _NODISCARD constexpr _Reference operator*() const
; 2057 :         noexcept(noexcept(static_cast<_Reference>(*_Current))) /* strengthened */ {
; 2058 :         return static_cast<_Reference>(*_Current);
; 2059 :     }
; 2060 : 
; 2061 :     _NODISCARD constexpr const auto* operator->() const
; 2062 :         noexcept(contiguous_iterator<_Iter> || noexcept(*_Current)) /* strengthened */
; 2063 :         requires is_lvalue_reference_v<iter_reference_t<_Iter>>
; 2064 :               && same_as<remove_cvref_t<iter_reference_t<_Iter>>, value_type>
; 2065 :     {
; 2066 :         if constexpr (contiguous_iterator<_Iter>) {
; 2067 :             return _STD to_address(_Current);
; 2068 :         } else {
; 2069 :             return _STD addressof(*_Current);
; 2070 :         }
; 2071 :     }
; 2072 : 
; 2073 :     constexpr basic_const_iterator& operator++() noexcept(noexcept(++_Current)) /* strengthened */ {
; 2074 :         ++_Current;
; 2075 :         return *this;
; 2076 :     }
; 2077 : 
; 2078 :     constexpr void operator++(int) noexcept(noexcept(++_Current)) /* strengthened */ {
; 2079 :         ++_Current;
; 2080 :     }
; 2081 : 
; 2082 :     constexpr basic_const_iterator operator++(int) noexcept(
; 2083 :         noexcept(++*this) && is_nothrow_copy_constructible_v<basic_const_iterator>) // strengthened
; 2084 :         requires forward_iterator<_Iter>
; 2085 :     {
; 2086 :         auto _Tmp = *this;
; 2087 :         ++*this;
; 2088 :         return _Tmp;
; 2089 :     }
; 2090 : 
; 2091 :     constexpr basic_const_iterator& operator--() noexcept(noexcept(--_Current)) // strengthened
; 2092 :         requires bidirectional_iterator<_Iter>
; 2093 :     {
; 2094 :         --_Current;
; 2095 :         return *this;
; 2096 :     }
; 2097 : 
; 2098 :     constexpr basic_const_iterator operator--(int) noexcept(
; 2099 :         noexcept(--*this) && is_nothrow_copy_constructible_v<basic_const_iterator>) // strengthened
; 2100 :         requires bidirectional_iterator<_Iter>
; 2101 :     {
; 2102 :         auto _Tmp = *this;
; 2103 :         --*this;
; 2104 :         return _Tmp;
; 2105 :     }
; 2106 : 
; 2107 :     constexpr basic_const_iterator& operator+=(const difference_type _Off) noexcept(
; 2108 :         noexcept(_Current += _Off)) // strengthened
; 2109 :         requires random_access_iterator<_Iter>
; 2110 :     {
; 2111 :         _Current += _Off;
; 2112 :         return *this;
; 2113 :     }
; 2114 : 
; 2115 :     constexpr basic_const_iterator& operator-=(const difference_type _Off) noexcept(
; 2116 :         noexcept(_Current -= _Off)) // strengthened
; 2117 :         requires random_access_iterator<_Iter>
; 2118 :     {
; 2119 :         _Current -= _Off;
; 2120 :         return *this;
; 2121 :     }
; 2122 : 
; 2123 :     _NODISCARD constexpr _Reference operator[](const difference_type _Idx) const
; 2124 :         noexcept(noexcept(static_cast<_Reference>(_Current[_Idx]))) // strengthened
; 2125 :         requires random_access_iterator<_Iter>
; 2126 :     {
; 2127 :         return static_cast<_Reference>(_Current[_Idx]);
; 2128 :     }
; 2129 : 
; 2130 :     template <sentinel_for<_Iter> _Sent>
; 2131 :     _NODISCARD constexpr bool operator==(const _Sent& _Se) const
; 2132 :         noexcept(noexcept(_Fake_copy_init<bool>(_Current == _Se))) /* strengthened */ {
; 2133 :         return _Current == _Se;
; 2134 :     }
; 2135 : 
; 2136 :     _NODISCARD constexpr bool operator<(const basic_const_iterator& _Right) const
; 2137 :         noexcept(noexcept(_Fake_copy_init<bool>(_Current < _Right._Current))) // strengthened
; 2138 :         requires random_access_iterator<_Iter>
; 2139 :     {
; 2140 :         return _Current < _Right._Current;
; 2141 :     }
; 2142 : 
; 2143 :     _NODISCARD constexpr bool operator>(const basic_const_iterator& _Right) const
; 2144 :         noexcept(noexcept(_Fake_copy_init<bool>(_Current > _Right._Current))) // strengthened
; 2145 :         requires random_access_iterator<_Iter>
; 2146 :     {
; 2147 :         return _Current > _Right._Current;
; 2148 :     }
; 2149 : 
; 2150 :     _NODISCARD constexpr bool operator<=(const basic_const_iterator& _Right) const
; 2151 :         noexcept(noexcept(_Fake_copy_init<bool>(_Current <= _Right._Current))) // strengthened
; 2152 :         requires random_access_iterator<_Iter>
; 2153 :     {
; 2154 :         return _Current <= _Right._Current;
; 2155 :     }
; 2156 : 
; 2157 :     _NODISCARD constexpr bool operator>=(const basic_const_iterator& _Right) const
; 2158 :         noexcept(noexcept(_Fake_copy_init<bool>(_Current >= _Right._Current))) // strengthened
; 2159 :         requires random_access_iterator<_Iter>
; 2160 :     {
; 2161 :         return _Current >= _Right._Current;
; 2162 :     }
; 2163 : 
; 2164 :     _NODISCARD constexpr auto operator<=>(const basic_const_iterator& _Right) const
; 2165 :         noexcept(noexcept(_Current <=> _Right._Current)) // strengthened
; 2166 :         requires random_access_iterator<_Iter> && three_way_comparable<_Iter>
; 2167 :     {
; 2168 :         return _Current <=> _Right._Current;
; 2169 :     }
; 2170 : 
; 2171 :     template <_Bci_order<_Iter> _Other>
; 2172 :     _NODISCARD constexpr bool operator<(const _Other& _Right) const
; 2173 :         noexcept(noexcept(_Fake_copy_init<bool>(_Current < _Right))) /* strengthened */ {
; 2174 :         return _Current < _Right;
; 2175 :     }
; 2176 : 
; 2177 :     template <_Bci_order<_Iter> _Other>
; 2178 :     _NODISCARD constexpr bool operator>(const _Other& _Right) const
; 2179 :         noexcept(noexcept(_Fake_copy_init<bool>(_Current > _Right))) /* strengthened */ {
; 2180 :         return _Current > _Right;
; 2181 :     }
; 2182 : 
; 2183 :     template <_Bci_order<_Iter> _Other>
; 2184 :     _NODISCARD constexpr bool operator<=(const _Other& _Right) const
; 2185 :         noexcept(noexcept(_Fake_copy_init<bool>(_Current <= _Right))) /* strengthened */ {
; 2186 :         return _Current <= _Right;
; 2187 :     }
; 2188 : 
; 2189 :     template <_Bci_order<_Iter> _Other>
; 2190 :     _NODISCARD constexpr bool operator>=(const _Other& _Right) const
; 2191 :         noexcept(noexcept(_Fake_copy_init<bool>(_Current >= _Right))) /* strengthened */ {
; 2192 :         return _Current >= _Right;
; 2193 :     }
; 2194 : 
; 2195 :     template <_Bci_order_3way<_Iter> _Other>
; 2196 :     _NODISCARD constexpr auto operator<=>(const _Other& _Right) const
; 2197 :         noexcept(noexcept(_Current <=> _Right)) /* strengthened */ {
; 2198 :         return _Current <=> _Right;
; 2199 :     }
; 2200 : 
; 2201 :     template <_Not_bci_order<_Iter> _Other>
; 2202 :     _NODISCARD_FRIEND constexpr bool operator<(const _Other& _Left, const basic_const_iterator& _Right) noexcept(
; 2203 :         noexcept(_Fake_copy_init<bool>(_Left < _Right._Current))) /* strengthened */ {
; 2204 :         return _Left < _Right._Current;
; 2205 :     }
; 2206 : 
; 2207 :     template <_Not_bci_order<_Iter> _Other>
; 2208 :     _NODISCARD_FRIEND constexpr bool operator>(const _Other& _Left, const basic_const_iterator& _Right) noexcept(
; 2209 :         noexcept(_Fake_copy_init<bool>(_Left > _Right._Current))) /* strengthened */ {
; 2210 :         return _Left > _Right._Current;
; 2211 :     }
; 2212 : 
; 2213 :     template <_Not_bci_order<_Iter> _Other>
; 2214 :     _NODISCARD_FRIEND constexpr bool operator<=(const _Other& _Left, const basic_const_iterator& _Right) noexcept(
; 2215 :         noexcept(_Fake_copy_init<bool>(_Left <= _Right._Current))) /* strengthened */ {
; 2216 :         return _Left <= _Right._Current;
; 2217 :     }
; 2218 : 
; 2219 :     template <_Not_bci_order<_Iter> _Other>
; 2220 :     _NODISCARD_FRIEND constexpr bool operator>=(const _Other& _Left, const basic_const_iterator& _Right) noexcept(
; 2221 :         noexcept(_Fake_copy_init<bool>(_Left >= _Right._Current))) /* strengthened */ {
; 2222 :         return _Left >= _Right._Current;
; 2223 :     }
; 2224 : 
; 2225 :     _NODISCARD_FRIEND constexpr basic_const_iterator operator+(const basic_const_iterator& _It,
; 2226 :         const difference_type _Off) noexcept(noexcept(basic_const_iterator{_It._Current + _Off})) // strengthened
; 2227 :         requires random_access_iterator<_Iter>
; 2228 :     {
; 2229 :         return basic_const_iterator{_It._Current + _Off};
; 2230 :     }
; 2231 : 
; 2232 :     _NODISCARD_FRIEND constexpr basic_const_iterator operator+(const difference_type _Off,
; 2233 :         const basic_const_iterator& _It) noexcept(noexcept(basic_const_iterator{_It._Current + _Off})) // strengthened
; 2234 :         requires random_access_iterator<_Iter>
; 2235 :     {
; 2236 :         return basic_const_iterator{_It._Current + _Off};
; 2237 :     }
; 2238 : 
; 2239 :     _NODISCARD_FRIEND constexpr basic_const_iterator operator-(const basic_const_iterator& _It,
; 2240 :         const difference_type _Off) noexcept(noexcept(basic_const_iterator{_It._Current - _Off})) // strengthened
; 2241 :         requires random_access_iterator<_Iter>
; 2242 :     {
; 2243 :         return basic_const_iterator{_It._Current - _Off};
; 2244 :     }
; 2245 : 
; 2246 :     template <sized_sentinel_for<_Iter> _Sent>
; 2247 :     _NODISCARD constexpr difference_type operator-(const _Sent& _Se) const
; 2248 :         noexcept(noexcept(_Current - _Se)) /* strengthened */ {
; 2249 :         return _Current - _Se;
; 2250 :     }
; 2251 : 
; 2252 :     template <_Not_a_const_iterator _Sent>
; 2253 :         requires sized_sentinel_for<_Sent, _Iter>
; 2254 :     _NODISCARD_FRIEND constexpr difference_type operator-(const _Sent& _Se, const basic_const_iterator& _It) noexcept(
; 2255 :         noexcept(_Se - _It._Current)) /* strengthened */ {
; 2256 :         return _Se - _It._Current;
; 2257 :     }
; 2258 : 
; 2259 :     _NODISCARD_FRIEND constexpr _Rvalue_reference iter_move(const basic_const_iterator& _It) noexcept(
; 2260 :         noexcept(static_cast<_Rvalue_reference>(_RANGES iter_move(_It._Current)))) {
; 2261 :         return static_cast<_Rvalue_reference>(_RANGES iter_move(_It._Current));
; 2262 :     }
; 2263 : };
; 2264 : 
; 2265 : template <class _Ty1, common_with<_Ty1> _Ty2>
; 2266 :     requires input_iterator<common_type_t<_Ty1, _Ty2>>
; 2267 : struct common_type<basic_const_iterator<_Ty1>, _Ty2> {
; 2268 :     using type = basic_const_iterator<common_type_t<_Ty1, _Ty2>>;
; 2269 : };
; 2270 : 
; 2271 : template <class _Ty1, common_with<_Ty1> _Ty2>
; 2272 :     requires input_iterator<common_type_t<_Ty1, _Ty2>>
; 2273 : struct common_type<_Ty2, basic_const_iterator<_Ty1>> {
; 2274 :     using type = basic_const_iterator<common_type_t<_Ty1, _Ty2>>;
; 2275 : };
; 2276 : 
; 2277 : template <class _Ty1, common_with<_Ty1> _Ty2>
; 2278 :     requires input_iterator<common_type_t<_Ty1, _Ty2>>
; 2279 : struct common_type<basic_const_iterator<_Ty1>, basic_const_iterator<_Ty2>> {
; 2280 :     using type = basic_const_iterator<common_type_t<_Ty1, _Ty2>>;
; 2281 : };
; 2282 : 
; 2283 : _EXPORT_STD template <input_iterator _Iter>
; 2284 : _NODISCARD constexpr const_iterator<_Iter> make_const_iterator(_Iter _It) noexcept(
; 2285 :     is_nothrow_constructible_v<const_iterator<_Iter>, _Iter&>) /* strengthened */ {
; 2286 :     return _It;
; 2287 : }
; 2288 : 
; 2289 : _EXPORT_STD template <semiregular _Sent>
; 2290 : _NODISCARD constexpr const_sentinel<_Sent> make_const_sentinel(_Sent _Se) noexcept(
; 2291 :     is_nothrow_constructible_v<const_sentinel<_Sent>, _Sent&>) /* strengthened */ {
; 2292 :     return _Se;
; 2293 : }
; 2294 : #endif // _HAS_CXX23
; 2295 : 
; 2296 : namespace ranges {
; 2297 :     template <class>
; 2298 :     inline constexpr bool _Has_complete_elements = false;
; 2299 : 
; 2300 :     template <class _Ty>
; 2301 :         requires requires(_Ty& __t) { sizeof(__t[0]); }
; 2302 :     inline constexpr bool _Has_complete_elements<_Ty> = true;
; 2303 : 
; 2304 :     _EXPORT_STD template <class>
; 2305 :     inline constexpr bool enable_borrowed_range = false;
; 2306 : 
; 2307 :     template <class _Rng>
; 2308 :     concept _Should_range_access = is_lvalue_reference_v<_Rng> || enable_borrowed_range<remove_cvref_t<_Rng>>;
; 2309 : 
; 2310 :     namespace _Begin {
; 2311 : #if defined(__clang__) || defined(__EDG__) // TRANSITION, VSO-1681199
; 2312 :         void begin() = delete; // Block unqualified name lookup
; 2313 : #else // ^^^ no workaround / workaround vvv
; 2314 :         void begin();
; 2315 : #endif // ^^^ workaround ^^^
; 2316 : 
; 2317 :         template <class _Ty>
; 2318 :         concept _Has_member = requires(_Ty __t) {
; 2319 :             { _Fake_copy_init(__t.begin()) } -> input_or_output_iterator;
; 2320 :         };
; 2321 : 
; 2322 :         template <class _Ty>
; 2323 :         concept _Has_ADL = _Has_class_or_enum_type<_Ty> //
; 2324 :                         && requires(_Ty __t) {
; 2325 :                                { _Fake_copy_init(begin(__t)) } -> input_or_output_iterator; // intentional ADL
; 2326 :                            };
; 2327 : 
; 2328 :         class _Cpo {
; 2329 :         private:
; 2330 :             enum class _St { _None, _Array, _Member, _Non_member };
; 2331 : 
; 2332 :             template <class _Ty>
; 2333 :             _NODISCARD static consteval _Choice_t<_St> _Choose() noexcept {
; 2334 :                 _STL_INTERNAL_STATIC_ASSERT(is_lvalue_reference_v<_Ty>);
; 2335 :                 if constexpr (is_array_v<remove_reference_t<_Ty>>) {
; 2336 :                     static_assert(_Has_complete_elements<_Ty>,
; 2337 :                         "The range access customization point objects "
; 2338 :                         "std::ranges::begin, std::ranges::end, std::ranges::rbegin, std::ranges::rend, "
; 2339 :                         "and std::ranges::data do not accept arrays with incomplete element types.");
; 2340 :                     return {_St::_Array, true};
; 2341 :                 } else if constexpr (_Has_member<_Ty>) {
; 2342 :                     return {_St::_Member, noexcept(_Fake_copy_init(_STD declval<_Ty>().begin()))};
; 2343 :                 } else if constexpr (_Has_ADL<_Ty>) {
; 2344 :                     return {_St::_Non_member, noexcept(_Fake_copy_init(begin(_STD declval<_Ty>())))}; // intentional ADL
; 2345 :                 } else {
; 2346 :                     return {_St::_None};
; 2347 :                 }
; 2348 :             }
; 2349 : 
; 2350 :             template <class _Ty>
; 2351 :             static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();
; 2352 : 
; 2353 :         public:
; 2354 :             template <_Should_range_access _Ty>
; 2355 :                 requires (_Choice<_Ty&>._Strategy != _St::_None)
; 2356 :             _NODISCARD constexpr auto operator()(_Ty&& _Val) const noexcept(_Choice<_Ty&>._No_throw) {
; 2357 :                 constexpr _St _Strat = _Choice<_Ty&>._Strategy;
; 2358 : 
; 2359 :                 if constexpr (_Strat == _St::_Array) {
; 2360 :                     return _Val;
; 2361 :                 } else if constexpr (_Strat == _St::_Member) {
; 2362 :                     return _Val.begin();
; 2363 :                 } else if constexpr (_Strat == _St::_Non_member) {
; 2364 :                     return begin(_Val); // intentional ADL
; 2365 :                 } else {
; 2366 :                     static_assert(_Always_false<_Ty>, "Should be unreachable");
; 2367 :                 }
; 2368 :             }
; 2369 :         };
; 2370 :     } // namespace _Begin
; 2371 : 
; 2372 :     inline namespace _Cpos {
; 2373 :         _EXPORT_STD inline constexpr _Begin::_Cpo begin;
; 2374 :     }
; 2375 : 
; 2376 :     _EXPORT_STD template <class _Ty>
; 2377 :     using iterator_t = decltype(_RANGES begin(_STD declval<_Ty&>()));
; 2378 : 
; 2379 :     namespace _End {
; 2380 : #if defined(__clang__) || defined(__EDG__) // TRANSITION, VSO-1681199
; 2381 :         void end() = delete; // Block unqualified name lookup
; 2382 : #else // ^^^ no workaround / workaround vvv
; 2383 :         void end();
; 2384 : #endif // ^^^ workaround ^^^
; 2385 : 
; 2386 :         template <class _Ty>
; 2387 :         concept _Has_member = requires(_Ty __t) {
; 2388 :             { _Fake_copy_init(__t.end()) } -> sentinel_for<iterator_t<_Ty>>;
; 2389 :         };
; 2390 : 
; 2391 :         template <class _Ty>
; 2392 :         concept _Has_ADL = _Has_class_or_enum_type<_Ty> //
; 2393 :                         && requires(_Ty __t) {
; 2394 :                                { _Fake_copy_init(end(__t)) } -> sentinel_for<iterator_t<_Ty>>; // intentional ADL
; 2395 :                            };
; 2396 : 
; 2397 :         class _Cpo {
; 2398 :         private:
; 2399 :             enum class _St { _None, _Array, _Member, _Non_member };
; 2400 : 
; 2401 :             template <class _Ty>
; 2402 :             _NODISCARD static consteval _Choice_t<_St> _Choose() noexcept {
; 2403 :                 _STL_INTERNAL_STATIC_ASSERT(is_lvalue_reference_v<_Ty>);
; 2404 :                 using _UnRef = remove_reference_t<_Ty>;
; 2405 : 
; 2406 :                 if constexpr (is_array_v<_UnRef>) {
; 2407 :                     static_assert(_Has_complete_elements<_UnRef>,
; 2408 :                         "The range access customization point objects "
; 2409 :                         "std::ranges::begin, std::ranges::end, std::ranges::rbegin, std::ranges::rend, "
; 2410 :                         "and std::ranges::data do not accept arrays with incomplete element types.");
; 2411 :                     if constexpr (extent_v<_UnRef> != 0) {
; 2412 :                         return {_St::_Array, true};
; 2413 :                     } else {
; 2414 :                         return {_St::_None};
; 2415 :                     }
; 2416 :                 } else if constexpr (_Has_member<_Ty>) {
; 2417 :                     return {_St::_Member, noexcept(_Fake_copy_init(_STD declval<_Ty>().end()))};
; 2418 :                 } else if constexpr (_Has_ADL<_Ty>) {
; 2419 :                     return {_St::_Non_member, noexcept(_Fake_copy_init(end(_STD declval<_Ty>())))}; // intentional ADL
; 2420 :                 } else {
; 2421 :                     return {_St::_None};
; 2422 :                 }
; 2423 :             }
; 2424 : 
; 2425 :             template <class _Ty>
; 2426 :             static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();
; 2427 : 
; 2428 :         public:
; 2429 :             template <_Should_range_access _Ty>
; 2430 :                 requires (_Choice<_Ty&>._Strategy != _St::_None)
; 2431 :             _NODISCARD constexpr auto operator()(_Ty&& _Val) const noexcept(_Choice<_Ty&>._No_throw) {
; 2432 :                 constexpr _St _Strat = _Choice<_Ty&>._Strategy;
; 2433 : 
; 2434 :                 if constexpr (_Strat == _St::_Array) {
; 2435 :                     // extent_v<remove_reference_t<_Ty&>> reuses specializations from _Choose
; 2436 :                     return _Val + extent_v<remove_reference_t<_Ty&>>;
; 2437 :                 } else if constexpr (_Strat == _St::_Member) {
; 2438 :                     return _Val.end();
; 2439 :                 } else if constexpr (_Strat == _St::_Non_member) {
; 2440 :                     return end(_Val); // intentional ADL
; 2441 :                 } else {
; 2442 :                     static_assert(_Always_false<_Ty>, "should be unreachable");
; 2443 :                 }
; 2444 :             }
; 2445 :         };
; 2446 :     } // namespace _End
; 2447 : 
; 2448 :     inline namespace _Cpos {
; 2449 :         _EXPORT_STD inline constexpr _End::_Cpo end;
; 2450 :     }
; 2451 : 
; 2452 :     _EXPORT_STD template <class _Rng>
; 2453 :     concept range = requires(_Rng& __r) {
; 2454 :         _RANGES begin(__r);
; 2455 :         _RANGES end(__r);
; 2456 :     };
; 2457 : 
; 2458 :     _EXPORT_STD template <class _Rng>
; 2459 :     concept input_range = range<_Rng> && input_iterator<iterator_t<_Rng>>;
; 2460 : 
; 2461 :     _EXPORT_STD template <range _Rng>
; 2462 :     using sentinel_t = decltype(_RANGES end(_STD declval<_Rng&>()));
; 2463 : 
; 2464 :     template <class _Wrapped>
; 2465 :     concept _Weakly_unwrappable = _Allow_inheriting_unwrap_v<remove_cvref_t<_Wrapped>>
; 2466 :                                && requires(_Wrapped&& _Wr) { _STD forward<_Wrapped>(_Wr)._Unwrapped(); };
; 2467 : 
; 2468 :     template <class _Sent>
; 2469 :     concept _Weakly_unwrappable_sentinel = _Weakly_unwrappable<const remove_reference_t<_Sent>&>;
; 2470 : 
; 2471 :     template <class _Iter>
; 2472 :     concept _Weakly_unwrappable_iterator = //
; 2473 :         _Weakly_unwrappable<_Iter> //
; 2474 :         && requires(
; 2475 :             _Iter&& _It, remove_cvref_t<_Iter>& _MutIt) { _MutIt._Seek_to(_STD forward<_Iter>(_It)._Unwrapped()); };
; 2476 : 
; 2477 :     template <class _Sent, class _Iter>
; 2478 :     concept _Unwrappable_sentinel_for = //
; 2479 :         _Weakly_unwrappable_sentinel<_Sent> //
; 2480 :         && _Weakly_unwrappable_iterator<_Iter> //
; 2481 :         && requires(_Iter&& _It, const remove_reference_t<_Sent>& _Se) {
; 2482 :                { _Se._Unwrapped() } -> sentinel_for<decltype(_STD forward<_Iter>(_It)._Unwrapped())>;
; 2483 :            };
; 2484 : 
; 2485 :     template <class _Sent, class _Iter>
; 2486 :     _NODISCARD constexpr decltype(auto) _Unwrap_iter(_Iter&& _It) noexcept(
; 2487 :         !_Unwrappable_sentinel_for<_Sent, _Iter> || _Has_nothrow_unwrapped<_Iter>) {
; 2488 :         _STL_INTERNAL_STATIC_ASSERT(sentinel_for<remove_cvref_t<_Sent>, remove_cvref_t<_Iter>>);
; 2489 :         if constexpr (is_pointer_v<remove_cvref_t<_Iter>>) {
; 2490 :             return _It + 0;
; 2491 :         } else if constexpr (_Unwrappable_sentinel_for<_Sent, _Iter>) {
; 2492 :             return static_cast<_Iter&&>(_It)._Unwrapped();
; 2493 :         } else {
; 2494 :             return static_cast<_Iter&&>(_It);
; 2495 :         }
; 2496 :     }
; 2497 : 
; 2498 :     template <class _Iter, class _Sent>
; 2499 :     _NODISCARD constexpr decltype(auto) _Unwrap_sent(_Sent&& _Se) noexcept(
; 2500 :         !_Unwrappable_sentinel_for<_Sent, _Iter> || _Has_nothrow_unwrapped<_Sent>) {
; 2501 :         _STL_INTERNAL_STATIC_ASSERT(sentinel_for<remove_cvref_t<_Sent>, remove_cvref_t<_Iter>>);
; 2502 :         if constexpr (is_pointer_v<remove_cvref_t<_Sent>>) {
; 2503 :             return _Se + 0;
; 2504 :         } else if constexpr (_Unwrappable_sentinel_for<_Sent, _Iter>) {
; 2505 :             return static_cast<_Sent&&>(_Se)._Unwrapped();
; 2506 :         } else {
; 2507 :             return static_cast<_Sent&&>(_Se);
; 2508 :         }
; 2509 :     }
; 2510 : 
; 2511 :     template <range _Rng, class _Iter>
; 2512 :     _NODISCARD constexpr decltype(auto) _Unwrap_range_iter(_Iter&& _It) noexcept(
; 2513 :         noexcept(_Unwrap_iter<sentinel_t<_Rng>>(static_cast<_Iter&&>(_It)))) {
; 2514 :         _STL_INTERNAL_STATIC_ASSERT(same_as<remove_cvref_t<_Iter>, iterator_t<_Rng>>);
; 2515 :         return _Unwrap_iter<sentinel_t<_Rng>>(static_cast<_Iter&&>(_It));
; 2516 :     }
; 2517 : 
; 2518 :     template <range _Rng, class _Sent>
; 2519 :     _NODISCARD constexpr decltype(auto) _Unwrap_range_sent(_Sent&& _Se) noexcept(
; 2520 :         noexcept(_Unwrap_sent<iterator_t<_Rng>>(static_cast<_Sent&&>(_Se)))) {
; 2521 :         _STL_INTERNAL_STATIC_ASSERT(same_as<remove_cvref_t<_Sent>, sentinel_t<_Rng>>);
; 2522 :         return _Unwrap_sent<iterator_t<_Rng>>(static_cast<_Sent&&>(_Se));
; 2523 :     }
; 2524 : 
; 2525 :     template <class _Iter, class _Sent>
; 2526 :     using _Unwrap_iter_t = remove_cvref_t<decltype(_Unwrap_iter<_Sent>(_STD declval<_Iter>()))>;
; 2527 :     template <class _Sent, class _Iter>
; 2528 :     using _Unwrap_sent_t = remove_cvref_t<decltype(_Unwrap_sent<_Iter>(_STD declval<_Sent>()))>;
; 2529 : 
; 2530 :     template <range _Rng>
; 2531 :     using _Unwrapped_iterator_t = _Unwrap_iter_t<iterator_t<_Rng>, sentinel_t<_Rng>>;
; 2532 :     template <range _Rng>
; 2533 :     using _Unwrapped_sentinel_t = _Unwrap_sent_t<sentinel_t<_Rng>, iterator_t<_Rng>>;
; 2534 : 
; 2535 :     namespace _Unchecked_begin {
; 2536 :         template <class _Ty>
; 2537 :         concept _Has_member = requires(_Ty& __t) {
; 2538 :             { __t._Unchecked_begin() } -> input_or_output_iterator;
; 2539 :         };
; 2540 : 
; 2541 :         template <class _Ty>
; 2542 :         concept _Can_begin = requires(_Ty& __t) { _Unwrap_range_iter<_Ty>(_RANGES begin(__t)); };
; 2543 : 
; 2544 :         class _Cpo {
; 2545 :         private:
; 2546 :             enum class _St { _None, _Member, _Unwrap };
; 2547 : 
; 2548 :             template <class _Ty>
; 2549 :             _NODISCARD static consteval _Choice_t<_St> _Choose() noexcept {
; 2550 :                 _STL_INTERNAL_STATIC_ASSERT(is_lvalue_reference_v<_Ty>);
; 2551 :                 if constexpr (_Has_member<_Ty>) {
; 2552 :                     _STL_INTERNAL_STATIC_ASSERT(
; 2553 :                         same_as<decltype(_STD declval<_Ty>()._Unchecked_begin()), _Unwrapped_iterator_t<_Ty>>);
; 2554 :                     return {_St::_Member, noexcept(_Fake_copy_init(_STD declval<_Ty>()._Unchecked_begin()))};
; 2555 :                 } else if constexpr (_Can_begin<_Ty>) {
; 2556 :                     return {_St::_Unwrap,
; 2557 :                         noexcept(_Fake_copy_init(_Unwrap_range_iter<_Ty>(_RANGES begin(_STD declval<_Ty>()))))};
; 2558 :                 } else {
; 2559 :                     return {_St::_None};
; 2560 :                 }
; 2561 :             }
; 2562 : 
; 2563 :             template <class _Ty>
; 2564 :             static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();
; 2565 : 
; 2566 :         public:
; 2567 :             template <_Should_range_access _Ty>
; 2568 :                 requires (_Choice<_Ty&>._Strategy != _St::_None)
; 2569 :             _NODISCARD constexpr auto operator()(_Ty&& _Val) const noexcept(_Choice<_Ty&>._No_throw) {
; 2570 :                 constexpr _St _Strat = _Choice<_Ty&>._Strategy;
; 2571 : 
; 2572 :                 if constexpr (_Strat == _St::_Member) {
; 2573 :                     return _Val._Unchecked_begin();
; 2574 :                 } else if constexpr (_Strat == _St::_Unwrap) {
; 2575 :                     return _Unwrap_range_iter<_Ty>(_RANGES begin(_Val));
; 2576 :                 } else {
; 2577 :                     static_assert(_Always_false<_Ty>, "Should be unreachable");
; 2578 :                 }
; 2579 :             }
; 2580 :         };
; 2581 :     } // namespace _Unchecked_begin
; 2582 : 
; 2583 :     inline namespace _Cpos {
; 2584 :         inline constexpr _Unchecked_begin::_Cpo _Ubegin;
; 2585 :     }
; 2586 : 
; 2587 :     namespace _Unchecked_end {
; 2588 :         template <class _Ty>
; 2589 :         concept _Has_member = _Unchecked_begin::_Has_member<_Ty> && requires(_Ty& __t) {
; 2590 :             __t._Unchecked_begin(); // required explicitly for better diagnostics
; 2591 :             { __t._Unchecked_end() } -> sentinel_for<decltype(__t._Unchecked_begin())>;
; 2592 :         };
; 2593 : 
; 2594 :         template <class _Ty>
; 2595 :         concept _Can_end = requires(_Ty& __t) { _Unwrap_range_sent<_Ty>(_RANGES end(__t)); };
; 2596 : 
; 2597 :         class _Cpo {
; 2598 :         private:
; 2599 :             enum class _St { _None, _Member, _Unwrap };
; 2600 : 
; 2601 :             template <class _Ty>
; 2602 :             _NODISCARD static consteval _Choice_t<_St> _Choose() noexcept {
; 2603 :                 _STL_INTERNAL_STATIC_ASSERT(is_lvalue_reference_v<_Ty>);
; 2604 :                 if constexpr (_Has_member<_Ty>) {
; 2605 :                     return {_St::_Member, noexcept(_STD declval<_Ty>()._Unchecked_end())};
; 2606 :                 } else if constexpr (_Can_end<_Ty>) {
; 2607 :                     return {_St::_Unwrap, noexcept(_Unwrap_range_sent<_Ty>(_RANGES end(_STD declval<_Ty>())))};
; 2608 :                 } else {
; 2609 :                     return {_St::_None};
; 2610 :                 }
; 2611 :             }
; 2612 : 
; 2613 :             template <class _Ty>
; 2614 :             static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();
; 2615 : 
; 2616 :         public:
; 2617 :             template <_Should_range_access _Ty>
; 2618 :                 requires (_Choice<_Ty&>._Strategy != _St::_None)
; 2619 :             _NODISCARD constexpr auto operator()(_Ty&& _Val) const noexcept(_Choice<_Ty&>._No_throw) {
; 2620 :                 constexpr _St _Strat = _Choice<_Ty&>._Strategy;
; 2621 : 
; 2622 :                 if constexpr (_Strat == _St::_Member) {
; 2623 :                     return _Val._Unchecked_end();
; 2624 :                 } else if constexpr (_Strat == _St::_Unwrap) {
; 2625 :                     return _Unwrap_range_sent<_Ty>(_RANGES end(_Val));
; 2626 :                 } else {
; 2627 :                     static_assert(_Always_false<_Ty>, "Should be unreachable");
; 2628 :                 }
; 2629 :             }
; 2630 :         };
; 2631 :     } // namespace _Unchecked_end
; 2632 : 
; 2633 :     inline namespace _Cpos {
; 2634 :         inline constexpr _Unchecked_end::_Cpo _Uend;
; 2635 :     }
; 2636 : 
; 2637 :     _EXPORT_STD template <class _Rng>
; 2638 :     concept borrowed_range = range<_Rng> && _Should_range_access<_Rng>;
; 2639 : 
; 2640 :     _EXPORT_STD template <range _Rng>
; 2641 :     using range_difference_t = iter_difference_t<iterator_t<_Rng>>;
; 2642 : 
; 2643 :     _EXPORT_STD template <range _Rng>
; 2644 :     using range_value_t = iter_value_t<iterator_t<_Rng>>;
; 2645 : 
; 2646 :     _EXPORT_STD template <range _Rng>
; 2647 :     using range_reference_t = iter_reference_t<iterator_t<_Rng>>;
; 2648 : 
; 2649 :     _EXPORT_STD template <range _Rng>
; 2650 :     using range_rvalue_reference_t = iter_rvalue_reference_t<iterator_t<_Rng>>;
; 2651 : 
; 2652 :     _EXPORT_STD template <range _Rng>
; 2653 :     using range_common_reference_t = iter_common_reference_t<iterator_t<_Rng>>;
; 2654 : 
; 2655 : #if _HAS_CXX23
; 2656 :     _EXPORT_STD template <class _Rng>
; 2657 :     concept constant_range = input_range<_Rng> && _Constant_iterator<iterator_t<_Rng>>;
; 2658 : 
; 2659 :     template <input_range _Rng>
; 2660 :     _NODISCARD constexpr auto& _Possibly_const_range(_Rng& _Range) noexcept {
; 2661 :         if constexpr (constant_range<const _Rng> && !constant_range<_Rng>) {
; 2662 :             return _STD as_const(_Range);
; 2663 :         } else {
; 2664 :             return _Range;
; 2665 :         }
; 2666 :     }
; 2667 : 
; 2668 :     template <class _Ty>
; 2669 :     _NODISCARD constexpr auto _As_const_pointer(const _Ty* _Ptr) noexcept {
; 2670 :         return _Ptr;
; 2671 :     }
; 2672 : 
; 2673 :     template <class _Ty>
; 2674 :     using _Begin_on_const = decltype(_RANGES begin(_RANGES _Possibly_const_range(_STD declval<_Ty&>())));
; 2675 : 
; 2676 :     // TRANSITION, LLVM-55945
; 2677 :     template <class _Ty>
; 2678 :     concept _Range_accessible_and_begin_adaptable = _Should_range_access<_Ty> && requires(_Ty& _Val) {
; 2679 :         const_iterator<_Begin_on_const<_Ty>>{_RANGES begin(_RANGES _Possibly_const_range(_Val))};
; 2680 :     };
; 2681 : 
; 2682 :     template <class _Ty>
; 2683 :     using _End_on_const = decltype(_RANGES end(_RANGES _Possibly_const_range(_STD declval<_Ty&>())));
; 2684 : 
; 2685 :     // TRANSITION, LLVM-55945
; 2686 :     template <class _Ty>
; 2687 :     concept _Range_accessible_and_end_adaptable = _Should_range_access<_Ty> && requires(_Ty& _Val) {
; 2688 :         const_sentinel<_End_on_const<_Ty>>{_RANGES end(_RANGES _Possibly_const_range(_Val))};
; 2689 :     };
; 2690 : #endif // _HAS_CXX23
; 2691 : 
; 2692 :     struct _Cbegin_fn {
; 2693 : #if _HAS_CXX23
; 2694 :         template <_Range_accessible_and_begin_adaptable _Ty>
; 2695 :         _NODISCARD constexpr auto operator()(_Ty&& _Val) const noexcept(
; 2696 :             noexcept(const_iterator<_Begin_on_const<_Ty>>{_RANGES begin(_RANGES _Possibly_const_range(_Val))})) {
; 2697 :             return const_iterator<_Begin_on_const<_Ty>>{_RANGES begin(_RANGES _Possibly_const_range(_Val))};
; 2698 :         }
; 2699 : #else // ^^^ C++23 / C++20 vvv
; 2700 :         template <class _Ty, class _CTy = _Const_thru_ref<_Ty>>
; 2701 :         _NODISCARD constexpr auto operator()(_Ty&& _Val) const
; 2702 :             noexcept(noexcept(_RANGES begin(static_cast<_CTy&&>(_Val))))
; 2703 :             requires requires { _RANGES begin(static_cast<_CTy&&>(_Val)); }
; 2704 :         {
; 2705 :             return _RANGES begin(static_cast<_CTy&&>(_Val));
; 2706 :         }
; 2707 : #endif // C++20
; 2708 :     };
; 2709 : 
; 2710 :     inline namespace _Cpos {
; 2711 :         _EXPORT_STD inline constexpr _Cbegin_fn cbegin;
; 2712 :     }
; 2713 : 
; 2714 :     struct _Cend_fn {
; 2715 : #if _HAS_CXX23
; 2716 :         template <_Range_accessible_and_end_adaptable _Ty>
; 2717 :         _NODISCARD constexpr auto operator()(_Ty&& _Val) const
; 2718 :             noexcept(noexcept(const_sentinel<_End_on_const<_Ty>>{_RANGES end(_RANGES _Possibly_const_range(_Val))})) {
; 2719 :             return const_sentinel<_End_on_const<_Ty>>{_RANGES end(_RANGES _Possibly_const_range(_Val))};
; 2720 :         }
; 2721 : #else // ^^^ C++23 / C++20 vvv
; 2722 :         template <class _Ty, class _CTy = _Const_thru_ref<_Ty>>
; 2723 :         _NODISCARD constexpr auto operator()(_Ty&& _Val) const
; 2724 :             noexcept(noexcept(_RANGES end(static_cast<_CTy&&>(_Val))))
; 2725 :             requires requires { _RANGES end(static_cast<_CTy&&>(_Val)); }
; 2726 :         {
; 2727 :             return _RANGES end(static_cast<_CTy&&>(_Val));
; 2728 :         }
; 2729 : #endif // C++20
; 2730 :     };
; 2731 : 
; 2732 :     inline namespace _Cpos {
; 2733 :         _EXPORT_STD inline constexpr _Cend_fn cend;
; 2734 :     }
; 2735 : 
; 2736 :     namespace _Rbegin {
; 2737 : #if defined(__clang__) || defined(__EDG__) // TRANSITION, VSO-1681199
; 2738 :         void rbegin() = delete; // Block unqualified name lookup
; 2739 : #else // ^^^ no workaround / workaround vvv
; 2740 :         void rbegin();
; 2741 : #endif // ^^^ workaround ^^^
; 2742 : 
; 2743 :         template <class _Ty>
; 2744 :         concept _Has_member = requires(_Ty __t) {
; 2745 :             { _Fake_copy_init(__t.rbegin()) } -> input_or_output_iterator;
; 2746 :         };
; 2747 : 
; 2748 :         template <class _Ty>
; 2749 :         concept _Has_ADL = _Has_class_or_enum_type<_Ty> //
; 2750 :                         && requires(_Ty __t) {
; 2751 :                                { _Fake_copy_init(rbegin(__t)) } -> input_or_output_iterator; // intentional ADL
; 2752 :                            };
; 2753 : 
; 2754 :         template <class _Ty>
; 2755 :         concept _Can_make_reverse = requires(_Ty __t) {
; 2756 :             { _RANGES begin(__t) } -> bidirectional_iterator;
; 2757 :             { _RANGES end(__t) } -> same_as<decltype(_RANGES begin(__t))>;
; 2758 :         };
; 2759 : 
; 2760 :         class _Cpo {
; 2761 :         private:
; 2762 :             enum class _St { _None, _Member, _Non_member, _Make_reverse };
; 2763 : 
; 2764 :             template <class _Ty>
; 2765 :             _NODISCARD static consteval _Choice_t<_St> _Choose() noexcept {
; 2766 :                 _STL_INTERNAL_STATIC_ASSERT(is_lvalue_reference_v<_Ty>);
; 2767 :                 if constexpr (_Has_member<_Ty>) {
; 2768 :                     return {_St::_Member, noexcept(_Fake_copy_init(_STD declval<_Ty>().rbegin()))};
; 2769 :                 } else if constexpr (_Has_ADL<_Ty>) {
; 2770 :                     return {
; 2771 :                         _St::_Non_member, noexcept(_Fake_copy_init(rbegin(_STD declval<_Ty>())))}; // intentional ADL
; 2772 :                 } else if constexpr (_Can_make_reverse<_Ty>) {
; 2773 :                     return {_St::_Make_reverse, noexcept(_STD make_reverse_iterator(_RANGES end(_STD declval<_Ty>())))};
; 2774 :                 } else {
; 2775 :                     return {_St::_None};
; 2776 :                 }
; 2777 :             }
; 2778 : 
; 2779 :             template <class _Ty>
; 2780 :             static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();
; 2781 : 
; 2782 :         public:
; 2783 :             template <_Should_range_access _Ty>
; 2784 :                 requires (_Choice<_Ty&>._Strategy != _St::_None)
; 2785 :             _NODISCARD constexpr auto operator()(_Ty&& _Val) const noexcept(_Choice<_Ty&>._No_throw) {
; 2786 :                 constexpr _St _Strat = _Choice<_Ty&>._Strategy;
; 2787 : 
; 2788 :                 if constexpr (_Strat == _St::_Member) {
; 2789 :                     return _Val.rbegin();
; 2790 :                 } else if constexpr (_Strat == _St::_Non_member) {
; 2791 :                     return rbegin(_Val); // intentional ADL
; 2792 :                 } else if constexpr (_Strat == _St::_Make_reverse) {
; 2793 :                     return _STD make_reverse_iterator(_RANGES end(_Val));
; 2794 :                 } else {
; 2795 :                     static_assert(_Always_false<_Ty>, "should be unreachable");
; 2796 :                 }
; 2797 :             }
; 2798 :         };
; 2799 :     } // namespace _Rbegin
; 2800 : 
; 2801 :     inline namespace _Cpos {
; 2802 :         _EXPORT_STD inline constexpr _Rbegin::_Cpo rbegin;
; 2803 :     }
; 2804 : 
; 2805 :     namespace _Rend {
; 2806 : #if defined(__clang__) || defined(__EDG__) // TRANSITION, VSO-1681199
; 2807 :         void rend() = delete; // Block unqualified name lookup
; 2808 : #else // ^^^ no workaround / workaround vvv
; 2809 :         void rend();
; 2810 : #endif // ^^^ workaround ^^^
; 2811 : 
; 2812 :         template <class _Ty>
; 2813 :         concept _Has_member = requires(_Ty __t) {
; 2814 :             { _Fake_copy_init(__t.rend()) } -> sentinel_for<decltype(_RANGES rbegin(__t))>;
; 2815 :         };
; 2816 : 
; 2817 :         template <class _Ty>
; 2818 :         concept _Has_ADL = _Has_class_or_enum_type<_Ty> //
; 2819 :                         && requires(_Ty __t) {
; 2820 :                                // intentional ADL
; 2821 :                                { _Fake_copy_init(rend(__t)) } -> sentinel_for<decltype(_RANGES rbegin(__t))>;
; 2822 :                            };
; 2823 : 
; 2824 :         template <class _Ty>
; 2825 :         concept _Can_make_reverse = requires(_Ty __t) {
; 2826 :             { _RANGES begin(__t) } -> bidirectional_iterator;
; 2827 :             { _RANGES end(__t) } -> same_as<decltype(_RANGES begin(__t))>;
; 2828 :         };
; 2829 : 
; 2830 :         class _Cpo {
; 2831 :         private:
; 2832 :             enum class _St { _None, _Member, _Non_member, _Make_reverse };
; 2833 : 
; 2834 :             template <class _Ty>
; 2835 :             _NODISCARD static consteval _Choice_t<_St> _Choose() noexcept {
; 2836 :                 _STL_INTERNAL_STATIC_ASSERT(is_lvalue_reference_v<_Ty>);
; 2837 :                 if constexpr (_Has_member<_Ty>) {
; 2838 :                     return {_St::_Member, noexcept(_Fake_copy_init(_STD declval<_Ty>().rend()))};
; 2839 :                 } else if constexpr (_Has_ADL<_Ty>) {
; 2840 :                     return {_St::_Non_member, noexcept(_Fake_copy_init(rend(_STD declval<_Ty>())))}; // intentional ADL
; 2841 :                 } else if constexpr (_Can_make_reverse<_Ty>) {
; 2842 :                     return {
; 2843 :                         _St::_Make_reverse, noexcept(_STD make_reverse_iterator(_RANGES begin(_STD declval<_Ty>())))};
; 2844 :                 } else {
; 2845 :                     return {_St::_None};
; 2846 :                 }
; 2847 :             }
; 2848 : 
; 2849 :             template <class _Ty>
; 2850 :             static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();
; 2851 : 
; 2852 :         public:
; 2853 :             template <_Should_range_access _Ty>
; 2854 :                 requires (_Choice<_Ty&>._Strategy != _St::_None)
; 2855 :             _NODISCARD constexpr auto operator()(_Ty&& _Val) const noexcept(_Choice<_Ty&>._No_throw) {
; 2856 :                 constexpr _St _Strat = _Choice<_Ty&>._Strategy;
; 2857 : 
; 2858 :                 if constexpr (_Strat == _St::_Member) {
; 2859 :                     return _Val.rend();
; 2860 :                 } else if constexpr (_Strat == _St::_Non_member) {
; 2861 :                     return rend(_Val); // intentional ADL
; 2862 :                 } else if constexpr (_Strat == _St::_Make_reverse) {
; 2863 :                     return _STD make_reverse_iterator(_RANGES begin(_Val));
; 2864 :                 } else {
; 2865 :                     static_assert(_Always_false<_Ty>, "should be unreachable");
; 2866 :                 }
; 2867 :             }
; 2868 :         };
; 2869 :     } // namespace _Rend
; 2870 : 
; 2871 :     inline namespace _Cpos {
; 2872 :         _EXPORT_STD inline constexpr _Rend::_Cpo rend;
; 2873 :     }
; 2874 : 
; 2875 : #if _HAS_CXX23
; 2876 :     template <class _Ty>
; 2877 :     using _Rbegin_on_const = decltype(_RANGES rbegin(_RANGES _Possibly_const_range(_STD declval<_Ty&>())));
; 2878 : 
; 2879 :     // TRANSITION, LLVM-55945
; 2880 :     template <class _Ty>
; 2881 :     concept _Range_accessible_and_rbegin_adaptable = _Should_range_access<_Ty> && requires(_Ty& _Val) {
; 2882 :         const_iterator<_Rbegin_on_const<_Ty>>{_RANGES rbegin(_RANGES _Possibly_const_range(_Val))};
; 2883 :     };
; 2884 : 
; 2885 :     template <class _Ty>
; 2886 :     using _Rend_on_const = decltype(_RANGES rend(_RANGES _Possibly_const_range(_STD declval<_Ty&>())));
; 2887 : 
; 2888 :     // TRANSITION, LLVM-55945
; 2889 :     template <class _Ty>
; 2890 :     concept _Range_accessible_and_rend_adaptable = _Should_range_access<_Ty> && requires(_Ty& _Val) {
; 2891 :         const_sentinel<_Rend_on_const<_Ty>>{_RANGES rend(_RANGES _Possibly_const_range(_Val))};
; 2892 :     };
; 2893 : #endif // _HAS_CXX23
; 2894 : 
; 2895 :     struct _Crbegin_fn {
; 2896 : #if _HAS_CXX23
; 2897 :         template <_Range_accessible_and_rbegin_adaptable _Ty>
; 2898 :         _NODISCARD constexpr auto operator()(_Ty&& _Val) const noexcept(
; 2899 :             noexcept(const_iterator<_Rbegin_on_const<_Ty>>{_RANGES rbegin(_RANGES _Possibly_const_range(_Val))})) {
; 2900 :             return const_iterator<_Rbegin_on_const<_Ty>>{_RANGES rbegin(_RANGES _Possibly_const_range(_Val))};
; 2901 :         }
; 2902 : #else // ^^^ C++23 / C++20 vvv
; 2903 :         template <class _Ty, class _CTy = _Const_thru_ref<_Ty>>
; 2904 :         _NODISCARD constexpr auto operator()(_Ty&& _Val) const
; 2905 :             noexcept(noexcept(_RANGES rbegin(static_cast<_CTy&&>(_Val))))
; 2906 :             requires requires { _RANGES rbegin(static_cast<_CTy&&>(_Val)); }
; 2907 :         {
; 2908 :             return _RANGES rbegin(static_cast<_CTy&&>(_Val));
; 2909 :         }
; 2910 : #endif // C++20
; 2911 :     };
; 2912 : 
; 2913 :     inline namespace _Cpos {
; 2914 :         _EXPORT_STD inline constexpr _Crbegin_fn crbegin;
; 2915 :     }
; 2916 : 
; 2917 :     struct _Crend_fn {
; 2918 : #if _HAS_CXX23
; 2919 :         template <_Range_accessible_and_rend_adaptable _Ty>
; 2920 :         _NODISCARD constexpr auto operator()(_Ty&& _Val) const
; 2921 :             noexcept(noexcept(const_sentinel<_Rend_on_const<_Ty>>{_RANGES rend(_RANGES _Possibly_const_range(_Val))})) {
; 2922 :             return const_sentinel<_Rend_on_const<_Ty>>{_RANGES rend(_RANGES _Possibly_const_range(_Val))};
; 2923 :         }
; 2924 : #else // ^^^ C++23 / C++20 vvv
; 2925 :         template <class _Ty, class _CTy = _Const_thru_ref<_Ty>>
; 2926 :         _NODISCARD constexpr auto operator()(_Ty&& _Val) const
; 2927 :             noexcept(noexcept(_RANGES rend(static_cast<_CTy&&>(_Val))))
; 2928 :             requires requires { _RANGES rend(static_cast<_CTy&&>(_Val)); }
; 2929 :         {
; 2930 :             return _RANGES rend(static_cast<_CTy&&>(_Val));
; 2931 :         }
; 2932 : #endif // C++20
; 2933 :     };
; 2934 : 
; 2935 :     inline namespace _Cpos {
; 2936 :         _EXPORT_STD inline constexpr _Crend_fn crend;
; 2937 :     }
; 2938 : 
; 2939 :     _EXPORT_STD template <class>
; 2940 :     inline constexpr bool disable_sized_range = false;
; 2941 : 
; 2942 :     namespace _Size {
; 2943 : #if defined(__clang__) || defined(__EDG__) // TRANSITION, VSO-1681199
; 2944 :         void size() = delete; // Block unqualified name lookup
; 2945 : #else // ^^^ no workaround / workaround vvv
; 2946 :         void size();
; 2947 : #endif // ^^^ workaround ^^^
; 2948 : 
; 2949 :         template <class _Ty, class _UnCV>
; 2950 :         concept _Has_member = (!disable_sized_range<_UnCV>) //
; 2951 :             &&requires(_Ty __t) {
; 2952 :                 { _Fake_copy_init(__t.size()) } -> _Integer_like;
; 2953 :             };
; 2954 : 
; 2955 :         template <class _Ty, class _UnCV>
; 2956 :         concept _Has_ADL = _Has_class_or_enum_type<_Ty>
; 2957 :                         && (!disable_sized_range<_UnCV>) //
; 2958 :                         &&requires(_Ty __t) {
; 2959 :                             { _Fake_copy_init(size(__t)) } -> _Integer_like; // intentional ADL
; 2960 :                         };
; 2961 : 
; 2962 :         template <class _Ty>
; 2963 :         concept _Can_difference = requires(_Ty __t) {
; 2964 :             { _RANGES begin(__t) } -> forward_iterator;
; 2965 :             { _RANGES end(__t) } -> sized_sentinel_for<decltype(_RANGES begin(__t))>;
; 2966 :         };
; 2967 : 
; 2968 :         class _Cpo {
; 2969 :         private:
; 2970 :             enum class _St { _None, _Array, _Member, _Non_member, _Subtract };
; 2971 : 
; 2972 :             template <class _Ty>
; 2973 :             _NODISCARD static consteval _Choice_t<_St> _Choose() noexcept {
; 2974 :                 _STL_INTERNAL_STATIC_ASSERT(is_lvalue_reference_v<_Ty>);
; 2975 :                 using _UnCV = remove_cvref_t<_Ty>;
; 2976 : 
; 2977 :                 if constexpr (is_array_v<_UnCV>) {
; 2978 :                     if constexpr (extent_v<_UnCV> != 0) {
; 2979 :                         return {_St::_Array, true};
; 2980 :                     } else {
; 2981 :                         return {_St::_None};
; 2982 :                     }
; 2983 :                 } else if constexpr (_Has_member<_Ty, _UnCV>) {
; 2984 :                     return {_St::_Member, noexcept(_Fake_copy_init(_STD declval<_Ty>().size()))};
; 2985 :                 } else if constexpr (_Has_ADL<_Ty, _UnCV>) {
; 2986 :                     return {_St::_Non_member, noexcept(_Fake_copy_init(size(_STD declval<_Ty>())))}; // intentional ADL
; 2987 :                 } else if constexpr (_Can_difference<_Ty>) {
; 2988 :                     return {_St::_Subtract,
; 2989 :                         noexcept(_RANGES end(_STD declval<_Ty>()) - _RANGES begin(_STD declval<_Ty>()))};
; 2990 :                 } else {
; 2991 :                     return {_St::_None};
; 2992 :                 }
; 2993 :             }
; 2994 : 
; 2995 :             template <class _Ty>
; 2996 :             static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();
; 2997 : 
; 2998 :         public:
; 2999 :             template <class _Ty>
; 3000 :                 requires (_Choice<_Ty&>._Strategy != _St::_None)
; 3001 :             _NODISCARD constexpr auto operator()(_Ty&& _Val) const noexcept(_Choice<_Ty&>._No_throw) {
; 3002 :                 constexpr _St _Strat = _Choice<_Ty&>._Strategy;
; 3003 : 
; 3004 :                 if constexpr (_Strat == _St::_Array) {
; 3005 :                     // extent_v<remove_cvref_t<_Ty&>> reuses specializations from _Choose
; 3006 :                     return extent_v<remove_cvref_t<_Ty&>>;
; 3007 :                 } else if constexpr (_Strat == _St::_Member) {
; 3008 :                     return _Val.size();
; 3009 :                 } else if constexpr (_Strat == _St::_Non_member) {
; 3010 :                     return size(_Val); // intentional ADL
; 3011 :                 } else if constexpr (_Strat == _St::_Subtract) {
; 3012 :                     const auto _Delta = _RANGES end(_Val) - _RANGES begin(_Val);
; 3013 :                     return static_cast<_Make_unsigned_like_t<remove_cv_t<decltype(_Delta)>>>(_Delta);
; 3014 :                 } else {
; 3015 :                     static_assert(_Always_false<_Ty>, "should be unreachable");
; 3016 :                 }
; 3017 :             }
; 3018 :         };
; 3019 :     } // namespace _Size
; 3020 : 
; 3021 :     inline namespace _Cpos {
; 3022 :         _EXPORT_STD inline constexpr _Size::_Cpo size;
; 3023 :     }
; 3024 : 
; 3025 :     namespace _Empty {
; 3026 :         template <class _Ty>
; 3027 :         concept _Has_member = requires(_Ty __t) { static_cast<bool>(__t.empty()); };
; 3028 : 
; 3029 :         template <class _Ty>
; 3030 :         concept _Has_size = requires(_Ty __t) { _RANGES size(__t); };
; 3031 : 
; 3032 :         template <class _Ty>
; 3033 :         concept _Can_begin_end = requires(_Ty __t) {
; 3034 :             { _RANGES begin(__t) } -> forward_iterator;
; 3035 :             _RANGES end(__t);
; 3036 :         };
; 3037 : 
; 3038 :         class _Cpo {
; 3039 :         private:
; 3040 :             enum class _St { _None, _Member, _Size, _Compare };
; 3041 : 
; 3042 :             template <class _Ty>
; 3043 :             _NODISCARD static consteval _Choice_t<_St> _Choose() noexcept {
; 3044 :                 _STL_INTERNAL_STATIC_ASSERT(is_lvalue_reference_v<_Ty>);
; 3045 :                 if constexpr (is_unbounded_array_v<remove_reference_t<_Ty>>) {
; 3046 :                     return {_St::_None};
; 3047 :                 } else if constexpr (_Has_member<_Ty>) {
; 3048 :                     return {_St::_Member, noexcept(static_cast<bool>(_STD declval<_Ty>().empty()))};
; 3049 :                 } else if constexpr (_Has_size<_Ty>) {
; 3050 :                     return {_St::_Size, noexcept(_RANGES size(_STD declval<_Ty>()))};
; 3051 :                 } else if constexpr (_Can_begin_end<_Ty>) {
; 3052 :                     constexpr auto _Nothrow = noexcept(
; 3053 :                         static_cast<bool>(_RANGES begin(_STD declval<_Ty>()) == _RANGES end(_STD declval<_Ty>())));
; 3054 :                     return {_St::_Compare, _Nothrow};
; 3055 :                 } else {
; 3056 :                     return {_St::_None};
; 3057 :                 }
; 3058 :             }
; 3059 : 
; 3060 :             template <class _Ty>
; 3061 :             static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();
; 3062 : 
; 3063 :         public:
; 3064 :             // clang-format off
; 3065 :             template <class _Ty>
; 3066 :                 requires (_Choice<_Ty&>._Strategy != _St::_None)
; 3067 :             _NODISCARD constexpr bool operator()(_Ty&& _Val) const noexcept(_Choice<_Ty&>._No_throw) {
; 3068 :                 constexpr _St _Strat = _Choice<_Ty&>._Strategy;
; 3069 : 
; 3070 :                 if constexpr (_Strat == _St::_Member) {
; 3071 :                     return static_cast<bool>(_Val.empty());
; 3072 :                 } else if constexpr (_Strat == _St::_Size) {
; 3073 :                     return _RANGES size(_Val) == 0;
; 3074 :                 } else if constexpr (_Strat == _St::_Compare) {
; 3075 :                     return static_cast<bool>(_RANGES begin(_Val) == _RANGES end(_Val));
; 3076 :                 } else {
; 3077 :                     static_assert(_Always_false<_Ty>, "should be unreachable");
; 3078 :                 }
; 3079 :             }
; 3080 :             // clang-format on
; 3081 :         };
; 3082 :     } // namespace _Empty
; 3083 : 
; 3084 :     inline namespace _Cpos {
; 3085 :         _EXPORT_STD inline constexpr _Empty::_Cpo empty;
; 3086 :     }
; 3087 : 
; 3088 :     namespace _Data {
; 3089 :         template <class _Ty>
; 3090 :         concept _Points_to_object = is_pointer_v<_Ty> && is_object_v<remove_pointer_t<_Ty>>;
; 3091 : 
; 3092 :         template <class _Ty>
; 3093 :         concept _Has_member = requires(_Ty __t) {
; 3094 :             { _Fake_copy_init(__t.data()) } -> _Points_to_object;
; 3095 :         };
; 3096 : 
; 3097 :         template <class _Ty>
; 3098 :         concept _Has_contiguous_iterator = requires(_Ty __t) {
; 3099 :             { _RANGES begin(__t) } -> contiguous_iterator;
; 3100 :         };
; 3101 : 
; 3102 :         class _Cpo {
; 3103 :         private:
; 3104 :             enum class _St { _None, _Member, _Address };
; 3105 : 
; 3106 :             template <class _Ty>
; 3107 :             _NODISCARD static consteval _Choice_t<_St> _Choose() noexcept {
; 3108 :                 _STL_INTERNAL_STATIC_ASSERT(is_lvalue_reference_v<_Ty>);
; 3109 :                 if constexpr (_Has_member<_Ty>) {
; 3110 :                     return {_St::_Member, noexcept(_STD declval<_Ty>().data())};
; 3111 :                 } else if constexpr (_Has_contiguous_iterator<_Ty>) {
; 3112 :                     return {_St::_Address, noexcept(_STD to_address(_RANGES begin(_STD declval<_Ty>())))};
; 3113 :                 } else {
; 3114 :                     return {_St::_None};
; 3115 :                 }
; 3116 :             }
; 3117 : 
; 3118 :             template <class _Ty>
; 3119 :             static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();
; 3120 : 
; 3121 :         public:
; 3122 :             template <_Should_range_access _Ty>
; 3123 :                 requires (_Choice<_Ty&>._Strategy != _St::_None)
; 3124 :             _NODISCARD constexpr auto operator()(_Ty&& _Val) const noexcept(_Choice<_Ty&>._No_throw) {
; 3125 :                 constexpr _St _Strat = _Choice<_Ty&>._Strategy;
; 3126 : 
; 3127 :                 if constexpr (_Strat == _St::_Member) {
; 3128 :                     return _Val.data();
; 3129 :                 } else if constexpr (_Strat == _St::_Address) {
; 3130 :                     return _STD to_address(_RANGES begin(_Val));
; 3131 :                 } else {
; 3132 :                     static_assert(_Always_false<_Ty>, "should be unreachable");
; 3133 :                 }
; 3134 :             }
; 3135 :         };
; 3136 :     } // namespace _Data
; 3137 : 
; 3138 :     inline namespace _Cpos {
; 3139 :         _EXPORT_STD inline constexpr _Data::_Cpo data;
; 3140 :     }
; 3141 : 
; 3142 : #if _HAS_CXX23
; 3143 :     // TRANSITION, LLVM-55945
; 3144 :     template <class _Ty>
; 3145 :     concept _Range_accessible_and_data_adaptable = _Should_range_access<_Ty> && requires(_Ty& _Val) {
; 3146 :         _RANGES _As_const_pointer(_RANGES data(_RANGES _Possibly_const_range(_Val)));
; 3147 :     };
; 3148 : #endif // _HAS_CXX23
; 3149 : 
; 3150 :     struct _Cdata_fn {
; 3151 : #if _HAS_CXX23
; 3152 :         template <_Range_accessible_and_data_adaptable _Ty>
; 3153 :         _NODISCARD constexpr auto operator()(_Ty&& _Val) const
; 3154 :             noexcept(noexcept(_RANGES data(_RANGES _Possibly_const_range(_Val)))) {
; 3155 :             return _RANGES _As_const_pointer(_RANGES data(_RANGES _Possibly_const_range(_Val)));
; 3156 :         }
; 3157 : #else // ^^^ C++23 / C++20 vvv
; 3158 :         template <class _Ty, class _CTy = _Const_thru_ref<_Ty>>
; 3159 :         _NODISCARD constexpr auto operator()(_Ty&& _Val) const
; 3160 :             noexcept(noexcept(_RANGES data(static_cast<_CTy&&>(_Val))))
; 3161 :             requires requires { _RANGES data(static_cast<_CTy&&>(_Val)); }
; 3162 :         {
; 3163 :             return _RANGES data(static_cast<_CTy&&>(_Val));
; 3164 :         }
; 3165 : #endif // C++20
; 3166 :     };
; 3167 : 
; 3168 :     inline namespace _Cpos {
; 3169 :         _EXPORT_STD inline constexpr _Cdata_fn cdata;
; 3170 :     }
; 3171 : 
; 3172 :     _EXPORT_STD template <class _Rng>
; 3173 :     concept sized_range = range<_Rng> && requires(_Rng& __r) { _RANGES size(__r); };
; 3174 : 
; 3175 :     _EXPORT_STD template <sized_range _Rng>
; 3176 :     using range_size_t = decltype(_RANGES size(_STD declval<_Rng&>()));
; 3177 : 
; 3178 :     _EXPORT_STD struct view_base {};
; 3179 : 
; 3180 :     template <class _Ty, template <class...> class _Template>
; 3181 :     concept _Strictly_derived_from_specialization_of =
; 3182 :         is_object_v<_Ty> && _Derived_from_specialization_of<_Ty, _Template>;
; 3183 : 
; 3184 :     _EXPORT_STD template <class _Derived>
; 3185 :         requires is_class_v<_Derived> && same_as<_Derived, remove_cv_t<_Derived>>
; 3186 :     class view_interface;
; 3187 : 
; 3188 :     _EXPORT_STD template <class _Ty>
; 3189 :     inline constexpr bool enable_view =
; 3190 :         derived_from<_Ty, view_base> || _Strictly_derived_from_specialization_of<_Ty, view_interface>;
; 3191 : 
; 3192 :     _EXPORT_STD template <class _Ty>
; 3193 :     concept view = range<_Ty> && movable<_Ty> && enable_view<_Ty>;
; 3194 : 
; 3195 :     _EXPORT_STD template <class _Rng, class _Ty>
; 3196 :     concept output_range = range<_Rng> && output_iterator<iterator_t<_Rng>, _Ty>;
; 3197 : 
; 3198 :     _EXPORT_STD template <class _Rng>
; 3199 :     concept forward_range = range<_Rng> && forward_iterator<iterator_t<_Rng>>;
; 3200 : 
; 3201 :     _EXPORT_STD template <class _Rng>
; 3202 :     concept bidirectional_range = range<_Rng> && bidirectional_iterator<iterator_t<_Rng>>;
; 3203 : 
; 3204 :     _EXPORT_STD template <class _Rng>
; 3205 :     concept random_access_range = range<_Rng> && random_access_iterator<iterator_t<_Rng>>;
; 3206 : 
; 3207 :     _EXPORT_STD template <class _Rng>
; 3208 :     concept contiguous_range = range<_Rng> && contiguous_iterator<iterator_t<_Rng>> && requires(_Rng& __r) {
; 3209 :         { _RANGES data(__r) } -> same_as<add_pointer_t<range_reference_t<_Rng>>>;
; 3210 :     };
; 3211 : 
; 3212 :     class _Not_quite_object {
; 3213 :     public:
; 3214 :         // Some overload sets in the library have the property that their constituent function templates are not visible
; 3215 :         // to argument-dependent name lookup (ADL) and that they inhibit ADL when found via unqualified name lookup.
; 3216 :         // This property allows these overload sets to be implemented as function objects. We derive such function
; 3217 :         // objects from this type to remove some typical object-ish behaviors which helps users avoid depending on their
; 3218 :         // non-specified object-ness.
; 3219 : 
; 3220 :         struct _Construct_tag {
; 3221 :             explicit _Construct_tag() = default;
; 3222 :         };
; 3223 : 
; 3224 :         _Not_quite_object() = delete;
; 3225 : 
; 3226 :         constexpr explicit _Not_quite_object(_Construct_tag) noexcept {}
; 3227 : 
; 3228 :         _Not_quite_object(const _Not_quite_object&)            = delete;
; 3229 :         _Not_quite_object& operator=(const _Not_quite_object&) = delete;
; 3230 : 
; 3231 :         void operator&() const = delete;
; 3232 : 
; 3233 :     protected:
; 3234 :         ~_Not_quite_object() = default;
; 3235 :     };
; 3236 : 
; 3237 :     class _Advance_fn : private _Not_quite_object {
; 3238 :     public:
; 3239 :         using _Not_quite_object::_Not_quite_object;
; 3240 : 
; 3241 :         template <input_or_output_iterator _It>
; 3242 :         constexpr void operator()(_It& _Where, iter_difference_t<_It> _Off) const {
; 3243 :             if constexpr (random_access_iterator<_It>) {
; 3244 :                 _Where += _Off;
; 3245 :             } else {
; 3246 :                 if constexpr (!bidirectional_iterator<_It>) {
; 3247 :                     _STL_ASSERT(_Off >= 0, "negative advance of non-bidirectional iterator");
; 3248 :                 }
; 3249 : 
; 3250 :                 decltype(auto) _UWhere      = _Get_unwrapped_n(_STD move(_Where), _Off);
; 3251 :                 constexpr bool _Need_rewrap = !is_reference_v<decltype(_Get_unwrapped_n(_STD move(_Where), _Off))>;
; 3252 : 
; 3253 :                 if constexpr (bidirectional_iterator<_It>) {
; 3254 :                     for (; _Off < 0; ++_Off) {
; 3255 :                         --_UWhere;
; 3256 :                     }
; 3257 :                 }
; 3258 : 
; 3259 :                 for (; _Off > 0; --_Off) {
; 3260 :                     ++_UWhere;
; 3261 :                 }
; 3262 : 
; 3263 :                 if constexpr (_Need_rewrap) {
; 3264 :                     _Seek_wrapped(_Where, _STD move(_UWhere));
; 3265 :                 }
; 3266 :             }
; 3267 :         }
; 3268 : 
; 3269 :         template <input_or_output_iterator _It, sentinel_for<_It> _Se>
; 3270 :         constexpr void operator()(_It& _Where, _Se _Last) const {
; 3271 :             if constexpr (assignable_from<_It&, _Se>) {
; 3272 :                 _Where = static_cast<_Se&&>(_Last);
; 3273 :             } else if constexpr (sized_sentinel_for<_Se, _It>) {
; 3274 :                 (*this)(_Where, _Last - _Where);
; 3275 :             } else {
; 3276 :                 _Adl_verify_range(_Where, _Last);
; 3277 : 
; 3278 :                 decltype(auto) _UWhere      = _Unwrap_iter<_Se>(static_cast<_It&&>(_Where));
; 3279 :                 constexpr bool _Need_rewrap = !is_reference_v<decltype(_Unwrap_iter<_Se>(static_cast<_It&&>(_Where)))>;
; 3280 :                 decltype(auto) _ULast       = _Unwrap_sent<_It>(static_cast<_Se&&>(_Last));
; 3281 : 
; 3282 :                 while (_UWhere != _ULast) {
; 3283 :                     ++_UWhere;
; 3284 :                 }
; 3285 : 
; 3286 :                 if constexpr (_Need_rewrap) {
; 3287 :                     _Seek_wrapped(_Where, _STD move(_UWhere));
; 3288 :                 }
; 3289 :             }
; 3290 :         }
; 3291 : 
; 3292 :         template <input_or_output_iterator _It, sentinel_for<_It> _Se>
; 3293 :         constexpr iter_difference_t<_It> operator()(_It& _Where, iter_difference_t<_It> _Off, _Se _Last) const {
; 3294 :             if constexpr (sized_sentinel_for<_Se, _It>) {
; 3295 :                 const iter_difference_t<_It> _Delta = _Last - _Where;
; 3296 :                 if ((_Off < 0 && _Off <= _Delta) || (_Off > 0 && _Off >= _Delta)) {
; 3297 :                     if constexpr (assignable_from<_It&, _Se>) {
; 3298 :                         _Where = static_cast<_Se&&>(_Last);
; 3299 :                     } else {
; 3300 :                         (*this)(_Where, _Delta);
; 3301 :                     }
; 3302 :                     return _Off - _Delta;
; 3303 :                 }
; 3304 : 
; 3305 :                 (*this)(_Where, _Off);
; 3306 :                 return 0;
; 3307 :             } else {
; 3308 :                 // performance note: develop unwrapping technology for (i, n, s)?
; 3309 :                 if constexpr (bidirectional_iterator<_It>) {
; 3310 :                     for (; _Off < 0 && _Where != _Last; ++_Off) {
; 3311 :                         --_Where;
; 3312 :                     }
; 3313 :                 } else {
; 3314 :                     _STL_ASSERT(_Off >= 0, "negative advance of non-bidirectional iterator");
; 3315 :                 }
; 3316 : 
; 3317 :                 for (; _Off > 0 && _Where != _Last; --_Off) {
; 3318 :                     ++_Where;
; 3319 :                 }
; 3320 : 
; 3321 :                 return _Off;
; 3322 :             }
; 3323 :         }
; 3324 :     };
; 3325 : 
; 3326 :     _EXPORT_STD inline constexpr _Advance_fn advance{_Not_quite_object::_Construct_tag{}};
; 3327 : 
; 3328 :     class _Distance_fn : private _Not_quite_object {
; 3329 :     public:
; 3330 :         using _Not_quite_object::_Not_quite_object;
; 3331 : 
; 3332 :         template <class _It, sentinel_for<_It> _Se>
; 3333 :             requires (!sized_sentinel_for<_Se, _It>)
; 3334 :         _NODISCARD constexpr iter_difference_t<_It> operator()(_It _First, _Se _Last) const
; 3335 :             noexcept(noexcept(_Distance_unchecked(
; 3336 :                 _Get_unwrapped(_STD move(_First)), _Get_unwrapped(_STD move(_Last))))) /* strengthened */ {
; 3337 :             _Adl_verify_range(_First, _Last);
; 3338 :             return _Distance_unchecked(_Unwrap_iter<_Se>(_STD move(_First)), _Unwrap_sent<_It>(_STD move(_Last)));
; 3339 :         }
; 3340 : 
; 3341 :         template <class _It, sized_sentinel_for<decay_t<_It>> _Se>
; 3342 :         _NODISCARD constexpr iter_difference_t<decay_t<_It>> operator()(_It&& _First, const _Se _Last) const
; 3343 :             noexcept(noexcept(_Last - static_cast<const decay_t<_It>&>(_First))) /* strengthened */ {
; 3344 :             return _Last - static_cast<const decay_t<_It>&>(_First);
; 3345 :         }
; 3346 : 
; 3347 :         template <range _Rng>
; 3348 :         _NODISCARD constexpr range_difference_t<_Rng> operator()(_Rng&& _Range) const
; 3349 :             noexcept(_Nothrow_size<_Rng>) /* strengthened */ {
; 3350 :             if constexpr (sized_range<_Rng>) {
; 3351 :                 return static_cast<range_difference_t<_Rng>>(_RANGES size(_Range));
; 3352 :             } else {
; 3353 :                 return _Distance_unchecked(_Ubegin(_Range), _Uend(_Range));
; 3354 :             }
; 3355 :         }
; 3356 : 
; 3357 :     private:
; 3358 :         template <class _It, class _Se>
; 3359 :         _NODISCARD static constexpr iter_difference_t<_It> _Distance_unchecked(_It _First, const _Se _Last) noexcept(
; 3360 :             noexcept(++_First != _Last)) {
; 3361 :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se, _It>);
; 3362 : 
; 3363 :             iter_difference_t<_It> _Count = 0;
; 3364 :             for (; _First != _Last; ++_First) {
; 3365 :                 ++_Count;
; 3366 :             }
; 3367 : 
; 3368 :             return _Count;
; 3369 :         }
; 3370 : 
; 3371 :         template <class _Rng>
; 3372 :         static constexpr bool _Nothrow_size =
; 3373 :             noexcept(_Distance_unchecked(_Ubegin(_STD declval<_Rng&>()), _Uend(_STD declval<_Rng&>())));
; 3374 : 
; 3375 :         template <sized_range _Rng>
; 3376 :         static constexpr bool _Nothrow_size<_Rng> = noexcept(_RANGES size(_STD declval<_Rng&>()));
; 3377 :     };
; 3378 : 
; 3379 :     _EXPORT_STD inline constexpr _Distance_fn distance{_Not_quite_object::_Construct_tag{}};
; 3380 : 
; 3381 :     class _Ssize_fn {
; 3382 :     public:
; 3383 :         // clang-format off
; 3384 :         template <class _Rng>
; 3385 :         _NODISCARD constexpr auto operator()(_Rng&& _Range) const requires requires { _RANGES size(_Range); } {
; 3386 :             using _Sty = _Make_signed_like_t<decltype(_RANGES size(_Range))>;
; 3387 :             using _Ty  = common_type_t<conditional_t<is_integral_v<_Sty>, ptrdiff_t, _Sty>, _Sty>;
; 3388 :             return static_cast<_Ty>(_RANGES size(_Range));
; 3389 :         }
; 3390 :         // clang-format on
; 3391 :     };
; 3392 : 
; 3393 :     inline namespace _Cpos {
; 3394 :         _EXPORT_STD inline constexpr _Ssize_fn ssize;
; 3395 :     }
; 3396 : 
; 3397 :     class _Next_fn : private _Not_quite_object {
; 3398 :     public:
; 3399 :         using _Not_quite_object::_Not_quite_object;
; 3400 : 
; 3401 :         template <input_or_output_iterator _It>
; 3402 :         _NODISCARD constexpr _It operator()(_It _Where) const {
; 3403 :             ++_Where;
; 3404 :             return _Where;
; 3405 :         }
; 3406 : 
; 3407 :         template <input_or_output_iterator _It>
; 3408 :         _NODISCARD constexpr _It operator()(_It _Where, const iter_difference_t<_It> _Off) const {
; 3409 :             _RANGES advance(_Where, _Off);
; 3410 :             return _Where;
; 3411 :         }
; 3412 : 
; 3413 :         template <input_or_output_iterator _It, sentinel_for<_It> _Se>
; 3414 :         _NODISCARD constexpr _It operator()(_It _Where, _Se _Last) const {
; 3415 :             _RANGES advance(_Where, static_cast<_Se&&>(_Last));
; 3416 :             return _Where;
; 3417 :         }
; 3418 : 
; 3419 :         template <input_or_output_iterator _It, sentinel_for<_It> _Se>
; 3420 :         _NODISCARD constexpr _It operator()(_It _Where, const iter_difference_t<_It> _Off, _Se _Last) const {
; 3421 :             _RANGES advance(_Where, _Off, static_cast<_Se&&>(_Last));
; 3422 :             return _Where;
; 3423 :         }
; 3424 :     };
; 3425 : 
; 3426 :     _EXPORT_STD inline constexpr _Next_fn next{_Not_quite_object::_Construct_tag{}};
; 3427 : 
; 3428 :     class _Prev_fn : private _Not_quite_object {
; 3429 :     public:
; 3430 :         using _Not_quite_object::_Not_quite_object;
; 3431 : 
; 3432 :         template <bidirectional_iterator _It>
; 3433 :         _NODISCARD constexpr _It operator()(_It _Where) const {
; 3434 :             --_Where;
; 3435 :             return _Where;
; 3436 :         }
; 3437 : 
; 3438 :         template <bidirectional_iterator _It>
; 3439 :         _NODISCARD constexpr _It operator()(_It _Where, const iter_difference_t<_It> _Off) const {
; 3440 :             _STL_ASSERT(_Off != _Min_possible_v<iter_difference_t<_It>>, "integer overflow");
; 3441 :             _RANGES advance(_Where, -_Off);
; 3442 :             return _Where;
; 3443 :         }
; 3444 : 
; 3445 :         template <bidirectional_iterator _It>
; 3446 :         _NODISCARD constexpr _It operator()(_It _Where, const iter_difference_t<_It> _Off, _It _Last) const {
; 3447 :             _STL_ASSERT(_Off != _Min_possible_v<iter_difference_t<_It>>, "integer overflow");
; 3448 :             _RANGES advance(_Where, -_Off, static_cast<_It&&>(_Last));
; 3449 :             return _Where;
; 3450 :         }
; 3451 :     };
; 3452 : 
; 3453 :     _EXPORT_STD inline constexpr _Prev_fn prev{_Not_quite_object::_Construct_tag{}};
; 3454 : 
; 3455 :     template <forward_iterator _It, sentinel_for<_It> _Se>
; 3456 :     _NODISCARD constexpr _It _Find_last_iterator(
; 3457 :         const _It& _First, const _Se& _Last, const iter_difference_t<_It> _Count) {
; 3458 :         // Find the iterator in [_First, _Last) (of length _Count) which equals _Last
; 3459 :         _STL_INTERNAL_CHECK(_RANGES distance(_First, _Last) == _Count);
; 3460 :         if constexpr (is_same_v<_It, _Se>) {
; 3461 :             return _Last;
; 3462 :         } else {
; 3463 :             return _RANGES next(_First, _Count);
; 3464 :         }
; 3465 :     }
; 3466 : 
; 3467 :     _EXPORT_STD struct equal_to {
; 3468 :         // clang-format off
; 3469 :         template <class _Ty1, class _Ty2>
; 3470 :             requires equality_comparable_with<_Ty1, _Ty2>
; 3471 :         _NODISCARD constexpr bool operator()(_Ty1&& _Left, _Ty2&& _Right) const noexcept(noexcept(
; 3472 :             static_cast<bool>(static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right)))) /* strengthened */ {
; 3473 :             return static_cast<bool>(static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right));
; 3474 :         }
; 3475 :         // clang-format on
; 3476 : 
; 3477 :         using is_transparent = int;
; 3478 :     };
; 3479 : 
; 3480 :     _EXPORT_STD struct less {
; 3481 :         // clang-format off
; 3482 :         template <class _Ty1, class _Ty2>
; 3483 :             requires totally_ordered_with<_Ty1, _Ty2>
; 3484 :         _NODISCARD constexpr bool operator()(_Ty1&& _Left, _Ty2&& _Right) const noexcept(noexcept(
; 3485 :             static_cast<bool>(static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right)))) /* strengthened */ {
; 3486 :             return static_cast<bool>(static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right));
; 3487 :         }
; 3488 :         // clang-format on
; 3489 : 
; 3490 :         using is_transparent = int;
; 3491 :     };
; 3492 : 
; 3493 :     _EXPORT_STD struct greater {
; 3494 :         // clang-format off
; 3495 :         template <class _Ty1, class _Ty2>
; 3496 :             requires totally_ordered_with<_Ty1, _Ty2>
; 3497 :         _NODISCARD constexpr bool operator()(_Ty1&& _Left, _Ty2&& _Right) const noexcept(noexcept(
; 3498 :             static_cast<bool>(static_cast<_Ty2&&>(_Right) < static_cast<_Ty1&&>(_Left)))) /* strengthened */ {
; 3499 :             return static_cast<bool>(static_cast<_Ty2&&>(_Right) < static_cast<_Ty1&&>(_Left));
; 3500 :         }
; 3501 :         // clang-format on
; 3502 : 
; 3503 :         using is_transparent = int;
; 3504 :     };
; 3505 : 
; 3506 :     _EXPORT_STD template <class _Rng>
; 3507 :     concept common_range = range<_Rng> && same_as<iterator_t<_Rng>, sentinel_t<_Rng>>;
; 3508 : 
; 3509 :     template <class _It, class _Se>
; 3510 :     concept _Bidi_common = is_same_v<_It, _Se> && bidirectional_iterator<_It>;
; 3511 :     template <class _Rng>
; 3512 :     concept _Bidi_common_range = common_range<_Rng> && bidirectional_iterator<iterator_t<_Rng>>;
; 3513 : 
; 3514 :     template <class _Ty>
; 3515 :     concept _Can_empty = requires(_Ty __t) { _RANGES empty(__t); };
; 3516 : 
; 3517 :     _EXPORT_STD template <class _Derived>
; 3518 :         requires is_class_v<_Derived> && same_as<_Derived, remove_cv_t<_Derived>>
; 3519 :     class view_interface {
; 3520 :     private:
; 3521 :         _NODISCARD constexpr _Derived& _Cast() noexcept {
; 3522 :             static_assert(derived_from<_Derived, view_interface>,
; 3523 :                 "view_interface's template argument D must derive from view_interface<D> "
; 3524 :                 "(N4950 [view.interface.general]/2).");
; 3525 :             static_assert(view<_Derived>,
; 3526 :                 "view_interface's template argument must model the view concept (N4950 [view.interface.general]/2).");
; 3527 :             return static_cast<_Derived&>(*this);
; 3528 :         }
; 3529 : 
; 3530 :         _NODISCARD constexpr const _Derived& _Cast() const noexcept {
; 3531 :             static_assert(derived_from<_Derived, view_interface>,
; 3532 :                 "view_interface's template argument D must derive from view_interface<D> "
; 3533 :                 "(N4950 [view.interface.general]/2).");
; 3534 :             static_assert(view<_Derived>,
; 3535 :                 "view_interface's template argument must model the view concept (N4950 [view.interface.general]/2).");
; 3536 :             return static_cast<const _Derived&>(*this);
; 3537 :         }
; 3538 : 
; 3539 :     public:
; 3540 :         _NODISCARD constexpr bool empty()
; 3541 :             requires sized_range<_Derived> || forward_range<_Derived>
; 3542 :         {
; 3543 :             auto& _Self = _Cast();
; 3544 :             if constexpr (sized_range<_Derived>) {
; 3545 :                 return _RANGES size(_Self) == 0;
; 3546 :             } else {
; 3547 :                 return _RANGES begin(_Self) == _RANGES end(_Self);
; 3548 :             }
; 3549 :         }
; 3550 : 
; 3551 :         _NODISCARD constexpr bool empty() const
; 3552 :             requires sized_range<const _Derived> || forward_range<const _Derived>
; 3553 :         {
; 3554 :             auto& _Self = _Cast();
; 3555 :             if constexpr (sized_range<const _Derived>) {
; 3556 :                 return _RANGES size(_Self) == 0;
; 3557 :             } else {
; 3558 :                 return _RANGES begin(_Self) == _RANGES end(_Self);
; 3559 :             }
; 3560 :         }
; 3561 : 
; 3562 : #if _HAS_CXX23
; 3563 :         _NODISCARD constexpr auto cbegin()
; 3564 :             requires input_range<_Derived>
; 3565 :         {
; 3566 :             return _RANGES cbegin(_Cast());
; 3567 :         }
; 3568 : 
; 3569 :         _NODISCARD constexpr auto cbegin() const
; 3570 :             requires input_range<const _Derived>
; 3571 :         {
; 3572 :             return _RANGES cbegin(_Cast());
; 3573 :         }
; 3574 : 
; 3575 :         _NODISCARD constexpr auto cend()
; 3576 :             requires input_range<_Derived>
; 3577 :         {
; 3578 :             return _RANGES cend(_Cast());
; 3579 :         }
; 3580 : 
; 3581 :         _NODISCARD constexpr auto cend() const
; 3582 :             requires input_range<const _Derived>
; 3583 :         {
; 3584 :             return _RANGES cend(_Cast());
; 3585 :         }
; 3586 : #endif // _HAS_CXX23
; 3587 : 
; 3588 :         constexpr explicit operator bool()
; 3589 :             requires _Can_empty<_Derived>
; 3590 :         {
; 3591 :             return !_RANGES empty(_Cast());
; 3592 :         }
; 3593 : 
; 3594 :         constexpr explicit operator bool() const
; 3595 :             requires _Can_empty<const _Derived>
; 3596 :         {
; 3597 :             return !_RANGES empty(_Cast());
; 3598 :         }
; 3599 : 
; 3600 :         _NODISCARD constexpr auto data()
; 3601 :             requires contiguous_iterator<iterator_t<_Derived>>
; 3602 :         {
; 3603 :             return _STD to_address(_RANGES begin(_Cast()));
; 3604 :         }
; 3605 : 
; 3606 :         _NODISCARD constexpr auto data() const
; 3607 :             requires range<const _Derived> && contiguous_iterator<iterator_t<const _Derived>>
; 3608 :         {
; 3609 :             return _STD to_address(_RANGES begin(_Cast()));
; 3610 :         }
; 3611 : 
; 3612 :         _NODISCARD constexpr auto size()
; 3613 :             requires forward_range<_Derived> && sized_sentinel_for<sentinel_t<_Derived>, iterator_t<_Derived>>
; 3614 :         {
; 3615 :             auto& _Self = _Cast();
; 3616 :             return _STD _To_unsigned_like(_RANGES end(_Self) - _RANGES begin(_Self));
; 3617 :         }
; 3618 : 
; 3619 :         _NODISCARD constexpr auto size() const
; 3620 :             requires forward_range<const _Derived>
; 3621 :                   && sized_sentinel_for<sentinel_t<const _Derived>, iterator_t<const _Derived>>
; 3622 :         {
; 3623 :             auto& _Self = _Cast();
; 3624 :             return _STD _To_unsigned_like(_RANGES end(_Self) - _RANGES begin(_Self));
; 3625 :         }
; 3626 : 
; 3627 :         _NODISCARD constexpr decltype(auto) front()
; 3628 :             requires forward_range<_Derived>
; 3629 :         {
; 3630 :             auto& _Self = _Cast();
; 3631 : #if _CONTAINER_DEBUG_LEVEL > 0
; 3632 :             _STL_VERIFY(!_RANGES empty(_Self), "front called on empty view_interface");
; 3633 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 3634 :             return *_RANGES begin(_Self);
; 3635 :         }
; 3636 : 
; 3637 :         _NODISCARD constexpr decltype(auto) front() const
; 3638 :             requires forward_range<const _Derived>
; 3639 :         {
; 3640 :             auto& _Self = _Cast();
; 3641 : #if _CONTAINER_DEBUG_LEVEL > 0
; 3642 :             _STL_VERIFY(!_RANGES empty(_Self), "front called on empty view_interface");
; 3643 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 3644 :             return *_RANGES begin(_Self);
; 3645 :         }
; 3646 : 
; 3647 :         _NODISCARD constexpr decltype(auto) back()
; 3648 :             requires bidirectional_range<_Derived> && common_range<_Derived>
; 3649 :         {
; 3650 :             auto& _Self = _Cast();
; 3651 : #if _CONTAINER_DEBUG_LEVEL > 0
; 3652 :             _STL_VERIFY(!_RANGES empty(_Self), "back called on empty view_interface");
; 3653 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 3654 :             auto _Last = _RANGES end(_Self);
; 3655 :             return *--_Last;
; 3656 :         }
; 3657 : 
; 3658 :         _NODISCARD constexpr decltype(auto) back() const
; 3659 :             requires bidirectional_range<const _Derived> && common_range<const _Derived>
; 3660 :         {
; 3661 :             auto& _Self = _Cast();
; 3662 : #if _CONTAINER_DEBUG_LEVEL > 0
; 3663 :             _STL_VERIFY(!_RANGES empty(_Self), "back called on empty view_interface");
; 3664 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 3665 :             auto _Last = _RANGES end(_Self);
; 3666 :             return *--_Last;
; 3667 :         }
; 3668 : 
; 3669 :         template <random_access_range _Rng = _Derived>
; 3670 :         _NODISCARD constexpr decltype(auto) operator[](const range_difference_t<_Rng> _Idx) {
; 3671 :             auto& _Self = _Cast();
; 3672 : #if _CONTAINER_DEBUG_LEVEL > 0
; 3673 :             if constexpr (sized_range<_Derived>) {
; 3674 :                 using _U_diff = _Make_unsigned_like_t<range_difference_t<_Rng>>;
; 3675 :                 _STL_VERIFY(static_cast<_U_diff>(_Idx) < static_cast<_U_diff>(_RANGES size(_Self)),
; 3676 :                     "index out of range for view_interface");
; 3677 :             }
; 3678 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 3679 :             return _RANGES begin(_Self)[_Idx];
; 3680 :         }
; 3681 : 
; 3682 :         template <random_access_range _Rng = const _Derived>
; 3683 :         _NODISCARD constexpr decltype(auto) operator[](const range_difference_t<_Rng> _Idx) const {
; 3684 :             auto& _Self = _Cast();
; 3685 : #if _CONTAINER_DEBUG_LEVEL > 0
; 3686 :             if constexpr (sized_range<_Derived>) {
; 3687 :                 using _U_diff = _Make_unsigned_like_t<range_difference_t<_Rng>>;
; 3688 :                 _STL_VERIFY(static_cast<_U_diff>(_Idx) < static_cast<_U_diff>(_RANGES size(_Self)),
; 3689 :                     "index out of range for view_interface");
; 3690 :             }
; 3691 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 3692 :             return _RANGES begin(_Self)[_Idx];
; 3693 :         }
; 3694 :     };
; 3695 : } // namespace ranges
; 3696 : 
; 3697 : namespace ranges {
; 3698 :     template <class _From, class _To>
; 3699 :     concept _Uses_nonqualification_pointer_conversion =
; 3700 :         is_pointer_v<_From> && is_pointer_v<_To>
; 3701 :         && (!convertible_to<remove_pointer_t<_From> (*)[], remove_pointer_t<_To> (*)[]>);
; 3702 : 
; 3703 :     template <class _From, class _To>
; 3704 :     concept _Convertible_to_non_slicing =
; 3705 :         convertible_to<_From, _To> && (!_Uses_nonqualification_pointer_conversion<decay_t<_From>, decay_t<_To>>);
; 3706 : 
; 3707 : #if !_HAS_CXX23
; 3708 :     template <class _Ty>
; 3709 :     concept _Pair_like = (!is_reference_v<_Ty>) &&requires(_Ty __t) {
; 3710 :         typename tuple_size<_Ty>::type;
; 3711 :         requires derived_from<tuple_size<_Ty>, integral_constant<size_t, 2>>;
; 3712 :         typename tuple_element_t<0, remove_const_t<_Ty>>;
; 3713 :         typename tuple_element_t<1, remove_const_t<_Ty>>;
; 3714 :         { _STD get<0>(__t) } -> convertible_to<const tuple_element_t<0, _Ty>&>;
; 3715 :         { _STD get<1>(__t) } -> convertible_to<const tuple_element_t<1, _Ty>&>;
; 3716 :     };
; 3717 : #endif // !_HAS_CXX23
; 3718 : 
; 3719 :     template <class _Ty, class _First, class _Second>
; 3720 :     concept _Pair_like_convertible_from =
; 3721 :         (!range<_Ty>)
; 3722 : #if _HAS_CXX23
; 3723 :         &&(!is_reference_v<_Ty>)
; 3724 : #endif // _HAS_CXX23
; 3725 :         &&_Pair_like<_Ty>
; 3726 :         && constructible_from<_Ty, _First, _Second> && _Convertible_to_non_slicing<_First, tuple_element_t<0, _Ty>>
; 3727 :         && convertible_to<_Second, tuple_element_t<1, _Ty>>;
; 3728 : 
; 3729 :     template <class _It, class _Se, subrange_kind _Ki>
; 3730 :     concept _Store_size = (_Ki == subrange_kind::sized) && (!sized_sentinel_for<_Se, _It>);
; 3731 : 
; 3732 :     template <class _It, class _Se, subrange_kind _Ki>
; 3733 :     class _Subrange_base : public view_interface<subrange<_It, _Se, _Ki>> {
; 3734 :     protected:
; 3735 :         using _Size_type = _Make_unsigned_like_t<iter_difference_t<_It>>;
; 3736 : 
; 3737 :     public:
; 3738 :         _Subrange_base() = default;
; 3739 :         constexpr explicit _Subrange_base(const _Size_type&) noexcept {}
; 3740 :     };
; 3741 : 
; 3742 :     template <class _It, class _Se, subrange_kind _Ki>
; 3743 :         requires _Store_size<_It, _Se, _Ki>
; 3744 :     class _Subrange_base<_It, _Se, _Ki> : public view_interface<subrange<_It, _Se, _Ki>> {
; 3745 :     protected:
; 3746 :         using _Size_type = _Make_unsigned_like_t<iter_difference_t<_It>>;
; 3747 : 
; 3748 :         _Size_type _Size = 0;
; 3749 : 
; 3750 :     public:
; 3751 :         _Subrange_base() = default;
; 3752 :         constexpr explicit _Subrange_base(const _Size_type& _Size_) noexcept : _Size(_Size_) {}
; 3753 :     };
; 3754 : 
; 3755 : #if 1 // TRANSITION, VSO-1695918 - Warning C4324 incorrectly firing in the presence of `pragma pack`
; 3756 : #pragma warning(push)
; 3757 : #pragma warning(disable : 4324) // structure was padded due to alignment specifier
; 3758 : #endif // ^^^ workaround ^^^
; 3759 :     _EXPORT_STD template <input_or_output_iterator _It, sentinel_for<_It> _Se, subrange_kind _Ki>
; 3760 :         requires (_Ki == subrange_kind::sized || !sized_sentinel_for<_Se, _It>)
; 3761 :     class subrange : public _Subrange_base<_It, _Se, _Ki> {
; 3762 :     private:
; 3763 :         using _Size_type = _Make_unsigned_like_t<iter_difference_t<_It>>;
; 3764 : 
; 3765 :         // TRANSITION, [[no_unique_address]]:
; 3766 :         /* [[no_unique_address]] */ _It _First{};
; 3767 :         /* [[no_unique_address]] */ _Se _Last{};
; 3768 :         // [[no_unique_address]] conditional_t<_Store_size<_It, _Se, _Ki>, _Size_type, _Nil> _Size{};
; 3769 : 
; 3770 :         template <class _Rng>
; 3771 :         constexpr subrange(true_type, _Rng&& _Val)
; 3772 :             : subrange(_STD forward<_Rng>(_Val), static_cast<_Size_type>(_RANGES size(_Val))) {
; 3773 :             // delegation target for subrange(_Rng&&) when we must store the range size
; 3774 :             _STL_INTERNAL_STATIC_ASSERT(_Store_size<_It, _Se, _Ki>);
; 3775 :         }
; 3776 : 
; 3777 :         template <class _Rng>
; 3778 :         constexpr subrange(false_type, _Rng&& _Val) : subrange(_RANGES begin(_Val), _RANGES end(_Val)) {
; 3779 :             // delegation target for subrange(_Rng&&) when we need not store the range size
; 3780 :             _STL_INTERNAL_STATIC_ASSERT(!_Store_size<_It, _Se, _Ki>);
; 3781 :         }
; 3782 : 
; 3783 :     public:
; 3784 :         // clang-format off
; 3785 :         subrange() requires default_initializable<_It> = default;
; 3786 :         // clang-format on
; 3787 : 
; 3788 :         template <_Convertible_to_non_slicing<_It> _It2>
; 3789 :         constexpr subrange(_It2 _First_, _Se _Last_)
; 3790 :             requires (!_Store_size<_It, _Se, _Ki>)
; 3791 :             : _First(_STD move(_First_)), _Last(_STD move(_Last_)) {}
; 3792 : 
; 3793 :         template <_Convertible_to_non_slicing<_It> _It2>
; 3794 :         constexpr subrange(_It2 _First_, _Se _Last_, const _Size_type _Size_)
; 3795 :             requires (_Ki == subrange_kind::sized)
; 3796 :             : _Subrange_base<_It, _Se, _Ki>(_Size_), _First(_STD move(_First_)), _Last(_STD move(_Last_)) {
; 3797 :             if constexpr (sized_sentinel_for<_Se, _It>) {
; 3798 :                 _STL_ASSERT(_Size_ == static_cast<_Size_type>(_Last - _First),
; 3799 :                     "This constructor's third argument should be equal to the distance "
; 3800 :                     "between the first and second arguments (N4950 [range.subrange.ctor]/3).");
; 3801 :             }
; 3802 :         }
; 3803 : 
; 3804 :         template <_Different_from<subrange> _Rng>
; 3805 :             requires (borrowed_range<_Rng> && _Convertible_to_non_slicing<iterator_t<_Rng>, _It>
; 3806 :                       && convertible_to<sentinel_t<_Rng>, _Se>)
; 3807 :         constexpr subrange(_Rng&& _Val)
; 3808 :             requires (!_Store_size<_It, _Se, _Ki> || sized_range<_Rng>)
; 3809 :             : subrange{bool_constant<_Store_size<_It, _Se, _Ki>>{}, _STD forward<_Rng>(_Val)} {}
; 3810 : 
; 3811 :         template <borrowed_range _Rng>
; 3812 :             requires (_Convertible_to_non_slicing<iterator_t<_Rng>, _It> && convertible_to<sentinel_t<_Rng>, _Se>)
; 3813 :         constexpr subrange(_Rng&& _Val, const _Size_type _Count)
; 3814 :             requires (_Ki == subrange_kind::sized)
; 3815 :             : subrange{_RANGES begin(_Val), _RANGES end(_Val), _Count} {}
; 3816 : 
; 3817 :         template <_Different_from<subrange> _Pair_like>
; 3818 :             requires _Pair_like_convertible_from<_Pair_like, const _It&, const _Se&>
; 3819 :         constexpr operator _Pair_like() const {
; 3820 :             return _Pair_like(_First, _Last);
; 3821 :         }
; 3822 : 
; 3823 :         _NODISCARD constexpr _It begin() const
; 3824 :             requires copyable<_It>
; 3825 :         {
; 3826 :             return _First;
; 3827 :         }
; 3828 :         _NODISCARD constexpr _It begin()
; 3829 :             requires (!copyable<_It>)
; 3830 :         {
; 3831 :             return _STD move(_First);
; 3832 :         }
; 3833 : 
; 3834 :         _NODISCARD constexpr _Se end() const {
; 3835 :             return _Last;
; 3836 :         }
; 3837 : 
; 3838 :         _NODISCARD constexpr bool empty() const {
; 3839 :             return _First == _Last;
; 3840 :         }
; 3841 : 
; 3842 :         _NODISCARD constexpr _Size_type size() const
; 3843 :             requires (_Ki == subrange_kind::sized)
; 3844 :         {
; 3845 :             if constexpr (_Store_size<_It, _Se, _Ki>) {
; 3846 :                 return this->_Size;
; 3847 :             } else {
; 3848 :                 return static_cast<_Size_type>(_Last - _First);
; 3849 :             }
; 3850 :         }
; 3851 : 
; 3852 :         _NODISCARD constexpr subrange next() const&
; 3853 :             requires forward_iterator<_It>
; 3854 :         {
; 3855 :             auto _Tmp = *this;
; 3856 :             if (_Tmp._First != _Tmp._Last) {
; 3857 :                 ++_Tmp._First;
; 3858 :                 if constexpr (_Store_size<_It, _Se, _Ki>) {
; 3859 :                     --_Tmp._Size;
; 3860 :                 }
; 3861 :             }
; 3862 :             return _Tmp;
; 3863 :         }
; 3864 :         _NODISCARD constexpr subrange next(const iter_difference_t<_It> _Count) const&
; 3865 :             requires forward_iterator<_It>
; 3866 :         {
; 3867 :             auto _Tmp = *this;
; 3868 :             _Tmp.advance(_Count);
; 3869 :             return _Tmp;
; 3870 :         }
; 3871 : 
; 3872 :         _NODISCARD constexpr subrange next() && {
; 3873 :             if (_First != _Last) {
; 3874 :                 ++_First;
; 3875 :                 if constexpr (_Store_size<_It, _Se, _Ki>) {
; 3876 :                     --this->_Size;
; 3877 :                 }
; 3878 :             }
; 3879 :             return _STD move(*this);
; 3880 :         }
; 3881 :         _NODISCARD constexpr subrange next(const iter_difference_t<_It> _Count) && {
; 3882 :             advance(_Count);
; 3883 :             return _STD move(*this);
; 3884 :         }
; 3885 : 
; 3886 :         _NODISCARD constexpr subrange prev() const
; 3887 :             requires bidirectional_iterator<_It>
; 3888 :         {
; 3889 :             auto _Tmp = *this;
; 3890 :             --_Tmp._First;
; 3891 :             if constexpr (_Store_size<_It, _Se, _Ki>) {
; 3892 :                 ++_Tmp._Size;
; 3893 :             }
; 3894 :             return _Tmp;
; 3895 :         }
; 3896 :         _NODISCARD constexpr subrange prev(const iter_difference_t<_It> _Count) const
; 3897 :             requires bidirectional_iterator<_It>
; 3898 :         {
; 3899 :             auto _Tmp = *this;
; 3900 :             _Tmp.advance(-_Count);
; 3901 :             return _Tmp;
; 3902 :         }
; 3903 : 
; 3904 :         constexpr subrange& advance(const iter_difference_t<_It> _Count) {
; 3905 :             if constexpr (bidirectional_iterator<_It>) {
; 3906 :                 if (_Count < 0) {
; 3907 :                     _RANGES advance(_First, _Count);
; 3908 :                     if constexpr (_Store_size<_It, _Se, _Ki>) {
; 3909 :                         this->_Size += static_cast<_Size_type>(-_Count);
; 3910 :                     }
; 3911 :                     return *this;
; 3912 :                 }
; 3913 :             }
; 3914 : 
; 3915 :             const auto _Remainder = _RANGES advance(_First, _Count, _Last);
; 3916 :             if constexpr (_Store_size<_It, _Se, _Ki>) {
; 3917 :                 this->_Size -= static_cast<_Size_type>(_Count - _Remainder);
; 3918 :             }
; 3919 :             return *this;
; 3920 :         }
; 3921 :     };
; 3922 : #if 1 // TRANSITION, VSO-1695918 - Warning C4324 incorrectly firing in the presence of `pragma pack`
; 3923 : #pragma warning(pop)
; 3924 : #endif // ^^^ workaround ^^^
; 3925 : 
; 3926 :     template <input_or_output_iterator _It, sentinel_for<_It> _Se>
; 3927 :     subrange(_It, _Se) -> subrange<_It, _Se>;
; 3928 : 
; 3929 :     template <input_or_output_iterator _It, sentinel_for<_It> _Se>
; 3930 :     subrange(_It, _Se, _Make_unsigned_like_t<iter_difference_t<_It>>) -> subrange<_It, _Se, subrange_kind::sized>;
; 3931 : 
; 3932 :     template <borrowed_range _Rng>
; 3933 :     subrange(_Rng&&) -> subrange<iterator_t<_Rng>, sentinel_t<_Rng>,
; 3934 :         (sized_range<_Rng> || sized_sentinel_for<sentinel_t<_Rng>, iterator_t<_Rng>>) ? subrange_kind::sized
; 3935 :                                                                                       : subrange_kind::unsized>;
; 3936 : 
; 3937 :     template <borrowed_range _Rng>
; 3938 :     subrange(_Rng&&, _Make_unsigned_like_t<range_difference_t<_Rng>>)
; 3939 :         -> subrange<iterator_t<_Rng>, sentinel_t<_Rng>, subrange_kind::sized>;
; 3940 : 
; 3941 :     template <class _It, class _Se, subrange_kind _Ki>
; 3942 :     inline constexpr bool enable_borrowed_range<subrange<_It, _Se, _Ki>> = true;
; 3943 : 
; 3944 :     _EXPORT_STD template <size_t _Idx, class _It, class _Se, subrange_kind _Ki>
; 3945 :         requires ((_Idx == 0 && copyable<_It>) || _Idx == 1)
; 3946 :     _NODISCARD constexpr auto get(const subrange<_It, _Se, _Ki>& _Val) {
; 3947 :         if constexpr (_Idx == 0) {
; 3948 :             return _Val.begin();
; 3949 :         } else {
; 3950 :             return _Val.end();
; 3951 :         }
; 3952 :     }
; 3953 : 
; 3954 :     _EXPORT_STD template <size_t _Idx, class _It, class _Se, subrange_kind _Ki>
; 3955 :         requires (_Idx < 2)
; 3956 :     _NODISCARD constexpr auto get(subrange<_It, _Se, _Ki>&& _Val) {
; 3957 :         if constexpr (_Idx == 0) {
; 3958 :             return _Val.begin();
; 3959 :         } else {
; 3960 :             return _Val.end();
; 3961 :         }
; 3962 :     }
; 3963 : 
; 3964 :     _EXPORT_STD struct dangling {
; 3965 :         constexpr dangling() noexcept = default;
; 3966 :         template <class... _Args>
; 3967 :         constexpr dangling(_Args&&...) noexcept {}
; 3968 :     };
; 3969 : 
; 3970 :     _EXPORT_STD template <range _Rng>
; 3971 :     using borrowed_iterator_t = conditional_t<borrowed_range<_Rng>, iterator_t<_Rng>, dangling>;
; 3972 : 
; 3973 :     _EXPORT_STD template <range _Rng>
; 3974 :     using borrowed_subrange_t = conditional_t<borrowed_range<_Rng>, subrange<iterator_t<_Rng>>, dangling>;
; 3975 : } // namespace ranges
; 3976 : #endif // __cpp_lib_concepts
; 3977 : 
; 3978 : struct _Container_proxy;
; 3979 : struct _Iterator_base12;
; 3980 : 
; 3981 : struct _Default_sentinel {}; // empty struct to serve as the end of a range
; 3982 : 
; 3983 : #ifdef __cpp_lib_concepts
; 3984 : _EXPORT_STD template <semiregular>
; 3985 : class move_sentinel;
; 3986 : 
; 3987 : template <class>
; 3988 : struct _Move_iterator_category {};
; 3989 : 
; 3990 : // clang-format off
; 3991 : template <class _Iter>
; 3992 :     requires requires { typename _Iter_cat_t<_Iter>; }
; 3993 : struct _Move_iterator_category<_Iter> {
; 3994 :     using iterator_category = conditional_t<derived_from<_Iter_cat_t<_Iter>, random_access_iterator_tag>,
; 3995 :         random_access_iterator_tag, _Iter_cat_t<_Iter>>;
; 3996 : };
; 3997 : // clang-format on
; 3998 : #else // ^^^ Ranges / no Ranges vvv
; 3999 : template <class _Iter>
; 4000 : struct _Move_iterator_category {
; 4001 :     using iterator_category = _Iter_cat_t<_Iter>;
; 4002 : };
; 4003 : #endif // __cpp_lib_concepts
; 4004 : 
; 4005 : _EXPORT_STD template <class _Iter>
; 4006 : class move_iterator : public _Move_iterator_category<_Iter> {
; 4007 : public:
; 4008 :     using iterator_type   = _Iter;
; 4009 :     using value_type      = _Iter_value_t<_Iter>;
; 4010 :     using difference_type = _Iter_diff_t<_Iter>;
; 4011 :     using pointer         = _Iter;
; 4012 : 
; 4013 : #ifdef __cpp_lib_concepts
; 4014 : private:
; 4015 :     static constexpr auto _Get_iter_concept() {
; 4016 :         if constexpr (random_access_iterator<_Iter>) {
; 4017 :             return random_access_iterator_tag{};
; 4018 :         } else if constexpr (bidirectional_iterator<_Iter>) {
; 4019 :             return bidirectional_iterator_tag{};
; 4020 :         } else if constexpr (forward_iterator<_Iter>) {
; 4021 :             return forward_iterator_tag{};
; 4022 :         } else {
; 4023 :             return input_iterator_tag{};
; 4024 :         }
; 4025 :     }
; 4026 : 
; 4027 : public:
; 4028 :     using iterator_concept = decltype(_Get_iter_concept());
; 4029 : 
; 4030 :     using reference = iter_rvalue_reference_t<_Iter>;
; 4031 : #else // ^^^ __cpp_lib_concepts / !__cpp_lib_concepts vvv
; 4032 :     using reference =
; 4033 :         conditional_t<is_reference_v<_Iter_ref_t<_Iter>>, remove_reference_t<_Iter_ref_t<_Iter>>&&, _Iter_ref_t<_Iter>>;
; 4034 : #endif // __cpp_lib_concepts
; 4035 : 
; 4036 :     _CONSTEXPR17 move_iterator() = default;
; 4037 : 
; 4038 :     _CONSTEXPR17 explicit move_iterator(_Iter _Right) noexcept(is_nothrow_move_constructible_v<_Iter>) // strengthened
; 4039 :         : _Current(_STD move(_Right)) {}
; 4040 : 
; 4041 :     // clang-format off
; 4042 :     template <class _Other>
; 4043 : #ifdef __cpp_lib_concepts
; 4044 :         requires (!is_same_v<_Other, _Iter>) && convertible_to<const _Other&, _Iter>
; 4045 : #endif // __cpp_lib_concepts
; 4046 :     _CONSTEXPR17 move_iterator(const move_iterator<_Other>& _Right) noexcept(
; 4047 :         is_nothrow_constructible_v<_Iter, const _Other&>) // strengthened
; 4048 :         : _Current(_Right.base()) {}
; 4049 : 
; 4050 :     template <class _Other>
; 4051 : #ifdef __cpp_lib_concepts
; 4052 :         requires (!is_same_v<_Other, _Iter>) && convertible_to<const _Other&, _Iter>
; 4053 :             && assignable_from<_Iter&, const _Other&>
; 4054 : #endif // __cpp_lib_concepts
; 4055 :     _CONSTEXPR17 move_iterator& operator=(const move_iterator<_Other>& _Right) noexcept(
; 4056 :         is_nothrow_assignable_v<_Iter&, const _Other&>) /* strengthened */ {
; 4057 :         _Current = _Right.base();
; 4058 :         return *this;
; 4059 :     }
; 4060 :     // clang-format on
; 4061 : 
; 4062 : #ifdef __cpp_lib_concepts
; 4063 :     _NODISCARD constexpr const iterator_type& base() const& noexcept {
; 4064 :         return _Current;
; 4065 :     }
; 4066 :     _NODISCARD constexpr iterator_type base() && noexcept(is_nothrow_move_constructible_v<_Iter>) /* strengthened */ {
; 4067 :         return _STD move(_Current);
; 4068 :     }
; 4069 : #else // ^^^ __cpp_lib_concepts / !__cpp_lib_concepts vvv
; 4070 :     _NODISCARD _CONSTEXPR17 iterator_type base() const
; 4071 :         noexcept(is_nothrow_copy_constructible_v<_Iter>) /* strengthened */ {
; 4072 :         return _Current;
; 4073 :     }
; 4074 : #endif // __cpp_lib_concepts
; 4075 : 
; 4076 :     _NODISCARD _CONSTEXPR17 reference operator*() const
; 4077 : #ifdef __cpp_lib_concepts
; 4078 :         noexcept(noexcept(_RANGES iter_move(_Current))) /* strengthened */ {
; 4079 :         return _RANGES iter_move(_Current);
; 4080 :     }
; 4081 : #else // ^^^ __cpp_lib_concepts / !__cpp_lib_concepts vvv
; 4082 :         noexcept(noexcept(static_cast<reference>(*_Current))) /* strengthened */ {
; 4083 :         return static_cast<reference>(*_Current);
; 4084 :     }
; 4085 : #endif // __cpp_lib_concepts
; 4086 : 
; 4087 :     _CXX20_DEPRECATE_MOVE_ITERATOR_ARROW _NODISCARD _CONSTEXPR17 pointer operator->() const
; 4088 :         noexcept(is_nothrow_copy_constructible_v<_Iter>) /* strengthened */ {
; 4089 :         return _Current;
; 4090 :     }
; 4091 : 
; 4092 :     _CONSTEXPR17 move_iterator& operator++() noexcept(noexcept(++_Current)) /* strengthened */ {
; 4093 :         ++_Current;
; 4094 :         return *this;
; 4095 :     }
; 4096 : 
; 4097 :     _CONSTEXPR17 auto operator++(int) noexcept(
; 4098 :         is_nothrow_copy_constructible_v<_Iter>&& noexcept(++_Current)) /* strengthened */ {
; 4099 : #ifdef __cpp_lib_concepts
; 4100 :         if constexpr (forward_iterator<_Iter>) {
; 4101 : #endif // __cpp_lib_concepts
; 4102 :             move_iterator _Tmp = *this;
; 4103 :             ++_Current;
; 4104 :             return _Tmp;
; 4105 : #ifdef __cpp_lib_concepts
; 4106 :         } else {
; 4107 :             ++_Current;
; 4108 :         }
; 4109 : #endif // __cpp_lib_concepts
; 4110 :     }
; 4111 : 
; 4112 :     _CONSTEXPR17 move_iterator& operator--() noexcept(noexcept(--_Current)) /* strengthened */ {
; 4113 :         --_Current;
; 4114 :         return *this;
; 4115 :     }
; 4116 : 
; 4117 :     _CONSTEXPR17 move_iterator operator--(int) noexcept(
; 4118 :         is_nothrow_copy_constructible_v<_Iter>&& noexcept(--_Current)) /* strengthened */ {
; 4119 :         move_iterator _Tmp = *this;
; 4120 :         --_Current;
; 4121 :         return _Tmp;
; 4122 :     }
; 4123 : 
; 4124 :     template <class _Iter2 = _Iter>
; 4125 :     _NODISCARD auto operator==(_Default_sentinel _Sentinel) const noexcept
; 4126 :         -> decltype(_STD declval<const _Iter2&>() == _Sentinel) {
; 4127 :         return _Current == _Sentinel;
; 4128 :     }
; 4129 : 
; 4130 :     template <class _Iter2 = _Iter>
; 4131 :     _NODISCARD auto operator!=(_Default_sentinel _Sentinel) const noexcept
; 4132 :         -> decltype(_STD declval<const _Iter2&>() != _Sentinel) {
; 4133 :         return _Current != _Sentinel;
; 4134 :     }
; 4135 : 
; 4136 :     _NODISCARD _CONSTEXPR17 move_iterator operator+(const difference_type _Off) const
; 4137 :         noexcept(noexcept(move_iterator(_Current + _Off))) /* strengthened */ {
; 4138 :         return move_iterator(_Current + _Off);
; 4139 :     }
; 4140 : 
; 4141 :     _CONSTEXPR17 move_iterator& operator+=(const difference_type _Off) noexcept(
; 4142 :         noexcept(_Current += _Off)) /* strengthened */ {
; 4143 :         _Current += _Off;
; 4144 :         return *this;
; 4145 :     }
; 4146 : 
; 4147 :     _NODISCARD _CONSTEXPR17 move_iterator operator-(const difference_type _Off) const
; 4148 :         noexcept(noexcept(move_iterator(_Current - _Off))) /* strengthened */ {
; 4149 :         return move_iterator(_Current - _Off);
; 4150 :     }
; 4151 : 
; 4152 :     _CONSTEXPR17 move_iterator& operator-=(const difference_type _Off) noexcept(
; 4153 :         noexcept(_Current -= _Off)) /* strengthened */ {
; 4154 :         _Current -= _Off;
; 4155 :         return *this;
; 4156 :     }
; 4157 : 
; 4158 :     _NODISCARD _CONSTEXPR17 reference operator[](const difference_type _Off) const
; 4159 : #ifdef __cpp_lib_concepts
; 4160 :         noexcept(noexcept(_RANGES iter_move(_Current + _Off))) /* strengthened */ {
; 4161 :         return _RANGES iter_move(_Current + _Off);
; 4162 : #else // ^^^ __cpp_lib_concepts / !__cpp_lib_concepts vvv
; 4163 :         noexcept(noexcept(_STD move(_Current[_Off]))) /* strengthened */ {
; 4164 :         return _STD move(_Current[_Off]);
; 4165 : #endif // __cpp_lib_concepts
; 4166 :     }
; 4167 : 
; 4168 : #ifdef __cpp_lib_concepts
; 4169 :     template <sentinel_for<_Iter> _Sent>
; 4170 :     _NODISCARD_FRIEND constexpr bool
; 4171 :         operator==(const move_iterator& _Left, const move_sentinel<_Sent>& _Right) noexcept(
; 4172 :             noexcept(_Fake_copy_init<bool>(_Left._Current == _Right._Get_last()))) /* strengthened */ {
; 4173 :         return _Left._Current == _Right._Get_last();
; 4174 :     }
; 4175 : 
; 4176 :     template <sized_sentinel_for<_Iter> _Sent>
; 4177 :     _NODISCARD_FRIEND constexpr difference_type operator-(const move_sentinel<_Sent>& _Left,
; 4178 :         const move_iterator& _Right) noexcept(noexcept(_Left._Get_last() - _Right._Current)) /* strengthened */ {
; 4179 :         return _Left._Get_last() - _Right._Current;
; 4180 :     }
; 4181 : 
; 4182 :     template <sized_sentinel_for<_Iter> _Sent>
; 4183 :     _NODISCARD_FRIEND constexpr difference_type operator-(const move_iterator& _Left,
; 4184 :         const move_sentinel<_Sent>& _Right) noexcept(noexcept(_Left._Current - _Right._Get_last())) /* strengthened */ {
; 4185 :         return _Left._Current - _Right._Get_last();
; 4186 :     }
; 4187 : 
; 4188 :     _NODISCARD_FRIEND constexpr reference iter_move(const move_iterator& _It)
; 4189 : #ifdef __EDG__ // TRANSITION, VSO-1222776
; 4190 :         noexcept(noexcept(_RANGES iter_move(_STD declval<const _Iter&>())))
; 4191 : #else // ^^^ workaround / no workaround vvv
; 4192 :         noexcept(noexcept(_RANGES iter_move(_It._Current)))
; 4193 : #endif // TRANSITION, VSO-1222776
; 4194 :     {
; 4195 :         return _RANGES iter_move(_It._Current);
; 4196 :     }
; 4197 : 
; 4198 :     template <indirectly_swappable<_Iter> _Iter2>
; 4199 :     friend constexpr void iter_swap(const move_iterator& _Left, const move_iterator<_Iter2>& _Right)
; 4200 : #ifdef __EDG__ // TRANSITION, VSO-1222776
; 4201 :         noexcept(noexcept(_RANGES iter_swap(_STD declval<const _Iter&>(), _STD declval<const _Iter2&>())))
; 4202 : #else // ^^^ workaround / no workaround vvv
; 4203 :         noexcept(noexcept(_RANGES iter_swap(_Left._Current, _Right.base())))
; 4204 : #endif // TRANSITION, VSO-1222776
; 4205 :     {
; 4206 :         _RANGES iter_swap(_Left._Current, _Right.base());
; 4207 :     }
; 4208 : #endif // __cpp_lib_concepts
; 4209 : 
; 4210 :     template <class _Iter2, enable_if_t<_Range_verifiable_v<_Iter, _Iter2>, int> = 0>
; 4211 :     friend constexpr void _Verify_range(const move_iterator& _First, const move_iterator<_Iter2>& _Last) noexcept {
; 4212 :         _Verify_range(_First._Current, _Last._Get_current());
; 4213 :     }
; 4214 : #ifdef __cpp_lib_concepts
; 4215 :     template <sentinel_for<_Iter> _Sent, enable_if_t<_Range_verifiable_v<_Iter, _Sent>, int> = 0>
; 4216 :     friend constexpr void _Verify_range(const move_iterator& _First, const move_sentinel<_Sent>& _Last) noexcept {
; 4217 :         _Verify_range(_First._Current, _Last._Get_last());
; 4218 :     }
; 4219 : #endif // __cpp_lib_concepts
; 4220 : 
; 4221 :     using _Prevent_inheriting_unwrap = move_iterator;
; 4222 : 
; 4223 :     template <class _Iter2 = iterator_type, enable_if_t<_Offset_verifiable_v<_Iter2>, int> = 0>
; 4224 :     constexpr void _Verify_offset(const difference_type _Off) const noexcept {
; 4225 :         _Current._Verify_offset(_Off);
; 4226 :     }
; 4227 : 
; 4228 :     template <class _Iter2 = iterator_type, enable_if_t<_Unwrappable_v<const _Iter2&>, int> = 0>
; 4229 :     _NODISCARD constexpr move_iterator<_Unwrapped_t<const _Iter2&>> _Unwrapped() const& noexcept(
; 4230 :         noexcept(static_cast<move_iterator<_Unwrapped_t<const _Iter2&>>>(_Current._Unwrapped()))) {
; 4231 :         return static_cast<move_iterator<_Unwrapped_t<const _Iter2&>>>(_Current._Unwrapped());
; 4232 :     }
; 4233 :     template <class _Iter2 = iterator_type, enable_if_t<_Unwrappable_v<_Iter2>, int> = 0>
; 4234 :     _NODISCARD constexpr move_iterator<_Unwrapped_t<_Iter2>> _Unwrapped() && noexcept(
; 4235 :         noexcept(static_cast<move_iterator<_Unwrapped_t<_Iter2>>>(_STD move(_Current)._Unwrapped()))) {
; 4236 :         return static_cast<move_iterator<_Unwrapped_t<_Iter2>>>(_STD move(_Current)._Unwrapped());
; 4237 :     }
; 4238 : 
; 4239 :     static constexpr bool _Unwrap_when_unverified = _Do_unwrap_when_unverified_v<iterator_type>;
; 4240 : 
; 4241 :     template <class _Src, enable_if_t<_Wrapped_seekable_v<iterator_type, const _Src&>, int> = 0>
; 4242 :     constexpr void _Seek_to(const move_iterator<_Src>& _It) noexcept(noexcept(_Current._Seek_to(_It._Get_current()))) {
; 4243 :         _Current._Seek_to(_It._Get_current());
; 4244 :     }
; 4245 :     template <class _Src, enable_if_t<_Wrapped_seekable_v<iterator_type, _Src>, int> = 0>
; 4246 :     constexpr void _Seek_to(move_iterator<_Src>&& _It) noexcept(
; 4247 :         noexcept(_Current._Seek_to(_STD move(_It)._Get_current()))) {
; 4248 :         _Current._Seek_to(_STD move(_It)._Get_current());
; 4249 :     }
; 4250 : 
; 4251 :     _NODISCARD constexpr const iterator_type& _Get_current() const& noexcept {
; 4252 :         return _Current;
; 4253 :     }
; 4254 :     _NODISCARD constexpr iterator_type&& _Get_current() && noexcept {
; 4255 :         return _STD move(_Current);
; 4256 :     }
; 4257 : 
; 4258 : private:
; 4259 :     iterator_type _Current{};
; 4260 : };
; 4261 : 
; 4262 : _EXPORT_STD template <class _Iter1, class _Iter2>
; 4263 : _NODISCARD _CONSTEXPR17 bool
; 4264 :     operator==(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right) noexcept(
; 4265 :         noexcept(_Fake_copy_init<bool>(_Left.base() == _Right.base()))) /* strengthened */
; 4266 : #ifdef __cpp_lib_concepts
; 4267 :     // clang-format off
; 4268 :     requires requires {
; 4269 :         { _Left.base() == _Right.base() } -> _Implicitly_convertible_to<bool>;
; 4270 :     }
; 4271 : // clang-format on
; 4272 : #endif // __cpp_lib_concepts
; 4273 : {
; 4274 :     return _Left.base() == _Right.base();
; 4275 : }
; 4276 : 
; 4277 : #if !_HAS_CXX20
; 4278 : template <class _Iter1, class _Iter2>
; 4279 : _NODISCARD _CONSTEXPR17 bool operator!=(const move_iterator<_Iter1>& _Left,
; 4280 :     const move_iterator<_Iter2>& _Right) noexcept(noexcept(_Left == _Right)) /* strengthened */ {
; 4281 :     return !(_Left == _Right);
; 4282 : }
; 4283 : #endif // !_HAS_CXX20
; 4284 : 
; 4285 : _EXPORT_STD template <class _Iter1, class _Iter2>
; 4286 : _NODISCARD _CONSTEXPR17 bool
; 4287 :     operator<(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right) noexcept(
; 4288 :         noexcept(_Fake_copy_init<bool>(_Left.base() < _Right.base()))) /* strengthened */
; 4289 : #ifdef __cpp_lib_concepts
; 4290 :     // clang-format off
; 4291 :     requires requires {
; 4292 :         { _Left.base() < _Right.base() } -> _Implicitly_convertible_to<bool>;
; 4293 :     }
; 4294 : // clang-format on
; 4295 : #endif // __cpp_lib_concepts
; 4296 : {
; 4297 :     return _Left.base() < _Right.base();
; 4298 : }
; 4299 : 
; 4300 : _EXPORT_STD template <class _Iter1, class _Iter2>
; 4301 : _NODISCARD _CONSTEXPR17 bool operator>(const move_iterator<_Iter1>& _Left,
; 4302 :     const move_iterator<_Iter2>& _Right) noexcept(noexcept(_Right < _Left)) /* strengthened */
; 4303 : #ifdef __cpp_lib_concepts
; 4304 :     requires requires { _Right < _Left; }
; 4305 : #endif // __cpp_lib_concepts
; 4306 : {
; 4307 :     return _Right < _Left;
; 4308 : }
; 4309 : 
; 4310 : _EXPORT_STD template <class _Iter1, class _Iter2>
; 4311 : _NODISCARD _CONSTEXPR17 bool operator<=(const move_iterator<_Iter1>& _Left,
; 4312 :     const move_iterator<_Iter2>& _Right) noexcept(noexcept(_Right < _Left)) /* strengthened */
; 4313 : #ifdef __cpp_lib_concepts
; 4314 :     requires requires { _Right < _Left; }
; 4315 : #endif // __cpp_lib_concepts
; 4316 : {
; 4317 :     return !(_Right < _Left);
; 4318 : }
; 4319 : 
; 4320 : _EXPORT_STD template <class _Iter1, class _Iter2>
; 4321 : _NODISCARD _CONSTEXPR17 bool operator>=(const move_iterator<_Iter1>& _Left,
; 4322 :     const move_iterator<_Iter2>& _Right) noexcept(noexcept(_Left < _Right)) /* strengthened */
; 4323 : #ifdef __cpp_lib_concepts
; 4324 :     requires requires { _Left < _Right; }
; 4325 : #endif // __cpp_lib_concepts
; 4326 : {
; 4327 :     return !(_Left < _Right);
; 4328 : }
; 4329 : 
; 4330 : #ifdef __cpp_lib_concepts
; 4331 : _EXPORT_STD template <class _Iter1, three_way_comparable_with<_Iter1> _Iter2>
; 4332 : _NODISCARD constexpr compare_three_way_result_t<_Iter1, _Iter2> operator<=>(const move_iterator<_Iter1>& _Left,
; 4333 :     const move_iterator<_Iter2>& _Right) noexcept(noexcept(_Left.base() <=> _Right.base())) /* strengthened */ {
; 4334 :     return _Left.base() <=> _Right.base();
; 4335 : }
; 4336 : #endif // __cpp_lib_concepts
; 4337 : 
; 4338 : _EXPORT_STD template <class _Iter1, class _Iter2>
; 4339 : _NODISCARD _CONSTEXPR17 auto operator-(const move_iterator<_Iter1>& _Left,
; 4340 :     const move_iterator<_Iter2>& _Right) noexcept(noexcept(_Left.base() - _Right.base())) /* strengthened */
; 4341 :     -> decltype(_Left.base() - _Right.base()) {
; 4342 :     return _Left.base() - _Right.base();
; 4343 : }
; 4344 : 
; 4345 : _EXPORT_STD template <class _Iter>
; 4346 : _NODISCARD _CONSTEXPR17 move_iterator<_Iter>
; 4347 :     operator+(typename move_iterator<_Iter>::difference_type _Off, const move_iterator<_Iter>& _Right) noexcept(
; 4348 :         noexcept(move_iterator<_Iter>(_Right.base() + _Off))) /* strengthened */
; 4349 : #ifdef __cpp_lib_concepts
; 4350 :     // clang-format off
; 4351 :     requires requires {
; 4352 :         { _Right.base() + _Off } -> same_as<_Iter>;
; 4353 :     }
; 4354 : // clang-format on
; 4355 : #endif // __cpp_lib_concepts
; 4356 : {
; 4357 :     return move_iterator<_Iter>(_Right.base() + _Off);
; 4358 : }
; 4359 : 
; 4360 : _EXPORT_STD template <class _Iter>
; 4361 : _NODISCARD _CONSTEXPR17 move_iterator<_Iter> make_move_iterator(_Iter _It) noexcept(
; 4362 :     is_nothrow_move_constructible_v<_Iter>) /* strengthened */ {
; 4363 :     return move_iterator<_Iter>(_STD move(_It));
; 4364 : }
; 4365 : 
; 4366 : #ifdef __cpp_lib_concepts
; 4367 : template <class _Iter1, class _Iter2>
; 4368 :     requires (!sized_sentinel_for<_Iter1, _Iter2>)
; 4369 : inline constexpr bool disable_sized_sentinel_for<move_iterator<_Iter1>, move_iterator<_Iter2>> = true;
; 4370 : 
; 4371 : _EXPORT_STD struct unreachable_sentinel_t;
; 4372 : namespace _Unreachable_sentinel_detail {
; 4373 :     struct _Base {
; 4374 :         template <weakly_incrementable _Winc>
; 4375 :         _NODISCARD_FRIEND constexpr bool operator==(const unreachable_sentinel_t&, const _Winc&) noexcept {
; 4376 :             return false;
; 4377 :         }
; 4378 :     };
; 4379 : } // namespace _Unreachable_sentinel_detail
; 4380 : _EXPORT_STD struct unreachable_sentinel_t : _Unreachable_sentinel_detail::_Base {}; // TRANSITION, /permissive-
; 4381 : 
; 4382 : _EXPORT_STD inline constexpr unreachable_sentinel_t unreachable_sentinel{};
; 4383 : #endif // __cpp_lib_concepts
; 4384 : 
; 4385 : // _Iterator_is_contiguous<_Iter> reports whether an iterator is known to be contiguous.
; 4386 : // (Without concepts, this detection is limited, which will limit when we can activate optimizations.)
; 4387 : 
; 4388 : #ifdef __cpp_lib_concepts
; 4389 : // When concepts are available, we can detect arbitrary contiguous iterators.
; 4390 : template <class _Iter>
; 4391 : inline constexpr bool _Iterator_is_contiguous = contiguous_iterator<_Iter>;
; 4392 : 
; 4393 : template <class _Iter>
; 4394 : _NODISCARD constexpr auto _To_address(const _Iter& _Val) noexcept {
; 4395 :     _STL_INTERNAL_STATIC_ASSERT(contiguous_iterator<_Iter>);
; 4396 :     return _STD to_address(_Val);
; 4397 : }
; 4398 : #else // ^^^ defined(__cpp_lib_concepts) / !defined(__cpp_lib_concepts) vvv
; 4399 : // When concepts aren't available, we can detect pointers. (Iterators should be unwrapped before using this.)
; 4400 : template <class _Iter>
; 4401 : _INLINE_VAR constexpr bool _Iterator_is_contiguous = is_pointer_v<_Iter>;
; 4402 : 
; 4403 : template <class _Iter>
; 4404 : _NODISCARD constexpr auto _To_address(const _Iter& _Val) noexcept {
; 4405 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 4406 :     return _Val;
; 4407 : }
; 4408 : #endif // ^^^ !defined(__cpp_lib_concepts) ^^^
; 4409 : 
; 4410 : template <class _Iter>
; 4411 : _NODISCARD constexpr auto _To_address(const move_iterator<_Iter>& _Val) noexcept {
; 4412 :     return _To_address(_Val.base());
; 4413 : }
; 4414 : 
; 4415 : // _Iterators_are_contiguous<_Iter1, _Iter2> reports whether both iterators are known to be contiguous.
; 4416 : 
; 4417 : template <class _Iter1, class _Iter2>
; 4418 : _INLINE_VAR constexpr bool _Iterators_are_contiguous =
; 4419 :     _Iterator_is_contiguous<_Iter1> && _Iterator_is_contiguous<_Iter2>;
; 4420 : 
; 4421 : template <class _Iter>
; 4422 : _INLINE_VAR constexpr bool _Iterator_is_volatile = is_volatile_v<remove_reference_t<_Iter_ref_t<_Iter>>>;
; 4423 : 
; 4424 : template <class _Source, class _Dest>
; 4425 : _INLINE_VAR constexpr bool _Is_pointer_address_convertible = is_void_v<_Source>
; 4426 :                                                           || is_void_v<_Dest>
; 4427 :                                                           // NOTE: is_same_v is required for function pointers to work
; 4428 :                                                           || is_same_v<remove_cv_t<_Source>, remove_cv_t<_Dest>>
; 4429 : #ifdef __cpp_lib_is_pointer_interconvertible
; 4430 :                                                           || is_pointer_interconvertible_base_of_v<_Dest, _Source>
; 4431 : #endif // __cpp_lib_is_pointer_interconvertible
; 4432 :     ;
; 4433 : 
; 4434 : template <class _Source, class _Dest, class _SourceRef, class _DestRef>
; 4435 : struct _Trivial_cat {
; 4436 :     using _USource = _Unwrap_enum_t<_Source>;
; 4437 :     using _UDest   = _Unwrap_enum_t<_Dest>;
; 4438 : 
; 4439 :     static constexpr bool _Same_size_and_compatible =
; 4440 :         sizeof(_Source) == sizeof(_Dest)
; 4441 :         // If _UDest is bool, _USource also needs to be bool
; 4442 :         // Conversion from non-bool => non-bool | bool => bool | bool => non-bool is fine.
; 4443 :         // Conversion from non-bool => bool is not fine.
; 4444 :         && is_same_v<bool, _USource> >= is_same_v<bool, _UDest>
; 4445 :         && (is_same_v<_USource, _UDest> || (is_integral_v<_USource> && is_integral_v<_UDest>)
; 4446 :             || (is_floating_point_v<_USource> && is_floating_point_v<_UDest>) );
; 4447 : 
; 4448 :     static constexpr bool _Bitcopy_constructible =
; 4449 :         _Same_size_and_compatible && is_trivially_constructible_v<_Dest, _SourceRef>;
; 4450 : 
; 4451 :     static constexpr bool _Bitcopy_assignable =
; 4452 :         _Same_size_and_compatible && is_trivially_assignable_v<_DestRef, _SourceRef>;
; 4453 : };
; 4454 : 
; 4455 : template <class _Source, class _Dest, class _SourceRef, class _DestRef>
; 4456 : struct _Trivial_cat<_Source*, _Dest*, _SourceRef, _DestRef> {
; 4457 :     static constexpr bool _Bitcopy_constructible =
; 4458 :         _Is_pointer_address_convertible<_Source, _Dest> && is_trivially_constructible_v<_Dest*, _SourceRef>;
; 4459 : 
; 4460 :     static constexpr bool _Bitcopy_assignable =
; 4461 :         _Is_pointer_address_convertible<_Source, _Dest> && is_trivially_assignable_v<_DestRef, _SourceRef>;
; 4462 : };
; 4463 : 
; 4464 : struct _False_trivial_cat {
; 4465 :     static constexpr bool _Bitcopy_constructible = false;
; 4466 :     static constexpr bool _Bitcopy_assignable    = false;
; 4467 : };
; 4468 : 
; 4469 : template <class _SourceIt, class _DestIt,
; 4470 :     bool _Are_contiguous = _Iterators_are_contiguous<_SourceIt, _DestIt> //
; 4471 :                         && !_Iterator_is_volatile<_SourceIt> && !_Iterator_is_volatile<_DestIt>>
; 4472 : struct _Iter_move_cat : _Trivial_cat<_Iter_value_t<_SourceIt>, _Iter_value_t<_DestIt>,
; 4473 :                             remove_reference_t<_Iter_ref_t<_SourceIt>>&&, _Iter_ref_t<_DestIt>> {};
; 4474 : 
; 4475 : template <class _SourceIt, class _DestIt>
; 4476 : struct _Iter_move_cat<_SourceIt, _DestIt, false> : _False_trivial_cat {};
; 4477 : 
; 4478 : template <class _SourceIt, class _DestIt>
; 4479 : struct _Iter_move_cat<move_iterator<_SourceIt>, _DestIt, false> : _Iter_move_cat<_SourceIt, _DestIt> {};
; 4480 : 
; 4481 : template <class _SourceIt, class _DestIt,
; 4482 :     bool _Are_contiguous = _Iterators_are_contiguous<_SourceIt, _DestIt> //
; 4483 :                         && !_Iterator_is_volatile<_SourceIt> && !_Iterator_is_volatile<_DestIt>>
; 4484 : struct _Iter_copy_cat
; 4485 :     : _Trivial_cat<_Iter_value_t<_SourceIt>, _Iter_value_t<_DestIt>, _Iter_ref_t<_SourceIt>, _Iter_ref_t<_DestIt>> {};
; 4486 : 
; 4487 : template <class _SourceIt, class _DestIt>
; 4488 : struct _Iter_copy_cat<_SourceIt, _DestIt, false> : _False_trivial_cat {};
; 4489 : 
; 4490 : template <class _SourceIt, class _DestIt>
; 4491 : struct _Iter_copy_cat<move_iterator<_SourceIt>, _DestIt, false> : _Iter_move_cat<_SourceIt, _DestIt> {};
; 4492 : 
; 4493 : template <class _Iter1, class _Sent1, class _Iter2>
; 4494 : _CONSTEXPR20 void _Verify_ranges_do_not_overlap(const _Iter1& _First1, const _Sent1& _Last1, const _Iter2& _First2) {
; 4495 : #if _ITERATOR_DEBUG_LEVEL == 2
; 4496 :     if constexpr (_Iterators_are_contiguous<_Iter1, _Iter2>
; 4497 : #ifdef __cpp_lib_concepts
; 4498 :                   && sized_sentinel_for<_Sent1, _Iter1>
; 4499 : #endif // __cpp_lib_concepts
; 4500 :     ) {
; 4501 : #if _HAS_CXX20
; 4502 :         if (_STD is_constant_evaluated()) {
; 4503 :             return;
; 4504 :         }
; 4505 : #endif // _HAS_CXX20
; 4506 : 
; 4507 :         const auto _Offset     = _Last1 - _First1;
; 4508 :         const auto _Ptr1Offset = _Offset * sizeof(*_To_address(_First1));
; 4509 :         const auto _Ptr2Offset = _Offset * sizeof(*_To_address(_First2));
; 4510 :         // This cast to `cv char*` allows us to compare pointers to distinct types,
; 4511 :         // in case one range provides storage for the other.
; 4512 :         const auto _PtrFirst1 = reinterpret_cast<const volatile char*>(_To_address(_First1));
; 4513 :         const auto _PtrLast1  = _PtrFirst1 + _Ptr1Offset;
; 4514 :         const auto _PtrFirst2 = reinterpret_cast<const volatile char*>(_To_address(_First2));
; 4515 :         const auto _PtrLast2  = _PtrFirst2 + _Ptr2Offset;
; 4516 :         _STL_VERIFY(_PtrLast1 <= _PtrFirst2 || _PtrLast2 <= _PtrFirst1, "ranges should not overlap each other");
; 4517 :     }
; 4518 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 / _ITERATOR_DEBUG_LEVEL != 2 vvv
; 4519 :     (void) _First1;
; 4520 :     (void) _Last1;
; 4521 :     (void) _First2;
; 4522 : #endif // _ITERATOR_DEBUG_LEVEL != 2 ^^^
; 4523 : }
; 4524 : 
; 4525 : template <class _CtgIt, class _OutCtgIt>
; 4526 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {
; 4527 :     auto _FirstPtr              = _To_address(_First);
; 4528 :     auto _LastPtr               = _To_address(_Last);
; 4529 :     auto _DestPtr               = _To_address(_Dest);
; 4530 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4531 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4532 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);
; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);
; 4535 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4536 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);
; 4537 :     } else {
; 4538 :         return _Dest + (_LastPtr - _FirstPtr);
; 4539 :     }
; 4540 : }
; 4541 : 
; 4542 : template <class _CtgIt, class _OutCtgIt>
; 4543 : _OutCtgIt _Copy_memmove_n(_CtgIt _First, const size_t _Count, _OutCtgIt _Dest) {
; 4544 :     const auto _Result = _Copy_memmove(_First, _First + _Count, _Dest);
; 4545 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4546 :         return _Result;
; 4547 :     } else { // _Result is unused so the compiler can optimize it away
; 4548 :         return _Dest + static_cast<_Iter_diff_t<_OutCtgIt>>(_Count);
; 4549 :     }
; 4550 : }
; 4551 : 
; 4552 : template <class _It, bool _RequiresMutable = false>
; 4553 : _INLINE_VAR constexpr bool _Is_vb_iterator = false;
; 4554 : 
; 4555 : template <class _InIt, class _SizeTy, class _OutIt>
; 4556 : _CONSTEXPR20 _OutIt _Copy_n_unchecked4(_InIt _First, _SizeTy _Count, _OutIt _Dest) {
; 4557 :     // copy _First + [0, _Count) to _Dest + [0, _Count), returning _Dest + _Count
; 4558 :     // note: has callers outside the copy family
; 4559 : #ifdef __cpp_lib_concepts
; 4560 :     _STL_INTERNAL_STATIC_ASSERT(_Integer_like<_SizeTy>);
; 4561 : #endif // __cpp_lib_concepts
; 4562 : 
; 4563 :     if constexpr (_Iter_copy_cat<_InIt, _OutIt>::_Bitcopy_assignable) {
; 4564 : #if _HAS_CXX20
; 4565 :         if (!_STD is_constant_evaluated())
; 4566 : #endif // _HAS_CXX20
; 4567 :         {
; 4568 :             return _Copy_memmove_n(_First, static_cast<size_t>(_Count), _Dest);
; 4569 :         }
; 4570 :     }
; 4571 : 
; 4572 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {
; 4573 :         *_Dest = *_First;
; 4574 :     }
; 4575 : 
; 4576 :     return _Dest;
; 4577 : }
; 4578 : 
; 4579 : template <class _InIt, class _Sent, class _OutIt>
; 4580 : using _Sent_copy_cat = conditional_t<
; 4581 : #ifdef __cpp_lib_concepts
; 4582 :     is_same_v<_Sent, _InIt> || sized_sentinel_for<_Sent, _InIt>,
; 4583 : #else // ^^^ Concepts support / no Concepts vvv
; 4584 :     is_same_v<_Sent, _InIt>,
; 4585 : #endif // ^^^ no Concepts ^^^
; 4586 :     _Iter_copy_cat<_InIt, _OutIt>, _False_trivial_cat>;
; 4587 : 
; 4588 : template <class _InIt, class _Sent, class _OutIt>
; 4589 : _CONSTEXPR20 _OutIt _Copy_unchecked(_InIt _First, _Sent _Last, _OutIt _Dest) {
; 4590 :     // copy [_First, _Last) to [_Dest, ...)
; 4591 :     // note: _Copy_unchecked has callers other than the copy family
; 4592 :     if constexpr (_Sent_copy_cat<_InIt, _Sent, _OutIt>::_Bitcopy_assignable) {
; 4593 : #if _HAS_CXX20
; 4594 :         if (!_STD is_constant_evaluated())
; 4595 : #endif // _HAS_CXX20
; 4596 :         {
; 4597 : #ifdef __cpp_lib_concepts
; 4598 :             if constexpr (is_same_v<_InIt, _Sent>)
; 4599 : #endif // __cpp_lib_concepts
; 4600 :             {
; 4601 :                 return _Copy_memmove(_First, _Last, _Dest);
; 4602 :             }
; 4603 : #ifdef __cpp_lib_concepts
; 4604 :             else {
; 4605 :                 return _Copy_memmove_n(_First, static_cast<size_t>(_Last - _First), _Dest);
; 4606 :             }
; 4607 : #endif // __cpp_lib_concepts
; 4608 :         }
; 4609 :     }
; 4610 : 
; 4611 :     for (; _First != _Last; ++_Dest, (void) ++_First) {
; 4612 :         *_Dest = *_First;
; 4613 :     }
; 4614 : 
; 4615 :     return _Dest;
; 4616 : }
; 4617 : 
; 4618 : _EXPORT_STD template <class _InIt, class _OutIt>
; 4619 : _CONSTEXPR20 _OutIt copy(_InIt _First, _InIt _Last, _OutIt _Dest) { // copy [_First, _Last) to [_Dest, ...)
; 4620 :     _Adl_verify_range(_First, _Last);
; 4621 :     const auto _UFirst = _Get_unwrapped(_First);
; 4622 :     const auto _ULast  = _Get_unwrapped(_Last);
; 4623 :     const auto _UDest  = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
; 4624 :     _Seek_wrapped(_Dest, _STD _Copy_unchecked(_UFirst, _ULast, _UDest));
; 4625 :     return _Dest;
; 4626 : }
; 4627 : 
; 4628 : #if _HAS_CXX17
; 4629 : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
; 4630 : _FwdIt2 copy(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last, _FwdIt2 _Dest) noexcept /* terminates */ {
; 4631 :     // copy [_First, _Last) to [_Dest, ...)
; 4632 :     // not parallelized as benchmarks show it isn't worth it
; 4633 :     _REQUIRE_PARALLEL_ITERATOR(_FwdIt1);
; 4634 :     _REQUIRE_CPP17_MUTABLE_ITERATOR(_FwdIt2);
; 4635 :     return _STD copy(_First, _Last, _Dest);
; 4636 : }
; 4637 : #endif // _HAS_CXX17
; 4638 : 
; 4639 : #ifdef __cpp_lib_concepts
; 4640 : namespace ranges {
; 4641 :     template <class _To, class _From>
; 4642 :     concept _Convertible_from = convertible_to<_From, _To>;
; 4643 : 
; 4644 :     _EXPORT_STD template <class _In, class _Out>
; 4645 :     struct in_out_result {
; 4646 :         /* [[no_unique_address]] */ _In in;
; 4647 :         /* [[no_unique_address]] */ _Out out;
; 4648 : 
; 4649 :         template <_Convertible_from<const _In&> _IIn, _Convertible_from<const _Out&> _OOut>
; 4650 :         constexpr operator in_out_result<_IIn, _OOut>() const& {
; 4651 :             return {in, out};
; 4652 :         }
; 4653 : 
; 4654 :         template <_Convertible_from<_In> _IIn, _Convertible_from<_Out> _OOut>
; 4655 :         constexpr operator in_out_result<_IIn, _OOut>() && {
; 4656 :             return {_STD move(in), _STD move(out)};
; 4657 :         }
; 4658 :     };
; 4659 : 
; 4660 :     template <forward_iterator _It, class _Se>
; 4661 :         requires sentinel_for<remove_cvref_t<_Se>, _It>
; 4662 :     _NODISCARD constexpr _Unwrap_iter_t<_It, _Se> _Get_final_iterator_unwrapped(
; 4663 :         const _Unwrap_iter_t<_It, _Se>& _UFirst, _Se&& _Last) {
; 4664 :         // find the iterator in [_UFirst, _Unwrap_sent<_It>(_Last)) which equals _Unwrap_sent<_It>(_Last)
; 4665 :         // [possibly O(N)]
; 4666 :         if constexpr (is_same_v<_Unwrap_iter_t<_It, _Se>, _Unwrap_sent_t<_Se, _It>>) {
; 4667 :             return _Unwrap_sent<_It>(_STD forward<_Se>(_Last));
; 4668 :         } else {
; 4669 :             return _RANGES next(_UFirst, _Unwrap_sent<_It>(_STD forward<_Se>(_Last)));
; 4670 :         }
; 4671 :     }
; 4672 : 
; 4673 :     template <forward_range _Rng>
; 4674 :     _NODISCARD constexpr auto _Get_final_iterator_unwrapped(_Rng& _Range) {
; 4675 :         // find the (unwrapped) iterator in _Range which equals _Uend(_Range) [possibly O(N)]
; 4676 :         if constexpr (common_range<_Rng>) {
; 4677 :             if constexpr (same_as<decltype(_Uend(_Range)), _Unwrapped_iterator_t<_Rng>>) {
; 4678 :                 return _Uend(_Range);
; 4679 :             } else {
; 4680 :                 return _Unwrap_range_sent<_Rng>(_RANGES end(_Range));
; 4681 :             }
; 4682 :         } else if constexpr (sized_range<_Rng>) {
; 4683 :             return _RANGES next(_Ubegin(_Range), _RANGES distance(_Range));
; 4684 :         } else {
; 4685 :             return _RANGES next(_Ubegin(_Range), _Uend(_Range));
; 4686 :         }
; 4687 :     }
; 4688 : 
; 4689 :     template <forward_range _Rng>
; 4690 :     _NODISCARD constexpr auto _Get_final_iterator_unwrapped(_Rng& _Range, const _Unwrapped_iterator_t<_Rng>& _Mid) {
; 4691 :         // find the (unwrapped) iterator in _Range which equals _Uend(_Range) [possibly O(N)]
; 4692 :         // Pre: [ranges::begin(_Range), _Mid) and [_Mid, ranges::end(_Range)) denote ranges
; 4693 :         if constexpr (common_range<_Rng>) {
; 4694 :             if constexpr (same_as<decltype(_Uend(_Range)), _Unwrapped_iterator_t<_Rng>>) {
; 4695 :                 return _Uend(_Range);
; 4696 :             } else {
; 4697 :                 return _Unwrap_range_sent<_Rng>(_RANGES end(_Range));
; 4698 :             }
; 4699 :         } else if constexpr (sized_range<_Rng>) {
; 4700 :             const auto _Dist = _RANGES distance(_Range);
; 4701 :             if constexpr (sized_sentinel_for<_Unwrapped_iterator_t<_Rng>, _Unwrapped_iterator_t<_Rng>>) {
; 4702 :                 return _RANGES next(_Mid, _Dist - (_Mid - _Ubegin(_Range)));
; 4703 :             } else {
; 4704 :                 return _RANGES next(_Ubegin(_Range), _Dist);
; 4705 :             }
; 4706 :         } else {
; 4707 :             return _RANGES next(_Mid, _Uend(_Range));
; 4708 :         }
; 4709 :     }
; 4710 : 
; 4711 : #if _HAS_CXX23
; 4712 :     _EXPORT_STD template <class _Out, class _Ty>
; 4713 :     struct out_value_result {
; 4714 :         /* [[no_unique_address]] */ _Out out;
; 4715 :         /* [[no_unique_address]] */ _Ty value;
; 4716 : 
; 4717 :         template <_Convertible_from<const _Out&> _OOut, _Convertible_from<const _Ty&> _TTy>
; 4718 :         constexpr operator out_value_result<_OOut, _TTy>() const& {
; 4719 :             return {out, value};
; 4720 :         }
; 4721 : 
; 4722 :         template <_Convertible_from<_Out> _OOut, _Convertible_from<_Ty> _TTy>
; 4723 :         constexpr operator out_value_result<_OOut, _TTy>() && {
; 4724 :             return {_STD move(out), _STD move(value)};
; 4725 :         }
; 4726 :     };
; 4727 : #endif // _HAS_CXX23
; 4728 : 
; 4729 :     _EXPORT_STD template <class _In, class _Out>
; 4730 :     using copy_result = in_out_result<_In, _Out>;
; 4731 : 
; 4732 :     template <input_iterator _It, sentinel_for<_It> _Se, weakly_incrementable _Out>
; 4733 :         requires indirectly_copyable<_It, _Out>
; 4734 :     _NODISCARD constexpr copy_result<_It, _Out> _Copy_unchecked(_It _First, _Se _Last, _Out _Result) {
; 4735 :         if constexpr (_Sent_copy_cat<_It, _Se, _Out>::_Bitcopy_assignable) {
; 4736 :             if (!_STD is_constant_evaluated()) {
; 4737 :                 if constexpr (is_same_v<_It, _Se>) {
; 4738 :                     _Result = _Copy_memmove(_STD move(_First), _Last, _STD move(_Result));
; 4739 :                     return {_STD move(_Last), _STD move(_Result)};
; 4740 :                 } else {
; 4741 :                     const auto _Count = static_cast<size_t>(_Last - _First);
; 4742 :                     _Result           = _Copy_memmove_n(_First, _Count, _STD move(_Result));
; 4743 :                     _First += _Count;
; 4744 :                     return {_STD move(_First), _STD move(_Result)};
; 4745 :                 }
; 4746 :             }
; 4747 :         }
; 4748 : 
; 4749 :         for (; _First != _Last; ++_First, (void) ++_Result) {
; 4750 :             *_Result = *_First;
; 4751 :         }
; 4752 : 
; 4753 :         return {_STD move(_First), _STD move(_Result)};
; 4754 :     }
; 4755 : 
; 4756 :     class _Copy_fn : private _Not_quite_object {
; 4757 :     public:
; 4758 :         using _Not_quite_object::_Not_quite_object;
; 4759 : 
; 4760 :         template <input_iterator _It, sentinel_for<_It> _Se, weakly_incrementable _Out>
; 4761 :             requires indirectly_copyable<_It, _Out>
; 4762 :         constexpr copy_result<_It, _Out> operator()(_It _First, _Se _Last, _Out _Result) const {
; 4763 :             _Adl_verify_range(_First, _Last);
; 4764 :             auto _UResult = _RANGES _Copy_unchecked(
; 4765 :                 _Unwrap_iter<_Se>(_STD move(_First)), _Unwrap_sent<_It>(_STD move(_Last)), _STD move(_Result));
; 4766 :             _Seek_wrapped(_First, _STD move(_UResult.in));
; 4767 :             return {_STD move(_First), _STD move(_UResult.out)};
; 4768 :         }
; 4769 : 
; 4770 :         template <input_range _Rng, weakly_incrementable _Out>
; 4771 :             requires indirectly_copyable<iterator_t<_Rng>, _Out>
; 4772 :         constexpr copy_result<borrowed_iterator_t<_Rng>, _Out> operator()(_Rng&& _Range, _Out _Result) const {
; 4773 :             auto _First = _RANGES begin(_Range);
; 4774 :             auto _UResult =
; 4775 :                 _RANGES _Copy_unchecked(_Unwrap_range_iter<_Rng>(_STD move(_First)), _Uend(_Range), _STD move(_Result));
; 4776 :             _Seek_wrapped(_First, _STD move(_UResult.in));
; 4777 :             return {_STD move(_First), _STD move(_UResult.out)};
; 4778 :         }
; 4779 :     };
; 4780 : 
; 4781 :     _EXPORT_STD inline constexpr _Copy_fn copy{_Not_quite_object::_Construct_tag {}};
; 4782 : } // namespace ranges
; 4783 : #endif // __cpp_lib_concepts
; 4784 : 
; 4785 : _EXPORT_STD template <class _InIt, class _Diff, class _OutIt>
; 4786 : _CONSTEXPR20 _OutIt copy_n(_InIt _First, _Diff _Count_raw, _OutIt _Dest) {
; 4787 :     // copy [_First, _First + _Count) to [_Dest, ...)
; 4788 :     _Algorithm_int_t<_Diff> _Count = _Count_raw;
; 4789 :     if (0 < _Count) {
; 4790 :         auto _UFirst = _Get_unwrapped_n(_First, _Count);
; 4791 :         auto _UDest  = _Get_unwrapped_n(_Dest, _Count);
; 4792 :         if constexpr (_Iter_copy_cat<decltype(_UFirst), decltype(_UDest)>::_Bitcopy_assignable) {
; 4793 : #if _HAS_CXX20
; 4794 :             if (!_STD is_constant_evaluated())
; 4795 : #endif // _HAS_CXX20
; 4796 :             {
; 4797 :                 _UDest = _Copy_memmove_n(_UFirst, static_cast<size_t>(_Count), _UDest);
; 4798 :                 _Seek_wrapped(_Dest, _UDest);
; 4799 :                 return _Dest;
; 4800 :             }
; 4801 :         }
; 4802 : 
; 4803 :         for (;;) {
; 4804 :             *_UDest = *_UFirst;
; 4805 :             ++_UDest;
; 4806 :             --_Count;
; 4807 :             if (_Count == 0) { // note that we avoid an extra ++_First here to allow istream_iterator to work,
; 4808 :                                // see LWG-2471
; 4809 :                 break;
; 4810 :             }
; 4811 : 
; 4812 :             ++_UFirst;
; 4813 :         }
; 4814 : 
; 4815 :         _Seek_wrapped(_Dest, _UDest);
; 4816 :     }
; 4817 : 
; 4818 :     return _Dest;
; 4819 : }
; 4820 : 
; 4821 : #if _HAS_CXX17
; 4822 : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _Diff, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
; 4823 : _FwdIt2 copy_n(_ExPo&&, _FwdIt1 _First, _Diff _Count_raw, _FwdIt2 _Dest) noexcept /* terminates */ {
; 4824 :     // copy [_First, _First + _Count) to [_Dest, ...)
; 4825 :     // not parallelized as benchmarks show it isn't worth it
; 4826 :     _REQUIRE_PARALLEL_ITERATOR(_FwdIt1);
; 4827 :     _REQUIRE_CPP17_MUTABLE_ITERATOR(_FwdIt2);
; 4828 :     return _STD copy_n(_First, _Count_raw, _Dest);
; 4829 : }
; 4830 : #endif // _HAS_CXX17
; 4831 : 
; 4832 : template <class _CtgIt1, class _CtgIt2>
; 4833 : _CtgIt2 _Copy_backward_memmove(_CtgIt1 _First, _CtgIt1 _Last, _CtgIt2 _Dest) {
; 4834 :     // implement copy_backward-like function as memmove
; 4835 :     auto _FirstPtr              = _To_address(_First);
; 4836 :     auto _LastPtr               = _To_address(_Last);
; 4837 :     auto _DestPtr               = _To_address(_Dest);
; 4838 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4839 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4840 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4841 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);
; 4842 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);
; 4843 :     if constexpr (is_pointer_v<_CtgIt2>) {
; 4844 :         return static_cast<_CtgIt2>(_Result);
; 4845 :     } else {
; 4846 :         return _Dest - (_LastPtr - _FirstPtr);
; 4847 :     }
; 4848 : }
; 4849 : 
; 4850 : template <class _BidIt1, class _BidIt2>
; 4851 : _BidIt2 _Copy_backward_memmove(move_iterator<_BidIt1> _First, move_iterator<_BidIt1> _Last, _BidIt2 _Dest) {
; 4852 :     return _Copy_backward_memmove(_First.base(), _Last.base(), _Dest);
; 4853 : }
; 4854 : 
; 4855 : template <class _BidIt1, class _BidIt2>
; 4856 : _NODISCARD _CONSTEXPR20 _BidIt2 _Copy_backward_unchecked(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {
; 4857 :     // copy [_First, _Last) backwards to [..., _Dest)
; 4858 :     if constexpr (_Iter_copy_cat<_BidIt1, _BidIt2>::_Bitcopy_assignable) {
; 4859 : #if _HAS_CXX20
; 4860 :         if (!_STD is_constant_evaluated())
; 4861 : #endif // _HAS_CXX20
; 4862 :         {
; 4863 :             return _Copy_backward_memmove(_First, _Last, _Dest);
; 4864 :         }
; 4865 :     }
; 4866 : 
; 4867 :     while (_First != _Last) {
; 4868 :         *--_Dest = *--_Last;
; 4869 :     }
; 4870 : 
; 4871 :     return _Dest;
; 4872 : }
; 4873 : 
; 4874 : _EXPORT_STD template <class _BidIt1, class _BidIt2>
; 4875 : _CONSTEXPR20 _BidIt2 copy_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {
; 4876 :     // copy [_First, _Last) backwards to [..., _Dest)
; 4877 :     _Adl_verify_range(_First, _Last);
; 4878 :     const auto _UFirst = _Get_unwrapped(_First);
; 4879 :     const auto _ULast  = _Get_unwrapped(_Last);
; 4880 :     const auto _UDest  = _Get_unwrapped_n(_Dest, -_Idl_distance<_BidIt1>(_UFirst, _ULast));
; 4881 :     _Seek_wrapped(_Dest, _Copy_backward_unchecked(_UFirst, _ULast, _UDest));
; 4882 :     return _Dest;
; 4883 : }
; 4884 : 
; 4885 : template <class _InIt, class _OutIt>
; 4886 : _CONSTEXPR20 _OutIt _Move_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest) {
; 4887 :     // move [_First, _Last) to [_Dest, ...)
; 4888 :     // note: _Move_unchecked has callers other than the move family
; 4889 :     if constexpr (_Iter_move_cat<_InIt, _OutIt>::_Bitcopy_assignable) {
; 4890 : #if _HAS_CXX20
; 4891 :         if (!_STD is_constant_evaluated())
; 4892 : #endif // _HAS_CXX20
; 4893 :         {
; 4894 :             return _Copy_memmove(_First, _Last, _Dest);
; 4895 :         }
; 4896 :     }
; 4897 : 
; 4898 :     for (; _First != _Last; ++_Dest, (void) ++_First) {
; 4899 :         *_Dest = _STD move(*_First);
; 4900 :     }
; 4901 : 
; 4902 :     return _Dest;
; 4903 : }
; 4904 : 
; 4905 : _EXPORT_STD template <class _InIt, class _OutIt>
; 4906 : _CONSTEXPR20 _OutIt move(_InIt _First, _InIt _Last, _OutIt _Dest) {
; 4907 :     // move [_First, _Last) to [_Dest, ...)
; 4908 :     _Adl_verify_range(_First, _Last);
; 4909 :     const auto _UFirst = _Get_unwrapped(_First);
; 4910 :     const auto _ULast  = _Get_unwrapped(_Last);
; 4911 :     const auto _UDest  = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
; 4912 :     _Seek_wrapped(_Dest, _STD _Move_unchecked(_UFirst, _ULast, _UDest));
; 4913 :     return _Dest;
; 4914 : }
; 4915 : 
; 4916 : #if _HAS_CXX17
; 4917 : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
; 4918 : _FwdIt2 move(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last, _FwdIt2 _Dest) noexcept /* terminates */ {
; 4919 :     // move [_First, _Last) to [_Dest, ...)
; 4920 :     // not parallelized as benchmarks show it isn't worth it
; 4921 :     _REQUIRE_CPP17_MUTABLE_ITERATOR(_FwdIt1);
; 4922 :     _REQUIRE_CPP17_MUTABLE_ITERATOR(_FwdIt2);
; 4923 :     return _STD move(_First, _Last, _Dest);
; 4924 : }
; 4925 : #endif // _HAS_CXX17
; 4926 : 
; 4927 : template <class _BidIt1, class _BidIt2>
; 4928 : _CONSTEXPR20 _BidIt2 _Move_backward_unchecked(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {
; 4929 :     // move [_First, _Last) backwards to [..., _Dest)
; 4930 :     // note: _Move_backward_unchecked has callers other than the move_backward family
; 4931 :     if constexpr (_Iter_move_cat<_BidIt1, _BidIt2>::_Bitcopy_assignable) {
; 4932 : #if _HAS_CXX20
; 4933 :         if (!_STD is_constant_evaluated())
; 4934 : #endif // _HAS_CXX20
; 4935 :         {
; 4936 :             return _Copy_backward_memmove(_First, _Last, _Dest);
; 4937 :         }
; 4938 :     }
; 4939 : 
; 4940 :     while (_First != _Last) {
; 4941 :         *--_Dest = _STD move(*--_Last);
; 4942 :     }
; 4943 : 
; 4944 :     return _Dest;
; 4945 : }
; 4946 : 
; 4947 : _EXPORT_STD template <class _BidIt1, class _BidIt2>
; 4948 : _CONSTEXPR20 _BidIt2 move_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {
; 4949 :     // move [_First, _Last) backwards to [..., _Dest)
; 4950 :     _Adl_verify_range(_First, _Last);
; 4951 :     const auto _UFirst = _Get_unwrapped(_First);
; 4952 :     const auto _ULast  = _Get_unwrapped(_Last);
; 4953 :     const auto _UDest  = _Get_unwrapped_n(_Dest, -_Idl_distance<_BidIt1>(_UFirst, _ULast));
; 4954 :     _Seek_wrapped(_Dest, _Move_backward_unchecked(_UFirst, _ULast, _UDest));
; 4955 :     return _Dest;
; 4956 : }
; 4957 : 
; 4958 : template <class _Ty>
; 4959 : struct _Is_character : false_type {}; // by default, not a character type
; 4960 : 
; 4961 : template <>
; 4962 : struct _Is_character<char> : true_type {}; // chars are characters
; 4963 : 
; 4964 : template <>
; 4965 : struct _Is_character<signed char> : true_type {}; // signed chars are also characters
; 4966 : 
; 4967 : template <>
; 4968 : struct _Is_character<unsigned char> : true_type {}; // unsigned chars are also characters
; 4969 : 
; 4970 : #ifdef __cpp_char8_t
; 4971 : template <>
; 4972 : struct _Is_character<char8_t> : true_type {}; // UTF-8 code units are sort-of characters
; 4973 : #endif // __cpp_char8_t
; 4974 : 
; 4975 : template <class _Ty>
; 4976 : struct _Is_character_or_bool : _Is_character<_Ty>::type {};
; 4977 : 
; 4978 : template <>
; 4979 : struct _Is_character_or_bool<bool> : true_type {};
; 4980 : 
; 4981 : template <class _Ty>
; 4982 : struct _Is_character_or_byte_or_bool : _Is_character_or_bool<_Ty>::type {};
; 4983 : 
; 4984 : #ifdef __cpp_lib_byte
; 4985 : template <>
; 4986 : struct _Is_character_or_byte_or_bool<byte> : true_type {};
; 4987 : #endif // __cpp_lib_byte
; 4988 : 
; 4989 : // _Fill_memset_is_safe determines if _FwdIt and _Ty are eligible for memset optimization in fill.
; 4990 : // Need to explicitly test for volatile because _Unwrap_enum_t discards qualifiers.
; 4991 : template <class _FwdIt, class _Ty, bool = _Iterator_is_contiguous<_FwdIt>>
; 4992 : _INLINE_VAR constexpr bool _Fill_memset_is_safe = conjunction_v<is_scalar<_Ty>,
; 4993 :     _Is_character_or_byte_or_bool<_Unwrap_enum_t<remove_reference_t<_Iter_ref_t<_FwdIt>>>>,
; 4994 :     negation<is_volatile<remove_reference_t<_Iter_ref_t<_FwdIt>>>>, is_assignable<_Iter_ref_t<_FwdIt>, const _Ty&>>;
; 4995 : 
; 4996 : template <class _FwdIt, class _Ty>
; 4997 : _INLINE_VAR constexpr bool _Fill_memset_is_safe<_FwdIt, _Ty, false> = false;
; 4998 : 
; 4999 : template <class _FwdIt, class _Ty, bool = _Iterator_is_contiguous<_FwdIt>>
; 5000 : _INLINE_VAR constexpr bool _Fill_zero_memset_is_safe =
; 5001 :     conjunction_v<is_scalar<_Ty>, is_scalar<_Iter_value_t<_FwdIt>>, negation<is_member_pointer<_Iter_value_t<_FwdIt>>>,
; 5002 :         negation<is_volatile<remove_reference_t<_Iter_ref_t<_FwdIt>>>>, is_assignable<_Iter_ref_t<_FwdIt>, const _Ty&>>;
; 5003 : 
; 5004 : template <class _FwdIt, class _Ty>
; 5005 : _INLINE_VAR constexpr bool _Fill_zero_memset_is_safe<_FwdIt, _Ty, false> = false;
; 5006 : 
; 5007 : template <class _CtgIt, class _Ty>
; 5008 : void _Fill_memset(_CtgIt _Dest, const _Ty _Val, const size_t _Count) {
; 5009 :     // implicitly convert (a cast would suppress warnings); also handles _Iter_value_t<_CtgIt> being bool
; 5010 :     _Iter_value_t<_CtgIt> _Dest_val = _Val;
; 5011 :     _CSTD memset(_To_address(_Dest), static_cast<unsigned char>(_Dest_val), _Count);
; 5012 : }
; 5013 : 
; 5014 : template <class _CtgIt>
; 5015 : void _Fill_zero_memset(_CtgIt _Dest, const size_t _Count) {
; 5016 :     _CSTD memset(_To_address(_Dest), 0, _Count * sizeof(_Iter_value_t<_CtgIt>));
; 5017 : }
; 5018 : 
; 5019 : template <class _Ty>
; 5020 : _NODISCARD bool _Is_all_bits_zero(const _Ty& _Val) {
; 5021 :     // checks if scalar type has all bits set to zero
; 5022 :     _STL_INTERNAL_STATIC_ASSERT(is_scalar_v<_Ty> && !is_member_pointer_v<_Ty>);
; 5023 :     if constexpr (is_same_v<_Ty, nullptr_t>) {
; 5024 :         return true;
; 5025 :     } else {
; 5026 :         constexpr _Ty _Zero{};
; 5027 :         return _CSTD memcmp(&_Val, &_Zero, sizeof(_Ty)) == 0;
; 5028 :     }
; 5029 : }
; 5030 : 
; 5031 : _EXPORT_STD template <class _FwdIt, class _Ty>
; 5032 : _CONSTEXPR20 void fill(const _FwdIt _First, const _FwdIt _Last, const _Ty& _Val) {
; 5033 :     // copy _Val through [_First, _Last)
; 5034 :     _Adl_verify_range(_First, _Last);
; 5035 :     if constexpr (_Is_vb_iterator<_FwdIt, true>) {
; 5036 :         _Fill_vbool(_First, _Last, _Val);
; 5037 :     } else {
; 5038 :         auto _UFirst      = _Get_unwrapped(_First);
; 5039 :         const auto _ULast = _Get_unwrapped(_Last);
; 5040 : #if _HAS_CXX20
; 5041 :         if (!_STD is_constant_evaluated())
; 5042 : #endif // _HAS_CXX20
; 5043 :         {
; 5044 :             if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5045 :                 _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 5046 :                 return;
; 5047 :             } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5048 :                 if (_Is_all_bits_zero(_Val)) {
; 5049 :                     _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 5050 :                     return;
; 5051 :                 }
; 5052 :             }
; 5053 :         }
; 5054 : 
; 5055 :         for (; _UFirst != _ULast; ++_UFirst) {
; 5056 :             *_UFirst = _Val;
; 5057 :         }
; 5058 :     }
; 5059 : }
; 5060 : 
; 5061 : #if _HAS_CXX17
; 5062 : _EXPORT_STD template <class _ExPo, class _FwdIt, class _Ty, _Enable_if_execution_policy_t<_ExPo> = 0>
; 5063 : void fill(_ExPo&&, _FwdIt _First, _FwdIt _Last, const _Ty& _Val) noexcept /* terminates */ {
; 5064 :     // copy _Val through [_First, _Last)
; 5065 :     // not parallelized as benchmarks show it isn't worth it
; 5066 :     _REQUIRE_CPP17_MUTABLE_ITERATOR(_FwdIt);
; 5067 :     return _STD fill(_First, _Last, _Val);
; 5068 : }
; 5069 : #endif // _HAS_CXX17
; 5070 : 
; 5071 : _EXPORT_STD template <class _OutIt, class _Diff, class _Ty>
; 5072 : _CONSTEXPR20 _OutIt fill_n(_OutIt _Dest, const _Diff _Count_raw, const _Ty& _Val) {
; 5073 :     // copy _Val _Count times through [_Dest, ...)
; 5074 :     _Algorithm_int_t<_Diff> _Count = _Count_raw;
; 5075 :     if (0 < _Count) {
; 5076 :         if constexpr (_Is_vb_iterator<_OutIt, true>) {
; 5077 :             const auto _Last = _Dest + static_cast<typename _OutIt::difference_type>(_Count);
; 5078 :             _Fill_vbool(_Dest, _Last, _Val);
; 5079 :             return _Last;
; 5080 :         } else {
; 5081 :             auto _UDest = _Get_unwrapped_n(_Dest, _Count);
; 5082 : #if _HAS_CXX20
; 5083 :             if (!_STD is_constant_evaluated())
; 5084 : #endif // _HAS_CXX20
; 5085 :             {
; 5086 :                 if constexpr (_Fill_memset_is_safe<decltype(_UDest), _Ty>) {
; 5087 :                     _Fill_memset(_UDest, _Val, static_cast<size_t>(_Count));
; 5088 :                     _Seek_wrapped(_Dest, _UDest + _Count);
; 5089 :                     return _Dest;
; 5090 :                 } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UDest), _Ty>) {
; 5091 :                     if (_Is_all_bits_zero(_Val)) {
; 5092 :                         _Fill_zero_memset(_UDest, static_cast<size_t>(_Count));
; 5093 :                         _Seek_wrapped(_Dest, _UDest + _Count);
; 5094 :                         return _Dest;
; 5095 :                     }
; 5096 :                 }
; 5097 :             }
; 5098 : 
; 5099 :             for (; 0 < _Count; --_Count, (void) ++_UDest) {
; 5100 :                 *_UDest = _Val;
; 5101 :             }
; 5102 : 
; 5103 :             _Seek_wrapped(_Dest, _UDest);
; 5104 :         }
; 5105 :     }
; 5106 :     return _Dest;
; 5107 : }
; 5108 : 
; 5109 : #if _HAS_CXX17
; 5110 : _EXPORT_STD template <class _ExPo, class _FwdIt, class _Diff, class _Ty, _Enable_if_execution_policy_t<_ExPo> = 0>
; 5111 : _FwdIt fill_n(_ExPo&&, _FwdIt _Dest, _Diff _Count_raw, const _Ty& _Val) noexcept /* terminates */ {
; 5112 :     // copy _Val _Count times through [_Dest, ...)
; 5113 :     // not parallelized as benchmarks show it isn't worth it
; 5114 :     _REQUIRE_CPP17_MUTABLE_ITERATOR(_FwdIt);
; 5115 :     return _STD fill_n(_Dest, _Count_raw, _Val);
; 5116 : }
; 5117 : #endif // _HAS_CXX17
; 5118 : 
; 5119 : #ifdef __cpp_lib_concepts
; 5120 : namespace ranges {
; 5121 :     class _Fill_n_fn : private _Not_quite_object {
; 5122 :     public:
; 5123 :         using _Not_quite_object::_Not_quite_object;
; 5124 : 
; 5125 :         template <class _Ty, output_iterator<const _Ty&> _It>
; 5126 :         constexpr _It operator()(_It _First, iter_difference_t<_It> _Count, const _Ty& _Value) const {
; 5127 :             if (_Count > 0) {
; 5128 :                 auto _UFirst = _Get_unwrapped_n(_STD move(_First), _Count);
; 5129 :                 if (!_STD is_constant_evaluated()) {
; 5130 :                     if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5131 :                         _Fill_memset(_UFirst, _Value, static_cast<size_t>(_Count));
; 5132 :                         _Seek_wrapped(_First, _UFirst + _Count); // no need to move since _UFirst is a pointer
; 5133 :                         return _First;
; 5134 :                     } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5135 :                         if (_Is_all_bits_zero(_Value)) {
; 5136 :                             _Fill_zero_memset(_UFirst, static_cast<size_t>(_Count));
; 5137 :                             _Seek_wrapped(_First, _UFirst + _Count); // no need to move since _UFirst is a pointer
; 5138 :                             return _First;
; 5139 :                         }
; 5140 :                     }
; 5141 :                 }
; 5142 : 
; 5143 :                 for (; _Count > 0; ++_UFirst, (void) --_Count) {
; 5144 :                     *_UFirst = _Value;
; 5145 :                 }
; 5146 : 
; 5147 :                 _Seek_wrapped(_First, _STD move(_UFirst));
; 5148 :             }
; 5149 : 
; 5150 :             return _First;
; 5151 :         }
; 5152 :     };
; 5153 : 
; 5154 :     _EXPORT_STD inline constexpr _Fill_n_fn fill_n{_Not_quite_object::_Construct_tag {}};
; 5155 : } // namespace ranges
; 5156 : #endif // __cpp_lib_concepts
; 5157 : 
; 5158 : template <class _Ty1, class _Ty2, class = void>
; 5159 : _INLINE_VAR constexpr bool _Can_compare_with_operator_equal = false;
; 5160 : 
; 5161 : template <class _Ty1, class _Ty2>
; 5162 : _INLINE_VAR constexpr bool
; 5163 :     _Can_compare_with_operator_equal<_Ty1, _Ty2, void_t<decltype(_STD declval<_Ty1&>() == _STD declval<_Ty2&>())>> =
; 5164 :         true;
; 5165 : 
; 5166 : template <class _Ty1, class _Ty2>
; 5167 : _INLINE_VAR constexpr bool _Is_pointer_address_comparable =
; 5168 :     _Can_compare_with_operator_equal<_Ty1*, _Ty2*>
; 5169 :     && (_Is_pointer_address_convertible<_Ty1, _Ty2> || _Is_pointer_address_convertible<_Ty2, _Ty1>);
; 5170 : 
; 5171 : // _Can_memcmp_elements<_Elem1, _Elem2> reports whether `_Elem1 == _Elem2` can be optimized to memcmp.
; 5172 : // Here, _Elem1 and _Elem2 aren't top-level const, because we remove_const_t before using _Can_memcmp_elements.
; 5173 : 
; 5174 : // Integral types are eligible for memcmp in very specific cases.
; 5175 : // * They must be the same size. (`int == long` is eligible; `int == long long` isn't.)
; 5176 : // * The usual arithmetic conversions must preserve bit patterns. (This is true for `int == unsigned int`,
; 5177 : //   but false for `short == unsigned short`.)
; 5178 : #pragma warning(push)
; 5179 : #pragma warning(disable : 4806) // no value of type 'bool' promoted to type 'char' can equal the given constant
; 5180 : template <class _Elem1, class _Elem2,
; 5181 :     bool = sizeof(_Elem1) == sizeof(_Elem2) && is_integral_v<_Elem1>&& is_integral_v<_Elem2>>
; 5182 : _INLINE_VAR constexpr bool _Can_memcmp_elements =
; 5183 :     is_same_v<_Elem1, bool> || is_same_v<_Elem2, bool> || static_cast<_Elem1>(-1) == static_cast<_Elem2>(-1);
; 5184 : #pragma warning(pop)
; 5185 : 
; 5186 : #ifdef __cpp_lib_byte
; 5187 : // Allow memcmping std::byte.
; 5188 : // inline is required here as explicit specializations of variable templates are problematic in C++14.
; 5189 : // However, std::byte is C++17 and above so we are safe.
; 5190 : template <>
; 5191 : inline constexpr bool _Can_memcmp_elements<byte, byte, false> = true;
; 5192 : #endif // __cpp_lib_byte
; 5193 : 
; 5194 : // Pointer elements are eligible for memcmp when they point to the same type, ignoring cv-qualification.
; 5195 : // This handles pointers to object types, pointers to void, and pointers to function types.
; 5196 : template <class _Ty1, class _Ty2>
; 5197 : _INLINE_VAR constexpr bool _Can_memcmp_elements<_Ty1*, _Ty2*, false> = _Is_pointer_address_comparable<_Ty1, _Ty2>;
; 5198 : 
; 5199 : template <class _Elem1, class _Elem2>
; 5200 : _INLINE_VAR constexpr bool _Can_memcmp_elements<_Elem1, _Elem2, false> = false;
; 5201 : 
; 5202 : // _Can_memcmp_elements_with_pred<_Elem1, _Elem2, _Pr> reports whether the memcmp optimization is applicable,
; 5203 : // given contiguously stored elements. (This avoids having to repeat the metaprogramming that finds the element types.)
; 5204 : // _Elem1 and _Elem2 aren't top-level const here.
; 5205 : template <class _Elem1, class _Elem2, class _Pr>
; 5206 : _INLINE_VAR constexpr bool _Can_memcmp_elements_with_pred = false;
; 5207 : 
; 5208 : // With equal_to<_Elem3> we need to make sure that both _Elem1 and _Elem2 are convertible to _Elem3 without changing
; 5209 : // object representation (we use _Iter_copy_cat for this task) and _Elem3 can be safely memcmp'ed with itself
; 5210 : template <class _Elem1, class _Elem2, class _Elem3>
; 5211 : _INLINE_VAR constexpr bool _Can_memcmp_elements_with_pred<_Elem1, _Elem2, equal_to<_Elem3>> =
; 5212 :     _Iter_copy_cat<_Elem1*, _Elem3*>::_Bitcopy_constructible && _Iter_copy_cat<_Elem2*, _Elem3*>::_Bitcopy_constructible
; 5213 :     && _Can_memcmp_elements<remove_cv_t<_Elem3>, remove_cv_t<_Elem3>>;
; 5214 : 
; 5215 : // equal_to<> is transparent.
; 5216 : template <class _Elem1, class _Elem2>
; 5217 : _INLINE_VAR constexpr bool _Can_memcmp_elements_with_pred<_Elem1, _Elem2, equal_to<>> =
; 5218 :     _Can_memcmp_elements<_Elem1, _Elem2>;
; 5219 : 
; 5220 : #ifdef __cpp_lib_concepts
; 5221 : // ranges::equal_to is also transparent.
; 5222 : template <class _Elem1, class _Elem2>
; 5223 : _INLINE_VAR constexpr bool _Can_memcmp_elements_with_pred<_Elem1, _Elem2, _RANGES equal_to> =
; 5224 :     _Can_memcmp_elements<_Elem1, _Elem2>;
; 5225 : #endif // __cpp_lib_concepts
; 5226 : 
; 5227 : // _Equal_memcmp_is_safe<_Iter1, _Iter2, _Pr> reports whether we can activate the memcmp optimization
; 5228 : // for arbitrary iterators and predicates.
; 5229 : // It ignores top-level constness on the iterators and on the elements.
; 5230 : template <class _Iter1, class _Iter2, class _Pr>
; 5231 : _INLINE_VAR constexpr bool _Equal_memcmp_is_safe_helper =
; 5232 :     _Iterators_are_contiguous<_Iter1, _Iter2> //
; 5233 :     && !_Iterator_is_volatile<_Iter1> && !_Iterator_is_volatile<_Iter2> //
; 5234 :     && _Can_memcmp_elements_with_pred<_Iter_value_t<_Iter1>, _Iter_value_t<_Iter2>, _Pr>;
; 5235 : 
; 5236 : template <class _Iter1, class _Iter2, class _Pr>
; 5237 : _INLINE_VAR constexpr bool _Equal_memcmp_is_safe =
; 5238 :     _Equal_memcmp_is_safe_helper<remove_const_t<_Iter1>, remove_const_t<_Iter2>, _Pr>;
; 5239 : 
; 5240 : template <class _CtgIt1, class _CtgIt2>
; 5241 : _NODISCARD int _Memcmp_ranges(_CtgIt1 _First1, _CtgIt1 _Last1, _CtgIt2 _First2) {
; 5242 :     _STL_INTERNAL_STATIC_ASSERT(sizeof(_Iter_value_t<_CtgIt1>) == sizeof(_Iter_value_t<_CtgIt2>));
; 5243 :     const auto _First1_ch = reinterpret_cast<const char*>(_To_address(_First1));
; 5244 :     const auto _Last1_ch  = reinterpret_cast<const char*>(_To_address(_Last1));
; 5245 :     const auto _First2_ch = reinterpret_cast<const char*>(_To_address(_First2));
; 5246 :     return _CSTD memcmp(_First1_ch, _First2_ch, static_cast<size_t>(_Last1_ch - _First1_ch));
; 5247 : }
; 5248 : 
; 5249 : template <class _CtgIt1, class _CtgIt2>
; 5250 : _NODISCARD int _Memcmp_count(_CtgIt1 _First1, _CtgIt2 _First2, const size_t _Count) {
; 5251 :     _STL_INTERNAL_STATIC_ASSERT(sizeof(_Iter_value_t<_CtgIt1>) == sizeof(_Iter_value_t<_CtgIt2>));
; 5252 :     const auto _First1_ch = reinterpret_cast<const char*>(_To_address(_First1));
; 5253 :     const auto _First2_ch = reinterpret_cast<const char*>(_To_address(_First2));
; 5254 :     return _CSTD memcmp(_First1_ch, _First2_ch, _Count * sizeof(_Iter_value_t<_CtgIt1>));
; 5255 : }
; 5256 : 
; 5257 : _EXPORT_STD template <class _InIt1, class _InIt2, class _Pr>
; 5258 : _NODISCARD _CONSTEXPR20 bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, _Pr _Pred) {
; 5259 :     // compare [_First1, _Last1) to [_First2, ...)
; 5260 :     _Adl_verify_range(_First1, _Last1);
; 5261 :     auto _UFirst1      = _Get_unwrapped(_First1);
; 5262 :     const auto _ULast1 = _Get_unwrapped(_Last1);
; 5263 :     auto _UFirst2      = _Get_unwrapped_n(_First2, _Idl_distance<_InIt1>(_UFirst1, _ULast1));
; 5264 :     if constexpr (_Equal_memcmp_is_safe<decltype(_UFirst1), decltype(_UFirst2), _Pr>) {
; 5265 : #if _HAS_CXX20
; 5266 :         if (!_STD is_constant_evaluated())
; 5267 : #endif // _HAS_CXX20
; 5268 :         {
; 5269 :             return _Memcmp_ranges(_UFirst1, _ULast1, _UFirst2) == 0;
; 5270 :         }
; 5271 :     }
; 5272 : 
; 5273 :     for (; _UFirst1 != _ULast1; ++_UFirst1, (void) ++_UFirst2) {

	add	rbx, 88					; 00000058H
	cmp	rbx, rdi
	jne	SHORT $LL6@equal
$LN5@equal:

; 5290 :     // compare [_First1, _Last1) to [_First2, ...)
; 5291 :     return _STD equal(_First1, _Last1, _First2, equal_to<>{});

	mov	al, 1

; 5292 : }

	mov	rbx, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN135@equal:
	mov	rbx, QWORD PTR [rsp+56]
	xor	al, al
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$equal@PEBVNode@BymlFile@@PEBV12@@std@@YA_NQEBVNode@BymlFile@@00@Z ENDP ; std::equal<BymlFile::Node const *,BymlFile::Node const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEAV?$vector@EV?$allocator@E@std@@@std@@@std@@YAAEAV?$vector@EV?$allocator@E@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAV?$vector@EV?$allocator@E@std@@@std@@@std@@YAAEAV?$vector@EV?$allocator@E@std@@@0@AEAV10@@Z PROC ; std::forward<std::vector<unsigned char,std::allocator<unsigned char> > &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEAV?$vector@EV?$allocator@E@std@@@std@@@std@@YAAEAV?$vector@EV?$allocator@E@std@@@0@AEAV10@@Z ENDP ; std::forward<std::vector<unsigned char,std::allocator<unsigned char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\__msvc_chrono.hpp
;	COMDAT ??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QEAA@AEB_J@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QEAA@AEB_J@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000> >::duration<__int64,std::ratio<1,1000> ><__int64,0>, COMDAT

; 99   :             : _MyRep(static_cast<_Rep>(_Val)) {}

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QEAA@AEB_J@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000> >::duration<__int64,std::ratio<1,1000> ><__int64,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0_JV<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
_TEXT	SEGMENT
_Val$1 = 48
_Val$2 = 48
_Mid$3 = 48
__$ArrayPad$ = 80
_First$ = 160
_Last$ = 168
_Ideal$ = 176
_Pred$ = 184
??$_Sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0_JV<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z PROC ; std::_Sort_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >, COMDAT

; 8033 : _CONSTEXPR20 void _Sort_unchecked(_RanIt _First, _RanIt _Last, _Iter_diff_t<_RanIt> _Ideal, _Pr _Pred) {

	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	movzx	ebx, r9b
	mov	rdi, r8
	mov	rbp, rdx
	mov	rsi, rcx

; 8034 :     // order [_First, _Last)
; 8035 :     for (;;) {
; 8036 :         if (_Last - _First <= _ISORT_MAX) { // small

	mov	rax, rdx
	sub	rax, rcx
	and	rax, -32				; ffffffffffffffe0H
	cmp	rax, 1024				; 00000400H
	jle	$LN155@Sort_unche
$LL2@Sort_unche:

; 8038 :             return;
; 8039 :         }
; 8040 : 
; 8041 :         if (_Ideal <= 0) { // heap sort if too many divisions

	test	rdi, rdi
	jle	$LN156@Sort_unche

; 8044 :             return;
; 8045 :         }
; 8046 : 
; 8047 :         // divide and conquer by quicksort
; 8048 :         auto _Mid = _Partition_by_median_guess_unchecked(_First, _Last, _Pred);

	movzx	r9d, bl
	mov	r8, rbp
	mov	rdx, rsi
	lea	rcx, QWORD PTR _Mid$3[rsp]
	call	??$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z ; std::_Partition_by_median_guess_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >

; 8049 : 
; 8050 :         _Ideal = (_Ideal >> 1) + (_Ideal >> 2); // allow 1.5 log2(N) divisions

	mov	rcx, rdi
	sar	rcx, 2
	sar	rdi, 1
	add	rdi, rcx

; 8051 : 
; 8052 :         if (_Mid.first - _First < _Last - _Mid.second) { // loop on second half

	mov	rdx, rbp
	mov	r14, QWORD PTR _Mid$3[rsp+8]
	sub	rdx, r14
	and	rdx, -32				; ffffffffffffffe0H
	mov	r15, QWORD PTR _Mid$3[rsp]
	mov	rax, r15
	sub	rax, rsi
	and	rax, -32				; ffffffffffffffe0H
	movzx	r9d, bl
	mov	r8, rdi
	cmp	rax, rdx
	jge	SHORT $LN7@Sort_unche

; 8053 :             _Sort_unchecked(_First, _Mid.first, _Ideal, _Pred);

	mov	rdx, r15
	mov	rcx, rsi
	call	??$_Sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0_JV<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ; std::_Sort_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >

; 8054 :             _First = _Mid.second;

	mov	rsi, r14

; 8055 :         } else { // loop on first half

	jmp	SHORT $LN8@Sort_unche
$LN7@Sort_unche:

; 8056 :             _Sort_unchecked(_Mid.second, _Last, _Ideal, _Pred);

	mov	rdx, rbp
	mov	rcx, r14
	call	??$_Sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0_JV<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ; std::_Sort_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >

; 8057 :             _Last = _Mid.first;

	mov	rbp, r15
$LN8@Sort_unche:

; 8034 :     // order [_First, _Last)
; 8035 :     for (;;) {
; 8036 :         if (_Last - _First <= _ISORT_MAX) { // small

	mov	rax, rbp
	sub	rax, rsi
	and	rax, -32				; ffffffffffffffe0H
	cmp	rax, 1024				; 00000400H
	jg	$LL2@Sort_unche
$LN155@Sort_unche:

; 8037 :             _Insertion_sort_unchecked(_First, _Last, _Pred);

	mov	rdx, rbp
	mov	rcx, rsi
	call	??$_Insertion_sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ; std::_Insertion_sort_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >
$LN79@Sort_unche:

; 8060 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 96					; 00000060H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN156@Sort_unche:

; 6596 :     _Diff _Bottom = _Last - _First;

	mov	r15, rbp
	sub	r15, rsi
	sar	r15, 5

; 6597 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	mov	r14, r15
	sar	r14, 1
	xor	r12d, r12d
	test	r14, r14
	jle	$LN12@Sort_unche

; 6477 :         _STD _Pop_heap_hole_unchecked(_First, _Last, _Last, _STD move(_Val), _Pred);
; 6478 :     }
; 6479 : }
; 6480 : 
; 6481 : _EXPORT_STD template <class _RanIt, class _Pr>
; 6482 : _CONSTEXPR20 void pop_heap(_RanIt _First, _RanIt _Last, _Pr _Pred) {
; 6483 :     // pop *_First to *(_Last - 1) and reheap
; 6484 :     _Adl_verify_range(_First, _Last);
; 6485 :     _STD _Pop_heap_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pass_fn(_Pred));
; 6486 : }
; 6487 : 
; 6488 : _EXPORT_STD template <class _RanIt>
; 6489 : _CONSTEXPR20 void pop_heap(_RanIt _First, _RanIt _Last) {
; 6490 :     // pop *_First to *(_Last - 1) and reheap
; 6491 :     _STD pop_heap(_First, _Last, less<>{});
; 6492 : }
; 6493 : 
; 6494 : #ifdef __cpp_lib_concepts
; 6495 : namespace ranges {
; 6496 :     template <random_access_iterator _It, class _Ty, class _Pr, class _Pj1, class _Pj2>
; 6497 :         requires sortable<_It, _Pr, _Pj1> && indirectly_writable<_It, _Ty>
; 6498 :               && indirect_strict_weak_order<_Pr, projected<_It, _Pj1>, projected<remove_reference_t<_Ty>*, _Pj2>>
; 6499 :     constexpr void _Pop_heap_hole_by_index(_It _First, iter_difference_t<_It> _Hole,
; 6500 :         const iter_difference_t<_It> _Bottom, _Ty&& _Val, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
; 6501 :         // percolate _Hole to _Bottom, then push _Val
; 6502 :         _STL_INTERNAL_CHECK(_Hole >= 0);
; 6503 :         _STL_INTERNAL_CHECK(_Bottom > 0);
; 6504 : 
; 6505 :         using _Diff      = iter_difference_t<_It>;
; 6506 :         const _Diff _Top = _Hole;
; 6507 :         _Diff _Idx       = _Hole;
; 6508 : 
; 6509 :         // Check whether _Idx can have a child before calculating that child's index, since
; 6510 :         // calculating the child's index can trigger integer overflows
; 6511 :         const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; // shift for codegen
; 6512 :         while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child
; 6513 :             _Idx      = 2 * _Idx + 2;
; 6514 :             auto _Mid = _First + _Idx;
; 6515 :             if (_STD invoke(_Pred, _STD invoke(_Proj1, *_Mid), _STD invoke(_Proj1, *_RANGES prev(_Mid)))) {
; 6516 :                 --_Idx;
; 6517 :                 --_Mid;
; 6518 :             }
; 6519 :             *(_First + _Hole) = _RANGES iter_move(_Mid);
; 6520 :             _Hole             = _Idx;
; 6521 :         }
; 6522 : 
; 6523 :         if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it
; 6524 :             *(_First + _Hole) = _RANGES iter_move(_First + (_Bottom - 1));
; 6525 :             _Hole             = _Bottom - 1;
; 6526 :         }
; 6527 : 
; 6528 :         _RANGES _Push_heap_by_index(_STD move(_First), _Hole, _Top, _STD forward<_Ty>(_Val), _Pred, _Proj1, _Proj2);
; 6529 :     }
; 6530 : 
; 6531 :     template <random_access_iterator _It, class _Ty, class _Pr, class _Pj1, class _Pj2>
; 6532 :         requires sortable<_It, _Pr, _Pj1> && indirectly_writable<_It, _Ty>
; 6533 :               && indirect_strict_weak_order<_Pr, projected<_It, _Pj1>, projected<remove_reference_t<_Ty>*, _Pj2>>
; 6534 :     constexpr void _Pop_heap_hole_unchecked(
; 6535 :         _It _First, const _It _Last, const _It _Dest, _Ty&& _Val, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
; 6536 :         // pop *_First to *_Dest and reheap
; 6537 :         _STL_INTERNAL_CHECK(_First != _Last);
; 6538 :         _STL_INTERNAL_CHECK(_First != _Dest);
; 6539 : 
; 6540 :         *_Dest            = _RANGES iter_move(_First);
; 6541 :         const auto _Count = _Last - _First;
; 6542 :         _RANGES _Pop_heap_hole_by_index(_STD move(_First), 0, _Count, _STD forward<_Ty>(_Val), _Pred, _Proj1, _Proj2);
; 6543 :     }
; 6544 : 
; 6545 :     template <random_access_iterator _It, class _Pr, class _Pj>
; 6546 :         requires sortable<_It, _Pr, _Pj>
; 6547 :     constexpr void _Pop_heap_unchecked(_It _First, _It _Last, _Pr _Pred, _Pj _Proj) {
; 6548 :         // pop *_First to *(_Last - 1) and reheap
; 6549 :         if (_Last - _First < 2) {
; 6550 :             return;
; 6551 :         }
; 6552 : 
; 6553 :         --_Last;
; 6554 :         iter_value_t<_It> _Val = _RANGES iter_move(_Last);
; 6555 :         // NB: if _Proj is a _Ref_fn, this aliases the _Proj1 and _Proj2 parameters of _Pop_heap_hole_unchecked
; 6556 :         _RANGES _Pop_heap_hole_unchecked(_STD move(_First), _Last, _Last, _STD move(_Val), _Pred, _Proj, _Proj);
; 6557 :     }
; 6558 : 
; 6559 :     class _Pop_heap_fn : private _Not_quite_object {
; 6560 :     public:
; 6561 :         using _Not_quite_object::_Not_quite_object;
; 6562 : 
; 6563 :         template <random_access_iterator _It, sentinel_for<_It> _Se, class _Pr = ranges::less, class _Pj = identity>
; 6564 :             requires sortable<_It, _Pr, _Pj>
; 6565 :         constexpr _It operator()(_It _First, _Se _Last, _Pr _Pred = {}, _Pj _Proj = {}) const {
; 6566 :             _Adl_verify_range(_First, _Last);
; 6567 :             auto _UFirst = _Unwrap_iter<_Se>(_STD move(_First));
; 6568 :             auto _ULast  = _Get_final_iterator_unwrapped<_It>(_UFirst, _STD move(_Last));
; 6569 :             _Seek_wrapped(_First, _ULast);
; 6570 :             _RANGES _Pop_heap_unchecked(_STD move(_UFirst), _STD move(_ULast), _Pass_fn(_Pred), _Pass_fn(_Proj));
; 6571 :             return _First;
; 6572 :         }
; 6573 : 
; 6574 :         template <random_access_range _Rng, class _Pr = ranges::less, class _Pj = identity>
; 6575 :             requires sortable<iterator_t<_Rng>, _Pr, _Pj>
; 6576 :         constexpr borrowed_iterator_t<_Rng> operator()(_Rng&& _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
; 6577 :             if constexpr (common_range<_Rng>) {
; 6578 :                 _RANGES _Pop_heap_unchecked(_Ubegin(_Range), _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj));
; 6579 :                 return _RANGES end(_Range);
; 6580 :             } else {
; 6581 :                 auto _ULast = _Get_final_iterator_unwrapped(_Range);
; 6582 :                 _RANGES _Pop_heap_unchecked(_Ubegin(_Range), _ULast, _Pass_fn(_Pred), _Pass_fn(_Proj));
; 6583 :                 return _Rewrap_iterator(_Range, _STD move(_ULast));
; 6584 :             }
; 6585 :         }
; 6586 :     };
; 6587 : 
; 6588 :     _EXPORT_STD inline constexpr _Pop_heap_fn pop_heap{_Not_quite_object::_Construct_tag{}};
; 6589 : } // namespace ranges
; 6590 : #endif // __cpp_lib_concepts
; 6591 : 
; 6592 : template <class _RanIt, class _Pr>
; 6593 : _CONSTEXPR20 void _Make_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {
; 6594 :     // make [_First, _Last) into a heap
; 6595 :     using _Diff   = _Iter_diff_t<_RanIt>;
; 6596 :     _Diff _Bottom = _Last - _First;

	mov	rdi, r14
	shl	rdi, 5
	add	rdi, rsi
	npad	10
$LL11@Sort_unche:

; 6598 :         // reheap top half, bottom to top
; 6599 :         --_Hole;

	dec	r14
	lea	rdi, QWORD PTR [rdi-32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdi]
	movups	XMMWORD PTR _Val$2[rsp], xmm0
	movups	xmm1, XMMWORD PTR [rdi+16]
	movups	XMMWORD PTR _Val$2[rsp+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6600 :         _Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

	mov	QWORD PTR [rdi+16], r12
	mov	QWORD PTR [rdi+24], 15
	mov	BYTE PTR [rdi], 0

; 6601 :         _STD _Pop_heap_hole_by_index(_First, _Hole, _Bottom, _STD move(_Val), _Pred);

	mov	BYTE PTR [rsp+32], bl
	lea	r9, QWORD PTR _Val$2[rsp]
	mov	r8, r15
	mov	rdx, r14
	mov	rcx, rsi
	call	??$_Pop_heap_hole_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ; std::_Pop_heap_hole_by_index<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,`BymlFile::ToBinary'::`2'::<lambda_1> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR _Val$2[rsp+24]
	cmp	rdx, 16
	jb	SHORT $LN58@Sort_unche

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR _Val$2[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN70@Sort_unche

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN139@Sort_unche
$LN70@Sort_unche:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN58@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6597 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	test	r14, r14
	jg	$LL11@Sort_unche
$LN12@Sort_unche:

; 6818 :     for (; _Last - _First >= 2; --_Last) {

	cmp	r15, 2
	jl	$LN79@Sort_unche

; 8042 :             _Make_heap_unchecked(_First, _Last, _Pred);
; 8043 :             _Sort_heap_unchecked(_First, _Last, _Pred);

	lea	rdi, QWORD PTR [rbp-32]
	mov	r14, -24
	sub	r14, rsi
	mov	ebp, 32					; 00000020H
	sub	rbp, rsi
	npad	11
$LL80@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdi]
	movups	XMMWORD PTR _Val$1[rsp], xmm0
	movups	xmm1, XMMWORD PTR [rdi+16]
	movups	XMMWORD PTR _Val$1[rsp+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6476 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	QWORD PTR [rdi+16], r12
	mov	QWORD PTR [rdi+24], 15
	mov	BYTE PTR [rdi], 0

; 6465 :     *_Dest      = _STD move(*_First);

	mov	rdx, rsi
	mov	rcx, rdi
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 6466 :     using _Diff = _Iter_diff_t<_RanIt>;
; 6467 :     _STD _Pop_heap_hole_by_index(

	lea	r8, QWORD PTR [rdi+24]
	add	r8, r14
	sar	r8, 5
	mov	BYTE PTR [rsp+32], bl
	lea	r9, QWORD PTR _Val$1[rsp]
	xor	edx, edx
	mov	rcx, rsi
	call	??$_Pop_heap_hole_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ; std::_Pop_heap_hole_by_index<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,`BymlFile::ToBinary'::`2'::<lambda_1> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR _Val$1[rsp+24]
	cmp	rdx, 16

; 4832 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN78@Sort_unche

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR _Val$1[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN142@Sort_unche

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN139@Sort_unche
$LN142@Sort_unche:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN78@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6818 :     for (; _Last - _First >= 2; --_Last) {

	sub	rdi, 32					; 00000020H
	lea	rax, QWORD PTR [rdi+rbp]
	and	rax, -32				; ffffffffffffffe0H
	cmp	rax, 64					; 00000040H
	jl	$LN79@Sort_unche
	jmp	$LL80@Sort_unche
$LN139@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN177@Sort_unche:
??$_Sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0_JV<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ENDP ; std::_Sort_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Val$1 = 48
_Val$2 = 48
_Mid$3 = 48
__$ArrayPad$ = 80
_First$ = 160
_Last$ = 168
_Ideal$ = 176
_Pred$ = 184
?dtor$0@?0???$_Sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0_JV<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA PROC ; `std::_Sort_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Val$2[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$_Sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0_JV<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA ENDP ; `std::_Sort_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Val$1 = 48
_Val$2 = 48
_Mid$3 = 48
__$ArrayPad$ = 80
_First$ = 160
_Last$ = 168
_Ideal$ = 176
_Pred$ = 184
?dtor$5@?0???$_Sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0_JV<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA PROC ; `std::_Sort_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >'::`1'::dtor$5
	lea	rcx, QWORD PTR _Val$1[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$5@?0???$_Sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0_JV<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA ENDP ; `std::_Sort_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0_JV<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
_TEXT	SEGMENT
_Val$1 = 48
_Val$2 = 48
_Mid$3 = 48
__$ArrayPad$ = 80
_First$ = 160
_Last$ = 168
_Ideal$ = 176
_Pred$ = 184
??$_Sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0_JV<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z PROC ; std::_Sort_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >, COMDAT

; 8033 : _CONSTEXPR20 void _Sort_unchecked(_RanIt _First, _RanIt _Last, _Iter_diff_t<_RanIt> _Ideal, _Pr _Pred) {

	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	movzx	ebx, r9b
	mov	rdi, r8
	mov	rbp, rdx
	mov	rsi, rcx

; 8034 :     // order [_First, _Last)
; 8035 :     for (;;) {
; 8036 :         if (_Last - _First <= _ISORT_MAX) { // small

	mov	rax, rdx
	sub	rax, rcx
	and	rax, -32				; ffffffffffffffe0H
	cmp	rax, 1024				; 00000400H
	jle	$LN155@Sort_unche
$LL2@Sort_unche:

; 8038 :             return;
; 8039 :         }
; 8040 : 
; 8041 :         if (_Ideal <= 0) { // heap sort if too many divisions

	test	rdi, rdi
	jle	$LN156@Sort_unche

; 8044 :             return;
; 8045 :         }
; 8046 : 
; 8047 :         // divide and conquer by quicksort
; 8048 :         auto _Mid = _Partition_by_median_guess_unchecked(_First, _Last, _Pred);

	movzx	r9d, bl
	mov	r8, rbp
	mov	rdx, rsi
	lea	rcx, QWORD PTR _Mid$3[rsp]
	call	??$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z ; std::_Partition_by_median_guess_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >

; 8049 : 
; 8050 :         _Ideal = (_Ideal >> 1) + (_Ideal >> 2); // allow 1.5 log2(N) divisions

	mov	rcx, rdi
	sar	rcx, 2
	sar	rdi, 1
	add	rdi, rcx

; 8051 : 
; 8052 :         if (_Mid.first - _First < _Last - _Mid.second) { // loop on second half

	mov	rdx, rbp
	mov	r14, QWORD PTR _Mid$3[rsp+8]
	sub	rdx, r14
	and	rdx, -32				; ffffffffffffffe0H
	mov	r15, QWORD PTR _Mid$3[rsp]
	mov	rax, r15
	sub	rax, rsi
	and	rax, -32				; ffffffffffffffe0H
	movzx	r9d, bl
	mov	r8, rdi
	cmp	rax, rdx
	jge	SHORT $LN7@Sort_unche

; 8053 :             _Sort_unchecked(_First, _Mid.first, _Ideal, _Pred);

	mov	rdx, r15
	mov	rcx, rsi
	call	??$_Sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0_JV<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ; std::_Sort_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >

; 8054 :             _First = _Mid.second;

	mov	rsi, r14

; 8055 :         } else { // loop on first half

	jmp	SHORT $LN8@Sort_unche
$LN7@Sort_unche:

; 8056 :             _Sort_unchecked(_Mid.second, _Last, _Ideal, _Pred);

	mov	rdx, rbp
	mov	rcx, r14
	call	??$_Sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0_JV<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ; std::_Sort_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >

; 8057 :             _Last = _Mid.first;

	mov	rbp, r15
$LN8@Sort_unche:

; 8034 :     // order [_First, _Last)
; 8035 :     for (;;) {
; 8036 :         if (_Last - _First <= _ISORT_MAX) { // small

	mov	rax, rbp
	sub	rax, rsi
	and	rax, -32				; ffffffffffffffe0H
	cmp	rax, 1024				; 00000400H
	jg	$LL2@Sort_unche
$LN155@Sort_unche:

; 8037 :             _Insertion_sort_unchecked(_First, _Last, _Pred);

	mov	rdx, rbp
	mov	rcx, rsi
	call	??$_Insertion_sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ; std::_Insertion_sort_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >
$LN79@Sort_unche:

; 8060 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 96					; 00000060H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN156@Sort_unche:

; 6596 :     _Diff _Bottom = _Last - _First;

	mov	r15, rbp
	sub	r15, rsi
	sar	r15, 5

; 6597 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	mov	r14, r15
	sar	r14, 1
	xor	r12d, r12d
	test	r14, r14
	jle	$LN12@Sort_unche

; 6477 :         _STD _Pop_heap_hole_unchecked(_First, _Last, _Last, _STD move(_Val), _Pred);
; 6478 :     }
; 6479 : }
; 6480 : 
; 6481 : _EXPORT_STD template <class _RanIt, class _Pr>
; 6482 : _CONSTEXPR20 void pop_heap(_RanIt _First, _RanIt _Last, _Pr _Pred) {
; 6483 :     // pop *_First to *(_Last - 1) and reheap
; 6484 :     _Adl_verify_range(_First, _Last);
; 6485 :     _STD _Pop_heap_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pass_fn(_Pred));
; 6486 : }
; 6487 : 
; 6488 : _EXPORT_STD template <class _RanIt>
; 6489 : _CONSTEXPR20 void pop_heap(_RanIt _First, _RanIt _Last) {
; 6490 :     // pop *_First to *(_Last - 1) and reheap
; 6491 :     _STD pop_heap(_First, _Last, less<>{});
; 6492 : }
; 6493 : 
; 6494 : #ifdef __cpp_lib_concepts
; 6495 : namespace ranges {
; 6496 :     template <random_access_iterator _It, class _Ty, class _Pr, class _Pj1, class _Pj2>
; 6497 :         requires sortable<_It, _Pr, _Pj1> && indirectly_writable<_It, _Ty>
; 6498 :               && indirect_strict_weak_order<_Pr, projected<_It, _Pj1>, projected<remove_reference_t<_Ty>*, _Pj2>>
; 6499 :     constexpr void _Pop_heap_hole_by_index(_It _First, iter_difference_t<_It> _Hole,
; 6500 :         const iter_difference_t<_It> _Bottom, _Ty&& _Val, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
; 6501 :         // percolate _Hole to _Bottom, then push _Val
; 6502 :         _STL_INTERNAL_CHECK(_Hole >= 0);
; 6503 :         _STL_INTERNAL_CHECK(_Bottom > 0);
; 6504 : 
; 6505 :         using _Diff      = iter_difference_t<_It>;
; 6506 :         const _Diff _Top = _Hole;
; 6507 :         _Diff _Idx       = _Hole;
; 6508 : 
; 6509 :         // Check whether _Idx can have a child before calculating that child's index, since
; 6510 :         // calculating the child's index can trigger integer overflows
; 6511 :         const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; // shift for codegen
; 6512 :         while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child
; 6513 :             _Idx      = 2 * _Idx + 2;
; 6514 :             auto _Mid = _First + _Idx;
; 6515 :             if (_STD invoke(_Pred, _STD invoke(_Proj1, *_Mid), _STD invoke(_Proj1, *_RANGES prev(_Mid)))) {
; 6516 :                 --_Idx;
; 6517 :                 --_Mid;
; 6518 :             }
; 6519 :             *(_First + _Hole) = _RANGES iter_move(_Mid);
; 6520 :             _Hole             = _Idx;
; 6521 :         }
; 6522 : 
; 6523 :         if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it
; 6524 :             *(_First + _Hole) = _RANGES iter_move(_First + (_Bottom - 1));
; 6525 :             _Hole             = _Bottom - 1;
; 6526 :         }
; 6527 : 
; 6528 :         _RANGES _Push_heap_by_index(_STD move(_First), _Hole, _Top, _STD forward<_Ty>(_Val), _Pred, _Proj1, _Proj2);
; 6529 :     }
; 6530 : 
; 6531 :     template <random_access_iterator _It, class _Ty, class _Pr, class _Pj1, class _Pj2>
; 6532 :         requires sortable<_It, _Pr, _Pj1> && indirectly_writable<_It, _Ty>
; 6533 :               && indirect_strict_weak_order<_Pr, projected<_It, _Pj1>, projected<remove_reference_t<_Ty>*, _Pj2>>
; 6534 :     constexpr void _Pop_heap_hole_unchecked(
; 6535 :         _It _First, const _It _Last, const _It _Dest, _Ty&& _Val, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
; 6536 :         // pop *_First to *_Dest and reheap
; 6537 :         _STL_INTERNAL_CHECK(_First != _Last);
; 6538 :         _STL_INTERNAL_CHECK(_First != _Dest);
; 6539 : 
; 6540 :         *_Dest            = _RANGES iter_move(_First);
; 6541 :         const auto _Count = _Last - _First;
; 6542 :         _RANGES _Pop_heap_hole_by_index(_STD move(_First), 0, _Count, _STD forward<_Ty>(_Val), _Pred, _Proj1, _Proj2);
; 6543 :     }
; 6544 : 
; 6545 :     template <random_access_iterator _It, class _Pr, class _Pj>
; 6546 :         requires sortable<_It, _Pr, _Pj>
; 6547 :     constexpr void _Pop_heap_unchecked(_It _First, _It _Last, _Pr _Pred, _Pj _Proj) {
; 6548 :         // pop *_First to *(_Last - 1) and reheap
; 6549 :         if (_Last - _First < 2) {
; 6550 :             return;
; 6551 :         }
; 6552 : 
; 6553 :         --_Last;
; 6554 :         iter_value_t<_It> _Val = _RANGES iter_move(_Last);
; 6555 :         // NB: if _Proj is a _Ref_fn, this aliases the _Proj1 and _Proj2 parameters of _Pop_heap_hole_unchecked
; 6556 :         _RANGES _Pop_heap_hole_unchecked(_STD move(_First), _Last, _Last, _STD move(_Val), _Pred, _Proj, _Proj);
; 6557 :     }
; 6558 : 
; 6559 :     class _Pop_heap_fn : private _Not_quite_object {
; 6560 :     public:
; 6561 :         using _Not_quite_object::_Not_quite_object;
; 6562 : 
; 6563 :         template <random_access_iterator _It, sentinel_for<_It> _Se, class _Pr = ranges::less, class _Pj = identity>
; 6564 :             requires sortable<_It, _Pr, _Pj>
; 6565 :         constexpr _It operator()(_It _First, _Se _Last, _Pr _Pred = {}, _Pj _Proj = {}) const {
; 6566 :             _Adl_verify_range(_First, _Last);
; 6567 :             auto _UFirst = _Unwrap_iter<_Se>(_STD move(_First));
; 6568 :             auto _ULast  = _Get_final_iterator_unwrapped<_It>(_UFirst, _STD move(_Last));
; 6569 :             _Seek_wrapped(_First, _ULast);
; 6570 :             _RANGES _Pop_heap_unchecked(_STD move(_UFirst), _STD move(_ULast), _Pass_fn(_Pred), _Pass_fn(_Proj));
; 6571 :             return _First;
; 6572 :         }
; 6573 : 
; 6574 :         template <random_access_range _Rng, class _Pr = ranges::less, class _Pj = identity>
; 6575 :             requires sortable<iterator_t<_Rng>, _Pr, _Pj>
; 6576 :         constexpr borrowed_iterator_t<_Rng> operator()(_Rng&& _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
; 6577 :             if constexpr (common_range<_Rng>) {
; 6578 :                 _RANGES _Pop_heap_unchecked(_Ubegin(_Range), _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj));
; 6579 :                 return _RANGES end(_Range);
; 6580 :             } else {
; 6581 :                 auto _ULast = _Get_final_iterator_unwrapped(_Range);
; 6582 :                 _RANGES _Pop_heap_unchecked(_Ubegin(_Range), _ULast, _Pass_fn(_Pred), _Pass_fn(_Proj));
; 6583 :                 return _Rewrap_iterator(_Range, _STD move(_ULast));
; 6584 :             }
; 6585 :         }
; 6586 :     };
; 6587 : 
; 6588 :     _EXPORT_STD inline constexpr _Pop_heap_fn pop_heap{_Not_quite_object::_Construct_tag{}};
; 6589 : } // namespace ranges
; 6590 : #endif // __cpp_lib_concepts
; 6591 : 
; 6592 : template <class _RanIt, class _Pr>
; 6593 : _CONSTEXPR20 void _Make_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {
; 6594 :     // make [_First, _Last) into a heap
; 6595 :     using _Diff   = _Iter_diff_t<_RanIt>;
; 6596 :     _Diff _Bottom = _Last - _First;

	mov	rdi, r14
	shl	rdi, 5
	add	rdi, rsi
	npad	10
$LL11@Sort_unche:

; 6598 :         // reheap top half, bottom to top
; 6599 :         --_Hole;

	dec	r14
	lea	rdi, QWORD PTR [rdi-32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdi]
	movups	XMMWORD PTR _Val$2[rsp], xmm0
	movups	xmm1, XMMWORD PTR [rdi+16]
	movups	XMMWORD PTR _Val$2[rsp+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6600 :         _Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

	mov	QWORD PTR [rdi+16], r12
	mov	QWORD PTR [rdi+24], 15
	mov	BYTE PTR [rdi], 0

; 6601 :         _STD _Pop_heap_hole_by_index(_First, _Hole, _Bottom, _STD move(_Val), _Pred);

	mov	BYTE PTR [rsp+32], bl
	lea	r9, QWORD PTR _Val$2[rsp]
	mov	r8, r15
	mov	rdx, r14
	mov	rcx, rsi
	call	??$_Pop_heap_hole_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ; std::_Pop_heap_hole_by_index<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,`BymlFile::ToBinary'::`2'::<lambda_2> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR _Val$2[rsp+24]
	cmp	rdx, 16
	jb	SHORT $LN58@Sort_unche

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR _Val$2[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN70@Sort_unche

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN139@Sort_unche
$LN70@Sort_unche:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN58@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6597 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	test	r14, r14
	jg	$LL11@Sort_unche
$LN12@Sort_unche:

; 6818 :     for (; _Last - _First >= 2; --_Last) {

	cmp	r15, 2
	jl	$LN79@Sort_unche

; 8042 :             _Make_heap_unchecked(_First, _Last, _Pred);
; 8043 :             _Sort_heap_unchecked(_First, _Last, _Pred);

	lea	rdi, QWORD PTR [rbp-32]
	mov	r14, -24
	sub	r14, rsi
	mov	ebp, 32					; 00000020H
	sub	rbp, rsi
	npad	11
$LL80@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdi]
	movups	XMMWORD PTR _Val$1[rsp], xmm0
	movups	xmm1, XMMWORD PTR [rdi+16]
	movups	XMMWORD PTR _Val$1[rsp+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6476 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	QWORD PTR [rdi+16], r12
	mov	QWORD PTR [rdi+24], 15
	mov	BYTE PTR [rdi], 0

; 6465 :     *_Dest      = _STD move(*_First);

	mov	rdx, rsi
	mov	rcx, rdi
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 6466 :     using _Diff = _Iter_diff_t<_RanIt>;
; 6467 :     _STD _Pop_heap_hole_by_index(

	lea	r8, QWORD PTR [rdi+24]
	add	r8, r14
	sar	r8, 5
	mov	BYTE PTR [rsp+32], bl
	lea	r9, QWORD PTR _Val$1[rsp]
	xor	edx, edx
	mov	rcx, rsi
	call	??$_Pop_heap_hole_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ; std::_Pop_heap_hole_by_index<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,`BymlFile::ToBinary'::`2'::<lambda_2> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR _Val$1[rsp+24]
	cmp	rdx, 16

; 4832 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN78@Sort_unche

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR _Val$1[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN142@Sort_unche

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN139@Sort_unche
$LN142@Sort_unche:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN78@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6818 :     for (; _Last - _First >= 2; --_Last) {

	sub	rdi, 32					; 00000020H
	lea	rax, QWORD PTR [rdi+rbp]
	and	rax, -32				; ffffffffffffffe0H
	cmp	rax, 64					; 00000040H
	jl	$LN79@Sort_unche
	jmp	$LL80@Sort_unche
$LN139@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN177@Sort_unche:
??$_Sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0_JV<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ENDP ; std::_Sort_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Val$1 = 48
_Val$2 = 48
_Mid$3 = 48
__$ArrayPad$ = 80
_First$ = 160
_Last$ = 168
_Ideal$ = 176
_Pred$ = 184
?dtor$0@?0???$_Sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0_JV<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA PROC ; `std::_Sort_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Val$2[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$_Sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0_JV<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA ENDP ; `std::_Sort_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Val$1 = 48
_Val$2 = 48
_Mid$3 = 48
__$ArrayPad$ = 80
_First$ = 160
_Last$ = 168
_Ideal$ = 176
_Pred$ = 184
?dtor$5@?0???$_Sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0_JV<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA PROC ; `std::_Sort_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >'::`1'::dtor$5
	lea	rcx, QWORD PTR _Val$1[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$5@?0???$_Sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0_JV<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA ENDP ; `std::_Sort_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple
;	COMDAT ??$forward_as_tuple@AEBVNode@BymlFile@@@std@@YA?AV?$tuple@AEBVNode@BymlFile@@@0@AEBVNode@BymlFile@@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
<_Args_0>$ = 16
??$forward_as_tuple@AEBVNode@BymlFile@@@std@@YA?AV?$tuple@AEBVNode@BymlFile@@@0@AEBVNode@BymlFile@@@Z PROC ; std::forward_as_tuple<BymlFile::Node const &>, COMDAT

; 144  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

	mov	QWORD PTR [rcx], rdx

; 1026 :     return tuple<_Types&&...>(_STD forward<_Types>(_Args)...);

	mov	rax, rcx

; 1027 : }

	ret	0
??$forward_as_tuple@AEBVNode@BymlFile@@@std@@YA?AV?$tuple@AEBVNode@BymlFile@@@0@AEBVNode@BymlFile@@@Z ENDP ; std::forward_as_tuple<BymlFile::Node const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBVNode@BymlFile@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBVNode@BymlFile@@@1@$$QEAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
this$ = 48
_Al_$ = 56
$T1 = 64
<_Vals_0>$dead$ = 64
<_Vals_1>$ = 72
<_Vals_2>$dead$ = 80
??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBVNode@BymlFile@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBVNode@BymlFile@@@1@$$QEAV?$tuple@$$V@1@@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > ><std::piecewise_construct_t const &,std::tuple<BymlFile::Node const &>,std::tuple<> >, COMDAT

; 584  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

$LN57:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+32], rsi
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, r9
	mov	rsi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1144 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR [rcx], rdx
	mov	QWORD PTR [rcx+8], 0

; 1151 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR [rcx+8], 0

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 112				; 00000070H
	call	??2@YAPEAX_K@Z				; operator new

; 1152 :         _Ptr = _Al.allocate(1);

	mov	QWORD PTR [rsi+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 586  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

	lea	rdi, QWORD PTR [rax+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple

; 366  :     tuple(tuple&&)      = default;

	mov	rbx, QWORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	QWORD PTR $T1[rsp], rdi
	mov	rdx, rbx
	mov	rcx, rdi
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	npad	1
	movzx	eax, BYTE PTR [rbx+24]
	mov	BYTE PTR [rdi+24], al
	lea	rcx, QWORD PTR [rdi+32]
	lea	rdx, QWORD PTR [rbx+32]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rdi+64]
	lea	rdx, QWORD PTR [rbx+64]
	call	??0?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@AEBV01@@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::vector<BymlFile::Node,std::allocator<BymlFile::Node> >
	npad	1
	mov	DWORD PTR [rdi+88], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 587  :     }

	mov	rax, rsi
	mov	rbx, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBVNode@BymlFile@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBVNode@BymlFile@@@1@$$QEAV?$tuple@$$V@1@@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > ><std::piecewise_construct_t const &,std::tuple<BymlFile::Node const &>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Al_$ = 56
$T1 = 64
<_Vals_0>$dead$ = 64
<_Vals_1>$ = 72
<_Vals_2>$dead$ = 80
?dtor$0@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBVNode@BymlFile@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBVNode@BymlFile@@@1@$$QEAV?$tuple@$$V@1@@Z@4HA PROC ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > ><std::piecewise_construct_t const &,std::tuple<BymlFile::Node const &>,std::tuple<> >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > >
?dtor$0@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBVNode@BymlFile@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBVNode@BymlFile@@@1@$$QEAV?$tuple@$$V@1@@Z@4HA ENDP ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > ><std::piecewise_construct_t const &,std::tuple<BymlFile::Node const &>,std::tuple<> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Al_$ = 56
$T1 = 64
<_Vals_0>$dead$ = 64
<_Vals_1>$ = 72
<_Vals_2>$dead$ = 80
?dtor$3@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBVNode@BymlFile@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBVNode@BymlFile@@@1@$$QEAV?$tuple@$$V@1@@Z@4HA PROC ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > ><std::piecewise_construct_t const &,std::tuple<BymlFile::Node const &>,std::tuple<> >'::`1'::dtor$3
	mov	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$3@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBVNode@BymlFile@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBVNode@BymlFile@@@1@$$QEAV?$tuple@$$V@1@@Z@4HA ENDP ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > ><std::piecewise_construct_t const &,std::tuple<BymlFile::Node const &>,std::tuple<> >'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Al_$ = 56
$T1 = 64
<_Vals_0>$dead$ = 64
<_Vals_1>$ = 72
<_Vals_2>$dead$ = 80
?dtor$4@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBVNode@BymlFile@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBVNode@BymlFile@@@1@$$QEAV?$tuple@$$V@1@@Z@4HA PROC ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > ><std::piecewise_construct_t const &,std::tuple<BymlFile::Node const &>,std::tuple<> >'::`1'::dtor$4
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 32					; 00000020H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBVNode@BymlFile@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBVNode@BymlFile@@@1@$$QEAV?$tuple@$$V@1@@Z@4HA ENDP ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > ><std::piecewise_construct_t const &,std::tuple<BymlFile::Node const &>,std::tuple<> >'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0AEAPEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@_N@std@@QEAA@AEAPEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@1@$$QEA_N@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$ = 24
??$?0AEAPEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@_N@std@@QEAA@AEAPEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@1@$$QEA_N@Z PROC ; std::pair<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> *,bool>::pair<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> *,bool><std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> * &,bool,0>, COMDAT

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [rcx+8], al

; 243  :     }

	mov	rax, rcx
	ret	0
??$?0AEAPEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@_N@std@@QEAA@AEAPEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@1@$$QEA_N@Z ENDP ; std::pair<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> *,bool>::pair<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> *,bool><std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> * &,bool,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0PEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@1@$$QEA_N@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$ = 24
??$?0PEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@1@$$QEA_N@Z PROC ; std::pair<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> *,bool>::pair<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> *,bool><std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> *,bool,0>, COMDAT

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [rcx+8], al

; 243  :     }

	mov	rax, rcx
	ret	0
??$?0PEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@1@$$QEA_N@Z ENDP ; std::pair<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> *,bool>::pair<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> *,bool><std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> *,bool,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@U?$pair@$$CBVNode@BymlFile@@I@std@@@std@@YA$$QEAU?$pair@$$CBVNode@BymlFile@@I@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@U?$pair@$$CBVNode@BymlFile@@I@std@@@std@@YA$$QEAU?$pair@$$CBVNode@BymlFile@@I@0@AEAU10@@Z PROC ; std::forward<std::pair<BymlFile::Node const ,unsigned int> >, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@U?$pair@$$CBVNode@BymlFile@@I@std@@@std@@YA$$QEAU?$pair@$$CBVNode@BymlFile@@I@0@AEAU10@@Z ENDP ; std::forward<std::pair<BymlFile::Node const ,unsigned int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??$?0U?$pair@$$CBVNode@BymlFile@@I@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBVNode@BymlFile@@I@1@@Z
_TEXT	SEGMENT
this$ = 48
$T1 = 56
_Al_$ = 56
<_Vals_0>$ = 64
??$?0U?$pair@$$CBVNode@BymlFile@@I@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBVNode@BymlFile@@I@1@@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > ><std::pair<BymlFile::Node const ,unsigned int> >, COMDAT

; 584  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

$LN52:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, r8
	mov	rsi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1144 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR [rcx], rdx
	xor	eax, eax

; 1151 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR [rcx+8], rax

; 87   :         return ::operator new(_Bytes);

	lea	ecx, QWORD PTR [rax+112]
	call	??2@YAPEAX_K@Z				; operator new

; 1152 :         _Ptr = _Al.allocate(1);

	mov	QWORD PTR [rsi+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 586  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

	lea	rbx, QWORD PTR [rax+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 246  :     pair(pair&&)      = default;

	mov	QWORD PTR $T1[rsp], rbx
	mov	rdx, rdi
	mov	rcx, rbx
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	npad	1
	movzx	eax, BYTE PTR [rdi+24]
	mov	BYTE PTR [rbx+24], al
	lea	rcx, QWORD PTR [rbx+32]
	lea	rdx, QWORD PTR [rdi+32]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rbx+64]
	lea	rdx, QWORD PTR [rdi+64]
	call	??0?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@AEBV01@@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::vector<BymlFile::Node,std::allocator<BymlFile::Node> >
	npad	1
	mov	eax, DWORD PTR [rdi+88]
	mov	DWORD PTR [rbx+88], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 587  :     }

	mov	rax, rsi
	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$?0U?$pair@$$CBVNode@BymlFile@@I@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBVNode@BymlFile@@I@1@@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > ><std::pair<BymlFile::Node const ,unsigned int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
$T1 = 56
_Al_$ = 56
<_Vals_0>$ = 64
?dtor$0@?0???$?0U?$pair@$$CBVNode@BymlFile@@I@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBVNode@BymlFile@@I@1@@Z@4HA PROC ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > ><std::pair<BymlFile::Node const ,unsigned int> >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > >
?dtor$0@?0???$?0U?$pair@$$CBVNode@BymlFile@@I@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBVNode@BymlFile@@I@1@@Z@4HA ENDP ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > ><std::pair<BymlFile::Node const ,unsigned int> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
$T1 = 56
_Al_$ = 56
<_Vals_0>$ = 64
?dtor$2@?0???$?0U?$pair@$$CBVNode@BymlFile@@I@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBVNode@BymlFile@@I@1@@Z@4HA PROC ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > ><std::pair<BymlFile::Node const ,unsigned int> >'::`1'::dtor$2
	mov	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$2@?0???$?0U?$pair@$$CBVNode@BymlFile@@I@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBVNode@BymlFile@@I@1@@Z@4HA ENDP ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > ><std::pair<BymlFile::Node const ,unsigned int> >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
$T1 = 56
_Al_$ = 56
<_Vals_0>$ = 64
?dtor$3@?0???$?0U?$pair@$$CBVNode@BymlFile@@I@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBVNode@BymlFile@@I@1@@Z@4HA PROC ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > ><std::pair<BymlFile::Node const ,unsigned int> >'::`1'::dtor$3
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 32					; 00000020H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0???$?0U?$pair@$$CBVNode@BymlFile@@I@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBVNode@BymlFile@@I@1@@Z@4HA ENDP ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > ><std::pair<BymlFile::Node const ,unsigned int> >'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEBV?$vector@EV?$allocator@E@std@@@std@@@std@@YAAEBV?$vector@EV?$allocator@E@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$vector@EV?$allocator@E@std@@@std@@@std@@YAAEBV?$vector@EV?$allocator@E@std@@@0@AEBV10@@Z PROC ; std::forward<std::vector<unsigned char,std::allocator<unsigned char> > const &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEBV?$vector@EV?$allocator@E@std@@@std@@@std@@YAAEBV?$vector@EV?$allocator@E@std@@@0@AEBV10@@Z ENDP ; std::forward<std::vector<unsigned char,std::allocator<unsigned char> > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple
;	COMDAT ??$forward_as_tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@std@@YA?AV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@0@AEBV?$vector@EV?$allocator@E@std@@@0@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
<_Args_0>$ = 16
??$forward_as_tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@std@@YA?AV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@0@AEBV?$vector@EV?$allocator@E@std@@@0@@Z PROC ; std::forward_as_tuple<std::vector<unsigned char,std::allocator<unsigned char> > const &>, COMDAT

; 144  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

	mov	QWORD PTR [rcx], rdx

; 1026 :     return tuple<_Types&&...>(_STD forward<_Types>(_Args)...);

	mov	rax, rcx

; 1027 : }

	ret	0
??$forward_as_tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@std@@YA?AV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@0@AEBV?$vector@EV?$allocator@E@std@@@0@@Z ENDP ; std::forward_as_tuple<std::vector<unsigned char,std::allocator<unsigned char> > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@$$QEAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
this$ = 48
_Al_$ = 56
<_Vals_0>$dead$ = 64
<_Vals_1>$ = 72
<_Vals_2>$dead$ = 80
??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@$$QEAV?$tuple@$$V@1@@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> > ><std::piecewise_construct_t const &,std::tuple<std::vector<unsigned char,std::allocator<unsigned char> > const &>,std::tuple<> >, COMDAT

; 584  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

$LN52:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, r9
	mov	rsi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1144 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR [rcx], rdx
	mov	QWORD PTR [rcx+8], 0

; 1151 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR [rcx+8], 0

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 48					; 00000030H
	call	??2@YAPEAX_K@Z				; operator new

; 1152 :         _Ptr = _Al.allocate(1);

	mov	QWORD PTR [rsi+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 586  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

	lea	rbx, QWORD PTR [rax+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	rdx, QWORD PTR [rdi]
	mov	rcx, rbx
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	mov	DWORD PTR [rbx+24], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 587  :     }

	mov	rax, rsi
	mov	rbx, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@$$QEAV?$tuple@$$V@1@@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> > ><std::piecewise_construct_t const &,std::tuple<std::vector<unsigned char,std::allocator<unsigned char> > const &>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Al_$ = 56
<_Vals_0>$dead$ = 64
<_Vals_1>$ = 72
<_Vals_2>$dead$ = 80
?dtor$0@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@$$QEAV?$tuple@$$V@1@@Z@4HA PROC ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> > ><std::piecewise_construct_t const &,std::tuple<std::vector<unsigned char,std::allocator<unsigned char> > const &>,std::tuple<> >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> > >
?dtor$0@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@$$QEAV?$tuple@$$V@1@@Z@4HA ENDP ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> > ><std::piecewise_construct_t const &,std::tuple<std::vector<unsigned char,std::allocator<unsigned char> > const &>,std::tuple<> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0AEAPEAU?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@_N@std@@QEAA@AEAPEAU?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@1@$$QEA_N@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$ = 24
??$?0AEAPEAU?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@_N@std@@QEAA@AEAPEAU?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@1@$$QEA_N@Z PROC ; std::pair<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> *,bool>::pair<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> *,bool><std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> * &,bool,0>, COMDAT

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [rcx+8], al

; 243  :     }

	mov	rax, rcx
	ret	0
??$?0AEAPEAU?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@_N@std@@QEAA@AEAPEAU?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@1@$$QEA_N@Z ENDP ; std::pair<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> *,bool>::pair<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> *,bool><std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> * &,bool,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0PEAU?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@1@$$QEA_N@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$ = 24
??$?0PEAU?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@1@$$QEA_N@Z PROC ; std::pair<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> *,bool>::pair<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> *,bool><std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> *,bool,0>, COMDAT

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [rcx+8], al

; 243  :     }

	mov	rax, rcx
	ret	0
??$?0PEAU?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@1@$$QEA_N@Z ENDP ; std::pair<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> *,bool>::pair<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> *,bool><std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> *,bool,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@std@@YA$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@std@@YA$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@0@AEAU10@@Z PROC ; std::forward<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@std@@YA$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@0@AEAU10@@Z ENDP ; std::forward<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??$?0U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@@Z
_TEXT	SEGMENT
this$ = 48
_Al_$ = 56
<_Vals_0>$ = 64
??$?0U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> > ><std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >, COMDAT

; 584  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

$LN47:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, r8
	mov	rsi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1144 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR [rcx], rdx
	xor	eax, eax

; 1151 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR [rcx+8], rax

; 87   :         return ::operator new(_Bytes);

	lea	ecx, QWORD PTR [rax+48]
	call	??2@YAPEAX_K@Z				; operator new

; 1152 :         _Ptr = _Al.allocate(1);

	mov	QWORD PTR [rsi+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 586  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

	lea	rbx, QWORD PTR [rax+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 246  :     pair(pair&&)      = default;

	mov	rdx, rdi
	mov	rcx, rbx
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	mov	eax, DWORD PTR [rdi+24]
	mov	DWORD PTR [rbx+24], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 587  :     }

	mov	rax, rsi
	mov	rbx, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$?0U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> > ><std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Al_$ = 56
<_Vals_0>$ = 64
?dtor$0@?0???$?0U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@@Z@4HA PROC ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> > ><std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> > >
?dtor$0@?0???$?0U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@@Z@4HA ENDP ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> > ><std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 64
_Newsize$ = 72
_Val$dead$ = 80
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Resize_reallocate<std::_Value_init_tag>, COMDAT

; 1511 :     _CONSTEXPR20 void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

$LN77:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1512 :         if (_Newsize > max_size()) {

	mov	rbx, 576460752303423487			; 07ffffffffffffffH
	mov	rsi, rdx
	mov	rdi, rcx
	cmp	rdx, rbx
	ja	$LN75@Resize_rea
	mov	QWORD PTR [rsp+80], rbp

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, rbx

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rbp, QWORD PTR [rcx+8]
	sub	rbp, QWORD PTR [rcx]

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, QWORD PTR [rdi]
	sar	rcx, 5

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	sar	rbp, 5

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	shr	rdx, 1
	sub	rax, rdx
	cmp	rcx, rax
	ja	SHORT $LN11@Resize_rea

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rbx, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rbx, rsi
	cmovb	rbx, rsi
$LN11@Resize_rea:

; 1522 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1523 : 
; 1524 :         const pointer _Newvec         = _Al.allocate(_Newcapacity);

	mov	rdx, rbx
	call	?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate

; 1525 :         const pointer _Appended_first = _Newvec + _Oldsize;

	mov	rdx, rbp

; 1526 :         pointer _Appended_last        = _Appended_first;
; 1527 : 
; 1528 :         _TRY_BEGIN
; 1529 :         if constexpr (is_same_v<_Ty2, _Ty>) {
; 1530 :             _Appended_last = _Uninitialized_fill_n(_Appended_first, _Newsize - _Oldsize, _Val, _Al);
; 1531 :         } else {
; 1532 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1533 :             _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);

	mov	r10, rsi
	shl	rdx, 5
	mov	r11, rax
	add	rdx, rax
	sub	r10, rbp
	mov	rbp, QWORD PTR [rsp+80]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2041 :     for (; 0 < _Count; --_Count) {

	je	SHORT $LN17@Resize_rea
	xor	eax, eax
	npad	4
$LL18@Resize_rea:

; 1803 :         ++_Last;

	lea	rdx, QWORD PTR [rdx+32]
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rdx-32], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdx-16], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdx-8], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdx-32], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2041 :     for (; 0 < _Count; --_Count) {

	sub	r10, 1
	jne	SHORT $LL18@Resize_rea
$LN17@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1537 :             _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	rdx, QWORD PTR [rdi+8]
	mov	r8, r11
	mov	rcx, QWORD PTR [rdi]
	call	??$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1538 :         } else {
; 1539 :             _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 1540 :         }
; 1541 :         _CATCH_ALL
; 1542 :         _Destroy_range(_Appended_first, _Appended_last, _Al);
; 1543 :         _Al.deallocate(_Newvec, _Newcapacity);
; 1544 :         _RERAISE;
; 1545 :         _CATCH_END
; 1546 : 
; 1547 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, rbx
	mov	r8, rsi
	mov	rdx, r11
	mov	rcx, rdi

; 1548 :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbx

; 1538 :         } else {
; 1539 :             _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 1540 :         }
; 1541 :         _CATCH_ALL
; 1542 :         _Destroy_range(_Appended_first, _Appended_last, _Al);
; 1543 :         _Al.deallocate(_Newvec, _Newcapacity);
; 1544 :         _RERAISE;
; 1545 :         _CATCH_END
; 1546 : 
; 1547 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	jmp	?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K1@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Change_array
$LN75@Resize_rea:

; 1513 :             _Xlength();

	call	?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlength
	int	3
$LN73@Resize_rea:
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PEAV10@_KAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Count$ = 16
_Al$dead$ = 24
??$_Uninitialized_value_construct_n@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PEAV10@_KAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 2027 :     // value-initialize _Count objects to raw _First, using _Al
; 2028 :     using _Ptrty = typename _Alloc::value_type*;
; 2029 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2030 : #if _HAS_CXX20
; 2031 :         if (!_STD is_constant_evaluated())
; 2032 : #endif // _HAS_CXX20
; 2033 :         {
; 2034 :             auto _PFirst = _Unfancy(_First);
; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2036 :             return _First + _Count;
; 2037 :         }
; 2038 :     }
; 2039 : 
; 2040 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2041 :     for (; 0 < _Count; --_Count) {

	test	rdx, rdx
	je	SHORT $LN56@Uninitiali
	xor	eax, eax
	npad	9
$LL4@Uninitiali:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rcx, 32					; 00000020H

; 2027 :     // value-initialize _Count objects to raw _First, using _Al
; 2028 :     using _Ptrty = typename _Alloc::value_type*;
; 2029 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2030 : #if _HAS_CXX20
; 2031 :         if (!_STD is_constant_evaluated())
; 2032 : #endif // _HAS_CXX20
; 2033 :         {
; 2034 :             auto _PFirst = _Unfancy(_First);
; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2036 :             return _First + _Count;
; 2037 :         }
; 2038 :     }
; 2039 : 
; 2040 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rdx, 1
	jne	SHORT $LL4@Uninitiali
$LN56@Uninitiali:

; 2042 :         _Backout._Emplace_back();
; 2043 :     }
; 2044 : 
; 2045 :     return _Backout._Release();
; 2046 : }

	mov	rax, rcx
	ret	0
??$_Uninitialized_value_construct_n@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PEAV10@_KAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 64
_Newsize$ = 72
_Val$dead$ = 80
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT

; 1511 :     _CONSTEXPR20 void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

$LN88:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1512 :         if (_Newsize > max_size()) {

	mov	rbx, 209622091746699450			; 02e8ba2e8ba2e8baH
	mov	rdi, rdx
	mov	rsi, rcx
	cmp	rdx, rbx
	ja	$LN86@Resize_rea

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	QWORD PTR [rsp+80], rbp
	mov	rdx, 3353953467947191203		; 2e8ba2e8ba2e8ba3H
	mov	rbp, QWORD PTR [rcx+8]

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, rbx

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	sub	rbp, QWORD PTR [rcx]

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, QWORD PTR [rsi]
	sar	rcx, 3
	imul	rcx, rdx

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	sar	rbp, 3
	imul	rbp, rdx

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	mov	QWORD PTR [rsp+88], r14
	shr	rdx, 1
	sub	rax, rdx
	cmp	rcx, rax
	ja	SHORT $LN11@Resize_rea

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rbx, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rbx, rdi
	cmovb	rbx, rdi
$LN11@Resize_rea:

; 1524 :         const pointer _Newvec         = _Al.allocate(_Newcapacity);

	mov	rdx, rbx
	call	?allocate@?$allocator@VNode@BymlFile@@@std@@QEAAPEAVNode@BymlFile@@_K@Z ; std::allocator<BymlFile::Node>::allocate

; 1525 :         const pointer _Appended_first = _Newvec + _Oldsize;

	imul	r10, rbp, 88				; 00000058H

; 1526 :         pointer _Appended_last        = _Appended_first;
; 1527 : 
; 1528 :         _TRY_BEGIN
; 1529 :         if constexpr (is_same_v<_Ty2, _Ty>) {
; 1530 :             _Appended_last = _Uninitialized_fill_n(_Appended_first, _Newsize - _Oldsize, _Val, _Al);
; 1531 :         } else {
; 1532 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1533 :             _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);

	mov	r11, rdi
	mov	r14, rax
	add	r10, rax
	sub	r11, rbp
	mov	rbp, QWORD PTR [rsp+80]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2041 :     for (; 0 < _Count; --_Count) {

	je	SHORT $LN17@Resize_rea
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1524 :         const pointer _Newvec         = _Al.allocate(_Newcapacity);

	lea	rdx, QWORD PTR [r10+56]
	xor	eax, eax
	npad	12
$LL18@Resize_rea:

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [r10], rax
	xorps	xmm0, xmm0
	mov	QWORD PTR [rdx-48], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	lea	r10, QWORD PTR [r10+88]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rdx-40], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rdx-24], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdx-8], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdx], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdx-24], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rdx+8], rax
	mov	QWORD PTR [rdx+16], rax
	mov	QWORD PTR [rdx+24], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	lea	rdx, QWORD PTR [rdx+88]

; 2041 :     for (; 0 < _Count; --_Count) {

	sub	r11, 1
	jne	SHORT $LL18@Resize_rea
$LN17@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1537 :             _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	rdx, QWORD PTR [rsi+8]
	mov	r8, r14
	mov	rcx, QWORD PTR [rsi]
	call	??$_Uninitialized_move@PEAVNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@QEAV12@0PEAV12@AEAV?$allocator@VNode@BymlFile@@@0@@Z ; std::_Uninitialized_move<BymlFile::Node *,std::allocator<BymlFile::Node> >

; 1538 :         } else {
; 1539 :             _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 1540 :         }
; 1541 :         _CATCH_ALL
; 1542 :         _Destroy_range(_Appended_first, _Appended_last, _Al);
; 1543 :         _Al.deallocate(_Newvec, _Newcapacity);
; 1544 :         _RERAISE;
; 1545 :         _CATCH_END
; 1546 : 
; 1547 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, rbx
	mov	r8, rdi
	mov	rdx, r14
	mov	rcx, rsi
	mov	r14, QWORD PTR [rsp+88]

; 1548 :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbx

; 1538 :         } else {
; 1539 :             _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 1540 :         }
; 1541 :         _CATCH_ALL
; 1542 :         _Destroy_range(_Appended_first, _Appended_last, _Al);
; 1543 :         _Al.deallocate(_Newvec, _Newcapacity);
; 1544 :         _RERAISE;
; 1545 :         _CATCH_END
; 1546 : 
; 1547 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	jmp	?_Change_array@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAXQEAVNode@BymlFile@@_K1@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Change_array
$LN86@Resize_rea:

; 1513 :             _Xlength();

	call	?_Xlength@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@CAXXZ ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Xlength
	int	3
$LN84@Resize_rea:
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@PEAV12@_KAEAV?$allocator@VNode@BymlFile@@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Count$ = 16
_Al$dead$ = 24
??$_Uninitialized_value_construct_n@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@PEAV12@_KAEAV?$allocator@VNode@BymlFile@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<BymlFile::Node> >, COMDAT

; 2026 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

	mov	rax, rcx

; 2027 :     // value-initialize _Count objects to raw _First, using _Al
; 2028 :     using _Ptrty = typename _Alloc::value_type*;
; 2029 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2030 : #if _HAS_CXX20
; 2031 :         if (!_STD is_constant_evaluated())
; 2032 : #endif // _HAS_CXX20
; 2033 :         {
; 2034 :             auto _PFirst = _Unfancy(_First);
; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2036 :             return _First + _Count;
; 2037 :         }
; 2038 :     }
; 2039 : 
; 2040 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2041 :     for (; 0 < _Count; --_Count) {

	test	rdx, rdx
	je	SHORT $LN102@Uninitiali
	add	rcx, 56					; 00000038H
	xor	r8d, r8d
	npad	1
$LL4@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rax], r8
	xorps	xmm0, xmm0
	mov	QWORD PTR [rcx-48], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rax, 88					; 00000058H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx-40], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx-24], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx-8], r8

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx-24], r8b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r8
	mov	QWORD PTR [rcx+24], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	lea	rcx, QWORD PTR [rcx+88]

; 2027 :     // value-initialize _Count objects to raw _First, using _Al
; 2028 :     using _Ptrty = typename _Alloc::value_type*;
; 2029 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2030 : #if _HAS_CXX20
; 2031 :         if (!_STD is_constant_evaluated())
; 2032 : #endif // _HAS_CXX20
; 2033 :         {
; 2034 :             auto _PFirst = _Unfancy(_First);
; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2036 :             return _First + _Count;
; 2037 :         }
; 2038 :     }
; 2039 : 
; 2040 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rdx, 1
	jne	SHORT $LL4@Uninitiali
$LN102@Uninitiali:

; 2042 :         _Backout._Emplace_back();
; 2043 :     }
; 2044 : 
; 2045 :     return _Backout._Release();
; 2046 : }

	ret	0
??$_Uninitialized_value_construct_n@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@PEAV12@_KAEAV?$allocator@VNode@BymlFile@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<BymlFile::Node> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEBVNode@BymlFile@@@std@@YA?A_TAEBQEBVNode@BymlFile@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEBVNode@BymlFile@@@std@@YA?A_TAEBQEBVNode@BymlFile@@@Z PROC ; std::_Get_unwrapped<BymlFile::Node const * const &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEBQEBVNode@BymlFile@@@std@@YA?A_TAEBQEBVNode@BymlFile@@@Z ENDP ; std::_Get_unwrapped<BymlFile::Node const * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Idl_distance@PEBVNode@BymlFile@@PEBV12@@std@@YA?A_PAEBQEBVNode@BymlFile@@0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Idl_distance@PEBVNode@BymlFile@@PEBV12@@std@@YA?A_PAEBQEBVNode@BymlFile@@0@Z PROC ; std::_Idl_distance<BymlFile::Node const *,BymlFile::Node const *>, COMDAT

; 1317 :     // tries to get the distance between _First and _Last if they are random-access iterators
; 1318 :     if constexpr (_Is_ranges_random_iter_v<_Iter>) {
; 1319 :         return static_cast<_Iter_diff_t<_Checked>>(_Last - _First);

	mov	rax, QWORD PTR [rdx]
	sub	rax, QWORD PTR [rcx]
	mov	rcx, 3353953467947191203		; 2e8ba2e8ba2e8ba3H
	sar	rax, 3
	imul	rax, rcx

; 1320 :     } else {
; 1321 :         return _Distance_unknown{};
; 1322 :     }
; 1323 : }

	ret	0
??$_Idl_distance@PEBVNode@BymlFile@@PEBV12@@std@@YA?A_PAEBQEBVNode@BymlFile@@0@Z ENDP ; std::_Idl_distance<BymlFile::Node const *,BymlFile::Node const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped_n@AEBQEBVNode@BymlFile@@_J@std@@YA?A_TAEBQEBVNode@BymlFile@@_J@Z
_TEXT	SEGMENT
_It$ = 8
_Off$dead$ = 16
??$_Get_unwrapped_n@AEBQEBVNode@BymlFile@@_J@std@@YA?A_TAEBQEBVNode@BymlFile@@_J@Z PROC ; std::_Get_unwrapped_n<BymlFile::Node const * const &,__int64>, COMDAT

; 1222 :     if constexpr (is_pointer_v<decay_t<_Iter>>) {
; 1223 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1224 :     } else if constexpr (_Unwrappable_for_offset_v<_Iter> && is_integral_v<_Diff>) {
; 1225 :         // ask an iterator to assert that the iterator moved _Off positions is valid, and unwrap
; 1226 :         using _IDiff     = _Iter_diff_t<_Remove_cvref_t<_Iter>>;
; 1227 :         using _CDiff     = common_type_t<_Diff, _IDiff>;
; 1228 :         const auto _COff = static_cast<_CDiff>(_Off);
; 1229 : 
; 1230 :         _STL_ASSERT(_COff <= static_cast<_CDiff>(_Max_possible_v<_IDiff>)
; 1231 :                         && (is_unsigned_v<_Diff> || static_cast<_CDiff>(_Min_possible_v<_IDiff>) <= _COff),
; 1232 :             "integer overflow");
; 1233 :         (void) _COff;
; 1234 : 
; 1235 :         _It._Verify_offset(static_cast<_IDiff>(_Off));
; 1236 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1237 :     } else if constexpr (_Unwrappable_for_unverified_v<_Iter>) {
; 1238 :         // iterator doesn't support offset-based asserts, or offset unknown; defer to unverified unwrap
; 1239 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1240 :     } else {
; 1241 :         // pass through iterator that doesn't participate in checking
; 1242 :         return static_cast<_Iter&&>(_It);
; 1243 :     }
; 1244 : }

	ret	0
??$_Get_unwrapped_n@AEBQEBVNode@BymlFile@@_J@std@@YA?A_TAEBQEBVNode@BymlFile@@_J@Z ENDP ; std::_Get_unwrapped_n<BymlFile::Node const * const &,__int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$equal@PEBVNode@BymlFile@@PEBV12@U?$equal_to@X@std@@@std@@YA_NQEBVNode@BymlFile@@00U?$equal_to@X@0@@Z
_TEXT	SEGMENT
_First1$ = 48
_Last1$ = 56
_First2$ = 64
_Pred$dead$ = 72
??$equal@PEBVNode@BymlFile@@PEBV12@U?$equal_to@X@std@@@std@@YA_NQEBVNode@BymlFile@@00U?$equal_to@X@0@@Z PROC ; std::equal<BymlFile::Node const *,BymlFile::Node const *,std::equal_to<void> >, COMDAT

; 5258 : _NODISCARD _CONSTEXPR20 bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, _Pr _Pred) {

$LN142:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, r8
	mov	rdi, rdx
	mov	rbx, rcx

; 5259 :     // compare [_First1, _Last1) to [_First2, ...)
; 5260 :     _Adl_verify_range(_First1, _Last1);
; 5261 :     auto _UFirst1      = _Get_unwrapped(_First1);
; 5262 :     const auto _ULast1 = _Get_unwrapped(_Last1);
; 5263 :     auto _UFirst2      = _Get_unwrapped_n(_First2, _Idl_distance<_InIt1>(_UFirst1, _ULast1));
; 5264 :     if constexpr (_Equal_memcmp_is_safe<decltype(_UFirst1), decltype(_UFirst2), _Pr>) {
; 5265 : #if _HAS_CXX20
; 5266 :         if (!_STD is_constant_evaluated())
; 5267 : #endif // _HAS_CXX20
; 5268 :         {
; 5269 :             return _Memcmp_ranges(_UFirst1, _ULast1, _UFirst2) == 0;
; 5270 :         }
; 5271 :     }
; 5272 : 
; 5273 :     for (; _UFirst1 != _ULast1; ++_UFirst1, (void) ++_UFirst2) {

	cmp	rcx, rdx
	je	SHORT $LN3@equal

; 5258 : _NODISCARD _CONSTEXPR20 bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, _Pr _Pred) {

	sub	rsi, rcx
$LL4@equal:

; 486  :         return static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right);

	lea	rdx, QWORD PTR [rsi+rbx]
	mov	rcx, rbx
	call	??8Node@BymlFile@@QEBA_NAEBV01@@Z	; BymlFile::Node::operator==

; 5274 :         if (!_Pred(*_UFirst1, *_UFirst2)) {

	test	al, al
	je	SHORT $LN135@equal

; 5259 :     // compare [_First1, _Last1) to [_First2, ...)
; 5260 :     _Adl_verify_range(_First1, _Last1);
; 5261 :     auto _UFirst1      = _Get_unwrapped(_First1);
; 5262 :     const auto _ULast1 = _Get_unwrapped(_Last1);
; 5263 :     auto _UFirst2      = _Get_unwrapped_n(_First2, _Idl_distance<_InIt1>(_UFirst1, _ULast1));
; 5264 :     if constexpr (_Equal_memcmp_is_safe<decltype(_UFirst1), decltype(_UFirst2), _Pr>) {
; 5265 : #if _HAS_CXX20
; 5266 :         if (!_STD is_constant_evaluated())
; 5267 : #endif // _HAS_CXX20
; 5268 :         {
; 5269 :             return _Memcmp_ranges(_UFirst1, _ULast1, _UFirst2) == 0;
; 5270 :         }
; 5271 :     }
; 5272 : 
; 5273 :     for (; _UFirst1 != _ULast1; ++_UFirst1, (void) ++_UFirst2) {

	add	rbx, 88					; 00000058H
	cmp	rbx, rdi
	jne	SHORT $LL4@equal
$LN3@equal:

; 5275 :             return false;
; 5276 :         }
; 5277 :     }
; 5278 : 
; 5279 :     return true;

	mov	al, 1

; 5280 : }

	mov	rbx, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN135@equal:
	mov	rbx, QWORD PTR [rsp+56]
	xor	al, al
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$equal@PEBVNode@BymlFile@@PEBV12@U?$equal_to@X@std@@@std@@YA_NQEBVNode@BymlFile@@00U?$equal_to@X@0@@Z ENDP ; std::equal<BymlFile::Node const *,BymlFile::Node const *,std::equal_to<void> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Insertion_sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
_TEXT	SEGMENT
tv2907 = 32
$T1 = 40
$T2 = 40
$T3 = 72
$T4 = 72
_Mid$1$ = 104
_Val$2$ = 112
_First$GSCopy$1$ = 120
_Ptr$1$ = 128
_Last$1$ = 136
$T5 = 144
$T6 = 144
_Val$4$ = 152
_Val$5$ = 168
_Val$7 = 192
__$ArrayPad$ = 224
_First$ = 288
_Last$ = 296
_Pred$dead$ = 304
??$_Insertion_sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z PROC ; std::_Insertion_sort_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >, COMDAT

; 7905 : _CONSTEXPR20 _BidIt _Insertion_sort_unchecked(const _BidIt _First, const _BidIt _Last, _Pr _Pred) {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-55]
	sub	rsp, 240				; 000000f0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-185], rax
	mov	rax, rdx
	mov	QWORD PTR _Last$1$[rbp-185], rdx
	mov	r15, rcx
	mov	QWORD PTR _First$GSCopy$1$[rbp-185], rcx

; 7906 :     // insertion sort [_First, _Last)
; 7907 :     if (_First != _Last) {

	cmp	rcx, rdx
	je	$LN3@Insertion_

; 7908 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

	lea	r12, QWORD PTR [rcx+32]
	cmp	r12, rdx
$LN565@Insertion_:

; 7909 :             _BidIt _Hole               = _Mid;

	mov	QWORD PTR _Mid$1$[rbp-185], r12
	je	$LN3@Insertion_
	mov	r9, -1
	lea	r8d, QWORD PTR [r9+23]
	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	xor	edx, edx
	mov	rdi, r12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r12]
	movups	XMMWORD PTR _Val$4$[rbp-185], xmm0
	movups	XMMWORD PTR _Val$7[rbp-185], xmm0
	movups	xmm2, XMMWORD PTR [r12+16]
	movups	XMMWORD PTR _Val$5$[rbp-185], xmm2
	movups	XMMWORD PTR _Val$7[rbp-169], xmm2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7910 :             _Iter_value_t<_BidIt> _Val = _STD move(*_Mid);

	mov	QWORD PTR [r12+16], rdx
	mov	QWORD PTR [r12+24], 15
	mov	BYTE PTR [r12], dl

; 7912 :             if (_DEBUG_LT_PRED(_Pred, _Val, *_First)) { // found new earliest element, move to front

	lea	rax, QWORD PTR $T2[rsp]
	mov	QWORD PTR $T6[rbp-185], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T2[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T2[rsp+16], rdx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T2[rbp-161], rdx

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rsi, QWORD PTR [r15+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r14, r15

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [r15+24], 16
	jb	SHORT $LN58@Insertion_

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r14, QWORD PTR [r15]
$LN58@Insertion_:

; 2620 :         if (_Count > max_size()) {

	cmp	rsi, rcx
	ja	$LN472@Insertion_

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T2[rbp-161], 15
	cmp	rsi, 16
	jae	SHORT $LN64@Insertion_

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T2[rsp+16], rsi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR $T2[rsp], xmm0

; 2647 :             return;

	jmp	SHORT $LN80@Insertion_
$LN64@Insertion_:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rbx, rsi
	or	rbx, 15
	cmp	rbx, rcx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN75@Insertion_

; 4716 :             return _Max;

	mov	rbx, rcx
	jmp	SHORT $LN74@Insertion_
$LN75@Insertion_:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rbx, 22
	cmovb	rbx, r8
$LN74@Insertion_:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rbx
	add	rdx, 1
	cmovb	rdx, r9
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T2[rsp], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T2[rsp+16], rsi

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T2[rbp-161], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rsi+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14
	mov	rcx, rax
	call	memcpy
	movups	xmm2, XMMWORD PTR _Val$5$[rbp-185]
	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	mov	r8d, 22
	lea	r9, QWORD PTR [r8-23]
$LN80@Insertion_:
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T4[rbp-185], xmm0

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rsi, QWORD PTR _Val$7[rbp-185]

; 2244 :         return _BUF_SIZE <= _Myres;

	movdqa	xmm1, xmm2
	psrldq	xmm1, 8
	movq	rax, xmm1
	mov	QWORD PTR _Val$2$[rbp-185], rax
	cmp	rax, 16
	setae	BYTE PTR tv2907[rsp]

; 2236 :         if (_Large_string_engaged()) {

	mov	r14, QWORD PTR _Val$4$[rbp-185]
	mov	QWORD PTR _Ptr$1$[rbp-185], r14
	cmovae	rsi, r14

; 2620 :         if (_Count > max_size()) {

	movq	r13, xmm2
	cmp	r13, rcx
	ja	$LN473@Insertion_

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	cmp	r13, 16
	jae	SHORT $LN105@Insertion_

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T4[rbp-169], r13

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T4[rbp-161], 15

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [rsi]
	movups	XMMWORD PTR $T4[rbp-185], xmm0

; 2647 :             return;

	jmp	SHORT $LN121@Insertion_
$LN105@Insertion_:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rbx, r13
	or	rbx, 15
	cmp	rbx, rcx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN116@Insertion_

; 4716 :             return _Max;

	mov	rbx, rcx
	jmp	SHORT $LN115@Insertion_
$LN116@Insertion_:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rbx, 22
	cmovb	rbx, r8
$LN115@Insertion_:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rbx
	add	rdx, 1
	cmovb	rdx, r9
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T4[rbp-185], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T4[rbp-169], r13

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T4[rbp-161], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [r13+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rsi
	mov	rcx, rax
	call	memcpy
	npad	1
$LN121@Insertion_:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 535  :     std::sort(this->m_HashKeyTable.begin(), this->m_HashKeyTable.end(), [](std::string A, std::string B) { return A < B; });

	lea	rdx, QWORD PTR $T2[rsp]
	lea	rcx, QWORD PTR $T4[rbp-185]
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
	movzx	ebx, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T4[rbp-185]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR $T2[rsp]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7912 :             if (_DEBUG_LT_PRED(_Pred, _Val, *_First)) { // found new earliest element, move to front

	test	bl, bl
	jns	$LN9@Insertion_

; 7913 :                 _Move_backward_unchecked(_First, _Mid, ++_Hole);

	lea	rdi, QWORD PTR [r12+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4940 :     while (_First != _Last) {

	cmp	r15, r12
	je	$LN140@Insertion_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7913 :                 _Move_backward_unchecked(_First, _Mid, ++_Hole);

	mov	rbx, r12
	npad	2
$LL139@Insertion_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4941 :         *--_Dest = _STD move(*--_Last);

	mov	rsi, rbx
	sub	rdi, 32					; 00000020H
	sub	rbx, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2961 :         if (this == _STD addressof(_Right)) {

	cmp	rdi, rbx
	je	SHORT $LN189@Insertion_

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR [rbx+56]

; 4832 :         if (_My_data._Large_string_engaged()) {

	cmp	rdx, 16
	jb	SHORT $LN154@Insertion_

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;

	mov	rcx, QWORD PTR [rdi]

; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN166@Insertion_

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN398@Insertion_

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN166@Insertion_:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN154@Insertion_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	xor	eax, eax
	mov	QWORD PTR [rbx+48], rax

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+56], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], al

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rbx]
	movups	XMMWORD PTR [rdi], xmm0
	movups	xmm1, XMMWORD PTR [rbx+16]
	movups	XMMWORD PTR [rdi+16], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rsi-16], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rsi-8], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], al
$LN189@Insertion_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4940 :     while (_First != _Last) {

	cmp	r15, rbx
	jne	SHORT $LL139@Insertion_
$LN140@Insertion_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2961 :         if (this == _STD addressof(_Right)) {

	lea	rax, QWORD PTR _Val$7[rbp-185]
	cmp	r15, rax
	je	$LN561@Insertion_

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR [r15+24]

; 4832 :         if (_My_data._Large_string_engaged()) {

	cmp	rdx, 16
	jb	SHORT $LN203@Insertion_

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;

	mov	rcx, QWORD PTR [r15]

; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN215@Insertion_

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN398@Insertion_

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN215@Insertion_:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN203@Insertion_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR _Val$4$[rbp-185]
	movups	XMMWORD PTR [r15], xmm0
	movups	xmm0, XMMWORD PTR _Val$5$[rbp-185]
	movups	XMMWORD PTR [r15+16], xmm0

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	edx, 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR _Val$7[rbp-185], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7915 :             } else { // look for insertion point after first

	mov	r14, QWORD PTR _Val$7[rbp-185]
	jmp	$LN424@Insertion_
$LN9@Insertion_:

; 7916 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

	mov	rsi, r12
	xor	ecx, ecx
	npad	6
$LL7@Insertion_:
	mov	r12, rsi
	lea	rax, QWORD PTR $T1[rsp]
	mov	QWORD PTR $T5[rbp-185], rax
	sub	rsi, 32					; 00000020H
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T1[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T1[rsp+16], rcx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T1[rbp-161], rcx

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r14, QWORD PTR [r12-16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r15, rsi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [r12-8], 16
	jb	SHORT $LN250@Insertion_

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r15, QWORD PTR [rsi]
$LN250@Insertion_:

; 2620 :         if (_Count > max_size()) {

	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	cmp	r14, rcx
	ja	$LN470@Insertion_

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T1[rbp-161], 15
	cmp	r14, 16
	jae	SHORT $LN256@Insertion_

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T1[rsp+16], r14

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r15]
	movups	XMMWORD PTR $T1[rsp], xmm0

; 2647 :             return;

	jmp	SHORT $LN272@Insertion_
$LN256@Insertion_:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rbx, r14
	or	rbx, 15
	cmp	rbx, rcx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN267@Insertion_

; 4716 :             return _Max;

	mov	rbx, rcx
	jmp	SHORT $LN266@Insertion_
$LN267@Insertion_:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rbx, 22
	mov	eax, 22
	cmovb	rbx, rax
$LN266@Insertion_:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rbx
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T1[rsp], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T1[rsp+16], r14

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T1[rbp-161], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [r14+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r15
	mov	rcx, rax
	call	memcpy
	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
$LN272@Insertion_:
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T3[rbp-185], xmm0

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	r14, QWORD PTR _Val$7[rbp-185]

; 2236 :         if (_Large_string_engaged()) {

	cmp	BYTE PTR tv2907[rsp], 0
	cmovne	r14, QWORD PTR _Ptr$1$[rbp-185]

; 2628 :         if (_Count < _BUF_SIZE) {

	cmp	r13, 16
	jae	SHORT $LN296@Insertion_

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T3[rbp-169], r13

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T3[rbp-161], 15

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR $T3[rbp-185], xmm0

; 2647 :             return;

	jmp	SHORT $LN312@Insertion_
$LN296@Insertion_:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rbx, r13
	or	rbx, 15
	cmp	rbx, rcx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN307@Insertion_

; 4716 :             return _Max;

	mov	rbx, rcx
	jmp	SHORT $LN306@Insertion_
$LN307@Insertion_:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rbx, 22
	mov	eax, 22
	cmovb	rbx, rax
$LN306@Insertion_:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rbx
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T3[rbp-185], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T3[rbp-169], r13

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T3[rbp-161], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [r13+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14
	mov	rcx, rax
	call	memcpy
	npad	1
$LN312@Insertion_:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 535  :     std::sort(this->m_HashKeyTable.begin(), this->m_HashKeyTable.end(), [](std::string A, std::string B) { return A < B; });

	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR $T3[rbp-185]
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
	movzx	ebx, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T3[rbp-185]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR $T1[rsp]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7916 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

	test	bl, bl
	jns	SHORT $LN6@Insertion_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2961 :         if (this == _STD addressof(_Right)) {

	cmp	rdi, rsi
	je	SHORT $LN562@Insertion_

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 16

; 4832 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN341@Insertion_

; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN353@Insertion_

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN398@Insertion_

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN353@Insertion_:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN341@Insertion_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	xor	ecx, ecx
	mov	QWORD PTR [rdi+16], rcx

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdi+24], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], cl

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rsi]
	movups	XMMWORD PTR [rdi], xmm0
	movups	xmm1, XMMWORD PTR [rsi+16]
	movups	XMMWORD PTR [rdi+16], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [r12-16], rcx

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [r12-8], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rsi], cl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7916 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

	mov	rdi, rsi
	jmp	$LL7@Insertion_
$LN562@Insertion_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2961 :         if (this == _STD addressof(_Right)) {

	xor	ecx, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7916 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

	mov	rdi, rsi
	jmp	$LL7@Insertion_
$LN6@Insertion_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2961 :         if (this == _STD addressof(_Right)) {

	lea	rax, QWORD PTR _Val$7[rbp-185]
	cmp	rdi, rax
	je	SHORT $LN560@Insertion_

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR [rdi+24]

; 4832 :         if (_My_data._Large_string_engaged()) {

	cmp	rdx, 16
	jb	SHORT $LN389@Insertion_

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;

	mov	rcx, QWORD PTR [rdi]

; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN401@Insertion_

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN398@Insertion_

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN401@Insertion_:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN389@Insertion_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR _Val$4$[rbp-185]
	movups	XMMWORD PTR [rdi], xmm0
	movups	xmm0, XMMWORD PTR _Val$5$[rbp-185]
	movups	XMMWORD PTR [rdi+16], xmm0

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	edx, 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR _Val$7[rbp-185], 0
	mov	r14, QWORD PTR _Val$7[rbp-185]
	mov	r15, QWORD PTR _First$GSCopy$1$[rbp-185]

; 2961 :         if (this == _STD addressof(_Right)) {

	mov	r12, QWORD PTR _Mid$1$[rbp-185]
	jmp	SHORT $LN424@Insertion_
$LN560@Insertion_:
	mov	r15, QWORD PTR _First$GSCopy$1$[rbp-185]
	mov	r12, QWORD PTR _Mid$1$[rbp-185]
	mov	r14, QWORD PTR _Ptr$1$[rbp-185]
$LN561@Insertion_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7922 :         }

	mov	rdx, QWORD PTR _Val$2$[rbp-185]
$LN424@Insertion_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	rdx, 16

; 4832 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN437@Insertion_

; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, r14

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN449@Insertion_

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r14, QWORD PTR [r14-8]
	sub	rax, r14

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN446@Insertion_
$LN449@Insertion_:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, r14
	call	??3@YAXPEAX_K@Z				; operator delete
$LN437@Insertion_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7908 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

	add	r12, 32					; 00000020H
	mov	rax, QWORD PTR _Last$1$[rbp-185]
	cmp	r12, rax
	jmp	$LN565@Insertion_
$LN398@Insertion_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN446@Insertion_:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN3@Insertion_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7926 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-185]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+240]
	mov	rbx, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	mov	rdi, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
$LN472@Insertion_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN470@Insertion_:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN473@Insertion_:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN563@Insertion_:
??$_Insertion_sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ENDP ; std::_Insertion_sort_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv2907 = 32
$T1 = 40
$T2 = 40
$T3 = 72
$T4 = 72
_Mid$1$ = 104
_Val$2$ = 112
_First$GSCopy$1$ = 120
_Ptr$1$ = 128
_Last$1$ = 136
$T5 = 144
$T6 = 144
_Val$4$ = 152
_Val$5$ = 168
_Val$7 = 192
__$ArrayPad$ = 224
_First$ = 288
_Last$ = 296
_Pred$dead$ = 304
?dtor$0@?0???$_Insertion_sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA PROC ; `std::_Insertion_sort_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Val$7[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$_Insertion_sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA ENDP ; `std::_Insertion_sort_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv2907 = 32
$T1 = 40
$T2 = 40
$T3 = 72
$T4 = 72
_Mid$1$ = 104
_Val$2$ = 112
_First$GSCopy$1$ = 120
_Ptr$1$ = 128
_Last$1$ = 136
$T5 = 144
$T6 = 144
_Val$4$ = 152
_Val$5$ = 168
_Val$7 = 192
__$ArrayPad$ = 224
_First$ = 288
_Last$ = 296
_Pred$dead$ = 304
?dtor$1@?0???$_Insertion_sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA PROC ; `std::_Insertion_sort_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >'::`1'::dtor$1
	mov	rcx, QWORD PTR $T6[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0???$_Insertion_sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA ENDP ; `std::_Insertion_sort_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv2907 = 32
$T1 = 40
$T2 = 40
$T3 = 72
$T4 = 72
_Mid$1$ = 104
_Val$2$ = 112
_First$GSCopy$1$ = 120
_Ptr$1$ = 128
_Last$1$ = 136
$T5 = 144
$T6 = 144
_Val$4$ = 152
_Val$5$ = 168
_Val$7 = 192
__$ArrayPad$ = 224
_First$ = 288
_Last$ = 296
_Pred$dead$ = 304
?dtor$3@?0???$_Insertion_sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA PROC ; `std::_Insertion_sort_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >'::`1'::dtor$3
	mov	rcx, QWORD PTR $T5[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0???$_Insertion_sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA ENDP ; `std::_Insertion_sort_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Make_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
_TEXT	SEGMENT
_Val$1 = 48
__$ArrayPad$ = 80
_First$ = 144
_Last$ = 152
_Pred$ = 160
??$_Make_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z PROC ; std::_Make_heap_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >, COMDAT

; 6593 : _CONSTEXPR20 void _Make_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	movzx	ebx, r8b
	mov	rbp, rdx
	mov	r14, rcx

; 6594 :     // make [_First, _Last) into a heap
; 6595 :     using _Diff   = _Iter_diff_t<_RanIt>;
; 6596 :     _Diff _Bottom = _Last - _First;

	sub	rbp, rcx
	sar	rbp, 5

; 6597 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	mov	rsi, rbp
	sar	rsi, 1
	test	rsi, rsi
	jle	$LN77@Make_heap_

; 6593 : _CONSTEXPR20 void _Make_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	mov	rdi, rsi
	shl	rdi, 5
	add	rdi, rcx
	xor	r15d, r15d
	npad	4
$LL2@Make_heap_:

; 6598 :         // reheap top half, bottom to top
; 6599 :         --_Hole;

	dec	rsi
	lea	rdi, QWORD PTR [rdi-32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdi]
	movups	XMMWORD PTR _Val$1[rsp], xmm0
	movups	xmm1, XMMWORD PTR [rdi+16]
	movups	XMMWORD PTR _Val$1[rsp+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6600 :         _Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

	mov	QWORD PTR [rdi+16], r15
	mov	QWORD PTR [rdi+24], 15
	mov	BYTE PTR [rdi], 0

; 6601 :         _STD _Pop_heap_hole_by_index(_First, _Hole, _Bottom, _STD move(_Val), _Pred);

	mov	BYTE PTR [rsp+32], bl
	lea	r9, QWORD PTR _Val$1[rsp]
	mov	r8, rbp
	mov	rdx, rsi
	mov	rcx, r14
	call	??$_Pop_heap_hole_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ; std::_Pop_heap_hole_by_index<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,`BymlFile::ToBinary'::`2'::<lambda_1> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR _Val$1[rsp+24]
	cmp	rdx, 16

; 4832 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN49@Make_heap_

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR _Val$1[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN61@Make_heap_

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN58@Make_heap_
$LN61@Make_heap_:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN49@Make_heap_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6597 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	test	rsi, rsi
	jg	SHORT $LL2@Make_heap_
$LN77@Make_heap_:

; 6603 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+160]
	add	rsp, 96					; 00000060H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN58@Make_heap_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN78@Make_heap_:
??$_Make_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ENDP ; std::_Make_heap_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Val$1 = 48
__$ArrayPad$ = 80
_First$ = 144
_Last$ = 152
_Pred$ = 160
?dtor$0@?0???$_Make_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA PROC ; `std::_Make_heap_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Val$1[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$_Make_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA ENDP ; `std::_Make_heap_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Sort_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
_TEXT	SEGMENT
_Val$1 = 48
__$ArrayPad$ = 80
_First$ = 144
_Last$ = 152
_Pred$ = 160
??$_Sort_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z PROC ; std::_Sort_heap_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >, COMDAT

; 6816 : _CONSTEXPR20 void _Sort_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	movzx	ebx, r8b
	mov	rbp, rcx

; 6818 :     for (; _Last - _First >= 2; --_Last) {

	mov	rax, rdx
	sub	rax, rcx
	and	rax, -32				; ffffffffffffffe0H
	cmp	rax, 64					; 00000040H
	jl	$LN84@Sort_heap_

; 6816 : _CONSTEXPR20 void _Sort_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	lea	rdi, QWORD PTR [rdx-32]
	mov	r14, -24
	sub	r14, rcx
	mov	esi, 32					; 00000020H
	sub	rsi, rcx
	xor	r15d, r15d
$LL4@Sort_heap_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdi]
	movups	XMMWORD PTR _Val$1[rsp], xmm0
	movups	xmm1, XMMWORD PTR [rdi+16]
	movups	XMMWORD PTR _Val$1[rsp+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6476 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	QWORD PTR [rdi+16], r15
	mov	QWORD PTR [rdi+24], 15
	mov	BYTE PTR [rdi], 0

; 6465 :     *_Dest      = _STD move(*_First);

	mov	rdx, rbp
	mov	rcx, rdi
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 6466 :     using _Diff = _Iter_diff_t<_RanIt>;
; 6467 :     _STD _Pop_heap_hole_by_index(

	lea	r8, QWORD PTR [r14+24]
	add	r8, rdi
	sar	r8, 5
	mov	BYTE PTR [rsp+32], bl
	lea	r9, QWORD PTR _Val$1[rsp]
	xor	edx, edx
	mov	rcx, rbp
	call	??$_Pop_heap_hole_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ; std::_Pop_heap_hole_by_index<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,`BymlFile::ToBinary'::`2'::<lambda_1> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR _Val$1[rsp+24]
	cmp	rdx, 16

; 4832 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN2@Sort_heap_

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR _Val$1[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN66@Sort_heap_

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN63@Sort_heap_
$LN66@Sort_heap_:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN2@Sort_heap_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6818 :     for (; _Last - _First >= 2; --_Last) {

	sub	rdi, 32					; 00000020H
	lea	rax, QWORD PTR [rsi+rdi]
	and	rax, -32				; ffffffffffffffe0H
	cmp	rax, 64					; 00000040H
	jge	$LL4@Sort_heap_
$LN84@Sort_heap_:

; 6821 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+160]
	add	rsp, 96					; 00000060H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN63@Sort_heap_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN85@Sort_heap_:
??$_Sort_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ENDP ; std::_Sort_heap_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Val$1 = 48
__$ArrayPad$ = 80
_First$ = 144
_Last$ = 152
_Pred$ = 160
?dtor$0@?0???$_Sort_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA PROC ; `std::_Sort_heap_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Val$1[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$_Sort_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA ENDP ; `std::_Sort_heap_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\compare
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 64
$T10 = 64
$T11 = 64
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
_Glast$1$ = 96
$T17 = 96
$T18 = 104
$T19 = 104
$T20 = 104
$T21 = 104
_First$GSCopy$1$ = 112
_Last$GSCopy$1$ = 120
$T22 = 128
$T23 = 128
$T24 = 128
__$ReturnUdt$GSCopy$1$ = 136
__$ReturnUdt$ = 208
_First$ = 216
_Last$ = 224
_Pred$ = 232
??$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z PROC ; std::_Partition_by_median_guess_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >, COMDAT

; 7962 : _CONSTEXPR20 pair<_RanIt, _RanIt> _Partition_by_median_guess_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-39]
	sub	rsp, 144				; 00000090H
	mov	QWORD PTR _Last$GSCopy$1$[rbp-105], r8
	mov	rax, rdx
	mov	QWORD PTR _First$GSCopy$1$[rbp-105], rdx
	mov	QWORD PTR __$ReturnUdt$GSCopy$1$[rbp-105], rcx

; 7963 :     // partition [_First, _Last)
; 7964 :     _RanIt _Mid = _First + ((_Last - _First) >> 1); // shift for codegen

	mov	rdi, r8
	sub	rdi, rdx
	sar	rdi, 6
	shl	rdi, 5
	add	rdi, rdx

; 7965 :     _Guess_median_unchecked(_First, _Mid, _Prev_iter(_Last), _Pred);

	lea	r12, QWORD PTR [r8-32]

; 7948 :     const _Diff _Count = _Last - _First;

	mov	rsi, r12
	sub	rsi, rdx
	sar	rsi, 5

; 7949 :     if (40 < _Count) { // Tukey's ninther

	mov	rcx, rdx
	cmp	rsi, 40					; 00000028H
	jle	SHORT $LN1124@Partition_

; 7950 :         const _Diff _Step     = (_Count + 1) >> 3; // +1 can't overflow because range was made inclusive in caller

	inc	rsi
	sar	rsi, 3

; 7951 :         const _Diff _Two_step = _Step << 1; // note: intentionally discards low-order bit
; 7952 :         _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);

	mov	r14, rsi
	shl	r14, 6
	shl	rsi, 5
	lea	r15, QWORD PTR [rsi+rdx]
	lea	r8, QWORD PTR [r14+rdx]
	mov	rdx, r15
	call	??$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ; std::_Med3_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >

; 7953 :         _Med3_unchecked(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

	lea	r8, QWORD PTR [rsi+rdi]
	mov	rcx, rdi
	sub	rcx, rsi
	mov	rdx, rdi
	call	??$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ; std::_Med3_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >

; 7954 :         _Med3_unchecked(_Last - _Two_step, _Last - _Step, _Last, _Pred);

	mov	rbx, r12
	sub	rbx, rsi
	mov	rcx, r12
	sub	rcx, r14
	mov	r8, r12
	mov	rdx, rbx
	call	??$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ; std::_Med3_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >

; 7955 :         _Med3_unchecked(_First + _Step, _Mid, _Last - _Step, _Pred);

	mov	r8, rbx
	mov	rcx, r15

; 7956 :     } else {

	jmp	SHORT $LN1694@Partition_
$LN1124@Partition_:

; 7957 :         _Med3_unchecked(_First, _Mid, _Last, _Pred);

	mov	r8, r12
$LN1694@Partition_:

; 7967 :     _RanIt _Plast  = _Next_iter(_Pfirst);

	mov	rdx, rdi
	call	??$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ; std::_Med3_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >
	lea	r13, QWORD PTR [rdi+32]

; 7970 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

	xor	edx, edx
	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	lea	r8d, QWORD PTR [rdx+22]
	lea	r10, QWORD PTR [rdx-1]
	mov	r12, QWORD PTR _First$GSCopy$1$[rbp-105]
	cmp	r12, rdi
	jae	$LN1137@Partition_

; 7966 :     _RanIt _Pfirst = _Mid;

	lea	rsi, QWORD PTR [rdi-32]
	npad	6
$LL2@Partition_:

; 7970 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

	lea	rax, QWORD PTR $T8[rbp-105]
	mov	QWORD PTR $T17[rbp-105], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T8[rbp-105], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T8[rbp-89], rdx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T8[rbp-81], rdx

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r14, QWORD PTR [rsi+48]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r15, rdi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rsi+56], 16
	jb	SHORT $LN772@Partition_

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r15, QWORD PTR [rdi]
$LN772@Partition_:

; 2620 :         if (_Count > max_size()) {

	cmp	r14, rcx
	ja	$LN1200@Partition_

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T8[rbp-81], 15
	cmp	r14, 16
	jae	SHORT $LN778@Partition_

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T8[rbp-89], r14

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r15]
	movups	XMMWORD PTR $T8[rbp-105], xmm0

; 2647 :             return;

	jmp	SHORT $LN794@Partition_
$LN778@Partition_:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rbx, r14
	or	rbx, 15
	cmp	rbx, rcx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN789@Partition_

; 4716 :             return _Max;

	mov	rbx, rcx
	jmp	SHORT $LN788@Partition_
$LN789@Partition_:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rbx, 22
	cmovb	rbx, r8
$LN788@Partition_:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rbx
	add	rdx, 1
	cmovb	rdx, r10
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T8[rbp-105], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T8[rbp-89], r14

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T8[rbp-81], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [r14+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r15
	mov	rcx, rax
	call	memcpy
	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	xor	edx, edx
	lea	r10, QWORD PTR [rdx-1]
$LN794@Partition_:
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T16[rbp-105], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T16[rbp-89], rdx

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r14, QWORD PTR [rsi+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r15, rsi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rsi+24], 16
	jb	SHORT $LN1671@Partition_

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r15, QWORD PTR [rsi]
$LN1671@Partition_:

; 2620 :         if (_Count > max_size()) {

	cmp	r14, rcx
	ja	$LN1201@Partition_

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T16[rbp-81], 15
	cmp	r14, 16
	jae	SHORT $LN818@Partition_

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T16[rbp-89], r14

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r15]
	movups	XMMWORD PTR $T16[rbp-105], xmm0

; 2647 :             return;

	jmp	SHORT $LN826@Partition_
$LN818@Partition_:

; 2648 :         }
; 2649 : 
; 2650 :         _My_data._Myres               = _BUF_SIZE - 1;
; 2651 :         const size_type _New_capacity = _Calculate_growth(_Count);

	mov	rdx, r14
	lea	rcx, QWORD PTR $T16[rbp-105]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	rbx, rax

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rax
	add	rdx, 1
	cmovb	rdx, r10
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T16[rbp-105], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T16[rbp-89], r14

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T16[rbp-81], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [r14+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r15
	mov	rcx, rax
	call	memcpy
	npad	1
$LN826@Partition_:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 535  :     std::sort(this->m_HashKeyTable.begin(), this->m_HashKeyTable.end(), [](std::string A, std::string B) { return A < B; });

	lea	rdx, QWORD PTR $T8[rbp-105]
	lea	rcx, QWORD PTR $T16[rbp-105]
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
	movzx	ebx, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T16[rbp-105]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR $T8[rbp-105]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7970 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

	test	bl, bl
	js	$LN1691@Partition_
	lea	rax, QWORD PTR $T15[rbp-105]
	mov	QWORD PTR $T21[rbp-105], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T15[rbp-105], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	mov	QWORD PTR $T15[rbp-89], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T15[rbp-81], rax

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r14, QWORD PTR [rsi+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r15, rsi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rsi+24], 16
	jb	SHORT $LN1044@Partition_

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r15, QWORD PTR [rsi]
$LN1044@Partition_:

; 2620 :         if (_Count > max_size()) {

	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	cmp	r14, rcx
	ja	$LN1202@Partition_

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T15[rbp-81], 15
	cmp	r14, 16
	jae	SHORT $LN1050@Partition_

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T15[rbp-89], r14

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r15]
	movups	XMMWORD PTR $T15[rbp-105], xmm0

; 2647 :             return;

	jmp	SHORT $LN1058@Partition_
$LN1050@Partition_:

; 2648 :         }
; 2649 : 
; 2650 :         _My_data._Myres               = _BUF_SIZE - 1;
; 2651 :         const size_type _New_capacity = _Calculate_growth(_Count);

	mov	rdx, r14
	lea	rcx, QWORD PTR $T15[rbp-105]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	rbx, rax

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rax
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T15[rbp-105], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T15[rbp-89], r14

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T15[rbp-81], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [r14+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r15
	mov	rcx, rax
	call	memcpy
	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
$LN1058@Partition_:
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T7[rbp-105], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T7[rbp-89], 0

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r14, QWORD PTR [rsi+48]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r15, rdi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rsi+56], 16
	jb	SHORT $LN1670@Partition_

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r15, QWORD PTR [rdi]
$LN1670@Partition_:

; 2620 :         if (_Count > max_size()) {

	cmp	r14, rcx
	ja	$LN1203@Partition_

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T7[rbp-81], 15
	cmp	r14, 16
	jae	SHORT $LN1018@Partition_

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T7[rbp-89], r14

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r15]
	movups	XMMWORD PTR $T7[rbp-105], xmm0

; 2647 :             return;

	jmp	SHORT $LN1026@Partition_
$LN1018@Partition_:

; 2648 :         }
; 2649 : 
; 2650 :         _My_data._Myres               = _BUF_SIZE - 1;
; 2651 :         const size_type _New_capacity = _Calculate_growth(_Count);

	mov	rdx, r14
	lea	rcx, QWORD PTR $T7[rbp-105]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	rbx, rax

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rax
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T7[rbp-105], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T7[rbp-89], r14

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T7[rbp-81], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [r14+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r15
	mov	rcx, rax
	call	memcpy
	npad	1
$LN1026@Partition_:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 535  :     std::sort(this->m_HashKeyTable.begin(), this->m_HashKeyTable.end(), [](std::string A, std::string B) { return A < B; });

	lea	rdx, QWORD PTR $T15[rbp-105]
	lea	rcx, QWORD PTR $T7[rbp-105]
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
	movzx	ebx, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T7[rbp-105]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR $T15[rbp-105]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7970 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	mov	r10, -1
	test	bl, bl
	js	SHORT $LN1137@Partition_

; 7971 :         --_Pfirst;

	sub	rdi, 32					; 00000020H
	sub	rsi, 32					; 00000020H

; 7970 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

	cmp	r12, rdi
	lea	edx, QWORD PTR [r10+1]
	lea	r8d, QWORD PTR [r10+23]
	jb	$LL2@Partition_

; 8002 :                 swap(*_Pfirst, *_Glast_prev); // intentional ADL
; 8003 :             }
; 8004 :         }
; 8005 : 
; 8006 :         if (_Glast == _First && _Gfirst == _Last) {

	jmp	SHORT $LN1137@Partition_
$LN1691@Partition_:

; 7970 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	mov	r10, -1
$LN1137@Partition_:

; 7974 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

	mov	r15, QWORD PTR _Last$GSCopy$1$[rbp-105]
	cmp	r13, r15
	jae	$LN5@Partition_
	xor	r12d, r12d
	jmp	SHORT $LN4@Partition_
	npad	9
$LL1692@Partition_:
	mov	r10, -1
$LN4@Partition_:
	lea	rax, QWORD PTR $T14[rbp-105]
	mov	QWORD PTR $T20[rbp-105], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T14[rbp-105], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T14[rbp-89], r12

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T14[rbp-81], r12

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rsi, QWORD PTR [rdi+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r14, rdi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rdi+24], 16
	jb	SHORT $LN886@Partition_

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r14, QWORD PTR [rdi]
$LN886@Partition_:

; 2620 :         if (_Count > max_size()) {

	cmp	rsi, rcx
	ja	$LN1204@Partition_

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T14[rbp-81], 15
	cmp	rsi, 16
	jae	SHORT $LN892@Partition_

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T14[rbp-89], rsi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR $T14[rbp-105], xmm0

; 2647 :             return;

	jmp	SHORT $LN900@Partition_
$LN892@Partition_:

; 2648 :         }
; 2649 : 
; 2650 :         _My_data._Myres               = _BUF_SIZE - 1;
; 2651 :         const size_type _New_capacity = _Calculate_growth(_Count);

	mov	rdx, rsi
	lea	rcx, QWORD PTR $T14[rbp-105]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	rbx, rax

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rax
	add	rdx, 1
	cmovb	rdx, r10
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T14[rbp-105], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T14[rbp-89], rsi

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T14[rbp-81], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rsi+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14
	mov	rcx, rax
	call	memcpy
	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
$LN900@Partition_:
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T6[rbp-105], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T6[rbp-89], r12

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rsi, QWORD PTR [r13+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r14, r13

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [r13+24], 16
	jb	SHORT $LN1673@Partition_

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r14, QWORD PTR [r13]
$LN1673@Partition_:

; 2620 :         if (_Count > max_size()) {

	cmp	rsi, rcx
	ja	$LN1205@Partition_

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T6[rbp-81], 15
	cmp	rsi, 16
	jae	SHORT $LN860@Partition_

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T6[rbp-89], rsi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR $T6[rbp-105], xmm0

; 2647 :             return;

	jmp	SHORT $LN868@Partition_
$LN860@Partition_:

; 2648 :         }
; 2649 : 
; 2650 :         _My_data._Myres               = _BUF_SIZE - 1;
; 2651 :         const size_type _New_capacity = _Calculate_growth(_Count);

	mov	rdx, rsi
	lea	rcx, QWORD PTR $T6[rbp-105]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	rbx, rax

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rax
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T6[rbp-105], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T6[rbp-89], rsi

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T6[rbp-81], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rsi+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14
	mov	rcx, rax
	call	memcpy
	npad	1
$LN868@Partition_:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 535  :     std::sort(this->m_HashKeyTable.begin(), this->m_HashKeyTable.end(), [](std::string A, std::string B) { return A < B; });

	lea	rdx, QWORD PTR $T14[rbp-105]
	lea	rcx, QWORD PTR $T6[rbp-105]
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
	movzx	ebx, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T6[rbp-105]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR $T14[rbp-105]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7974 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

	test	bl, bl
	js	$LN5@Partition_
	lea	rax, QWORD PTR $T13[rbp-105]
	mov	QWORD PTR $T19[rbp-105], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T13[rbp-105], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T13[rbp-89], r12

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T13[rbp-81], r12

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rsi, QWORD PTR [r13+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r14, r13

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [r13+24], 16
	jb	SHORT $LN970@Partition_

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r14, QWORD PTR [r13]
$LN970@Partition_:

; 2620 :         if (_Count > max_size()) {

	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	cmp	rsi, rcx
	ja	$LN1206@Partition_

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T13[rbp-81], 15
	cmp	rsi, 16
	jae	SHORT $LN976@Partition_

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T13[rbp-89], rsi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR $T13[rbp-105], xmm0

; 2647 :             return;

	jmp	SHORT $LN984@Partition_
$LN976@Partition_:

; 2648 :         }
; 2649 : 
; 2650 :         _My_data._Myres               = _BUF_SIZE - 1;
; 2651 :         const size_type _New_capacity = _Calculate_growth(_Count);

	mov	rdx, rsi
	lea	rcx, QWORD PTR $T13[rbp-105]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	rbx, rax

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rax
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T13[rbp-105], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T13[rbp-89], rsi

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T13[rbp-81], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rsi+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14
	mov	rcx, rax
	call	memcpy
	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
$LN984@Partition_:
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T5[rbp-105], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T5[rbp-89], r12

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rsi, QWORD PTR [rdi+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r14, rdi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rdi+24], 16
	jb	SHORT $LN1672@Partition_

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r14, QWORD PTR [rdi]
$LN1672@Partition_:

; 2620 :         if (_Count > max_size()) {

	cmp	rsi, rcx
	ja	$LN1207@Partition_

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T5[rbp-81], 15
	cmp	rsi, 16
	jae	SHORT $LN944@Partition_

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T5[rbp-89], rsi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR $T5[rbp-105], xmm0

; 2647 :             return;

	jmp	SHORT $LN952@Partition_
$LN944@Partition_:

; 2648 :         }
; 2649 : 
; 2650 :         _My_data._Myres               = _BUF_SIZE - 1;
; 2651 :         const size_type _New_capacity = _Calculate_growth(_Count);

	mov	rdx, rsi
	lea	rcx, QWORD PTR $T5[rbp-105]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	rbx, rax

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rax
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T5[rbp-105], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T5[rbp-89], rsi

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T5[rbp-81], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rsi+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14
	mov	rcx, rax
	call	memcpy
	npad	1
$LN952@Partition_:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 535  :     std::sort(this->m_HashKeyTable.begin(), this->m_HashKeyTable.end(), [](std::string A, std::string B) { return A < B; });

	lea	rdx, QWORD PTR $T13[rbp-105]
	lea	rcx, QWORD PTR $T5[rbp-105]
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
	movzx	ebx, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T5[rbp-105]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR $T13[rbp-105]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7974 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

	test	bl, bl
	js	SHORT $LN5@Partition_

; 7975 :         ++_Plast;

	add	r13, 32					; 00000020H

; 7974 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

	cmp	r13, r15
	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	jb	$LL1692@Partition_
$LN5@Partition_:

; 7976 :     }
; 7977 : 
; 7978 :     _RanIt _Gfirst = _Plast;

	mov	rsi, r13

; 7979 :     _RanIt _Glast  = _Pfirst;

	mov	r12, rdi
	mov	QWORD PTR _Glast$1$[rbp-105], rdi
	mov	rax, QWORD PTR _First$GSCopy$1$[rbp-105]
$LL6@Partition_:

; 7982 :         for (; _Gfirst < _Last; ++_Gfirst) {

	cmp	rsi, r15
	jae	$LN1685@Partition_
$LL11@Partition_:

; 7983 :             if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst)) {

	lea	rax, QWORD PTR $T4[rbp-105]
	mov	QWORD PTR $T18[rbp-105], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T4[rbp-105], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	mov	QWORD PTR $T4[rbp-89], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T4[rbp-81], rax

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r14, QWORD PTR [rsi+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r15, rsi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rsi+24], 16
	jb	SHORT $LN526@Partition_

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r15, QWORD PTR [rsi]
$LN526@Partition_:

; 2620 :         if (_Count > max_size()) {

	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	cmp	r14, rcx
	ja	$LN1208@Partition_

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T4[rbp-81], 15
	cmp	r14, 16
	jae	SHORT $LN532@Partition_

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T4[rbp-89], r14

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r15]
	movups	XMMWORD PTR $T4[rbp-105], xmm0

; 2647 :             return;

	jmp	SHORT $LN548@Partition_
$LN532@Partition_:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rbx, r14
	or	rbx, 15
	cmp	rbx, rcx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN543@Partition_

; 4716 :             return _Max;

	mov	rbx, rcx
	jmp	SHORT $LN542@Partition_
$LN543@Partition_:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rbx, 22
	mov	eax, 22
	cmovb	rbx, rax
$LN542@Partition_:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rbx
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T4[rbp-105], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T4[rbp-89], r14

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T4[rbp-81], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [r14+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r15
	mov	rcx, rax
	call	memcpy
	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
$LN548@Partition_:
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T12[rbp-105], xmm0

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r14, QWORD PTR [rdi+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r15, rdi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rdi+24], 16
	jb	SHORT $LN1674@Partition_

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r15, QWORD PTR [rdi]
$LN1674@Partition_:

; 2620 :         if (_Count > max_size()) {

	cmp	r14, rcx
	ja	$LN1209@Partition_

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	cmp	r14, 16
	jae	SHORT $LN482@Partition_

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T12[rbp-89], r14

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T12[rbp-81], 15

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r15]
	movups	XMMWORD PTR $T12[rbp-105], xmm0

; 2647 :             return;

	jmp	SHORT $LN498@Partition_
$LN482@Partition_:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rbx, r14
	or	rbx, 15
	cmp	rbx, rcx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN493@Partition_

; 4716 :             return _Max;

	mov	rbx, rcx
	jmp	SHORT $LN492@Partition_
$LN493@Partition_:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rbx, 22
	mov	eax, 22
	cmovb	rbx, rax
$LN492@Partition_:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rbx
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T12[rbp-105], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T12[rbp-89], r14

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T12[rbp-81], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [r14+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r15
	mov	rcx, rax
	call	memcpy
	npad	1
$LN498@Partition_:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 535  :     std::sort(this->m_HashKeyTable.begin(), this->m_HashKeyTable.end(), [](std::string A, std::string B) { return A < B; });

	lea	rdx, QWORD PTR $T4[rbp-105]
	lea	rcx, QWORD PTR $T12[rbp-105]
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
	movzx	ebx, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T12[rbp-105]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR $T4[rbp-105]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7983 :             if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst)) {

	test	bl, bl
	js	$LN9@Partition_

; 7985 :             } else if (_Pred(*_Gfirst, *_Pfirst)) {

	lea	rax, QWORD PTR $T3[rbp-105]
	mov	QWORD PTR $T24[rbp-105], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T3[rbp-105], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	mov	QWORD PTR $T3[rbp-89], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T3[rbp-81], rax

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r14, QWORD PTR [rdi+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r15, rdi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rdi+24], 16
	jb	SHORT $LN682@Partition_

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r15, QWORD PTR [rdi]
$LN682@Partition_:

; 2620 :         if (_Count > max_size()) {

	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	cmp	r14, rcx
	ja	$LN1210@Partition_

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T3[rbp-81], 15
	cmp	r14, 16
	jae	SHORT $LN688@Partition_

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T3[rbp-89], r14

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r15]
	movups	XMMWORD PTR $T3[rbp-105], xmm0

; 2647 :             return;

	jmp	SHORT $LN704@Partition_
$LN688@Partition_:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rbx, r14
	or	rbx, 15
	cmp	rbx, rcx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN699@Partition_

; 4716 :             return _Max;

	mov	rbx, rcx
	jmp	SHORT $LN698@Partition_
$LN699@Partition_:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rbx, 22
	mov	eax, 22
	cmovb	rbx, rax
$LN698@Partition_:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rbx
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T3[rbp-105], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T3[rbp-89], r14

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T3[rbp-81], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [r14+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r15
	mov	rcx, rax
	call	memcpy
	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
$LN704@Partition_:
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T11[rbp-105], xmm0

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r14, QWORD PTR [rsi+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r15, rsi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rsi+24], 16
	jb	SHORT $LN722@Partition_

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r15, QWORD PTR [rsi]
$LN722@Partition_:

; 2620 :         if (_Count > max_size()) {

	cmp	r14, rcx
	ja	$LN1211@Partition_

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	cmp	r14, 16
	jae	SHORT $LN728@Partition_

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T11[rbp-89], r14

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T11[rbp-81], 15

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r15]
	movups	XMMWORD PTR $T11[rbp-105], xmm0

; 2647 :             return;

	jmp	SHORT $LN744@Partition_
$LN728@Partition_:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rbx, r14
	or	rbx, 15
	cmp	rbx, rcx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN739@Partition_

; 4716 :             return _Max;

	mov	rbx, rcx
	jmp	SHORT $LN738@Partition_
$LN739@Partition_:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rbx, 22
	mov	eax, 22
	cmovb	rbx, rax
$LN738@Partition_:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rbx
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T11[rbp-105], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T11[rbp-89], r14

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T11[rbp-81], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [r14+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r15
	mov	rcx, rax
	call	memcpy
	npad	1
$LN744@Partition_:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 535  :     std::sort(this->m_HashKeyTable.begin(), this->m_HashKeyTable.end(), [](std::string A, std::string B) { return A < B; });

	lea	rdx, QWORD PTR $T3[rbp-105]
	lea	rcx, QWORD PTR $T11[rbp-105]
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
	movzx	ebx, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T11[rbp-105]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR $T3[rbp-105]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7985 :             } else if (_Pred(*_Gfirst, *_Pfirst)) {

	test	bl, bl
	js	SHORT $LN1689@Partition_

; 7986 :                 break;
; 7987 :             } else if (_Plast != _Gfirst) {

	cmp	r13, rsi
	je	SHORT $LN19@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4281 :                 _CSTD memcpy(_Temp_mem, _My_data_mem, _Memcpy_val_size);

	movups	xmm2, XMMWORD PTR [r13]
	movups	xmm3, XMMWORD PTR [r13+16]

; 4282 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rsi]
	movups	XMMWORD PTR [r13], xmm0
	movups	xmm1, XMMWORD PTR [rsi+16]
	movups	XMMWORD PTR [r13+16], xmm1

; 4283 :                 _CSTD memcpy(_Right_data_mem, _Temp_mem, _Memcpy_val_size);

	movups	XMMWORD PTR [rsi], xmm2
	movups	XMMWORD PTR [rsi+16], xmm3
$LN19@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7982 :         for (; _Gfirst < _Last; ++_Gfirst) {

	add	r13, 32					; 00000020H
$LN9@Partition_:
	add	rsi, 32					; 00000020H
	cmp	rsi, QWORD PTR _Last$GSCopy$1$[rbp-105]
	jb	$LL11@Partition_
$LN1689@Partition_:

; 7995 :         for (; _First < _Glast; --_Glast) {

	mov	rax, QWORD PTR _First$GSCopy$1$[rbp-105]
$LN1685@Partition_:
	cmp	r12, rax
	jbe	$LN1695@Partition_
	lea	r14, QWORD PTR [r12-32]
	npad	3
$LL14@Partition_:

; 7997 :             if (_DEBUG_LT_PRED(_Pred, *_Glast_prev, *_Pfirst)) {

	lea	rax, QWORD PTR $T2[rbp-105]
	mov	QWORD PTR $T23[rbp-105], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T2[rbp-105], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	mov	QWORD PTR $T2[rbp-89], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T2[rbp-81], rax

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r15, QWORD PTR [rdi+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r12, rdi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rdi+24], 16
	jb	SHORT $LN112@Partition_

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r12, QWORD PTR [rdi]
$LN112@Partition_:

; 2620 :         if (_Count > max_size()) {

	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	cmp	r15, rcx
	ja	$LN1213@Partition_

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T2[rbp-81], 15
	cmp	r15, 16
	jae	SHORT $LN118@Partition_

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T2[rbp-89], r15

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r12]
	movups	XMMWORD PTR $T2[rbp-105], xmm0

; 2647 :             return;

	jmp	SHORT $LN134@Partition_
$LN118@Partition_:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rbx, r15
	or	rbx, 15
	cmp	rbx, rcx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN129@Partition_

; 4716 :             return _Max;

	mov	rbx, rcx
	jmp	SHORT $LN128@Partition_
$LN129@Partition_:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rbx, 22
	mov	eax, 22
	cmovb	rbx, rax
$LN128@Partition_:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rbx
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T2[rbp-105], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T2[rbp-89], r15

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T2[rbp-81], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [r15+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r12
	mov	rcx, rax
	call	memcpy
	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
$LN134@Partition_:
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T10[rbp-105], xmm0

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r15, QWORD PTR [r14+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r12, r14

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [r14+24], 16
	jb	SHORT $LN1675@Partition_

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r12, QWORD PTR [r14]
$LN1675@Partition_:

; 2620 :         if (_Count > max_size()) {

	cmp	r15, rcx
	ja	$LN1214@Partition_

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	cmp	r15, 16
	jae	SHORT $LN77@Partition_

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T10[rbp-89], r15

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T10[rbp-81], 15

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r12]
	movups	XMMWORD PTR $T10[rbp-105], xmm0

; 2647 :             return;

	jmp	SHORT $LN93@Partition_
$LN77@Partition_:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rbx, r15
	or	rbx, 15
	cmp	rbx, rcx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN88@Partition_

; 4716 :             return _Max;

	mov	rbx, rcx
	jmp	SHORT $LN87@Partition_
$LN88@Partition_:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rbx, 22
	mov	eax, 22
	cmovb	rbx, rax
$LN87@Partition_:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rbx
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T10[rbp-105], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T10[rbp-89], r15

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T10[rbp-81], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [r15+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r12
	mov	rcx, rax
	call	memcpy
	npad	1
$LN93@Partition_:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 535  :     std::sort(this->m_HashKeyTable.begin(), this->m_HashKeyTable.end(), [](std::string A, std::string B) { return A < B; });

	lea	rdx, QWORD PTR $T2[rbp-105]
	lea	rcx, QWORD PTR $T10[rbp-105]
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
	movzx	ebx, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T10[rbp-105]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR $T2[rbp-105]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7997 :             if (_DEBUG_LT_PRED(_Pred, *_Glast_prev, *_Pfirst)) {

	test	bl, bl
	js	$LN12@Partition_

; 7999 :             } else if (_Pred(*_Pfirst, *_Glast_prev)) {

	lea	rax, QWORD PTR $T1[rbp-105]
	mov	QWORD PTR $T22[rbp-105], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T1[rbp-105], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	mov	QWORD PTR $T1[rbp-89], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T1[rbp-81], rax

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r15, QWORD PTR [r14+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r12, r14

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [r14+24], 16
	jb	SHORT $LN152@Partition_

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r12, QWORD PTR [r14]
$LN152@Partition_:

; 2620 :         if (_Count > max_size()) {

	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	cmp	r15, rcx
	ja	$LN1215@Partition_

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T1[rbp-81], 15
	cmp	r15, 16
	jae	SHORT $LN158@Partition_

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T1[rbp-89], r15

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r12]
	movups	XMMWORD PTR $T1[rbp-105], xmm0

; 2647 :             return;

	jmp	SHORT $LN174@Partition_
$LN158@Partition_:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rbx, r15
	or	rbx, 15
	cmp	rbx, rcx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN169@Partition_

; 4716 :             return _Max;

	mov	rbx, rcx
	jmp	SHORT $LN168@Partition_
$LN169@Partition_:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rbx, 22
	mov	eax, 22
	cmovb	rbx, rax
$LN168@Partition_:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rbx
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T1[rbp-105], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T1[rbp-89], r15

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T1[rbp-81], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [r15+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r12
	mov	rcx, rax
	call	memcpy
	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
$LN174@Partition_:
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T9[rbp-105], xmm0

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r15, QWORD PTR [rdi+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r12, rdi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rdi+24], 16
	jb	SHORT $LN202@Partition_

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r12, QWORD PTR [rdi]
$LN202@Partition_:

; 2620 :         if (_Count > max_size()) {

	cmp	r15, rcx
	ja	$LN1216@Partition_

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	cmp	r15, 16
	jae	SHORT $LN208@Partition_

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T9[rbp-89], r15

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T9[rbp-81], 15

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r12]
	movups	XMMWORD PTR $T9[rbp-105], xmm0

; 2647 :             return;

	jmp	SHORT $LN224@Partition_
$LN208@Partition_:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rbx, r15
	or	rbx, 15
	cmp	rbx, rcx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN219@Partition_

; 4716 :             return _Max;

	mov	rbx, rcx
	jmp	SHORT $LN218@Partition_
$LN219@Partition_:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rbx, 22
	mov	eax, 22
	cmovb	rbx, rax
$LN218@Partition_:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rbx
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T9[rbp-105], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T9[rbp-89], r15

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T9[rbp-81], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [r15+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r12
	mov	rcx, rax
	call	memcpy
	npad	1
$LN224@Partition_:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 535  :     std::sort(this->m_HashKeyTable.begin(), this->m_HashKeyTable.end(), [](std::string A, std::string B) { return A < B; });

	lea	rdx, QWORD PTR $T1[rbp-105]
	lea	rcx, QWORD PTR $T9[rbp-105]
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
	movzx	ebx, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T9[rbp-105]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR $T1[rbp-105]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\compare

; 197  :         return _Val._Value < 0;

	test	bl, bl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7999 :             } else if (_Pred(*_Pfirst, *_Glast_prev)) {

	js	SHORT $LN1687@Partition_

; 8000 :                 break;
; 8001 :             } else if (--_Pfirst != _Glast_prev) {

	sub	rdi, 32					; 00000020H
	cmp	rdi, r14
	je	SHORT $LN12@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4281 :                 _CSTD memcpy(_Temp_mem, _My_data_mem, _Memcpy_val_size);

	movups	xmm2, XMMWORD PTR [rdi]
	movups	xmm3, XMMWORD PTR [rdi+16]

; 4282 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR [rdi], xmm0
	movups	xmm1, XMMWORD PTR [r14+16]
	movups	XMMWORD PTR [rdi+16], xmm1

; 4283 :                 _CSTD memcpy(_Right_data_mem, _Temp_mem, _Memcpy_val_size);

	movups	XMMWORD PTR [r14], xmm2
	movups	XMMWORD PTR [r14+16], xmm3
$LN12@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7995 :         for (; _First < _Glast; --_Glast) {

	mov	r12, QWORD PTR _Glast$1$[rbp-105]
	sub	r12, 32					; 00000020H
	mov	QWORD PTR _Glast$1$[rbp-105], r12
	sub	r14, 32					; 00000020H
	mov	rax, QWORD PTR _First$GSCopy$1$[rbp-105]
	cmp	rax, r12
	jb	$LL14@Partition_

; 7999 :             } else if (_Pred(*_Pfirst, *_Glast_prev)) {

	jmp	SHORT $LN1686@Partition_
$LN1687@Partition_:
	mov	r12, QWORD PTR _Glast$1$[rbp-105]
	mov	rax, QWORD PTR _First$GSCopy$1$[rbp-105]
$LN1686@Partition_:

; 8002 :                 swap(*_Pfirst, *_Glast_prev); // intentional ADL
; 8003 :             }
; 8004 :         }
; 8005 : 
; 8006 :         if (_Glast == _First && _Gfirst == _Last) {

	cmp	r12, rax
$LN1695@Partition_:
	mov	r15, QWORD PTR _Last$GSCopy$1$[rbp-105]
	jne	SHORT $LN27@Partition_
	cmp	rsi, r15
	je	$LN1218@Partition_

; 8007 :             return pair<_RanIt, _RanIt>(_Pfirst, _Plast);
; 8008 :         }
; 8009 : 
; 8010 :         if (_Glast == _First) { // no room at bottom, rotate pivot upward
; 8011 :             if (_Plast != _Gfirst) {

	cmp	r13, rsi
	je	SHORT $LN464@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4308 :         if (this != _STD addressof(_Right)) {

	cmp	rdi, r13
	je	SHORT $LN464@Partition_

; 4281 :                 _CSTD memcpy(_Temp_mem, _My_data_mem, _Memcpy_val_size);

	movups	xmm2, XMMWORD PTR [rdi]
	movups	xmm3, XMMWORD PTR [rdi+16]

; 4282 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r13]
	movups	XMMWORD PTR [rdi], xmm0
	movups	xmm1, XMMWORD PTR [r13+16]
	movups	XMMWORD PTR [rdi+16], xmm1

; 4283 :                 _CSTD memcpy(_Right_data_mem, _Temp_mem, _Memcpy_val_size);

	movups	XMMWORD PTR [r13], xmm2
	movups	XMMWORD PTR [r13+16], xmm3
$LN464@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8015 :             ++_Plast;

	add	r13, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4308 :         if (this != _STD addressof(_Right)) {

	cmp	rdi, rsi
	je	SHORT $LN288@Partition_

; 4281 :                 _CSTD memcpy(_Temp_mem, _My_data_mem, _Memcpy_val_size);

	movups	xmm2, XMMWORD PTR [rdi]
	movups	xmm3, XMMWORD PTR [rdi+16]

; 4282 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rsi]
	movups	XMMWORD PTR [rdi], xmm0
	movups	xmm1, XMMWORD PTR [rsi+16]
	movups	XMMWORD PTR [rdi+16], xmm1

; 4283 :                 _CSTD memcpy(_Right_data_mem, _Temp_mem, _Memcpy_val_size);

	movups	XMMWORD PTR [rsi], xmm2
	movups	XMMWORD PTR [rsi+16], xmm3
$LN288@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8017 :             ++_Pfirst;

	add	rdi, 32					; 00000020H

; 8018 :             ++_Gfirst;

	add	rsi, 32					; 00000020H
	jmp	$LL6@Partition_
$LN27@Partition_:

; 8019 :         } else if (_Gfirst == _Last) { // no room at top, rotate pivot downward

	add	r12, -32				; ffffffffffffffe0H
	mov	QWORD PTR _Glast$1$[rbp-105], r12
	cmp	rsi, r15
	jne	SHORT $LN30@Partition_

; 8020 :             if (--_Glast != --_Pfirst) {

	sub	rdi, 32					; 00000020H
	cmp	r12, rdi
	je	SHORT $LN670@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4281 :                 _CSTD memcpy(_Temp_mem, _My_data_mem, _Memcpy_val_size);

	movups	xmm2, XMMWORD PTR [r12]
	movups	xmm3, XMMWORD PTR [r12+16]

; 4282 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdi]
	movups	XMMWORD PTR [r12], xmm0
	movups	xmm1, XMMWORD PTR [rdi+16]
	movups	XMMWORD PTR [r12+16], xmm1

; 4283 :                 _CSTD memcpy(_Right_data_mem, _Temp_mem, _Memcpy_val_size);

	movups	XMMWORD PTR [rdi], xmm2
	movups	XMMWORD PTR [rdi+16], xmm3
$LN670@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8024 :             swap(*_Pfirst, *--_Plast); // intentional ADL

	sub	r13, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4308 :         if (this != _STD addressof(_Right)) {

	cmp	rdi, r13
	je	$LL6@Partition_

; 4281 :                 _CSTD memcpy(_Temp_mem, _My_data_mem, _Memcpy_val_size);

	movups	xmm2, XMMWORD PTR [rdi]
	movups	xmm3, XMMWORD PTR [rdi+16]

; 4282 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r13]
	movups	XMMWORD PTR [rdi], xmm0
	movups	xmm1, XMMWORD PTR [r13+16]
	movups	XMMWORD PTR [rdi+16], xmm1

; 4283 :                 _CSTD memcpy(_Right_data_mem, _Temp_mem, _Memcpy_val_size);

	movups	XMMWORD PTR [r13], xmm2
	movups	XMMWORD PTR [r13+16], xmm3
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8025 :         } else {

	jmp	$LL6@Partition_
$LN30@Partition_:

; 8026 :             swap(*_Gfirst, *--_Glast); // intentional ADL

	mov	QWORD PTR _Glast$1$[rbp-105], r12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4308 :         if (this != _STD addressof(_Right)) {

	cmp	rsi, r12
	je	SHORT $LN348@Partition_

; 4281 :                 _CSTD memcpy(_Temp_mem, _My_data_mem, _Memcpy_val_size);

	movups	xmm2, XMMWORD PTR [rsi]
	movups	xmm3, XMMWORD PTR [rsi+16]

; 4282 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r12]
	movups	XMMWORD PTR [rsi], xmm0
	movups	xmm1, XMMWORD PTR [r12+16]
	movups	XMMWORD PTR [rsi+16], xmm1

; 4283 :                 _CSTD memcpy(_Right_data_mem, _Temp_mem, _Memcpy_val_size);

	movups	XMMWORD PTR [r12], xmm2
	movups	XMMWORD PTR [r12+16], xmm3
$LN348@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8027 :             ++_Gfirst;

	add	rsi, 32					; 00000020H

; 8028 :         }
; 8029 :     }

	jmp	$LL6@Partition_
$LN1218@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rax, QWORD PTR __$ReturnUdt$GSCopy$1$[rbp-105]
	mov	QWORD PTR [rax], rdi
	mov	QWORD PTR [rax+8], r13
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8030 : }

	mov	rbx, QWORD PTR [rsp+232]
	add	rsp, 144				; 00000090H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN1213@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1203@Partition_:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1202@Partition_:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1201@Partition_:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1200@Partition_:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1207@Partition_:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1206@Partition_:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1205@Partition_:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1204@Partition_:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1211@Partition_:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1210@Partition_:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1209@Partition_:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1208@Partition_:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1216@Partition_:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1215@Partition_:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1214@Partition_:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN1693@Partition_:
??$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z ENDP ; std::_Partition_by_median_guess_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 64
$T10 = 64
$T11 = 64
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
_Glast$1$ = 96
$T17 = 96
$T18 = 104
$T19 = 104
$T20 = 104
$T21 = 104
_First$GSCopy$1$ = 112
_Last$GSCopy$1$ = 120
$T22 = 128
$T23 = 128
$T24 = 128
__$ReturnUdt$GSCopy$1$ = 136
__$ReturnUdt$ = 208
_First$ = 216
_Last$ = 224
_Pred$ = 232
?dtor$0@?0???$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z@4HA PROC ; `std::_Partition_by_median_guess_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >'::`1'::dtor$0
	mov	rcx, QWORD PTR $T17[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z@4HA ENDP ; `std::_Partition_by_median_guess_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 64
$T10 = 64
$T11 = 64
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
_Glast$1$ = 96
$T17 = 96
$T18 = 104
$T19 = 104
$T20 = 104
$T21 = 104
_First$GSCopy$1$ = 112
_Last$GSCopy$1$ = 120
$T22 = 128
$T23 = 128
$T24 = 128
__$ReturnUdt$GSCopy$1$ = 136
__$ReturnUdt$ = 208
_First$ = 216
_Last$ = 224
_Pred$ = 232
?dtor$2@?0???$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z@4HA PROC ; `std::_Partition_by_median_guess_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >'::`1'::dtor$2
	mov	rcx, QWORD PTR $T21[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0???$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z@4HA ENDP ; `std::_Partition_by_median_guess_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 64
$T10 = 64
$T11 = 64
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
_Glast$1$ = 96
$T17 = 96
$T18 = 104
$T19 = 104
$T20 = 104
$T21 = 104
_First$GSCopy$1$ = 112
_Last$GSCopy$1$ = 120
$T22 = 128
$T23 = 128
$T24 = 128
__$ReturnUdt$GSCopy$1$ = 136
__$ReturnUdt$ = 208
_First$ = 216
_Last$ = 224
_Pred$ = 232
?dtor$4@?0???$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z@4HA PROC ; `std::_Partition_by_median_guess_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >'::`1'::dtor$4
	mov	rcx, QWORD PTR $T20[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0???$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z@4HA ENDP ; `std::_Partition_by_median_guess_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 64
$T10 = 64
$T11 = 64
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
_Glast$1$ = 96
$T17 = 96
$T18 = 104
$T19 = 104
$T20 = 104
$T21 = 104
_First$GSCopy$1$ = 112
_Last$GSCopy$1$ = 120
$T22 = 128
$T23 = 128
$T24 = 128
__$ReturnUdt$GSCopy$1$ = 136
__$ReturnUdt$ = 208
_First$ = 216
_Last$ = 224
_Pred$ = 232
?dtor$6@?0???$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z@4HA PROC ; `std::_Partition_by_median_guess_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >'::`1'::dtor$6
	mov	rcx, QWORD PTR $T19[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$6@?0???$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z@4HA ENDP ; `std::_Partition_by_median_guess_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 64
$T10 = 64
$T11 = 64
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
_Glast$1$ = 96
$T17 = 96
$T18 = 104
$T19 = 104
$T20 = 104
$T21 = 104
_First$GSCopy$1$ = 112
_Last$GSCopy$1$ = 120
$T22 = 128
$T23 = 128
$T24 = 128
__$ReturnUdt$GSCopy$1$ = 136
__$ReturnUdt$ = 208
_First$ = 216
_Last$ = 224
_Pred$ = 232
?dtor$8@?0???$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z@4HA PROC ; `std::_Partition_by_median_guess_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >'::`1'::dtor$8
	mov	rcx, QWORD PTR $T18[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$8@?0???$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z@4HA ENDP ; `std::_Partition_by_median_guess_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 64
$T10 = 64
$T11 = 64
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
_Glast$1$ = 96
$T17 = 96
$T18 = 104
$T19 = 104
$T20 = 104
$T21 = 104
_First$GSCopy$1$ = 112
_Last$GSCopy$1$ = 120
$T22 = 128
$T23 = 128
$T24 = 128
__$ReturnUdt$GSCopy$1$ = 136
__$ReturnUdt$ = 208
_First$ = 216
_Last$ = 224
_Pred$ = 232
?dtor$10@?0???$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z@4HA PROC ; `std::_Partition_by_median_guess_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >'::`1'::dtor$10
	mov	rcx, QWORD PTR $T24[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$10@?0???$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z@4HA ENDP ; `std::_Partition_by_median_guess_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >'::`1'::dtor$10
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 64
$T10 = 64
$T11 = 64
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
_Glast$1$ = 96
$T17 = 96
$T18 = 104
$T19 = 104
$T20 = 104
$T21 = 104
_First$GSCopy$1$ = 112
_Last$GSCopy$1$ = 120
$T22 = 128
$T23 = 128
$T24 = 128
__$ReturnUdt$GSCopy$1$ = 136
__$ReturnUdt$ = 208
_First$ = 216
_Last$ = 224
_Pred$ = 232
?dtor$12@?0???$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z@4HA PROC ; `std::_Partition_by_median_guess_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >'::`1'::dtor$12
	mov	rcx, QWORD PTR $T23[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$12@?0???$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z@4HA ENDP ; `std::_Partition_by_median_guess_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >'::`1'::dtor$12
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 64
$T10 = 64
$T11 = 64
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
_Glast$1$ = 96
$T17 = 96
$T18 = 104
$T19 = 104
$T20 = 104
$T21 = 104
_First$GSCopy$1$ = 112
_Last$GSCopy$1$ = 120
$T22 = 128
$T23 = 128
$T24 = 128
__$ReturnUdt$GSCopy$1$ = 136
__$ReturnUdt$ = 208
_First$ = 216
_Last$ = 224
_Pred$ = 232
?dtor$14@?0???$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z@4HA PROC ; `std::_Partition_by_median_guess_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >'::`1'::dtor$14
	mov	rcx, QWORD PTR $T22[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$14@?0???$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z@4HA ENDP ; `std::_Partition_by_median_guess_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >'::`1'::dtor$14
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Insertion_sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
_TEXT	SEGMENT
tv2907 = 32
$T1 = 40
$T2 = 40
$T3 = 72
$T4 = 72
_Mid$1$ = 104
_Val$2$ = 112
_First$GSCopy$1$ = 120
_Ptr$1$ = 128
_Last$1$ = 136
$T5 = 144
$T6 = 144
_Val$4$ = 152
_Val$5$ = 168
_Val$7 = 192
__$ArrayPad$ = 224
_First$ = 288
_Last$ = 296
_Pred$dead$ = 304
??$_Insertion_sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z PROC ; std::_Insertion_sort_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >, COMDAT

; 7905 : _CONSTEXPR20 _BidIt _Insertion_sort_unchecked(const _BidIt _First, const _BidIt _Last, _Pr _Pred) {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-55]
	sub	rsp, 240				; 000000f0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-185], rax
	mov	rax, rdx
	mov	QWORD PTR _Last$1$[rbp-185], rdx
	mov	r15, rcx
	mov	QWORD PTR _First$GSCopy$1$[rbp-185], rcx

; 7906 :     // insertion sort [_First, _Last)
; 7907 :     if (_First != _Last) {

	cmp	rcx, rdx
	je	$LN3@Insertion_

; 7908 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

	lea	r12, QWORD PTR [rcx+32]
	cmp	r12, rdx
$LN565@Insertion_:

; 7909 :             _BidIt _Hole               = _Mid;

	mov	QWORD PTR _Mid$1$[rbp-185], r12
	je	$LN3@Insertion_
	mov	r9, -1
	lea	r8d, QWORD PTR [r9+23]
	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	xor	edx, edx
	mov	rdi, r12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r12]
	movups	XMMWORD PTR _Val$4$[rbp-185], xmm0
	movups	XMMWORD PTR _Val$7[rbp-185], xmm0
	movups	xmm2, XMMWORD PTR [r12+16]
	movups	XMMWORD PTR _Val$5$[rbp-185], xmm2
	movups	XMMWORD PTR _Val$7[rbp-169], xmm2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7910 :             _Iter_value_t<_BidIt> _Val = _STD move(*_Mid);

	mov	QWORD PTR [r12+16], rdx
	mov	QWORD PTR [r12+24], 15
	mov	BYTE PTR [r12], dl

; 7912 :             if (_DEBUG_LT_PRED(_Pred, _Val, *_First)) { // found new earliest element, move to front

	lea	rax, QWORD PTR $T2[rsp]
	mov	QWORD PTR $T6[rbp-185], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T2[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T2[rsp+16], rdx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T2[rbp-161], rdx

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rsi, QWORD PTR [r15+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r14, r15

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [r15+24], 16
	jb	SHORT $LN58@Insertion_

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r14, QWORD PTR [r15]
$LN58@Insertion_:

; 2620 :         if (_Count > max_size()) {

	cmp	rsi, rcx
	ja	$LN472@Insertion_

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T2[rbp-161], 15
	cmp	rsi, 16
	jae	SHORT $LN64@Insertion_

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T2[rsp+16], rsi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR $T2[rsp], xmm0

; 2647 :             return;

	jmp	SHORT $LN80@Insertion_
$LN64@Insertion_:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rbx, rsi
	or	rbx, 15
	cmp	rbx, rcx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN75@Insertion_

; 4716 :             return _Max;

	mov	rbx, rcx
	jmp	SHORT $LN74@Insertion_
$LN75@Insertion_:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rbx, 22
	cmovb	rbx, r8
$LN74@Insertion_:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rbx
	add	rdx, 1
	cmovb	rdx, r9
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T2[rsp], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T2[rsp+16], rsi

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T2[rbp-161], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rsi+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14
	mov	rcx, rax
	call	memcpy
	movups	xmm2, XMMWORD PTR _Val$5$[rbp-185]
	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	mov	r8d, 22
	lea	r9, QWORD PTR [r8-23]
$LN80@Insertion_:
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T4[rbp-185], xmm0

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rsi, QWORD PTR _Val$7[rbp-185]

; 2244 :         return _BUF_SIZE <= _Myres;

	movdqa	xmm1, xmm2
	psrldq	xmm1, 8
	movq	rax, xmm1
	mov	QWORD PTR _Val$2$[rbp-185], rax
	cmp	rax, 16
	setae	BYTE PTR tv2907[rsp]

; 2236 :         if (_Large_string_engaged()) {

	mov	r14, QWORD PTR _Val$4$[rbp-185]
	mov	QWORD PTR _Ptr$1$[rbp-185], r14
	cmovae	rsi, r14

; 2620 :         if (_Count > max_size()) {

	movq	r13, xmm2
	cmp	r13, rcx
	ja	$LN473@Insertion_

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	cmp	r13, 16
	jae	SHORT $LN105@Insertion_

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T4[rbp-169], r13

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T4[rbp-161], 15

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [rsi]
	movups	XMMWORD PTR $T4[rbp-185], xmm0

; 2647 :             return;

	jmp	SHORT $LN121@Insertion_
$LN105@Insertion_:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rbx, r13
	or	rbx, 15
	cmp	rbx, rcx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN116@Insertion_

; 4716 :             return _Max;

	mov	rbx, rcx
	jmp	SHORT $LN115@Insertion_
$LN116@Insertion_:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rbx, 22
	cmovb	rbx, r8
$LN115@Insertion_:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rbx
	add	rdx, 1
	cmovb	rdx, r9
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T4[rbp-185], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T4[rbp-169], r13

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T4[rbp-161], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [r13+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rsi
	mov	rcx, rax
	call	memcpy
	npad	1
$LN121@Insertion_:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 536  :     std::sort(this->m_StringTable.begin(), this->m_StringTable.end(), [](std::string A, std::string B) { return A < B; });

	lea	rdx, QWORD PTR $T2[rsp]
	lea	rcx, QWORD PTR $T4[rbp-185]
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
	movzx	ebx, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T4[rbp-185]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR $T2[rsp]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7912 :             if (_DEBUG_LT_PRED(_Pred, _Val, *_First)) { // found new earliest element, move to front

	test	bl, bl
	jns	$LN9@Insertion_

; 7913 :                 _Move_backward_unchecked(_First, _Mid, ++_Hole);

	lea	rdi, QWORD PTR [r12+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4940 :     while (_First != _Last) {

	cmp	r15, r12
	je	$LN140@Insertion_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7913 :                 _Move_backward_unchecked(_First, _Mid, ++_Hole);

	mov	rbx, r12
	npad	2
$LL139@Insertion_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4941 :         *--_Dest = _STD move(*--_Last);

	mov	rsi, rbx
	sub	rdi, 32					; 00000020H
	sub	rbx, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2961 :         if (this == _STD addressof(_Right)) {

	cmp	rdi, rbx
	je	SHORT $LN189@Insertion_

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR [rbx+56]

; 4832 :         if (_My_data._Large_string_engaged()) {

	cmp	rdx, 16
	jb	SHORT $LN154@Insertion_

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;

	mov	rcx, QWORD PTR [rdi]

; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN166@Insertion_

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN398@Insertion_

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN166@Insertion_:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN154@Insertion_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	xor	eax, eax
	mov	QWORD PTR [rbx+48], rax

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+56], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], al

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rbx]
	movups	XMMWORD PTR [rdi], xmm0
	movups	xmm1, XMMWORD PTR [rbx+16]
	movups	XMMWORD PTR [rdi+16], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rsi-16], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rsi-8], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], al
$LN189@Insertion_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4940 :     while (_First != _Last) {

	cmp	r15, rbx
	jne	SHORT $LL139@Insertion_
$LN140@Insertion_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2961 :         if (this == _STD addressof(_Right)) {

	lea	rax, QWORD PTR _Val$7[rbp-185]
	cmp	r15, rax
	je	$LN561@Insertion_

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR [r15+24]

; 4832 :         if (_My_data._Large_string_engaged()) {

	cmp	rdx, 16
	jb	SHORT $LN203@Insertion_

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;

	mov	rcx, QWORD PTR [r15]

; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN215@Insertion_

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN398@Insertion_

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN215@Insertion_:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN203@Insertion_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR _Val$4$[rbp-185]
	movups	XMMWORD PTR [r15], xmm0
	movups	xmm0, XMMWORD PTR _Val$5$[rbp-185]
	movups	XMMWORD PTR [r15+16], xmm0

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	edx, 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR _Val$7[rbp-185], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7915 :             } else { // look for insertion point after first

	mov	r14, QWORD PTR _Val$7[rbp-185]
	jmp	$LN424@Insertion_
$LN9@Insertion_:

; 7916 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

	mov	rsi, r12
	xor	ecx, ecx
	npad	6
$LL7@Insertion_:
	mov	r12, rsi
	lea	rax, QWORD PTR $T1[rsp]
	mov	QWORD PTR $T5[rbp-185], rax
	sub	rsi, 32					; 00000020H
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T1[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T1[rsp+16], rcx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T1[rbp-161], rcx

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r14, QWORD PTR [r12-16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r15, rsi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [r12-8], 16
	jb	SHORT $LN250@Insertion_

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r15, QWORD PTR [rsi]
$LN250@Insertion_:

; 2620 :         if (_Count > max_size()) {

	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	cmp	r14, rcx
	ja	$LN470@Insertion_

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T1[rbp-161], 15
	cmp	r14, 16
	jae	SHORT $LN256@Insertion_

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T1[rsp+16], r14

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r15]
	movups	XMMWORD PTR $T1[rsp], xmm0

; 2647 :             return;

	jmp	SHORT $LN272@Insertion_
$LN256@Insertion_:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rbx, r14
	or	rbx, 15
	cmp	rbx, rcx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN267@Insertion_

; 4716 :             return _Max;

	mov	rbx, rcx
	jmp	SHORT $LN266@Insertion_
$LN267@Insertion_:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rbx, 22
	mov	eax, 22
	cmovb	rbx, rax
$LN266@Insertion_:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rbx
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T1[rsp], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T1[rsp+16], r14

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T1[rbp-161], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [r14+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r15
	mov	rcx, rax
	call	memcpy
	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
$LN272@Insertion_:
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T3[rbp-185], xmm0

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	r14, QWORD PTR _Val$7[rbp-185]

; 2236 :         if (_Large_string_engaged()) {

	cmp	BYTE PTR tv2907[rsp], 0
	cmovne	r14, QWORD PTR _Ptr$1$[rbp-185]

; 2628 :         if (_Count < _BUF_SIZE) {

	cmp	r13, 16
	jae	SHORT $LN296@Insertion_

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T3[rbp-169], r13

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T3[rbp-161], 15

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR $T3[rbp-185], xmm0

; 2647 :             return;

	jmp	SHORT $LN312@Insertion_
$LN296@Insertion_:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rbx, r13
	or	rbx, 15
	cmp	rbx, rcx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN307@Insertion_

; 4716 :             return _Max;

	mov	rbx, rcx
	jmp	SHORT $LN306@Insertion_
$LN307@Insertion_:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rbx, 22
	mov	eax, 22
	cmovb	rbx, rax
$LN306@Insertion_:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rbx
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T3[rbp-185], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T3[rbp-169], r13

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T3[rbp-161], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [r13+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14
	mov	rcx, rax
	call	memcpy
	npad	1
$LN312@Insertion_:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 536  :     std::sort(this->m_StringTable.begin(), this->m_StringTable.end(), [](std::string A, std::string B) { return A < B; });

	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR $T3[rbp-185]
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
	movzx	ebx, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T3[rbp-185]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR $T1[rsp]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7916 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

	test	bl, bl
	jns	SHORT $LN6@Insertion_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2961 :         if (this == _STD addressof(_Right)) {

	cmp	rdi, rsi
	je	SHORT $LN562@Insertion_

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 16

; 4832 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN341@Insertion_

; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN353@Insertion_

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN398@Insertion_

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN353@Insertion_:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN341@Insertion_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	xor	ecx, ecx
	mov	QWORD PTR [rdi+16], rcx

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdi+24], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], cl

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rsi]
	movups	XMMWORD PTR [rdi], xmm0
	movups	xmm1, XMMWORD PTR [rsi+16]
	movups	XMMWORD PTR [rdi+16], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [r12-16], rcx

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [r12-8], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rsi], cl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7916 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

	mov	rdi, rsi
	jmp	$LL7@Insertion_
$LN562@Insertion_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2961 :         if (this == _STD addressof(_Right)) {

	xor	ecx, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7916 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

	mov	rdi, rsi
	jmp	$LL7@Insertion_
$LN6@Insertion_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2961 :         if (this == _STD addressof(_Right)) {

	lea	rax, QWORD PTR _Val$7[rbp-185]
	cmp	rdi, rax
	je	SHORT $LN560@Insertion_

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR [rdi+24]

; 4832 :         if (_My_data._Large_string_engaged()) {

	cmp	rdx, 16
	jb	SHORT $LN389@Insertion_

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;

	mov	rcx, QWORD PTR [rdi]

; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN401@Insertion_

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN398@Insertion_

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN401@Insertion_:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN389@Insertion_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR _Val$4$[rbp-185]
	movups	XMMWORD PTR [rdi], xmm0
	movups	xmm0, XMMWORD PTR _Val$5$[rbp-185]
	movups	XMMWORD PTR [rdi+16], xmm0

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	edx, 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR _Val$7[rbp-185], 0
	mov	r14, QWORD PTR _Val$7[rbp-185]
	mov	r15, QWORD PTR _First$GSCopy$1$[rbp-185]

; 2961 :         if (this == _STD addressof(_Right)) {

	mov	r12, QWORD PTR _Mid$1$[rbp-185]
	jmp	SHORT $LN424@Insertion_
$LN560@Insertion_:
	mov	r15, QWORD PTR _First$GSCopy$1$[rbp-185]
	mov	r12, QWORD PTR _Mid$1$[rbp-185]
	mov	r14, QWORD PTR _Ptr$1$[rbp-185]
$LN561@Insertion_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7922 :         }

	mov	rdx, QWORD PTR _Val$2$[rbp-185]
$LN424@Insertion_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	rdx, 16

; 4832 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN437@Insertion_

; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, r14

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN449@Insertion_

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r14, QWORD PTR [r14-8]
	sub	rax, r14

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN446@Insertion_
$LN449@Insertion_:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, r14
	call	??3@YAXPEAX_K@Z				; operator delete
$LN437@Insertion_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7908 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

	add	r12, 32					; 00000020H
	mov	rax, QWORD PTR _Last$1$[rbp-185]
	cmp	r12, rax
	jmp	$LN565@Insertion_
$LN398@Insertion_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN446@Insertion_:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN3@Insertion_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7926 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-185]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+240]
	mov	rbx, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	mov	rdi, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
$LN472@Insertion_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN470@Insertion_:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN473@Insertion_:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN563@Insertion_:
??$_Insertion_sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ENDP ; std::_Insertion_sort_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv2907 = 32
$T1 = 40
$T2 = 40
$T3 = 72
$T4 = 72
_Mid$1$ = 104
_Val$2$ = 112
_First$GSCopy$1$ = 120
_Ptr$1$ = 128
_Last$1$ = 136
$T5 = 144
$T6 = 144
_Val$4$ = 152
_Val$5$ = 168
_Val$7 = 192
__$ArrayPad$ = 224
_First$ = 288
_Last$ = 296
_Pred$dead$ = 304
?dtor$0@?0???$_Insertion_sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA PROC ; `std::_Insertion_sort_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Val$7[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$_Insertion_sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA ENDP ; `std::_Insertion_sort_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv2907 = 32
$T1 = 40
$T2 = 40
$T3 = 72
$T4 = 72
_Mid$1$ = 104
_Val$2$ = 112
_First$GSCopy$1$ = 120
_Ptr$1$ = 128
_Last$1$ = 136
$T5 = 144
$T6 = 144
_Val$4$ = 152
_Val$5$ = 168
_Val$7 = 192
__$ArrayPad$ = 224
_First$ = 288
_Last$ = 296
_Pred$dead$ = 304
?dtor$1@?0???$_Insertion_sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA PROC ; `std::_Insertion_sort_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >'::`1'::dtor$1
	mov	rcx, QWORD PTR $T6[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0???$_Insertion_sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA ENDP ; `std::_Insertion_sort_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv2907 = 32
$T1 = 40
$T2 = 40
$T3 = 72
$T4 = 72
_Mid$1$ = 104
_Val$2$ = 112
_First$GSCopy$1$ = 120
_Ptr$1$ = 128
_Last$1$ = 136
$T5 = 144
$T6 = 144
_Val$4$ = 152
_Val$5$ = 168
_Val$7 = 192
__$ArrayPad$ = 224
_First$ = 288
_Last$ = 296
_Pred$dead$ = 304
?dtor$3@?0???$_Insertion_sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA PROC ; `std::_Insertion_sort_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >'::`1'::dtor$3
	mov	rcx, QWORD PTR $T5[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0???$_Insertion_sort_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA ENDP ; `std::_Insertion_sort_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Make_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
_TEXT	SEGMENT
_Val$1 = 48
__$ArrayPad$ = 80
_First$ = 144
_Last$ = 152
_Pred$ = 160
??$_Make_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z PROC ; std::_Make_heap_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >, COMDAT

; 6593 : _CONSTEXPR20 void _Make_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	movzx	ebx, r8b
	mov	rbp, rdx
	mov	r14, rcx

; 6594 :     // make [_First, _Last) into a heap
; 6595 :     using _Diff   = _Iter_diff_t<_RanIt>;
; 6596 :     _Diff _Bottom = _Last - _First;

	sub	rbp, rcx
	sar	rbp, 5

; 6597 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	mov	rsi, rbp
	sar	rsi, 1
	test	rsi, rsi
	jle	$LN77@Make_heap_

; 6593 : _CONSTEXPR20 void _Make_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	mov	rdi, rsi
	shl	rdi, 5
	add	rdi, rcx
	xor	r15d, r15d
	npad	4
$LL2@Make_heap_:

; 6598 :         // reheap top half, bottom to top
; 6599 :         --_Hole;

	dec	rsi
	lea	rdi, QWORD PTR [rdi-32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdi]
	movups	XMMWORD PTR _Val$1[rsp], xmm0
	movups	xmm1, XMMWORD PTR [rdi+16]
	movups	XMMWORD PTR _Val$1[rsp+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6600 :         _Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

	mov	QWORD PTR [rdi+16], r15
	mov	QWORD PTR [rdi+24], 15
	mov	BYTE PTR [rdi], 0

; 6601 :         _STD _Pop_heap_hole_by_index(_First, _Hole, _Bottom, _STD move(_Val), _Pred);

	mov	BYTE PTR [rsp+32], bl
	lea	r9, QWORD PTR _Val$1[rsp]
	mov	r8, rbp
	mov	rdx, rsi
	mov	rcx, r14
	call	??$_Pop_heap_hole_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ; std::_Pop_heap_hole_by_index<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,`BymlFile::ToBinary'::`2'::<lambda_2> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR _Val$1[rsp+24]
	cmp	rdx, 16

; 4832 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN49@Make_heap_

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR _Val$1[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN61@Make_heap_

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN58@Make_heap_
$LN61@Make_heap_:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN49@Make_heap_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6597 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	test	rsi, rsi
	jg	SHORT $LL2@Make_heap_
$LN77@Make_heap_:

; 6603 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+160]
	add	rsp, 96					; 00000060H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN58@Make_heap_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN78@Make_heap_:
??$_Make_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ENDP ; std::_Make_heap_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Val$1 = 48
__$ArrayPad$ = 80
_First$ = 144
_Last$ = 152
_Pred$ = 160
?dtor$0@?0???$_Make_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA PROC ; `std::_Make_heap_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Val$1[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$_Make_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA ENDP ; `std::_Make_heap_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Sort_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
_TEXT	SEGMENT
_Val$1 = 48
__$ArrayPad$ = 80
_First$ = 144
_Last$ = 152
_Pred$ = 160
??$_Sort_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z PROC ; std::_Sort_heap_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >, COMDAT

; 6816 : _CONSTEXPR20 void _Sort_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	movzx	ebx, r8b
	mov	rbp, rcx

; 6818 :     for (; _Last - _First >= 2; --_Last) {

	mov	rax, rdx
	sub	rax, rcx
	and	rax, -32				; ffffffffffffffe0H
	cmp	rax, 64					; 00000040H
	jl	$LN84@Sort_heap_

; 6816 : _CONSTEXPR20 void _Sort_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	lea	rdi, QWORD PTR [rdx-32]
	mov	r14, -24
	sub	r14, rcx
	mov	esi, 32					; 00000020H
	sub	rsi, rcx
	xor	r15d, r15d
$LL4@Sort_heap_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdi]
	movups	XMMWORD PTR _Val$1[rsp], xmm0
	movups	xmm1, XMMWORD PTR [rdi+16]
	movups	XMMWORD PTR _Val$1[rsp+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6476 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	QWORD PTR [rdi+16], r15
	mov	QWORD PTR [rdi+24], 15
	mov	BYTE PTR [rdi], 0

; 6465 :     *_Dest      = _STD move(*_First);

	mov	rdx, rbp
	mov	rcx, rdi
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 6466 :     using _Diff = _Iter_diff_t<_RanIt>;
; 6467 :     _STD _Pop_heap_hole_by_index(

	lea	r8, QWORD PTR [r14+24]
	add	r8, rdi
	sar	r8, 5
	mov	BYTE PTR [rsp+32], bl
	lea	r9, QWORD PTR _Val$1[rsp]
	xor	edx, edx
	mov	rcx, rbp
	call	??$_Pop_heap_hole_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ; std::_Pop_heap_hole_by_index<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,`BymlFile::ToBinary'::`2'::<lambda_2> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR _Val$1[rsp+24]
	cmp	rdx, 16

; 4832 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN2@Sort_heap_

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR _Val$1[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN66@Sort_heap_

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN63@Sort_heap_
$LN66@Sort_heap_:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN2@Sort_heap_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6818 :     for (; _Last - _First >= 2; --_Last) {

	sub	rdi, 32					; 00000020H
	lea	rax, QWORD PTR [rsi+rdi]
	and	rax, -32				; ffffffffffffffe0H
	cmp	rax, 64					; 00000040H
	jge	$LL4@Sort_heap_
$LN84@Sort_heap_:

; 6821 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+160]
	add	rsp, 96					; 00000060H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN63@Sort_heap_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN85@Sort_heap_:
??$_Sort_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ENDP ; std::_Sort_heap_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Val$1 = 48
__$ArrayPad$ = 80
_First$ = 144
_Last$ = 152
_Pred$ = 160
?dtor$0@?0???$_Sort_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA PROC ; `std::_Sort_heap_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Val$1[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$_Sort_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA ENDP ; `std::_Sort_heap_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\compare
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 64
$T10 = 64
$T11 = 64
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
_Glast$1$ = 96
$T17 = 96
$T18 = 104
$T19 = 104
$T20 = 104
$T21 = 104
_First$GSCopy$1$ = 112
_Last$GSCopy$1$ = 120
$T22 = 128
$T23 = 128
$T24 = 128
__$ReturnUdt$GSCopy$1$ = 136
__$ReturnUdt$ = 208
_First$ = 216
_Last$ = 224
_Pred$ = 232
??$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z PROC ; std::_Partition_by_median_guess_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >, COMDAT

; 7962 : _CONSTEXPR20 pair<_RanIt, _RanIt> _Partition_by_median_guess_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-39]
	sub	rsp, 144				; 00000090H
	mov	QWORD PTR _Last$GSCopy$1$[rbp-105], r8
	mov	rax, rdx
	mov	QWORD PTR _First$GSCopy$1$[rbp-105], rdx
	mov	QWORD PTR __$ReturnUdt$GSCopy$1$[rbp-105], rcx

; 7963 :     // partition [_First, _Last)
; 7964 :     _RanIt _Mid = _First + ((_Last - _First) >> 1); // shift for codegen

	mov	rdi, r8
	sub	rdi, rdx
	sar	rdi, 6
	shl	rdi, 5
	add	rdi, rdx

; 7965 :     _Guess_median_unchecked(_First, _Mid, _Prev_iter(_Last), _Pred);

	lea	r12, QWORD PTR [r8-32]

; 7948 :     const _Diff _Count = _Last - _First;

	mov	rsi, r12
	sub	rsi, rdx
	sar	rsi, 5

; 7949 :     if (40 < _Count) { // Tukey's ninther

	mov	rcx, rdx
	cmp	rsi, 40					; 00000028H
	jle	SHORT $LN1124@Partition_

; 7950 :         const _Diff _Step     = (_Count + 1) >> 3; // +1 can't overflow because range was made inclusive in caller

	inc	rsi
	sar	rsi, 3

; 7951 :         const _Diff _Two_step = _Step << 1; // note: intentionally discards low-order bit
; 7952 :         _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);

	mov	r14, rsi
	shl	r14, 6
	shl	rsi, 5
	lea	r15, QWORD PTR [rsi+rdx]
	lea	r8, QWORD PTR [r14+rdx]
	mov	rdx, r15
	call	??$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ; std::_Med3_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >

; 7953 :         _Med3_unchecked(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

	lea	r8, QWORD PTR [rsi+rdi]
	mov	rcx, rdi
	sub	rcx, rsi
	mov	rdx, rdi
	call	??$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ; std::_Med3_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >

; 7954 :         _Med3_unchecked(_Last - _Two_step, _Last - _Step, _Last, _Pred);

	mov	rbx, r12
	sub	rbx, rsi
	mov	rcx, r12
	sub	rcx, r14
	mov	r8, r12
	mov	rdx, rbx
	call	??$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ; std::_Med3_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >

; 7955 :         _Med3_unchecked(_First + _Step, _Mid, _Last - _Step, _Pred);

	mov	r8, rbx
	mov	rcx, r15

; 7956 :     } else {

	jmp	SHORT $LN1694@Partition_
$LN1124@Partition_:

; 7957 :         _Med3_unchecked(_First, _Mid, _Last, _Pred);

	mov	r8, r12
$LN1694@Partition_:

; 7967 :     _RanIt _Plast  = _Next_iter(_Pfirst);

	mov	rdx, rdi
	call	??$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ; std::_Med3_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >
	lea	r13, QWORD PTR [rdi+32]

; 7970 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

	xor	edx, edx
	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	lea	r8d, QWORD PTR [rdx+22]
	lea	r10, QWORD PTR [rdx-1]
	mov	r12, QWORD PTR _First$GSCopy$1$[rbp-105]
	cmp	r12, rdi
	jae	$LN1137@Partition_

; 7966 :     _RanIt _Pfirst = _Mid;

	lea	rsi, QWORD PTR [rdi-32]
	npad	6
$LL2@Partition_:

; 7970 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

	lea	rax, QWORD PTR $T8[rbp-105]
	mov	QWORD PTR $T17[rbp-105], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T8[rbp-105], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T8[rbp-89], rdx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T8[rbp-81], rdx

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r14, QWORD PTR [rsi+48]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r15, rdi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rsi+56], 16
	jb	SHORT $LN772@Partition_

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r15, QWORD PTR [rdi]
$LN772@Partition_:

; 2620 :         if (_Count > max_size()) {

	cmp	r14, rcx
	ja	$LN1200@Partition_

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T8[rbp-81], 15
	cmp	r14, 16
	jae	SHORT $LN778@Partition_

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T8[rbp-89], r14

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r15]
	movups	XMMWORD PTR $T8[rbp-105], xmm0

; 2647 :             return;

	jmp	SHORT $LN794@Partition_
$LN778@Partition_:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rbx, r14
	or	rbx, 15
	cmp	rbx, rcx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN789@Partition_

; 4716 :             return _Max;

	mov	rbx, rcx
	jmp	SHORT $LN788@Partition_
$LN789@Partition_:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rbx, 22
	cmovb	rbx, r8
$LN788@Partition_:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rbx
	add	rdx, 1
	cmovb	rdx, r10
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T8[rbp-105], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T8[rbp-89], r14

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T8[rbp-81], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [r14+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r15
	mov	rcx, rax
	call	memcpy
	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	xor	edx, edx
	lea	r10, QWORD PTR [rdx-1]
$LN794@Partition_:
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T16[rbp-105], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T16[rbp-89], rdx

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r14, QWORD PTR [rsi+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r15, rsi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rsi+24], 16
	jb	SHORT $LN1671@Partition_

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r15, QWORD PTR [rsi]
$LN1671@Partition_:

; 2620 :         if (_Count > max_size()) {

	cmp	r14, rcx
	ja	$LN1201@Partition_

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T16[rbp-81], 15
	cmp	r14, 16
	jae	SHORT $LN818@Partition_

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T16[rbp-89], r14

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r15]
	movups	XMMWORD PTR $T16[rbp-105], xmm0

; 2647 :             return;

	jmp	SHORT $LN826@Partition_
$LN818@Partition_:

; 2648 :         }
; 2649 : 
; 2650 :         _My_data._Myres               = _BUF_SIZE - 1;
; 2651 :         const size_type _New_capacity = _Calculate_growth(_Count);

	mov	rdx, r14
	lea	rcx, QWORD PTR $T16[rbp-105]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	rbx, rax

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rax
	add	rdx, 1
	cmovb	rdx, r10
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T16[rbp-105], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T16[rbp-89], r14

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T16[rbp-81], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [r14+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r15
	mov	rcx, rax
	call	memcpy
	npad	1
$LN826@Partition_:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 536  :     std::sort(this->m_StringTable.begin(), this->m_StringTable.end(), [](std::string A, std::string B) { return A < B; });

	lea	rdx, QWORD PTR $T8[rbp-105]
	lea	rcx, QWORD PTR $T16[rbp-105]
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
	movzx	ebx, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T16[rbp-105]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR $T8[rbp-105]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7970 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

	test	bl, bl
	js	$LN1691@Partition_
	lea	rax, QWORD PTR $T15[rbp-105]
	mov	QWORD PTR $T21[rbp-105], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T15[rbp-105], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	mov	QWORD PTR $T15[rbp-89], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T15[rbp-81], rax

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r14, QWORD PTR [rsi+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r15, rsi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rsi+24], 16
	jb	SHORT $LN1044@Partition_

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r15, QWORD PTR [rsi]
$LN1044@Partition_:

; 2620 :         if (_Count > max_size()) {

	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	cmp	r14, rcx
	ja	$LN1202@Partition_

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T15[rbp-81], 15
	cmp	r14, 16
	jae	SHORT $LN1050@Partition_

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T15[rbp-89], r14

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r15]
	movups	XMMWORD PTR $T15[rbp-105], xmm0

; 2647 :             return;

	jmp	SHORT $LN1058@Partition_
$LN1050@Partition_:

; 2648 :         }
; 2649 : 
; 2650 :         _My_data._Myres               = _BUF_SIZE - 1;
; 2651 :         const size_type _New_capacity = _Calculate_growth(_Count);

	mov	rdx, r14
	lea	rcx, QWORD PTR $T15[rbp-105]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	rbx, rax

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rax
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T15[rbp-105], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T15[rbp-89], r14

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T15[rbp-81], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [r14+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r15
	mov	rcx, rax
	call	memcpy
	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
$LN1058@Partition_:
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T7[rbp-105], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T7[rbp-89], 0

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r14, QWORD PTR [rsi+48]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r15, rdi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rsi+56], 16
	jb	SHORT $LN1670@Partition_

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r15, QWORD PTR [rdi]
$LN1670@Partition_:

; 2620 :         if (_Count > max_size()) {

	cmp	r14, rcx
	ja	$LN1203@Partition_

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T7[rbp-81], 15
	cmp	r14, 16
	jae	SHORT $LN1018@Partition_

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T7[rbp-89], r14

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r15]
	movups	XMMWORD PTR $T7[rbp-105], xmm0

; 2647 :             return;

	jmp	SHORT $LN1026@Partition_
$LN1018@Partition_:

; 2648 :         }
; 2649 : 
; 2650 :         _My_data._Myres               = _BUF_SIZE - 1;
; 2651 :         const size_type _New_capacity = _Calculate_growth(_Count);

	mov	rdx, r14
	lea	rcx, QWORD PTR $T7[rbp-105]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	rbx, rax

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rax
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T7[rbp-105], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T7[rbp-89], r14

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T7[rbp-81], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [r14+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r15
	mov	rcx, rax
	call	memcpy
	npad	1
$LN1026@Partition_:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 536  :     std::sort(this->m_StringTable.begin(), this->m_StringTable.end(), [](std::string A, std::string B) { return A < B; });

	lea	rdx, QWORD PTR $T15[rbp-105]
	lea	rcx, QWORD PTR $T7[rbp-105]
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
	movzx	ebx, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T7[rbp-105]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR $T15[rbp-105]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7970 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	mov	r10, -1
	test	bl, bl
	js	SHORT $LN1137@Partition_

; 7971 :         --_Pfirst;

	sub	rdi, 32					; 00000020H
	sub	rsi, 32					; 00000020H

; 7970 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

	cmp	r12, rdi
	lea	edx, QWORD PTR [r10+1]
	lea	r8d, QWORD PTR [r10+23]
	jb	$LL2@Partition_

; 8002 :                 swap(*_Pfirst, *_Glast_prev); // intentional ADL
; 8003 :             }
; 8004 :         }
; 8005 : 
; 8006 :         if (_Glast == _First && _Gfirst == _Last) {

	jmp	SHORT $LN1137@Partition_
$LN1691@Partition_:

; 7970 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	mov	r10, -1
$LN1137@Partition_:

; 7974 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

	mov	r15, QWORD PTR _Last$GSCopy$1$[rbp-105]
	cmp	r13, r15
	jae	$LN5@Partition_
	xor	r12d, r12d
	jmp	SHORT $LN4@Partition_
	npad	9
$LL1692@Partition_:
	mov	r10, -1
$LN4@Partition_:
	lea	rax, QWORD PTR $T14[rbp-105]
	mov	QWORD PTR $T20[rbp-105], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T14[rbp-105], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T14[rbp-89], r12

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T14[rbp-81], r12

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rsi, QWORD PTR [rdi+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r14, rdi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rdi+24], 16
	jb	SHORT $LN886@Partition_

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r14, QWORD PTR [rdi]
$LN886@Partition_:

; 2620 :         if (_Count > max_size()) {

	cmp	rsi, rcx
	ja	$LN1204@Partition_

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T14[rbp-81], 15
	cmp	rsi, 16
	jae	SHORT $LN892@Partition_

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T14[rbp-89], rsi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR $T14[rbp-105], xmm0

; 2647 :             return;

	jmp	SHORT $LN900@Partition_
$LN892@Partition_:

; 2648 :         }
; 2649 : 
; 2650 :         _My_data._Myres               = _BUF_SIZE - 1;
; 2651 :         const size_type _New_capacity = _Calculate_growth(_Count);

	mov	rdx, rsi
	lea	rcx, QWORD PTR $T14[rbp-105]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	rbx, rax

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rax
	add	rdx, 1
	cmovb	rdx, r10
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T14[rbp-105], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T14[rbp-89], rsi

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T14[rbp-81], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rsi+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14
	mov	rcx, rax
	call	memcpy
	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
$LN900@Partition_:
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T6[rbp-105], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T6[rbp-89], r12

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rsi, QWORD PTR [r13+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r14, r13

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [r13+24], 16
	jb	SHORT $LN1673@Partition_

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r14, QWORD PTR [r13]
$LN1673@Partition_:

; 2620 :         if (_Count > max_size()) {

	cmp	rsi, rcx
	ja	$LN1205@Partition_

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T6[rbp-81], 15
	cmp	rsi, 16
	jae	SHORT $LN860@Partition_

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T6[rbp-89], rsi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR $T6[rbp-105], xmm0

; 2647 :             return;

	jmp	SHORT $LN868@Partition_
$LN860@Partition_:

; 2648 :         }
; 2649 : 
; 2650 :         _My_data._Myres               = _BUF_SIZE - 1;
; 2651 :         const size_type _New_capacity = _Calculate_growth(_Count);

	mov	rdx, rsi
	lea	rcx, QWORD PTR $T6[rbp-105]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	rbx, rax

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rax
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T6[rbp-105], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T6[rbp-89], rsi

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T6[rbp-81], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rsi+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14
	mov	rcx, rax
	call	memcpy
	npad	1
$LN868@Partition_:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 536  :     std::sort(this->m_StringTable.begin(), this->m_StringTable.end(), [](std::string A, std::string B) { return A < B; });

	lea	rdx, QWORD PTR $T14[rbp-105]
	lea	rcx, QWORD PTR $T6[rbp-105]
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
	movzx	ebx, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T6[rbp-105]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR $T14[rbp-105]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7974 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

	test	bl, bl
	js	$LN5@Partition_
	lea	rax, QWORD PTR $T13[rbp-105]
	mov	QWORD PTR $T19[rbp-105], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T13[rbp-105], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T13[rbp-89], r12

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T13[rbp-81], r12

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rsi, QWORD PTR [r13+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r14, r13

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [r13+24], 16
	jb	SHORT $LN970@Partition_

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r14, QWORD PTR [r13]
$LN970@Partition_:

; 2620 :         if (_Count > max_size()) {

	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	cmp	rsi, rcx
	ja	$LN1206@Partition_

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T13[rbp-81], 15
	cmp	rsi, 16
	jae	SHORT $LN976@Partition_

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T13[rbp-89], rsi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR $T13[rbp-105], xmm0

; 2647 :             return;

	jmp	SHORT $LN984@Partition_
$LN976@Partition_:

; 2648 :         }
; 2649 : 
; 2650 :         _My_data._Myres               = _BUF_SIZE - 1;
; 2651 :         const size_type _New_capacity = _Calculate_growth(_Count);

	mov	rdx, rsi
	lea	rcx, QWORD PTR $T13[rbp-105]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	rbx, rax

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rax
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T13[rbp-105], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T13[rbp-89], rsi

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T13[rbp-81], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rsi+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14
	mov	rcx, rax
	call	memcpy
	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
$LN984@Partition_:
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T5[rbp-105], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T5[rbp-89], r12

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rsi, QWORD PTR [rdi+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r14, rdi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rdi+24], 16
	jb	SHORT $LN1672@Partition_

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r14, QWORD PTR [rdi]
$LN1672@Partition_:

; 2620 :         if (_Count > max_size()) {

	cmp	rsi, rcx
	ja	$LN1207@Partition_

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T5[rbp-81], 15
	cmp	rsi, 16
	jae	SHORT $LN944@Partition_

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T5[rbp-89], rsi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR $T5[rbp-105], xmm0

; 2647 :             return;

	jmp	SHORT $LN952@Partition_
$LN944@Partition_:

; 2648 :         }
; 2649 : 
; 2650 :         _My_data._Myres               = _BUF_SIZE - 1;
; 2651 :         const size_type _New_capacity = _Calculate_growth(_Count);

	mov	rdx, rsi
	lea	rcx, QWORD PTR $T5[rbp-105]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	rbx, rax

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rax
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T5[rbp-105], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T5[rbp-89], rsi

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T5[rbp-81], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rsi+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14
	mov	rcx, rax
	call	memcpy
	npad	1
$LN952@Partition_:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 536  :     std::sort(this->m_StringTable.begin(), this->m_StringTable.end(), [](std::string A, std::string B) { return A < B; });

	lea	rdx, QWORD PTR $T13[rbp-105]
	lea	rcx, QWORD PTR $T5[rbp-105]
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
	movzx	ebx, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T5[rbp-105]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR $T13[rbp-105]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7974 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

	test	bl, bl
	js	SHORT $LN5@Partition_

; 7975 :         ++_Plast;

	add	r13, 32					; 00000020H

; 7974 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

	cmp	r13, r15
	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	jb	$LL1692@Partition_
$LN5@Partition_:

; 7976 :     }
; 7977 : 
; 7978 :     _RanIt _Gfirst = _Plast;

	mov	rsi, r13

; 7979 :     _RanIt _Glast  = _Pfirst;

	mov	r12, rdi
	mov	QWORD PTR _Glast$1$[rbp-105], rdi
	mov	rax, QWORD PTR _First$GSCopy$1$[rbp-105]
$LL6@Partition_:

; 7982 :         for (; _Gfirst < _Last; ++_Gfirst) {

	cmp	rsi, r15
	jae	$LN1685@Partition_
$LL11@Partition_:

; 7983 :             if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst)) {

	lea	rax, QWORD PTR $T4[rbp-105]
	mov	QWORD PTR $T18[rbp-105], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T4[rbp-105], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	mov	QWORD PTR $T4[rbp-89], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T4[rbp-81], rax

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r14, QWORD PTR [rsi+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r15, rsi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rsi+24], 16
	jb	SHORT $LN526@Partition_

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r15, QWORD PTR [rsi]
$LN526@Partition_:

; 2620 :         if (_Count > max_size()) {

	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	cmp	r14, rcx
	ja	$LN1208@Partition_

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T4[rbp-81], 15
	cmp	r14, 16
	jae	SHORT $LN532@Partition_

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T4[rbp-89], r14

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r15]
	movups	XMMWORD PTR $T4[rbp-105], xmm0

; 2647 :             return;

	jmp	SHORT $LN548@Partition_
$LN532@Partition_:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rbx, r14
	or	rbx, 15
	cmp	rbx, rcx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN543@Partition_

; 4716 :             return _Max;

	mov	rbx, rcx
	jmp	SHORT $LN542@Partition_
$LN543@Partition_:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rbx, 22
	mov	eax, 22
	cmovb	rbx, rax
$LN542@Partition_:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rbx
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T4[rbp-105], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T4[rbp-89], r14

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T4[rbp-81], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [r14+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r15
	mov	rcx, rax
	call	memcpy
	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
$LN548@Partition_:
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T12[rbp-105], xmm0

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r14, QWORD PTR [rdi+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r15, rdi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rdi+24], 16
	jb	SHORT $LN1674@Partition_

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r15, QWORD PTR [rdi]
$LN1674@Partition_:

; 2620 :         if (_Count > max_size()) {

	cmp	r14, rcx
	ja	$LN1209@Partition_

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	cmp	r14, 16
	jae	SHORT $LN482@Partition_

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T12[rbp-89], r14

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T12[rbp-81], 15

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r15]
	movups	XMMWORD PTR $T12[rbp-105], xmm0

; 2647 :             return;

	jmp	SHORT $LN498@Partition_
$LN482@Partition_:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rbx, r14
	or	rbx, 15
	cmp	rbx, rcx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN493@Partition_

; 4716 :             return _Max;

	mov	rbx, rcx
	jmp	SHORT $LN492@Partition_
$LN493@Partition_:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rbx, 22
	mov	eax, 22
	cmovb	rbx, rax
$LN492@Partition_:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rbx
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T12[rbp-105], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T12[rbp-89], r14

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T12[rbp-81], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [r14+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r15
	mov	rcx, rax
	call	memcpy
	npad	1
$LN498@Partition_:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 536  :     std::sort(this->m_StringTable.begin(), this->m_StringTable.end(), [](std::string A, std::string B) { return A < B; });

	lea	rdx, QWORD PTR $T4[rbp-105]
	lea	rcx, QWORD PTR $T12[rbp-105]
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
	movzx	ebx, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T12[rbp-105]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR $T4[rbp-105]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7983 :             if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst)) {

	test	bl, bl
	js	$LN9@Partition_

; 7985 :             } else if (_Pred(*_Gfirst, *_Pfirst)) {

	lea	rax, QWORD PTR $T3[rbp-105]
	mov	QWORD PTR $T24[rbp-105], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T3[rbp-105], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	mov	QWORD PTR $T3[rbp-89], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T3[rbp-81], rax

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r14, QWORD PTR [rdi+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r15, rdi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rdi+24], 16
	jb	SHORT $LN682@Partition_

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r15, QWORD PTR [rdi]
$LN682@Partition_:

; 2620 :         if (_Count > max_size()) {

	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	cmp	r14, rcx
	ja	$LN1210@Partition_

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T3[rbp-81], 15
	cmp	r14, 16
	jae	SHORT $LN688@Partition_

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T3[rbp-89], r14

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r15]
	movups	XMMWORD PTR $T3[rbp-105], xmm0

; 2647 :             return;

	jmp	SHORT $LN704@Partition_
$LN688@Partition_:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rbx, r14
	or	rbx, 15
	cmp	rbx, rcx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN699@Partition_

; 4716 :             return _Max;

	mov	rbx, rcx
	jmp	SHORT $LN698@Partition_
$LN699@Partition_:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rbx, 22
	mov	eax, 22
	cmovb	rbx, rax
$LN698@Partition_:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rbx
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T3[rbp-105], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T3[rbp-89], r14

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T3[rbp-81], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [r14+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r15
	mov	rcx, rax
	call	memcpy
	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
$LN704@Partition_:
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T11[rbp-105], xmm0

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r14, QWORD PTR [rsi+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r15, rsi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rsi+24], 16
	jb	SHORT $LN722@Partition_

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r15, QWORD PTR [rsi]
$LN722@Partition_:

; 2620 :         if (_Count > max_size()) {

	cmp	r14, rcx
	ja	$LN1211@Partition_

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	cmp	r14, 16
	jae	SHORT $LN728@Partition_

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T11[rbp-89], r14

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T11[rbp-81], 15

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r15]
	movups	XMMWORD PTR $T11[rbp-105], xmm0

; 2647 :             return;

	jmp	SHORT $LN744@Partition_
$LN728@Partition_:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rbx, r14
	or	rbx, 15
	cmp	rbx, rcx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN739@Partition_

; 4716 :             return _Max;

	mov	rbx, rcx
	jmp	SHORT $LN738@Partition_
$LN739@Partition_:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rbx, 22
	mov	eax, 22
	cmovb	rbx, rax
$LN738@Partition_:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rbx
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T11[rbp-105], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T11[rbp-89], r14

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T11[rbp-81], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [r14+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r15
	mov	rcx, rax
	call	memcpy
	npad	1
$LN744@Partition_:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 536  :     std::sort(this->m_StringTable.begin(), this->m_StringTable.end(), [](std::string A, std::string B) { return A < B; });

	lea	rdx, QWORD PTR $T3[rbp-105]
	lea	rcx, QWORD PTR $T11[rbp-105]
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
	movzx	ebx, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T11[rbp-105]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR $T3[rbp-105]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7985 :             } else if (_Pred(*_Gfirst, *_Pfirst)) {

	test	bl, bl
	js	SHORT $LN1689@Partition_

; 7986 :                 break;
; 7987 :             } else if (_Plast != _Gfirst) {

	cmp	r13, rsi
	je	SHORT $LN19@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4281 :                 _CSTD memcpy(_Temp_mem, _My_data_mem, _Memcpy_val_size);

	movups	xmm2, XMMWORD PTR [r13]
	movups	xmm3, XMMWORD PTR [r13+16]

; 4282 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rsi]
	movups	XMMWORD PTR [r13], xmm0
	movups	xmm1, XMMWORD PTR [rsi+16]
	movups	XMMWORD PTR [r13+16], xmm1

; 4283 :                 _CSTD memcpy(_Right_data_mem, _Temp_mem, _Memcpy_val_size);

	movups	XMMWORD PTR [rsi], xmm2
	movups	XMMWORD PTR [rsi+16], xmm3
$LN19@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7982 :         for (; _Gfirst < _Last; ++_Gfirst) {

	add	r13, 32					; 00000020H
$LN9@Partition_:
	add	rsi, 32					; 00000020H
	cmp	rsi, QWORD PTR _Last$GSCopy$1$[rbp-105]
	jb	$LL11@Partition_
$LN1689@Partition_:

; 7995 :         for (; _First < _Glast; --_Glast) {

	mov	rax, QWORD PTR _First$GSCopy$1$[rbp-105]
$LN1685@Partition_:
	cmp	r12, rax
	jbe	$LN1695@Partition_
	lea	r14, QWORD PTR [r12-32]
	npad	3
$LL14@Partition_:

; 7997 :             if (_DEBUG_LT_PRED(_Pred, *_Glast_prev, *_Pfirst)) {

	lea	rax, QWORD PTR $T2[rbp-105]
	mov	QWORD PTR $T23[rbp-105], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T2[rbp-105], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	mov	QWORD PTR $T2[rbp-89], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T2[rbp-81], rax

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r15, QWORD PTR [rdi+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r12, rdi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rdi+24], 16
	jb	SHORT $LN112@Partition_

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r12, QWORD PTR [rdi]
$LN112@Partition_:

; 2620 :         if (_Count > max_size()) {

	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	cmp	r15, rcx
	ja	$LN1213@Partition_

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T2[rbp-81], 15
	cmp	r15, 16
	jae	SHORT $LN118@Partition_

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T2[rbp-89], r15

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r12]
	movups	XMMWORD PTR $T2[rbp-105], xmm0

; 2647 :             return;

	jmp	SHORT $LN134@Partition_
$LN118@Partition_:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rbx, r15
	or	rbx, 15
	cmp	rbx, rcx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN129@Partition_

; 4716 :             return _Max;

	mov	rbx, rcx
	jmp	SHORT $LN128@Partition_
$LN129@Partition_:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rbx, 22
	mov	eax, 22
	cmovb	rbx, rax
$LN128@Partition_:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rbx
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T2[rbp-105], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T2[rbp-89], r15

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T2[rbp-81], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [r15+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r12
	mov	rcx, rax
	call	memcpy
	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
$LN134@Partition_:
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T10[rbp-105], xmm0

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r15, QWORD PTR [r14+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r12, r14

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [r14+24], 16
	jb	SHORT $LN1675@Partition_

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r12, QWORD PTR [r14]
$LN1675@Partition_:

; 2620 :         if (_Count > max_size()) {

	cmp	r15, rcx
	ja	$LN1214@Partition_

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	cmp	r15, 16
	jae	SHORT $LN77@Partition_

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T10[rbp-89], r15

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T10[rbp-81], 15

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r12]
	movups	XMMWORD PTR $T10[rbp-105], xmm0

; 2647 :             return;

	jmp	SHORT $LN93@Partition_
$LN77@Partition_:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rbx, r15
	or	rbx, 15
	cmp	rbx, rcx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN88@Partition_

; 4716 :             return _Max;

	mov	rbx, rcx
	jmp	SHORT $LN87@Partition_
$LN88@Partition_:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rbx, 22
	mov	eax, 22
	cmovb	rbx, rax
$LN87@Partition_:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rbx
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T10[rbp-105], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T10[rbp-89], r15

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T10[rbp-81], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [r15+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r12
	mov	rcx, rax
	call	memcpy
	npad	1
$LN93@Partition_:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 536  :     std::sort(this->m_StringTable.begin(), this->m_StringTable.end(), [](std::string A, std::string B) { return A < B; });

	lea	rdx, QWORD PTR $T2[rbp-105]
	lea	rcx, QWORD PTR $T10[rbp-105]
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
	movzx	ebx, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T10[rbp-105]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR $T2[rbp-105]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7997 :             if (_DEBUG_LT_PRED(_Pred, *_Glast_prev, *_Pfirst)) {

	test	bl, bl
	js	$LN12@Partition_

; 7999 :             } else if (_Pred(*_Pfirst, *_Glast_prev)) {

	lea	rax, QWORD PTR $T1[rbp-105]
	mov	QWORD PTR $T22[rbp-105], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T1[rbp-105], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	mov	QWORD PTR $T1[rbp-89], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T1[rbp-81], rax

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r15, QWORD PTR [r14+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r12, r14

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [r14+24], 16
	jb	SHORT $LN152@Partition_

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r12, QWORD PTR [r14]
$LN152@Partition_:

; 2620 :         if (_Count > max_size()) {

	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	cmp	r15, rcx
	ja	$LN1215@Partition_

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T1[rbp-81], 15
	cmp	r15, 16
	jae	SHORT $LN158@Partition_

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T1[rbp-89], r15

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r12]
	movups	XMMWORD PTR $T1[rbp-105], xmm0

; 2647 :             return;

	jmp	SHORT $LN174@Partition_
$LN158@Partition_:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rbx, r15
	or	rbx, 15
	cmp	rbx, rcx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN169@Partition_

; 4716 :             return _Max;

	mov	rbx, rcx
	jmp	SHORT $LN168@Partition_
$LN169@Partition_:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rbx, 22
	mov	eax, 22
	cmovb	rbx, rax
$LN168@Partition_:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rbx
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T1[rbp-105], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T1[rbp-89], r15

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T1[rbp-81], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [r15+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r12
	mov	rcx, rax
	call	memcpy
	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
$LN174@Partition_:
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T9[rbp-105], xmm0

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r15, QWORD PTR [rdi+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r12, rdi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rdi+24], 16
	jb	SHORT $LN202@Partition_

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r12, QWORD PTR [rdi]
$LN202@Partition_:

; 2620 :         if (_Count > max_size()) {

	cmp	r15, rcx
	ja	$LN1216@Partition_

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	cmp	r15, 16
	jae	SHORT $LN208@Partition_

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T9[rbp-89], r15

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T9[rbp-81], 15

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r12]
	movups	XMMWORD PTR $T9[rbp-105], xmm0

; 2647 :             return;

	jmp	SHORT $LN224@Partition_
$LN208@Partition_:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rbx, r15
	or	rbx, 15
	cmp	rbx, rcx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN219@Partition_

; 4716 :             return _Max;

	mov	rbx, rcx
	jmp	SHORT $LN218@Partition_
$LN219@Partition_:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rbx, 22
	mov	eax, 22
	cmovb	rbx, rax
$LN218@Partition_:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rbx
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T9[rbp-105], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T9[rbp-89], r15

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T9[rbp-81], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [r15+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r12
	mov	rcx, rax
	call	memcpy
	npad	1
$LN224@Partition_:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 536  :     std::sort(this->m_StringTable.begin(), this->m_StringTable.end(), [](std::string A, std::string B) { return A < B; });

	lea	rdx, QWORD PTR $T1[rbp-105]
	lea	rcx, QWORD PTR $T9[rbp-105]
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
	movzx	ebx, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T9[rbp-105]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR $T1[rbp-105]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\compare

; 197  :         return _Val._Value < 0;

	test	bl, bl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7999 :             } else if (_Pred(*_Pfirst, *_Glast_prev)) {

	js	SHORT $LN1687@Partition_

; 8000 :                 break;
; 8001 :             } else if (--_Pfirst != _Glast_prev) {

	sub	rdi, 32					; 00000020H
	cmp	rdi, r14
	je	SHORT $LN12@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4281 :                 _CSTD memcpy(_Temp_mem, _My_data_mem, _Memcpy_val_size);

	movups	xmm2, XMMWORD PTR [rdi]
	movups	xmm3, XMMWORD PTR [rdi+16]

; 4282 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR [rdi], xmm0
	movups	xmm1, XMMWORD PTR [r14+16]
	movups	XMMWORD PTR [rdi+16], xmm1

; 4283 :                 _CSTD memcpy(_Right_data_mem, _Temp_mem, _Memcpy_val_size);

	movups	XMMWORD PTR [r14], xmm2
	movups	XMMWORD PTR [r14+16], xmm3
$LN12@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7995 :         for (; _First < _Glast; --_Glast) {

	mov	r12, QWORD PTR _Glast$1$[rbp-105]
	sub	r12, 32					; 00000020H
	mov	QWORD PTR _Glast$1$[rbp-105], r12
	sub	r14, 32					; 00000020H
	mov	rax, QWORD PTR _First$GSCopy$1$[rbp-105]
	cmp	rax, r12
	jb	$LL14@Partition_

; 7999 :             } else if (_Pred(*_Pfirst, *_Glast_prev)) {

	jmp	SHORT $LN1686@Partition_
$LN1687@Partition_:
	mov	r12, QWORD PTR _Glast$1$[rbp-105]
	mov	rax, QWORD PTR _First$GSCopy$1$[rbp-105]
$LN1686@Partition_:

; 8002 :                 swap(*_Pfirst, *_Glast_prev); // intentional ADL
; 8003 :             }
; 8004 :         }
; 8005 : 
; 8006 :         if (_Glast == _First && _Gfirst == _Last) {

	cmp	r12, rax
$LN1695@Partition_:
	mov	r15, QWORD PTR _Last$GSCopy$1$[rbp-105]
	jne	SHORT $LN27@Partition_
	cmp	rsi, r15
	je	$LN1218@Partition_

; 8007 :             return pair<_RanIt, _RanIt>(_Pfirst, _Plast);
; 8008 :         }
; 8009 : 
; 8010 :         if (_Glast == _First) { // no room at bottom, rotate pivot upward
; 8011 :             if (_Plast != _Gfirst) {

	cmp	r13, rsi
	je	SHORT $LN464@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4308 :         if (this != _STD addressof(_Right)) {

	cmp	rdi, r13
	je	SHORT $LN464@Partition_

; 4281 :                 _CSTD memcpy(_Temp_mem, _My_data_mem, _Memcpy_val_size);

	movups	xmm2, XMMWORD PTR [rdi]
	movups	xmm3, XMMWORD PTR [rdi+16]

; 4282 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r13]
	movups	XMMWORD PTR [rdi], xmm0
	movups	xmm1, XMMWORD PTR [r13+16]
	movups	XMMWORD PTR [rdi+16], xmm1

; 4283 :                 _CSTD memcpy(_Right_data_mem, _Temp_mem, _Memcpy_val_size);

	movups	XMMWORD PTR [r13], xmm2
	movups	XMMWORD PTR [r13+16], xmm3
$LN464@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8015 :             ++_Plast;

	add	r13, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4308 :         if (this != _STD addressof(_Right)) {

	cmp	rdi, rsi
	je	SHORT $LN288@Partition_

; 4281 :                 _CSTD memcpy(_Temp_mem, _My_data_mem, _Memcpy_val_size);

	movups	xmm2, XMMWORD PTR [rdi]
	movups	xmm3, XMMWORD PTR [rdi+16]

; 4282 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rsi]
	movups	XMMWORD PTR [rdi], xmm0
	movups	xmm1, XMMWORD PTR [rsi+16]
	movups	XMMWORD PTR [rdi+16], xmm1

; 4283 :                 _CSTD memcpy(_Right_data_mem, _Temp_mem, _Memcpy_val_size);

	movups	XMMWORD PTR [rsi], xmm2
	movups	XMMWORD PTR [rsi+16], xmm3
$LN288@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8017 :             ++_Pfirst;

	add	rdi, 32					; 00000020H

; 8018 :             ++_Gfirst;

	add	rsi, 32					; 00000020H
	jmp	$LL6@Partition_
$LN27@Partition_:

; 8019 :         } else if (_Gfirst == _Last) { // no room at top, rotate pivot downward

	add	r12, -32				; ffffffffffffffe0H
	mov	QWORD PTR _Glast$1$[rbp-105], r12
	cmp	rsi, r15
	jne	SHORT $LN30@Partition_

; 8020 :             if (--_Glast != --_Pfirst) {

	sub	rdi, 32					; 00000020H
	cmp	r12, rdi
	je	SHORT $LN670@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4281 :                 _CSTD memcpy(_Temp_mem, _My_data_mem, _Memcpy_val_size);

	movups	xmm2, XMMWORD PTR [r12]
	movups	xmm3, XMMWORD PTR [r12+16]

; 4282 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdi]
	movups	XMMWORD PTR [r12], xmm0
	movups	xmm1, XMMWORD PTR [rdi+16]
	movups	XMMWORD PTR [r12+16], xmm1

; 4283 :                 _CSTD memcpy(_Right_data_mem, _Temp_mem, _Memcpy_val_size);

	movups	XMMWORD PTR [rdi], xmm2
	movups	XMMWORD PTR [rdi+16], xmm3
$LN670@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8024 :             swap(*_Pfirst, *--_Plast); // intentional ADL

	sub	r13, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4308 :         if (this != _STD addressof(_Right)) {

	cmp	rdi, r13
	je	$LL6@Partition_

; 4281 :                 _CSTD memcpy(_Temp_mem, _My_data_mem, _Memcpy_val_size);

	movups	xmm2, XMMWORD PTR [rdi]
	movups	xmm3, XMMWORD PTR [rdi+16]

; 4282 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r13]
	movups	XMMWORD PTR [rdi], xmm0
	movups	xmm1, XMMWORD PTR [r13+16]
	movups	XMMWORD PTR [rdi+16], xmm1

; 4283 :                 _CSTD memcpy(_Right_data_mem, _Temp_mem, _Memcpy_val_size);

	movups	XMMWORD PTR [r13], xmm2
	movups	XMMWORD PTR [r13+16], xmm3
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8025 :         } else {

	jmp	$LL6@Partition_
$LN30@Partition_:

; 8026 :             swap(*_Gfirst, *--_Glast); // intentional ADL

	mov	QWORD PTR _Glast$1$[rbp-105], r12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4308 :         if (this != _STD addressof(_Right)) {

	cmp	rsi, r12
	je	SHORT $LN348@Partition_

; 4281 :                 _CSTD memcpy(_Temp_mem, _My_data_mem, _Memcpy_val_size);

	movups	xmm2, XMMWORD PTR [rsi]
	movups	xmm3, XMMWORD PTR [rsi+16]

; 4282 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r12]
	movups	XMMWORD PTR [rsi], xmm0
	movups	xmm1, XMMWORD PTR [r12+16]
	movups	XMMWORD PTR [rsi+16], xmm1

; 4283 :                 _CSTD memcpy(_Right_data_mem, _Temp_mem, _Memcpy_val_size);

	movups	XMMWORD PTR [r12], xmm2
	movups	XMMWORD PTR [r12+16], xmm3
$LN348@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8027 :             ++_Gfirst;

	add	rsi, 32					; 00000020H

; 8028 :         }
; 8029 :     }

	jmp	$LL6@Partition_
$LN1218@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rax, QWORD PTR __$ReturnUdt$GSCopy$1$[rbp-105]
	mov	QWORD PTR [rax], rdi
	mov	QWORD PTR [rax+8], r13
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8030 : }

	mov	rbx, QWORD PTR [rsp+232]
	add	rsp, 144				; 00000090H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN1213@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1203@Partition_:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1202@Partition_:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1201@Partition_:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1200@Partition_:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1207@Partition_:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1206@Partition_:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1205@Partition_:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1204@Partition_:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1211@Partition_:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1210@Partition_:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1209@Partition_:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1208@Partition_:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1216@Partition_:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1215@Partition_:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1214@Partition_:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN1693@Partition_:
??$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z ENDP ; std::_Partition_by_median_guess_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 64
$T10 = 64
$T11 = 64
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
_Glast$1$ = 96
$T17 = 96
$T18 = 104
$T19 = 104
$T20 = 104
$T21 = 104
_First$GSCopy$1$ = 112
_Last$GSCopy$1$ = 120
$T22 = 128
$T23 = 128
$T24 = 128
__$ReturnUdt$GSCopy$1$ = 136
__$ReturnUdt$ = 208
_First$ = 216
_Last$ = 224
_Pred$ = 232
?dtor$0@?0???$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z@4HA PROC ; `std::_Partition_by_median_guess_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >'::`1'::dtor$0
	mov	rcx, QWORD PTR $T17[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z@4HA ENDP ; `std::_Partition_by_median_guess_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 64
$T10 = 64
$T11 = 64
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
_Glast$1$ = 96
$T17 = 96
$T18 = 104
$T19 = 104
$T20 = 104
$T21 = 104
_First$GSCopy$1$ = 112
_Last$GSCopy$1$ = 120
$T22 = 128
$T23 = 128
$T24 = 128
__$ReturnUdt$GSCopy$1$ = 136
__$ReturnUdt$ = 208
_First$ = 216
_Last$ = 224
_Pred$ = 232
?dtor$2@?0???$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z@4HA PROC ; `std::_Partition_by_median_guess_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >'::`1'::dtor$2
	mov	rcx, QWORD PTR $T21[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0???$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z@4HA ENDP ; `std::_Partition_by_median_guess_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 64
$T10 = 64
$T11 = 64
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
_Glast$1$ = 96
$T17 = 96
$T18 = 104
$T19 = 104
$T20 = 104
$T21 = 104
_First$GSCopy$1$ = 112
_Last$GSCopy$1$ = 120
$T22 = 128
$T23 = 128
$T24 = 128
__$ReturnUdt$GSCopy$1$ = 136
__$ReturnUdt$ = 208
_First$ = 216
_Last$ = 224
_Pred$ = 232
?dtor$4@?0???$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z@4HA PROC ; `std::_Partition_by_median_guess_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >'::`1'::dtor$4
	mov	rcx, QWORD PTR $T20[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0???$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z@4HA ENDP ; `std::_Partition_by_median_guess_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 64
$T10 = 64
$T11 = 64
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
_Glast$1$ = 96
$T17 = 96
$T18 = 104
$T19 = 104
$T20 = 104
$T21 = 104
_First$GSCopy$1$ = 112
_Last$GSCopy$1$ = 120
$T22 = 128
$T23 = 128
$T24 = 128
__$ReturnUdt$GSCopy$1$ = 136
__$ReturnUdt$ = 208
_First$ = 216
_Last$ = 224
_Pred$ = 232
?dtor$6@?0???$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z@4HA PROC ; `std::_Partition_by_median_guess_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >'::`1'::dtor$6
	mov	rcx, QWORD PTR $T19[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$6@?0???$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z@4HA ENDP ; `std::_Partition_by_median_guess_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 64
$T10 = 64
$T11 = 64
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
_Glast$1$ = 96
$T17 = 96
$T18 = 104
$T19 = 104
$T20 = 104
$T21 = 104
_First$GSCopy$1$ = 112
_Last$GSCopy$1$ = 120
$T22 = 128
$T23 = 128
$T24 = 128
__$ReturnUdt$GSCopy$1$ = 136
__$ReturnUdt$ = 208
_First$ = 216
_Last$ = 224
_Pred$ = 232
?dtor$8@?0???$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z@4HA PROC ; `std::_Partition_by_median_guess_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >'::`1'::dtor$8
	mov	rcx, QWORD PTR $T18[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$8@?0???$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z@4HA ENDP ; `std::_Partition_by_median_guess_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 64
$T10 = 64
$T11 = 64
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
_Glast$1$ = 96
$T17 = 96
$T18 = 104
$T19 = 104
$T20 = 104
$T21 = 104
_First$GSCopy$1$ = 112
_Last$GSCopy$1$ = 120
$T22 = 128
$T23 = 128
$T24 = 128
__$ReturnUdt$GSCopy$1$ = 136
__$ReturnUdt$ = 208
_First$ = 216
_Last$ = 224
_Pred$ = 232
?dtor$10@?0???$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z@4HA PROC ; `std::_Partition_by_median_guess_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >'::`1'::dtor$10
	mov	rcx, QWORD PTR $T24[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$10@?0???$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z@4HA ENDP ; `std::_Partition_by_median_guess_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >'::`1'::dtor$10
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 64
$T10 = 64
$T11 = 64
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
_Glast$1$ = 96
$T17 = 96
$T18 = 104
$T19 = 104
$T20 = 104
$T21 = 104
_First$GSCopy$1$ = 112
_Last$GSCopy$1$ = 120
$T22 = 128
$T23 = 128
$T24 = 128
__$ReturnUdt$GSCopy$1$ = 136
__$ReturnUdt$ = 208
_First$ = 216
_Last$ = 224
_Pred$ = 232
?dtor$12@?0???$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z@4HA PROC ; `std::_Partition_by_median_guess_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >'::`1'::dtor$12
	mov	rcx, QWORD PTR $T23[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$12@?0???$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z@4HA ENDP ; `std::_Partition_by_median_guess_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >'::`1'::dtor$12
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 64
$T10 = 64
$T11 = 64
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
_Glast$1$ = 96
$T17 = 96
$T18 = 104
$T19 = 104
$T20 = 104
$T21 = 104
_First$GSCopy$1$ = 112
_Last$GSCopy$1$ = 120
$T22 = 128
$T23 = 128
$T24 = 128
__$ReturnUdt$GSCopy$1$ = 136
__$ReturnUdt$ = 208
_First$ = 216
_Last$ = 224
_Pred$ = 232
?dtor$14@?0???$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z@4HA PROC ; `std::_Partition_by_median_guess_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >'::`1'::dtor$14
	mov	rcx, QWORD PTR $T22[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$14@?0???$_Partition_by_median_guess_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YA?AU?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@0@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@5@@Z@@Z@4HA ENDP ; `std::_Partition_by_median_guess_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >'::`1'::dtor$14
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple
;	COMDAT ??$?0AEBVNode@BymlFile@@$0A@@?$tuple@AEBVNode@BymlFile@@@std@@QEAA@AEBVNode@BymlFile@@@Z
_TEXT	SEGMENT
this$ = 8
_This_arg$ = 16
??$?0AEBVNode@BymlFile@@$0A@@?$tuple@AEBVNode@BymlFile@@@std@@QEAA@AEBVNode@BymlFile@@@Z PROC ; std::tuple<BymlFile::Node const &>::tuple<BymlFile::Node const &><BymlFile::Node const &,0>, COMDAT

; 144  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

	mov	QWORD PTR [rcx], rdx

; 355  :         : tuple(_Exact_args_t{}, _This_arg, _Rest_arg...) {}

	mov	rax, rcx
	ret	0
??$?0AEBVNode@BymlFile@@$0A@@?$tuple@AEBVNode@BymlFile@@@std@@QEAA@AEBVNode@BymlFile@@@Z ENDP ; std::tuple<BymlFile::Node const &>::tuple<BymlFile::Node const &><BymlFile::Node const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@V?$tuple@AEBVNode@BymlFile@@@std@@@std@@YA$$QEAV?$tuple@AEBVNode@BymlFile@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$tuple@AEBVNode@BymlFile@@@std@@@std@@YA$$QEAV?$tuple@AEBVNode@BymlFile@@@0@AEAV10@@Z PROC ; std::forward<std::tuple<BymlFile::Node const &> >, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@V?$tuple@AEBVNode@BymlFile@@@std@@@std@@YA$$QEAV?$tuple@AEBVNode@BymlFile@@@0@AEAV10@@Z ENDP ; std::forward<std::tuple<BymlFile::Node const &> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@U?$pair@$$CBVNode@BymlFile@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBVNode@BymlFile@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBVNode@BymlFile@@I@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBVNode@BymlFile@@@1@$$QEAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
__formal$dead$ = 48
_Ptr$ = 56
$T1 = 64
<_Args_0>$dead$ = 64
<_Args_1>$ = 72
<_Args_2>$dead$ = 80
??$construct@U?$pair@$$CBVNode@BymlFile@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBVNode@BymlFile@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBVNode@BymlFile@@I@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBVNode@BymlFile@@@1@$$QEAV?$tuple@$$V@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > >::construct<std::pair<BymlFile::Node const ,unsigned int>,std::piecewise_construct_t const &,std::tuple<BymlFile::Node const &>,std::tuple<> >, COMDAT

; 715  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN20:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], r8
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple

; 366  :     tuple(tuple&&)      = default;

	mov	rbx, QWORD PTR [r9]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	QWORD PTR $T1[rsp], rdx
	mov	rdx, rbx
	mov	rcx, rdi
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	npad	1
	movzx	eax, BYTE PTR [rbx+24]
	mov	BYTE PTR [rdi+24], al
	lea	rcx, QWORD PTR [rdi+32]
	lea	rdx, QWORD PTR [rbx+32]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rdi+64]
	lea	rdx, QWORD PTR [rbx+64]
	call	??0?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@AEBV01@@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::vector<BymlFile::Node,std::allocator<BymlFile::Node> >
	npad	1
	mov	DWORD PTR [rdi+88], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$construct@U?$pair@$$CBVNode@BymlFile@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBVNode@BymlFile@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBVNode@BymlFile@@I@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBVNode@BymlFile@@@1@$$QEAV?$tuple@$$V@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > >::construct<std::pair<BymlFile::Node const ,unsigned int>,std::piecewise_construct_t const &,std::tuple<BymlFile::Node const &>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
__formal$dead$ = 48
_Ptr$ = 56
$T1 = 64
<_Args_0>$dead$ = 64
<_Args_1>$ = 72
<_Args_2>$dead$ = 80
?dtor$2@?0???$construct@U?$pair@$$CBVNode@BymlFile@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBVNode@BymlFile@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBVNode@BymlFile@@I@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBVNode@BymlFile@@@1@$$QEAV?$tuple@$$V@1@@Z@4HA PROC ; `std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > >::construct<std::pair<BymlFile::Node const ,unsigned int>,std::piecewise_construct_t const &,std::tuple<BymlFile::Node const &>,std::tuple<> >'::`1'::dtor$2
	mov	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$2@?0???$construct@U?$pair@$$CBVNode@BymlFile@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBVNode@BymlFile@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBVNode@BymlFile@@I@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBVNode@BymlFile@@@1@$$QEAV?$tuple@$$V@1@@Z@4HA ENDP ; `std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > >::construct<std::pair<BymlFile::Node const ,unsigned int>,std::piecewise_construct_t const &,std::tuple<BymlFile::Node const &>,std::tuple<> >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
__formal$dead$ = 48
_Ptr$ = 56
$T1 = 64
<_Args_0>$dead$ = 64
<_Args_1>$ = 72
<_Args_2>$dead$ = 80
?dtor$3@?0???$construct@U?$pair@$$CBVNode@BymlFile@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBVNode@BymlFile@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBVNode@BymlFile@@I@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBVNode@BymlFile@@@1@$$QEAV?$tuple@$$V@1@@Z@4HA PROC ; `std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > >::construct<std::pair<BymlFile::Node const ,unsigned int>,std::piecewise_construct_t const &,std::tuple<BymlFile::Node const &>,std::tuple<> >'::`1'::dtor$3
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 32					; 00000020H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0???$construct@U?$pair@$$CBVNode@BymlFile@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBVNode@BymlFile@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBVNode@BymlFile@@I@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBVNode@BymlFile@@@1@$$QEAV?$tuple@$$V@1@@Z@4HA ENDP ; `std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > >::construct<std::pair<BymlFile::Node const ,unsigned int>,std::piecewise_construct_t const &,std::tuple<BymlFile::Node const &>,std::tuple<> >'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@U?$pair@$$CBVNode@BymlFile@@I@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBVNode@BymlFile@@I@1@$$QEAU31@@Z
_TEXT	SEGMENT
$T1 = 48
__formal$dead$ = 48
_Ptr$ = 56
<_Args_0>$ = 64
??$construct@U?$pair@$$CBVNode@BymlFile@@I@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBVNode@BymlFile@@I@1@$$QEAU31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > >::construct<std::pair<BymlFile::Node const ,unsigned int>,std::pair<BymlFile::Node const ,unsigned int> >, COMDAT

; 715  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN15:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, r8
	mov	rdi, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 246  :     pair(pair&&)      = default;

	mov	QWORD PTR $T1[rsp], rdx
	mov	rdx, r8
	mov	rcx, rdi
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	npad	1
	movzx	eax, BYTE PTR [rbx+24]
	mov	BYTE PTR [rdi+24], al
	lea	rcx, QWORD PTR [rdi+32]
	lea	rdx, QWORD PTR [rbx+32]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rdi+64]
	lea	rdx, QWORD PTR [rbx+64]
	call	??0?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@AEBV01@@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::vector<BymlFile::Node,std::allocator<BymlFile::Node> >
	npad	1
	mov	eax, DWORD PTR [rbx+88]
	mov	DWORD PTR [rdi+88], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$construct@U?$pair@$$CBVNode@BymlFile@@I@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBVNode@BymlFile@@I@1@$$QEAU31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > >::construct<std::pair<BymlFile::Node const ,unsigned int>,std::pair<BymlFile::Node const ,unsigned int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
__formal$dead$ = 48
_Ptr$ = 56
<_Args_0>$ = 64
?dtor$1@?0???$construct@U?$pair@$$CBVNode@BymlFile@@I@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBVNode@BymlFile@@I@1@$$QEAU31@@Z@4HA PROC ; `std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > >::construct<std::pair<BymlFile::Node const ,unsigned int>,std::pair<BymlFile::Node const ,unsigned int> >'::`1'::dtor$1
	mov	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$1@?0???$construct@U?$pair@$$CBVNode@BymlFile@@I@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBVNode@BymlFile@@I@1@$$QEAU31@@Z@4HA ENDP ; `std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > >::construct<std::pair<BymlFile::Node const ,unsigned int>,std::pair<BymlFile::Node const ,unsigned int> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
__formal$dead$ = 48
_Ptr$ = 56
<_Args_0>$ = 64
?dtor$2@?0???$construct@U?$pair@$$CBVNode@BymlFile@@I@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBVNode@BymlFile@@I@1@$$QEAU31@@Z@4HA PROC ; `std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > >::construct<std::pair<BymlFile::Node const ,unsigned int>,std::pair<BymlFile::Node const ,unsigned int> >'::`1'::dtor$2
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 32					; 00000020H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0???$construct@U?$pair@$$CBVNode@BymlFile@@I@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVNode@BymlFile@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBVNode@BymlFile@@I@1@$$QEAU31@@Z@4HA ENDP ; `std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<BymlFile::Node const ,unsigned int>,void *> > >::construct<std::pair<BymlFile::Node const ,unsigned int>,std::pair<BymlFile::Node const ,unsigned int> >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple
;	COMDAT ??$?0AEBV?$vector@EV?$allocator@E@std@@@std@@$0A@@?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@std@@QEAA@AEBV?$vector@EV?$allocator@E@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_This_arg$ = 16
??$?0AEBV?$vector@EV?$allocator@E@std@@@std@@$0A@@?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@std@@QEAA@AEBV?$vector@EV?$allocator@E@std@@@1@@Z PROC ; std::tuple<std::vector<unsigned char,std::allocator<unsigned char> > const &>::tuple<std::vector<unsigned char,std::allocator<unsigned char> > const &><std::vector<unsigned char,std::allocator<unsigned char> > const &,0>, COMDAT

; 144  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

	mov	QWORD PTR [rcx], rdx

; 355  :         : tuple(_Exact_args_t{}, _This_arg, _Rest_arg...) {}

	mov	rax, rcx
	ret	0
??$?0AEBV?$vector@EV?$allocator@E@std@@@std@@$0A@@?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@std@@QEAA@AEBV?$vector@EV?$allocator@E@std@@@1@@Z ENDP ; std::tuple<std::vector<unsigned char,std::allocator<unsigned char> > const &>::tuple<std::vector<unsigned char,std::allocator<unsigned char> > const &><std::vector<unsigned char,std::allocator<unsigned char> > const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@V?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@YA$$QEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@YA$$QEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@0@AEAV10@@Z PROC ; std::forward<std::tuple<std::vector<unsigned char,std::allocator<unsigned char> > const &> >, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@V?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@YA$$QEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@0@AEAV10@@Z ENDP ; std::forward<std::tuple<std::vector<unsigned char,std::allocator<unsigned char> > const &> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@$$QEAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
__formal$dead$ = 48
_Ptr$ = 56
<_Args_0>$dead$ = 64
<_Args_1>$ = 72
<_Args_2>$dead$ = 80
??$construct@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@$$QEAV?$tuple@$$V@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> > >::construct<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,std::piecewise_construct_t const &,std::tuple<std::vector<unsigned char,std::allocator<unsigned char> > const &>,std::tuple<> >, COMDAT

; 715  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN15:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	rdx, QWORD PTR [r9]
	mov	rcx, rbx
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	mov	DWORD PTR [rbx+24], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$construct@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@$$QEAV?$tuple@$$V@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> > >::construct<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,std::piecewise_construct_t const &,std::tuple<std::vector<unsigned char,std::allocator<unsigned char> > const &>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@$$QEAU31@@Z
_TEXT	SEGMENT
__formal$dead$ = 48
_Ptr$ = 56
<_Args_0>$ = 64
??$construct@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@$$QEAU31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> > >::construct<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >, COMDAT

; 715  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN10:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx
	mov	rbx, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 246  :     pair(pair&&)      = default;

	mov	rcx, rdi
	mov	rdx, r8
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	mov	eax, DWORD PTR [rbx+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	mov	rbx, QWORD PTR [rsp+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 246  :     pair(pair&&)      = default;

	mov	DWORD PTR [rdi+24], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$construct@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@1@$$QEAU31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,void *> > >::construct<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAXXZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back<>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rcx+8]
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rax], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rax+16], 0

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rax+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rax], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rcx+8], 32			; 00000020H

; 1804 :     }

	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAXXZ PROC ; std::_Uninitialized_backout_al<std::allocator<BymlFile::Node> >::_Emplace_back<>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	edx, edx
	xorps	xmm0, xmm0
	mov	QWORD PTR [rax], rdx
	mov	QWORD PTR [rax+8], rdx
	mov	QWORD PTR [rax+16], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rax+32], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rax+48], rdx

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rax+56], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rax+32], dl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rax+64], rdx
	mov	QWORD PTR [rax+72], rdx
	mov	QWORD PTR [rax+80], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rcx+8], 88			; 00000058H

; 1804 :     }

	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAXXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<BymlFile::Node> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Adl_verify_range@PEBVNode@BymlFile@@PEBV12@@std@@YAXAEBQEBVNode@BymlFile@@0@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
??$_Adl_verify_range@PEBVNode@BymlFile@@PEBV12@@std@@YAXAEBQEBVNode@BymlFile@@0@Z PROC ; std::_Adl_verify_range<BymlFile::Node const *,BymlFile::Node const *>, COMDAT

; 1133 :     // check that [_First, _Last) forms an iterator range
; 1134 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1135 :         _Verify_range(_First, _Last);
; 1136 :     }
; 1137 : }

	ret	0
??$_Adl_verify_range@PEBVNode@BymlFile@@PEBV12@@std@@YAXAEBQEBVNode@BymlFile@@0@Z ENDP ; std::_Adl_verify_range<BymlFile::Node const *,BymlFile::Node const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$?RAEBVNode@BymlFile@@AEBV01@@?$equal_to@X@std@@QEBA_NAEBVNode@BymlFile@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
_Left$ = 16
_Right$ = 24
??$?RAEBVNode@BymlFile@@AEBV01@@?$equal_to@X@std@@QEBA_NAEBVNode@BymlFile@@0@Z PROC ; std::equal_to<void>::operator()<BymlFile::Node const &,BymlFile::Node const &>, COMDAT

; 485  :         -> decltype(static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right)) {

	mov	rcx, rdx

; 486  :         return static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right);

	mov	rdx, r8
	jmp	??8Node@BymlFile@@QEBA_NAEBV01@@Z	; BymlFile::Node::operator==
??$?RAEBVNode@BymlFile@@AEBV01@@?$equal_to@X@std@@QEBA_NAEBVNode@BymlFile@@0@Z ENDP ; std::equal_to<void>::operator()<BymlFile::Node const &,BymlFile::Node const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Move_backward_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PEAV10@00@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
??$_Move_backward_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PEAV10@00@Z PROC ; std::_Move_backward_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 4928 : _CONSTEXPR20 _BidIt2 _Move_backward_unchecked(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {

$LN72:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H
	mov	rbx, r8
	mov	rdi, rdx
	mov	rbp, rcx

; 4940 :     while (_First != _Last) {

	cmp	rcx, rdx
	je	$LN63@Move_backw

; 4928 : _CONSTEXPR20 _BidIt2 _Move_backward_unchecked(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {

	xor	r14d, r14d
	npad	9
$LL2@Move_backw:

; 4941 :         *--_Dest = _STD move(*--_Last);

	mov	rsi, rdi
	sub	rbx, 32					; 00000020H
	sub	rdi, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2961 :         if (this == _STD addressof(_Right)) {

	cmp	rbx, rdi
	je	SHORT $LN52@Move_backw

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR [rbx+24]
	cmp	rdx, 16

; 4832 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN17@Move_backw
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN29@Move_backw

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN26@Move_backw

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN29@Move_backw:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN17@Move_backw:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], r14

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], r14b

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdi]
	movups	XMMWORD PTR [rbx], xmm0
	movups	xmm1, XMMWORD PTR [rdi+16]
	movups	XMMWORD PTR [rbx+16], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rsi-16], r14

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rsi-8], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], r14b
$LN52@Move_backw:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4940 :     while (_First != _Last) {

	cmp	rbp, rdi
	jne	SHORT $LL2@Move_backw
$LN63@Move_backw:

; 4945 : }

	mov	rbp, QWORD PTR [rsp+88]
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN26@Move_backw:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN69@Move_backw:
??$_Move_backward_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PEAV10@00@Z ENDP ; std::_Move_backward_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Pop_heap_hole_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 80
_Max_sequence_non_leaf$1$ = 112
_Bottom$GSCopy$1$ = 120
tv1217 = 128
_Val$GSCopy$1$ = 136
_Top$1$ = 144
$T3 = 152
_First$ = 256
_Hole$ = 264
_Bottom$ = 272
_Val$ = 280
_Pred$ = 288
??$_Pop_heap_hole_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z PROC ; std::_Pop_heap_hole_by_index<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,`BymlFile::ToBinary'::`2'::<lambda_1> >, COMDAT

; 6432 :     _RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Bottom, _Ty&& _Val, _Pr _Pred) {

	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-23]
	sub	rsp, 184				; 000000b8H
	mov	rsi, r9
	mov	QWORD PTR _Val$GSCopy$1$[rbp-161], r9
	mov	QWORD PTR _Bottom$GSCopy$1$[rbp-161], r8
	mov	r14, rdx
	mov	r13, rcx

; 6433 :     // percolate _Hole to _Bottom, then push _Val
; 6434 :     _STL_INTERNAL_CHECK(_Bottom > 0);
; 6435 : 
; 6436 :     using _Diff      = _Iter_diff_t<_RanIt>;
; 6437 :     const _Diff _Top = _Hole;

	mov	r15, rdx
	mov	QWORD PTR _Top$1$[rbp-161], rdx

; 6438 :     _Diff _Idx       = _Hole;

	mov	rbx, rdx

; 6439 : 
; 6440 :     // Check whether _Idx can have a child before calculating that child's index, since
; 6441 :     // calculating the child's index can trigger integer overflows
; 6442 :     const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; // shift for codegen

	lea	rdi, QWORD PTR [r8-1]
	mov	QWORD PTR tv1217[rbp-161], rdi
	mov	rax, rdi
	sar	rax, 1
	mov	QWORD PTR _Max_sequence_non_leaf$1$[rbp-161], rax

; 6443 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	cmp	rdx, rax
	jge	$LN3@Pop_heap_h
	xor	edx, edx
$LN193@Pop_heap_h:

; 6444 :         _Idx = 2 * _Idx + 2;

	mov	r9, -1
	lea	r8d, QWORD PTR [r9+23]
	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	lea	r12, QWORD PTR [rbx+rbx]

; 6445 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

	lea	rax, QWORD PTR $T1[rbp-161]
	mov	QWORD PTR $T3[rbp-161], rax
	mov	r15, r12
	shl	r15, 5
	lea	rsi, QWORD PTR [r13+32]
	add	rsi, r15
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T1[rbp-161], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T1[rbp-145], rdx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T1[rbp-137], rdx

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rdi, QWORD PTR [rsi+16]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rsi+24], 16
	jb	SHORT $LN20@Pop_heap_h

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rsi, QWORD PTR [rsi]
$LN20@Pop_heap_h:

; 2620 :         if (_Count > max_size()) {

	cmp	rdi, rcx
	ja	$LN154@Pop_heap_h

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T1[rbp-137], 15
	cmp	rdi, 16
	jae	SHORT $LN26@Pop_heap_h

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T1[rbp-145], rdi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [rsi]
	movups	XMMWORD PTR $T1[rbp-161], xmm0

; 2647 :             return;

	jmp	SHORT $LN42@Pop_heap_h
$LN26@Pop_heap_h:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rbx, rdi
	or	rbx, 15
	cmp	rbx, rcx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN37@Pop_heap_h

; 4716 :             return _Max;

	mov	rbx, rcx
	jmp	SHORT $LN36@Pop_heap_h
$LN37@Pop_heap_h:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rbx, 22
	cmovb	rbx, r8
$LN36@Pop_heap_h:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rbx
	add	rdx, 1
	cmovb	rdx, r9
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T1[rbp-161], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T1[rbp-145], rdi

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T1[rbp-137], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rdi+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rsi
	mov	rcx, rax
	call	memcpy
	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	mov	r8d, 22
	lea	r9, QWORD PTR [r8-23]
$LN42@Pop_heap_h:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6445 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

	lea	rdi, QWORD PTR [r13+64]
	add	rdi, r15
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T2[rbp-161], xmm0

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rsi, QWORD PTR [rdi+16]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rdi+24], 16
	jb	SHORT $LN61@Pop_heap_h

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdi, QWORD PTR [rdi]
$LN61@Pop_heap_h:

; 2620 :         if (_Count > max_size()) {

	cmp	rsi, rcx
	ja	$LN155@Pop_heap_h

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	cmp	rsi, 16
	jae	SHORT $LN67@Pop_heap_h

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T2[rbp-145], rsi

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T2[rbp-137], 15

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [rdi]
	movups	XMMWORD PTR $T2[rbp-161], xmm0

; 2647 :             return;

	jmp	SHORT $LN83@Pop_heap_h
$LN67@Pop_heap_h:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rbx, rsi
	or	rbx, 15
	cmp	rbx, rcx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN78@Pop_heap_h

; 4716 :             return _Max;

	mov	rbx, rcx
	jmp	SHORT $LN77@Pop_heap_h
$LN78@Pop_heap_h:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rbx, 22
	cmovb	rbx, r8
$LN77@Pop_heap_h:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rbx
	add	rdx, 1
	cmovb	rdx, r9
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T2[rbp-161], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T2[rbp-145], rsi

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T2[rbp-137], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rsi+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rdi
	mov	rcx, rax
	call	memcpy
	npad	1
$LN83@Pop_heap_h:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 535  :     std::sort(this->m_HashKeyTable.begin(), this->m_HashKeyTable.end(), [](std::string A, std::string B) { return A < B; });

	lea	rdx, QWORD PTR $T1[rbp-161]
	lea	rcx, QWORD PTR $T2[rbp-161]
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
	movsx	rbx, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T2[rbp-161]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR $T1[rbp-161]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6448 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	sar	rbx, 63					; 0000003fH
	add	rbx, 2
	add	rbx, r12
	mov	rdi, rbx
	shl	rdi, 5
	add	rdi, r13
	shl	r14, 5
	add	r14, r13
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2961 :         if (this == _STD addressof(_Right)) {

	cmp	r14, rdi
	je	SHORT $LN191@Pop_heap_h

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR [r14+24]
	cmp	rdx, 16

; 4832 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN112@Pop_heap_h

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [r14]

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN124@Pop_heap_h

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN121@Pop_heap_h

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN124@Pop_heap_h:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN112@Pop_heap_h:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	xor	edx, edx
	mov	QWORD PTR [r14+16], rdx

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [r14+24], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [r14], dl

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdi]
	movups	XMMWORD PTR [r14], xmm0
	movups	xmm1, XMMWORD PTR [rdi+16]
	movups	XMMWORD PTR [r14+16], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], rdx

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdi+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], dl

; 2961 :         if (this == _STD addressof(_Right)) {

	jmp	SHORT $LN147@Pop_heap_h
$LN191@Pop_heap_h:
	xor	edx, edx
$LN147@Pop_heap_h:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6449 :         _Hole             = _Idx;

	mov	r14, rbx

; 6443 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	mov	rax, QWORD PTR _Max_sequence_non_leaf$1$[rbp-161]
	cmp	rbx, rax
	jl	$LN193@Pop_heap_h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2620 :         if (_Count > max_size()) {

	mov	r8, QWORD PTR _Bottom$GSCopy$1$[rbp-161]
	mov	rdi, QWORD PTR tv1217[rbp-161]
	mov	rsi, QWORD PTR _Val$GSCopy$1$[rbp-161]
	mov	r15, QWORD PTR _Top$1$[rbp-161]
$LN3@Pop_heap_h:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6452 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

	mov	rdx, rbx
	cmp	rbx, rax
	jne	SHORT $LN5@Pop_heap_h
	test	r8b, 1
	jne	SHORT $LN5@Pop_heap_h

; 6453 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

	shl	r8, 5
	lea	rdx, QWORD PTR [r13-32]
	add	rdx, r8
	shl	rbx, 5
	lea	rcx, QWORD PTR [rbx+r13]
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 6454 :         _Hole             = _Bottom - 1;

	mov	rdx, rdi
$LN5@Pop_heap_h:

; 6455 :     }
; 6456 : 
; 6457 :     _STD _Push_heap_by_index(_First, _Hole, _Top, _STD forward<_Ty>(_Val), _Pred);

	mov	r9, rsi
	mov	r8, r15
	mov	rcx, r13

; 6458 : }

	add	rsp, 184				; 000000b8H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp

; 6455 :     }
; 6456 : 
; 6457 :     _STD _Push_heap_by_index(_First, _Hole, _Top, _STD forward<_Ty>(_Val), _Pred);

	jmp	??$_Push_heap_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ; std::_Push_heap_by_index<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,`BymlFile::ToBinary'::`2'::<lambda_1> >
$LN121@Pop_heap_h:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN155@Pop_heap_h:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN154@Pop_heap_h:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN192@Pop_heap_h:
??$_Pop_heap_hole_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ENDP ; std::_Pop_heap_hole_by_index<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,`BymlFile::ToBinary'::`2'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 80
_Max_sequence_non_leaf$1$ = 112
_Bottom$GSCopy$1$ = 120
tv1217 = 128
_Val$GSCopy$1$ = 136
_Top$1$ = 144
$T3 = 152
_First$ = 256
_Hole$ = 264
_Bottom$ = 272
_Val$ = 280
_Pred$ = 288
?dtor$0@?0???$_Pop_heap_hole_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA PROC ; `std::_Pop_heap_hole_by_index<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,`BymlFile::ToBinary'::`2'::<lambda_1> >'::`1'::dtor$0
	mov	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$_Pop_heap_hole_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA ENDP ; `std::_Pop_heap_hole_by_index<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,`BymlFile::ToBinary'::`2'::<lambda_1> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Pop_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
_TEXT	SEGMENT
_Val$1 = 48
__$ArrayPad$ = 80
_First$ = 112
_Last$ = 120
_Pred$ = 128
??$_Pop_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z PROC ; std::_Pop_heap_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >, COMDAT

; 6472 : _CONSTEXPR20 void _Pop_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	movzx	ebx, r8b
	mov	rsi, rcx

; 6473 :     // pop *_First to *(_Last - 1) and reheap
; 6474 :     if (2 <= _Last - _First) {

	mov	rax, rdx
	sub	rax, rcx
	and	rax, -32				; ffffffffffffffe0H
	cmp	rax, 64					; 00000040H
	jl	$LN49@Pop_heap_u

; 6475 :         --_Last;

	lea	rdi, QWORD PTR [rdx-32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdi]
	movups	XMMWORD PTR _Val$1[rsp], xmm0
	movups	xmm1, XMMWORD PTR [rdi+16]
	movups	XMMWORD PTR _Val$1[rsp+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6476 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	QWORD PTR [rdi+16], 0
	mov	QWORD PTR [rdi+24], 15
	mov	BYTE PTR [rdi], 0

; 6465 :     *_Dest      = _STD move(*_First);

	mov	rdx, rcx
	mov	rcx, rdi
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 6466 :     using _Diff = _Iter_diff_t<_RanIt>;
; 6467 :     _STD _Pop_heap_hole_by_index(

	sub	rdi, rsi
	sar	rdi, 5
	mov	BYTE PTR [rsp+32], bl
	lea	r9, QWORD PTR _Val$1[rsp]
	mov	r8, rdi
	xor	edx, edx
	mov	rcx, rsi
	call	??$_Pop_heap_hole_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ; std::_Pop_heap_hole_by_index<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,`BymlFile::ToBinary'::`2'::<lambda_1> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR _Val$1[rsp+24]
	cmp	rdx, 16

; 4832 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN49@Pop_heap_u

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR _Val$1[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN61@Pop_heap_u

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN61@Pop_heap_u
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN61@Pop_heap_u:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN49@Pop_heap_u:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6479 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+96]
	mov	rbx, QWORD PTR [r11+32]
	mov	rsi, QWORD PTR [r11+40]
	mov	rsp, r11
	pop	rdi
	ret	0
$LN73@Pop_heap_u:
??$_Pop_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ENDP ; std::_Pop_heap_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Val$1 = 48
__$ArrayPad$ = 80
_First$ = 112
_Last$ = 120
_Pred$ = 128
?dtor$0@?0???$_Pop_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA PROC ; `std::_Pop_heap_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Val$1[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$_Pop_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA ENDP ; `std::_Pop_heap_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Prev_iter@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PEAV10@@Z
_TEXT	SEGMENT
_First$ = 8
??$_Prev_iter@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PEAV10@@Z PROC ; std::_Prev_iter<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 1451 :     return --_First;

	lea	rax, QWORD PTR [rcx-32]

; 1452 : }

	ret	0
??$_Prev_iter@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PEAV10@@Z ENDP ; std::_Prev_iter<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
_TEXT	SEGMENT
_First$ = 64
_Mid$ = 72
_Last$ = 80
_Pred$ = 88
??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z PROC ; std::_Guess_median_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >, COMDAT

; 7945 : _CONSTEXPR20 void _Guess_median_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {

	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 7946 :     // sort median element to middle
; 7947 :     using _Diff        = _Iter_diff_t<_RanIt>;
; 7948 :     const _Diff _Count = _Last - _First;

	mov	rdi, r8
	mov	r14, r8
	sub	rdi, rcx
	mov	r15, rdx
	sar	rdi, 5

; 7949 :     if (40 < _Count) { // Tukey's ninther

	cmp	rdi, 40					; 00000028H
	jle	$LN2@Guess_medi

; 7950 :         const _Diff _Step     = (_Count + 1) >> 3; // +1 can't overflow because range was made inclusive in caller

	inc	rdi
	mov	QWORD PTR [rsp+64], rbx
	sar	rdi, 3
	mov	QWORD PTR [rsp+72], rbp
	mov	QWORD PTR [rsp+80], rsi

; 7951 :         const _Diff _Two_step = _Step << 1; // note: intentionally discards low-order bit
; 7952 :         _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);

	mov	rsi, rdi
	shl	rdi, 5
	shl	rsi, 6
	lea	rbp, QWORD PTR [rdi+rcx]
	mov	rdx, rbp
	lea	r8, QWORD PTR [rsi+rcx]
	call	??$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ; std::_Med3_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >

; 7953 :         _Med3_unchecked(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

	mov	rcx, r15
	lea	r8, QWORD PTR [rdi+r15]
	sub	rcx, rdi
	mov	rdx, r15
	call	??$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ; std::_Med3_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >

; 7954 :         _Med3_unchecked(_Last - _Two_step, _Last - _Step, _Last, _Pred);

	mov	rbx, r14
	mov	rcx, r14
	sub	rbx, rdi
	sub	rcx, rsi
	mov	rdx, rbx
	mov	r8, r14
	call	??$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ; std::_Med3_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >

; 7955 :         _Med3_unchecked(_First + _Step, _Mid, _Last - _Step, _Pred);

	mov	r8, rbx
	mov	rdx, r15
	mov	rcx, rbp
	mov	rsi, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 7958 :     }
; 7959 : }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi

; 7955 :         _Med3_unchecked(_First + _Step, _Mid, _Last - _Step, _Pred);

	jmp	??$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ; std::_Med3_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >
$LN2@Guess_medi:

; 7958 :     }
; 7959 : }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi

; 7956 :     } else {
; 7957 :         _Med3_unchecked(_First, _Mid, _Last, _Pred);

	jmp	??$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ; std::_Med3_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >
??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ENDP ; std::_Guess_median_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Next_iter@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PEAV10@@Z
_TEXT	SEGMENT
_First$ = 8
??$_Next_iter@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PEAV10@@Z PROC ; std::_Next_iter<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 1438 :     return ++_First;

	lea	rax, QWORD PTR [rcx+32]

; 1439 : }

	ret	0
??$_Next_iter@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PEAV10@@Z ENDP ; std::_Next_iter<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??$swap@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$swap@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z PROC ; std::swap<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 4308 :         if (this != _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN58@swap

; 4282 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	xmm2, XMMWORD PTR [rcx]
	movups	xmm3, XMMWORD PTR [rcx+16]
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1

; 4283 :                 _CSTD memcpy(_Right_data_mem, _Temp_mem, _Memcpy_val_size);

	movups	XMMWORD PTR [rdx], xmm2
	movups	XMMWORD PTR [rdx+16], xmm3
$LN58@swap:

; 4895 :     _Left.swap(_Right);
; 4896 : }

	ret	0
??$swap@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ENDP ; std::swap<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0AEAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAPEAV01@$0A@@?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@std@@QEAA@AEAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$ = 24
??$?0AEAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAPEAV01@$0A@@?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@std@@QEAA@AEAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *><std::basic_string<char,std::char_traits<char>,std::allocator<char> > * &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > * &,0>, COMDAT

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rcx+8], rax

; 243  :     }

	mov	rax, rcx
	ret	0
??$?0AEAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAPEAV01@$0A@@?$pair@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV12@@std@@QEAA@AEAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *><std::basic_string<char,std::char_traits<char>,std::allocator<char> > * &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > * &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Pop_heap_hole_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 80
_Max_sequence_non_leaf$1$ = 112
_Bottom$GSCopy$1$ = 120
tv1217 = 128
_Val$GSCopy$1$ = 136
_Top$1$ = 144
$T3 = 152
_First$ = 256
_Hole$ = 264
_Bottom$ = 272
_Val$ = 280
_Pred$ = 288
??$_Pop_heap_hole_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z PROC ; std::_Pop_heap_hole_by_index<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,`BymlFile::ToBinary'::`2'::<lambda_2> >, COMDAT

; 6432 :     _RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Bottom, _Ty&& _Val, _Pr _Pred) {

	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-23]
	sub	rsp, 184				; 000000b8H
	mov	rsi, r9
	mov	QWORD PTR _Val$GSCopy$1$[rbp-161], r9
	mov	QWORD PTR _Bottom$GSCopy$1$[rbp-161], r8
	mov	r14, rdx
	mov	r13, rcx

; 6433 :     // percolate _Hole to _Bottom, then push _Val
; 6434 :     _STL_INTERNAL_CHECK(_Bottom > 0);
; 6435 : 
; 6436 :     using _Diff      = _Iter_diff_t<_RanIt>;
; 6437 :     const _Diff _Top = _Hole;

	mov	r15, rdx
	mov	QWORD PTR _Top$1$[rbp-161], rdx

; 6438 :     _Diff _Idx       = _Hole;

	mov	rbx, rdx

; 6439 : 
; 6440 :     // Check whether _Idx can have a child before calculating that child's index, since
; 6441 :     // calculating the child's index can trigger integer overflows
; 6442 :     const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; // shift for codegen

	lea	rdi, QWORD PTR [r8-1]
	mov	QWORD PTR tv1217[rbp-161], rdi
	mov	rax, rdi
	sar	rax, 1
	mov	QWORD PTR _Max_sequence_non_leaf$1$[rbp-161], rax

; 6443 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	cmp	rdx, rax
	jge	$LN3@Pop_heap_h
	xor	edx, edx
$LN193@Pop_heap_h:

; 6444 :         _Idx = 2 * _Idx + 2;

	mov	r9, -1
	lea	r8d, QWORD PTR [r9+23]
	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	lea	r12, QWORD PTR [rbx+rbx]

; 6445 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

	lea	rax, QWORD PTR $T1[rbp-161]
	mov	QWORD PTR $T3[rbp-161], rax
	mov	r15, r12
	shl	r15, 5
	lea	rsi, QWORD PTR [r13+32]
	add	rsi, r15
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T1[rbp-161], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T1[rbp-145], rdx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T1[rbp-137], rdx

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rdi, QWORD PTR [rsi+16]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rsi+24], 16
	jb	SHORT $LN20@Pop_heap_h

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rsi, QWORD PTR [rsi]
$LN20@Pop_heap_h:

; 2620 :         if (_Count > max_size()) {

	cmp	rdi, rcx
	ja	$LN154@Pop_heap_h

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T1[rbp-137], 15
	cmp	rdi, 16
	jae	SHORT $LN26@Pop_heap_h

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T1[rbp-145], rdi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [rsi]
	movups	XMMWORD PTR $T1[rbp-161], xmm0

; 2647 :             return;

	jmp	SHORT $LN42@Pop_heap_h
$LN26@Pop_heap_h:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rbx, rdi
	or	rbx, 15
	cmp	rbx, rcx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN37@Pop_heap_h

; 4716 :             return _Max;

	mov	rbx, rcx
	jmp	SHORT $LN36@Pop_heap_h
$LN37@Pop_heap_h:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rbx, 22
	cmovb	rbx, r8
$LN36@Pop_heap_h:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rbx
	add	rdx, 1
	cmovb	rdx, r9
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T1[rbp-161], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T1[rbp-145], rdi

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T1[rbp-137], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rdi+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rsi
	mov	rcx, rax
	call	memcpy
	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	mov	r8d, 22
	lea	r9, QWORD PTR [r8-23]
$LN42@Pop_heap_h:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6445 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

	lea	rdi, QWORD PTR [r13+64]
	add	rdi, r15
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T2[rbp-161], xmm0

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rsi, QWORD PTR [rdi+16]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rdi+24], 16
	jb	SHORT $LN61@Pop_heap_h

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdi, QWORD PTR [rdi]
$LN61@Pop_heap_h:

; 2620 :         if (_Count > max_size()) {

	cmp	rsi, rcx
	ja	$LN155@Pop_heap_h

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	cmp	rsi, 16
	jae	SHORT $LN67@Pop_heap_h

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T2[rbp-145], rsi

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T2[rbp-137], 15

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [rdi]
	movups	XMMWORD PTR $T2[rbp-161], xmm0

; 2647 :             return;

	jmp	SHORT $LN83@Pop_heap_h
$LN67@Pop_heap_h:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rbx, rsi
	or	rbx, 15
	cmp	rbx, rcx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN78@Pop_heap_h

; 4716 :             return _Max;

	mov	rbx, rcx
	jmp	SHORT $LN77@Pop_heap_h
$LN78@Pop_heap_h:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rbx, 22
	cmovb	rbx, r8
$LN77@Pop_heap_h:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rbx
	add	rdx, 1
	cmovb	rdx, r9
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T2[rbp-161], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T2[rbp-145], rsi

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T2[rbp-137], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rsi+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rdi
	mov	rcx, rax
	call	memcpy
	npad	1
$LN83@Pop_heap_h:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 536  :     std::sort(this->m_StringTable.begin(), this->m_StringTable.end(), [](std::string A, std::string B) { return A < B; });

	lea	rdx, QWORD PTR $T1[rbp-161]
	lea	rcx, QWORD PTR $T2[rbp-161]
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
	movsx	rbx, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T2[rbp-161]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR $T1[rbp-161]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6448 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	sar	rbx, 63					; 0000003fH
	add	rbx, 2
	add	rbx, r12
	mov	rdi, rbx
	shl	rdi, 5
	add	rdi, r13
	shl	r14, 5
	add	r14, r13
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2961 :         if (this == _STD addressof(_Right)) {

	cmp	r14, rdi
	je	SHORT $LN191@Pop_heap_h

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR [r14+24]
	cmp	rdx, 16

; 4832 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN112@Pop_heap_h

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [r14]

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN124@Pop_heap_h

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN121@Pop_heap_h

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN124@Pop_heap_h:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN112@Pop_heap_h:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	xor	edx, edx
	mov	QWORD PTR [r14+16], rdx

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [r14+24], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [r14], dl

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdi]
	movups	XMMWORD PTR [r14], xmm0
	movups	xmm1, XMMWORD PTR [rdi+16]
	movups	XMMWORD PTR [r14+16], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], rdx

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdi+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], dl

; 2961 :         if (this == _STD addressof(_Right)) {

	jmp	SHORT $LN147@Pop_heap_h
$LN191@Pop_heap_h:
	xor	edx, edx
$LN147@Pop_heap_h:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6449 :         _Hole             = _Idx;

	mov	r14, rbx

; 6443 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	mov	rax, QWORD PTR _Max_sequence_non_leaf$1$[rbp-161]
	cmp	rbx, rax
	jl	$LN193@Pop_heap_h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2620 :         if (_Count > max_size()) {

	mov	r8, QWORD PTR _Bottom$GSCopy$1$[rbp-161]
	mov	rdi, QWORD PTR tv1217[rbp-161]
	mov	rsi, QWORD PTR _Val$GSCopy$1$[rbp-161]
	mov	r15, QWORD PTR _Top$1$[rbp-161]
$LN3@Pop_heap_h:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6452 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

	mov	rdx, rbx
	cmp	rbx, rax
	jne	SHORT $LN5@Pop_heap_h
	test	r8b, 1
	jne	SHORT $LN5@Pop_heap_h

; 6453 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

	shl	r8, 5
	lea	rdx, QWORD PTR [r13-32]
	add	rdx, r8
	shl	rbx, 5
	lea	rcx, QWORD PTR [rbx+r13]
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 6454 :         _Hole             = _Bottom - 1;

	mov	rdx, rdi
$LN5@Pop_heap_h:

; 6455 :     }
; 6456 : 
; 6457 :     _STD _Push_heap_by_index(_First, _Hole, _Top, _STD forward<_Ty>(_Val), _Pred);

	mov	r9, rsi
	mov	r8, r15
	mov	rcx, r13

; 6458 : }

	add	rsp, 184				; 000000b8H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp

; 6455 :     }
; 6456 : 
; 6457 :     _STD _Push_heap_by_index(_First, _Hole, _Top, _STD forward<_Ty>(_Val), _Pred);

	jmp	??$_Push_heap_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ; std::_Push_heap_by_index<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,`BymlFile::ToBinary'::`2'::<lambda_2> >
$LN121@Pop_heap_h:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN155@Pop_heap_h:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN154@Pop_heap_h:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN192@Pop_heap_h:
??$_Pop_heap_hole_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ENDP ; std::_Pop_heap_hole_by_index<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,`BymlFile::ToBinary'::`2'::<lambda_2> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 80
_Max_sequence_non_leaf$1$ = 112
_Bottom$GSCopy$1$ = 120
tv1217 = 128
_Val$GSCopy$1$ = 136
_Top$1$ = 144
$T3 = 152
_First$ = 256
_Hole$ = 264
_Bottom$ = 272
_Val$ = 280
_Pred$ = 288
?dtor$0@?0???$_Pop_heap_hole_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA PROC ; `std::_Pop_heap_hole_by_index<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,`BymlFile::ToBinary'::`2'::<lambda_2> >'::`1'::dtor$0
	mov	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$_Pop_heap_hole_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA ENDP ; `std::_Pop_heap_hole_by_index<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,`BymlFile::ToBinary'::`2'::<lambda_2> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Pop_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
_TEXT	SEGMENT
_Val$1 = 48
__$ArrayPad$ = 80
_First$ = 112
_Last$ = 120
_Pred$ = 128
??$_Pop_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z PROC ; std::_Pop_heap_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >, COMDAT

; 6472 : _CONSTEXPR20 void _Pop_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	movzx	ebx, r8b
	mov	rsi, rcx

; 6473 :     // pop *_First to *(_Last - 1) and reheap
; 6474 :     if (2 <= _Last - _First) {

	mov	rax, rdx
	sub	rax, rcx
	and	rax, -32				; ffffffffffffffe0H
	cmp	rax, 64					; 00000040H
	jl	$LN49@Pop_heap_u

; 6475 :         --_Last;

	lea	rdi, QWORD PTR [rdx-32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdi]
	movups	XMMWORD PTR _Val$1[rsp], xmm0
	movups	xmm1, XMMWORD PTR [rdi+16]
	movups	XMMWORD PTR _Val$1[rsp+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6476 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	QWORD PTR [rdi+16], 0
	mov	QWORD PTR [rdi+24], 15
	mov	BYTE PTR [rdi], 0

; 6465 :     *_Dest      = _STD move(*_First);

	mov	rdx, rcx
	mov	rcx, rdi
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 6466 :     using _Diff = _Iter_diff_t<_RanIt>;
; 6467 :     _STD _Pop_heap_hole_by_index(

	sub	rdi, rsi
	sar	rdi, 5
	mov	BYTE PTR [rsp+32], bl
	lea	r9, QWORD PTR _Val$1[rsp]
	mov	r8, rdi
	xor	edx, edx
	mov	rcx, rsi
	call	??$_Pop_heap_hole_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ; std::_Pop_heap_hole_by_index<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,`BymlFile::ToBinary'::`2'::<lambda_2> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR _Val$1[rsp+24]
	cmp	rdx, 16

; 4832 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN49@Pop_heap_u

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR _Val$1[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN61@Pop_heap_u

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN61@Pop_heap_u
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN61@Pop_heap_u:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN49@Pop_heap_u:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6479 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+96]
	mov	rbx, QWORD PTR [r11+32]
	mov	rsi, QWORD PTR [r11+40]
	mov	rsp, r11
	pop	rdi
	ret	0
$LN73@Pop_heap_u:
??$_Pop_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ENDP ; std::_Pop_heap_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Val$1 = 48
__$ArrayPad$ = 80
_First$ = 112
_Last$ = 120
_Pred$ = 128
?dtor$0@?0???$_Pop_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA PROC ; `std::_Pop_heap_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Val$1[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$_Pop_heap_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA ENDP ; `std::_Pop_heap_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
_TEXT	SEGMENT
_First$ = 64
_Mid$ = 72
_Last$ = 80
_Pred$ = 88
??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z PROC ; std::_Guess_median_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >, COMDAT

; 7945 : _CONSTEXPR20 void _Guess_median_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {

	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 7946 :     // sort median element to middle
; 7947 :     using _Diff        = _Iter_diff_t<_RanIt>;
; 7948 :     const _Diff _Count = _Last - _First;

	mov	rdi, r8
	mov	r14, r8
	sub	rdi, rcx
	mov	r15, rdx
	sar	rdi, 5

; 7949 :     if (40 < _Count) { // Tukey's ninther

	cmp	rdi, 40					; 00000028H
	jle	$LN2@Guess_medi

; 7950 :         const _Diff _Step     = (_Count + 1) >> 3; // +1 can't overflow because range was made inclusive in caller

	inc	rdi
	mov	QWORD PTR [rsp+64], rbx
	sar	rdi, 3
	mov	QWORD PTR [rsp+72], rbp
	mov	QWORD PTR [rsp+80], rsi

; 7951 :         const _Diff _Two_step = _Step << 1; // note: intentionally discards low-order bit
; 7952 :         _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);

	mov	rsi, rdi
	shl	rdi, 5
	shl	rsi, 6
	lea	rbp, QWORD PTR [rdi+rcx]
	mov	rdx, rbp
	lea	r8, QWORD PTR [rsi+rcx]
	call	??$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ; std::_Med3_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >

; 7953 :         _Med3_unchecked(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

	mov	rcx, r15
	lea	r8, QWORD PTR [rdi+r15]
	sub	rcx, rdi
	mov	rdx, r15
	call	??$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ; std::_Med3_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >

; 7954 :         _Med3_unchecked(_Last - _Two_step, _Last - _Step, _Last, _Pred);

	mov	rbx, r14
	mov	rcx, r14
	sub	rbx, rdi
	sub	rcx, rsi
	mov	rdx, rbx
	mov	r8, r14
	call	??$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ; std::_Med3_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >

; 7955 :         _Med3_unchecked(_First + _Step, _Mid, _Last - _Step, _Pred);

	mov	r8, rbx
	mov	rdx, r15
	mov	rcx, rbp
	mov	rsi, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 7958 :     }
; 7959 : }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi

; 7955 :         _Med3_unchecked(_First + _Step, _Mid, _Last - _Step, _Pred);

	jmp	??$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ; std::_Med3_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >
$LN2@Guess_medi:

; 7958 :     }
; 7959 : }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi

; 7956 :     } else {
; 7957 :         _Med3_unchecked(_First, _Mid, _Last, _Pred);

	jmp	??$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ; std::_Med3_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >
??$_Guess_median_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ENDP ; std::_Guess_median_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@AEBVNode@BymlFile@@$$V$0A@@?$tuple@AEBVNode@BymlFile@@@std@@QEAA@U_Exact_args_t@1@AEBVNode@BymlFile@@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_This_arg$ = 24
??$?0U_Exact_args_t@std@@AEBVNode@BymlFile@@$$V$0A@@?$tuple@AEBVNode@BymlFile@@@std@@QEAA@U_Exact_args_t@1@AEBVNode@BymlFile@@@Z PROC ; std::tuple<BymlFile::Node const &>::tuple<BymlFile::Node const &><std::_Exact_args_t,BymlFile::Node const &,0>, COMDAT

; 144  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

	mov	QWORD PTR [rcx], r8

; 317  :         : _Mybase(_Exact_args_t{}, _STD forward<_Rest2>(_Rest_arg)...), _Myfirst(_STD forward<_This2>(_This_arg)) {}

	mov	rax, rcx
	ret	0
??$?0U_Exact_args_t@std@@AEBVNode@BymlFile@@$$V$0A@@?$tuple@AEBVNode@BymlFile@@@std@@QEAA@U_Exact_args_t@1@AEBVNode@BymlFile@@@Z ENDP ; std::tuple<BymlFile::Node const &>::tuple<BymlFile::Node const &><std::_Exact_args_t,BymlFile::Node const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@U?$pair@$$CBVNode@BymlFile@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBVNode@BymlFile@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBVNode@BymlFile@@I@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBVNode@BymlFile@@@0@$$QEAV?$tuple@$$V@0@@Z
_TEXT	SEGMENT
_Location$ = 48
<_Args_0>$dead$ = 56
<_Args_1>$ = 64
$T1 = 72
<_Args_2>$dead$ = 72
??$construct_at@U?$pair@$$CBVNode@BymlFile@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBVNode@BymlFile@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBVNode@BymlFile@@I@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBVNode@BymlFile@@@0@$$QEAV?$tuple@$$V@0@@Z PROC ; std::construct_at<std::pair<BymlFile::Node const ,unsigned int>,std::piecewise_construct_t const &,std::tuple<BymlFile::Node const &>,std::tuple<>,0>, COMDAT

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN18:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+32], r9
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple

; 366  :     tuple(tuple&&)      = default;

	mov	rbx, QWORD PTR [r8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	QWORD PTR $T1[rsp], rcx
	mov	rdx, rbx
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	npad	1
	movzx	eax, BYTE PTR [rbx+24]
	mov	BYTE PTR [rdi+24], al
	lea	rcx, QWORD PTR [rdi+32]
	lea	rdx, QWORD PTR [rbx+32]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rdi+64]
	lea	rdx, QWORD PTR [rbx+64]
	call	??0?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@AEBV01@@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::vector<BymlFile::Node,std::allocator<BymlFile::Node> >
	npad	1
	mov	DWORD PTR [rdi+88], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rdi

; 242  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$construct_at@U?$pair@$$CBVNode@BymlFile@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBVNode@BymlFile@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBVNode@BymlFile@@I@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBVNode@BymlFile@@@0@$$QEAV?$tuple@$$V@0@@Z ENDP ; std::construct_at<std::pair<BymlFile::Node const ,unsigned int>,std::piecewise_construct_t const &,std::tuple<BymlFile::Node const &>,std::tuple<>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Location$ = 48
<_Args_0>$dead$ = 56
<_Args_1>$ = 64
$T1 = 72
<_Args_2>$dead$ = 72
?dtor$2@?0???$construct_at@U?$pair@$$CBVNode@BymlFile@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBVNode@BymlFile@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBVNode@BymlFile@@I@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBVNode@BymlFile@@@0@$$QEAV?$tuple@$$V@0@@Z@4HA PROC ; `std::construct_at<std::pair<BymlFile::Node const ,unsigned int>,std::piecewise_construct_t const &,std::tuple<BymlFile::Node const &>,std::tuple<>,0>'::`1'::dtor$2
	mov	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$2@?0???$construct_at@U?$pair@$$CBVNode@BymlFile@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBVNode@BymlFile@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBVNode@BymlFile@@I@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBVNode@BymlFile@@@0@$$QEAV?$tuple@$$V@0@@Z@4HA ENDP ; `std::construct_at<std::pair<BymlFile::Node const ,unsigned int>,std::piecewise_construct_t const &,std::tuple<BymlFile::Node const &>,std::tuple<>,0>'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Location$ = 48
<_Args_0>$dead$ = 56
<_Args_1>$ = 64
$T1 = 72
<_Args_2>$dead$ = 72
?dtor$3@?0???$construct_at@U?$pair@$$CBVNode@BymlFile@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBVNode@BymlFile@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBVNode@BymlFile@@I@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBVNode@BymlFile@@@0@$$QEAV?$tuple@$$V@0@@Z@4HA PROC ; `std::construct_at<std::pair<BymlFile::Node const ,unsigned int>,std::piecewise_construct_t const &,std::tuple<BymlFile::Node const &>,std::tuple<>,0>'::`1'::dtor$3
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 32					; 00000020H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0???$construct_at@U?$pair@$$CBVNode@BymlFile@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBVNode@BymlFile@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBVNode@BymlFile@@I@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBVNode@BymlFile@@@0@$$QEAV?$tuple@$$V@0@@Z@4HA ENDP ; `std::construct_at<std::pair<BymlFile::Node const ,unsigned int>,std::piecewise_construct_t const &,std::tuple<BymlFile::Node const &>,std::tuple<>,0>'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@U?$pair@$$CBVNode@BymlFile@@I@std@@U12@$0A@@std@@YAPEAU?$pair@$$CBVNode@BymlFile@@I@0@QEAU10@$$QEAU10@@Z
_TEXT	SEGMENT
$T1 = 48
_Location$ = 48
<_Args_0>$ = 56
??$construct_at@U?$pair@$$CBVNode@BymlFile@@I@std@@U12@$0A@@std@@YAPEAU?$pair@$$CBVNode@BymlFile@@I@0@QEAU10@$$QEAU10@@Z PROC ; std::construct_at<std::pair<BymlFile::Node const ,unsigned int>,std::pair<BymlFile::Node const ,unsigned int>,0>, COMDAT

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN13:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 246  :     pair(pair&&)      = default;

	mov	QWORD PTR $T1[rsp], rcx
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	npad	1
	movzx	eax, BYTE PTR [rbx+24]
	mov	BYTE PTR [rdi+24], al
	lea	rcx, QWORD PTR [rdi+32]
	lea	rdx, QWORD PTR [rbx+32]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rdi+64]
	lea	rdx, QWORD PTR [rbx+64]
	call	??0?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@AEBV01@@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::vector<BymlFile::Node,std::allocator<BymlFile::Node> >
	npad	1
	mov	eax, DWORD PTR [rbx+88]
	mov	DWORD PTR [rdi+88], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rdi

; 242  : }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$construct_at@U?$pair@$$CBVNode@BymlFile@@I@std@@U12@$0A@@std@@YAPEAU?$pair@$$CBVNode@BymlFile@@I@0@QEAU10@$$QEAU10@@Z ENDP ; std::construct_at<std::pair<BymlFile::Node const ,unsigned int>,std::pair<BymlFile::Node const ,unsigned int>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
_Location$ = 48
<_Args_0>$ = 56
?dtor$1@?0???$construct_at@U?$pair@$$CBVNode@BymlFile@@I@std@@U12@$0A@@std@@YAPEAU?$pair@$$CBVNode@BymlFile@@I@0@QEAU10@$$QEAU10@@Z@4HA PROC ; `std::construct_at<std::pair<BymlFile::Node const ,unsigned int>,std::pair<BymlFile::Node const ,unsigned int>,0>'::`1'::dtor$1
	mov	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$1@?0???$construct_at@U?$pair@$$CBVNode@BymlFile@@I@std@@U12@$0A@@std@@YAPEAU?$pair@$$CBVNode@BymlFile@@I@0@QEAU10@$$QEAU10@@Z@4HA ENDP ; `std::construct_at<std::pair<BymlFile::Node const ,unsigned int>,std::pair<BymlFile::Node const ,unsigned int>,0>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
_Location$ = 48
<_Args_0>$ = 56
?dtor$2@?0???$construct_at@U?$pair@$$CBVNode@BymlFile@@I@std@@U12@$0A@@std@@YAPEAU?$pair@$$CBVNode@BymlFile@@I@0@QEAU10@$$QEAU10@@Z@4HA PROC ; `std::construct_at<std::pair<BymlFile::Node const ,unsigned int>,std::pair<BymlFile::Node const ,unsigned int>,0>'::`1'::dtor$2
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 32					; 00000020H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0???$construct_at@U?$pair@$$CBVNode@BymlFile@@I@std@@U12@$0A@@std@@YAPEAU?$pair@$$CBVNode@BymlFile@@I@0@QEAU10@$$QEAU10@@Z@4HA ENDP ; `std::construct_at<std::pair<BymlFile::Node const ,unsigned int>,std::pair<BymlFile::Node const ,unsigned int>,0>'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@AEBV?$vector@EV?$allocator@E@std@@@1@$$V$0A@@?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@std@@QEAA@U_Exact_args_t@1@AEBV?$vector@EV?$allocator@E@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_This_arg$ = 24
??$?0U_Exact_args_t@std@@AEBV?$vector@EV?$allocator@E@std@@@1@$$V$0A@@?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@std@@QEAA@U_Exact_args_t@1@AEBV?$vector@EV?$allocator@E@std@@@1@@Z PROC ; std::tuple<std::vector<unsigned char,std::allocator<unsigned char> > const &>::tuple<std::vector<unsigned char,std::allocator<unsigned char> > const &><std::_Exact_args_t,std::vector<unsigned char,std::allocator<unsigned char> > const &,0>, COMDAT

; 144  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

	mov	QWORD PTR [rcx], r8

; 317  :         : _Mybase(_Exact_args_t{}, _STD forward<_Rest2>(_Rest_arg)...), _Myfirst(_STD forward<_This2>(_This_arg)) {}

	mov	rax, rcx
	ret	0
??$?0U_Exact_args_t@std@@AEBV?$vector@EV?$allocator@E@std@@@1@$$V$0A@@?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@std@@QEAA@U_Exact_args_t@1@AEBV?$vector@EV?$allocator@E@std@@@1@@Z ENDP ; std::tuple<std::vector<unsigned char,std::allocator<unsigned char> > const &>::tuple<std::vector<unsigned char,std::allocator<unsigned char> > const &><std::_Exact_args_t,std::vector<unsigned char,std::allocator<unsigned char> > const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@0@$$QEAV?$tuple@$$V@0@@Z
_TEXT	SEGMENT
_Location$ = 48
<_Args_0>$dead$ = 56
<_Args_1>$ = 64
<_Args_2>$dead$ = 72
??$construct_at@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@0@$$QEAV?$tuple@$$V@0@@Z PROC ; std::construct_at<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,std::piecewise_construct_t const &,std::tuple<std::vector<unsigned char,std::allocator<unsigned char> > const &>,std::tuple<>,0>, COMDAT

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN13:
	push	rbx
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	rdx, QWORD PTR [r8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	DWORD PTR [rbx+24], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 242  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$construct_at@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@0@$$QEAV?$tuple@$$V@0@@Z ENDP ; std::construct_at<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,std::piecewise_construct_t const &,std::tuple<std::vector<unsigned char,std::allocator<unsigned char> > const &>,std::tuple<>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@U12@$0A@@std@@YAPEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@0@QEAU10@$$QEAU10@@Z
_TEXT	SEGMENT
_Location$ = 48
<_Args_0>$ = 56
??$construct_at@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@U12@$0A@@std@@YAPEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@0@QEAU10@$$QEAU10@@Z PROC ; std::construct_at<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,0>, COMDAT

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN8:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 246  :     pair(pair&&)      = default;

	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	mov	eax, DWORD PTR [rbx+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 242  : }

	mov	rbx, QWORD PTR [rsp+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 246  :     pair(pair&&)      = default;

	mov	DWORD PTR [rdi+24], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rdi

; 242  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$construct_at@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@U12@$0A@@std@@YAPEAU?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@0@QEAU10@$$QEAU10@@Z ENDP ; std::construct_at<std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 715  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rdx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdx+16], 0

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@VNode@BymlFile@@$$V@?$_Default_allocator_traits@V?$allocator@VNode@BymlFile@@@std@@@std@@SAXAEAV?$allocator@VNode@BymlFile@@@1@QEAVNode@BymlFile@@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$construct@VNode@BymlFile@@$$V@?$_Default_allocator_traits@V?$allocator@VNode@BymlFile@@@std@@@std@@SAXAEAV?$allocator@VNode@BymlFile@@@1@QEAVNode@BymlFile@@@Z PROC ; std::_Default_allocator_traits<std::allocator<BymlFile::Node> >::construct<BymlFile::Node>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	xorps	xmm0, xmm0
	mov	QWORD PTR [rdx], rax
	mov	QWORD PTR [rdx+8], rax
	mov	QWORD PTR [rdx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rdx+32], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdx+48], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdx+56], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdx+32], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rdx+64], rax
	mov	QWORD PTR [rdx+72], rax
	mov	QWORD PTR [rdx+80], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@VNode@BymlFile@@$$V@?$_Default_allocator_traits@V?$allocator@VNode@BymlFile@@@std@@@std@@SAXAEAV?$allocator@VNode@BymlFile@@@1@QEAVNode@BymlFile@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<BymlFile::Node> >::construct<BymlFile::Node>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple
;	COMDAT ??0?$tuple@AEBVNode@BymlFile@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
__that$ = 16
??0?$tuple@AEBVNode@BymlFile@@@std@@QEAA@$$QEAV01@@Z PROC ; std::tuple<BymlFile::Node const &>::tuple<BymlFile::Node const &>, COMDAT

; 366  :     tuple(tuple&&)      = default;

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??0?$tuple@AEBVNode@BymlFile@@@std@@QEAA@$$QEAV01@@Z ENDP ; std::tuple<BymlFile::Node const &>::tuple<BymlFile::Node const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??0?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@$$QEAU01@@Z
_TEXT	SEGMENT
$T1 = 48
this$ = 48
__that$ = 56
??0?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@$$QEAU01@@Z PROC ; std::pair<BymlFile::Node const ,unsigned int>::pair<BymlFile::Node const ,unsigned int>, COMDAT

; 246  :     pair(pair&&)      = default;

$LN11:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx
	mov	QWORD PTR $T1[rsp], rcx
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	npad	1
	movzx	eax, BYTE PTR [rbx+24]
	mov	BYTE PTR [rdi+24], al
	lea	rcx, QWORD PTR [rdi+32]
	lea	rdx, QWORD PTR [rbx+32]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rdi+64]
	lea	rdx, QWORD PTR [rbx+64]
	call	??0?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@AEBV01@@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::vector<BymlFile::Node,std::allocator<BymlFile::Node> >
	npad	1
	mov	eax, DWORD PTR [rbx+88]
	mov	DWORD PTR [rdi+88], eax
	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@$$QEAU01@@Z ENDP ; std::pair<BymlFile::Node const ,unsigned int>::pair<BymlFile::Node const ,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
this$ = 48
__that$ = 56
?dtor$1@?0???0?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@$$QEAU01@@Z@4HA PROC ; `std::pair<BymlFile::Node const ,unsigned int>::pair<BymlFile::Node const ,unsigned int>'::`1'::dtor$1
	mov	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$1@?0???0?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@$$QEAU01@@Z@4HA ENDP ; `std::pair<BymlFile::Node const ,unsigned int>::pair<BymlFile::Node const ,unsigned int>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
this$ = 48
__that$ = 56
?dtor$2@?0???0?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@$$QEAU01@@Z@4HA PROC ; `std::pair<BymlFile::Node const ,unsigned int>::pair<BymlFile::Node const ,unsigned int>'::`1'::dtor$2
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 32					; 00000020H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0???0?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@$$QEAU01@@Z@4HA ENDP ; `std::pair<BymlFile::Node const ,unsigned int>::pair<BymlFile::Node const ,unsigned int>'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple
;	COMDAT ??0?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
__that$ = 16
??0?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@std@@QEAA@$$QEAV01@@Z PROC ; std::tuple<std::vector<unsigned char,std::allocator<unsigned char> > const &>::tuple<std::vector<unsigned char,std::allocator<unsigned char> > const &>, COMDAT

; 366  :     tuple(tuple&&)      = default;

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??0?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@std@@QEAA@$$QEAV01@@Z ENDP ; std::tuple<std::vector<unsigned char,std::allocator<unsigned char> > const &>::tuple<std::vector<unsigned char,std::allocator<unsigned char> > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??0?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@QEAA@$$QEAU01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@QEAA@$$QEAU01@@Z PROC ; std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>, COMDAT

; 246  :     pair(pair&&)      = default;

$LN6:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	mov	eax, DWORD PTR [rbx+24]
	mov	rbx, QWORD PTR [rsp+48]
	mov	DWORD PTR [rdi+24], eax
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@QEAA@$$QEAU01@@Z ENDP ; std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?swap@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXAEAV12@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
?swap@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXAEAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::swap, COMDAT

; 4308 :         if (this != _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN56@swap

; 4282 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	xmm2, XMMWORD PTR [rcx]
	movups	xmm3, XMMWORD PTR [rcx+16]
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1

; 4283 :                 _CSTD memcpy(_Right_data_mem, _Temp_mem, _Memcpy_val_size);

	movups	XMMWORD PTR [rdx], xmm2
	movups	XMMWORD PTR [rdx+16], xmm3
$LN56@swap:

; 4309 :             _Pocs(_Getal(), _Right._Getal());
; 4310 : 
; 4311 : #if _ITERATOR_DEBUG_LEVEL != 0
; 4312 :             auto& _My_data    = _Mypair._Myval2;
; 4313 :             auto& _Right_data = _Right._Mypair._Myval2;
; 4314 : 
; 4315 :             if (!_My_data._Large_string_engaged()) {
; 4316 :                 _My_data._Orphan_all();
; 4317 :             }
; 4318 : 
; 4319 :             if (!_Right_data._Large_string_engaged()) {
; 4320 :                 _Right_data._Orphan_all();
; 4321 :             }
; 4322 : 
; 4323 :             _My_data._Swap_proxy_and_iterators(_Right_data);
; 4324 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 4325 : 
; 4326 :             _Swap_data(_Right);
; 4327 :         }
; 4328 :     }

	ret	0
?swap@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXAEAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::swap
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?_Swap_data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXAEAV12@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
?_Swap_data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXAEAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_data, COMDAT

; 4262 :         using _STD swap;
; 4263 : 
; 4264 :         auto& _My_data    = _Mypair._Myval2;
; 4265 :         auto& _Right_data = _Right._Mypair._Myval2;
; 4266 : 
; 4267 :         const bool _My_large    = _My_data._Large_string_engaged();
; 4268 :         const bool _Right_large = _Right_data._Large_string_engaged();
; 4269 : 
; 4270 : #if !defined(_INSERT_STRING_ANNOTATION)
; 4271 :         if constexpr (_Can_memcpy_val) {
; 4272 : #if _HAS_CXX20
; 4273 :             if (!_STD is_constant_evaluated())
; 4274 : #endif // _HAS_CXX20
; 4275 :             {
; 4276 :                 const auto _My_data_mem =
; 4277 :                     reinterpret_cast<unsigned char*>(_STD addressof(_My_data)) + _Memcpy_val_offset;
; 4278 :                 const auto _Right_data_mem =
; 4279 :                     reinterpret_cast<unsigned char*>(_STD addressof(_Right_data)) + _Memcpy_val_offset;
; 4280 :                 unsigned char _Temp_mem[_Memcpy_val_size];
; 4281 :                 _CSTD memcpy(_Temp_mem, _My_data_mem, _Memcpy_val_size);
; 4282 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	xmm2, XMMWORD PTR [rcx]
	movups	xmm3, XMMWORD PTR [rcx+16]
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1

; 4283 :                 _CSTD memcpy(_Right_data_mem, _Temp_mem, _Memcpy_val_size);

	movups	XMMWORD PTR [rdx], xmm2
	movups	XMMWORD PTR [rdx+16], xmm3

; 4284 : 
; 4285 :                 return;
; 4286 :             }
; 4287 :         }
; 4288 : #endif // !defined(_INSERT_STRING_ANNOTATION)
; 4289 : 
; 4290 :         if (_My_large && _Right_large) { // swap buffers, iterators preserved
; 4291 :             swap(_My_data._Bx._Ptr, _Right_data._Bx._Ptr); // intentional ADL
; 4292 :         } else if (_My_large) { // swap large with small
; 4293 :             _Swap_bx_large_with_small(_My_data, _Right_data);
; 4294 :         } else if (_Right_large) { // swap small with large
; 4295 :             _Swap_bx_large_with_small(_Right_data, _My_data);
; 4296 :         } else {
; 4297 :             _Elem _Temp_buf[_BUF_SIZE];
; 4298 :             _Traits::copy(_Temp_buf, _My_data._Bx._Buf, _My_data._Mysize + 1);
; 4299 :             _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);
; 4300 :             _Traits::copy(_Right_data._Bx._Buf, _Temp_buf, _My_data._Mysize + 1);
; 4301 :         }
; 4302 : 
; 4303 :         _STD swap(_My_data._Mysize, _Right_data._Mysize);
; 4304 :         _STD swap(_My_data._Myres, _Right_data._Myres);
; 4305 :     }

	ret	0
?_Swap_data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXAEAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?_Swap_bx_large_with_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXAEAV?$_String_val@U?$_Simple_types@D@std@@@2@0@Z
_TEXT	SEGMENT
_Starts_large$ = 8
_Starts_small$ = 16
?_Swap_bx_large_with_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXAEAV?$_String_val@U?$_Simple_types@D@std@@@2@0@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_bx_large_with_small, COMDAT

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [rdx]

; 4251 :         // exchange a string in large mode with one in small mode
; 4252 :         const pointer _Ptr = _Starts_large._Bx._Ptr;

	mov	rax, QWORD PTR [rcx]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	XMMWORD PTR [rcx], xmm0

; 4253 :         _Destroy_in_place(_Starts_large._Bx._Ptr);
; 4254 : 
; 4255 :         _Starts_large._Activate_SSO_buffer();
; 4256 :         _Traits::copy(_Starts_large._Bx._Buf, _Starts_small._Bx._Buf, _BUF_SIZE);
; 4257 : 
; 4258 :         _Construct_in_place(_Starts_small._Bx._Ptr, _Ptr);

	mov	QWORD PTR [rdx], rax

; 4259 :     }

	ret	0
?_Swap_bx_large_with_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXAEAV?$_String_val@U?$_Simple_types@D@std@@@2@0@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_bx_large_with_small
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0AEBVNode@BymlFile@@$$Z$$V@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBVNode@BymlFile@@@1@V?$tuple@$$V@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$dead$ = 56
_Val1$ = 64
$T1 = 72
_Val2$dead$ = 72
??$?0AEBVNode@BymlFile@@$$Z$$V@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBVNode@BymlFile@@@1@V?$tuple@$$V@1@@Z PROC ; std::pair<BymlFile::Node const ,unsigned int>::pair<BymlFile::Node const ,unsigned int><BymlFile::Node const &>, COMDAT

; 305  :         : pair(_Val1, _Val2, index_sequence_for<_Types1...>{}, index_sequence_for<_Types2...>{}) {}

$LN14:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+32], r9
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	QWORD PTR $T1[rsp], rcx
	mov	rbx, QWORD PTR [r8]
	mov	rdx, rbx
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	npad	1
	movzx	eax, BYTE PTR [rbx+24]
	mov	BYTE PTR [rdi+24], al
	lea	rcx, QWORD PTR [rdi+32]
	lea	rdx, QWORD PTR [rbx+32]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rdi+64]
	lea	rdx, QWORD PTR [rbx+64]
	call	??0?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@AEBV01@@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::vector<BymlFile::Node,std::allocator<BymlFile::Node> >
	npad	1
	mov	DWORD PTR [rdi+88], 0

; 305  :         : pair(_Val1, _Val2, index_sequence_for<_Types1...>{}, index_sequence_for<_Types2...>{}) {}

	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$?0AEBVNode@BymlFile@@$$Z$$V@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBVNode@BymlFile@@@1@V?$tuple@$$V@1@@Z ENDP ; std::pair<BymlFile::Node const ,unsigned int>::pair<BymlFile::Node const ,unsigned int><BymlFile::Node const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__formal$dead$ = 56
_Val1$ = 64
$T1 = 72
_Val2$dead$ = 72
?dtor$2@?0???$?0AEBVNode@BymlFile@@$$Z$$V@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBVNode@BymlFile@@@1@V?$tuple@$$V@1@@Z@4HA PROC ; `std::pair<BymlFile::Node const ,unsigned int>::pair<BymlFile::Node const ,unsigned int><BymlFile::Node const &>'::`1'::dtor$2
	mov	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$2@?0???$?0AEBVNode@BymlFile@@$$Z$$V@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBVNode@BymlFile@@@1@V?$tuple@$$V@1@@Z@4HA ENDP ; `std::pair<BymlFile::Node const ,unsigned int>::pair<BymlFile::Node const ,unsigned int><BymlFile::Node const &>'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__formal$dead$ = 56
_Val1$ = 64
$T1 = 72
_Val2$dead$ = 72
?dtor$3@?0???$?0AEBVNode@BymlFile@@$$Z$$V@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBVNode@BymlFile@@@1@V?$tuple@$$V@1@@Z@4HA PROC ; `std::pair<BymlFile::Node const ,unsigned int>::pair<BymlFile::Node const ,unsigned int><BymlFile::Node const &>'::`1'::dtor$3
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 32					; 00000020H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0???$?0AEBVNode@BymlFile@@$$Z$$V@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBVNode@BymlFile@@@1@V?$tuple@$$V@1@@Z@4HA ENDP ; `std::pair<BymlFile::Node const ,unsigned int>::pair<BymlFile::Node const ,unsigned int><BymlFile::Node const &>'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0AEBV?$vector@EV?$allocator@E@std@@@std@@$$Z$$V@?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@V?$tuple@$$V@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$dead$ = 56
_Val1$ = 64
_Val2$dead$ = 72
??$?0AEBV?$vector@EV?$allocator@E@std@@@std@@$$Z$$V@?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@V?$tuple@$$V@1@@Z PROC ; std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int><std::vector<unsigned char,std::allocator<unsigned char> > const &>, COMDAT

; 305  :         : pair(_Val1, _Val2, index_sequence_for<_Types1...>{}, index_sequence_for<_Types2...>{}) {}

$LN9:
	push	rbx
	sub	rsp, 32					; 00000020H

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	rdx, QWORD PTR [r8]

; 305  :         : pair(_Val1, _Val2, index_sequence_for<_Types1...>{}, index_sequence_for<_Types2...>{}) {}

	mov	rbx, rcx

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >

; 305  :         : pair(_Val1, _Val2, index_sequence_for<_Types1...>{}, index_sequence_for<_Types2...>{}) {}

	mov	rax, rbx

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	DWORD PTR [rbx+24], 0

; 305  :         : pair(_Val1, _Val2, index_sequence_for<_Types1...>{}, index_sequence_for<_Types2...>{}) {}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$?0AEBV?$vector@EV?$allocator@E@std@@@std@@$$Z$$V@?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@V?$tuple@$$V@1@@Z ENDP ; std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int><std::vector<unsigned char,std::allocator<unsigned char> > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\compare
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Push_heap_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
_TEXT	SEGMENT
$T1 = 32
_First$GSCopy$1$ = 64
$T2 = 72
_Top$1$ = 104
$T3 = 112
_First$ = 192
_Hole$ = 200
_Top$ = 208
_Val$ = 216
_Pred$dead$ = 224
??$_Push_heap_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z PROC ; std::_Push_heap_by_index<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,`BymlFile::ToBinary'::`2'::<lambda_1> >, COMDAT

; 6324 :     _RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Top, _Ty&& _Val, _Pr _Pred) {

	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	mov	rbp, rsp
	sub	rsp, 128				; 00000080H
	mov	r13, r9
	mov	QWORD PTR _Top$1$[rbp-128], r8
	mov	rdi, rdx
	mov	r12, rcx
	mov	QWORD PTR _First$GSCopy$1$[rbp-128], rcx

; 6325 :     // percolate _Hole to _Top or where _Val belongs
; 6326 :     using _Diff = _Iter_diff_t<_RanIt>;
; 6327 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

	lea	r15, QWORD PTR [rdx-1]
	sar	r15, 1

; 6328 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	cmp	r8, rdx
	jge	$LN3@Push_heap_
	xor	edx, edx
$LN194@Push_heap_:
	mov	r9, -1
	lea	r8d, QWORD PTR [r9+23]
	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	lea	rax, QWORD PTR $T1[rbp-128]
	mov	QWORD PTR $T3[rbp-128], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T1[rbp-128], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T1[rbp-112], rdx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T1[rbp-104], rdx

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rsi, QWORD PTR [r13+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r14, r13

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [r13+24], 16
	jb	SHORT $LN19@Push_heap_

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r14, QWORD PTR [r13]
$LN19@Push_heap_:

; 2620 :         if (_Count > max_size()) {

	cmp	rsi, rcx
	ja	$LN153@Push_heap_

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T1[rbp-104], 15
	cmp	rsi, 16
	jae	SHORT $LN25@Push_heap_

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T1[rbp-112], rsi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR $T1[rbp-128], xmm0

; 2647 :             return;

	jmp	SHORT $LN41@Push_heap_
$LN25@Push_heap_:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rbx, rsi
	or	rbx, 15
	cmp	rbx, rcx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN36@Push_heap_

; 4716 :             return _Max;

	mov	rbx, rcx
	jmp	SHORT $LN35@Push_heap_
$LN36@Push_heap_:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rbx, 22
	cmovb	rbx, r8
$LN35@Push_heap_:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rbx
	add	rdx, 1
	cmovb	rdx, r9
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T1[rbp-128], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T1[rbp-112], rsi

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T1[rbp-104], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rsi+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14
	mov	rcx, rax
	call	memcpy
	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	mov	r8d, 22
	lea	r9, QWORD PTR [r8-23]
$LN41@Push_heap_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6328 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	mov	rsi, r15
	shl	rsi, 5
	add	rsi, r12
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T2[rbp-128], xmm0

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r14, QWORD PTR [rsi+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r12, rsi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rsi+24], 16
	jb	SHORT $LN60@Push_heap_

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r12, QWORD PTR [rsi]
$LN60@Push_heap_:

; 2620 :         if (_Count > max_size()) {

	cmp	r14, rcx
	ja	$LN154@Push_heap_

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	cmp	r14, 16
	jae	SHORT $LN66@Push_heap_

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T2[rbp-112], r14

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T2[rbp-104], 15

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r12]
	movups	XMMWORD PTR $T2[rbp-128], xmm0

; 2647 :             return;

	jmp	SHORT $LN82@Push_heap_
$LN66@Push_heap_:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rbx, r14
	or	rbx, 15
	cmp	rbx, rcx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN77@Push_heap_

; 4716 :             return _Max;

	mov	rbx, rcx
	jmp	SHORT $LN76@Push_heap_
$LN77@Push_heap_:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rbx, 22
	cmovb	rbx, r8
$LN76@Push_heap_:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rbx
	add	rdx, 1
	cmovb	rdx, r9
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T2[rbp-128], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T2[rbp-112], r14

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T2[rbp-104], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [r14+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r12
	mov	rcx, rax
	call	memcpy
	npad	1
$LN82@Push_heap_:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 535  :     std::sort(this->m_HashKeyTable.begin(), this->m_HashKeyTable.end(), [](std::string A, std::string B) { return A < B; });

	lea	rdx, QWORD PTR $T1[rbp-128]
	lea	rcx, QWORD PTR $T2[rbp-128]
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
	movzx	ebx, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T2[rbp-128]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR $T1[rbp-128]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6328 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	mov	r12, QWORD PTR _First$GSCopy$1$[rbp-128]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\compare

; 197  :         return _Val._Value < 0;

	test	bl, bl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6328 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	jns	$LN3@Push_heap_

; 6330 :         // move _Hole up to parent
; 6331 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	shl	rdi, 5
	add	rdi, r12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2961 :         if (this == _STD addressof(_Right)) {

	cmp	rdi, rsi
	je	SHORT $LN192@Push_heap_

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 16

; 4832 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN111@Push_heap_

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN123@Push_heap_

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN120@Push_heap_

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN123@Push_heap_:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN111@Push_heap_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	xor	edx, edx
	mov	QWORD PTR [rdi+16], rdx

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdi+24], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], dl

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rsi]
	movups	XMMWORD PTR [rdi], xmm0
	movups	xmm1, XMMWORD PTR [rsi+16]
	movups	XMMWORD PTR [rdi+16], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rsi+16], rdx

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rsi+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rsi], dl

; 2961 :         if (this == _STD addressof(_Right)) {

	jmp	SHORT $LN189@Push_heap_
$LN192@Push_heap_:
	xor	edx, edx
$LN189@Push_heap_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6332 :         _Hole             = _Idx;

	mov	rdi, r15

; 6329 :          _Idx = (_Hole - 1) >> 1) { // shift for codegen

	dec	r15
	sar	r15, 1

; 6328 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	cmp	QWORD PTR _Top$1$[rbp-128], rdi
	jl	$LN194@Push_heap_
$LN3@Push_heap_:

; 6333 :     }
; 6334 : 
; 6335 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	shl	rdi, 5
	lea	rcx, QWORD PTR [r12+rdi]
	mov	rdx, r13

; 6336 : }

	mov	rbx, QWORD PTR [rsp+208]
	add	rsp, 128				; 00000080H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp

; 6333 :     }
; 6334 : 
; 6335 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	jmp	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
$LN120@Push_heap_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN154@Push_heap_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN153@Push_heap_:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN193@Push_heap_:
??$_Push_heap_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ENDP ; std::_Push_heap_by_index<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,`BymlFile::ToBinary'::`2'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_First$GSCopy$1$ = 64
$T2 = 72
_Top$1$ = 104
$T3 = 112
_First$ = 192
_Hole$ = 200
_Top$ = 208
_Val$ = 216
_Pred$dead$ = 224
?dtor$0@?0???$_Push_heap_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA PROC ; `std::_Push_heap_by_index<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,`BymlFile::ToBinary'::`2'::<lambda_1> >'::`1'::dtor$0
	mov	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$_Push_heap_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA ENDP ; `std::_Push_heap_by_index<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,`BymlFile::ToBinary'::`2'::<lambda_1> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Pop_heap_hole_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00$$QEAV10@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Val$ = 88
_Pred$ = 96
??$_Pop_heap_hole_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00$$QEAV10@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z PROC ; std::_Pop_heap_hole_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,`BymlFile::ToBinary'::`2'::<lambda_1> >, COMDAT

; 6461 : _CONSTEXPR20 void _Pop_heap_hole_unchecked(_RanIt _First, _RanIt _Last, _RanIt _Dest, _Ty&& _Val, _Pr _Pred) {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, rdx
	mov	rsi, rcx

; 6462 :     // pop *_First to *_Dest and reheap
; 6463 :     // precondition: _First != _Last
; 6464 :     // precondition: _First != _Dest
; 6465 :     *_Dest      = _STD move(*_First);

	mov	rdx, rcx
	mov	rdi, r9
	mov	rcx, r8
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 6466 :     using _Diff = _Iter_diff_t<_RanIt>;
; 6467 :     _STD _Pop_heap_hole_by_index(

	movzx	eax, BYTE PTR _Pred$[rsp]
	sub	rbx, rsi
	sar	rbx, 5
	mov	r9, rdi
	mov	r8, rbx
	mov	BYTE PTR _Pred$[rsp], al
	xor	edx, edx
	mov	rcx, rsi

; 6468 :         _First, static_cast<_Diff>(0), static_cast<_Diff>(_Last - _First), _STD forward<_Ty>(_Val), _Pred);
; 6469 : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi

; 6466 :     using _Diff = _Iter_diff_t<_RanIt>;
; 6467 :     _STD _Pop_heap_hole_by_index(

	jmp	??$_Pop_heap_hole_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ; std::_Pop_heap_hole_by_index<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,`BymlFile::ToBinary'::`2'::<lambda_1> >
??$_Pop_heap_hole_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00$$QEAV10@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ENDP ; std::_Pop_heap_hole_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,`BymlFile::ToBinary'::`2'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\compare
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 48
$T5 = 48
$T6 = 48
$T7 = 80
$T8 = 80
$T9 = 80
_First$ = 160
_Mid$ = 168
_Last$ = 176
_Pred$dead$ = 184
??$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z PROC ; std::_Med3_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >, COMDAT

; 7929 : _CONSTEXPR20 void _Med3_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {

	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 112				; 00000070H
	mov	r15, r8
	mov	rbp, rdx
	mov	r14, rcx

; 7931 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	lea	rax, QWORD PTR $T6[rsp]
	mov	QWORD PTR $T1[rsp], rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rsi, rax
	mov	rdx, rbp
	lea	rcx, QWORD PTR $T9[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 535  :     std::sort(this->m_HashKeyTable.begin(), this->m_HashKeyTable.end(), [](std::string A, std::string B) { return A < B; });

	mov	rdx, rsi
	mov	rcx, rax
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
	movzx	ebx, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rdi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	mov	rcx, rsi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7931 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	test	bl, bl
	jns	SHORT $LN79@Med3_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4308 :         if (this != _STD addressof(_Right)) {

	cmp	rbp, r14
	je	SHORT $LN79@Med3_unche

; 4281 :                 _CSTD memcpy(_Temp_mem, _My_data_mem, _Memcpy_val_size);

	movups	xmm2, XMMWORD PTR [rbp]
	movups	xmm3, XMMWORD PTR [rbp+16]

; 4282 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR [rbp], xmm0
	movups	xmm1, XMMWORD PTR [r14+16]
	movups	XMMWORD PTR [rbp+16], xmm1

; 4283 :                 _CSTD memcpy(_Right_data_mem, _Temp_mem, _Memcpy_val_size);

	movups	XMMWORD PTR [r14], xmm2
	movups	XMMWORD PTR [r14+16], xmm3
$LN79@Med3_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7935 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

	lea	rax, QWORD PTR $T8[rsp]
	mov	QWORD PTR $T3[rsp], rax
	mov	rdx, rbp
	lea	rcx, QWORD PTR $T8[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rsi, rax
	mov	rdx, r15
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 535  :     std::sort(this->m_HashKeyTable.begin(), this->m_HashKeyTable.end(), [](std::string A, std::string B) { return A < B; });

	mov	rdx, rsi
	mov	rcx, rax
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
	movzx	ebx, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rdi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	mov	rcx, rsi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7935 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

	test	bl, bl
	jns	$LN215@Med3_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4308 :         if (this != _STD addressof(_Right)) {

	cmp	r15, rbp
	je	SHORT $LN147@Med3_unche

; 4281 :                 _CSTD memcpy(_Temp_mem, _My_data_mem, _Memcpy_val_size);

	movups	xmm2, XMMWORD PTR [r15]
	movups	xmm3, XMMWORD PTR [r15+16]

; 4282 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rbp]
	movups	XMMWORD PTR [r15], xmm0
	movups	xmm1, XMMWORD PTR [rbp+16]
	movups	XMMWORD PTR [r15+16], xmm1

; 4283 :                 _CSTD memcpy(_Right_data_mem, _Temp_mem, _Memcpy_val_size);

	movups	XMMWORD PTR [rbp], xmm2
	movups	XMMWORD PTR [rbp+16], xmm3
$LN147@Med3_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7938 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	lea	rax, QWORD PTR $T7[rsp]
	mov	QWORD PTR $T2[rsp], rax
	mov	rdx, r14
	lea	rcx, QWORD PTR $T7[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rsi, rax
	mov	rdx, rbp
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 535  :     std::sort(this->m_HashKeyTable.begin(), this->m_HashKeyTable.end(), [](std::string A, std::string B) { return A < B; });

	mov	rdx, rsi
	mov	rcx, rax
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
	movzx	ebx, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rdi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	mov	rcx, rsi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\compare

; 197  :         return _Val._Value < 0;

	test	bl, bl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7938 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	jns	SHORT $LN215@Med3_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4308 :         if (this != _STD addressof(_Right)) {

	cmp	rbp, r14
	je	SHORT $LN215@Med3_unche

; 4281 :                 _CSTD memcpy(_Temp_mem, _My_data_mem, _Memcpy_val_size);

	movups	xmm2, XMMWORD PTR [rbp]
	movups	xmm3, XMMWORD PTR [rbp+16]

; 4282 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR [rbp], xmm0
	movups	xmm1, XMMWORD PTR [r14+16]
	movups	XMMWORD PTR [rbp+16], xmm1

; 4283 :                 _CSTD memcpy(_Right_data_mem, _Temp_mem, _Memcpy_val_size);

	movups	XMMWORD PTR [r14], xmm2
	movups	XMMWORD PTR [r14+16], xmm3
$LN215@Med3_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7942 : }

	mov	rbx, QWORD PTR [rsp+184]
	add	rsp, 112				; 00000070H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
??$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ENDP ; std::_Med3_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 48
$T5 = 48
$T6 = 48
$T7 = 80
$T8 = 80
$T9 = 80
_First$ = 160
_Mid$ = 168
_Last$ = 176
_Pred$dead$ = 184
?dtor$0@?0???$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA PROC ; `std::_Med3_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >'::`1'::dtor$0
	mov	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA ENDP ; `std::_Med3_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 48
$T5 = 48
$T6 = 48
$T7 = 80
$T8 = 80
$T9 = 80
_First$ = 160
_Mid$ = 168
_Last$ = 176
_Pred$dead$ = 184
?dtor$2@?0???$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA PROC ; `std::_Med3_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >'::`1'::dtor$2
	mov	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0???$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA ENDP ; `std::_Med3_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 48
$T5 = 48
$T6 = 48
$T7 = 80
$T8 = 80
$T9 = 80
_First$ = 160
_Mid$ = 168
_Last$ = 176
_Pred$dead$ = 184
?dtor$4@?0???$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA PROC ; `std::_Med3_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >'::`1'::dtor$4
	mov	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0???$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_1>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA ENDP ; `std::_Med3_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_1> >'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAEAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAPEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAEAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAPEAV10@@Z PROC ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAEAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAPEAV10@@Z ENDP ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\compare
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Push_heap_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
_TEXT	SEGMENT
$T1 = 32
_First$GSCopy$1$ = 64
$T2 = 72
_Top$1$ = 104
$T3 = 112
_First$ = 192
_Hole$ = 200
_Top$ = 208
_Val$ = 216
_Pred$dead$ = 224
??$_Push_heap_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z PROC ; std::_Push_heap_by_index<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,`BymlFile::ToBinary'::`2'::<lambda_2> >, COMDAT

; 6324 :     _RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Top, _Ty&& _Val, _Pr _Pred) {

	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	mov	rbp, rsp
	sub	rsp, 128				; 00000080H
	mov	r13, r9
	mov	QWORD PTR _Top$1$[rbp-128], r8
	mov	rdi, rdx
	mov	r12, rcx
	mov	QWORD PTR _First$GSCopy$1$[rbp-128], rcx

; 6325 :     // percolate _Hole to _Top or where _Val belongs
; 6326 :     using _Diff = _Iter_diff_t<_RanIt>;
; 6327 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

	lea	r15, QWORD PTR [rdx-1]
	sar	r15, 1

; 6328 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	cmp	r8, rdx
	jge	$LN3@Push_heap_
	xor	edx, edx
$LN194@Push_heap_:
	mov	r9, -1
	lea	r8d, QWORD PTR [r9+23]
	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	lea	rax, QWORD PTR $T1[rbp-128]
	mov	QWORD PTR $T3[rbp-128], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T1[rbp-128], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T1[rbp-112], rdx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T1[rbp-104], rdx

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rsi, QWORD PTR [r13+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r14, r13

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [r13+24], 16
	jb	SHORT $LN19@Push_heap_

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r14, QWORD PTR [r13]
$LN19@Push_heap_:

; 2620 :         if (_Count > max_size()) {

	cmp	rsi, rcx
	ja	$LN153@Push_heap_

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T1[rbp-104], 15
	cmp	rsi, 16
	jae	SHORT $LN25@Push_heap_

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T1[rbp-112], rsi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR $T1[rbp-128], xmm0

; 2647 :             return;

	jmp	SHORT $LN41@Push_heap_
$LN25@Push_heap_:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rbx, rsi
	or	rbx, 15
	cmp	rbx, rcx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN36@Push_heap_

; 4716 :             return _Max;

	mov	rbx, rcx
	jmp	SHORT $LN35@Push_heap_
$LN36@Push_heap_:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rbx, 22
	cmovb	rbx, r8
$LN35@Push_heap_:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rbx
	add	rdx, 1
	cmovb	rdx, r9
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T1[rbp-128], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T1[rbp-112], rsi

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T1[rbp-104], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rsi+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14
	mov	rcx, rax
	call	memcpy
	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	mov	r8d, 22
	lea	r9, QWORD PTR [r8-23]
$LN41@Push_heap_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6328 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	mov	rsi, r15
	shl	rsi, 5
	add	rsi, r12
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T2[rbp-128], xmm0

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r14, QWORD PTR [rsi+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r12, rsi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rsi+24], 16
	jb	SHORT $LN60@Push_heap_

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r12, QWORD PTR [rsi]
$LN60@Push_heap_:

; 2620 :         if (_Count > max_size()) {

	cmp	r14, rcx
	ja	$LN154@Push_heap_

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	cmp	r14, 16
	jae	SHORT $LN66@Push_heap_

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T2[rbp-112], r14

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T2[rbp-104], 15

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r12]
	movups	XMMWORD PTR $T2[rbp-128], xmm0

; 2647 :             return;

	jmp	SHORT $LN82@Push_heap_
$LN66@Push_heap_:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rbx, r14
	or	rbx, 15
	cmp	rbx, rcx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN77@Push_heap_

; 4716 :             return _Max;

	mov	rbx, rcx
	jmp	SHORT $LN76@Push_heap_
$LN77@Push_heap_:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rbx, 22
	cmovb	rbx, r8
$LN76@Push_heap_:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rbx
	add	rdx, 1
	cmovb	rdx, r9
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T2[rbp-128], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T2[rbp-112], r14

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T2[rbp-104], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [r14+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r12
	mov	rcx, rax
	call	memcpy
	npad	1
$LN82@Push_heap_:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 536  :     std::sort(this->m_StringTable.begin(), this->m_StringTable.end(), [](std::string A, std::string B) { return A < B; });

	lea	rdx, QWORD PTR $T1[rbp-128]
	lea	rcx, QWORD PTR $T2[rbp-128]
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
	movzx	ebx, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T2[rbp-128]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR $T1[rbp-128]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6328 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	mov	r12, QWORD PTR _First$GSCopy$1$[rbp-128]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\compare

; 197  :         return _Val._Value < 0;

	test	bl, bl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6328 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	jns	$LN3@Push_heap_

; 6330 :         // move _Hole up to parent
; 6331 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	shl	rdi, 5
	add	rdi, r12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2961 :         if (this == _STD addressof(_Right)) {

	cmp	rdi, rsi
	je	SHORT $LN192@Push_heap_

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 16

; 4832 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN111@Push_heap_

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN123@Push_heap_

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN120@Push_heap_

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN123@Push_heap_:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN111@Push_heap_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	xor	edx, edx
	mov	QWORD PTR [rdi+16], rdx

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdi+24], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], dl

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rsi]
	movups	XMMWORD PTR [rdi], xmm0
	movups	xmm1, XMMWORD PTR [rsi+16]
	movups	XMMWORD PTR [rdi+16], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rsi+16], rdx

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rsi+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rsi], dl

; 2961 :         if (this == _STD addressof(_Right)) {

	jmp	SHORT $LN189@Push_heap_
$LN192@Push_heap_:
	xor	edx, edx
$LN189@Push_heap_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6332 :         _Hole             = _Idx;

	mov	rdi, r15

; 6329 :          _Idx = (_Hole - 1) >> 1) { // shift for codegen

	dec	r15
	sar	r15, 1

; 6328 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	cmp	QWORD PTR _Top$1$[rbp-128], rdi
	jl	$LN194@Push_heap_
$LN3@Push_heap_:

; 6333 :     }
; 6334 : 
; 6335 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	shl	rdi, 5
	lea	rcx, QWORD PTR [r12+rdi]
	mov	rdx, r13

; 6336 : }

	mov	rbx, QWORD PTR [rsp+208]
	add	rsp, 128				; 00000080H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp

; 6333 :     }
; 6334 : 
; 6335 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	jmp	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
$LN120@Push_heap_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN154@Push_heap_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN153@Push_heap_:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN193@Push_heap_:
??$_Push_heap_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ENDP ; std::_Push_heap_by_index<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,`BymlFile::ToBinary'::`2'::<lambda_2> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_First$GSCopy$1$ = 64
$T2 = 72
_Top$1$ = 104
$T3 = 112
_First$ = 192
_Hole$ = 200
_Top$ = 208
_Val$ = 216
_Pred$dead$ = 224
?dtor$0@?0???$_Push_heap_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA PROC ; `std::_Push_heap_by_index<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,`BymlFile::ToBinary'::`2'::<lambda_2> >'::`1'::dtor$0
	mov	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$_Push_heap_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA ENDP ; `std::_Push_heap_by_index<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,`BymlFile::ToBinary'::`2'::<lambda_2> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Pop_heap_hole_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00$$QEAV10@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Val$ = 88
_Pred$ = 96
??$_Pop_heap_hole_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00$$QEAV10@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z PROC ; std::_Pop_heap_hole_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,`BymlFile::ToBinary'::`2'::<lambda_2> >, COMDAT

; 6461 : _CONSTEXPR20 void _Pop_heap_hole_unchecked(_RanIt _First, _RanIt _Last, _RanIt _Dest, _Ty&& _Val, _Pr _Pred) {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, rdx
	mov	rsi, rcx

; 6462 :     // pop *_First to *_Dest and reheap
; 6463 :     // precondition: _First != _Last
; 6464 :     // precondition: _First != _Dest
; 6465 :     *_Dest      = _STD move(*_First);

	mov	rdx, rcx
	mov	rdi, r9
	mov	rcx, r8
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 6466 :     using _Diff = _Iter_diff_t<_RanIt>;
; 6467 :     _STD _Pop_heap_hole_by_index(

	movzx	eax, BYTE PTR _Pred$[rsp]
	sub	rbx, rsi
	sar	rbx, 5
	mov	r9, rdi
	mov	r8, rbx
	mov	BYTE PTR _Pred$[rsp], al
	xor	edx, edx
	mov	rcx, rsi

; 6468 :         _First, static_cast<_Diff>(0), static_cast<_Diff>(_Last - _First), _STD forward<_Ty>(_Val), _Pred);
; 6469 : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi

; 6466 :     using _Diff = _Iter_diff_t<_RanIt>;
; 6467 :     _STD _Pop_heap_hole_by_index(

	jmp	??$_Pop_heap_hole_by_index@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J1$$QEAV10@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ; std::_Pop_heap_hole_by_index<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,`BymlFile::ToBinary'::`2'::<lambda_2> >
??$_Pop_heap_hole_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00$$QEAV10@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ENDP ; std::_Pop_heap_hole_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,`BymlFile::ToBinary'::`2'::<lambda_2> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\compare
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 48
$T5 = 48
$T6 = 48
$T7 = 80
$T8 = 80
$T9 = 80
_First$ = 160
_Mid$ = 168
_Last$ = 176
_Pred$dead$ = 184
??$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z PROC ; std::_Med3_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >, COMDAT

; 7929 : _CONSTEXPR20 void _Med3_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {

	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 112				; 00000070H
	mov	r15, r8
	mov	rbp, rdx
	mov	r14, rcx

; 7931 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	lea	rax, QWORD PTR $T6[rsp]
	mov	QWORD PTR $T1[rsp], rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rsi, rax
	mov	rdx, rbp
	lea	rcx, QWORD PTR $T9[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 536  :     std::sort(this->m_StringTable.begin(), this->m_StringTable.end(), [](std::string A, std::string B) { return A < B; });

	mov	rdx, rsi
	mov	rcx, rax
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
	movzx	ebx, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rdi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	mov	rcx, rsi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7931 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	test	bl, bl
	jns	SHORT $LN79@Med3_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4308 :         if (this != _STD addressof(_Right)) {

	cmp	rbp, r14
	je	SHORT $LN79@Med3_unche

; 4281 :                 _CSTD memcpy(_Temp_mem, _My_data_mem, _Memcpy_val_size);

	movups	xmm2, XMMWORD PTR [rbp]
	movups	xmm3, XMMWORD PTR [rbp+16]

; 4282 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR [rbp], xmm0
	movups	xmm1, XMMWORD PTR [r14+16]
	movups	XMMWORD PTR [rbp+16], xmm1

; 4283 :                 _CSTD memcpy(_Right_data_mem, _Temp_mem, _Memcpy_val_size);

	movups	XMMWORD PTR [r14], xmm2
	movups	XMMWORD PTR [r14+16], xmm3
$LN79@Med3_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7935 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

	lea	rax, QWORD PTR $T8[rsp]
	mov	QWORD PTR $T3[rsp], rax
	mov	rdx, rbp
	lea	rcx, QWORD PTR $T8[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rsi, rax
	mov	rdx, r15
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 536  :     std::sort(this->m_StringTable.begin(), this->m_StringTable.end(), [](std::string A, std::string B) { return A < B; });

	mov	rdx, rsi
	mov	rcx, rax
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
	movzx	ebx, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rdi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	mov	rcx, rsi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7935 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

	test	bl, bl
	jns	$LN215@Med3_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4308 :         if (this != _STD addressof(_Right)) {

	cmp	r15, rbp
	je	SHORT $LN147@Med3_unche

; 4281 :                 _CSTD memcpy(_Temp_mem, _My_data_mem, _Memcpy_val_size);

	movups	xmm2, XMMWORD PTR [r15]
	movups	xmm3, XMMWORD PTR [r15+16]

; 4282 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rbp]
	movups	XMMWORD PTR [r15], xmm0
	movups	xmm1, XMMWORD PTR [rbp+16]
	movups	XMMWORD PTR [r15+16], xmm1

; 4283 :                 _CSTD memcpy(_Right_data_mem, _Temp_mem, _Memcpy_val_size);

	movups	XMMWORD PTR [rbp], xmm2
	movups	XMMWORD PTR [rbp+16], xmm3
$LN147@Med3_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7938 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	lea	rax, QWORD PTR $T7[rsp]
	mov	QWORD PTR $T2[rsp], rax
	mov	rdx, r14
	lea	rcx, QWORD PTR $T7[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rsi, rax
	mov	rdx, rbp
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.cpp

; 536  :     std::sort(this->m_StringTable.begin(), this->m_StringTable.end(), [](std::string A, std::string B) { return A < B; });

	mov	rdx, rsi
	mov	rcx, rax
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
	movzx	ebx, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rdi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	mov	rcx, rsi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\compare

; 197  :         return _Val._Value < 0;

	test	bl, bl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7938 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	jns	SHORT $LN215@Med3_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4308 :         if (this != _STD addressof(_Right)) {

	cmp	rbp, r14
	je	SHORT $LN215@Med3_unche

; 4281 :                 _CSTD memcpy(_Temp_mem, _My_data_mem, _Memcpy_val_size);

	movups	xmm2, XMMWORD PTR [rbp]
	movups	xmm3, XMMWORD PTR [rbp+16]

; 4282 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR [rbp], xmm0
	movups	xmm1, XMMWORD PTR [r14+16]
	movups	XMMWORD PTR [rbp+16], xmm1

; 4283 :                 _CSTD memcpy(_Right_data_mem, _Temp_mem, _Memcpy_val_size);

	movups	XMMWORD PTR [r14], xmm2
	movups	XMMWORD PTR [r14+16], xmm3
$LN215@Med3_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7942 : }

	mov	rbx, QWORD PTR [rsp+184]
	add	rsp, 112				; 00000070H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
??$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z ENDP ; std::_Med3_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 48
$T5 = 48
$T6 = 48
$T7 = 80
$T8 = 80
$T9 = 80
_First$ = 160
_Mid$ = 168
_Last$ = 176
_Pred$dead$ = 184
?dtor$0@?0???$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA PROC ; `std::_Med3_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >'::`1'::dtor$0
	mov	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA ENDP ; `std::_Med3_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 48
$T5 = 48
$T6 = 48
$T7 = 80
$T8 = 80
$T9 = 80
_First$ = 160
_Mid$ = 168
_Last$ = 176
_Pred$dead$ = 184
?dtor$2@?0???$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA PROC ; `std::_Med3_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >'::`1'::dtor$2
	mov	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0???$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA ENDP ; `std::_Med3_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 48
$T5 = 48
$T6 = 48
$T7 = 80
$T8 = 80
$T9 = 80
_First$ = 160
_Mid$ = 168
_Last$ = 176
_Pred$dead$ = 184
?dtor$4@?0???$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA PROC ; `std::_Med3_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >'::`1'::dtor$4
	mov	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0???$_Med3_unchecked@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@W4TableGeneration@5@@Z@@std@@YAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@00V<lambda_2>@?1??ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@W4TableGeneration@4@@Z@@Z@4HA ENDP ; `std::_Med3_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,`BymlFile::ToBinary'::`2'::<lambda_2> >'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple
;	COMDAT ??$?0AEBVNode@BymlFile@@@?$_Tuple_val@AEBVNode@BymlFile@@@std@@QEAA@AEBVNode@BymlFile@@@Z
_TEXT	SEGMENT
this$ = 8
_Arg$ = 16
??$?0AEBVNode@BymlFile@@@?$_Tuple_val@AEBVNode@BymlFile@@@std@@QEAA@AEBVNode@BymlFile@@@Z PROC ; std::_Tuple_val<BymlFile::Node const &>::_Tuple_val<BymlFile::Node const &><BymlFile::Node const &>, COMDAT

; 144  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??$?0AEBVNode@BymlFile@@@?$_Tuple_val@AEBVNode@BymlFile@@@std@@QEAA@AEBVNode@BymlFile@@@Z ENDP ; std::_Tuple_val<BymlFile::Node const &>::_Tuple_val<BymlFile::Node const &><BymlFile::Node const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple
;	COMDAT ??$?0AEBV?$vector@EV?$allocator@E@std@@@std@@@?$_Tuple_val@AEBV?$vector@EV?$allocator@E@std@@@std@@@std@@QEAA@AEBV?$vector@EV?$allocator@E@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Arg$ = 16
??$?0AEBV?$vector@EV?$allocator@E@std@@@std@@@?$_Tuple_val@AEBV?$vector@EV?$allocator@E@std@@@std@@@std@@QEAA@AEBV?$vector@EV?$allocator@E@std@@@1@@Z PROC ; std::_Tuple_val<std::vector<unsigned char,std::allocator<unsigned char> > const &>::_Tuple_val<std::vector<unsigned char,std::allocator<unsigned char> > const &><std::vector<unsigned char,std::allocator<unsigned char> > const &>, COMDAT

; 144  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??$?0AEBV?$vector@EV?$allocator@E@std@@@std@@@?$_Tuple_val@AEBV?$vector@EV?$allocator@E@std@@@std@@@std@@QEAA@AEBV?$vector@EV?$allocator@E@std@@@1@@Z ENDP ; std::_Tuple_val<std::vector<unsigned char,std::allocator<unsigned char> > const &>::_Tuple_val<std::vector<unsigned char,std::allocator<unsigned char> > const &><std::vector<unsigned char,std::allocator<unsigned char> > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V$0A@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@@Z
_TEXT	SEGMENT
_Location$ = 8
??$construct_at@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V$0A@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@@Z PROC ; std::construct_at<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,0>, COMDAT

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

	xorps	xmm0, xmm0

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], 0

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 242  : }

	ret	0
??$construct_at@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V$0A@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@@Z ENDP ; std::construct_at<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@VNode@BymlFile@@$$V$0A@@std@@YAPEAVNode@BymlFile@@QEAV12@@Z
_TEXT	SEGMENT
_Location$ = 8
??$construct_at@VNode@BymlFile@@$$V$0A@@std@@YAPEAVNode@BymlFile@@QEAV12@@Z PROC ; std::construct_at<BymlFile::Node,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	xorps	xmm0, xmm0
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx+32], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+48], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+56], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx+32], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+64], rax
	mov	QWORD PTR [rcx+72], rax
	mov	QWORD PTR [rcx+80], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@VNode@BymlFile@@$$V$0A@@std@@YAPEAVNode@BymlFile@@QEAV12@@Z ENDP ; std::construct_at<BymlFile::Node,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Pocs@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z
_TEXT	SEGMENT
_Left$dead$ = 8
_Right$dead$ = 16
??$_Pocs@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z PROC ; std::_Pocs<std::allocator<char> >, COMDAT

; 1074 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_swap::value) {
; 1075 :         swap(_Left, _Right); // intentional ADL
; 1076 :     } else {
; 1077 :         _STL_ASSERT(_Left == _Right, "containers incompatible for swap");
; 1078 :     }
; 1079 : }

	ret	0
??$_Pocs@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z ENDP ; std::_Pocs<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$swap@PEAD$0A@@std@@YAXAEAPEAD0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$swap@PEAD$0A@@std@@YAXAEAPEAD0@Z PROC		; std::swap<char *,0>, COMDAT

; 99   :     _Ty _Tmp = _STD move(_Left);
; 100  :     _Left    = _STD move(_Right);

	mov	rax, QWORD PTR [rdx]
	mov	r8, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rax

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [rdx], r8

; 102  : }

	ret	0
??$swap@PEAD$0A@@std@@YAXAEAPEAD0@Z ENDP		; std::swap<char *,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0V?$tuple@AEBVNode@BymlFile@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@AEAV?$tuple@AEBVNode@BymlFile@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z
_TEXT	SEGMENT
this$ = 48
_Val1$ = 56
$T1 = 64
_Val2$dead$ = 64
__formal$dead$ = 72
__formal$dead$ = 80
??$?0V?$tuple@AEBVNode@BymlFile@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@AEAV?$tuple@AEBVNode@BymlFile@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z PROC ; std::pair<BymlFile::Node const ,unsigned int>::pair<BymlFile::Node const ,unsigned int><std::tuple<BymlFile::Node const &>,std::tuple<>,0>, COMDAT

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

$LN11:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], r8
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx
	mov	QWORD PTR $T1[rsp], rcx
	mov	rbx, QWORD PTR [rdx]
	mov	rdx, rbx
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	npad	1
	movzx	eax, BYTE PTR [rbx+24]
	mov	BYTE PTR [rdi+24], al
	lea	rcx, QWORD PTR [rdi+32]
	lea	rdx, QWORD PTR [rbx+32]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rdi+64]
	lea	rdx, QWORD PTR [rbx+64]
	call	??0?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@AEBV01@@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::vector<BymlFile::Node,std::allocator<BymlFile::Node> >
	npad	1
	mov	DWORD PTR [rdi+88], 0
	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$?0V?$tuple@AEBVNode@BymlFile@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@AEAV?$tuple@AEBVNode@BymlFile@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z ENDP ; std::pair<BymlFile::Node const ,unsigned int>::pair<BymlFile::Node const ,unsigned int><std::tuple<BymlFile::Node const &>,std::tuple<>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Val1$ = 56
$T1 = 64
_Val2$dead$ = 64
__formal$dead$ = 72
__formal$dead$ = 80
?dtor$1@?0???$?0V?$tuple@AEBVNode@BymlFile@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@AEAV?$tuple@AEBVNode@BymlFile@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z@4HA PROC ; `std::pair<BymlFile::Node const ,unsigned int>::pair<BymlFile::Node const ,unsigned int><std::tuple<BymlFile::Node const &>,std::tuple<>,0>'::`1'::dtor$1
	mov	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$1@?0???$?0V?$tuple@AEBVNode@BymlFile@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@AEAV?$tuple@AEBVNode@BymlFile@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z@4HA ENDP ; `std::pair<BymlFile::Node const ,unsigned int>::pair<BymlFile::Node const ,unsigned int><std::tuple<BymlFile::Node const &>,std::tuple<>,0>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Val1$ = 56
$T1 = 64
_Val2$dead$ = 64
__formal$dead$ = 72
__formal$dead$ = 80
?dtor$2@?0???$?0V?$tuple@AEBVNode@BymlFile@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@AEAV?$tuple@AEBVNode@BymlFile@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z@4HA PROC ; `std::pair<BymlFile::Node const ,unsigned int>::pair<BymlFile::Node const ,unsigned int><std::tuple<BymlFile::Node const &>,std::tuple<>,0>'::`1'::dtor$2
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 32					; 00000020H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0???$?0V?$tuple@AEBVNode@BymlFile@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBVNode@BymlFile@@I@std@@QEAA@AEAV?$tuple@AEBVNode@BymlFile@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z@4HA ENDP ; `std::pair<BymlFile::Node const ,unsigned int>::pair<BymlFile::Node const ,unsigned int><std::tuple<BymlFile::Node const &>,std::tuple<>,0>'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple
;	COMDAT ??$_Tuple_get@$0A@AEBVNode@BymlFile@@@std@@YA$$QEA_P$$QEAV?$tuple@AEBVNode@BymlFile@@@0@@Z
_TEXT	SEGMENT
_Tuple$ = 8
??$_Tuple_get@$0A@AEBVNode@BymlFile@@@std@@YA$$QEA_P$$QEAV?$tuple@AEBVNode@BymlFile@@@0@@Z PROC ; std::_Tuple_get<0,BymlFile::Node const &>, COMDAT

; 971  :     // used by pair's piecewise constructor
; 972  :     using _Ty    = tuple_element_t<_Index, tuple<_Types...>>;
; 973  :     using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
; 974  :     return static_cast<_Ty&&>(static_cast<_Ttype&>(_Tuple)._Myfirst._Val);

	mov	rax, QWORD PTR [rcx]

; 975  : }

	ret	0
??$_Tuple_get@$0A@AEBVNode@BymlFile@@@std@@YA$$QEA_P$$QEAV?$tuple@AEBVNode@BymlFile@@@0@@Z ENDP ; std::_Tuple_get<0,BymlFile::Node const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0V?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@QEAA@AEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z
_TEXT	SEGMENT
this$ = 48
_Val1$ = 56
_Val2$dead$ = 64
__formal$dead$ = 72
__formal$dead$ = 80
??$?0V?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@QEAA@AEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z PROC ; std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int><std::tuple<std::vector<unsigned char,std::allocator<unsigned char> > const &>,std::tuple<>,0>, COMDAT

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rdx, QWORD PTR [rdx]
	mov	rbx, rcx
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	mov	rax, rbx
	mov	DWORD PTR [rbx+24], 0
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$?0V?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@QEAA@AEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z ENDP ; std::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int>::pair<std::vector<unsigned char,std::allocator<unsigned char> > const ,unsigned int><std::tuple<std::vector<unsigned char,std::allocator<unsigned char> > const &>,std::tuple<>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple
;	COMDAT ??$_Tuple_get@$0A@AEBV?$vector@EV?$allocator@E@std@@@std@@@std@@YA$$QEA_P$$QEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@0@@Z
_TEXT	SEGMENT
_Tuple$ = 8
??$_Tuple_get@$0A@AEBV?$vector@EV?$allocator@E@std@@@std@@@std@@YA$$QEA_P$$QEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@0@@Z PROC ; std::_Tuple_get<0,std::vector<unsigned char,std::allocator<unsigned char> > const &>, COMDAT

; 971  :     // used by pair's piecewise constructor
; 972  :     using _Ty    = tuple_element_t<_Index, tuple<_Types...>>;
; 973  :     using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
; 974  :     return static_cast<_Ty&&>(static_cast<_Ttype&>(_Tuple)._Myfirst._Val);

	mov	rax, QWORD PTR [rcx]

; 975  : }

	ret	0
??$_Tuple_get@$0A@AEBV?$vector@EV?$allocator@E@std@@@std@@@std@@YA$$QEA_P$$QEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@0@@Z ENDP ; std::_Tuple_get<0,std::vector<unsigned char,std::allocator<unsigned char> > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAPEAD@std@@YA$$QEAPEADAEAPEAD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAPEAD@std@@YA$$QEAPEADAEAPEAD@Z PROC		; std::move<char * &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAPEAD@std@@YA$$QEAPEADAEAPEAD@Z ENDP		; std::move<char * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAV?$tuple@AEBVNode@BymlFile@@@std@@@std@@YA$$QEAV?$tuple@AEBVNode@BymlFile@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$tuple@AEBVNode@BymlFile@@@std@@@std@@YA$$QEAV?$tuple@AEBVNode@BymlFile@@@0@AEAV10@@Z PROC ; std::move<std::tuple<BymlFile::Node const &> &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAV?$tuple@AEBVNode@BymlFile@@@std@@@std@@YA$$QEAV?$tuple@AEBVNode@BymlFile@@@0@AEAV10@@Z ENDP ; std::move<std::tuple<BymlFile::Node const &> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@YA$$QEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@YA$$QEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@0@AEAV10@@Z PROC ; std::move<std::tuple<std::vector<unsigned char,std::allocator<unsigned char> > const &> &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@YA$$QEAV?$tuple@AEBV?$vector@EV?$allocator@E@std@@@std@@@0@AEAV10@@Z ENDP ; std::move<std::tuple<std::vector<unsigned char,std::allocator<unsigned char> > const &> &>
_TEXT	ENDS
END
