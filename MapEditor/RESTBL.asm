; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32822.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0O@JABPLMM@ResTblDecoder@			; `string'
PUBLIC	??_C@_0BN@EAHPGPFO@Wrong?5magic?0?5expected?5RESTBL@ ; `string'
PUBLIC	??_C@_06JNECDHIJ@RESTBL@			; `string'
PUBLIC	??_C@_0BF@CENPBOCA@Could?5not?5open?5file?$CC@	; `string'
;	COMDAT ??_C@_0BF@CENPBOCA@Could?5not?5open?5file?$CC@
CONST	SEGMENT
??_C@_0BF@CENPBOCA@Could?5not?5open?5file?$CC@ DB 'Could not open file"', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06JNECDHIJ@RESTBL@
CONST	SEGMENT
??_C@_06JNECDHIJ@RESTBL@ DB 'RESTBL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@EAHPGPFO@Wrong?5magic?0?5expected?5RESTBL@
CONST	SEGMENT
??_C@_0BN@EAHPGPFO@Wrong?5magic?0?5expected?5RESTBL@ DB 'Wrong magic, exp'
	DB	'ected RESTBL', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JABPLMM@ResTblDecoder@
CONST	SEGMENT
??_C@_0O@JABPLMM@ResTblDecoder@ DB 'ResTblDecoder', 00H	; `string'
PUBLIC	??0NameEntry@ResTableFile@@QEAA@$$QEAU01@@Z	; ResTableFile::NameEntry::NameEntry
PUBLIC	??$construct_at@UNameEntry@ResTableFile@@U12@$0A@@std@@YAPEAUNameEntry@ResTableFile@@QEAU12@$$QEAU12@@Z ; std::construct_at<ResTableFile::NameEntry,ResTableFile::NameEntry,0>
PUBLIC	??$construct_at@UCrcEntry@ResTableFile@@$$V$0A@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@@Z ; std::construct_at<ResTableFile::CrcEntry,0>
PUBLIC	??$to_address@UCrcEntry@ResTableFile@@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@@Z ; std::to_address<ResTableFile::CrcEntry>
PUBLIC	??$construct_at@UNameEntry@ResTableFile@@$$V$0A@@std@@YAPEAUNameEntry@ResTableFile@@QEAU12@@Z ; std::construct_at<ResTableFile::NameEntry,0>
PUBLIC	??$construct@UNameEntry@ResTableFile@@U12@@?$_Default_allocator_traits@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@SAXAEAV?$allocator@UNameEntry@ResTableFile@@@1@QEAUNameEntry@ResTableFile@@$$QEAU34@@Z ; std::_Default_allocator_traits<std::allocator<ResTableFile::NameEntry> >::construct<ResTableFile::NameEntry,ResTableFile::NameEntry>
PUBLIC	??$forward@UNameEntry@ResTableFile@@@std@@YA$$QEAUNameEntry@ResTableFile@@AEAU12@@Z ; std::forward<ResTableFile::NameEntry>
PUBLIC	??$forward@AEAPEAUCrcEntry@ResTableFile@@@std@@YAAEAPEAUCrcEntry@ResTableFile@@AEAPEAU12@@Z ; std::forward<ResTableFile::CrcEntry * &>
PUBLIC	??$_Copy_backward_memmove@PEAUCrcEntry@ResTableFile@@PEAU12@@std@@YAPEAUCrcEntry@ResTableFile@@PEAU12@00@Z ; std::_Copy_backward_memmove<ResTableFile::CrcEntry *,ResTableFile::CrcEntry *>
PUBLIC	??$construct_at@UCrcEntry@ResTableFile@@U12@$0A@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@$$QEAU12@@Z ; std::construct_at<ResTableFile::CrcEntry,ResTableFile::CrcEntry,0>
PUBLIC	??$addressof@UCrcEntry@ResTableFile@@@std@@YAPEAUCrcEntry@ResTableFile@@AEAU12@@Z ; std::addressof<ResTableFile::CrcEntry>
PUBLIC	??$construct@UCrcEntry@ResTableFile@@$$V@?$_Default_allocator_traits@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@SAXAEAV?$allocator@UCrcEntry@ResTableFile@@@1@QEAUCrcEntry@ResTableFile@@@Z ; std::_Default_allocator_traits<std::allocator<ResTableFile::CrcEntry> >::construct<ResTableFile::CrcEntry>
PUBLIC	??$_Emplace_back@UCrcEntry@ResTableFile@@@?$_Uninitialized_backout_al@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAAX$$QEAUCrcEntry@ResTableFile@@@Z ; std::_Uninitialized_backout_al<std::allocator<ResTableFile::CrcEntry> >::_Emplace_back<ResTableFile::CrcEntry>
PUBLIC	??$_To_address@PEAUCrcEntry@ResTableFile@@@std@@YA?A_PAEBQEAUCrcEntry@ResTableFile@@@Z ; std::_To_address<ResTableFile::CrcEntry *>
PUBLIC	??$_Copy_memmove@PEAUCrcEntry@ResTableFile@@PEAU12@@std@@YAPEAUCrcEntry@ResTableFile@@PEAU12@00@Z ; std::_Copy_memmove<ResTableFile::CrcEntry *,ResTableFile::CrcEntry *>
PUBLIC	??$construct@UNameEntry@ResTableFile@@$$V@?$_Default_allocator_traits@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@SAXAEAV?$allocator@UNameEntry@ResTableFile@@@1@QEAUNameEntry@ResTableFile@@@Z ; std::_Default_allocator_traits<std::allocator<ResTableFile::NameEntry> >::construct<ResTableFile::NameEntry>
PUBLIC	??$_Emplace_back@UNameEntry@ResTableFile@@@?$_Uninitialized_backout_al@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAAX$$QEAUNameEntry@ResTableFile@@@Z ; std::_Uninitialized_backout_al<std::allocator<ResTableFile::NameEntry> >::_Emplace_back<ResTableFile::NameEntry>
PUBLIC	??$move@AEAUNameEntry@ResTableFile@@@std@@YA$$QEAUNameEntry@ResTableFile@@AEAU12@@Z ; std::move<ResTableFile::NameEntry &>
PUBLIC	??$?0AEAPEAUCrcEntry@ResTableFile@@AEAPEAU01@$0A@@?$pair@PEAUCrcEntry@ResTableFile@@PEAU12@@std@@QEAA@AEAPEAUCrcEntry@ResTableFile@@0@Z ; std::pair<ResTableFile::CrcEntry *,ResTableFile::CrcEntry *>::pair<ResTableFile::CrcEntry *,ResTableFile::CrcEntry *><ResTableFile::CrcEntry * &,ResTableFile::CrcEntry * &,0>
PUBLIC	??$swap@UCrcEntry@ResTableFile@@$0A@@std@@YAXAEAUCrcEntry@ResTableFile@@0@Z ; std::swap<ResTableFile::CrcEntry,0>
PUBLIC	??$_Next_iter@PEAUCrcEntry@ResTableFile@@@std@@YAPEAUCrcEntry@ResTableFile@@PEAU12@@Z ; std::_Next_iter<ResTableFile::CrcEntry *>
PUBLIC	??$_Prev_iter@PEAUCrcEntry@ResTableFile@@@std@@YAPEAUCrcEntry@ResTableFile@@PEAU12@@Z ; std::_Prev_iter<ResTableFile::CrcEntry *>
PUBLIC	??$_Move_backward_unchecked@PEAUCrcEntry@ResTableFile@@PEAU12@@std@@YAPEAUCrcEntry@ResTableFile@@PEAU12@00@Z ; std::_Move_backward_unchecked<ResTableFile::CrcEntry *,ResTableFile::CrcEntry *>
PUBLIC	??$construct@UCrcEntry@ResTableFile@@U12@@?$_Default_allocator_traits@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@SAXAEAV?$allocator@UCrcEntry@ResTableFile@@@1@QEAUCrcEntry@ResTableFile@@$$QEAU34@@Z ; std::_Default_allocator_traits<std::allocator<ResTableFile::CrcEntry> >::construct<ResTableFile::CrcEntry,ResTableFile::CrcEntry>
PUBLIC	??$_Construct_in_place@UCrcEntry@ResTableFile@@U12@@std@@YAXAEAUCrcEntry@ResTableFile@@$$QEAU12@@Z ; std::_Construct_in_place<ResTableFile::CrcEntry,ResTableFile::CrcEntry>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAAXXZ ; std::_Uninitialized_backout_al<std::allocator<ResTableFile::CrcEntry> >::_Emplace_back<>
PUBLIC	??$_Uninitialized_move@PEAUCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@0PEAU12@AEAV?$allocator@UCrcEntry@ResTableFile@@@0@@Z ; std::_Uninitialized_move<ResTableFile::CrcEntry *,std::allocator<ResTableFile::CrcEntry> >
PUBLIC	??$_Get_unwrapped@AEBQEAUCrcEntry@ResTableFile@@@std@@YA?A_TAEBQEAUCrcEntry@ResTableFile@@@Z ; std::_Get_unwrapped<ResTableFile::CrcEntry * const &>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAAXXZ ; std::_Uninitialized_backout_al<std::allocator<ResTableFile::NameEntry> >::_Emplace_back<>
PUBLIC	??$_Uninitialized_move@PEAUNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@YAPEAUNameEntry@ResTableFile@@QEAU12@0PEAU12@AEAV?$allocator@UNameEntry@ResTableFile@@@0@@Z ; std::_Uninitialized_move<ResTableFile::NameEntry *,std::allocator<ResTableFile::NameEntry> >
PUBLIC	??$_Get_unwrapped@AEBQEAUNameEntry@ResTableFile@@@std@@YA?A_TAEBQEAUNameEntry@ResTableFile@@@Z ; std::_Get_unwrapped<ResTableFile::NameEntry * const &>
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UCrcEntry@ResTableFile@@@std@@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UCrcEntry@ResTableFile@@@2@XZ ; std::_Compressed_pair<std::allocator<ResTableFile::CrcEntry>,std::_Vector_val<std::_Simple_types<ResTableFile::CrcEntry> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UNameEntry@ResTableFile@@@std@@V?$_Vector_val@U?$_Simple_types@UNameEntry@ResTableFile@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UNameEntry@ResTableFile@@@2@XZ ; std::_Compressed_pair<std::allocator<ResTableFile::NameEntry>,std::_Vector_val<std::_Simple_types<ResTableFile::NameEntry> >,1>::_Get_first
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@SA_KAEBV?$allocator@UCrcEntry@ResTableFile@@@2@@Z ; std::_Default_allocator_traits<std::allocator<ResTableFile::CrcEntry> >::max_size
PUBLIC	?capacity@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEBA_KXZ ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::capacity
PUBLIC	?_Getal@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEBAAEBV?$allocator@UCrcEntry@ResTableFile@@@2@XZ ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::_Getal
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@SA_KAEBV?$allocator@UNameEntry@ResTableFile@@@2@@Z ; std::_Default_allocator_traits<std::allocator<ResTableFile::NameEntry> >::max_size
PUBLIC	?capacity@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEBA_KXZ ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::capacity
PUBLIC	?_Getal@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEBAAEBV?$allocator@UNameEntry@ResTableFile@@@2@XZ ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::_Getal
PUBLIC	?allocate@?$allocator@UCrcEntry@ResTableFile@@@std@@QEAAPEAUCrcEntry@ResTableFile@@_K@Z ; std::allocator<ResTableFile::CrcEntry>::allocate
PUBLIC	?max_size@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEBA_KXZ ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::max_size
PUBLIC	?_Calculate_growth@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEBA_K_K@Z ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAXQEAUCrcEntry@ResTableFile@@_K1@Z ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::_Change_array
PUBLIC	?_Xlength@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@CAXXZ ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::_Xlength
PUBLIC	?allocate@?$allocator@UNameEntry@ResTableFile@@@std@@QEAAPEAUNameEntry@ResTableFile@@_K@Z ; std::allocator<ResTableFile::NameEntry>::allocate
PUBLIC	?max_size@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEBA_KXZ ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::max_size
PUBLIC	?_Calculate_growth@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEBA_K_K@Z ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAXQEAUNameEntry@ResTableFile@@_K1@Z ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::_Change_array
PUBLIC	?_Xlength@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@CAXXZ ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::_Xlength
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAA@PEAUNameEntry@ResTableFile@@AEAV?$allocator@UNameEntry@ResTableFile@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<ResTableFile::NameEntry> >::_Uninitialized_backout_al<std::allocator<ResTableFile::NameEntry> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<ResTableFile::NameEntry> >::~_Uninitialized_backout_al<std::allocator<ResTableFile::NameEntry> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAAPEAUNameEntry@ResTableFile@@XZ ; std::_Uninitialized_backout_al<std::allocator<ResTableFile::NameEntry> >::_Release
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAA@PEAUCrcEntry@ResTableFile@@AEAV?$allocator@UCrcEntry@ResTableFile@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<ResTableFile::CrcEntry> >::_Uninitialized_backout_al<std::allocator<ResTableFile::CrcEntry> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<ResTableFile::CrcEntry> >::~_Uninitialized_backout_al<std::allocator<ResTableFile::CrcEntry> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAAPEAUCrcEntry@ResTableFile@@XZ ; std::_Uninitialized_backout_al<std::allocator<ResTableFile::CrcEntry> >::_Release
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAAX_K@Z ; std::_Uninitialized_backout_al<std::allocator<ResTableFile::CrcEntry> >::__autoclassinit2
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAAX_K@Z ; std::_Uninitialized_backout_al<std::allocator<ResTableFile::NameEntry> >::__autoclassinit2
PUBLIC	??$_Emplace_reallocate@UCrcEntry@ResTableFile@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAPEAUCrcEntry@ResTableFile@@QEAU23@$$QEAU23@@Z ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::_Emplace_reallocate<ResTableFile::CrcEntry>
PUBLIC	??$_Emplace_back_with_unused_capacity@UCrcEntry@ResTableFile@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAAEAUCrcEntry@ResTableFile@@$$QEAU23@@Z ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::_Emplace_back_with_unused_capacity<ResTableFile::CrcEntry>
PUBLIC	??$forward@UCrcEntry@ResTableFile@@@std@@YA$$QEAUCrcEntry@ResTableFile@@AEAU12@@Z ; std::forward<ResTableFile::CrcEntry>
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@YAPEAUCrcEntry@ResTableFile@@PEAU12@_KAEAV?$allocator@UCrcEntry@ResTableFile@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<ResTableFile::CrcEntry> >
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@YAPEAUNameEntry@ResTableFile@@PEAU12@_KAEAV?$allocator@UNameEntry@ResTableFile@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<ResTableFile::NameEntry> >
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Copy_unchecked@PEAEPEAEV?$ostream_iterator@EDU?$char_traits@D@std@@@std@@@std@@YA?AV?$ostream_iterator@EDU?$char_traits@D@std@@@0@PEAE0V10@@Z ; std::_Copy_unchecked<unsigned char *,unsigned char *,std::ostream_iterator<unsigned char,char,std::char_traits<char> > >
PUBLIC	??$_Unfancy@UCrcEntry@ResTableFile@@@std@@YAPEAUCrcEntry@ResTableFile@@PEAU12@@Z ; std::_Unfancy<ResTableFile::CrcEntry>
PUBLIC	??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ResTableFile::CrcEntry> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ResTableFile::CrcEntry> > > >
PUBLIC	??0?$allocator@UCrcEntry@ResTableFile@@@std@@QEAA@XZ ; std::allocator<ResTableFile::CrcEntry>::allocator<ResTableFile::CrcEntry>
PUBLIC	?_Orphan_range@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEBAXPEAUCrcEntry@ResTableFile@@0@Z ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::_Orphan_range
PUBLIC	??0?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<ResTableFile::CrcEntry> >::_Vector_val<std::_Simple_types<ResTableFile::CrcEntry> >
PUBLIC	??0?$allocator@UNameEntry@ResTableFile@@@std@@QEAA@XZ ; std::allocator<ResTableFile::NameEntry>::allocator<ResTableFile::NameEntry>
PUBLIC	?_Orphan_range@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEBAXPEAUNameEntry@ResTableFile@@0@Z ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::_Orphan_range
PUBLIC	??0?$_Vector_val@U?$_Simple_types@UNameEntry@ResTableFile@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<ResTableFile::NameEntry> >::_Vector_val<std::_Simple_types<ResTableFile::NameEntry> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@UCrcEntry@ResTableFile@@@std@@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<ResTableFile::CrcEntry>,std::_Vector_val<std::_Simple_types<ResTableFile::CrcEntry> >,1>::_Compressed_pair<std::allocator<ResTableFile::CrcEntry>,std::_Vector_val<std::_Simple_types<ResTableFile::CrcEntry> >,1><>
PUBLIC	??$_Emplace_one_at_back@UCrcEntry@ResTableFile@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAAEAUCrcEntry@ResTableFile@@$$QEAU23@@Z ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::_Emplace_one_at_back<ResTableFile::CrcEntry>
PUBLIC	??$move@AEAUCrcEntry@ResTableFile@@@std@@YA$$QEAUCrcEntry@ResTableFile@@AEAU12@@Z ; std::move<ResTableFile::CrcEntry &>
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::_Resize<std::_Value_init_tag>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@0@AEAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<ResTableFile::CrcEntry> > >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@UNameEntry@ResTableFile@@@std@@V?$_Vector_val@U?$_Simple_types@UNameEntry@ResTableFile@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<ResTableFile::NameEntry>,std::_Vector_val<std::_Simple_types<ResTableFile::NameEntry> >,1>::_Compressed_pair<std::allocator<ResTableFile::NameEntry>,std::_Vector_val<std::_Simple_types<ResTableFile::NameEntry> >,1><>
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::_Resize<std::_Value_init_tag>
PUBLIC	??$_Idl_distance@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PEAE@std@@YA?A_PAEBQEAE0@Z ; std::_Idl_distance<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,unsigned char *>
PUBLIC	??$copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V?$ostream_iterator@EDU?$char_traits@D@std@@@2@@std@@YA?AV?$ostream_iterator@EDU?$char_traits@D@std@@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0V10@@Z ; std::copy<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,std::ostream_iterator<unsigned char,char,std::char_traits<char> > >
PUBLIC	?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@std@@QEBAPEAUCrcEntry@ResTableFile@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ResTableFile::CrcEntry> > >::_Unwrapped
PUBLIC	??$_Get_unwrapped@AEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@std@@@std@@YA?A_TAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ResTableFile::CrcEntry> > > const &>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@std@@QEAA@PEAUCrcEntry@ResTableFile@@PEBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ResTableFile::CrcEntry> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ResTableFile::CrcEntry> > >
PUBLIC	??0?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAA@XZ ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >
PUBLIC	?push_back@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAAX$$QEAUCrcEntry@ResTableFile@@@Z ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::push_back
PUBLIC	?resize@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAAX_K@Z ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::resize
PUBLIC	?begin@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@2@XZ ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::begin
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@std@@QEAA@PEAUCrcEntry@ResTableFile@@PEBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ResTableFile::CrcEntry> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<ResTableFile::CrcEntry> > >
PUBLIC	?end@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@2@XZ ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::end
PUBLIC	?_Unchecked_begin@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAAPEAUCrcEntry@ResTableFile@@XZ ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAAPEAUCrcEntry@ResTableFile@@XZ ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::_Unchecked_end
PUBLIC	?size@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEBA_KXZ ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::size
PUBLIC	??A?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAAAEAUCrcEntry@ResTableFile@@_K@Z ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::operator[]
PUBLIC	??0?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAA@XZ ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >
PUBLIC	?resize@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAAX_K@Z ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::resize
PUBLIC	?_Unchecked_begin@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAAPEAUNameEntry@ResTableFile@@XZ ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAAPEAUNameEntry@ResTableFile@@XZ ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::_Unchecked_end
PUBLIC	?size@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEBA_KXZ ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::size
PUBLIC	??A?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAAAEAUNameEntry@ResTableFile@@_K@Z ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::operator[]
PUBLIC	??0NameEntry@ResTableFile@@QEAA@AEBU01@@Z	; ResTableFile::NameEntry::NameEntry
PUBLIC	??4NameEntry@ResTableFile@@QEAAAEAU01@AEBU01@@Z	; ResTableFile::NameEntry::operator=
PUBLIC	??0NameEntry@ResTableFile@@QEAA@XZ		; ResTableFile::NameEntry::NameEntry
PUBLIC	?SetFileSize@ResTableFile@@QEAAXII@Z		; ResTableFile::SetFileSize
PUBLIC	?GenerateCrc32Hash@ResTableFile@@QEAAIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ResTableFile::GenerateCrc32Hash
PUBLIC	?GenerateCrcTable@ResTableFile@@AEAAXXZ		; ResTableFile::GenerateCrcTable
PUBLIC	??0ResTableFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z ; ResTableFile::ResTableFile
PUBLIC	?ToBinary@ResTableFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ ; ResTableFile::ToBinary
PUBLIC	?SetFileSize@ResTableFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z ; ResTableFile::SetFileSize
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove@PEAUCrcEntry@ResTableFile@@PEAU12@@std@@YAPEAUCrcEntry@ResTableFile@@PEAU12@00@Z DD imagerel $LN4
	DD	imagerel $LN4+48
	DD	imagerel $unwind$??$_Copy_memmove@PEAUCrcEntry@ResTableFile@@PEAU12@@std@@YAPEAUCrcEntry@ResTableFile@@PEAU12@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Guess_median_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD imagerel ??$_Guess_median_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
	DD	imagerel ??$_Guess_median_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+33
	DD	imagerel $unwind$??$_Guess_median_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Guess_median_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD imagerel ??$_Guess_median_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+33
	DD	imagerel ??$_Guess_median_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+42
	DD	imagerel $chain$0$??$_Guess_median_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Guess_median_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD imagerel ??$_Guess_median_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+42
	DD	imagerel ??$_Guess_median_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+207
	DD	imagerel $chain$1$??$_Guess_median_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Guess_median_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD imagerel ??$_Guess_median_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+207
	DD	imagerel ??$_Guess_median_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+316
	DD	imagerel $chain$2$??$_Guess_median_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Guess_median_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD imagerel ??$_Guess_median_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+316
	DD	imagerel ??$_Guess_median_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+377
	DD	imagerel $chain$3$??$_Guess_median_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Pop_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD imagerel ??$_Pop_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
	DD	imagerel ??$_Pop_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+44
	DD	imagerel $unwind$??$_Pop_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Pop_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD imagerel ??$_Pop_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+44
	DD	imagerel ??$_Pop_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+130
	DD	imagerel $chain$1$??$_Pop_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Pop_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD imagerel ??$_Pop_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+130
	DD	imagerel ??$_Pop_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+160
	DD	imagerel $chain$2$??$_Pop_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Pop_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD imagerel ??$_Pop_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+160
	DD	imagerel ??$_Pop_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+198
	DD	imagerel $chain$3$??$_Pop_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Pop_heap_hole_by_index@PEAUCrcEntry@ResTableFile@@U12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@_J1$$QEAU12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD imagerel ??$_Pop_heap_hole_by_index@PEAUCrcEntry@ResTableFile@@U12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@_J1$$QEAU12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
	DD	imagerel ??$_Pop_heap_hole_by_index@PEAUCrcEntry@ResTableFile@@U12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@_J1$$QEAU12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+155
	DD	imagerel $unwind$??$_Pop_heap_hole_by_index@PEAUCrcEntry@ResTableFile@@U12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@_J1$$QEAU12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAUCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@0PEAU12@AEAV?$allocator@UCrcEntry@ResTableFile@@@0@@Z DD imagerel $LN23
	DD	imagerel $LN23+52
	DD	imagerel $unwind$??$_Uninitialized_move@PEAUCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@0PEAU12@AEAV?$allocator@UCrcEntry@ResTableFile@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Partition_by_median_guess_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YA?AU?$pair@PEAUCrcEntry@ResTableFile@@PEAU12@@0@PEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@3@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD imagerel ??$_Partition_by_median_guess_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YA?AU?$pair@PEAUCrcEntry@ResTableFile@@PEAU12@@0@PEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@3@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
	DD	imagerel ??$_Partition_by_median_guess_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YA?AU?$pair@PEAUCrcEntry@ResTableFile@@PEAU12@@0@PEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@3@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+384
	DD	imagerel $unwind$??$_Partition_by_median_guess_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YA?AU?$pair@PEAUCrcEntry@ResTableFile@@PEAU12@@0@PEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@3@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Sort_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD imagerel ??$_Sort_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
	DD	imagerel ??$_Sort_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+27
	DD	imagerel $unwind$??$_Sort_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Sort_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD imagerel ??$_Sort_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+27
	DD	imagerel ??$_Sort_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+266
	DD	imagerel $chain$3$??$_Sort_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Sort_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD imagerel ??$_Sort_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+266
	DD	imagerel ??$_Sort_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+271
	DD	imagerel $chain$4$??$_Sort_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Make_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD imagerel ??$_Make_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
	DD	imagerel ??$_Make_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+30
	DD	imagerel $unwind$??$_Make_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Make_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD imagerel ??$_Make_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+30
	DD	imagerel ??$_Make_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+212
	DD	imagerel $chain$1$??$_Make_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Make_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD imagerel ??$_Make_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+212
	DD	imagerel ??$_Make_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+214
	DD	imagerel $chain$2$??$_Make_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Insertion_sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD imagerel ??$_Insertion_sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
	DD	imagerel ??$_Insertion_sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+41
	DD	imagerel $unwind$??$_Insertion_sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Insertion_sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD imagerel ??$_Insertion_sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+41
	DD	imagerel ??$_Insertion_sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+55
	DD	imagerel $chain$0$??$_Insertion_sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Insertion_sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD imagerel ??$_Insertion_sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+55
	DD	imagerel ??$_Insertion_sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+147
	DD	imagerel $chain$1$??$_Insertion_sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Insertion_sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD imagerel ??$_Insertion_sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+147
	DD	imagerel ??$_Insertion_sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+155
	DD	imagerel $chain$2$??$_Insertion_sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Insertion_sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD imagerel ??$_Insertion_sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+155
	DD	imagerel ??$_Insertion_sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+185
	DD	imagerel $chain$3$??$_Insertion_sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@UCrcEntry@ResTableFile@@@std@@QEAAPEAUCrcEntry@ResTableFile@@_K@Z DD imagerel $LN32
	DD	imagerel $LN32+112
	DD	imagerel $unwind$?allocate@?$allocator@UCrcEntry@ResTableFile@@@std@@QEAAPEAUCrcEntry@ResTableFile@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAXQEAUCrcEntry@ResTableFile@@_K1@Z DD imagerel $LN30
	DD	imagerel $LN30+136
	DD	imagerel $unwind$?_Change_array@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAXQEAUCrcEntry@ResTableFile@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlength@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@UNameEntry@ResTableFile@@@std@@QEAAPEAUNameEntry@ResTableFile@@_K@Z DD imagerel $LN32
	DD	imagerel $LN32+116
	DD	imagerel $unwind$?allocate@?$allocator@UNameEntry@ResTableFile@@@std@@QEAAPEAUNameEntry@ResTableFile@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAXQEAUNameEntry@ResTableFile@@_K1@Z DD imagerel $LN53
	DD	imagerel $LN53+40
	DD	imagerel $unwind$?_Change_array@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAXQEAUNameEntry@ResTableFile@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Change_array@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAXQEAUNameEntry@ResTableFile@@_K1@Z DD imagerel $LN53+40
	DD	imagerel $LN53+121
	DD	imagerel $chain$0$?_Change_array@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAXQEAUNameEntry@ResTableFile@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Change_array@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAXQEAUNameEntry@ResTableFile@@_K1@Z DD imagerel $LN53+121
	DD	imagerel $LN53+205
	DD	imagerel $chain$1$?_Change_array@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAXQEAUNameEntry@ResTableFile@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlength@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Uninitialized_backout_al@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAA@XZ DD imagerel $LN28
	DD	imagerel $LN28+50
	DD	imagerel $unwind$??1?$_Uninitialized_backout_al@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@UCrcEntry@ResTableFile@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAPEAUCrcEntry@ResTableFile@@QEAU23@$$QEAU23@@Z DD imagerel $LN85
	DD	imagerel $LN85+72
	DD	imagerel $unwind$??$_Emplace_reallocate@UCrcEntry@ResTableFile@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAPEAUCrcEntry@ResTableFile@@QEAU23@$$QEAU23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Emplace_reallocate@UCrcEntry@ResTableFile@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAPEAUCrcEntry@ResTableFile@@QEAU23@$$QEAU23@@Z DD imagerel $LN85+72
	DD	imagerel $LN85+234
	DD	imagerel $chain$1$??$_Emplace_reallocate@UCrcEntry@ResTableFile@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAPEAUCrcEntry@ResTableFile@@QEAU23@$$QEAU23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Emplace_reallocate@UCrcEntry@ResTableFile@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAPEAUCrcEntry@ResTableFile@@QEAU23@$$QEAU23@@Z DD imagerel $LN85+234
	DD	imagerel $LN85+240
	DD	imagerel $chain$2$??$_Emplace_reallocate@UCrcEntry@ResTableFile@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAPEAUCrcEntry@ResTableFile@@QEAU23@$$QEAU23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_value_construct_n@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@YAPEAUCrcEntry@ResTableFile@@PEAU12@_KAEAV?$allocator@UCrcEntry@ResTableFile@@@0@@Z DD imagerel $LN26
	DD	imagerel $LN26+14
	DD	imagerel $unwind$??$_Uninitialized_value_construct_n@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@YAPEAUCrcEntry@ResTableFile@@PEAU12@_KAEAV?$allocator@UCrcEntry@ResTableFile@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Uninitialized_value_construct_n@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@YAPEAUCrcEntry@ResTableFile@@PEAU12@_KAEAV?$allocator@UCrcEntry@ResTableFile@@@0@@Z DD imagerel $LN26+14
	DD	imagerel $LN26+52
	DD	imagerel $chain$0$??$_Uninitialized_value_construct_n@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@YAPEAUCrcEntry@ResTableFile@@PEAU12@_KAEAV?$allocator@UCrcEntry@ResTableFile@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Uninitialized_value_construct_n@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@YAPEAUCrcEntry@ResTableFile@@PEAU12@_KAEAV?$allocator@UCrcEntry@ResTableFile@@@0@@Z DD imagerel $LN26+52
	DD	imagerel $LN26+61
	DD	imagerel $chain$1$??$_Uninitialized_value_construct_n@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@YAPEAUCrcEntry@ResTableFile@@PEAU12@_KAEAV?$allocator@UCrcEntry@ResTableFile@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN63
	DD	imagerel $LN63+33
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN63+33
	DD	imagerel $LN63+121
	DD	imagerel $chain$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN63+121
	DD	imagerel $LN63+183
	DD	imagerel $chain$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN63+183
	DD	imagerel $LN63+189
	DD	imagerel $chain$3$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN264
	DD	imagerel $LN264+33
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN264+33
	DD	imagerel $LN264+537
	DD	imagerel $chain$4$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN264+537
	DD	imagerel $LN264+544
	DD	imagerel $chain$6$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN264+544
	DD	imagerel $LN264+550
	DD	imagerel $chain$7$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN264+550
	DD	imagerel $LN264+556
	DD	imagerel $chain$8$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_unchecked@PEAEPEAEV?$ostream_iterator@EDU?$char_traits@D@std@@@std@@@std@@YA?AV?$ostream_iterator@EDU?$char_traits@D@std@@@0@PEAE0V10@@Z DD imagerel $LN27
	DD	imagerel $LN27+31
	DD	imagerel $unwind$??$_Copy_unchecked@PEAEPEAEV?$ostream_iterator@EDU?$char_traits@D@std@@@std@@@std@@YA?AV?$ostream_iterator@EDU?$char_traits@D@std@@@0@PEAE0V10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Copy_unchecked@PEAEPEAEV?$ostream_iterator@EDU?$char_traits@D@std@@@std@@@std@@YA?AV?$ostream_iterator@EDU?$char_traits@D@std@@@0@PEAE0V10@@Z DD imagerel $LN27+31
	DD	imagerel $LN27+114
	DD	imagerel $chain$1$??$_Copy_unchecked@PEAEPEAEV?$ostream_iterator@EDU?$char_traits@D@std@@@std@@@std@@YA?AV?$ostream_iterator@EDU?$char_traits@D@std@@@0@PEAE0V10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Copy_unchecked@PEAEPEAEV?$ostream_iterator@EDU?$char_traits@D@std@@@std@@@std@@YA?AV?$ostream_iterator@EDU?$char_traits@D@std@@@0@PEAE0V10@@Z DD imagerel $LN27+114
	DD	imagerel $LN27+140
	DD	imagerel $chain$2$??$_Copy_unchecked@PEAEPEAEV?$ostream_iterator@EDU?$char_traits@D@std@@@std@@@std@@YA?AV?$ostream_iterator@EDU?$char_traits@D@std@@@0@PEAE0V10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0_JV<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD imagerel ??$_Sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0_JV<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
	DD	imagerel ??$_Sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0_JV<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+1043
	DD	imagerel $unwind$??$_Sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0_JV<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize@U_Value_init_tag@std@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN33
	DD	imagerel $LN33+95
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Resize@U_Value_init_tag@std@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN33+95
	DD	imagerel $LN33+129
	DD	imagerel $chain$0$??$_Resize@U_Value_init_tag@std@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Resize@U_Value_init_tag@std@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN33+129
	DD	imagerel $LN33+144
	DD	imagerel $chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize@U_Value_init_tag@std@@@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN97
	DD	imagerel $LN97+46
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Resize@U_Value_init_tag@std@@@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN97+46
	DD	imagerel $LN97+110
	DD	imagerel $chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Resize@U_Value_init_tag@std@@@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN97+110
	DD	imagerel $LN97+205
	DD	imagerel $chain$2$??$_Resize@U_Value_init_tag@std@@@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V?$ostream_iterator@EDU?$char_traits@D@std@@@2@@std@@YA?AV?$ostream_iterator@EDU?$char_traits@D@std@@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0V10@@Z DD imagerel $LN27
	DD	imagerel $LN27+38
	DD	imagerel $unwind$??$copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V?$ostream_iterator@EDU?$char_traits@D@std@@@2@@std@@YA?AV?$ostream_iterator@EDU?$char_traits@D@std@@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0V10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V?$ostream_iterator@EDU?$char_traits@D@std@@@2@@std@@YA?AV?$ostream_iterator@EDU?$char_traits@D@std@@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0V10@@Z DD imagerel $LN27+38
	DD	imagerel $LN27+109
	DD	imagerel $chain$1$??$copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V?$ostream_iterator@EDU?$char_traits@D@std@@@2@@std@@YA?AV?$ostream_iterator@EDU?$char_traits@D@std@@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0V10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V?$ostream_iterator@EDU?$char_traits@D@std@@@2@@std@@YA?AV?$ostream_iterator@EDU?$char_traits@D@std@@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0V10@@Z DD imagerel $LN27+109
	DD	imagerel $LN27+131
	DD	imagerel $chain$2$??$copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V?$ostream_iterator@EDU?$char_traits@D@std@@@2@@std@@YA?AV?$ostream_iterator@EDU?$char_traits@D@std@@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0V10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@std@@V<lambda_1>@?1??ToBinary@ResTableFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@XZ@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@0@0V<lambda_1>@?1??ToBinary@ResTableFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD imagerel ??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@std@@V<lambda_1>@?1??ToBinary@ResTableFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@XZ@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@0@0V<lambda_1>@?1??ToBinary@ResTableFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
	DD	imagerel ??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@std@@V<lambda_1>@?1??ToBinary@ResTableFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@XZ@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@0@0V<lambda_1>@?1??ToBinary@ResTableFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+34
	DD	imagerel $unwind$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@std@@V<lambda_1>@?1??ToBinary@ResTableFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@XZ@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@0@0V<lambda_1>@?1??ToBinary@ResTableFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAAX_K@Z DD imagerel $LN35
	DD	imagerel $LN35+95
	DD	imagerel $unwind$?resize@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?resize@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAAX_K@Z DD imagerel $LN35+95
	DD	imagerel $LN35+129
	DD	imagerel $chain$0$?resize@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?resize@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAAX_K@Z DD imagerel $LN35+129
	DD	imagerel $LN35+144
	DD	imagerel $chain$1$?resize@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAAX_K@Z DD imagerel $LN99
	DD	imagerel $LN99+46
	DD	imagerel $unwind$?resize@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?resize@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAAX_K@Z DD imagerel $LN99+46
	DD	imagerel $LN99+110
	DD	imagerel $chain$1$?resize@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?resize@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAAX_K@Z DD imagerel $LN99+110
	DD	imagerel $LN99+205
	DD	imagerel $chain$2$?resize@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0NameEntry@ResTableFile@@QEAA@AEBU01@@Z DD imagerel $LN6
	DD	imagerel $LN6+41
	DD	imagerel $unwind$??0NameEntry@ResTableFile@@QEAA@AEBU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4NameEntry@ResTableFile@@QEAAAEAU01@AEBU01@@Z DD imagerel $LN15
	DD	imagerel $LN15+60
	DD	imagerel $unwind$??4NameEntry@ResTableFile@@QEAAAEAU01@AEBU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SetFileSize@ResTableFile@@QEAAXII@Z DD imagerel $LN20
	DD	imagerel $LN20+96
	DD	imagerel $unwind$?SetFileSize@ResTableFile@@QEAAXII@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GenerateCrc32Hash@ResTableFile@@QEAAIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN26
	DD	imagerel $LN26+93
	DD	imagerel $unwind$?GenerateCrc32Hash@ResTableFile@@QEAAIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GenerateCrcTable@ResTableFile@@AEAAXXZ DD imagerel $LN48
	DD	imagerel $LN48+217
	DD	imagerel $unwind$?GenerateCrcTable@ResTableFile@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ResTableFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z DD imagerel $LN485
	DD	imagerel $LN485+1485
	DD	imagerel $unwind$??0ResTableFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ToBinary@ResTableFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ DD imagerel $LN345
	DD	imagerel $LN345+1820
	DD	imagerel $unwind$?ToBinary@ResTableFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SetFileSize@ResTableFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z DD imagerel $LN84
	DD	imagerel $LN84+358
	DD	imagerel $unwind$?SetFileSize@ResTableFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?SetFileSize@ResTableFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z DB 04H
	DB	'A', 02H
	DB	02H
	DB	0a1H, 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?SetFileSize@ResTableFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?SetFileSize@ResTableFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z DB 028H
	DD	imagerel $stateUnwindMap$?SetFileSize@ResTableFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z
	DD	imagerel $ip2state$?SetFileSize@ResTableFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SetFileSize@ResTableFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z DD 0a2519H
	DD	0155416H
	DD	0143416H
	DD	0f012b216H
	DD	0c00ee010H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?SetFileSize@ResTableFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?ToBinary@ResTableFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ DB 0aH
	DB	0acH
	DB	02H
	DB	'1', 012H
	DB	04H
	DB	'u', 05H
	DB	02H
	DB	0e8H
	DB	00H
	DB	0c6H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?ToBinary@ResTableFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ DB 04H
	DB	0aH
	DD	imagerel ??1BinaryVectorWriter@@QEAA@XZ
	DB	070H
	DB	032H
	DD	imagerel ??1NameEntry@ResTableFile@@QEAA@XZ
	DB	0b0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?ToBinary@ResTableFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ DB 028H
	DD	imagerel $stateUnwindMap$?ToBinary@ResTableFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ
	DD	imagerel $ip2state$?ToBinary@ResTableFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ToBinary@ResTableFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ DD 0b2a19H
	DD	01c341cH
	DD	012011cH
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?ToBinary@ResTableFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ
	DD	082H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0ResTableFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z DB 0cH
	DB	0c6H
	DB	08H
	DB	081H, 0eH
	DB	0cH
	DB	'a', 03H
	DB	08H
	DB	09aH
	DB	0aH
	DB	'L'
	DB	08H
	DB	01cH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0ResTableFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z DB 0cH
	DB	0cH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	021H
	DB	02H
	DB	03cH
	DD	imagerel ??1?$vector@IV?$allocator@I@std@@@std@@QEAA@XZ
	DB	0e0H
	DB	036H
	DD	imagerel ?dtor$2@?0???0ResTableFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$3@?0???0ResTableFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA
	DB	02cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	040H
	DB	05aH
	DD	imagerel ??1NameEntry@ResTableFile@@QEAA@XZ
	DB	041H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0ResTableFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0ResTableFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z
	DD	imagerel $ip2state$??0ResTableFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ResTableFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z DD 0b2a19H
	DD	022341cH
	DD	018011cH
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??0ResTableFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z
	DD	0baH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GenerateCrcTable@ResTableFile@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GenerateCrc32Hash@ResTableFile@@QEAAIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SetFileSize@ResTableFile@@QEAAXII@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4NameEntry@ResTableFile@@QEAAAEAU01@AEBU01@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0NameEntry@ResTableFile@@QEAA@AEBU01@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?resize@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAAX_K@Z DD 021H
	DD	imagerel $LN99
	DD	imagerel $LN99+46
	DD	imagerel $unwind$?resize@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?resize@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAAX_K@Z DD 041221H
	DD	047412H
	DD	0a5405H
	DD	imagerel $LN99
	DD	imagerel $LN99+46
	DD	imagerel $unwind$?resize@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAAX_K@Z DD 030701H
	DD	060034207H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?resize@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAAX_K@Z DD 021H
	DD	imagerel $LN35
	DD	imagerel $LN35+95
	DD	imagerel $unwind$?resize@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?resize@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAAX_K@Z DD 020521H
	DD	083405H
	DD	imagerel $LN35
	DD	imagerel $LN35+95
	DD	imagerel $unwind$?resize@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAAX_K@Z DD 040a01H
	DD	09640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@std@@V<lambda_1>@?1??ToBinary@ResTableFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@XZ@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@0@0V<lambda_1>@?1??ToBinary@ResTableFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V?$ostream_iterator@EDU?$char_traits@D@std@@@2@@std@@YA?AV?$ostream_iterator@EDU?$char_traits@D@std@@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0V10@@Z DD 021H
	DD	imagerel $LN27
	DD	imagerel $LN27+38
	DD	imagerel $unwind$??$copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V?$ostream_iterator@EDU?$char_traits@D@std@@@2@@std@@YA?AV?$ostream_iterator@EDU?$char_traits@D@std@@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0V10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V?$ostream_iterator@EDU?$char_traits@D@std@@@2@@std@@YA?AV?$ostream_iterator@EDU?$char_traits@D@std@@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0V10@@Z DD 040f21H
	DD	06640fH
	DD	0d5405H
	DD	imagerel $LN27
	DD	imagerel $LN27+38
	DD	imagerel $unwind$??$copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V?$ostream_iterator@EDU?$char_traits@D@std@@@2@@std@@YA?AV?$ostream_iterator@EDU?$char_traits@D@std@@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0V10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V?$ostream_iterator@EDU?$char_traits@D@std@@@2@@std@@YA?AV?$ostream_iterator@EDU?$char_traits@D@std@@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0V10@@Z DD 050b01H
	DD	0f007620bH
	DD	07003e005H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Resize@U_Value_init_tag@std@@@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN97
	DD	imagerel $LN97+46
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 041221H
	DD	047412H
	DD	0a5405H
	DD	imagerel $LN97
	DD	imagerel $LN97+46
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 030701H
	DD	060034207H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN33
	DD	imagerel $LN33+95
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Resize@U_Value_init_tag@std@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 020521H
	DD	083405H
	DD	imagerel $LN33
	DD	imagerel $LN33+95
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040a01H
	DD	09640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0_JV<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD 081001H
	DD	0d3410H
	DD	0f00c3210H
	DD	07008e00aH
	DD	050066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Copy_unchecked@PEAEPEAEV?$ostream_iterator@EDU?$char_traits@D@std@@@std@@@std@@YA?AV?$ostream_iterator@EDU?$char_traits@D@std@@@0@PEAE0V10@@Z DD 021H
	DD	imagerel $LN27
	DD	imagerel $LN27+31
	DD	imagerel $unwind$??$_Copy_unchecked@PEAEPEAEV?$ostream_iterator@EDU?$char_traits@D@std@@@std@@@std@@YA?AV?$ostream_iterator@EDU?$char_traits@D@std@@@0@PEAE0V10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Copy_unchecked@PEAEPEAEV?$ostream_iterator@EDU?$char_traits@D@std@@@std@@@std@@YA?AV?$ostream_iterator@EDU?$char_traits@D@std@@@0@PEAE0V10@@Z DD 040d21H
	DD	09740dH
	DD	085405H
	DD	imagerel $LN27
	DD	imagerel $LN27+31
	DD	imagerel $unwind$??$_Copy_unchecked@PEAEPEAEV?$ostream_iterator@EDU?$char_traits@D@std@@@std@@@std@@YA?AV?$ostream_iterator@EDU?$char_traits@D@std@@@0@PEAE0V10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_unchecked@PEAEPEAEV?$ostream_iterator@EDU?$char_traits@D@std@@@std@@@std@@YA?AV?$ostream_iterator@EDU?$char_traits@D@std@@@0@PEAE0V10@@Z DD 060e01H
	DD	0a340eH
	DD	0f00a320eH
	DD	06006e008H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 0a0021H
	DD	04f400H
	DD	05c400H
	DD	067400H
	DD	0d5400H
	DD	0c3400H
	DD	imagerel $LN264
	DD	imagerel $LN264+33
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN264
	DD	imagerel $LN264+33
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 0a0021H
	DD	04f400H
	DD	05c400H
	DD	067400H
	DD	0d5400H
	DD	0c3400H
	DD	imagerel $LN264
	DD	imagerel $LN264+33
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 0a4321H
	DD	04f443H
	DD	05c425H
	DD	067420H
	DD	0d541bH
	DD	0c3405H
	DD	imagerel $LN264
	DD	imagerel $LN264+33
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 030801H
	DD	0e0046208H
	DD	06002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN63
	DD	imagerel $LN63+33
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 020021H
	DD	0be400H
	DD	imagerel $LN63
	DD	imagerel $LN63+33
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 042c21H
	DD	0be42cH
	DD	0a5405H
	DD	imagerel $LN63
	DD	imagerel $LN63+33
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040801H
	DD	070043208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Uninitialized_value_construct_n@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@YAPEAUCrcEntry@ResTableFile@@PEAU12@_KAEAV?$allocator@UCrcEntry@ResTableFile@@@0@@Z DD 021H
	DD	imagerel $LN26
	DD	imagerel $LN26+14
	DD	imagerel $unwind$??$_Uninitialized_value_construct_n@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@YAPEAUCrcEntry@ResTableFile@@PEAU12@_KAEAV?$allocator@UCrcEntry@ResTableFile@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Uninitialized_value_construct_n@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@YAPEAUCrcEntry@ResTableFile@@PEAU12@_KAEAV?$allocator@UCrcEntry@ResTableFile@@@0@@Z DD 020521H
	DD	063405H
	DD	imagerel $LN26
	DD	imagerel $LN26+14
	DD	imagerel $unwind$??$_Uninitialized_value_construct_n@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@YAPEAUCrcEntry@ResTableFile@@PEAU12@_KAEAV?$allocator@UCrcEntry@ResTableFile@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_value_construct_n@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@YAPEAUCrcEntry@ResTableFile@@PEAU12@_KAEAV?$allocator@UCrcEntry@ResTableFile@@@0@@Z DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Emplace_reallocate@UCrcEntry@ResTableFile@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAPEAUCrcEntry@ResTableFile@@QEAU23@$$QEAU23@@Z DD 021H
	DD	imagerel $LN85
	DD	imagerel $LN85+72
	DD	imagerel $unwind$??$_Emplace_reallocate@UCrcEntry@ResTableFile@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAPEAUCrcEntry@ResTableFile@@QEAU23@$$QEAU23@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Emplace_reallocate@UCrcEntry@ResTableFile@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAPEAUCrcEntry@ResTableFile@@QEAU23@$$QEAU23@@Z DD 041521H
	DD	0d6415H
	DD	0c5405H
	DD	imagerel $LN85
	DD	imagerel $LN85+72
	DD	imagerel $unwind$??$_Emplace_reallocate@UCrcEntry@ResTableFile@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAPEAUCrcEntry@ResTableFile@@QEAU23@$$QEAU23@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@UCrcEntry@ResTableFile@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAPEAUCrcEntry@ResTableFile@@QEAU23@$$QEAU23@@Z DD 060d01H
	DD	0f009320dH
	DD	0c005e007H
	DD	030027003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Uninitialized_backout_al@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAA@XZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Change_array@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAXQEAUNameEntry@ResTableFile@@_K1@Z DD 021H
	DD	imagerel $LN53
	DD	imagerel $LN53+40
	DD	imagerel $unwind$?_Change_array@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAXQEAUNameEntry@ResTableFile@@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Change_array@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAXQEAUNameEntry@ResTableFile@@_K1@Z DD 020521H
	DD	097405H
	DD	imagerel $LN53
	DD	imagerel $LN53+40
	DD	imagerel $unwind$?_Change_array@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAXQEAUNameEntry@ResTableFile@@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAXQEAUNameEntry@ResTableFile@@_K1@Z DD 081401H
	DD	0b6414H
	DD	0a3414H
	DD	0f0103214H
	DD	0c00ce00eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@UNameEntry@ResTableFile@@@std@@QEAAPEAUNameEntry@ResTableFile@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAXQEAUCrcEntry@ResTableFile@@_K1@Z DD 081401H
	DD	096414H
	DD	085414H
	DD	073414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@UCrcEntry@ResTableFile@@@std@@QEAAPEAUCrcEntry@ResTableFile@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Insertion_sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD 021H
	DD	imagerel ??$_Insertion_sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
	DD	imagerel ??$_Insertion_sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+41
	DD	imagerel $unwind$??$_Insertion_sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Insertion_sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD 021H
	DD	imagerel ??$_Insertion_sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+41
	DD	imagerel ??$_Insertion_sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+55
	DD	imagerel $chain$0$??$_Insertion_sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Insertion_sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD 020521H
	DD	093405H
	DD	imagerel ??$_Insertion_sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+41
	DD	imagerel ??$_Insertion_sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+55
	DD	imagerel $chain$0$??$_Insertion_sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Insertion_sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD 020521H
	DD	0a7405H
	DD	imagerel ??$_Insertion_sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
	DD	imagerel ??$_Insertion_sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+41
	DD	imagerel $unwind$??$_Insertion_sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Insertion_sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD 041a19H
	DD	0b640bH
	DD	0e007520bH
	DD	imagerel __GSHandlerCheck
	DD	020H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Make_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD 021H
	DD	imagerel ??$_Make_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
	DD	imagerel ??$_Make_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+30
	DD	imagerel $unwind$??$_Make_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Make_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD 041121H
	DD	056411H
	DD	043405H
	DD	imagerel ??$_Make_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
	DD	imagerel ??$_Make_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+30
	DD	imagerel $unwind$??$_Make_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Make_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD 010201H
	DD	07002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Sort_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD 021H
	DD	imagerel ??$_Sort_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
	DD	imagerel ??$_Sort_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+27
	DD	imagerel $unwind$??$_Sort_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Sort_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD 081721H
	DD	0e417H
	DD	01740fH
	DD	02640aH
	DD	063405H
	DD	imagerel ??$_Sort_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
	DD	imagerel ??$_Sort_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+27
	DD	imagerel $unwind$??$_Sort_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Sort_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD 010401H
	DD	02204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Partition_by_median_guess_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YA?AU?$pair@PEAUCrcEntry@ResTableFile@@PEAU12@@0@PEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@3@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD 041719H
	DD	070045208H
	DD	030026003H
	DD	imagerel __GSHandlerCheck
	DD	020H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAUCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@0PEAU12@AEAV?$allocator@UCrcEntry@ResTableFile@@@0@@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Pop_heap_hole_by_index@PEAUCrcEntry@ResTableFile@@U12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@_J1$$QEAU12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD 040701H
	DD	063407H
	DD	060067007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Pop_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD 021H
	DD	imagerel ??$_Pop_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
	DD	imagerel ??$_Pop_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+44
	DD	imagerel $unwind$??$_Pop_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Pop_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD 020021H
	DD	07400H
	DD	imagerel ??$_Pop_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
	DD	imagerel ??$_Pop_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+44
	DD	imagerel $unwind$??$_Pop_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Pop_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD 040c21H
	DD	0740cH
	DD	043405H
	DD	imagerel ??$_Pop_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
	DD	imagerel ??$_Pop_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+44
	DD	imagerel $unwind$??$_Pop_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Pop_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Guess_median_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD 021H
	DD	imagerel ??$_Guess_median_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
	DD	imagerel ??$_Guess_median_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+33
	DD	imagerel $unwind$??$_Guess_median_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Guess_median_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD 021H
	DD	imagerel ??$_Guess_median_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+33
	DD	imagerel ??$_Guess_median_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+42
	DD	imagerel $chain$0$??$_Guess_median_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Guess_median_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD 020421H
	DD	07404H
	DD	imagerel ??$_Guess_median_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+33
	DD	imagerel ??$_Guess_median_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+42
	DD	imagerel $chain$0$??$_Guess_median_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Guess_median_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD 020521H
	DD	053405H
	DD	imagerel ??$_Guess_median_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
	DD	imagerel ??$_Guess_median_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+33
	DD	imagerel $unwind$??$_Guess_median_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Guess_median_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove@PEAUCrcEntry@ResTableFile@@PEAU12@@std@@YAPEAUCrcEntry@ResTableFile@@PEAU12@00@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
;	COMDAT ?SetFileSize@ResTableFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
Key$GSCopy$ = 72
__$ArrayPad$ = 80
this$ = 144
Key$ = 152
Value$ = 160
?SetFileSize@ResTableFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z PROC ; ResTableFile::SetFileSize, COMDAT

; 81   : {

$LN84:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r12d, r8d
	mov	rdi, rdx
	mov	r15, rcx

; 78   : }
; 79   : 
; 80   : void ResTableFile::SetFileSize(std::string Key, uint32_t Value)

	mov	QWORD PTR Key$GSCopy$[rsp], rdx

; 82   :     for (ResTableFile::NameEntry& NameEntry : this->m_NameEntries)

	mov	rbx, QWORD PTR [rcx+48]
	mov	rsi, QWORD PTR [rcx+56]
	cmp	rbx, rsi
	je	SHORT $LN3@SetFileSiz
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rbp, QWORD PTR [rdx+24]

; 4584 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	r14, QWORD PTR [rdx+16]
	npad	8
$LL4@SetFileSiz:

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rdx, rdi

; 2236 :         if (_Large_string_engaged()) {

	cmp	rbp, 16
	jb	SHORT $LN14@SetFileSiz

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdi]
$LN14@SetFileSiz:

; 4584 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	r8, QWORD PTR [rbx+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rbx

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rbx+24], 16
	jb	SHORT $LN19@SetFileSiz

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rbx]
$LN19@SetFileSiz:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	r8, r14
	jne	SHORT $LN25@SetFileSiz

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	je	$LN68@SetFileSiz
$LN25@SetFileSiz:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 82   :     for (ResTableFile::NameEntry& NameEntry : this->m_NameEntries)

	add	rbx, 40					; 00000028H
	cmp	rbx, rsi
	jne	SHORT $LL4@SetFileSiz
$LN3@SetFileSiz:

; 88   :         }
; 89   :     }
; 90   :     this->SetFileSize(this->GenerateCrc32Hash(Key), Value);

	mov	rdx, rdi
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	r8, rax

; 33   :     uint32_t CRC = 0xFFFFFFFF;

	mov	ebx, -1					; ffffffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r10, rax

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rax+24], 16
	jb	SHORT $LN40@SetFileSiz

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r10, QWORD PTR [rax]
$LN40@SetFileSiz:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 35   :     for (size_t i = 0; i < Key.length(); ++i)

	mov	r9, QWORD PTR [rax+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4107 :         return _Mypair._Myval2._Myptr();

	xor	edx, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 35   :     for (size_t i = 0; i < Key.length(); ++i)

	test	r9, r9
	je	SHORT $LN34@SetFileSiz
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r11, QWORD PTR [r15]
	npad	8
$LL35@SetFileSiz:
	movzx	ecx, BYTE PTR [r10+rdx]
	mov	eax, ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 37   :         CRC = this->m_CrcTable[(CRC ^ u[i]) & 0xFF] ^ (CRC >> 8);

	xor	rcx, rax
	movzx	eax, cl
	shr	ebx, 8
	xor	ebx, DWORD PTR [r11+rax*4]

; 35   :     for (size_t i = 0; i < Key.length(); ++i)

	inc	rdx
	cmp	rdx, r9
	jb	SHORT $LL35@SetFileSiz
$LN34@SetFileSiz:

; 38   :     }
; 39   :     return CRC ^ 0xFFFFFFFF;

	not	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, r8
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 68   :     for (ResTableFile::CrcEntry& CrcEntry : this->m_CrcEntries)

	lea	rcx, QWORD PTR [r15+24]
	mov	rax, QWORD PTR [rcx]
	mov	rdx, QWORD PTR [rcx+8]
	cmp	rax, rdx
	je	SHORT $LN51@SetFileSiz
$LL52@SetFileSiz:

; 69   :     {
; 70   :         if (CrcEntry.Hash == Hash)

	cmp	DWORD PTR [rax], ebx
	je	SHORT $LN69@SetFileSiz

; 68   :     for (ResTableFile::CrcEntry& CrcEntry : this->m_CrcEntries)

	add	rax, 8
	cmp	rax, rdx
	jne	SHORT $LL52@SetFileSiz
$LN51@SetFileSiz:

; 74   :         }
; 75   :     }
; 76   : 
; 77   :     this->m_CrcEntries.push_back({ Hash, Value });

	mov	DWORD PTR $T1[rsp], ebx
	mov	DWORD PTR $T1[rsp+4], r12d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	cmp	rdx, QWORD PTR [rcx+16]
	je	SHORT $LN58@SetFileSiz

; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	rax, QWORD PTR $T1[rsp]
	mov	QWORD PTR [rdx], rax

; 798  :         } else {
; 799  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 800  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 801  :             _ASAN_VECTOR_RELEASE_GUARD;
; 802  :         }
; 803  : 
; 804  :         _Orphan_range(_Mylast, _Mylast);
; 805  :         _Ty& _Result = *_Mylast;
; 806  :         ++_Mylast;

	add	QWORD PTR [rcx+8], 8

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN57@SetFileSiz
$LN68@SetFileSiz:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 86   :             NameEntry.Size = Value;

	mov	DWORD PTR [rbx+32], r12d

; 87   :             return;

	jmp	SHORT $LN57@SetFileSiz
$LN69@SetFileSiz:

; 72   :             CrcEntry.Size = Value;

	mov	DWORD PTR [rax+4], r12d

; 73   :             return;

	jmp	SHORT $LN57@SetFileSiz
$LN58@SetFileSiz:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T1[rsp]
	call	??$_Emplace_reallocate@UCrcEntry@ResTableFile@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAPEAUCrcEntry@ResTableFile@@QEAU23@$$QEAU23@@Z ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::_Emplace_reallocate<ResTableFile::CrcEntry>
	npad	1
$LN57@SetFileSiz:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 91   : }

	mov	rcx, rdi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+96]
	mov	rbx, QWORD PTR [r11+64]
	mov	rbp, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	ret	0
?SetFileSize@ResTableFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z ENDP ; ResTableFile::SetFileSize
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
Key$GSCopy$ = 72
__$ArrayPad$ = 80
this$ = 144
Key$ = 152
Value$ = 160
?dtor$0@?0??SetFileSize@ResTableFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z@4HA PROC ; `ResTableFile::SetFileSize'::`1'::dtor$0
	mov	rcx, QWORD PTR Key$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??SetFileSize@ResTableFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z@4HA ENDP ; `ResTableFile::SetFileSize'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
;	COMDAT ?ToBinary@ResTableFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ
_TEXT	SEGMENT
$T2 = 32
__$ReturnUdt$GSCopy$ = 40
CrcEntry$3 = 40
Writer$ = 56
NameEntry$4 = 88
__$ArrayPad$ = 128
this$ = 208
__$ReturnUdt$ = 216
?ToBinary@ResTableFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ PROC ; ResTableFile::ToBinary, COMDAT

; 163  : {

$LN345:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-39]
	sub	rsp, 144				; 00000090H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-105], rax
	mov	r15, rdx
	mov	r14, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rbp-105], rdx
	xor	r13d, r13d
	xorps	xmm0, xmm0
	movups	XMMWORD PTR Writer$[rbp-89], xmm0
	xorps	xmm1, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR Writer$[rbp-105], xmm1
	mov	QWORD PTR Writer$[rbp-89], r13
	mov	DWORD PTR Writer$[rbp-81], r13d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 46   : 		this->m_Data.resize(this->m_Data.size() + strlen(Bytes));

	lea	edx, QWORD PTR [r13+6]
	lea	rcx, QWORD PTR Writer$[rbp-105]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	mov	r9d, r13d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 163  : {

	lea	r8, OFFSET FLAT:??_C@_06JNECDHIJ@RESTBL@+1
	mov	eax, DWORD PTR Writer$[rbp-81]
	npad	8
$LL177@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8-1]
	mov	rax, QWORD PTR Writer$[rbp-105]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-81]
	inc	eax
	mov	DWORD PTR Writer$[rbp-81], eax

; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8]
	mov	rax, QWORD PTR Writer$[rbp-105]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-81]
	inc	eax
	mov	DWORD PTR Writer$[rbp-81], eax

; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-105]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-81]
	inc	eax
	mov	DWORD PTR Writer$[rbp-81], eax

; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR Writer$[rbp-105]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-81]
	inc	eax
	mov	DWORD PTR Writer$[rbp-81], eax

; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+3]
	mov	rax, QWORD PTR Writer$[rbp-105]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-81]
	inc	eax
	mov	DWORD PTR Writer$[rbp-81], eax

; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movzx	edx, BYTE PTR [r8+4]
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-105]
	mov	BYTE PTR [rcx+rax], dl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-81]
	inc	eax
	mov	DWORD PTR Writer$[rbp-81], eax

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	add	r9d, 6
	lea	r8, QWORD PTR [r8+6]
	cmp	r9d, 6
	jb	$LL177@ToBinary
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 167  :     Writer.WriteInteger(this->m_Header.Version, sizeof(uint32_t)); //Version

	mov	ebx, DWORD PTR [r14+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-97]
	sub	rdx, QWORD PTR Writer$[rbp-105]
	add	eax, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN190@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-105]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN190@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 89   : 
; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], rbx

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-81]
	mov	rax, QWORD PTR Writer$[rbp-105]
	mov	BYTE PTR [rcx+rax], bl
	mov	eax, DWORD PTR Writer$[rbp-81]
	inc	eax
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-105]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR Writer$[rbp-81]
	add	eax, 2
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR Writer$[rbp-105]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r8+3]
	mov	eax, DWORD PTR Writer$[rbp-81]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-105]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	eax, DWORD PTR Writer$[rbp-81]
	add	eax, 4
	mov	DWORD PTR Writer$[rbp-81], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 168  :     Writer.WriteInteger(this->m_Header.StringBlockSize, sizeof(uint32_t)); //StringBlockSize

	mov	ebx, DWORD PTR [r14+76]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-97]
	sub	rdx, QWORD PTR Writer$[rbp-105]
	add	eax, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN204@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-105]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN204@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 89   : 
; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], rbx

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-81]
	mov	rax, QWORD PTR Writer$[rbp-105]
	mov	BYTE PTR [rcx+rax], bl
	mov	eax, DWORD PTR Writer$[rbp-81]
	inc	eax
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-105]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR Writer$[rbp-81]
	add	eax, 2
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR Writer$[rbp-105]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r8+3]
	mov	eax, DWORD PTR Writer$[rbp-81]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-105]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	eax, DWORD PTR Writer$[rbp-81]
	add	eax, 4
	mov	DWORD PTR Writer$[rbp-81], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rbx, QWORD PTR [r14+32]
	sub	rbx, QWORD PTR [r14+24]
	sar	rbx, 3
	mov	rdx, QWORD PTR Writer$[rbp-97]
	sub	rdx, QWORD PTR Writer$[rbp-105]
	add	eax, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN220@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-105]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN220@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 89   : 
; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], rbx

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-81]
	mov	rax, QWORD PTR Writer$[rbp-105]
	mov	BYTE PTR [rcx+rax], bl
	mov	eax, DWORD PTR Writer$[rbp-81]
	inc	eax
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-105]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR Writer$[rbp-81]
	add	eax, 2
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR Writer$[rbp-105]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r8+3]
	mov	eax, DWORD PTR Writer$[rbp-81]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-105]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	eax, DWORD PTR Writer$[rbp-81]
	add	eax, 4
	mov	DWORD PTR Writer$[rbp-81], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rbx, QWORD PTR [r14+56]
	sub	rbx, QWORD PTR [r14+48]
	sar	rbx, 3
	mov	rcx, -3689348814741910323		; cccccccccccccccdH
	imul	rbx, rcx
	mov	rdx, QWORD PTR Writer$[rbp-97]
	sub	rdx, QWORD PTR Writer$[rbp-105]
	add	eax, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN236@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-105]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN236@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 89   : 
; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], rbx

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-81]
	mov	rax, QWORD PTR Writer$[rbp-105]
	mov	BYTE PTR [rcx+rax], bl
	mov	eax, DWORD PTR Writer$[rbp-81]
	inc	eax
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-105]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR Writer$[rbp-81]
	add	eax, 2
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR Writer$[rbp-105]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r8+3]
	mov	eax, DWORD PTR Writer$[rbp-81]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-105]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	add	DWORD PTR Writer$[rbp-81], 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 43   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	rdx, QWORD PTR [r14+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8065 :     const auto _UFirst = _Get_unwrapped(_First);

	mov	rcx, QWORD PTR [r14+24]

; 8066 :     const auto _ULast  = _Get_unwrapped(_Last);
; 8067 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

	mov	r8, rdx
	sub	r8, rcx
	sar	r8, 3
	movzx	r9d, BYTE PTR $T2[rbp-105]
	call	??$_Sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0_JV<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z ; std::_Sort_unchecked<ResTableFile::CrcEntry *,`ResTableFile::ToBinary'::`2'::<lambda_1> >
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 174  :     for (ResTableFile::CrcEntry CrcEntry : this->m_CrcEntries)

	mov	rbx, QWORD PTR [r14+24]
	mov	rsi, QWORD PTR [r14+32]
	cmp	rbx, rsi
	je	$LN3@ToBinary
	mov	eax, DWORD PTR Writer$[rbp-81]
	npad	4
$LL4@ToBinary:
	mov	rdi, QWORD PTR [rbx]
	mov	QWORD PTR CrcEntry$3[rbp-105], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-97]
	sub	rdx, QWORD PTR Writer$[rbp-105]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	add	eax, 4
	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN139@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-105]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN139@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax
	mov	edx, edi

; 89   : 
; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], rdx

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-81]
	mov	rax, QWORD PTR Writer$[rbp-105]
	mov	BYTE PTR [rcx+rax], dl
	mov	eax, DWORD PTR Writer$[rbp-81]
	inc	eax
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-105]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR Writer$[rbp-81]
	add	eax, 2
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR Writer$[rbp-105]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r8+3]
	mov	eax, DWORD PTR Writer$[rbp-81]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-105]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	eax, DWORD PTR Writer$[rbp-81]
	add	eax, 4
	mov	DWORD PTR Writer$[rbp-81], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-97]
	sub	rdx, QWORD PTR Writer$[rbp-105]
	add	eax, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN153@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-105]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN153@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 89   : 
; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	edx, DWORD PTR CrcEntry$3[rbp-101]
	mov	QWORD PTR [rax], rdx

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-81]
	mov	rax, QWORD PTR Writer$[rbp-105]
	mov	BYTE PTR [rcx+rax], dl
	mov	eax, DWORD PTR Writer$[rbp-81]
	inc	eax
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-105]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR Writer$[rbp-81]
	add	eax, 2
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR Writer$[rbp-105]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r8+3]
	mov	eax, DWORD PTR Writer$[rbp-81]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-105]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	eax, DWORD PTR Writer$[rbp-81]
	add	eax, 4
	mov	DWORD PTR Writer$[rbp-81], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 174  :     for (ResTableFile::CrcEntry CrcEntry : this->m_CrcEntries)

	add	rbx, 8
	cmp	rbx, rsi
	jne	$LL4@ToBinary
$LN3@ToBinary:

; 180  :     for (ResTableFile::NameEntry NameEntry : this->m_NameEntries)

	mov	rdi, QWORD PTR [r14+48]
	mov	r12, QWORD PTR [r14+56]
	cmp	rdi, r12
	je	$LN6@ToBinary
	npad	2
$LL7@ToBinary:
	mov	rdx, rdi
	lea	rcx, QWORD PTR NameEntry$4[rbp-105]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	esi, DWORD PTR [rdi+32]
	mov	DWORD PTR NameEntry$4[rbp-73], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rbx, QWORD PTR NameEntry$4[rbp-105]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR NameEntry$4[rbp-81], 16
	cmovae	rbx, QWORD PTR NameEntry$4[rbp-105]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-97]
	sub	rdx, QWORD PTR Writer$[rbp-105]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 44   : 	if (this->m_Offset + strlen(Bytes) > this->m_Data.size())

	mov	rcx, -1
	npad	1
$LL336@ToBinary:
	inc	rcx
	cmp	BYTE PTR [rbx+rcx], 0
	jne	SHORT $LL336@ToBinary
	movsxd	r8, DWORD PTR Writer$[rbp-81]
	lea	rax, QWORD PTR [rcx+r8]
	cmp	rax, rdx
	jbe	SHORT $LN27@ToBinary

; 46   : 		this->m_Data.resize(this->m_Data.size() + strlen(Bytes));

	add	rdx, rcx
	lea	rcx, QWORD PTR Writer$[rbp-105]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	r8d, DWORD PTR Writer$[rbp-81]
$LN27@ToBinary:

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	mov	r9d, r13d
	mov	rax, -1
$LL335@ToBinary:
	inc	rax
	cmp	BYTE PTR [rbx+rax], r9b
	jne	SHORT $LL335@ToBinary
	test	rax, rax
	je	SHORT $LN340@ToBinary
	mov	r10, rbx
$LL26@ToBinary:

; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movzx	edx, BYTE PTR [r10]
	movsxd	rcx, r8d
	mov	rax, QWORD PTR Writer$[rbp-105]
	mov	BYTE PTR [rcx+rax], dl

; 51   : 		this->m_Offset++;

	mov	r8d, DWORD PTR Writer$[rbp-81]
	inc	r8d
	mov	DWORD PTR Writer$[rbp-81], r8d

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	inc	r9d
	lea	r10, QWORD PTR [r10+1]
	mov	rax, -1
	npad	8
$LL334@ToBinary:
	inc	rax
	cmp	BYTE PTR [rbx+rax], 0
	jne	SHORT $LL334@ToBinary
	movsxd	rcx, r9d
	cmp	rcx, rax
	jb	SHORT $LL26@ToBinary
$LN340@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 183  :         Writer.Seek(this->m_Header.StringBlockSize - NameEntry.Name.length(), BinaryVectorWriter::Position::Current);

	mov	ebx, DWORD PTR [r14+76]
	sub	ebx, DWORD PTR NameEntry$4[rbp-89]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR Writer$[rbp-97]
	sub	rcx, QWORD PTR Writer$[rbp-105]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 30   : 		if (this->m_Offset + Offset >= this->m_Data.size())

	lea	edx, DWORD PTR [r8+rbx]
	movsxd	rax, edx
	cmp	rax, rcx
	jb	SHORT $LN41@ToBinary

; 31   : 		{
; 32   : 			this->m_Data.resize(Offset + this->m_Offset + 1);

	lea	eax, DWORD PTR [rdx+1]
	movsxd	rdx, eax
	lea	rcx, QWORD PTR Writer$[rbp-105]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	r8d, DWORD PTR Writer$[rbp-81]
$LN41@ToBinary:

; 33   : 		}
; 34   : 		this->m_Offset += Offset;

	add	r8d, ebx
	mov	DWORD PTR Writer$[rbp-81], r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 184  :         Writer.WriteInteger(NameEntry.Size, sizeof(uint32_t));

	mov	rbx, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-97]
	sub	rdx, QWORD PTR Writer$[rbp-105]
	lea	eax, DWORD PTR [r8+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN54@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-105]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN54@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 89   : 
; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], rbx

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-81]
	mov	rax, QWORD PTR Writer$[rbp-105]
	mov	BYTE PTR [rcx+rax], bl
	mov	eax, DWORD PTR Writer$[rbp-81]
	inc	eax
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-105]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR Writer$[rbp-81]
	add	eax, 2
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR Writer$[rbp-105]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r8+3]
	mov	eax, DWORD PTR Writer$[rbp-81]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-105]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	add	DWORD PTR Writer$[rbp-81], 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR NameEntry$4[rbp-105]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 180  :     for (ResTableFile::NameEntry NameEntry : this->m_NameEntries)

	add	rdi, 40					; 00000028H
	cmp	rdi, r12
	jne	$LL7@ToBinary
$LN6@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [r15], r13
	mov	QWORD PTR [r15+8], r13
	mov	QWORD PTR [r15+16], r13

; 685  :         const auto _Count       = static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-97]
	mov	rcx, QWORD PTR Writer$[rbp-105]
	sub	rdx, rcx

; 2065 :         if (_Count != 0) {

	je	SHORT $LN101@ToBinary

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	rdx, rax
	ja	$LN343@ToBinary

; 2008 :         }
; 2009 : 
; 2010 :         _Buy_raw(_Newcapacity);

	mov	rcx, r15
	call	?_Buy_raw@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy_raw

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rsi, QWORD PTR [r15]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1825 :     auto _UFirst = _RANGES _Unwrap_iter<_Se>(_STD move(_First));

	mov	rdi, QWORD PTR Writer$[rbp-105]

; 1826 :     auto _ULast  = _RANGES _Unwrap_sent<_InIt>(_STD move(_Last));

	mov	rbx, QWORD PTR Writer$[rbp-97]
	mov	r8, rbx
	sub	r8, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rdi
	mov	rcx, rsi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1844 :                 _Dest += _ULast - _UFirst;

	sub	rbx, rdi
	lea	rax, QWORD PTR [rbx+rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	QWORD PTR [r15+8], rax
	mov	rcx, QWORD PTR Writer$[rbp-105]
$LN101@ToBinary:

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	test	rcx, rcx
	je	SHORT $LN111@ToBinary

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR Writer$[rbp-89]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN129@ToBinary

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN129@ToBinary
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN129@ToBinary:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN111@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 187  :     return Writer.GetData();

	mov	rax, r15

; 188  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-105]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+224]
	add	rsp, 144				; 00000090H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN343@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
	npad	1
$LN341@ToBinary:
?ToBinary@ResTableFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ ENDP ; ResTableFile::ToBinary
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 32
__$ReturnUdt$GSCopy$ = 40
CrcEntry$3 = 40
Writer$ = 56
NameEntry$4 = 88
__$ArrayPad$ = 128
this$ = 208
__$ReturnUdt$ = 216
?dtor$0@?0??ToBinary@ResTableFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@4HA PROC ; `ResTableFile::ToBinary'::`1'::dtor$0
	lea	rcx, QWORD PTR Writer$[rdx]
	jmp	??1BinaryVectorWriter@@QEAA@XZ
?dtor$0@?0??ToBinary@ResTableFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@4HA ENDP ; `ResTableFile::ToBinary'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 32
__$ReturnUdt$GSCopy$ = 40
CrcEntry$3 = 40
Writer$ = 56
NameEntry$4 = 88
__$ArrayPad$ = 128
this$ = 208
__$ReturnUdt$ = 216
?dtor$1@?0??ToBinary@ResTableFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@4HA PROC ; `ResTableFile::ToBinary'::`1'::dtor$1
	lea	rcx, QWORD PTR NameEntry$4[rdx]
	jmp	??1NameEntry@ResTableFile@@QEAA@XZ
?dtor$1@?0??ToBinary@ResTableFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@4HA ENDP ; `ResTableFile::ToBinary'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
;	COMDAT ??0ResTableFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z
_TEXT	SEGMENT
$T3 = 32
$T4 = 32
$T5 = 40
$T6 = 72
this$GSCopy$ = 112
Data$GSCopy$ = 136
NameEntry$7 = 144
__$ArrayPad$ = 184
this$ = 256
Data$ = 264
??0ResTableFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z PROC ; ResTableFile::ResTableFile, COMDAT

; 94   : {

$LN485:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-39]
	sub	rsp, 192				; 000000c0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-153], rax
	mov	r14, rdx
	mov	rsi, rcx

; 28   :     }
; 29   : }
; 30   : 
; 31   : uint32_t ResTableFile::GenerateCrc32Hash(std::string Key)
; 32   : {
; 33   :     uint32_t CRC = 0xFFFFFFFF;
; 34   :     const uint8_t* u = reinterpret_cast<const uint8_t*>(Key.c_str());
; 35   :     for (size_t i = 0; i < Key.length(); ++i)
; 36   :     {
; 37   :         CRC = this->m_CrcTable[(CRC ^ u[i]) & 0xFF] ^ (CRC >> 8);
; 38   :     }
; 39   :     return CRC ^ 0xFFFFFFFF;
; 40   : }
; 41   : 
; 42   : uint32_t ResTableFile::GetFileSize(uint32_t Hash)
; 43   : {
; 44   :     for (ResTableFile::CrcEntry& CrcEntry : this->m_CrcEntries)
; 45   :     {
; 46   :         if (CrcEntry.Hash == Hash)
; 47   :         {
; 48   :             return CrcEntry.Size;
; 49   :         }
; 50   :     }
; 51   :     return 0;
; 52   : }
; 53   : 
; 54   : uint32_t ResTableFile::GetFileSize(std::string Key)
; 55   : {
; 56   :     for (ResTableFile::NameEntry& NameEntry : this->m_NameEntries)
; 57   :     {
; 58   :         if (NameEntry.Name == Key)
; 59   :         {
; 60   :             return NameEntry.Size;
; 61   :         }
; 62   :     }
; 63   :     return this->GetFileSize(this->GenerateCrc32Hash(Key));
; 64   : }
; 65   : 
; 66   : void ResTableFile::SetFileSize(uint32_t Hash, uint32_t Value)
; 67   : {
; 68   :     for (ResTableFile::CrcEntry& CrcEntry : this->m_CrcEntries)
; 69   :     {
; 70   :         if (CrcEntry.Hash == Hash)
; 71   :         {
; 72   :             CrcEntry.Size = Value;
; 73   :             return;
; 74   :         }
; 75   :     }
; 76   : 
; 77   :     this->m_CrcEntries.push_back({ Hash, Value });
; 78   : }
; 79   : 
; 80   : void ResTableFile::SetFileSize(std::string Key, uint32_t Value)
; 81   : {
; 82   :     for (ResTableFile::NameEntry& NameEntry : this->m_NameEntries)
; 83   :     {
; 84   :         if (NameEntry.Name == Key)
; 85   :         {
; 86   :             NameEntry.Size = Value;
; 87   :             return;
; 88   :         }
; 89   :     }
; 90   :     this->SetFileSize(this->GenerateCrc32Hash(Key), Value);
; 91   : }
; 92   : 
; 93   : ResTableFile::ResTableFile(std::vector<unsigned char> Data)

	mov	QWORD PTR this$GSCopy$[rbp-153], rcx
	mov	QWORD PTR Data$GSCopy$[rbp-153], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	r12d, r12d
	mov	QWORD PTR [rcx], r12
	mov	QWORD PTR [rcx+8], r12
	mov	QWORD PTR [rcx+16], r12
	mov	QWORD PTR [rcx+24], r12
	mov	QWORD PTR [rcx+32], r12
	mov	QWORD PTR [rcx+40], r12
	mov	QWORD PTR [rcx+48], r12
	mov	QWORD PTR [rcx+56], r12
	mov	QWORD PTR [rcx+64], r12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 12   :     this->m_CrcTable.resize(256);

	mov	edx, 256				; 00000100H
	call	?resize@?$vector@IV?$allocator@I@std@@@std@@QEAAX_K@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::resize

; 28   :     }
; 29   : }
; 30   : 
; 31   : uint32_t ResTableFile::GenerateCrc32Hash(std::string Key)
; 32   : {
; 33   :     uint32_t CRC = 0xFFFFFFFF;
; 34   :     const uint8_t* u = reinterpret_cast<const uint8_t*>(Key.c_str());
; 35   :     for (size_t i = 0; i < Key.length(); ++i)
; 36   :     {
; 37   :         CRC = this->m_CrcTable[(CRC ^ u[i]) & 0xFF] ^ (CRC >> 8);
; 38   :     }
; 39   :     return CRC ^ 0xFFFFFFFF;
; 40   : }
; 41   : 
; 42   : uint32_t ResTableFile::GetFileSize(uint32_t Hash)
; 43   : {
; 44   :     for (ResTableFile::CrcEntry& CrcEntry : this->m_CrcEntries)
; 45   :     {
; 46   :         if (CrcEntry.Hash == Hash)
; 47   :         {
; 48   :             return CrcEntry.Size;
; 49   :         }
; 50   :     }
; 51   :     return 0;
; 52   : }
; 53   : 
; 54   : uint32_t ResTableFile::GetFileSize(std::string Key)
; 55   : {
; 56   :     for (ResTableFile::NameEntry& NameEntry : this->m_NameEntries)
; 57   :     {
; 58   :         if (NameEntry.Name == Key)
; 59   :         {
; 60   :             return NameEntry.Size;
; 61   :         }
; 62   :     }
; 63   :     return this->GetFileSize(this->GenerateCrc32Hash(Key));
; 64   : }
; 65   : 
; 66   : void ResTableFile::SetFileSize(uint32_t Hash, uint32_t Value)
; 67   : {
; 68   :     for (ResTableFile::CrcEntry& CrcEntry : this->m_CrcEntries)
; 69   :     {
; 70   :         if (CrcEntry.Hash == Hash)
; 71   :         {
; 72   :             CrcEntry.Size = Value;
; 73   :             return;
; 74   :         }
; 75   :     }
; 76   : 
; 77   :     this->m_CrcEntries.push_back({ Hash, Value });
; 78   : }
; 79   : 
; 80   : void ResTableFile::SetFileSize(std::string Key, uint32_t Value)
; 81   : {
; 82   :     for (ResTableFile::NameEntry& NameEntry : this->m_NameEntries)
; 83   :     {
; 84   :         if (NameEntry.Name == Key)
; 85   :         {
; 86   :             NameEntry.Size = Value;
; 87   :             return;
; 88   :         }
; 89   :     }
; 90   :     this->SetFileSize(this->GenerateCrc32Hash(Key), Value);
; 91   : }
; 92   : 
; 93   : ResTableFile::ResTableFile(std::vector<unsigned char> Data)

	mov	r8d, r12d
	mov	r9d, r12d
	npad	2
$LL112@ResTableFi:

; 18   :             if (c & 1)

	mov	ecx, r8d
	shr	ecx, 1
	mov	edx, ecx
	xor	edx, -306674912				; edb88320H
	test	r8b, 1
	cmove	edx, ecx
	mov	eax, edx
	shr	eax, 1
	mov	ecx, eax
	xor	ecx, -306674912				; edb88320H
	test	dl, 1
	cmove	ecx, eax
	mov	eax, ecx
	shr	eax, 1
	mov	edx, eax
	xor	edx, -306674912				; edb88320H
	test	cl, 1
	cmove	edx, eax
	mov	eax, edx
	shr	eax, 1
	mov	ecx, eax
	xor	ecx, -306674912				; edb88320H
	test	dl, 1
	cmove	ecx, eax
	mov	eax, ecx
	shr	eax, 1
	mov	edx, eax
	xor	edx, -306674912				; edb88320H
	test	cl, 1
	cmove	edx, eax
	mov	eax, edx
	shr	eax, 1
	mov	ecx, eax
	xor	ecx, -306674912				; edb88320H
	test	dl, 1
	cmove	ecx, eax
	mov	eax, ecx
	shr	eax, 1
	mov	edx, eax
	xor	edx, -306674912				; edb88320H
	test	cl, 1
	cmove	edx, eax
	mov	eax, edx
	shr	eax, 1
	mov	ecx, eax
	xor	ecx, -306674912				; edb88320H
	test	dl, 1
	cmove	ecx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rsi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 27   :         this->m_CrcTable[i] = c;

	mov	DWORD PTR [r9+rax], ecx

; 13   :     for (uint32_t i = 0; i < 256; i++)

	inc	r8d
	lea	r9, QWORD PTR [r9+4]
	cmp	r8d, 256				; 00000100H
	jb	$LL112@ResTableFi
	mov	rdx, QWORD PTR [r14]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 38   : 		Data[i] = this->m_Bytes[this->m_Offset];

	cmp	BYTE PTR [rdx], 82			; 00000052H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 102  :     if (Magic[0] != 'R' || Magic[1] != 'E' || Magic[2] != 'S' || Magic[3] != 'T' || Magic[4] != 'B' || Magic[5] != 'L')

	jne	$LN12@ResTableFi
	cmp	BYTE PTR [rdx+1], 69			; 00000045H
	jne	$LN12@ResTableFi
	cmp	BYTE PTR [rdx+2], 83			; 00000053H
	jne	$LN12@ResTableFi
	cmp	BYTE PTR [rdx+3], 84			; 00000054H
	jne	$LN12@ResTableFi
	cmp	BYTE PTR [rdx+4], 66			; 00000042H
	jne	$LN12@ResTableFi
	cmp	BYTE PTR [rdx+5], 76			; 0000004cH
	jne	$LN12@ResTableFi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movzx	ecx, BYTE PTR [rdx+8]
	shl	ecx, 8
	movzx	eax, BYTE PTR [rdx+7]
	or	ecx, eax
	shl	ecx, 8
	movzx	eax, BYTE PTR [rdx+9]
	shl	eax, 24
	or	ecx, eax
	movzx	eax, BYTE PTR [rdx+6]
	or	ecx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 108  :     this->m_Header.Version = Reader.ReadUInt32();

	mov	DWORD PTR [rsi+72], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [r14]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movzx	edx, BYTE PTR [rcx+12]
	shl	edx, 8
	movzx	eax, BYTE PTR [rcx+11]
	or	edx, eax
	shl	edx, 8
	movzx	eax, BYTE PTR [rcx+13]
	shl	eax, 24
	or	edx, eax
	movzx	eax, BYTE PTR [rcx+10]
	or	edx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 109  :     this->m_Header.StringBlockSize = Reader.ReadUInt32();

	mov	DWORD PTR [rsi+76], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rdx, QWORD PTR [r14]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movzx	ebx, BYTE PTR [rdx+16]
	shl	ebx, 8
	movzx	eax, BYTE PTR [rdx+15]
	or	ebx, eax
	shl	ebx, 8
	movzx	eax, BYTE PTR [rdx+17]
	shl	eax, 24
	or	ebx, eax
	movzx	eax, BYTE PTR [rdx+14]
	or	ebx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 110  :     this->m_Header.CrcMapCount = Reader.ReadUInt32();

	mov	DWORD PTR [rsi+80], ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 76   : 	this->m_Offset += 4;

	mov	edi, 21
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [r14]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movzx	edx, BYTE PTR [rcx+20]
	shl	edx, 8
	movzx	eax, BYTE PTR [rcx+19]
	or	edx, eax
	shl	edx, 8
	movzx	eax, BYTE PTR [rcx+21]
	shl	eax, 24
	or	edx, eax
	movzx	eax, BYTE PTR [rcx+18]
	or	edx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 111  :     this->m_Header.NameMapCount = Reader.ReadUInt32();

	mov	DWORD PTR [rsi+84], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rdx, QWORD PTR [rsi+24]
	mov	r12, QWORD PTR [rsi+32]
	mov	rcx, r12
	sub	rcx, rdx
	sar	rcx, 3

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rbx, rcx
	jae	SHORT $LN391@ResTableFi

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rax, QWORD PTR [rdx+rbx*8]

; 1563 :             _Mylast = _Newlast;

	mov	QWORD PTR [rsi+32], rax

; 1564 :             return;

	jmp	SHORT $LN392@ResTableFi
$LN391@ResTableFi:

; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN392@ResTableFi

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [rsi+40]
	sub	rax, rdx
	sar	rax, 3

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rbx, rax
	jbe	SHORT $LN393@ResTableFi

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rdx, rbx
	lea	rcx, QWORD PTR [rsi+24]
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::_Resize_reallocate<std::_Value_init_tag>

; 1571 :                 return;

	jmp	SHORT $LN392@ResTableFi
$LN393@ResTableFi:

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2041 :     for (; 0 < _Count; --_Count) {

	je	SHORT $LN398@ResTableFi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	lea	rbx, QWORD PTR [rbx*8]
	mov	r8, rbx
	xor	edx, edx
	mov	rcx, r12
	call	memset
	add	r12, rbx
$LN398@ResTableFi:
	mov	QWORD PTR [rsi+32], r12
$LN392@ResTableFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 114  :     for (int i = 0; i < this->m_Header.CrcMapCount; i++)

	xor	r12d, r12d
	mov	ebx, r12d
	cmp	DWORD PTR [rsi+80], r12d
	jbe	$LN3@ResTableFi
	npad	13
$LL4@ResTableFi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r11, QWORD PTR [r14]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movsxd	r10, edi
	lea	eax, DWORD PTR [rdi+3]
	movsxd	rdx, eax
	lea	eax, DWORD PTR [rdi+2]
	movsxd	rcx, eax
	lea	eax, DWORD PTR [rdi+1]
	movsxd	r8, eax
	movzx	r9d, BYTE PTR [rdx+r11]
	shl	r9d, 8
	movzx	eax, BYTE PTR [rcx+r11]
	or	r9d, eax
	shl	r9d, 8
	movzx	eax, BYTE PTR [r10+r11+4]
	shl	eax, 24
	or	r9d, eax
	movzx	eax, BYTE PTR [r8+r11]
	or	r9d, eax
	mov	DWORD PTR $T3[rbp-153], r9d

; 76   : 	this->m_Offset += 4;

	add	edi, 8

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movsxd	rax, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	rcx, QWORD PTR [r11+rax]
	lea	rdx, QWORD PTR [rax+r11]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movzx	r8d, BYTE PTR [rax+r11-1]
	shl	r8d, 8
	movzx	eax, BYTE PTR [rax+r11-2]
	or	r8d, eax
	shl	r8d, 8
	movzx	eax, BYTE PTR [rcx]
	shl	eax, 24
	or	r8d, eax
	movzx	eax, BYTE PTR [rdx-3]
	or	r8d, eax
	mov	DWORD PTR $T3[rbp-149], r8d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [rsi+24]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 116  :         this->m_CrcEntries[i] = { Reader.ReadUInt32(), Reader.ReadUInt32() };

	mov	rax, QWORD PTR $T3[rbp-153]
	mov	QWORD PTR [rcx+r12], rax

; 114  :     for (int i = 0; i < this->m_Header.CrcMapCount; i++)

	inc	ebx
	lea	r12, QWORD PTR [r12+8]
	cmp	ebx, DWORD PTR [rsi+80]
	jb	$LL4@ResTableFi
	xor	r12d, r12d
$LN3@ResTableFi:

; 117  :     }
; 118  : 
; 119  :     this->m_NameEntries.resize(this->m_Header.NameMapCount);

	mov	ecx, DWORD PTR [rsi+84]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rbx, QWORD PTR [rsi+56]
	mov	r8, QWORD PTR [rsi+48]
	mov	rdx, rbx
	sub	rdx, r8
	sar	rdx, 3
	mov	r9, -3689348814741910323		; cccccccccccccccdH
	imul	rdx, r9

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rcx, rdx
	jae	SHORT $LN233@ResTableFi

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rax, QWORD PTR [rcx+rcx*4]
	lea	r15, QWORD PTR [r8+rax*8]

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rdi, r15
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	r15, rbx
	je	SHORT $LN239@ResTableFi
$LL240@ResTableFi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rdi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rdi, 40					; 00000028H
	cmp	rdi, rbx
	jne	SHORT $LL240@ResTableFi
$LN239@ResTableFi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1563 :             _Mylast = _Newlast;

	mov	QWORD PTR [rsi+56], r15

; 1564 :             return;

	jmp	SHORT $LN234@ResTableFi
$LN233@ResTableFi:

; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN234@ResTableFi

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [rsi+64]
	sub	rax, r8
	sar	rax, 3
	imul	rax, r9

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rcx, rax
	jbe	SHORT $LN235@ResTableFi

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rdx, rcx
	lea	rcx, QWORD PTR [rsi+48]
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::_Resize_reallocate<std::_Value_init_tag>

; 1571 :                 return;

	jmp	SHORT $LN234@ResTableFi
$LN235@ResTableFi:

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rcx, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2041 :     for (; 0 < _Count; --_Count) {

	je	SHORT $LN257@ResTableFi
	npad	11
$LL258@ResTableFi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR [rbx+32], r12
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rbx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], r12

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rbx, 40					; 00000028H

; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rcx, 1
	jne	SHORT $LL258@ResTableFi
$LN257@ResTableFi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	mov	QWORD PTR [rsi+56], rbx
$LN234@ResTableFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 120  :     for (int i = 0; i < this->m_Header.NameMapCount; i++)

	mov	r15d, r12d
	cmp	DWORD PTR [rsi+84], 0
	jbe	$LN6@ResTableFi
	npad	12
$LL7@ResTableFi:

; 121  :     {
; 122  :         uint32_t Offset = 22 + (this->m_Header.CrcMapCount * 8) + ((this->m_Header.StringBlockSize + 4) * i);

	mov	edx, DWORD PTR [rsi+76]
	lea	ecx, DWORD PTR [rdx+4]
	imul	ecx, r15d
	mov	eax, DWORD PTR [rsi+80]
	lea	ebx, DWORD PTR [rax*8+21]
	add	ebx, ecx
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR NameEntry$7[rbp-153], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR NameEntry$7[rbp-137], 0

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	r11d, 15
	mov	QWORD PTR NameEntry$7[rbp-129], r11

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR NameEntry$7[rbp-153], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 125  :         for (int j = 0; j < this->m_Header.StringBlockSize; j++)

	xor	edi, edi
	test	edx, edx
	je	SHORT $LN9@ResTableFi
	npad	7
$LL10@ResTableFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 50   : 	this->m_Offset++;

	movsxd	r9, ebx
	inc	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r14]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 51   : 	return this->m_Bytes[this->m_Offset];

	movzx	r9d, BYTE PTR [r9+rax+1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 128  :             if (Character != 0x00)

	test	r9b, r9b
	je	SHORT $LN8@ResTableFi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4046 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR NameEntry$7[rbp-137]
	cmp	rcx, r11

; 4047 :         if (_Old_size < _Mypair._Myval2._Myres) {

	jae	SHORT $LN157@ResTableFi

; 4048 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 4049 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR NameEntry$7[rbp-137], rax

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR NameEntry$7[rbp-153]

; 2227 :         if (_Large_string_engaged()) {

	cmp	r11, 16
	cmovae	rax, QWORD PTR NameEntry$7[rbp-153]

; 4051 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	BYTE PTR [rax+rcx], r9b

; 4052 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [rax+rcx+1], 0

; 4053 :             return;

	jmp	SHORT $LN482@ResTableFi
$LN157@ResTableFi:

; 4054 :         }
; 4055 : 
; 4056 :         _Reallocate_grow_by(

	lea	rcx, QWORD PTR NameEntry$7[rbp-153]
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
$LN482@ResTableFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 125  :         for (int j = 0; j < this->m_Header.StringBlockSize; j++)

	mov	r11, QWORD PTR NameEntry$7[rbp-129]
$LN8@ResTableFi:
	inc	edi
	cmp	edi, DWORD PTR [rsi+76]
	jb	SHORT $LL10@ResTableFi
$LN9@ResTableFi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r8, QWORD PTR [r14]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movsxd	r10, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	r10, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	lea	eax, DWORD PTR [rbx+3]
	movsxd	rdx, eax
	lea	eax, DWORD PTR [rbx+2]
	movsxd	rcx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rcx, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	lea	eax, DWORD PTR [rbx+1]
	movsxd	r9, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	r9, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movzx	r8d, BYTE PTR [rdx+r8]
	shl	r8d, 8
	movzx	eax, BYTE PTR [rcx]
	or	r8d, eax
	shl	r8d, 8
	movzx	eax, BYTE PTR [r10+4]
	shl	eax, 24
	or	r8d, eax
	movzx	eax, BYTE PTR [r9]
	or	r8d, eax
	mov	DWORD PTR NameEntry$7[rbp-121], r8d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rbx, QWORD PTR [rsi+48]
	add	rbx, r12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3156 :         if (this == _STD addressof(_Right)) {

	lea	rax, QWORD PTR NameEntry$7[rbp-153]
	cmp	rbx, rax
	je	SHORT $LN50@ResTableFi

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR NameEntry$7[rbp-153]

; 2236 :         if (_Large_string_engaged()) {

	cmp	r11, 16
	cmovae	rdx, QWORD PTR NameEntry$7[rbp-153]

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR NameEntry$7[rbp-137]
	mov	rcx, rbx
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	r8d, DWORD PTR NameEntry$7[rbp-121]
$LN50@ResTableFi:
	mov	DWORD PTR [rbx+32], r8d

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR NameEntry$7[rbp-153]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 120  :     for (int i = 0; i < this->m_Header.NameMapCount; i++)

	inc	r15d
	add	r12, 40					; 00000028H
	cmp	r15d, DWORD PTR [rsi+84]
	jb	$LL7@ResTableFi

; 16   :         for (size_t j = 0; j < 8; j++)

	xor	r12d, r12d
	jmp	SHORT $LN6@ResTableFi
$LN12@ResTableFi:

; 104  :         Logger::Error("ResTblDecoder", "Wrong magic, expected RESTBL");

	lea	rax, QWORD PTR $T5[rbp-153]
	mov	QWORD PTR $T4[rbp-153], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T5[rbp-153], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T5[rbp-137], r12

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T5[rbp-129], r12

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 28
	lea	rdx, OFFSET FLAT:??_C@_0BN@EAHPGPFO@Wrong?5magic?0?5expected?5RESTBL@
	lea	rcx, QWORD PTR $T5[rbp-153]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T6[rbp-153], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T6[rbp-137], r12

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T6[rbp-129], r12

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 13
	lea	rdx, OFFSET FLAT:??_C@_0O@JABPLMM@ResTblDecoder@
	lea	rcx, QWORD PTR $T6[rbp-153]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 104  :         Logger::Error("ResTblDecoder", "Wrong magic, expected RESTBL");

	lea	rdx, QWORD PTR $T5[rbp-153]
	lea	rcx, QWORD PTR $T6[rbp-153]
	call	?Error@Logger@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; Logger::Error
	npad	1
$LN6@ResTableFi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [r14]
	test	rcx, rcx
	je	SHORT $LN67@ResTableFi

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [r14+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN85@ResTableFi

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN82@ResTableFi

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN85@ResTableFi:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	mov	QWORD PTR [r14], r12

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [r14+8], r12

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [r14+16], r12
$LN67@ResTableFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 136  : }

	mov	rax, rsi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp-153]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+272]
	add	rsp, 192				; 000000c0H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN82@ResTableFi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN481@ResTableFi:
??0ResTableFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z ENDP ; ResTableFile::ResTableFile
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T3 = 32
$T4 = 32
$T5 = 40
$T6 = 72
this$GSCopy$ = 112
Data$GSCopy$ = 136
NameEntry$7 = 144
__$ArrayPad$ = 184
this$ = 256
Data$ = 264
?dtor$0@?0???0ResTableFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA PROC ; `ResTableFile::ResTableFile'::`1'::dtor$0
	mov	rcx, QWORD PTR Data$GSCopy$[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$0@?0???0ResTableFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA ENDP ; `ResTableFile::ResTableFile'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T3 = 32
$T4 = 32
$T5 = 40
$T6 = 72
this$GSCopy$ = 112
Data$GSCopy$ = 136
NameEntry$7 = 144
__$ArrayPad$ = 184
this$ = 256
Data$ = 264
?dtor$1@?0???0ResTableFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA PROC ; `ResTableFile::ResTableFile'::`1'::dtor$1
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	jmp	??1?$vector@IV?$allocator@I@std@@@std@@QEAA@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
?dtor$1@?0???0ResTableFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA ENDP ; `ResTableFile::ResTableFile'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T3 = 32
$T4 = 32
$T5 = 40
$T6 = 72
this$GSCopy$ = 112
Data$GSCopy$ = 136
NameEntry$7 = 144
__$ArrayPad$ = 184
this$ = 256
Data$ = 264
?dtor$2@?0???0ResTableFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA PROC ; `ResTableFile::ResTableFile'::`1'::dtor$2
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 24
	jmp	??1?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAA@XZ ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::~vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >
?dtor$2@?0???0ResTableFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA ENDP ; `ResTableFile::ResTableFile'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T3 = 32
$T4 = 32
$T5 = 40
$T6 = 72
this$GSCopy$ = 112
Data$GSCopy$ = 136
NameEntry$7 = 144
__$ArrayPad$ = 184
this$ = 256
Data$ = 264
?dtor$3@?0???0ResTableFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA PROC ; `ResTableFile::ResTableFile'::`1'::dtor$3
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 48					; 00000030H
	jmp	??1?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAA@XZ ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::~vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >
?dtor$3@?0???0ResTableFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA ENDP ; `ResTableFile::ResTableFile'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T3 = 32
$T4 = 32
$T5 = 40
$T6 = 72
this$GSCopy$ = 112
Data$GSCopy$ = 136
NameEntry$7 = 144
__$ArrayPad$ = 184
this$ = 256
Data$ = 264
?dtor$4@?0???0ResTableFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA PROC ; `ResTableFile::ResTableFile'::`1'::dtor$4
	mov	rcx, QWORD PTR $T4[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0???0ResTableFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA ENDP ; `ResTableFile::ResTableFile'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T3 = 32
$T4 = 32
$T5 = 40
$T6 = 72
this$GSCopy$ = 112
Data$GSCopy$ = 136
NameEntry$7 = 144
__$ArrayPad$ = 184
this$ = 256
Data$ = 264
?dtor$6@?0???0ResTableFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA PROC ; `ResTableFile::ResTableFile'::`1'::dtor$6
	lea	rcx, QWORD PTR NameEntry$7[rdx]
	jmp	??1NameEntry@ResTableFile@@QEAA@XZ
?dtor$6@?0???0ResTableFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA ENDP ; `ResTableFile::ResTableFile'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
;	COMDAT ?GenerateCrcTable@ResTableFile@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?GenerateCrcTable@ResTableFile@@AEAAXXZ PROC		; ResTableFile::GenerateCrcTable, COMDAT

; 11   : {

$LN48:
	push	rbx
	sub	rsp, 32					; 00000020H

; 12   :     this->m_CrcTable.resize(256);

	mov	edx, 256				; 00000100H
	mov	rbx, rcx
	call	?resize@?$vector@IV?$allocator@I@std@@@std@@QEAAX_K@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::resize
	xor	r9d, r9d
	mov	r10d, r9d
	npad	7
$LL4@GenerateCr:

; 13   :     for (uint32_t i = 0; i < 256; i++)
; 14   :     {
; 15   :         uint32_t c = i;
; 16   :         for (size_t j = 0; j < 8; j++)
; 17   :         {
; 18   :             if (c & 1)

	mov	edx, r9d
	lea	r10, QWORD PTR [r10+4]
	shr	edx, 1
	mov	ecx, edx
	xor	ecx, -306674912				; edb88320H
	test	r9b, 1
	cmove	ecx, edx
	mov	eax, ecx
	shr	eax, 1
	mov	edx, eax
	xor	edx, -306674912				; edb88320H
	test	cl, 1
	cmove	edx, eax
	mov	eax, edx
	shr	eax, 1
	mov	ecx, eax
	xor	ecx, -306674912				; edb88320H
	test	dl, 1
	cmove	ecx, eax
	mov	eax, ecx
	shr	eax, 1
	mov	edx, eax
	xor	edx, -306674912				; edb88320H
	test	cl, 1
	cmove	edx, eax
	mov	eax, edx
	shr	eax, 1
	mov	ecx, eax
	xor	ecx, -306674912				; edb88320H
	test	dl, 1
	cmove	ecx, eax
	mov	eax, ecx
	shr	eax, 1
	mov	edx, eax
	xor	edx, -306674912				; edb88320H
	test	cl, 1
	cmove	edx, eax
	mov	eax, edx
	shr	eax, 1
	mov	r8d, eax
	xor	r8d, -306674912				; edb88320H
	test	dl, 1
	cmove	r8d, eax
	mov	eax, r8d
	shr	eax, 1
	mov	ecx, eax
	xor	ecx, -306674912				; edb88320H
	test	r8b, 1
	cmove	ecx, eax

; 19   :             {
; 20   :                 c = 0xEDB88320 ^ (c >> 1);
; 21   :             }
; 22   :             else
; 23   :             {
; 24   :                 c >>= 1;
; 25   :             }
; 26   :         }
; 27   :         this->m_CrcTable[i] = c;

	mov	rax, QWORD PTR [rbx]
	inc	r9d
	mov	DWORD PTR [r10+rax-4], ecx
	cmp	r9d, 256				; 00000100H
	jb	$LL4@GenerateCr

; 28   :     }
; 29   : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?GenerateCrcTable@ResTableFile@@AEAAXXZ ENDP		; ResTableFile::GenerateCrcTable
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
;	COMDAT ?GenerateCrc32Hash@ResTableFile@@QEAAIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
this$ = 48
Key$ = 56
?GenerateCrc32Hash@ResTableFile@@QEAAIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; ResTableFile::GenerateCrc32Hash, COMDAT

; 32   : {

$LN26:
	push	rbx
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 16
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 32   : {

	mov	r9, rdx

; 33   :     uint32_t CRC = 0xFFFFFFFF;

	mov	ebx, -1					; ffffffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r10, rdx

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN9@GenerateCr

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r10, QWORD PTR [rdx]
$LN9@GenerateCr:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 35   :     for (size_t i = 0; i < Key.length(); ++i)

	mov	r11, QWORD PTR [rdx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4107 :         return _Mypair._Myval2._Myptr();

	xor	r8d, r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 35   :     for (size_t i = 0; i < Key.length(); ++i)

	test	r11, r11
	je	SHORT $LN3@GenerateCr
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [rcx]
	npad	6
$LL4@GenerateCr:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 37   :         CRC = this->m_CrcTable[(CRC ^ u[i]) & 0xFF] ^ (CRC >> 8);

	movzx	edx, BYTE PTR [r10+r8]
	mov	eax, ebx
	xor	rdx, rax
	shr	ebx, 8
	movzx	eax, dl
	inc	r8
	xor	ebx, DWORD PTR [rcx+rax*4]
	cmp	r8, r11
	jb	SHORT $LL4@GenerateCr
$LN3@GenerateCr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, r9
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 39   :     return CRC ^ 0xFFFFFFFF;

	not	ebx
	mov	eax, ebx

; 40   : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?GenerateCrc32Hash@ResTableFile@@QEAAIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; ResTableFile::GenerateCrc32Hash
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
;	COMDAT ?SetFileSize@ResTableFile@@QEAAXII@Z
_TEXT	SEGMENT
$T1 = 48
this$ = 48
Hash$ = 56
Value$ = 64
?SetFileSize@ResTableFile@@QEAAXII@Z PROC		; ResTableFile::SetFileSize, COMDAT

; 67   : {

$LN20:
	sub	rsp, 40					; 00000028H

; 68   :     for (ResTableFile::CrcEntry& CrcEntry : this->m_CrcEntries)

	mov	rax, QWORD PTR [rcx+24]
	add	rcx, 24
	mov	r9d, edx
	mov	rdx, QWORD PTR [rcx+8]
	cmp	rax, rdx
	je	SHORT $LN3@SetFileSiz
$LL4@SetFileSiz:

; 69   :     {
; 70   :         if (CrcEntry.Hash == Hash)

	cmp	DWORD PTR [rax], r9d
	je	SHORT $LN15@SetFileSiz

; 68   :     for (ResTableFile::CrcEntry& CrcEntry : this->m_CrcEntries)

	add	rax, 8
	cmp	rax, rdx
	jne	SHORT $LL4@SetFileSiz
$LN3@SetFileSiz:

; 73   :             return;
; 74   :         }
; 75   :     }
; 76   : 
; 77   :     this->m_CrcEntries.push_back({ Hash, Value });

	mov	DWORD PTR $T1[rsp], r9d
	mov	DWORD PTR $T1[rsp+4], r8d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	cmp	rdx, QWORD PTR [rcx+16]
	je	SHORT $LN10@SetFileSiz

; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	rax, QWORD PTR $T1[rsp]
	mov	QWORD PTR [rdx], rax

; 798  :         } else {
; 799  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 800  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 801  :             _ASAN_VECTOR_RELEASE_GUARD;
; 802  :         }
; 803  : 
; 804  :         _Orphan_range(_Mylast, _Mylast);
; 805  :         _Ty& _Result = *_Mylast;
; 806  :         ++_Mylast;

	add	QWORD PTR [rcx+8], 8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 78   : }

	add	rsp, 40					; 00000028H
	ret	0
$LN15@SetFileSiz:

; 71   :         {
; 72   :             CrcEntry.Size = Value;

	mov	DWORD PTR [rax+4], r8d

; 78   : }

	add	rsp, 40					; 00000028H
	ret	0
$LN10@SetFileSiz:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T1[rsp]
	call	??$_Emplace_reallocate@UCrcEntry@ResTableFile@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAPEAUCrcEntry@ResTableFile@@QEAU23@$$QEAU23@@Z ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::_Emplace_reallocate<ResTableFile::CrcEntry>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 78   : }

	add	rsp, 40					; 00000028H
	ret	0
?SetFileSize@ResTableFile@@QEAAXII@Z ENDP		; ResTableFile::SetFileSize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??0NameEntry@ResTableFile@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0NameEntry@ResTableFile@@QEAA@XZ PROC			; ResTableFile::NameEntry::NameEntry, COMDAT
	xorps	xmm0, xmm0
	mov	rax, rcx

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], 0

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], 0
	ret	0
??0NameEntry@ResTableFile@@QEAA@XZ ENDP			; ResTableFile::NameEntry::NameEntry
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??4NameEntry@ResTableFile@@QEAAAEAU01@AEBU01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??4NameEntry@ResTableFile@@QEAAAEAU01@AEBU01@@Z PROC	; ResTableFile::NameEntry::operator=, COMDAT
$LN15:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx

; 3156 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN3@operator

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN7@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN7@operator:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rbx+16]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN3@operator:
	mov	eax, DWORD PTR [rbx+32]
	mov	rbx, QWORD PTR [rsp+48]
	mov	DWORD PTR [rdi+32], eax
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??4NameEntry@ResTableFile@@QEAAAEAU01@AEBU01@@Z ENDP	; ResTableFile::NameEntry::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
;	COMDAT ??R<lambda_1>@?1??ToBinary@ResTableFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@QEBA@UCrcEntry@2@0@Z
_TEXT	SEGMENT
this$dead$ = 8
A$ = 16
B$ = 24
??R<lambda_1>@?1??ToBinary@ResTableFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@QEBA@UCrcEntry@2@0@Z PROC ; `ResTableFile::ToBinary'::`2'::<lambda_1>::operator(), COMDAT

; 172  :     std::sort(this->m_CrcEntries.begin(), this->m_CrcEntries.end(), [](ResTableFile::CrcEntry A, ResTableFile::CrcEntry B) { return A.Hash < B.Hash; });

	cmp	edx, r8d
	setb	al
	ret	0
??R<lambda_1>@?1??ToBinary@ResTableFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@QEBA@UCrcEntry@2@0@Z ENDP ; `ResTableFile::ToBinary'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??0NameEntry@ResTableFile@@QEAA@AEBU01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0NameEntry@ResTableFile@@QEAA@AEBU01@@Z PROC		; ResTableFile::NameEntry::NameEntry, COMDAT
$LN6:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR [rbx+32]
	mov	rbx, QWORD PTR [rsp+48]
	mov	DWORD PTR [rdi+32], eax
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0NameEntry@ResTableFile@@QEAA@AEBU01@@Z ENDP		; ResTableFile::NameEntry::NameEntry
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??A?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAAAEAUNameEntry@ResTableFile@@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAAAEAUNameEntry@ResTableFile@@_K@Z PROC ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::operator[], COMDAT

; 1883 :         auto& _My_data = _Mypair._Myval2;
; 1884 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1885 :         _STL_VERIFY(
; 1886 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1887 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1888 : 
; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rcx]
	lea	rdx, QWORD PTR [rdx+rdx*4]
	lea	rax, QWORD PTR [rax+rdx*8]

; 1890 :     }

	ret	0
??A?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAAAEAUNameEntry@ResTableFile@@_K@Z ENDP ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?size@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEBA_KXZ PROC ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::size, COMDAT

; 1868 :         auto& _My_data = _Mypair._Myval2;
; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	mov	rcx, -3689348814741910323		; cccccccccccccccdH
	sar	rax, 3
	imul	rax, rcx

; 1870 :     }

	ret	0
?size@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Unchecked_end@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAAPEAUNameEntry@ResTableFile@@XZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_end@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAAPEAUNameEntry@ResTableFile@@XZ PROC ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::_Unchecked_end, COMDAT

; 1855 :         return _Mypair._Myval2._Mylast;

	mov	rax, QWORD PTR [rcx+8]

; 1856 :     }

	ret	0
?_Unchecked_end@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAAPEAUNameEntry@ResTableFile@@XZ ENDP ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Unchecked_begin@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAAPEAUNameEntry@ResTableFile@@XZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_begin@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAAPEAUNameEntry@ResTableFile@@XZ PROC ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::_Unchecked_begin, COMDAT

; 1847 :         return _Mypair._Myval2._Myfirst;

	mov	rax, QWORD PTR [rcx]

; 1848 :     }

	ret	0
?_Unchecked_begin@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAAPEAUNameEntry@ResTableFile@@XZ ENDP ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?resize@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 64
_Newsize$ = 72
?resize@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAAX_K@Z PROC ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::resize, COMDAT

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

$LN99:
	push	rbx
	push	rsi
	sub	rsp, 40					; 00000028H

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rbx, QWORD PTR [rcx+8]

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	mov	rsi, rcx

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r8, QWORD PTR [rcx]
	mov	r9, -3689348814741910323		; cccccccccccccccdH
	mov	rcx, rbx
	sub	rcx, r8
	sar	rcx, 3
	imul	rcx, r9

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdx, rcx
	jae	SHORT $LN4@resize
	mov	QWORD PTR [rsp+80], rbp

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rax, QWORD PTR [rdx+rdx*4]
	lea	rbp, QWORD PTR [r8+rax*8]
	mov	QWORD PTR [rsp+32], rdi

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rdi, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbp, rbx
	je	SHORT $LN10@resize
$LL11@resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rdi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rdi, 40					; 00000028H
	cmp	rdi, rbx
	jne	SHORT $LL11@resize
$LN10@resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1563 :             _Mylast = _Newlast;

	mov	rdi, QWORD PTR [rsp+32]
	mov	QWORD PTR [rsi+8], rbp
	mov	rbp, QWORD PTR [rsp+80]

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	add	rsp, 40					; 00000028H
	pop	rsi
	pop	rbx
	ret	0
$LN4@resize:

; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN5@resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [rsi+16]
	sub	rax, r8
	sar	rax, 3
	imul	rax, r9

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN6@resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, rsi

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	add	rsp, 40					; 00000028H
	pop	rsi
	pop	rbx

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::_Resize_reallocate<std::_Value_init_tag>
$LN6@resize:

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2041 :     for (; 0 < _Count; --_Count) {

	je	SHORT $LN28@resize
	xor	eax, eax
	npad	7
$LL29@resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR [rbx+32], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rbx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rbx, 40					; 00000028H

; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rdx, 1
	jne	SHORT $LL29@resize
$LN28@resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	mov	QWORD PTR [rsi+8], rbx
$LN5@resize:

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	add	rsp, 40					; 00000028H
	pop	rsi
	pop	rbx
	ret	0
?resize@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAAX_K@Z ENDP ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAA@XZ PROC ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 611  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 612  :     }

	mov	rax, rcx
	ret	0
??0?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAA@XZ ENDP ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??A?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAAAEAUCrcEntry@ResTableFile@@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAAAEAUCrcEntry@ResTableFile@@_K@Z PROC ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::operator[], COMDAT

; 1883 :         auto& _My_data = _Mypair._Myval2;
; 1884 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1885 :         _STL_VERIFY(
; 1886 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1887 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1888 : 
; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rcx]
	lea	rax, QWORD PTR [rax+rdx*8]

; 1890 :     }

	ret	0
??A?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAAAEAUCrcEntry@ResTableFile@@_K@Z ENDP ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?size@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEBA_KXZ PROC ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::size, COMDAT

; 1868 :         auto& _My_data = _Mypair._Myval2;
; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 1870 :     }

	ret	0
?size@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Unchecked_end@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAAPEAUCrcEntry@ResTableFile@@XZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_end@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAAPEAUCrcEntry@ResTableFile@@XZ PROC ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::_Unchecked_end, COMDAT

; 1855 :         return _Mypair._Myval2._Mylast;

	mov	rax, QWORD PTR [rcx+8]

; 1856 :     }

	ret	0
?_Unchecked_end@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAAPEAUCrcEntry@ResTableFile@@XZ ENDP ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Unchecked_begin@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAAPEAUCrcEntry@ResTableFile@@XZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_begin@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAAPEAUCrcEntry@ResTableFile@@XZ PROC ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::_Unchecked_begin, COMDAT

; 1847 :         return _Mypair._Myval2._Myfirst;

	mov	rax, QWORD PTR [rcx]

; 1848 :     }

	ret	0
?_Unchecked_begin@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAAPEAUCrcEntry@ResTableFile@@XZ ENDP ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?end@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?end@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@2@XZ PROC ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::end, COMDAT

; 43   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rdx], rax

; 1805 :         auto& _My_data = _Mypair._Myval2;
; 1806 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

	mov	rax, rdx

; 1807 :     }

	ret	0
?end@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@2@XZ ENDP ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@std@@QEAA@PEAUCrcEntry@ResTableFile@@PEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
__param0$ = 16
__param1$dead$ = 24
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@std@@QEAA@PEAUCrcEntry@ResTableFile@@PEBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ResTableFile::CrcEntry> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<ResTableFile::CrcEntry> > >, COMDAT

; 43   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@std@@QEAA@PEAUCrcEntry@ResTableFile@@PEBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ResTableFile::CrcEntry> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<ResTableFile::CrcEntry> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?begin@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?begin@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@2@XZ PROC ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::begin, COMDAT

; 43   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax

; 1795 :         auto& _My_data = _Mypair._Myval2;
; 1796 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

	mov	rax, rdx

; 1797 :     }

	ret	0
?begin@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@2@XZ ENDP ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?resize@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
?resize@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAAX_K@Z PROC ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::resize, COMDAT

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

$LN35:
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rsi, QWORD PTR [rcx+8]

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	mov	rdi, rcx

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r8, QWORD PTR [rcx]
	mov	rcx, rsi
	sub	rcx, r8
	sar	rcx, 3

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdx, rcx
	jae	SHORT $LN4@resize

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rax, QWORD PTR [r8+rdx*8]

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);
; 1562 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1563 :             _Mylast = _Newlast;

	mov	QWORD PTR [rdi+8], rax

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN4@resize:

; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN5@resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [rdi+16]
	sub	rax, r8
	sar	rax, 3

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN6@resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, rdi

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::_Resize_reallocate<std::_Value_init_tag>
$LN6@resize:

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2041 :     for (; 0 < _Count; --_Count) {

	je	SHORT $LN11@resize
	mov	QWORD PTR [rsp+64], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	mov	rcx, rsi
	lea	rbx, QWORD PTR [rdx*8]
	xor	edx, edx
	mov	r8, rbx
	call	memset
	add	rsi, rbx
	mov	rbx, QWORD PTR [rsp+64]
$LN11@resize:
	mov	QWORD PTR [rdi+8], rsi
$LN5@resize:

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?resize@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAAX_K@Z ENDP ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?push_back@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAAX$$QEAUCrcEntry@ResTableFile@@@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
?push_back@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAAX$$QEAUCrcEntry@ResTableFile@@@Z PROC ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::push_back, COMDAT

; 876  :     _CONSTEXPR20 void push_back(_Ty&& _Val) {

	mov	r8, rdx

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rcx+8]
	cmp	rdx, QWORD PTR [rcx+16]
	je	SHORT $LN4@push_back

; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax

; 798  :         } else {
; 799  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 800  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 801  :             _ASAN_VECTOR_RELEASE_GUARD;
; 802  :         }
; 803  : 
; 804  :         _Orphan_range(_Mylast, _Mylast);
; 805  :         _Ty& _Result = *_Mylast;
; 806  :         ++_Mylast;

	add	QWORD PTR [rcx+8], 8

; 877  :         // insert by moving into element at end, provide strong guarantee
; 878  :         _Emplace_one_at_back(_STD move(_Val));
; 879  :     }

	ret	0
$LN4@push_back:

; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@UCrcEntry@ResTableFile@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAPEAUCrcEntry@ResTableFile@@QEAU23@$$QEAU23@@Z ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::_Emplace_reallocate<ResTableFile::CrcEntry>
?push_back@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAAX$$QEAUCrcEntry@ResTableFile@@@Z ENDP ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAA@XZ PROC ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 611  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 612  :     }

	mov	rax, rcx
	ret	0
??0?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAA@XZ ENDP ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@std@@QEAA@PEAUCrcEntry@ResTableFile@@PEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
_Parg$ = 16
_Pvector$dead$ = 24
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@std@@QEAA@PEAUCrcEntry@ResTableFile@@PEBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ResTableFile::CrcEntry> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ResTableFile::CrcEntry> > >, COMDAT

; 43   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	QWORD PTR [rcx], rdx

; 44   :         this->_Adopt(_Pvector);
; 45   :     }

	mov	rax, rcx
	ret	0
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@std@@QEAA@PEAUCrcEntry@ResTableFile@@PEBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ResTableFile::CrcEntry> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ResTableFile::CrcEntry> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@std@@V<lambda_1>@?1??ToBinary@ResTableFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@XZ@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@0@0V<lambda_1>@?1??ToBinary@ResTableFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Pred$dead$ = 64
$T1 = 64
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@std@@V<lambda_1>@?1??ToBinary@ResTableFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@XZ@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@0@0V<lambda_1>@?1??ToBinary@ResTableFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z PROC ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ResTableFile::CrcEntry> > >,`ResTableFile::ToBinary'::`2'::<lambda_1> >, COMDAT

; 8063 : _CONSTEXPR20 void sort(const _RanIt _First, const _RanIt _Last, _Pr _Pred) { // order [_First, _Last)

	mov	BYTE PTR [rsp+24], r8b
	sub	rsp, 40					; 00000028H

; 8064 :     _Adl_verify_range(_First, _Last);
; 8065 :     const auto _UFirst = _Get_unwrapped(_First);
; 8066 :     const auto _ULast  = _Get_unwrapped(_Last);
; 8067 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

	movzx	r9d, BYTE PTR $T1[rsp]
	mov	r8, rdx
	sub	r8, rcx
	sar	r8, 3

; 8068 : }

	add	rsp, 40					; 00000028H

; 8064 :     _Adl_verify_range(_First, _Last);
; 8065 :     const auto _UFirst = _Get_unwrapped(_First);
; 8066 :     const auto _ULast  = _Get_unwrapped(_Last);
; 8067 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

	jmp	??$_Sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0_JV<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z ; std::_Sort_unchecked<ResTableFile::CrcEntry *,`ResTableFile::ToBinary'::`2'::<lambda_1> >
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@std@@V<lambda_1>@?1??ToBinary@ResTableFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@XZ@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@0@0V<lambda_1>@?1??ToBinary@ResTableFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z ENDP ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ResTableFile::CrcEntry> > >,`ResTableFile::ToBinary'::`2'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@std@@@std@@YA?A_TAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@std@@@std@@YA?A_TAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ResTableFile::CrcEntry> > > const &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;
; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();

	mov	rax, QWORD PTR [rcx]

; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@std@@@std@@YA?A_TAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ResTableFile::CrcEntry> > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@std@@QEBAPEAUCrcEntry@ResTableFile@@XZ
_TEXT	SEGMENT
this$ = 8
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@std@@QEBAPEAUCrcEntry@ResTableFile@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ResTableFile::CrcEntry> > >::_Unwrapped, COMDAT

; 342  :         return _Unfancy(this->_Ptr);

	mov	rax, QWORD PTR [rcx]

; 343  :     }

	ret	0
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@std@@QEBAPEAUCrcEntry@ResTableFile@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ResTableFile::CrcEntry> > >::_Unwrapped
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Pass_fn@V<lambda_1>@?1??ToBinary@ResTableFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YA?A_PAEAV<lambda_1>@?1??ToBinary@ResTableFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Func$dead$ = 16
??$_Pass_fn@V<lambda_1>@?1??ToBinary@ResTableFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YA?A_PAEAV<lambda_1>@?1??ToBinary@ResTableFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z PROC ; std::_Pass_fn<`ResTableFile::ToBinary'::`2'::<lambda_1> >, COMDAT

; 556  :     constexpr bool _Pass_by_value = conjunction_v<bool_constant<sizeof(_Fn) <= sizeof(void*)>,
; 557  :         is_trivially_copy_constructible<_Fn>, is_trivially_destructible<_Fn>>;
; 558  :     if constexpr (_Pass_by_value) {
; 559  :         return _Func;

	mov	rax, rcx

; 560  :     } else {
; 561  :         return _Ref_fn<_Fn>{_Func}; // pass functor by "reference"
; 562  :     }
; 563  : }

	ret	0
??$_Pass_fn@V<lambda_1>@?1??ToBinary@ResTableFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YA?A_PAEAV<lambda_1>@?1??ToBinary@ResTableFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z ENDP ; std::_Pass_fn<`ResTableFile::ToBinary'::`2'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V?$ostream_iterator@EDU?$char_traits@D@std@@@2@@std@@YA?AV?$ostream_iterator@EDU?$char_traits@D@std@@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0V10@@Z
_TEXT	SEGMENT
$T1 = 32
__$ReturnUdt$ = 96
_First$ = 104
_Last$ = 112
_Dest$ = 120
??$copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V?$ostream_iterator@EDU?$char_traits@D@std@@@2@@std@@YA?AV?$ostream_iterator@EDU?$char_traits@D@std@@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0V10@@Z PROC ; std::copy<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,std::ostream_iterator<unsigned char,char,std::char_traits<char> > >, COMDAT

; 4619 : _CONSTEXPR20 _OutIt copy(_InIt _First, _InIt _Last, _OutIt _Dest) { // copy [_First, _Last) to [_Dest, ...)

$LN27:
	push	rbx
	push	rdi
	push	r14
	push	r15
	sub	rsp, 56					; 00000038H

; 4620 :     _Adl_verify_range(_First, _Last);
; 4621 :     const auto _UFirst = _Get_unwrapped(_First);
; 4622 :     const auto _ULast  = _Get_unwrapped(_Last);
; 4623 :     const auto _UDest  = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
; 4624 :     _Seek_wrapped(_Dest, _STD _Copy_unchecked(_UFirst, _ULast, _UDest));

	movaps	xmm0, XMMWORD PTR [r9]
	mov	r15, r9
	movdqa	XMMWORD PTR $T1[rsp], xmm0
	mov	rbx, r8
	mov	rdi, rdx
	mov	r14, rcx

; 4611 :     for (; _First != _Last; ++_Dest, (void) ++_First) {

	cmp	rdx, r8
	je	SHORT $LN9@copy
	mov	QWORD PTR [rsp+104], rbp
	mov	rbp, QWORD PTR $T1[rsp]
	mov	QWORD PTR [rsp+48], rsi
	mov	rsi, QWORD PTR $T1[rsp+8]
	npad	6
$LL10@copy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream

; 948  :     return _Ostr << static_cast<char>(_Ch);

	movzx	edx, BYTE PTR [rdi]
	mov	rcx, rsi
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\iterator

; 341  :         if (_Mydelim) {

	test	rbp, rbp
	je	SHORT $LN8@copy

; 342  :             *_Myostr << _Mydelim;

	mov	rdx, rbp
	mov	rcx, rsi
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
$LN8@copy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4611 :     for (; _First != _Last; ++_Dest, (void) ++_First) {

	inc	rdi
	cmp	rdi, rbx
	jne	SHORT $LL10@copy
	mov	rsi, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+104]
$LN9@copy:

; 4612 :         *_Dest = *_First;
; 4613 :     }
; 4614 : 
; 4615 :     return _Dest;

	movaps	xmm0, XMMWORD PTR [r15]

; 4625 :     return _Dest;

	mov	rax, r14
	movups	XMMWORD PTR [r14], xmm0

; 4626 : }

	add	rsp, 56					; 00000038H
	pop	r15
	pop	r14
	pop	rdi
	pop	rbx
	ret	0
??$copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V?$ostream_iterator@EDU?$char_traits@D@std@@@2@@std@@YA?AV?$ostream_iterator@EDU?$char_traits@D@std@@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0V10@@Z ENDP ; std::copy<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,std::ostream_iterator<unsigned char,char,std::char_traits<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Idl_distance@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PEAE@std@@YA?A_PAEBQEAE0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Idl_distance@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PEAE@std@@YA?A_PAEBQEAE0@Z PROC ; std::_Idl_distance<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,unsigned char *>, COMDAT

; 1317 :     // tries to get the distance between _First and _Last if they are random-access iterators
; 1318 :     if constexpr (_Is_ranges_random_iter_v<_Iter>) {
; 1319 :         return static_cast<_Iter_diff_t<_Checked>>(_Last - _First);

	mov	rax, QWORD PTR [rdx]
	sub	rax, QWORD PTR [rcx]

; 1320 :     } else {
; 1321 :         return _Distance_unknown{};
; 1322 :     }
; 1323 : }

	ret	0
??$_Idl_distance@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PEAE@std@@YA?A_PAEBQEAE0@Z ENDP ; std::_Idl_distance<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 64
_Newsize$ = 72
_Val$dead$ = 80
??$_Resize@U_Value_init_tag@std@@@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::_Resize<std::_Value_init_tag>, COMDAT

; 1551 :     _CONSTEXPR20 void _Resize(const size_type _Newsize, const _Ty2& _Val) {

$LN97:
	push	rbx
	push	rsi
	sub	rsp, 40					; 00000028H

; 1552 :         // trim or append elements, provide strong guarantee
; 1553 :         auto& _Al           = _Getal();
; 1554 :         auto& _My_data      = _Mypair._Myval2;
; 1555 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1556 :         pointer& _Mylast    = _My_data._Mylast;
; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rbx, QWORD PTR [rcx+8]
	mov	rsi, rcx
	mov	r8, QWORD PTR [rcx]
	mov	r9, -3689348814741910323		; cccccccccccccccdH
	mov	rcx, rbx
	sub	rcx, r8
	sar	rcx, 3
	imul	rcx, r9

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdx, rcx
	jae	SHORT $LN2@Resize
	mov	QWORD PTR [rsp+80], rbp

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rax, QWORD PTR [rdx+rdx*4]
	lea	rbp, QWORD PTR [r8+rax*8]
	mov	QWORD PTR [rsp+32], rdi

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rdi, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbp, rbx
	je	SHORT $LN8@Resize
$LL9@Resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rdi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rdi, 40					; 00000028H
	cmp	rdi, rbx
	jne	SHORT $LL9@Resize
$LN8@Resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1563 :             _Mylast = _Newlast;

	mov	rdi, QWORD PTR [rsp+32]
	mov	QWORD PTR [rsi+8], rbp
	mov	rbp, QWORD PTR [rsp+80]

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	add	rsp, 40					; 00000028H
	pop	rsi
	pop	rbx
	ret	0
$LN2@Resize:

; 1564 :             return;
; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN3@Resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [rsi+16]
	sub	rax, r8
	sar	rax, 3
	imul	rax, r9

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN4@Resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, rsi

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	add	rsp, 40					; 00000028H
	pop	rsi
	pop	rbx

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::_Resize_reallocate<std::_Value_init_tag>
$LN4@Resize:

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2041 :     for (; 0 < _Count; --_Count) {

	je	SHORT $LN26@Resize
	xor	eax, eax
	npad	7
$LL27@Resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR [rbx+32], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rbx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rbx, 40					; 00000028H

; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rdx, 1
	jne	SHORT $LL27@Resize
$LN26@Resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	mov	QWORD PTR [rsi+8], rbx
$LN3@Resize:

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	add	rsp, 40					; 00000028H
	pop	rsi
	pop	rbx
	ret	0
??$_Resize@U_Value_init_tag@std@@@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@UNameEntry@ResTableFile@@@std@@V?$_Vector_val@U?$_Simple_types@UNameEntry@ResTableFile@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@UNameEntry@ResTableFile@@@std@@V?$_Vector_val@U?$_Simple_types@UNameEntry@ResTableFile@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<ResTableFile::NameEntry>,std::_Vector_val<std::_Simple_types<ResTableFile::NameEntry> >,1>::_Compressed_pair<std::allocator<ResTableFile::NameEntry>,std::_Vector_val<std::_Simple_types<ResTableFile::NameEntry> >,1><>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@UNameEntry@ResTableFile@@@std@@V?$_Vector_val@U?$_Simple_types@UNameEntry@ResTableFile@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<ResTableFile::NameEntry>,std::_Vector_val<std::_Simple_types<ResTableFile::NameEntry> >,1>::_Compressed_pair<std::allocator<ResTableFile::NameEntry>,std::_Vector_val<std::_Simple_types<ResTableFile::NameEntry> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<ResTableFile::CrcEntry> > >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<ResTableFile::CrcEntry> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
_Val$dead$ = 64
??$_Resize@U_Value_init_tag@std@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::_Resize<std::_Value_init_tag>, COMDAT

; 1551 :     _CONSTEXPR20 void _Resize(const size_type _Newsize, const _Ty2& _Val) {

$LN33:
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1552 :         // trim or append elements, provide strong guarantee
; 1553 :         auto& _Al           = _Getal();
; 1554 :         auto& _My_data      = _Mypair._Myval2;
; 1555 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1556 :         pointer& _Mylast    = _My_data._Mylast;
; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rsi, QWORD PTR [rcx+8]
	mov	rdi, rcx
	mov	r8, QWORD PTR [rcx]
	mov	rcx, rsi
	sub	rcx, r8
	sar	rcx, 3

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdx, rcx
	jae	SHORT $LN2@Resize

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rax, QWORD PTR [r8+rdx*8]

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);
; 1562 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1563 :             _Mylast = _Newlast;

	mov	QWORD PTR [rdi+8], rax

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@Resize:

; 1564 :             return;
; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN3@Resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [rdi+16]
	sub	rax, r8
	sar	rax, 3

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN4@Resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, rdi

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::_Resize_reallocate<std::_Value_init_tag>
$LN4@Resize:

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2041 :     for (; 0 < _Count; --_Count) {

	je	SHORT $LN9@Resize
	mov	QWORD PTR [rsp+64], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	mov	rcx, rsi
	lea	rbx, QWORD PTR [rdx*8]
	xor	edx, edx
	mov	r8, rbx
	call	memset
	add	rsi, rbx
	mov	rbx, QWORD PTR [rsp+64]
$LN9@Resize:
	mov	QWORD PTR [rdi+8], rsi
$LN3@Resize:

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Resize@U_Value_init_tag@std@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAUCrcEntry@ResTableFile@@@std@@YA$$QEAUCrcEntry@ResTableFile@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAUCrcEntry@ResTableFile@@@std@@YA$$QEAUCrcEntry@ResTableFile@@AEAU12@@Z PROC ; std::move<ResTableFile::CrcEntry &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAUCrcEntry@ResTableFile@@@std@@YA$$QEAUCrcEntry@ResTableFile@@AEAU12@@Z ENDP ; std::move<ResTableFile::CrcEntry &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Emplace_one_at_back@UCrcEntry@ResTableFile@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAAEAUCrcEntry@ResTableFile@@$$QEAU23@@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$_Emplace_one_at_back@UCrcEntry@ResTableFile@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAAEAUCrcEntry@ResTableFile@@$$QEAU23@@Z PROC ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::_Emplace_one_at_back<ResTableFile::CrcEntry>, COMDAT

; 776  :     _CONSTEXPR20 _Ty& _Emplace_one_at_back(_Valty&&... _Val) {

	mov	r8, rdx

; 777  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 778  :         auto& _My_data   = _Mypair._Myval2;
; 779  :         pointer& _Mylast = _My_data._Mylast;
; 780  : 
; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rcx+8]
	cmp	rdx, QWORD PTR [rcx+16]
	je	SHORT $LN2@Emplace_on

; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax

; 798  :         } else {
; 799  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 800  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 801  :             _ASAN_VECTOR_RELEASE_GUARD;
; 802  :         }
; 803  : 
; 804  :         _Orphan_range(_Mylast, _Mylast);
; 805  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR [rcx+8]

; 806  :         ++_Mylast;

	lea	rdx, QWORD PTR [rax+8]
	mov	QWORD PTR [rcx+8], rdx

; 786  :     }

	ret	0
$LN2@Emplace_on:

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@UCrcEntry@ResTableFile@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAPEAUCrcEntry@ResTableFile@@QEAU23@$$QEAU23@@Z ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::_Emplace_reallocate<ResTableFile::CrcEntry>
??$_Emplace_one_at_back@UCrcEntry@ResTableFile@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAAEAUCrcEntry@ResTableFile@@$$QEAU23@@Z ENDP ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::_Emplace_one_at_back<ResTableFile::CrcEntry>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@UCrcEntry@ResTableFile@@@std@@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@UCrcEntry@ResTableFile@@@std@@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<ResTableFile::CrcEntry>,std::_Vector_val<std::_Simple_types<ResTableFile::CrcEntry> >,1>::_Compressed_pair<std::allocator<ResTableFile::CrcEntry>,std::_Vector_val<std::_Simple_types<ResTableFile::CrcEntry> >,1><>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@UCrcEntry@ResTableFile@@@std@@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<ResTableFile::CrcEntry>,std::_Vector_val<std::_Simple_types<ResTableFile::CrcEntry> >,1>::_Compressed_pair<std::allocator<ResTableFile::CrcEntry>,std::_Vector_val<std::_Simple_types<ResTableFile::CrcEntry> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UNameEntry@ResTableFile@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@UNameEntry@ResTableFile@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<ResTableFile::NameEntry> >::_Vector_val<std::_Simple_types<ResTableFile::NameEntry> >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@UNameEntry@ResTableFile@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<ResTableFile::NameEntry> >::_Vector_val<std::_Simple_types<ResTableFile::NameEntry> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Orphan_range@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEBAXPEAUNameEntry@ResTableFile@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEBAXPEAUNameEntry@ResTableFile@@0@Z PROC ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::_Orphan_range, COMDAT

; 2177 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

	ret	0
?_Orphan_range@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEBAXPEAUNameEntry@ResTableFile@@0@Z ENDP ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$allocator@UNameEntry@ResTableFile@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@UNameEntry@ResTableFile@@@std@@QEAA@XZ PROC ; std::allocator<ResTableFile::NameEntry>::allocator<ResTableFile::NameEntry>, COMDAT

; 958  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@UNameEntry@ResTableFile@@@std@@QEAA@XZ ENDP ; std::allocator<ResTableFile::NameEntry>::allocator<ResTableFile::NameEntry>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<ResTableFile::CrcEntry> >::_Vector_val<std::_Simple_types<ResTableFile::CrcEntry> >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<ResTableFile::CrcEntry> >::_Vector_val<std::_Simple_types<ResTableFile::CrcEntry> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Orphan_range@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEBAXPEAUCrcEntry@ResTableFile@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEBAXPEAUCrcEntry@ResTableFile@@0@Z PROC ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::_Orphan_range, COMDAT

; 2177 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

	ret	0
?_Orphan_range@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEBAXPEAUCrcEntry@ResTableFile@@0@Z ENDP ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$allocator@UCrcEntry@ResTableFile@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@UCrcEntry@ResTableFile@@@std@@QEAA@XZ PROC ; std::allocator<ResTableFile::CrcEntry>::allocator<ResTableFile::CrcEntry>, COMDAT

; 958  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@UCrcEntry@ResTableFile@@@std@@QEAA@XZ ENDP ; std::allocator<ResTableFile::CrcEntry>::allocator<ResTableFile::CrcEntry>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ResTableFile::CrcEntry> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ResTableFile::CrcEntry> > > >, COMDAT

; 1133 :     // check that [_First, _Last) forms an iterator range
; 1134 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1135 :         _Verify_range(_First, _Last);
; 1136 :     }
; 1137 : }

	ret	0
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ResTableFile::CrcEntry> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ResTableFile::CrcEntry> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Unfancy@UCrcEntry@ResTableFile@@@std@@YAPEAUCrcEntry@ResTableFile@@PEAU12@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@UCrcEntry@ResTableFile@@@std@@YAPEAUCrcEntry@ResTableFile@@PEAU12@@Z PROC ; std::_Unfancy<ResTableFile::CrcEntry>, COMDAT

; 37   :     return _Ptr;

	mov	rax, rcx

; 38   : }

	ret	0
??$_Unfancy@UCrcEntry@ResTableFile@@@std@@YAPEAUCrcEntry@ResTableFile@@PEAU12@@Z ENDP ; std::_Unfancy<ResTableFile::CrcEntry>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0_JV<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
_TEXT	SEGMENT
_First$ = 80
_Last$ = 88
_Ideal$ = 96
_Pred$ = 104
??$_Sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0_JV<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z PROC ; std::_Sort_unchecked<ResTableFile::CrcEntry *,`ResTableFile::ToBinary'::`2'::<lambda_1> >, COMDAT

; 8033 : _CONSTEXPR20 void _Sort_unchecked(_RanIt _First, _RanIt _Last, _Iter_diff_t<_RanIt> _Ideal, _Pr _Pred) {

	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 8034 :     // order [_First, _Last)
; 8035 :     for (;;) {
; 8036 :         if (_Last - _First <= _ISORT_MAX) { // small

	mov	rax, rdx
	movzx	ebx, r9b
	sub	rax, rcx
	mov	r15, r8
	and	rax, -8
	mov	rbp, rdx
	mov	r14, rcx
	cmp	rax, 256				; 00000100H
	jle	$LN162@Sort_unche
	npad	13
$LL2@Sort_unche:

; 8037 :             _Insertion_sort_unchecked(_First, _Last, _Pred);
; 8038 :             return;
; 8039 :         }
; 8040 : 
; 8041 :         if (_Ideal <= 0) { // heap sort if too many divisions

	mov	r11, rbp
	sub	r11, r14
	test	r15, r15
	jle	$LN163@Sort_unche

; 7964 :     _RanIt _Mid = _First + ((_Last - _First) >> 1); // shift for codegen

	sar	r11, 4

; 7965 :     _Guess_median_unchecked(_First, _Mid, _Prev_iter(_Last), _Pred);

	lea	r8, QWORD PTR [rbp-8]
	movzx	r9d, bl
	mov	rcx, r14
	lea	rdi, QWORD PTR [r14+r11*8]
	mov	rdx, rdi
	call	??$_Guess_median_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z ; std::_Guess_median_unchecked<ResTableFile::CrcEntry *,`ResTableFile::ToBinary'::`2'::<lambda_1> >

; 7966 :     _RanIt _Pfirst = _Mid;
; 7967 :     _RanIt _Plast  = _Next_iter(_Pfirst);

	lea	rsi, QWORD PTR [rdi+8]

; 7970 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

	cmp	r14, rdi
	jae	SHORT $LN218@Sort_unche
	mov	ecx, DWORD PTR [rdi]
$LL78@Sort_unche:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 172  :     std::sort(this->m_CrcEntries.begin(), this->m_CrcEntries.end(), [](ResTableFile::CrcEntry A, ResTableFile::CrcEntry B) { return A.Hash < B.Hash; });

	mov	eax, DWORD PTR [rdi-8]
	lea	rdx, QWORD PTR [rdi-8]
	cmp	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7970 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

	jb	SHORT $LN218@Sort_unche
	ja	SHORT $LN218@Sort_unche

; 7971 :         --_Pfirst;

	mov	rdi, rdx
	mov	ecx, eax
	cmp	r14, rdx
	jb	SHORT $LL78@Sort_unche
$LN218@Sort_unche:

; 7974 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

	cmp	rsi, rbp
	jae	SHORT $LN219@Sort_unche
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 172  :     std::sort(this->m_CrcEntries.begin(), this->m_CrcEntries.end(), [](ResTableFile::CrcEntry A, ResTableFile::CrcEntry B) { return A.Hash < B.Hash; });

	mov	ecx, DWORD PTR [rdi]
$LL80@Sort_unche:
	cmp	DWORD PTR [rsi], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7974 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

	jb	SHORT $LN219@Sort_unche
	ja	SHORT $LN219@Sort_unche

; 7975 :         ++_Plast;

	add	rsi, 8
	cmp	rsi, rbp
	jb	SHORT $LL80@Sort_unche
$LN219@Sort_unche:

; 7976 :     }
; 7977 : 
; 7978 :     _RanIt _Gfirst = _Plast;

	mov	rdx, rsi

; 7979 :     _RanIt _Glast  = _Pfirst;

	mov	r9, rdi
$LL82@Sort_unche:

; 7982 :         for (; _Gfirst < _Last; ++_Gfirst) {

	cmp	rdx, rbp
	jae	SHORT $LN220@Sort_unche
	npad	3
$LL87@Sort_unche:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 172  :     std::sort(this->m_CrcEntries.begin(), this->m_CrcEntries.end(), [](ResTableFile::CrcEntry A, ResTableFile::CrcEntry B) { return A.Hash < B.Hash; });

	mov	eax, DWORD PTR [rdi]
	cmp	eax, DWORD PTR [rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7983 :             if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst)) {

	jb	SHORT $LN85@Sort_unche

; 7984 :                 continue;
; 7985 :             } else if (_Pred(*_Gfirst, *_Pfirst)) {

	ja	SHORT $LN220@Sort_unche

; 7986 :                 break;
; 7987 :             } else if (_Plast != _Gfirst) {

	cmp	rsi, rdx
	je	SHORT $LN95@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	mov	rcx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rsi]
	mov	QWORD PTR [rsi], rcx

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [rdx], rax
$LN95@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7982 :         for (; _Gfirst < _Last; ++_Gfirst) {

	add	rsi, 8
$LN85@Sort_unche:
	add	rdx, 8
	cmp	rdx, rbp
	jb	SHORT $LL87@Sort_unche
$LN220@Sort_unche:

; 7995 :         for (; _First < _Glast; --_Glast) {

	cmp	r9, r14
	jbe	SHORT $LN270@Sort_unche
	lea	r8, QWORD PTR [r9-8]
	npad	1
$LL90@Sort_unche:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 172  :     std::sort(this->m_CrcEntries.begin(), this->m_CrcEntries.end(), [](ResTableFile::CrcEntry A, ResTableFile::CrcEntry B) { return A.Hash < B.Hash; });

	mov	eax, DWORD PTR [r8]
	cmp	eax, DWORD PTR [rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7997 :             if (_DEBUG_LT_PRED(_Pred, *_Glast_prev, *_Pfirst)) {

	jb	SHORT $LN88@Sort_unche

; 7998 :                 continue;
; 7999 :             } else if (_Pred(*_Pfirst, *_Glast_prev)) {

	ja	SHORT $LN221@Sort_unche

; 8000 :                 break;
; 8001 :             } else if (--_Pfirst != _Glast_prev) {

	sub	rdi, 8
	cmp	rdi, r8
	je	SHORT $LN88@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	mov	rcx, QWORD PTR [r8]
	mov	rax, QWORD PTR [rdi]
	mov	QWORD PTR [rdi], rcx

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [r8], rax
$LN88@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7995 :         for (; _First < _Glast; --_Glast) {

	sub	r9, 8
	sub	r8, 8
	cmp	r14, r9
	jb	SHORT $LL90@Sort_unche
$LN221@Sort_unche:

; 8002 :                 swap(*_Pfirst, *_Glast_prev); // intentional ADL
; 8003 :             }
; 8004 :         }
; 8005 : 
; 8006 :         if (_Glast == _First && _Gfirst == _Last) {

	cmp	r9, r14
$LN270@Sort_unche:
	jne	SHORT $LN103@Sort_unche
	cmp	rdx, rbp
	je	SHORT $LN161@Sort_unche

; 8007 :             return pair<_RanIt, _RanIt>(_Pfirst, _Plast);
; 8008 :         }
; 8009 : 
; 8010 :         if (_Glast == _First) { // no room at bottom, rotate pivot upward
; 8011 :             if (_Plast != _Gfirst) {

	cmp	rsi, rdx
	je	SHORT $LN119@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	mov	rcx, QWORD PTR [rsi]
	mov	rax, QWORD PTR [rdi]
	mov	QWORD PTR [rdi], rcx

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [rsi], rax
$LN119@Sort_unche:

; 100  :     _Left    = _STD move(_Right);

	mov	rcx, QWORD PTR [rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8015 :             ++_Plast;

	add	rsi, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 99   :     _Ty _Tmp = _STD move(_Left);

	mov	rax, QWORD PTR [rdi]

; 100  :     _Left    = _STD move(_Right);

	mov	QWORD PTR [rdi], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8017 :             ++_Pfirst;

	add	rdi, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [rdx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8018 :             ++_Gfirst;

	add	rdx, 8
	jmp	$LL82@Sort_unche
$LN103@Sort_unche:

; 8019 :         } else if (_Gfirst == _Last) { // no room at top, rotate pivot downward

	add	r9, -8
	cmp	rdx, rbp
	jne	SHORT $LN106@Sort_unche

; 8020 :             if (--_Glast != --_Pfirst) {

	sub	rdi, 8
	cmp	r9, rdi
	je	SHORT $LN209@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	mov	rcx, QWORD PTR [rdi]
	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [r9], rcx

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [rdi], rax
$LN209@Sort_unche:

; 100  :     _Left    = _STD move(_Right);

	mov	rcx, QWORD PTR [rsi-8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8024 :             swap(*_Pfirst, *--_Plast); // intentional ADL

	sub	rsi, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 99   :     _Ty _Tmp = _STD move(_Left);

	mov	rax, QWORD PTR [rdi]

; 100  :     _Left    = _STD move(_Right);

	mov	QWORD PTR [rdi], rcx

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [rsi], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8025 :         } else {

	jmp	$LL82@Sort_unche
$LN106@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 99   :     _Ty _Tmp = _STD move(_Left);

	mov	rax, QWORD PTR [rdx]

; 100  :     _Left    = _STD move(_Right);

	mov	rcx, QWORD PTR [r9]
	mov	QWORD PTR [rdx], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8027 :             ++_Gfirst;

	add	rdx, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [r9], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8029 :     }

	jmp	$LL82@Sort_unche
$LN161@Sort_unche:

; 8044 :             return;
; 8045 :         }
; 8046 : 
; 8047 :         // divide and conquer by quicksort
; 8048 :         auto _Mid = _Partition_by_median_guess_unchecked(_First, _Last, _Pred);
; 8049 : 
; 8050 :         _Ideal = (_Ideal >> 1) + (_Ideal >> 2); // allow 1.5 log2(N) divisions

	mov	rcx, r15

; 8051 : 
; 8052 :         if (_Mid.first - _First < _Last - _Mid.second) { // loop on second half

	mov	rdx, rbp
	sar	rcx, 2
	sub	rdx, rsi
	sar	r15, 1
	mov	rax, rdi
	sub	rax, r14
	add	r15, rcx
	and	rdx, -8
	and	rax, -8
	movzx	r9d, bl
	mov	r8, r15
	cmp	rax, rdx
	jge	SHORT $LN7@Sort_unche

; 8053 :             _Sort_unchecked(_First, _Mid.first, _Ideal, _Pred);

	mov	rdx, rdi
	mov	rcx, r14
	call	??$_Sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0_JV<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z ; std::_Sort_unchecked<ResTableFile::CrcEntry *,`ResTableFile::ToBinary'::`2'::<lambda_1> >

; 8054 :             _First = _Mid.second;

	mov	r14, rsi

; 8055 :         } else { // loop on first half

	jmp	SHORT $LN8@Sort_unche
$LN7@Sort_unche:

; 8056 :             _Sort_unchecked(_Mid.second, _Last, _Ideal, _Pred);

	mov	rdx, rbp
	mov	rcx, rsi
	call	??$_Sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0_JV<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z ; std::_Sort_unchecked<ResTableFile::CrcEntry *,`ResTableFile::ToBinary'::`2'::<lambda_1> >

; 8057 :             _Last = _Mid.first;

	mov	rbp, rdi
$LN8@Sort_unche:

; 8034 :     // order [_First, _Last)
; 8035 :     for (;;) {
; 8036 :         if (_Last - _First <= _ISORT_MAX) { // small

	mov	rax, rbp
	sub	rax, r14
	and	rax, -8
	cmp	rax, 256				; 00000100H
	jg	$LL2@Sort_unche
$LN162@Sort_unche:

; 7907 :     if (_First != _Last) {

	cmp	r14, rbp
	je	$LN54@Sort_unche

; 7908 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

	lea	rdi, QWORD PTR [r14+8]
	cmp	rdi, rbp
	je	$LN54@Sort_unche
	npad	13
$LL11@Sort_unche:

; 7909 :             _BidIt _Hole               = _Mid;
; 7910 :             _Iter_value_t<_BidIt> _Val = _STD move(*_Mid);

	mov	rbx, QWORD PTR [rdi]
	mov	rdx, rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 172  :     std::sort(this->m_CrcEntries.begin(), this->m_CrcEntries.end(), [](ResTableFile::CrcEntry A, ResTableFile::CrcEntry B) { return A.Hash < B.Hash; });

	cmp	ebx, DWORD PTR [r14]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7912 :             if (_DEBUG_LT_PRED(_Pred, _Val, *_First)) { // found new earliest element, move to front

	jae	$LN18@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4841 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	r8, rdi

; 4842 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	mov	rdx, r14
	add	rdi, 8
	sub	r8, r14
	mov	rcx, rdi
	sub	rcx, r8
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7914 :                 *_First = _STD move(_Val);

	mov	QWORD PTR [r14], rbx

; 7915 :             } else { // look for insertion point after first

	jmp	$LN19@Sort_unche
$LN163@Sort_unche:

; 6596 :     _Diff _Bottom = _Last - _First;

	sar	r11, 3

; 6597 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	mov	r10, r11
	sar	r10, 1
	test	r10, r10
	jle	$LN34@Sort_unche
	lea	rbx, QWORD PTR [r11-1]
	sar	rbx, 1
	npad	7
$LL33@Sort_unche:

; 6598 :         // reheap top half, bottom to top
; 6599 :         --_Hole;
; 6600 :         _Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

	mov	rax, QWORD PTR [r14+r10*8-8]
	dec	r10

; 6601 :         _STD _Pop_heap_hole_by_index(_First, _Hole, _Bottom, _STD move(_Val), _Pred);

	mov	r8, r10

; 6438 :     _Diff _Idx       = _Hole;

	mov	r9, r10

; 6443 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	cmp	r10, rbx
	jge	SHORT $LN39@Sort_unche
	npad	13
$LL38@Sort_unche:

; 6444 :         _Idx = 2 * _Idx + 2;

	lea	rdx, QWORD PTR [r9+r9]

; 6445 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {
; 6446 :             --_Idx;
; 6447 :         }
; 6448 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	mov	ecx, DWORD PTR [r14+rdx*8+8]
	cmp	DWORD PTR [r14+rdx*8+16], ecx
	sbb	r9, r9
	add	r9, 2
	add	r9, rdx
	mov	rcx, QWORD PTR [r14+r9*8]
	mov	QWORD PTR [r14+r8*8], rcx

; 6449 :         _Hole             = _Idx;

	mov	r8, r9
	cmp	r9, rbx
	jl	SHORT $LL38@Sort_unche
$LN39@Sort_unche:

; 6450 :     }
; 6451 : 
; 6452 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

	cmp	r9, rbx
	jne	SHORT $LN41@Sort_unche
	test	r11b, 1
	jne	SHORT $LN41@Sort_unche

; 6453 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

	mov	rcx, QWORD PTR [r14+r11*8-8]
	mov	QWORD PTR [r14+r8*8], rcx

; 6454 :         _Hole             = _Bottom - 1;

	lea	r8, QWORD PTR [r11-1]
$LN41@Sort_unche:

; 6328 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	cmp	r10, r8
	jge	SHORT $LN222@Sort_unche
	npad	11
$LL48@Sort_unche:

; 6327 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

	lea	rdx, QWORD PTR [r8-1]
	sar	rdx, 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 172  :     std::sort(this->m_CrcEntries.begin(), this->m_CrcEntries.end(), [](ResTableFile::CrcEntry A, ResTableFile::CrcEntry B) { return A.Hash < B.Hash; });

	cmp	DWORD PTR [r14+rdx*8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6328 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	jae	SHORT $LN222@Sort_unche

; 6329 :          _Idx = (_Hole - 1) >> 1) { // shift for codegen
; 6330 :         // move _Hole up to parent
; 6331 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	mov	rcx, QWORD PTR [r14+rdx*8]
	mov	QWORD PTR [r14+r8*8], rcx

; 6332 :         _Hole             = _Idx;

	mov	r8, rdx
	cmp	r10, rdx
	jl	SHORT $LL48@Sort_unche
$LN222@Sort_unche:

; 6333 :     }
; 6334 : 
; 6335 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	mov	QWORD PTR [r14+r8*8], rax

; 6597 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	test	r10, r10
	jg	$LL33@Sort_unche
$LN34@Sort_unche:

; 6818 :     for (; _Last - _First >= 2; --_Last) {

	cmp	r11, 2
	jl	$LN54@Sort_unche

; 8042 :             _Make_heap_unchecked(_First, _Last, _Pred);
; 8043 :             _Sort_heap_unchecked(_First, _Last, _Pred);

	add	rbp, -8
	mov	edi, 8
	sub	rdi, r14
$LL55@Sort_unche:

; 6465 :     *_Dest      = _STD move(*_First);

	mov	rcx, QWORD PTR [r14]

; 6466 :     using _Diff = _Iter_diff_t<_RanIt>;
; 6467 :     _STD _Pop_heap_hole_by_index(

	mov	r10, rbp

; 6476 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	rax, QWORD PTR [rbp]

; 6467 :     _STD _Pop_heap_hole_by_index(

	sub	r10, r14
	sar	r10, 3
	xor	r8d, r8d

; 6438 :     _Diff _Idx       = _Hole;

	xor	r9d, r9d

; 6465 :     *_Dest      = _STD move(*_First);

	mov	QWORD PTR [rbp], rcx

; 6442 :     const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; // shift for codegen

	lea	r11, QWORD PTR [r10-1]
	sar	r11, 1

; 6443 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	test	r11, r11
	jle	SHORT $LN64@Sort_unche
	npad	9
$LL63@Sort_unche:

; 6444 :         _Idx = 2 * _Idx + 2;

	lea	rdx, QWORD PTR [r9+r9]

; 6445 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {
; 6446 :             --_Idx;
; 6447 :         }
; 6448 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	mov	ecx, DWORD PTR [r14+rdx*8+8]
	cmp	DWORD PTR [r14+rdx*8+16], ecx
	sbb	r9, r9
	add	r9, 2
	add	r9, rdx
	mov	rcx, QWORD PTR [r14+r9*8]
	mov	QWORD PTR [r14+r8*8], rcx

; 6449 :         _Hole             = _Idx;

	mov	r8, r9
	cmp	r9, r11
	jl	SHORT $LL63@Sort_unche
$LN64@Sort_unche:

; 6450 :     }
; 6451 : 
; 6452 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

	cmp	r9, r11
	jne	SHORT $LN66@Sort_unche
	test	r10b, 1
	jne	SHORT $LN66@Sort_unche

; 6453 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

	mov	rcx, QWORD PTR [r14+r10*8-8]
	mov	QWORD PTR [r14+r8*8], rcx

; 6454 :         _Hole             = _Bottom - 1;

	lea	r8, QWORD PTR [r10-1]
$LN66@Sort_unche:

; 6328 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	test	r8, r8
	jle	SHORT $LN223@Sort_unche
	npad	11
$LL73@Sort_unche:

; 6327 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

	lea	rdx, QWORD PTR [r8-1]
	sar	rdx, 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 172  :     std::sort(this->m_CrcEntries.begin(), this->m_CrcEntries.end(), [](ResTableFile::CrcEntry A, ResTableFile::CrcEntry B) { return A.Hash < B.Hash; });

	cmp	DWORD PTR [r14+rdx*8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6328 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	jae	SHORT $LN223@Sort_unche

; 6329 :          _Idx = (_Hole - 1) >> 1) { // shift for codegen
; 6330 :         // move _Hole up to parent
; 6331 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	mov	rcx, QWORD PTR [r14+rdx*8]
	mov	QWORD PTR [r14+r8*8], rcx

; 6332 :         _Hole             = _Idx;

	mov	r8, rdx
	test	rdx, rdx
	jg	SHORT $LL73@Sort_unche
$LN223@Sort_unche:

; 6818 :     for (; _Last - _First >= 2; --_Last) {

	sub	rbp, 8

; 6335 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	mov	QWORD PTR [r14+r8*8], rax

; 6818 :     for (; _Last - _First >= 2; --_Last) {

	lea	rax, QWORD PTR [rdi+rbp]
	and	rax, -8
	cmp	rax, 16
	jge	$LL55@Sort_unche

; 8058 :         }
; 8059 :     }
; 8060 : }

	mov	rbx, QWORD PTR [rsp+104]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN18@Sort_unche:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 172  :     std::sort(this->m_CrcEntries.begin(), this->m_CrcEntries.end(), [](ResTableFile::CrcEntry A, ResTableFile::CrcEntry B) { return A.Hash < B.Hash; });

	cmp	ebx, DWORD PTR [rdi-8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7916 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

	lea	rcx, QWORD PTR [rdi-8]
	jae	SHORT $LN15@Sort_unche
$LL16@Sort_unche:

; 7917 :                     *_Hole = _STD move(*_Prev); // move hole down

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax
	mov	rdx, rcx
	sub	rcx, 8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 172  :     std::sort(this->m_CrcEntries.begin(), this->m_CrcEntries.end(), [](ResTableFile::CrcEntry A, ResTableFile::CrcEntry B) { return A.Hash < B.Hash; });

	cmp	ebx, DWORD PTR [rcx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7916 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

	jb	SHORT $LL16@Sort_unche
$LN15@Sort_unche:

; 7918 :                 }
; 7919 : 
; 7920 :                 *_Hole = _STD move(_Val); // insert element in hole

	mov	QWORD PTR [rdx], rbx
	add	rdi, 8
$LN19@Sort_unche:

; 7908 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

	cmp	rdi, rbp
	jne	$LL11@Sort_unche
$LN54@Sort_unche:

; 8058 :         }
; 8059 :     }
; 8060 : }

	mov	rbx, QWORD PTR [rsp+104]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
??$_Sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0_JV<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z ENDP ; std::_Sort_unchecked<ResTableFile::CrcEntry *,`ResTableFile::ToBinary'::`2'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Copy_unchecked@PEAEPEAEV?$ostream_iterator@EDU?$char_traits@D@std@@@std@@@std@@YA?AV?$ostream_iterator@EDU?$char_traits@D@std@@@0@PEAE0V10@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 64
_First$ = 72
_Last$ = 80
_Dest$ = 88
??$_Copy_unchecked@PEAEPEAEV?$ostream_iterator@EDU?$char_traits@D@std@@@std@@@std@@YA?AV?$ostream_iterator@EDU?$char_traits@D@std@@@0@PEAE0V10@@Z PROC ; std::_Copy_unchecked<unsigned char *,unsigned char *,std::ostream_iterator<unsigned char,char,std::char_traits<char> > >, COMDAT

; 4589 : _CONSTEXPR20 _OutIt _Copy_unchecked(_InIt _First, _Sent _Last, _OutIt _Dest) {

$LN27:
	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H
	mov	r14, r9
	mov	rsi, r8
	mov	rbx, rdx
	mov	r15, rcx

; 4611 :     for (; _First != _Last; ++_Dest, (void) ++_First) {

	cmp	rdx, r8
	je	SHORT $LN2@Copy_unche
	mov	QWORD PTR [rsp+64], rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\iterator

; 341  :         if (_Mydelim) {

	mov	rbp, QWORD PTR [r9]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4611 :     for (; _First != _Last; ++_Dest, (void) ++_First) {

	mov	QWORD PTR [rsp+72], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\iterator

; 340  :         *_Myostr << _Val;

	mov	rdi, QWORD PTR [r9+8]

; 341  :         if (_Mydelim) {

	test	rbp, rbp
	je	SHORT $LL13@Copy_unche
$LL4@Copy_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream

; 948  :     return _Ostr << static_cast<char>(_Ch);

	movzx	edx, BYTE PTR [rbx]
	mov	rcx, rdi
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\iterator

; 342  :             *_Myostr << _Mydelim;

	mov	rdx, rbp
	mov	rcx, rdi
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4611 :     for (; _First != _Last; ++_Dest, (void) ++_First) {

	inc	rbx
	cmp	rbx, rsi
	jne	SHORT $LL4@Copy_unche
	jmp	SHORT $LN25@Copy_unche
$LL13@Copy_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream

; 948  :     return _Ostr << static_cast<char>(_Ch);

	movzx	edx, BYTE PTR [rbx]
	mov	rcx, rdi
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4611 :     for (; _First != _Last; ++_Dest, (void) ++_First) {

	inc	rbx
	cmp	rbx, rsi
	jne	SHORT $LL13@Copy_unche
$LN25@Copy_unche:
	mov	rbp, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
$LN2@Copy_unche:

; 4612 :         *_Dest = *_First;
; 4613 :     }
; 4614 : 
; 4615 :     return _Dest;

	movaps	xmm0, XMMWORD PTR [r14]
	mov	rax, r15

; 4616 : }

	mov	rbx, QWORD PTR [rsp+80]
	movups	XMMWORD PTR [r15], xmm0
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rsi
	ret	0
??$_Copy_unchecked@PEAEPEAEV?$ostream_iterator@EDU?$char_traits@D@std@@@std@@@std@@YA?AV?$ostream_iterator@EDU?$char_traits@D@std@@@0@PEAE0V10@@Z ENDP ; std::_Copy_unchecked<unsigned char *,unsigned char *,std::ostream_iterator<unsigned char,char,std::char_traits<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 80
_Newsize$ = 88
_Val$dead$ = 96
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT

; 1511 :     _CONSTEXPR20 void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

$LN264:
	push	rsi
	push	r14
	sub	rsp, 56					; 00000038H

; 1512 :         if (_Newsize > max_size()) {

	mov	r8, 461168601842738790			; 0666666666666666H
	mov	r14, rdx
	mov	rsi, rcx
	cmp	rdx, r8
	ja	$LN262@Resize_rea
	mov	QWORD PTR [rsp+96], rbx

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, r8

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rbx, QWORD PTR [rcx+8]
	sub	rbx, QWORD PTR [rcx]

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, QWORD PTR [rsi]
	mov	QWORD PTR [rsp+104], rbp
	mov	QWORD PTR [rsp+48], rdi
	mov	QWORD PTR [rsp+40], r12

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r12, -3689348814741910323		; cccccccccccccccdH

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	rcx, 3
	imul	rcx, r12

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	sar	rbx, 3

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	mov	QWORD PTR [rsp+32], r15
	shr	rdx, 1
	sub	rax, rdx

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	imul	rbx, r12

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	cmp	rcx, rax
	ja	$LN238@Resize_rea

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rax, r14
	jae	SHORT $LN11@Resize_rea

; 1973 :             return _Newsize; // geometric growth would be insufficient

	mov	rax, r14
	jmp	SHORT $LN236@Resize_rea
$LN11@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 70   :         if (_Count > _Max_possible) {

	cmp	rax, r8
	ja	$LN238@Resize_rea
$LN236@Resize_rea:

; 71   :             _Throw_bad_array_new_length(); // multiply overflow
; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	lea	rax, QWORD PTR [rax+rax*4]

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	xor	ebp, ebp

; 75   :     return _Count * _Ty_size;

	lea	r15, QWORD PTR [rax*8]

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	r15, 4096				; 00001000H
	jb	SHORT $LN23@Resize_rea

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [r15+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, r15
	jbe	$LN238@Resize_rea

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN200@Resize_rea

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN21@Resize_rea
$LN23@Resize_rea:

; 240  :         }
; 241  :     }
; 242  : #endif // defined(_M_IX86) || defined(_M_X64)
; 243  : 
; 244  :     if (_Bytes != 0) {

	test	r15, r15
	je	SHORT $LN24@Resize_rea

; 87   :         return ::operator new(_Bytes);

	mov	rcx, r15
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax

; 245  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN21@Resize_rea
$LN24@Resize_rea:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

	mov	rdi, rbp
$LN21@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1525 :         const pointer _Appended_first = _Newvec + _Oldsize;

	lea	rax, QWORD PTR [rbx+rbx*4]
	lea	rcx, QWORD PTR [rdi+rax*8]

; 1526 :         pointer _Appended_last        = _Appended_first;
; 1527 : 
; 1528 :         _TRY_BEGIN
; 1529 :         if constexpr (is_same_v<_Ty2, _Ty>) {
; 1530 :             _Appended_last = _Uninitialized_fill_n(_Appended_first, _Newsize - _Oldsize, _Val, _Al);
; 1531 :         } else {
; 1532 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1533 :             _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);

	mov	rax, r14
	sub	rax, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2041 :     for (; 0 < _Count; --_Count) {

	je	SHORT $LN45@Resize_rea
	npad	13
$LL46@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR [rcx+32], rbp
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], rbp

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], bpl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	lea	rcx, QWORD PTR [rcx+40]

; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rax, 1
	jne	SHORT $LL46@Resize_rea
$LN45@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1537 :             _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	rbx, QWORD PTR [rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1932 :     const auto _ULast = _Get_unwrapped(_Last);

	mov	rdx, QWORD PTR [rsi+8]

; 1933 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1934 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1935 : #if _HAS_CXX20
; 1936 :         if (!_STD is_constant_evaluated())
; 1937 : #endif // _HAS_CXX20
; 1938 :         {
; 1939 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1940 :             return _Dest + (_ULast - _UFirst);
; 1941 :         }
; 1942 :     }
; 1943 : 
; 1944 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rbx, rdx
	je	SHORT $LN98@Resize_rea

; 1804 :     }
; 1805 : 
; 1806 :     constexpr pointer _Release() { // suppress any exception handling backout and return _Last
; 1807 :         _First = _Last;
; 1808 :         return _Last;
; 1809 :     }
; 1810 : 
; 1811 : private:
; 1812 :     pointer _First;
; 1813 :     pointer _Last;
; 1814 :     _Alloc& _Al;
; 1815 : };
; 1816 : 
; 1817 : template <class _InIt, class _Se, class _Alloc>
; 1818 : _CONSTEXPR20 _Alloc_ptr_t<_Alloc> _Uninitialized_copy(
; 1819 :     _InIt _First, _Se _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {
; 1820 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1821 :     // note: only called internally from elsewhere in the STL
; 1822 :     using _Ptrval = typename _Alloc::value_type*;
; 1823 : 
; 1824 : #ifdef __cpp_lib_concepts
; 1825 :     auto _UFirst = _RANGES _Unwrap_iter<_Se>(_STD move(_First));
; 1826 :     auto _ULast  = _RANGES _Unwrap_sent<_InIt>(_STD move(_Last));
; 1827 : #else // ^^^ __cpp_lib_concepts / !__cpp_lib_concepts vvv
; 1828 :     // In pre-concepts world, _Uninitialized_copy should only ever be called with an iterator
; 1829 :     // and sentinel of the same type, so `_Get_unwrapped` is fine to call.
; 1830 :     auto _UFirst = _Get_unwrapped(_STD move(_First));
; 1831 :     auto _ULast  = _Get_unwrapped(_STD move(_Last));
; 1832 : #endif // ^^^ !__cpp_lib_concepts ^^^
; 1833 : 
; 1834 :     constexpr bool _Can_memmove = _Sent_copy_cat<decltype(_UFirst), decltype(_ULast), _Ptrval>::_Bitcopy_constructible
; 1835 :                                && _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>::value;
; 1836 : 
; 1837 :     if constexpr (_Can_memmove) {
; 1838 : #if _HAS_CXX20
; 1839 :         if (!_STD is_constant_evaluated())
; 1840 : #endif // _HAS_CXX20
; 1841 :         {
; 1842 :             if constexpr (is_same_v<decltype(_UFirst), decltype(_ULast)>) {
; 1843 :                 _Copy_memmove(_To_address(_UFirst), _To_address(_ULast), _Unfancy(_Dest));
; 1844 :                 _Dest += _ULast - _UFirst;
; 1845 :             } else {
; 1846 :                 const auto _Count = static_cast<size_t>(_ULast - _UFirst);
; 1847 :                 _Copy_memmove_n(_To_address(_UFirst), _Count, _Unfancy(_Dest));
; 1848 :                 _Dest += _Count;
; 1849 :             }
; 1850 :             return _Dest;
; 1851 :         }
; 1852 :     }
; 1853 : 
; 1854 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1855 :     for (; _UFirst != _ULast; ++_UFirst) {
; 1856 :         _Backout._Emplace_back(*_UFirst);
; 1857 :     }
; 1858 : 
; 1859 :     return _Backout._Release();
; 1860 : }
; 1861 : 
; 1862 : template <class _InIt, class _Alloc>
; 1863 : _CONSTEXPR20 _Alloc_ptr_t<_Alloc> _Uninitialized_copy_n(
; 1864 :     _InIt _First, size_t _Count, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {
; 1865 :     // copy _First + [0, _Count) to raw _Dest, using _Al
; 1866 :     // note: only called internally from elsewhere in the STL
; 1867 :     using _Ptrval = typename _Alloc::value_type*;
; 1868 : 
; 1869 :     auto _UFirst = _Get_unwrapped(_STD move(_First));
; 1870 : 
; 1871 :     constexpr bool _Can_memmove =
; 1872 :         conjunction_v<bool_constant<_Iter_copy_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1873 :             _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>;
; 1874 : 
; 1875 :     if constexpr (_Can_memmove) {
; 1876 : #if _HAS_CXX20
; 1877 :         if (!_STD is_constant_evaluated())
; 1878 : #endif // _HAS_CXX20
; 1879 :         {
; 1880 :             _Copy_memmove_n(_UFirst, _Count, _Unfancy(_Dest));
; 1881 :             _Dest += _Count;
; 1882 :             return _Dest;
; 1883 :         }
; 1884 :     }
; 1885 : 
; 1886 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1887 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {
; 1888 :         _Backout._Emplace_back(*_UFirst);
; 1889 :     }
; 1890 : 
; 1891 :     return _Backout._Release();
; 1892 : }
; 1893 : 
; 1894 : template <class _InIt, class _NoThrowFwdIt>
; 1895 : _CONSTEXPR20 _NoThrowFwdIt _Uninitialized_copy_unchecked(_InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {
; 1896 :     // copy [_First, _Last) to raw [_Dest, ...)
; 1897 :     if constexpr (_Iter_copy_cat<_InIt, _NoThrowFwdIt>::_Bitcopy_constructible) {
; 1898 : #if _HAS_CXX20
; 1899 :         if (!_STD is_constant_evaluated())
; 1900 : #endif // _HAS_CXX20
; 1901 :         {
; 1902 :             return _Copy_memmove(_First, _Last, _Dest);
; 1903 :         }
; 1904 :     }
; 1905 : 
; 1906 :     _Uninitialized_backout<_NoThrowFwdIt> _Backout{_Dest};
; 1907 :     for (; _First != _Last; ++_First) {
; 1908 :         _Backout._Emplace_back(*_First);
; 1909 :     }
; 1910 : 
; 1911 :     return _Backout._Release();
; 1912 : }
; 1913 : 
; 1914 : _EXPORT_STD template <class _InIt, class _NoThrowFwdIt>
; 1915 : _NoThrowFwdIt uninitialized_copy(const _InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {
; 1916 :     // copy [_First, _Last) to raw [_Dest, ...)
; 1917 :     _Adl_verify_range(_First, _Last);
; 1918 :     auto _UFirst      = _Get_unwrapped(_First);
; 1919 :     const auto _ULast = _Get_unwrapped(_Last);
; 1920 :     auto _UDest       = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
; 1921 :     _Seek_wrapped(_Dest, _Uninitialized_copy_unchecked(_UFirst, _ULast, _UDest));
; 1922 :     return _Dest;
; 1923 : }
; 1924 : 
; 1925 : template <class _InIt, class _Alloc>
; 1926 : _CONSTEXPR20 _Alloc_ptr_t<_Alloc> _Uninitialized_move(
; 1927 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	lea	rcx, QWORD PTR [rdi+24]
	npad	13
$LL99@Resize_rea:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx-24], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx-8], rbp

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx], rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	lea	rcx, QWORD PTR [rcx+40]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rbx]
	movups	XMMWORD PTR [rcx-64], xmm0
	movups	xmm1, XMMWORD PTR [rbx+16]
	movups	XMMWORD PTR [rcx-48], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	mov	QWORD PTR [rbx+16], rbp
	mov	QWORD PTR [rbx+24], 15
	mov	BYTE PTR [rbx], bpl
	mov	eax, DWORD PTR [rbx+32]

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	rbx, 40					; 00000028H
	mov	DWORD PTR [rcx-32], eax
	cmp	rbx, rdx
	jne	SHORT $LL99@Resize_rea
	mov	rbx, QWORD PTR [rsi]
$LN98@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2023 :         if (_Myfirst) { // destroy and deallocate old array

	test	rbx, rbx
	je	SHORT $LN191@Resize_rea

; 2024 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rbp, QWORD PTR [rsi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rbp
	je	SHORT $LN171@Resize_rea
$LL172@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 40					; 00000028H
	cmp	rbx, rbp
	jne	SHORT $LL172@Resize_rea
$LN171@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rsi]
	mov	rax, QWORD PTR [rsi+16]
	sub	rax, rcx
	sar	rax, 3
	imul	rax, r12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*4]
	shl	rdx, 3

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN203@Resize_rea

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN200@Resize_rea

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN203@Resize_rea:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN191@Resize_rea:
	mov	r12, QWORD PTR [rsp+40]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2030 :         _Mylast  = _Newvec + _Newsize;

	lea	rax, QWORD PTR [r14+r14*4]
	mov	rbp, QWORD PTR [rsp+104]
	lea	rcx, QWORD PTR [rdi+rax*8]
	mov	rbx, QWORD PTR [rsp+96]

; 2031 :         _Myend   = _Newvec + _Newcapacity;

	lea	rax, QWORD PTR [r15+rdi]
	mov	r15, QWORD PTR [rsp+32]

; 2027 :         }
; 2028 : 
; 2029 :         _Myfirst = _Newvec;

	mov	QWORD PTR [rsi], rdi
	mov	rdi, QWORD PTR [rsp+48]

; 2030 :         _Mylast  = _Newvec + _Newsize;

	mov	QWORD PTR [rsi+8], rcx

; 2031 :         _Myend   = _Newvec + _Newcapacity;

	mov	QWORD PTR [rsi+16], rax

; 1548 :     }

	add	rsp, 56					; 00000038H
	pop	r14
	pop	rsi
	ret	0
$LN200@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN262@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1513 :             _Xlength();

	call	?_Xlength@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@CAXXZ ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::_Xlength
	int	3
$LN238@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN260@Resize_rea:
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@YAPEAUNameEntry@ResTableFile@@PEAU12@_KAEAV?$allocator@UNameEntry@ResTableFile@@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Count$ = 16
_Al$dead$ = 24
??$_Uninitialized_value_construct_n@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@YAPEAUNameEntry@ResTableFile@@PEAU12@_KAEAV?$allocator@UNameEntry@ResTableFile@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<ResTableFile::NameEntry> >, COMDAT

; 2027 :     // value-initialize _Count objects to raw _First, using _Al
; 2028 :     using _Ptrty = typename _Alloc::value_type*;
; 2029 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2030 : #if _HAS_CXX20
; 2031 :         if (!_STD is_constant_evaluated())
; 2032 : #endif // _HAS_CXX20
; 2033 :         {
; 2034 :             auto _PFirst = _Unfancy(_First);
; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2036 :             return _First + _Count;
; 2037 :         }
; 2038 :     }
; 2039 : 
; 2040 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2041 :     for (; 0 < _Count; --_Count) {

	test	rdx, rdx
	je	SHORT $LN62@Uninitiali
	xor	eax, eax
	npad	9
$LL4@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR [rcx+32], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rcx, 40					; 00000028H

; 2027 :     // value-initialize _Count objects to raw _First, using _Al
; 2028 :     using _Ptrty = typename _Alloc::value_type*;
; 2029 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2030 : #if _HAS_CXX20
; 2031 :         if (!_STD is_constant_evaluated())
; 2032 : #endif // _HAS_CXX20
; 2033 :         {
; 2034 :             auto _PFirst = _Unfancy(_First);
; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2036 :             return _First + _Count;
; 2037 :         }
; 2038 :     }
; 2039 : 
; 2040 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rdx, 1
	jne	SHORT $LL4@Uninitiali
$LN62@Uninitiali:

; 2042 :         _Backout._Emplace_back();
; 2043 :     }
; 2044 : 
; 2045 :     return _Backout._Release();
; 2046 : }

	mov	rax, rcx
	ret	0
??$_Uninitialized_value_construct_n@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@YAPEAUNameEntry@ResTableFile@@PEAU12@_KAEAV?$allocator@UNameEntry@ResTableFile@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<ResTableFile::NameEntry> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 64
_Newsize$ = 72
_Val$dead$ = 80
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT

; 1511 :     _CONSTEXPR20 void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

$LN63:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1512 :         if (_Newsize > max_size()) {

	mov	rbx, 2305843009213693951		; 1fffffffffffffffH
	mov	rdi, rdx
	mov	rsi, rcx
	cmp	rdx, rbx
	ja	$LN61@Resize_rea
	mov	QWORD PTR [rsp+80], rbp

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, rbx

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rbp, QWORD PTR [rcx+8]
	sub	rbp, QWORD PTR [rcx]

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, QWORD PTR [rsi]
	sar	rcx, 3

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	sar	rbp, 3

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	shr	rdx, 1
	sub	rax, rdx
	mov	QWORD PTR [rsp+88], r14
	cmp	rcx, rax
	ja	SHORT $LN11@Resize_rea

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rbx, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rbx, rdi
	cmovb	rbx, rdi
$LN11@Resize_rea:

; 1524 :         const pointer _Newvec         = _Al.allocate(_Newcapacity);

	mov	rdx, rbx
	call	?allocate@?$allocator@UCrcEntry@ResTableFile@@@std@@QEAAPEAUCrcEntry@ResTableFile@@_K@Z ; std::allocator<ResTableFile::CrcEntry>::allocate

; 1525 :         const pointer _Appended_first = _Newvec + _Oldsize;
; 1526 :         pointer _Appended_last        = _Appended_first;
; 1527 : 
; 1528 :         _TRY_BEGIN
; 1529 :         if constexpr (is_same_v<_Ty2, _Ty>) {
; 1530 :             _Appended_last = _Uninitialized_fill_n(_Appended_first, _Newsize - _Oldsize, _Val, _Al);
; 1531 :         } else {
; 1532 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1533 :             _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);

	mov	r8, rdi
	mov	r14, rax
	sub	r8, rbp
	lea	rcx, QWORD PTR [rax+rbp*8]
	mov	rbp, QWORD PTR [rsp+80]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2041 :     for (; 0 < _Count; --_Count) {

	je	SHORT $LN18@Resize_rea
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1524 :         const pointer _Newvec         = _Al.allocate(_Newcapacity);

	lea	r8, QWORD PTR [r8*8]
	xor	edx, edx
	call	memset
$LN18@Resize_rea:

; 1534 :         }
; 1535 : 
; 1536 :         if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 1537 :             _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	rdx, QWORD PTR [rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, r14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1932 :     const auto _ULast = _Get_unwrapped(_Last);

	mov	r8, QWORD PTR [rsi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1547 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, rbx
	mov	r8, rdi
	mov	rdx, r14
	mov	rcx, rsi
	mov	r14, QWORD PTR [rsp+88]

; 1548 :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbx

; 1547 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	jmp	?_Change_array@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAXQEAUCrcEntry@ResTableFile@@_K1@Z ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::_Change_array
$LN61@Resize_rea:

; 1513 :             _Xlength();

	call	?_Xlength@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@CAXXZ ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::_Xlength
	int	3
$LN59@Resize_rea:
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@YAPEAUCrcEntry@ResTableFile@@PEAU12@_KAEAV?$allocator@UCrcEntry@ResTableFile@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Al$dead$ = 64
??$_Uninitialized_value_construct_n@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@YAPEAUCrcEntry@ResTableFile@@PEAU12@_KAEAV?$allocator@UCrcEntry@ResTableFile@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<ResTableFile::CrcEntry> >, COMDAT

; 2026 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

$LN26:
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx

; 2027 :     // value-initialize _Count objects to raw _First, using _Al
; 2028 :     using _Ptrty = typename _Alloc::value_type*;
; 2029 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2030 : #if _HAS_CXX20
; 2031 :         if (!_STD is_constant_evaluated())
; 2032 : #endif // _HAS_CXX20
; 2033 :         {
; 2034 :             auto _PFirst = _Unfancy(_First);
; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2036 :             return _First + _Count;
; 2037 :         }
; 2038 :     }
; 2039 : 
; 2040 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2041 :     for (; 0 < _Count; --_Count) {

	test	rdx, rdx
	je	SHORT $LN22@Uninitiali
	mov	QWORD PTR [rsp+48], rbx
	lea	rbx, QWORD PTR [rdx*8]
	mov	r8, rbx
	xor	edx, edx
	call	memset
	lea	rax, QWORD PTR [rbx+rdi]

; 2042 :         _Backout._Emplace_back();
; 2043 :     }
; 2044 : 
; 2045 :     return _Backout._Release();

	mov	rbx, QWORD PTR [rsp+48]

; 2046 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN22@Uninitiali:

; 2042 :         _Backout._Emplace_back();
; 2043 :     }
; 2044 : 
; 2045 :     return _Backout._Release();

	mov	rax, rdi

; 2046 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_value_construct_n@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@YAPEAUCrcEntry@ResTableFile@@PEAU12@_KAEAV?$allocator@UCrcEntry@ResTableFile@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<ResTableFile::CrcEntry> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@UCrcEntry@ResTableFile@@@std@@YA$$QEAUCrcEntry@ResTableFile@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@UCrcEntry@ResTableFile@@@std@@YA$$QEAUCrcEntry@ResTableFile@@AEAU12@@Z PROC ; std::forward<ResTableFile::CrcEntry>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@UCrcEntry@ResTableFile@@@std@@YA$$QEAUCrcEntry@ResTableFile@@AEAU12@@Z ENDP ; std::forward<ResTableFile::CrcEntry>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@UCrcEntry@ResTableFile@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAAEAUCrcEntry@ResTableFile@@$$QEAU23@@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$_Emplace_back_with_unused_capacity@UCrcEntry@ResTableFile@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAAEAUCrcEntry@ResTableFile@@$$QEAU23@@Z PROC ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::_Emplace_back_with_unused_capacity<ResTableFile::CrcEntry>, COMDAT

; 790  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 791  :         auto& _My_data   = _Mypair._Myval2;
; 792  :         pointer& _Mylast = _My_data._Mylast;
; 793  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 794  :         if constexpr (conjunction_v<is_nothrow_constructible<_Ty, _Valty...>,
; 795  :                           _Uses_default_construct<_Alloc, _Ty*, _Valty...>>) {
; 796  :             _ASAN_VECTOR_MODIFY(1);
; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	rax, QWORD PTR [rdx]
	mov	r8, QWORD PTR [rcx+8]
	mov	QWORD PTR [r8], rax

; 798  :         } else {
; 799  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 800  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 801  :             _ASAN_VECTOR_RELEASE_GUARD;
; 802  :         }
; 803  : 
; 804  :         _Orphan_range(_Mylast, _Mylast);
; 805  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR [rcx+8]

; 806  :         ++_Mylast;

	lea	rdx, QWORD PTR [rax+8]
	mov	QWORD PTR [rcx+8], rdx

; 807  : 
; 808  :         return _Result;
; 809  :     }

	ret	0
??$_Emplace_back_with_unused_capacity@UCrcEntry@ResTableFile@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAAEAUCrcEntry@ResTableFile@@$$QEAU23@@Z ENDP ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::_Emplace_back_with_unused_capacity<ResTableFile::CrcEntry>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Emplace_reallocate@UCrcEntry@ResTableFile@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAPEAUCrcEntry@ResTableFile@@QEAU23@$$QEAU23@@Z
_TEXT	SEGMENT
this$ = 80
_Whereptr$ = 88
<_Val_0>$ = 96
??$_Emplace_reallocate@UCrcEntry@ResTableFile@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAPEAUCrcEntry@ResTableFile@@QEAU23@$$QEAU23@@Z PROC ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::_Emplace_reallocate<ResTableFile::CrcEntry>, COMDAT

; 812  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN85:
	push	rbx
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 813  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 814  :         _Alty& _Al        = _Getal();
; 815  :         auto& _My_data    = _Mypair._Myval2;
; 816  :         pointer& _Myfirst = _My_data._Myfirst;
; 817  :         pointer& _Mylast  = _My_data._Mylast;
; 818  : 
; 819  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 820  : 
; 821  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);
; 822  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	mov	r15, rdx
	mov	rdx, QWORD PTR [rcx]
	mov	r14, r15
	sub	r14, rdx
	sub	rax, rdx
	sar	r14, 3

; 823  : 
; 824  :         if (_Oldsize == max_size()) {

	mov	rbx, 2305843009213693951		; 1fffffffffffffffH
	sar	rax, 3
	mov	r12, r8
	mov	rdi, rcx
	cmp	rax, rbx
	je	$LN83@Emplace_re

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, rdx
	mov	QWORD PTR [rsp+96], rbp
	sar	rcx, 3

; 826  :         }
; 827  : 
; 828  :         const size_type _Newsize     = _Oldsize + 1;

	lea	rbp, QWORD PTR [rax+1]

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	mov	QWORD PTR [rsp+104], rsi
	shr	rdx, 1
	mov	rax, rbx
	sub	rax, rdx
	cmp	rcx, rax
	ja	SHORT $LN13@Emplace_re

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rbx, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rbx, rbp
	cmovb	rbx, rbp
$LN13@Emplace_re:

; 829  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 830  : 
; 831  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	rdx, rbx
	call	?allocate@?$allocator@UCrcEntry@ResTableFile@@@std@@QEAAPEAUCrcEntry@ResTableFile@@_K@Z ; std::allocator<ResTableFile::CrcEntry>::allocate

; 832  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;
; 833  :         pointer _Constructed_first      = _Constructed_last;
; 834  : 
; 835  :         _TRY_BEGIN
; 836  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR [r12]
	mov	rsi, rax
	mov	QWORD PTR [rax+r14*8], rcx

; 837  :         _Constructed_first = _Newvec + _Whereoff;
; 838  : 
; 839  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	rcx, rax
	mov	r8, QWORD PTR [rdi+8]
	mov	rdx, QWORD PTR [rdi]
	lea	r14, QWORD PTR [rax+r14*8]
	cmp	r15, r8
	jne	SHORT $LN4@Emplace_re
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 845  :         } else { // provide basic guarantee

	jmp	SHORT $LN81@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	r8, r15
	sub	r8, rdx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1932 :     const auto _ULast = _Get_unwrapped(_Last);

	mov	r8, QWORD PTR [rdi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 848  :             _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

	lea	rcx, QWORD PTR [r14+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, r15

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, r15
$LN81@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 848  :             _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

	call	memmove

; 849  :         }
; 850  :         _CATCH_ALL
; 851  :         _Destroy_range(_Constructed_first, _Constructed_last, _Al);
; 852  :         _Al.deallocate(_Newvec, _Newcapacity);
; 853  :         _RERAISE;
; 854  :         _CATCH_END
; 855  : 
; 856  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, rbx
	mov	r8, rbp
	mov	rdx, rsi
	mov	rcx, rdi
	call	?_Change_array@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAXQEAUCrcEntry@ResTableFile@@_K1@Z ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::_Change_array

; 857  :         return _Newvec + _Whereoff;

	mov	rsi, QWORD PTR [rsp+104]
	mov	rax, r14
	mov	rbp, QWORD PTR [rsp+96]

; 858  :     }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rbx
	ret	0
$LN83@Emplace_re:

; 825  :             _Xlength();

	call	?_Xlength@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@CAXXZ ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::_Xlength
	int	3
$LN80@Emplace_re:
??$_Emplace_reallocate@UCrcEntry@ResTableFile@@@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAPEAUCrcEntry@ResTableFile@@QEAU23@$$QEAU23@@Z ENDP ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::_Emplace_reallocate<ResTableFile::CrcEntry>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAAX_K@Z PROC ; std::_Uninitialized_backout_al<std::allocator<ResTableFile::NameEntry> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAAX_K@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<ResTableFile::NameEntry> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAAX_K@Z PROC ; std::_Uninitialized_backout_al<std::allocator<ResTableFile::CrcEntry> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAAX_K@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<ResTableFile::CrcEntry> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAAPEAUCrcEntry@ResTableFile@@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAAPEAUCrcEntry@ResTableFile@@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<ResTableFile::CrcEntry> >::_Release, COMDAT

; 1807 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1808 :         return _Last;
; 1809 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAAPEAUCrcEntry@ResTableFile@@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<ResTableFile::CrcEntry> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Uninitialized_backout_al@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<ResTableFile::CrcEntry> >::~_Uninitialized_backout_al<std::allocator<ResTableFile::CrcEntry> >, COMDAT

; 1797 :         _Destroy_range(_First, _Last, _Al);
; 1798 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<ResTableFile::CrcEntry> >::~_Uninitialized_backout_al<std::allocator<ResTableFile::CrcEntry> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAA@PEAUCrcEntry@ResTableFile@@AEAV?$allocator@UCrcEntry@ResTableFile@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAA@PEAUCrcEntry@ResTableFile@@AEAV?$allocator@UCrcEntry@ResTableFile@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<ResTableFile::CrcEntry> >::_Uninitialized_backout_al<std::allocator<ResTableFile::CrcEntry> >, COMDAT

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAA@PEAUCrcEntry@ResTableFile@@AEAV?$allocator@UCrcEntry@ResTableFile@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<ResTableFile::CrcEntry> >::_Uninitialized_backout_al<std::allocator<ResTableFile::CrcEntry> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAAPEAUNameEntry@ResTableFile@@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAAPEAUNameEntry@ResTableFile@@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<ResTableFile::NameEntry> >::_Release, COMDAT

; 1807 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1808 :         return _Last;
; 1809 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAAPEAUNameEntry@ResTableFile@@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<ResTableFile::NameEntry> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Uninitialized_backout_al@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<ResTableFile::NameEntry> >::~_Uninitialized_backout_al<std::allocator<ResTableFile::NameEntry> >, COMDAT

; 1796 :     _CONSTEXPR20 ~_Uninitialized_backout_al() {

$LN28:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1797 :         _Destroy_range(_First, _Last, _Al);

	mov	rdi, QWORD PTR [rcx+8]
	mov	rbx, QWORD PTR [rcx]

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN5@Uninitiali
$LL6@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 40					; 00000028H
	cmp	rbx, rdi
	jne	SHORT $LL6@Uninitiali
$LN5@Uninitiali:

; 1798 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<ResTableFile::NameEntry> >::~_Uninitialized_backout_al<std::allocator<ResTableFile::NameEntry> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAA@PEAUNameEntry@ResTableFile@@AEAV?$allocator@UNameEntry@ResTableFile@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAA@PEAUNameEntry@ResTableFile@@AEAV?$allocator@UNameEntry@ResTableFile@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<ResTableFile::NameEntry> >::_Uninitialized_backout_al<std::allocator<ResTableFile::NameEntry> >, COMDAT

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAA@PEAUNameEntry@ResTableFile@@AEAV?$allocator@UNameEntry@ResTableFile@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<ResTableFile::NameEntry> >::_Uninitialized_backout_al<std::allocator<ResTableFile::NameEntry> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Xlength@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@CAXXZ PROC ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::_Xlength, COMDAT

; 2137 :     [[noreturn]] static void _Xlength() {

$LN4:
	sub	rsp, 40					; 00000028H

; 2138 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlength:
?_Xlength@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@CAXXZ ENDP ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Change_array@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAXQEAUNameEntry@ResTableFile@@_K1@Z
_TEXT	SEGMENT
this$ = 64
_Newvec$ = 72
_Newsize$ = 80
_Newcapacity$ = 88
?_Change_array@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAXQEAUNameEntry@ResTableFile@@_K1@Z PROC ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::_Change_array, COMDAT

; 2013 :     _CONSTEXPR20 void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN53:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	r12
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 2014 :         // orphan all iterators, discard old array, acquire new array
; 2015 :         auto& _Al         = _Getal();
; 2016 :         auto& _My_data    = _Mypair._Myval2;
; 2017 :         pointer& _Myfirst = _My_data._Myfirst;
; 2018 :         pointer& _Mylast  = _My_data._Mylast;
; 2019 :         pointer& _Myend   = _My_data._Myend;
; 2020 : 
; 2021 :         _My_data._Orphan_all();
; 2022 : 
; 2023 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR [rcx]
	mov	r15, r9
	mov	r12, r8
	mov	r14, rdx
	mov	rsi, rcx
	test	rbx, rbx
	je	SHORT $LN26@Change_arr
	mov	QWORD PTR [rsp+72], rdi

; 2024 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdi, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN6@Change_arr
$LL7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 40					; 00000028H
	cmp	rbx, rdi
	jne	SHORT $LL7@Change_arr
$LN6@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rsi]
	mov	rdx, -3689348814741910323		; cccccccccccccccdH
	mov	rax, QWORD PTR [rsi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdi, QWORD PTR [rsp+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rax, rcx
	sar	rax, 3
	imul	rax, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*4]
	shl	rdx, 3

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN38@Change_arr

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN35@Change_arr

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN38@Change_arr:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN26@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2033 :     }

	mov	rbx, QWORD PTR [rsp+80]
	lea	rax, QWORD PTR [r12+r12*4]
	lea	rcx, QWORD PTR [r14+rax*8]
	mov	QWORD PTR [rsi], r14
	mov	QWORD PTR [rsi+8], rcx
	lea	rax, QWORD PTR [r15+r15*4]
	lea	rcx, QWORD PTR [r14+rax*8]
	mov	QWORD PTR [rsi+16], rcx
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r12
	ret	0
$LN35@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN50@Change_arr:
?_Change_array@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEAAXQEAUNameEntry@ResTableFile@@_K1@Z ENDP ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Calculate_growth@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$ = 16
?_Calculate_growth@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEBA_K_K@Z PROC ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::_Calculate_growth, COMDAT

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	r8, QWORD PTR [rcx+16]
	mov	rax, -3689348814741910323		; cccccccccccccccdH
	sub	r8, QWORD PTR [rcx]
	sar	r8, 3
	imul	r8, rax

; 1962 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1963 :         const size_type _Oldcapacity = capacity();
; 1964 :         const auto _Max              = max_size();
; 1965 : 
; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, 461168601842738790			; 0666666666666666H
	mov	r9, r8
	mov	rcx, rax
	shr	r9, 1
	sub	rcx, r9
	cmp	r8, rcx
	ja	SHORT $LN1@Calculate_

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [r9+r8]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rax, rdx
	cmovb	rax, rdx
$LN1@Calculate_:

; 1973 :             return _Newsize; // geometric growth would be insufficient
; 1974 :         }
; 1975 : 
; 1976 :         return _Geometric; // geometric growth is sufficient
; 1977 :     }

	ret	0
?_Calculate_growth@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEBA_K_K@Z ENDP ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?max_size@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEBA_KXZ PROC ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::max_size, COMDAT

; 1873 :         return (_STD min)(

	mov	rax, 461168601842738790			; 0666666666666666H

; 1874 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1875 :     }

	ret	0
?max_size@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?allocate@?$allocator@UNameEntry@ResTableFile@@@std@@QEAAPEAUNameEntry@ResTableFile@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@UNameEntry@ResTableFile@@@std@@QEAAPEAUNameEntry@ResTableFile@@_K@Z PROC ; std::allocator<ResTableFile::NameEntry>::allocate, COMDAT

; 972  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN32:
	sub	rsp, 40					; 00000028H

; 70   :         if (_Count > _Max_possible) {

	mov	rax, 461168601842738790			; 0666666666666666H
	cmp	rdx, rax
	ja	SHORT $LN28@allocate

; 71   :             _Throw_bad_array_new_length(); // multiply overflow
; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	lea	rax, QWORD PTR [rdx+rdx*4]
	lea	rcx, QWORD PTR [rax*8]

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN9@allocate

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN28@allocate

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN18@allocate

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN18@allocate:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@allocate:

; 244  :     if (_Bytes != 0) {

	test	rcx, rcx
	je	SHORT $LN10@allocate

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H

; 87   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN10@allocate:

; 248  :     return nullptr;

	xor	eax, eax

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN28@allocate:

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN30@allocate:
?allocate@?$allocator@UNameEntry@ResTableFile@@@std@@QEAAPEAUNameEntry@ResTableFile@@_K@Z ENDP ; std::allocator<ResTableFile::NameEntry>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Xlength@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@CAXXZ PROC ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::_Xlength, COMDAT

; 2137 :     [[noreturn]] static void _Xlength() {

$LN4:
	sub	rsp, 40					; 00000028H

; 2138 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlength:
?_Xlength@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@CAXXZ ENDP ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Change_array@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAXQEAUCrcEntry@ResTableFile@@_K1@Z
_TEXT	SEGMENT
this$ = 48
_Newvec$ = 56
_Newsize$ = 64
_Newcapacity$ = 72
?_Change_array@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAXQEAUCrcEntry@ResTableFile@@_K1@Z PROC ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::_Change_array, COMDAT

; 2013 :     _CONSTEXPR20 void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN30:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rsi, r9

; 2014 :         // orphan all iterators, discard old array, acquire new array
; 2015 :         auto& _Al         = _Getal();
; 2016 :         auto& _My_data    = _Mypair._Myval2;
; 2017 :         pointer& _Myfirst = _My_data._Myfirst;
; 2018 :         pointer& _Mylast  = _My_data._Mylast;
; 2019 :         pointer& _Myend   = _My_data._Myend;
; 2020 : 
; 2021 :         _My_data._Orphan_all();
; 2022 : 
; 2023 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	mov	rbp, r8
	mov	rdi, rdx
	test	rcx, rcx
	je	SHORT $LN8@Change_arr

; 2024 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2025 :             _ASAN_VECTOR_REMOVE;
; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN20@Change_arr

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN17@Change_arr

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN20@Change_arr:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN8@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2030 :         _Mylast  = _Newvec + _Newsize;

	lea	rax, QWORD PTR [rdi+rbp*8]
	mov	QWORD PTR [rbx], rdi

; 2033 :     }

	mov	rbp, QWORD PTR [rsp+64]
	mov	QWORD PTR [rbx+8], rax
	lea	rax, QWORD PTR [rdi+rsi*8]
	mov	rsi, QWORD PTR [rsp+72]
	mov	QWORD PTR [rbx+16], rax
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN17@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN27@Change_arr:
?_Change_array@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEAAXQEAUCrcEntry@ResTableFile@@_K1@Z ENDP ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Calculate_growth@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$ = 16
?_Calculate_growth@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEBA_K_K@Z PROC ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::_Calculate_growth, COMDAT

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	r8, QWORD PTR [rcx+16]

; 1962 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1963 :         const size_type _Oldcapacity = capacity();
; 1964 :         const auto _Max              = max_size();
; 1965 : 
; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sub	r8, QWORD PTR [rcx]

; 1962 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1963 :         const size_type _Oldcapacity = capacity();
; 1964 :         const auto _Max              = max_size();
; 1965 : 
; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rcx, rax

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	r8, 3

; 1962 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1963 :         const size_type _Oldcapacity = capacity();
; 1964 :         const auto _Max              = max_size();
; 1965 : 
; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	r9, r8
	shr	r9, 1
	sub	rcx, r9
	cmp	r8, rcx
	ja	SHORT $LN1@Calculate_

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [r9+r8]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rax, rdx
	cmovb	rax, rdx
$LN1@Calculate_:

; 1973 :             return _Newsize; // geometric growth would be insufficient
; 1974 :         }
; 1975 : 
; 1976 :         return _Geometric; // geometric growth is sufficient
; 1977 :     }

	ret	0
?_Calculate_growth@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEBA_K_K@Z ENDP ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?max_size@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEBA_KXZ PROC ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::max_size, COMDAT

; 1873 :         return (_STD min)(

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 1874 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1875 :     }

	ret	0
?max_size@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?allocate@?$allocator@UCrcEntry@ResTableFile@@@std@@QEAAPEAUCrcEntry@ResTableFile@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@UCrcEntry@ResTableFile@@@std@@QEAAPEAUCrcEntry@ResTableFile@@_K@Z PROC ; std::allocator<ResTableFile::CrcEntry>::allocate, COMDAT

; 972  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN32:
	sub	rsp, 40					; 00000028H

; 70   :         if (_Count > _Max_possible) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN28@allocate

; 71   :             _Throw_bad_array_new_length(); // multiply overflow
; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	lea	rcx, QWORD PTR [rdx*8]

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN9@allocate

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN28@allocate

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN18@allocate

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN18@allocate:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@allocate:

; 244  :     if (_Bytes != 0) {

	test	rcx, rcx
	je	SHORT $LN10@allocate

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H

; 87   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN10@allocate:

; 248  :     return nullptr;

	xor	eax, eax

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN28@allocate:

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN30@allocate:
?allocate@?$allocator@UCrcEntry@ResTableFile@@@std@@QEAAPEAUCrcEntry@ResTableFile@@_K@Z ENDP ; std::allocator<ResTableFile::CrcEntry>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Getal@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEBAAEBV?$allocator@UNameEntry@ResTableFile@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEBAAEBV?$allocator@UNameEntry@ResTableFile@@@2@XZ PROC ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::_Getal, COMDAT

; 2185 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2186 :     }

	ret	0
?_Getal@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@AEBAAEBV?$allocator@UNameEntry@ResTableFile@@@2@XZ ENDP ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?capacity@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEBA_KXZ PROC ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::capacity, COMDAT

; 1878 :         auto& _My_data = _Mypair._Myval2;
; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	mov	rcx, -3689348814741910323		; cccccccccccccccdH
	sar	rax, 3
	imul	rax, rcx

; 1880 :     }

	ret	0
?capacity@?$vector@UNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<ResTableFile::NameEntry,std::allocator<ResTableFile::NameEntry> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@SA_KAEBV?$allocator@UNameEntry@ResTableFile@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@SA_KAEBV?$allocator@UNameEntry@ResTableFile@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<ResTableFile::NameEntry> >::max_size, COMDAT

; 733  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 461168601842738790			; 0666666666666666H

; 734  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@SA_KAEBV?$allocator@UNameEntry@ResTableFile@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<ResTableFile::NameEntry> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Getal@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEBAAEBV?$allocator@UCrcEntry@ResTableFile@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEBAAEBV?$allocator@UCrcEntry@ResTableFile@@@2@XZ PROC ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::_Getal, COMDAT

; 2185 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2186 :     }

	ret	0
?_Getal@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@AEBAAEBV?$allocator@UCrcEntry@ResTableFile@@@2@XZ ENDP ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?capacity@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEBA_KXZ PROC ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::capacity, COMDAT

; 1878 :         auto& _My_data = _Mypair._Myval2;
; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 1880 :     }

	ret	0
?capacity@?$vector@UCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<ResTableFile::CrcEntry,std::allocator<ResTableFile::CrcEntry> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@SA_KAEBV?$allocator@UCrcEntry@ResTableFile@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@SA_KAEBV?$allocator@UCrcEntry@ResTableFile@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<ResTableFile::CrcEntry> >::max_size, COMDAT

; 733  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 734  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@SA_KAEBV?$allocator@UCrcEntry@ResTableFile@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<ResTableFile::CrcEntry> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UNameEntry@ResTableFile@@@std@@V?$_Vector_val@U?$_Simple_types@UNameEntry@ResTableFile@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UNameEntry@ResTableFile@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@UNameEntry@ResTableFile@@@std@@V?$_Vector_val@U?$_Simple_types@UNameEntry@ResTableFile@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UNameEntry@ResTableFile@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<ResTableFile::NameEntry>,std::_Vector_val<std::_Simple_types<ResTableFile::NameEntry> >,1>::_Get_first, COMDAT

; 1527 :         return *this;

	mov	rax, rcx

; 1528 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@UNameEntry@ResTableFile@@@std@@V?$_Vector_val@U?$_Simple_types@UNameEntry@ResTableFile@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UNameEntry@ResTableFile@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<ResTableFile::NameEntry>,std::_Vector_val<std::_Simple_types<ResTableFile::NameEntry> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UCrcEntry@ResTableFile@@@std@@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UCrcEntry@ResTableFile@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@UCrcEntry@ResTableFile@@@std@@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UCrcEntry@ResTableFile@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<ResTableFile::CrcEntry>,std::_Vector_val<std::_Simple_types<ResTableFile::CrcEntry> >,1>::_Get_first, COMDAT

; 1527 :         return *this;

	mov	rax, rcx

; 1528 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@UCrcEntry@ResTableFile@@@std@@V?$_Vector_val@U?$_Simple_types@UCrcEntry@ResTableFile@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UCrcEntry@ResTableFile@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<ResTableFile::CrcEntry>,std::_Vector_val<std::_Simple_types<ResTableFile::CrcEntry> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Insertion_sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
_TEXT	SEGMENT
__$ArrayPad$ = 32
_First$ = 64
_Last$ = 72
_Pred$dead$ = 80
??$_Insertion_sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z PROC ; std::_Insertion_sort_unchecked<ResTableFile::CrcEntry *,`ResTableFile::ToBinary'::`2'::<lambda_1> >, COMDAT

; 7905 : _CONSTEXPR20 _BidIt _Insertion_sort_unchecked(const _BidIt _First, const _BidIt _Last, _Pr _Pred) {

	mov	QWORD PTR [rsp+32], rsi
	push	r14
	sub	rsp, 48					; 00000030H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rsi, rdx
	mov	r14, rcx

; 7906 :     // insertion sort [_First, _Last)
; 7907 :     if (_First != _Last) {

	cmp	rcx, rdx
	je	$LN35@Insertion_
	mov	QWORD PTR [rsp+80], rdi

; 7908 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

	lea	rdi, QWORD PTR [rcx+8]
	cmp	rdi, rdx
	je	SHORT $LN36@Insertion_
	mov	QWORD PTR [rsp+72], rbx
	npad	4
$LL2@Insertion_:

; 7909 :             _BidIt _Hole               = _Mid;
; 7910 :             _Iter_value_t<_BidIt> _Val = _STD move(*_Mid);

	mov	rbx, QWORD PTR [rdi]
	mov	rdx, rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 172  :     std::sort(this->m_CrcEntries.begin(), this->m_CrcEntries.end(), [](ResTableFile::CrcEntry A, ResTableFile::CrcEntry B) { return A.Hash < B.Hash; });

	cmp	ebx, DWORD PTR [r14]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7912 :             if (_DEBUG_LT_PRED(_Pred, _Val, *_First)) { // found new earliest element, move to front

	jae	SHORT $LN9@Insertion_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4841 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	r8, rdi

; 4842 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	mov	rdx, r14
	add	rdi, 8
	sub	r8, r14
	mov	rcx, rdi
	sub	rcx, r8
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7914 :                 *_First = _STD move(_Val);

	mov	QWORD PTR [r14], rbx

; 7915 :             } else { // look for insertion point after first

	jmp	SHORT $LN10@Insertion_
$LN9@Insertion_:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 172  :     std::sort(this->m_CrcEntries.begin(), this->m_CrcEntries.end(), [](ResTableFile::CrcEntry A, ResTableFile::CrcEntry B) { return A.Hash < B.Hash; });

	cmp	ebx, DWORD PTR [rdi-8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7916 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

	lea	rax, QWORD PTR [rdi-8]
	jae	SHORT $LN6@Insertion_
$LL7@Insertion_:

; 7917 :                     *_Hole = _STD move(*_Prev); // move hole down

	mov	rcx, QWORD PTR [rax]
	mov	QWORD PTR [rdx], rcx
	mov	rdx, rax
	sub	rax, 8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 172  :     std::sort(this->m_CrcEntries.begin(), this->m_CrcEntries.end(), [](ResTableFile::CrcEntry A, ResTableFile::CrcEntry B) { return A.Hash < B.Hash; });

	cmp	ebx, DWORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7916 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

	jb	SHORT $LL7@Insertion_
$LN6@Insertion_:

; 7918 :                 }
; 7919 : 
; 7920 :                 *_Hole = _STD move(_Val); // insert element in hole

	mov	QWORD PTR [rdx], rbx
	add	rdi, 8
$LN10@Insertion_:

; 7908 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

	cmp	rdi, rsi
	jne	SHORT $LL2@Insertion_
	mov	rbx, QWORD PTR [rsp+72]
$LN36@Insertion_:
	mov	rdi, QWORD PTR [rsp+80]

; 7921 :             }
; 7922 :         }
; 7923 :     }
; 7924 : 
; 7925 :     return _Last;

	mov	rax, rsi
$LN3@Insertion_:

; 7926 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	r14
	ret	0
$LN35@Insertion_:

; 7921 :             }
; 7922 :         }
; 7923 :     }
; 7924 : 
; 7925 :     return _Last;

	mov	rax, rsi
	jmp	SHORT $LN3@Insertion_
??$_Insertion_sort_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z ENDP ; std::_Insertion_sort_unchecked<ResTableFile::CrcEntry *,`ResTableFile::ToBinary'::`2'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Make_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
_TEXT	SEGMENT
_First$ = 16
_Last$ = 24
_Pred$ = 32
??$_Make_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z PROC ; std::_Make_heap_unchecked<ResTableFile::CrcEntry *,`ResTableFile::ToBinary'::`2'::<lambda_1> >, COMDAT

; 6593 : _CONSTEXPR20 void _Make_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	push	rdi
	mov	rdi, rdx
	mov	r10, rcx

; 6594 :     // make [_First, _Last) into a heap
; 6595 :     using _Diff   = _Iter_diff_t<_RanIt>;
; 6596 :     _Diff _Bottom = _Last - _First;

	sub	rdi, rcx
	sar	rdi, 3

; 6597 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	mov	r11, rdi
	sar	r11, 1
	test	r11, r11
	jle	$LN3@Make_heap_
	mov	QWORD PTR [rsp+32], rbx
	lea	rbx, QWORD PTR [rdi-1]
	sar	rbx, 1
	mov	QWORD PTR [rsp+40], rsi
	npad	1
$LL2@Make_heap_:

; 6598 :         // reheap top half, bottom to top
; 6599 :         --_Hole;
; 6600 :         _Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

	mov	rax, QWORD PTR [r10+r11*8-8]
	dec	r11

; 6601 :         _STD _Pop_heap_hole_by_index(_First, _Hole, _Bottom, _STD move(_Val), _Pred);

	mov	r8, r11

; 6438 :     _Diff _Idx       = _Hole;

	mov	r9, r11

; 6439 : 
; 6440 :     // Check whether _Idx can have a child before calculating that child's index, since
; 6441 :     // calculating the child's index can trigger integer overflows
; 6442 :     const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; // shift for codegen
; 6443 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	cmp	r11, rbx
	jge	SHORT $LN8@Make_heap_
	npad	13
$LL7@Make_heap_:

; 6444 :         _Idx = 2 * _Idx + 2;

	lea	rdx, QWORD PTR [r9+r9]

; 6445 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {
; 6446 :             --_Idx;
; 6447 :         }
; 6448 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	mov	ecx, DWORD PTR [r10+rdx*8+8]
	cmp	DWORD PTR [r10+rdx*8+16], ecx
	sbb	r9, r9
	add	r9, 2
	add	r9, rdx
	mov	rcx, QWORD PTR [r10+r9*8]
	mov	QWORD PTR [r10+r8*8], rcx

; 6449 :         _Hole             = _Idx;

	mov	r8, r9
	cmp	r9, rbx
	jl	SHORT $LL7@Make_heap_
$LN8@Make_heap_:

; 6450 :     }
; 6451 : 
; 6452 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

	cmp	r9, rbx
	jne	SHORT $LN10@Make_heap_
	test	dil, 1
	jne	SHORT $LN10@Make_heap_

; 6453 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

	mov	rcx, QWORD PTR [r10+rdi*8-8]
	mov	QWORD PTR [r10+r8*8], rcx

; 6454 :         _Hole             = _Bottom - 1;

	lea	r8, QWORD PTR [rdi-1]
$LN10@Make_heap_:

; 6328 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	cmp	r11, r8
	jge	SHORT $LN33@Make_heap_
	npad	11
$LL17@Make_heap_:

; 6327 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

	lea	rcx, QWORD PTR [r8-1]
	sar	rcx, 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 172  :     std::sort(this->m_CrcEntries.begin(), this->m_CrcEntries.end(), [](ResTableFile::CrcEntry A, ResTableFile::CrcEntry B) { return A.Hash < B.Hash; });

	cmp	DWORD PTR [r10+rcx*8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6328 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	jae	SHORT $LN33@Make_heap_

; 6329 :          _Idx = (_Hole - 1) >> 1) { // shift for codegen
; 6330 :         // move _Hole up to parent
; 6331 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	mov	rdx, QWORD PTR [r10+rcx*8]
	mov	QWORD PTR [r10+r8*8], rdx

; 6332 :         _Hole             = _Idx;

	mov	r8, rcx
	cmp	r11, rcx
	jl	SHORT $LL17@Make_heap_
$LN33@Make_heap_:

; 6333 :     }
; 6334 : 
; 6335 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	mov	QWORD PTR [r10+r8*8], rax

; 6597 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	test	r11, r11
	jg	$LL2@Make_heap_
	mov	rsi, QWORD PTR [rsp+40]
	mov	rbx, QWORD PTR [rsp+32]
$LN3@Make_heap_:

; 6602 :     }
; 6603 : }

	pop	rdi
	ret	0
??$_Make_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z ENDP ; std::_Make_heap_unchecked<ResTableFile::CrcEntry *,`ResTableFile::ToBinary'::`2'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Sort_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
_TEXT	SEGMENT
_First$ = 32
_Last$ = 40
_Pred$ = 48
??$_Sort_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z PROC ; std::_Sort_heap_unchecked<ResTableFile::CrcEntry *,`ResTableFile::ToBinary'::`2'::<lambda_1> >, COMDAT

; 6816 : _CONSTEXPR20 void _Sort_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	sub	rsp, 24

; 6817 :     // order heap by repeatedly popping
; 6818 :     for (; _Last - _First >= 2; --_Last) {

	mov	rax, rdx
	mov	r9, rcx
	sub	rax, rcx
	and	rax, -8
	cmp	rax, 16
	jl	$LN3@Sort_heap_
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+8], rdi
	lea	rdi, QWORD PTR [rdx-8]
	mov	QWORD PTR [rsp], r14
	mov	r14d, 8
	sub	r14, rcx
	npad	5
$LL4@Sort_heap_:

; 6465 :     *_Dest      = _STD move(*_First);

	mov	rcx, QWORD PTR [r9]

; 6466 :     using _Diff = _Iter_diff_t<_RanIt>;
; 6467 :     _STD _Pop_heap_hole_by_index(

	mov	r11, rdi

; 6476 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	rax, QWORD PTR [rdi]

; 6467 :     _STD _Pop_heap_hole_by_index(

	sub	r11, r9
	sar	r11, 3
	xor	r8d, r8d

; 6438 :     _Diff _Idx       = _Hole;

	xor	r10d, r10d

; 6465 :     *_Dest      = _STD move(*_First);

	mov	QWORD PTR [rdi], rcx

; 6442 :     const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; // shift for codegen

	lea	rbx, QWORD PTR [r11-1]
	sar	rbx, 1

; 6443 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	test	rbx, rbx
	jle	SHORT $LN13@Sort_heap_
	npad	11
$LL12@Sort_heap_:

; 6444 :         _Idx = 2 * _Idx + 2;

	lea	rdx, QWORD PTR [r10+r10]

; 6445 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {
; 6446 :             --_Idx;
; 6447 :         }
; 6448 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	mov	ecx, DWORD PTR [r9+rdx*8+8]
	cmp	DWORD PTR [r9+rdx*8+16], ecx
	sbb	r10, r10
	add	r10, 2
	add	r10, rdx
	mov	rcx, QWORD PTR [r9+r10*8]
	mov	QWORD PTR [r9+r8*8], rcx

; 6449 :         _Hole             = _Idx;

	mov	r8, r10
	cmp	r10, rbx
	jl	SHORT $LL12@Sort_heap_
$LN13@Sort_heap_:

; 6450 :     }
; 6451 : 
; 6452 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

	cmp	r10, rbx
	jne	SHORT $LN15@Sort_heap_
	test	r11b, 1
	jne	SHORT $LN15@Sort_heap_

; 6453 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

	mov	rcx, QWORD PTR [r9+r11*8-8]
	mov	QWORD PTR [r9+r8*8], rcx

; 6454 :         _Hole             = _Bottom - 1;

	lea	r8, QWORD PTR [r11-1]
$LN15@Sort_heap_:

; 6328 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	test	r8, r8
	jle	SHORT $LN39@Sort_heap_
	npad	11
$LL22@Sort_heap_:

; 6327 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

	lea	rcx, QWORD PTR [r8-1]
	sar	rcx, 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 172  :     std::sort(this->m_CrcEntries.begin(), this->m_CrcEntries.end(), [](ResTableFile::CrcEntry A, ResTableFile::CrcEntry B) { return A.Hash < B.Hash; });

	cmp	DWORD PTR [r9+rcx*8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6328 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	jae	SHORT $LN39@Sort_heap_

; 6329 :          _Idx = (_Hole - 1) >> 1) { // shift for codegen
; 6330 :         // move _Hole up to parent
; 6331 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	mov	rdx, QWORD PTR [r9+rcx*8]
	mov	QWORD PTR [r9+r8*8], rdx

; 6332 :         _Hole             = _Idx;

	mov	r8, rcx
	test	rcx, rcx
	jg	SHORT $LL22@Sort_heap_
$LN39@Sort_heap_:

; 6817 :     // order heap by repeatedly popping
; 6818 :     for (; _Last - _First >= 2; --_Last) {

	sub	rdi, 8

; 6335 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	mov	QWORD PTR [r9+r8*8], rax

; 6817 :     // order heap by repeatedly popping
; 6818 :     for (; _Last - _First >= 2; --_Last) {

	lea	rax, QWORD PTR [r14+rdi]
	and	rax, -8
	cmp	rax, 16
	jge	$LL4@Sort_heap_
	mov	r14, QWORD PTR [rsp]
	mov	rdi, QWORD PTR [rsp+8]
	mov	rsi, QWORD PTR [rsp+16]
	mov	rbx, QWORD PTR [rsp+48]
$LN3@Sort_heap_:

; 6819 :         _STD _Pop_heap_unchecked(_First, _Last, _Pred);
; 6820 :     }
; 6821 : }

	add	rsp, 24
	ret	0
??$_Sort_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z ENDP ; std::_Sort_heap_unchecked<ResTableFile::CrcEntry *,`ResTableFile::ToBinary'::`2'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Partition_by_median_guess_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YA?AU?$pair@PEAUCrcEntry@ResTableFile@@PEAU12@@0@PEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@3@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
_TEXT	SEGMENT
__$ArrayPad$ = 32
__$ReturnUdt$ = 80
_First$ = 88
_Last$ = 96
_Pred$ = 104
??$_Partition_by_median_guess_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YA?AU?$pair@PEAUCrcEntry@ResTableFile@@PEAU12@@0@PEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@3@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z PROC ; std::_Partition_by_median_guess_unchecked<ResTableFile::CrcEntry *,`ResTableFile::ToBinary'::`2'::<lambda_1> >, COMDAT

; 7962 : _CONSTEXPR20 pair<_RanIt, _RanIt> _Partition_by_median_guess_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 7963 :     // partition [_First, _Last)
; 7964 :     _RanIt _Mid = _First + ((_Last - _First) >> 1); // shift for codegen

	mov	rax, r8
	mov	rdi, rdx
	sub	rax, rdx
	mov	rbx, r8
	sar	rax, 4
	mov	rsi, rcx

; 7965 :     _Guess_median_unchecked(_First, _Mid, _Prev_iter(_Last), _Pred);

	add	r8, -8
	mov	rcx, rdi
	lea	rdx, QWORD PTR [rdx+rax*8]
	call	??$_Guess_median_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z ; std::_Guess_median_unchecked<ResTableFile::CrcEntry *,`ResTableFile::ToBinary'::`2'::<lambda_1> >

; 7966 :     _RanIt _Pfirst = _Mid;
; 7967 :     _RanIt _Plast  = _Next_iter(_Pfirst);

	lea	r9, QWORD PTR [rdx+8]

; 7970 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

	cmp	rdi, rdx
	jae	SHORT $LN94@Partition_
	mov	ecx, DWORD PTR [rdx]
$LL2@Partition_:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 172  :     std::sort(this->m_CrcEntries.begin(), this->m_CrcEntries.end(), [](ResTableFile::CrcEntry A, ResTableFile::CrcEntry B) { return A.Hash < B.Hash; });

	mov	eax, DWORD PTR [rdx-8]
	lea	r8, QWORD PTR [rdx-8]
	cmp	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7970 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

	jb	SHORT $LN94@Partition_
	ja	SHORT $LN94@Partition_

; 7971 :         --_Pfirst;

	mov	rdx, r8
	mov	ecx, eax
	cmp	rdi, r8
	jb	SHORT $LL2@Partition_
$LN94@Partition_:

; 7974 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

	cmp	r9, rbx
	jae	SHORT $LN95@Partition_
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 172  :     std::sort(this->m_CrcEntries.begin(), this->m_CrcEntries.end(), [](ResTableFile::CrcEntry A, ResTableFile::CrcEntry B) { return A.Hash < B.Hash; });

	mov	ecx, DWORD PTR [rdx]
$LL4@Partition_:
	cmp	DWORD PTR [r9], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7974 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

	jb	SHORT $LN95@Partition_
	ja	SHORT $LN95@Partition_

; 7975 :         ++_Plast;

	add	r9, 8
	cmp	r9, rbx
	jb	SHORT $LL4@Partition_
$LN95@Partition_:

; 7976 :     }
; 7977 : 
; 7978 :     _RanIt _Gfirst = _Plast;

	mov	r8, r9

; 7979 :     _RanIt _Glast  = _Pfirst;

	mov	r11, rdx
	npad	7
$LL6@Partition_:

; 7982 :         for (; _Gfirst < _Last; ++_Gfirst) {

	cmp	r8, rbx
	jae	SHORT $LN96@Partition_
$LL11@Partition_:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 172  :     std::sort(this->m_CrcEntries.begin(), this->m_CrcEntries.end(), [](ResTableFile::CrcEntry A, ResTableFile::CrcEntry B) { return A.Hash < B.Hash; });

	mov	eax, DWORD PTR [rdx]
	cmp	eax, DWORD PTR [r8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7983 :             if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst)) {

	jb	SHORT $LN9@Partition_

; 7984 :                 continue;
; 7985 :             } else if (_Pred(*_Gfirst, *_Pfirst)) {

	ja	SHORT $LN96@Partition_

; 7986 :                 break;
; 7987 :             } else if (_Plast != _Gfirst) {

	cmp	r9, r8
	je	SHORT $LN19@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	mov	rcx, QWORD PTR [r8]
	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [r9], rcx

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [r8], rax
$LN19@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7982 :         for (; _Gfirst < _Last; ++_Gfirst) {

	add	r9, 8
$LN9@Partition_:
	add	r8, 8
	cmp	r8, rbx
	jb	SHORT $LL11@Partition_
$LN96@Partition_:

; 7995 :         for (; _First < _Glast; --_Glast) {

	cmp	r11, rdi
	jbe	SHORT $LN118@Partition_
	lea	r10, QWORD PTR [r11-8]
$LL14@Partition_:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 172  :     std::sort(this->m_CrcEntries.begin(), this->m_CrcEntries.end(), [](ResTableFile::CrcEntry A, ResTableFile::CrcEntry B) { return A.Hash < B.Hash; });

	mov	eax, DWORD PTR [r10]
	cmp	eax, DWORD PTR [rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7997 :             if (_DEBUG_LT_PRED(_Pred, *_Glast_prev, *_Pfirst)) {

	jb	SHORT $LN12@Partition_

; 7998 :                 continue;
; 7999 :             } else if (_Pred(*_Pfirst, *_Glast_prev)) {

	ja	SHORT $LN97@Partition_

; 8000 :                 break;
; 8001 :             } else if (--_Pfirst != _Glast_prev) {

	sub	rdx, 8
	cmp	rdx, r10
	je	SHORT $LN12@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	mov	rcx, QWORD PTR [r10]
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rdx], rcx

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [r10], rax
$LN12@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7995 :         for (; _First < _Glast; --_Glast) {

	sub	r11, 8
	sub	r10, 8
	cmp	rdi, r11
	jb	SHORT $LL14@Partition_
$LN97@Partition_:

; 8002 :                 swap(*_Pfirst, *_Glast_prev); // intentional ADL
; 8003 :             }
; 8004 :         }
; 8005 : 
; 8006 :         if (_Glast == _First && _Gfirst == _Last) {

	cmp	r11, rdi
$LN118@Partition_:
	jne	SHORT $LN27@Partition_
	cmp	r8, rbx
	je	SHORT $LN74@Partition_

; 8008 :         }
; 8009 : 
; 8010 :         if (_Glast == _First) { // no room at bottom, rotate pivot upward
; 8011 :             if (_Plast != _Gfirst) {

	cmp	r9, r8
	je	SHORT $LN43@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	mov	rcx, QWORD PTR [r9]
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rdx], rcx

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [r9], rax
$LN43@Partition_:

; 100  :     _Left    = _STD move(_Right);

	mov	rcx, QWORD PTR [r8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8015 :             ++_Plast;

	add	r9, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 99   :     _Ty _Tmp = _STD move(_Left);

	mov	rax, QWORD PTR [rdx]

; 100  :     _Left    = _STD move(_Right);

	mov	QWORD PTR [rdx], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8017 :             ++_Pfirst;

	add	rdx, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [r8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8018 :             ++_Gfirst;

	add	r8, 8
	jmp	$LL6@Partition_
$LN27@Partition_:

; 8019 :         } else if (_Gfirst == _Last) { // no room at top, rotate pivot downward

	add	r11, -8
	cmp	r8, rbx
	jne	SHORT $LN30@Partition_

; 8020 :             if (--_Glast != --_Pfirst) {

	sub	rdx, 8
	cmp	r11, rdx
	je	SHORT $LN90@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	mov	rcx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [r11]
	mov	QWORD PTR [r11], rcx

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [rdx], rax
$LN90@Partition_:

; 100  :     _Left    = _STD move(_Right);

	mov	rcx, QWORD PTR [r9-8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8024 :             swap(*_Pfirst, *--_Plast); // intentional ADL

	sub	r9, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 99   :     _Ty _Tmp = _STD move(_Left);

	mov	rax, QWORD PTR [rdx]

; 100  :     _Left    = _STD move(_Right);

	mov	QWORD PTR [rdx], rcx

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [r9], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8025 :         } else {

	jmp	$LL6@Partition_
$LN30@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 99   :     _Ty _Tmp = _STD move(_Left);

	mov	rax, QWORD PTR [r8]

; 100  :     _Left    = _STD move(_Right);

	mov	rcx, QWORD PTR [r11]
	mov	QWORD PTR [r8], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8027 :             ++_Gfirst;

	add	r8, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [r11], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8029 :     }

	jmp	$LL6@Partition_
$LN74@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR [rsi], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8007 :             return pair<_RanIt, _RanIt>(_Pfirst, _Plast);

	mov	rax, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR [rsi+8], r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8030 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
??$_Partition_by_median_guess_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YA?AU?$pair@PEAUCrcEntry@ResTableFile@@PEAU12@@0@PEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@3@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z ENDP ; std::_Partition_by_median_guess_unchecked<ResTableFile::CrcEntry *,`ResTableFile::ToBinary'::`2'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAUNameEntry@ResTableFile@@@std@@YA?A_TAEBQEAUNameEntry@ResTableFile@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAUNameEntry@ResTableFile@@@std@@YA?A_TAEBQEAUNameEntry@ResTableFile@@@Z PROC ; std::_Get_unwrapped<ResTableFile::NameEntry * const &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEBQEAUNameEntry@ResTableFile@@@std@@YA?A_TAEBQEAUNameEntry@ResTableFile@@@Z ENDP ; std::_Get_unwrapped<ResTableFile::NameEntry * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAUNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@YAPEAUNameEntry@ResTableFile@@QEAU12@0PEAU12@AEAV?$allocator@UNameEntry@ResTableFile@@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Dest$ = 24
_Al$dead$ = 32
??$_Uninitialized_move@PEAUNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@YAPEAUNameEntry@ResTableFile@@QEAU12@0PEAU12@AEAV?$allocator@UNameEntry@ResTableFile@@@0@@Z PROC ; std::_Uninitialized_move<ResTableFile::NameEntry *,std::allocator<ResTableFile::NameEntry> >, COMDAT

; 1927 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	mov	rax, r8

; 1928 :     // move [_First, _Last) to raw _Dest, using _Al
; 1929 :     // note: only called internally from elsewhere in the STL
; 1930 :     using _Ptrval     = typename _Alloc::value_type*;
; 1931 :     auto _UFirst      = _Get_unwrapped(_First);
; 1932 :     const auto _ULast = _Get_unwrapped(_Last);
; 1933 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1934 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1935 : #if _HAS_CXX20
; 1936 :         if (!_STD is_constant_evaluated())
; 1937 : #endif // _HAS_CXX20
; 1938 :         {
; 1939 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1940 :             return _Dest + (_ULast - _UFirst);
; 1941 :         }
; 1942 :     }
; 1943 : 
; 1944 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, rdx
	je	SHORT $LN88@Uninitiali

; 1927 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	mov	r9, rax
	lea	r8, QWORD PTR [rcx+24]
	sub	r9, rcx
	xor	r10d, r10d
	npad	11
$LL4@Uninitiali:
	xorps	xmm0, xmm0

; 1803 :         ++_Last;

	lea	r8, QWORD PTR [r8+40]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rax], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [r9+r8-48], r10

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [r8+r9-40], r10

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r8-64]
	movups	XMMWORD PTR [rax], xmm0
	movups	xmm1, XMMWORD PTR [r8-48]
	movups	XMMWORD PTR [rax+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	mov	QWORD PTR [r8-48], r10
	add	rax, 40					; 00000028H
	mov	QWORD PTR [r8-40], 15
	mov	BYTE PTR [r8-64], r10b
	mov	ecx, DWORD PTR [r8-32]
	mov	DWORD PTR [r9+r8-32], ecx

; 1928 :     // move [_First, _Last) to raw _Dest, using _Al
; 1929 :     // note: only called internally from elsewhere in the STL
; 1930 :     using _Ptrval     = typename _Alloc::value_type*;
; 1931 :     auto _UFirst      = _Get_unwrapped(_First);
; 1932 :     const auto _ULast = _Get_unwrapped(_Last);
; 1933 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1934 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1935 : #if _HAS_CXX20
; 1936 :         if (!_STD is_constant_evaluated())
; 1937 : #endif // _HAS_CXX20
; 1938 :         {
; 1939 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1940 :             return _Dest + (_ULast - _UFirst);
; 1941 :         }
; 1942 :     }
; 1943 : 
; 1944 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	lea	rcx, QWORD PTR [r8-24]
	cmp	rcx, rdx
	jne	SHORT $LL4@Uninitiali
$LN88@Uninitiali:

; 1946 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1947 :     }
; 1948 : 
; 1949 :     return _Backout._Release();
; 1950 : }

	ret	0
??$_Uninitialized_move@PEAUNameEntry@ResTableFile@@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@YAPEAUNameEntry@ResTableFile@@QEAU12@0PEAU12@AEAV?$allocator@UNameEntry@ResTableFile@@@0@@Z ENDP ; std::_Uninitialized_move<ResTableFile::NameEntry *,std::allocator<ResTableFile::NameEntry> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAAXXZ PROC ; std::_Uninitialized_backout_al<std::allocator<ResTableFile::NameEntry> >::_Emplace_back<>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rcx+8]
	xor	edx, edx
	xorps	xmm0, xmm0
	mov	QWORD PTR [rax+32], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rax], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rax+16], rdx

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rax+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rax], dl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rcx+8], 40			; 00000028H

; 1804 :     }

	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAAXXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<ResTableFile::NameEntry> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAUCrcEntry@ResTableFile@@@std@@YA?A_TAEBQEAUCrcEntry@ResTableFile@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAUCrcEntry@ResTableFile@@@std@@YA?A_TAEBQEAUCrcEntry@ResTableFile@@@Z PROC ; std::_Get_unwrapped<ResTableFile::CrcEntry * const &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEBQEAUCrcEntry@ResTableFile@@@std@@YA?A_TAEBQEAUCrcEntry@ResTableFile@@@Z ENDP ; std::_Get_unwrapped<ResTableFile::CrcEntry * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAUCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@0PEAU12@AEAV?$allocator@UCrcEntry@ResTableFile@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$dead$ = 72
??$_Uninitialized_move@PEAUCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@0PEAU12@AEAV?$allocator@UCrcEntry@ResTableFile@@@0@@Z PROC ; std::_Uninitialized_move<ResTableFile::CrcEntry *,std::allocator<ResTableFile::CrcEntry> >, COMDAT

; 1927 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN23:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1940 :             return _Dest + (_ULast - _UFirst);

	sar	rbx, 3
	lea	rax, QWORD PTR [rdi+rbx*8]

; 1941 :         }
; 1942 :     }
; 1943 : 
; 1944 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {
; 1946 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1947 :     }
; 1948 : 
; 1949 :     return _Backout._Release();
; 1950 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_move@PEAUCrcEntry@ResTableFile@@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@0PEAU12@AEAV?$allocator@UCrcEntry@ResTableFile@@@0@@Z ENDP ; std::_Uninitialized_move<ResTableFile::CrcEntry *,std::allocator<ResTableFile::CrcEntry> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAAXXZ PROC ; std::_Uninitialized_backout_al<std::allocator<ResTableFile::CrcEntry> >::_Emplace_back<>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rcx+8]
	xor	edx, edx
	mov	QWORD PTR [rax], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rcx+8], 8

; 1804 :     }

	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAAXXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<ResTableFile::CrcEntry> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Construct_in_place@UCrcEntry@ResTableFile@@U12@@std@@YAXAEAUCrcEntry@ResTableFile@@$$QEAU12@@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@UCrcEntry@ResTableFile@@U12@@std@@YAXAEAUCrcEntry@ResTableFile@@$$QEAU12@@Z PROC ; std::_Construct_in_place<ResTableFile::CrcEntry,ResTableFile::CrcEntry>, COMDAT

; 248  : #if _HAS_CXX20
; 249  :     if (_STD is_constant_evaluated()) {
; 250  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 251  :     } else
; 252  : #endif // _HAS_CXX20
; 253  :     {
; 254  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 255  :     }
; 256  : }

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	ret	0
??$_Construct_in_place@UCrcEntry@ResTableFile@@U12@@std@@YAXAEAUCrcEntry@ResTableFile@@$$QEAU12@@Z ENDP ; std::_Construct_in_place<ResTableFile::CrcEntry,ResTableFile::CrcEntry>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@UCrcEntry@ResTableFile@@U12@@?$_Default_allocator_traits@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@SAXAEAV?$allocator@UCrcEntry@ResTableFile@@@1@QEAUCrcEntry@ResTableFile@@$$QEAU34@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@UCrcEntry@ResTableFile@@U12@@?$_Default_allocator_traits@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@SAXAEAV?$allocator@UCrcEntry@ResTableFile@@@1@QEAUCrcEntry@ResTableFile@@$$QEAU34@@Z PROC ; std::_Default_allocator_traits<std::allocator<ResTableFile::CrcEntry> >::construct<ResTableFile::CrcEntry,ResTableFile::CrcEntry>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@UCrcEntry@ResTableFile@@U12@@?$_Default_allocator_traits@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@SAXAEAV?$allocator@UCrcEntry@ResTableFile@@@1@QEAUCrcEntry@ResTableFile@@$$QEAU34@@Z ENDP ; std::_Default_allocator_traits<std::allocator<ResTableFile::CrcEntry> >::construct<ResTableFile::CrcEntry,ResTableFile::CrcEntry>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Move_backward_unchecked@PEAUCrcEntry@ResTableFile@@PEAU12@@std@@YAPEAUCrcEntry@ResTableFile@@PEAU12@00@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Dest$ = 24
??$_Move_backward_unchecked@PEAUCrcEntry@ResTableFile@@PEAU12@@std@@YAPEAUCrcEntry@ResTableFile@@PEAU12@00@Z PROC ; std::_Move_backward_unchecked<ResTableFile::CrcEntry *,ResTableFile::CrcEntry *>, COMDAT

; 4841 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rdx, rcx

; 4928 : _CONSTEXPR20 _BidIt2 _Move_backward_unchecked(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {

	mov	rax, r8

; 4842 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	sub	rax, rdx
	mov	r8, rdx
	mov	rdx, rcx
	mov	rcx, rax
	jmp	memmove
??$_Move_backward_unchecked@PEAUCrcEntry@ResTableFile@@PEAU12@@std@@YAPEAUCrcEntry@ResTableFile@@PEAU12@00@Z ENDP ; std::_Move_backward_unchecked<ResTableFile::CrcEntry *,ResTableFile::CrcEntry *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Pop_heap_hole_by_index@PEAUCrcEntry@ResTableFile@@U12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@_J1$$QEAU12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
_TEXT	SEGMENT
_First$ = 24
_Hole$ = 32
_Bottom$ = 40
_Val$ = 48
_Pred$ = 56
??$_Pop_heap_hole_by_index@PEAUCrcEntry@ResTableFile@@U12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@_J1$$QEAU12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z PROC ; std::_Pop_heap_hole_by_index<ResTableFile::CrcEntry *,ResTableFile::CrcEntry,`ResTableFile::ToBinary'::`2'::<lambda_1> >, COMDAT

; 6432 :     _RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Bottom, _Ty&& _Val, _Pr _Pred) {

	mov	QWORD PTR [rsp+32], rbx
	push	rsi
	push	rdi

; 6433 :     // percolate _Hole to _Bottom, then push _Val
; 6434 :     _STL_INTERNAL_CHECK(_Bottom > 0);
; 6435 : 
; 6436 :     using _Diff      = _Iter_diff_t<_RanIt>;
; 6437 :     const _Diff _Top = _Hole;
; 6438 :     _Diff _Idx       = _Hole;
; 6439 : 
; 6440 :     // Check whether _Idx can have a child before calculating that child's index, since
; 6441 :     // calculating the child's index can trigger integer overflows
; 6442 :     const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; // shift for codegen

	lea	rdi, QWORD PTR [r8-1]
	mov	r10, rcx
	sar	rdi, 1
	mov	rbx, rdx
	mov	r11, rdx

; 6443 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	cmp	rdx, rdi
	jge	SHORT $LN3@Pop_heap_h
	npad	4
$LL2@Pop_heap_h:

; 6444 :         _Idx = 2 * _Idx + 2;

	lea	rcx, QWORD PTR [r11+r11]

; 6445 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {
; 6446 :             --_Idx;
; 6447 :         }
; 6448 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	mov	eax, DWORD PTR [r10+rcx*8+8]
	cmp	DWORD PTR [r10+rcx*8+16], eax
	sbb	r11, r11
	add	r11, 2
	add	r11, rcx
	mov	rax, QWORD PTR [r10+r11*8]
	mov	QWORD PTR [r10+rdx*8], rax

; 6449 :         _Hole             = _Idx;

	mov	rdx, r11
	cmp	r11, rdi
	jl	SHORT $LL2@Pop_heap_h
$LN3@Pop_heap_h:

; 6450 :     }
; 6451 : 
; 6452 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

	cmp	r11, rdi
	jne	SHORT $LN5@Pop_heap_h
	test	r8b, 1
	jne	SHORT $LN5@Pop_heap_h

; 6453 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

	mov	rax, QWORD PTR [r10+r8*8-8]
	mov	QWORD PTR [r10+rdx*8], rax

; 6454 :         _Hole             = _Bottom - 1;

	lea	rdx, QWORD PTR [r8-1]
$LN5@Pop_heap_h:

; 6327 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

	lea	rax, QWORD PTR [rdx-1]
	sar	rax, 1

; 6328 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	cmp	rbx, rdx
	jge	SHORT $LN24@Pop_heap_h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 172  :     std::sort(this->m_CrcEntries.begin(), this->m_CrcEntries.end(), [](ResTableFile::CrcEntry A, ResTableFile::CrcEntry B) { return A.Hash < B.Hash; });

	mov	r8d, DWORD PTR [r9]
	npad	1
$LL12@Pop_heap_h:
	cmp	DWORD PTR [r10+rax*8], r8d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6328 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	jae	SHORT $LN24@Pop_heap_h

; 6329 :          _Idx = (_Hole - 1) >> 1) { // shift for codegen
; 6330 :         // move _Hole up to parent
; 6331 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	mov	rcx, QWORD PTR [r10+rax*8]
	mov	QWORD PTR [r10+rdx*8], rcx

; 6332 :         _Hole             = _Idx;

	mov	rdx, rax
	dec	rax
	sar	rax, 1
	cmp	rbx, rdx
	jl	SHORT $LL12@Pop_heap_h
$LN24@Pop_heap_h:

; 6455 :     }
; 6456 : 
; 6457 :     _STD _Push_heap_by_index(_First, _Hole, _Top, _STD forward<_Ty>(_Val), _Pred);
; 6458 : }

	mov	rax, QWORD PTR [r9]
	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [r10+rdx*8], rax
	pop	rdi
	pop	rsi
	ret	0
??$_Pop_heap_hole_by_index@PEAUCrcEntry@ResTableFile@@U12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@_J1$$QEAU12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z ENDP ; std::_Pop_heap_hole_by_index<ResTableFile::CrcEntry *,ResTableFile::CrcEntry,`ResTableFile::ToBinary'::`2'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Pop_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
_TEXT	SEGMENT
_First$ = 16
_Last$ = 24
_Pred$ = 32
??$_Pop_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z PROC ; std::_Pop_heap_unchecked<ResTableFile::CrcEntry *,`ResTableFile::ToBinary'::`2'::<lambda_1> >, COMDAT

; 6472 : _CONSTEXPR20 void _Pop_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	sub	rsp, 8

; 6473 :     // pop *_First to *(_Last - 1) and reheap
; 6474 :     if (2 <= _Last - _First) {

	mov	rax, rdx
	mov	r11, rdx
	sub	rax, rcx
	mov	r9, rcx
	and	rax, -8
	cmp	rax, 16
	jl	$LN2@Pop_heap_u

; 6475 :         --_Last;
; 6476 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	rax, QWORD PTR [r11-8]
	sub	r11, 8

; 6465 :     *_Dest      = _STD move(*_First);

	mov	rcx, QWORD PTR [rcx]

; 6466 :     using _Diff = _Iter_diff_t<_RanIt>;
; 6467 :     _STD _Pop_heap_hole_by_index(

	xor	r8d, r8d

; 6473 :     // pop *_First to *(_Last - 1) and reheap
; 6474 :     if (2 <= _Last - _First) {

	mov	QWORD PTR [rsp+32], rbx

; 6438 :     _Diff _Idx       = _Hole;

	mov	r10d, r8d

; 6473 :     // pop *_First to *(_Last - 1) and reheap
; 6474 :     if (2 <= _Last - _First) {

	mov	QWORD PTR [rsp], rdi

; 6465 :     *_Dest      = _STD move(*_First);

	mov	QWORD PTR [r11], rcx

; 6466 :     using _Diff = _Iter_diff_t<_RanIt>;
; 6467 :     _STD _Pop_heap_hole_by_index(

	sub	r11, r9
	sar	r11, 3

; 6442 :     const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; // shift for codegen

	lea	rbx, QWORD PTR [r11-1]
	sar	rbx, 1

; 6443 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	test	rbx, rbx
	jle	SHORT $LN8@Pop_heap_u
	npad	2
$LL7@Pop_heap_u:

; 6444 :         _Idx = 2 * _Idx + 2;

	lea	rdx, QWORD PTR [r10+r10]

; 6445 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {
; 6446 :             --_Idx;
; 6447 :         }
; 6448 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	mov	ecx, DWORD PTR [r9+rdx*8+8]
	cmp	DWORD PTR [r9+rdx*8+16], ecx
	sbb	r10, r10
	add	r10, 2
	add	r10, rdx
	mov	rcx, QWORD PTR [r9+r10*8]
	mov	QWORD PTR [r9+r8*8], rcx

; 6449 :         _Hole             = _Idx;

	mov	r8, r10
	cmp	r10, rbx
	jl	SHORT $LL7@Pop_heap_u
$LN8@Pop_heap_u:

; 6450 :     }
; 6451 : 
; 6452 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

	cmp	r10, rbx
	mov	rbx, QWORD PTR [rsp+32]
	jne	SHORT $LN10@Pop_heap_u
	test	r11b, 1
	jne	SHORT $LN10@Pop_heap_u

; 6453 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

	mov	rcx, QWORD PTR [r9+r11*8-8]
	mov	QWORD PTR [r9+r8*8], rcx

; 6454 :         _Hole             = _Bottom - 1;

	lea	r8, QWORD PTR [r11-1]
$LN10@Pop_heap_u:
	mov	rdi, QWORD PTR [rsp]

; 6328 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	test	r8, r8
	jle	SHORT $LN29@Pop_heap_u
	npad	2
$LL17@Pop_heap_u:

; 6327 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

	lea	rcx, QWORD PTR [r8-1]
	sar	rcx, 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 172  :     std::sort(this->m_CrcEntries.begin(), this->m_CrcEntries.end(), [](ResTableFile::CrcEntry A, ResTableFile::CrcEntry B) { return A.Hash < B.Hash; });

	cmp	DWORD PTR [r9+rcx*8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6328 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	jae	SHORT $LN29@Pop_heap_u

; 6329 :          _Idx = (_Hole - 1) >> 1) { // shift for codegen
; 6330 :         // move _Hole up to parent
; 6331 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	mov	rdx, QWORD PTR [r9+rcx*8]
	mov	QWORD PTR [r9+r8*8], rdx

; 6332 :         _Hole             = _Idx;

	mov	r8, rcx
	test	rcx, rcx
	jg	SHORT $LL17@Pop_heap_u
$LN29@Pop_heap_u:

; 6333 :     }
; 6334 : 
; 6335 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	mov	QWORD PTR [r9+r8*8], rax
$LN2@Pop_heap_u:

; 6477 :         _STD _Pop_heap_hole_unchecked(_First, _Last, _Last, _STD move(_Val), _Pred);
; 6478 :     }
; 6479 : }

	add	rsp, 8
	ret	0
??$_Pop_heap_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z ENDP ; std::_Pop_heap_unchecked<ResTableFile::CrcEntry *,`ResTableFile::ToBinary'::`2'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Prev_iter@PEAUCrcEntry@ResTableFile@@@std@@YAPEAUCrcEntry@ResTableFile@@PEAU12@@Z
_TEXT	SEGMENT
_First$ = 8
??$_Prev_iter@PEAUCrcEntry@ResTableFile@@@std@@YAPEAUCrcEntry@ResTableFile@@PEAU12@@Z PROC ; std::_Prev_iter<ResTableFile::CrcEntry *>, COMDAT

; 1451 :     return --_First;

	lea	rax, QWORD PTR [rcx-8]

; 1452 : }

	ret	0
??$_Prev_iter@PEAUCrcEntry@ResTableFile@@@std@@YAPEAUCrcEntry@ResTableFile@@PEAU12@@Z ENDP ; std::_Prev_iter<ResTableFile::CrcEntry *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Guess_median_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
_TEXT	SEGMENT
_First$ = 16
_Mid$ = 24
_Last$ = 32
_Pred$ = 40
??$_Guess_median_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z PROC ; std::_Guess_median_unchecked<ResTableFile::CrcEntry *,`ResTableFile::ToBinary'::`2'::<lambda_1> >, COMDAT

; 7945 : _CONSTEXPR20 void _Guess_median_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {

	sub	rsp, 8

; 7946 :     // sort median element to middle
; 7947 :     using _Diff        = _Iter_diff_t<_RanIt>;
; 7948 :     const _Diff _Count = _Last - _First;

	mov	rax, r8
	mov	r10, r8
	sub	rax, rcx
	mov	r9, rcx
	sar	rax, 3

; 7949 :     if (40 < _Count) { // Tukey's ninther

	cmp	rax, 40					; 00000028H
	jle	$LN2@Guess_medi

; 7950 :         const _Diff _Step     = (_Count + 1) >> 3; // +1 can't overflow because range was made inclusive in caller

	inc	rax
	mov	QWORD PTR [rsp+40], rbx
	sar	rax, 3
	mov	QWORD PTR [rsp], rdi

; 7951 :         const _Diff _Two_step = _Step << 1; // note: intentionally discards low-order bit
; 7952 :         _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);

	mov	rdi, rax
	shl	rdi, 4
	lea	rbx, QWORD PTR [rax*8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 172  :     std::sort(this->m_CrcEntries.begin(), this->m_CrcEntries.end(), [](ResTableFile::CrcEntry A, ResTableFile::CrcEntry B) { return A.Hash < B.Hash; });

	mov	eax, DWORD PTR [rcx]
	cmp	DWORD PTR [rbx+rcx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7931 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	jae	SHORT $LN95@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 99   :     _Ty _Tmp = _STD move(_Left);

	mov	rax, QWORD PTR [rbx+rcx]

; 100  :     _Left    = _STD move(_Right);

	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rbx+r9], rcx

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [r9], rax
$LN95@Guess_medi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 172  :     std::sort(this->m_CrcEntries.begin(), this->m_CrcEntries.end(), [](ResTableFile::CrcEntry A, ResTableFile::CrcEntry B) { return A.Hash < B.Hash; });

	mov	eax, DWORD PTR [rbx+r9]
	cmp	DWORD PTR [rdi+r9], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7935 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

	jae	SHORT $LN21@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 99   :     _Ty _Tmp = _STD move(_Left);

	mov	rax, QWORD PTR [rdi+r9]

; 100  :     _Left    = _STD move(_Right);

	mov	rcx, QWORD PTR [rbx+r9]
	mov	QWORD PTR [rdi+r9], rcx

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [rbx+r9], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 172  :     std::sort(this->m_CrcEntries.begin(), this->m_CrcEntries.end(), [](ResTableFile::CrcEntry A, ResTableFile::CrcEntry B) { return A.Hash < B.Hash; });

	cmp	eax, DWORD PTR [r9]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7938 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	jae	SHORT $LN21@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	mov	rcx, QWORD PTR [r9]
	mov	QWORD PTR [rbx+r9], rcx

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [r9], rax
$LN21@Guess_medi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7953 :         _Med3_unchecked(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

	mov	r8, rdx
	sub	r8, rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 172  :     std::sort(this->m_CrcEntries.begin(), this->m_CrcEntries.end(), [](ResTableFile::CrcEntry A, ResTableFile::CrcEntry B) { return A.Hash < B.Hash; });

	mov	eax, DWORD PTR [r8]
	cmp	DWORD PTR [rdx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7931 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	jae	SHORT $LN96@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	mov	rcx, QWORD PTR [r8]
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rdx], rcx

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [r8], rax
$LN96@Guess_medi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 172  :     std::sort(this->m_CrcEntries.begin(), this->m_CrcEntries.end(), [](ResTableFile::CrcEntry A, ResTableFile::CrcEntry B) { return A.Hash < B.Hash; });

	mov	eax, DWORD PTR [rdx]
	cmp	DWORD PTR [rbx+rdx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7935 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

	jae	SHORT $LN38@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 99   :     _Ty _Tmp = _STD move(_Left);

	mov	rax, QWORD PTR [rbx+rdx]

; 100  :     _Left    = _STD move(_Right);

	mov	rcx, QWORD PTR [rdx]
	mov	QWORD PTR [rbx+rdx], rcx

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [rdx], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 172  :     std::sort(this->m_CrcEntries.begin(), this->m_CrcEntries.end(), [](ResTableFile::CrcEntry A, ResTableFile::CrcEntry B) { return A.Hash < B.Hash; });

	cmp	eax, DWORD PTR [r8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7938 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	jae	SHORT $LN38@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	mov	rcx, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rcx

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [r8], rax
$LN38@Guess_medi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7954 :         _Med3_unchecked(_Last - _Two_step, _Last - _Step, _Last, _Pred);

	mov	r11, r10
	mov	r8, r10
	sub	r11, rdi
	sub	r8, rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 172  :     std::sort(this->m_CrcEntries.begin(), this->m_CrcEntries.end(), [](ResTableFile::CrcEntry A, ResTableFile::CrcEntry B) { return A.Hash < B.Hash; });

	mov	rdi, QWORD PTR [rsp]
	mov	eax, DWORD PTR [r11]
	cmp	DWORD PTR [r8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7931 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	jae	SHORT $LN97@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	mov	rcx, QWORD PTR [r11]
	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [r8], rcx

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [r11], rax
$LN97@Guess_medi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 172  :     std::sort(this->m_CrcEntries.begin(), this->m_CrcEntries.end(), [](ResTableFile::CrcEntry A, ResTableFile::CrcEntry B) { return A.Hash < B.Hash; });

	mov	eax, DWORD PTR [r8]
	cmp	DWORD PTR [r10], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7935 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

	jae	SHORT $LN55@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 99   :     _Ty _Tmp = _STD move(_Left);

	mov	rax, QWORD PTR [r10]

; 100  :     _Left    = _STD move(_Right);

	mov	rcx, QWORD PTR [r8]
	mov	QWORD PTR [r10], rcx

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [r8], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 172  :     std::sort(this->m_CrcEntries.begin(), this->m_CrcEntries.end(), [](ResTableFile::CrcEntry A, ResTableFile::CrcEntry B) { return A.Hash < B.Hash; });

	cmp	eax, DWORD PTR [r11]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7938 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	jae	SHORT $LN55@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	mov	rcx, QWORD PTR [r11]
	mov	QWORD PTR [r8], rcx

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [r11], rax
$LN55@Guess_medi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 172  :     std::sort(this->m_CrcEntries.begin(), this->m_CrcEntries.end(), [](ResTableFile::CrcEntry A, ResTableFile::CrcEntry B) { return A.Hash < B.Hash; });

	mov	eax, DWORD PTR [rbx+r9]
	cmp	DWORD PTR [rdx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7931 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	jae	SHORT $LN98@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	mov	rcx, QWORD PTR [rbx+r9]
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rdx], rcx

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [rbx+r9], rax
$LN98@Guess_medi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 172  :     std::sort(this->m_CrcEntries.begin(), this->m_CrcEntries.end(), [](ResTableFile::CrcEntry A, ResTableFile::CrcEntry B) { return A.Hash < B.Hash; });

	mov	eax, DWORD PTR [rdx]
	cmp	DWORD PTR [r8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7935 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

	jae	SHORT $LN116@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 99   :     _Ty _Tmp = _STD move(_Left);

	mov	rax, QWORD PTR [r8]

; 100  :     _Left    = _STD move(_Right);

	mov	rcx, QWORD PTR [rdx]
	mov	QWORD PTR [r8], rcx

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [rdx], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 172  :     std::sort(this->m_CrcEntries.begin(), this->m_CrcEntries.end(), [](ResTableFile::CrcEntry A, ResTableFile::CrcEntry B) { return A.Hash < B.Hash; });

	cmp	eax, DWORD PTR [rbx+r9]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7938 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	jae	SHORT $LN116@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	mov	rcx, QWORD PTR [rbx+r9]
	mov	QWORD PTR [rdx], rcx

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [rbx+r9], rax
$LN116@Guess_medi:
	mov	rbx, QWORD PTR [rsp+40]
$LN89@Guess_medi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7959 : }

	add	rsp, 8
	ret	0
$LN2@Guess_medi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 172  :     std::sort(this->m_CrcEntries.begin(), this->m_CrcEntries.end(), [](ResTableFile::CrcEntry A, ResTableFile::CrcEntry B) { return A.Hash < B.Hash; });

	mov	eax, DWORD PTR [rcx]
	cmp	DWORD PTR [rdx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7931 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	jae	SHORT $LN99@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rdx], rcx

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [r9], rax
$LN99@Guess_medi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 172  :     std::sort(this->m_CrcEntries.begin(), this->m_CrcEntries.end(), [](ResTableFile::CrcEntry A, ResTableFile::CrcEntry B) { return A.Hash < B.Hash; });

	mov	eax, DWORD PTR [rdx]
	cmp	DWORD PTR [r8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7935 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

	jae	SHORT $LN89@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 99   :     _Ty _Tmp = _STD move(_Left);

	mov	rax, QWORD PTR [r8]

; 100  :     _Left    = _STD move(_Right);

	mov	rcx, QWORD PTR [rdx]
	mov	QWORD PTR [r8], rcx

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [rdx], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 172  :     std::sort(this->m_CrcEntries.begin(), this->m_CrcEntries.end(), [](ResTableFile::CrcEntry A, ResTableFile::CrcEntry B) { return A.Hash < B.Hash; });

	cmp	eax, DWORD PTR [r9]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7938 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	jae	SHORT $LN89@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	mov	rcx, QWORD PTR [r9]
	mov	QWORD PTR [rdx], rcx

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [r9], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7959 : }

	add	rsp, 8
	ret	0
??$_Guess_median_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z ENDP ; std::_Guess_median_unchecked<ResTableFile::CrcEntry *,`ResTableFile::ToBinary'::`2'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Next_iter@PEAUCrcEntry@ResTableFile@@@std@@YAPEAUCrcEntry@ResTableFile@@PEAU12@@Z
_TEXT	SEGMENT
_First$ = 8
??$_Next_iter@PEAUCrcEntry@ResTableFile@@@std@@YAPEAUCrcEntry@ResTableFile@@PEAU12@@Z PROC ; std::_Next_iter<ResTableFile::CrcEntry *>, COMDAT

; 1438 :     return ++_First;

	lea	rax, QWORD PTR [rcx+8]

; 1439 : }

	ret	0
??$_Next_iter@PEAUCrcEntry@ResTableFile@@@std@@YAPEAUCrcEntry@ResTableFile@@PEAU12@@Z ENDP ; std::_Next_iter<ResTableFile::CrcEntry *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$swap@UCrcEntry@ResTableFile@@$0A@@std@@YAXAEAUCrcEntry@ResTableFile@@0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$swap@UCrcEntry@ResTableFile@@$0A@@std@@YAXAEAUCrcEntry@ResTableFile@@0@Z PROC ; std::swap<ResTableFile::CrcEntry,0>, COMDAT

; 99   :     _Ty _Tmp = _STD move(_Left);
; 100  :     _Left    = _STD move(_Right);

	mov	r8, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], r8

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [rdx], rax

; 102  : }

	ret	0
??$swap@UCrcEntry@ResTableFile@@$0A@@std@@YAXAEAUCrcEntry@ResTableFile@@0@Z ENDP ; std::swap<ResTableFile::CrcEntry,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0AEAPEAUCrcEntry@ResTableFile@@AEAPEAU01@$0A@@?$pair@PEAUCrcEntry@ResTableFile@@PEAU12@@std@@QEAA@AEAPEAUCrcEntry@ResTableFile@@0@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$ = 24
??$?0AEAPEAUCrcEntry@ResTableFile@@AEAPEAU01@$0A@@?$pair@PEAUCrcEntry@ResTableFile@@PEAU12@@std@@QEAA@AEAPEAUCrcEntry@ResTableFile@@0@Z PROC ; std::pair<ResTableFile::CrcEntry *,ResTableFile::CrcEntry *>::pair<ResTableFile::CrcEntry *,ResTableFile::CrcEntry *><ResTableFile::CrcEntry * &,ResTableFile::CrcEntry * &,0>, COMDAT

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rcx+8], rax

; 243  :     }

	mov	rax, rcx
	ret	0
??$?0AEAPEAUCrcEntry@ResTableFile@@AEAPEAU01@$0A@@?$pair@PEAUCrcEntry@ResTableFile@@PEAU12@@std@@QEAA@AEAPEAUCrcEntry@ResTableFile@@0@Z ENDP ; std::pair<ResTableFile::CrcEntry *,ResTableFile::CrcEntry *>::pair<ResTableFile::CrcEntry *,ResTableFile::CrcEntry *><ResTableFile::CrcEntry * &,ResTableFile::CrcEntry * &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAUNameEntry@ResTableFile@@@std@@YA$$QEAUNameEntry@ResTableFile@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAUNameEntry@ResTableFile@@@std@@YA$$QEAUNameEntry@ResTableFile@@AEAU12@@Z PROC ; std::move<ResTableFile::NameEntry &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAUNameEntry@ResTableFile@@@std@@YA$$QEAUNameEntry@ResTableFile@@AEAU12@@Z ENDP ; std::move<ResTableFile::NameEntry &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@UNameEntry@ResTableFile@@@?$_Uninitialized_backout_al@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAAX$$QEAUNameEntry@ResTableFile@@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@UNameEntry@ResTableFile@@@?$_Uninitialized_backout_al@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAAX$$QEAUNameEntry@ResTableFile@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<ResTableFile::NameEntry> >::_Emplace_back<ResTableFile::NameEntry>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	r8, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [r8], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [r8+16], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [r8+24], rax

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [r8], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [r8+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	mov	QWORD PTR [rdx+16], rax
	mov	QWORD PTR [rdx+24], 15
	mov	BYTE PTR [rdx], al
	mov	eax, DWORD PTR [rdx+32]
	mov	DWORD PTR [r8+32], eax
	add	QWORD PTR [rcx+8], 40			; 00000028H

; 1804 :     }

	ret	0
??$_Emplace_back@UNameEntry@ResTableFile@@@?$_Uninitialized_backout_al@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@QEAAX$$QEAUNameEntry@ResTableFile@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<ResTableFile::NameEntry> >::_Emplace_back<ResTableFile::NameEntry>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@UNameEntry@ResTableFile@@$$V@?$_Default_allocator_traits@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@SAXAEAV?$allocator@UNameEntry@ResTableFile@@@1@QEAUNameEntry@ResTableFile@@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$construct@UNameEntry@ResTableFile@@$$V@?$_Default_allocator_traits@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@SAXAEAV?$allocator@UNameEntry@ResTableFile@@@1@QEAUNameEntry@ResTableFile@@@Z PROC ; std::_Default_allocator_traits<std::allocator<ResTableFile::NameEntry> >::construct<ResTableFile::NameEntry>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	xorps	xmm0, xmm0
	mov	QWORD PTR [rdx+32], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rdx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdx+16], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdx], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@UNameEntry@ResTableFile@@$$V@?$_Default_allocator_traits@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@SAXAEAV?$allocator@UNameEntry@ResTableFile@@@1@QEAUNameEntry@ResTableFile@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<ResTableFile::NameEntry> >::construct<ResTableFile::NameEntry>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Copy_memmove@PEAUCrcEntry@ResTableFile@@PEAU12@@std@@YAPEAUCrcEntry@ResTableFile@@PEAU12@00@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Copy_memmove@PEAUCrcEntry@ResTableFile@@PEAU12@@std@@YAPEAUCrcEntry@ResTableFile@@PEAU12@00@Z PROC ; std::_Copy_memmove<ResTableFile::CrcEntry *,ResTableFile::CrcEntry *>, COMDAT

; 4526 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

$LN4:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8

; 4527 :     auto _FirstPtr              = _To_address(_First);
; 4528 :     auto _LastPtr               = _To_address(_Last);
; 4529 :     auto _DestPtr               = _To_address(_Dest);
; 4530 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4531 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4532 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove

; 4535 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4536 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rdi+rbx]

; 4537 :     } else {
; 4538 :         return _Dest + (_LastPtr - _FirstPtr);
; 4539 :     }
; 4540 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_memmove@PEAUCrcEntry@ResTableFile@@PEAU12@@std@@YAPEAUCrcEntry@ResTableFile@@PEAU12@00@Z ENDP ; std::_Copy_memmove<ResTableFile::CrcEntry *,ResTableFile::CrcEntry *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_To_address@PEAUCrcEntry@ResTableFile@@@std@@YA?A_PAEBQEAUCrcEntry@ResTableFile@@@Z
_TEXT	SEGMENT
_Val$ = 8
??$_To_address@PEAUCrcEntry@ResTableFile@@@std@@YA?A_PAEBQEAUCrcEntry@ResTableFile@@@Z PROC ; std::_To_address<ResTableFile::CrcEntry *>, COMDAT

; 4395 :     _STL_INTERNAL_STATIC_ASSERT(contiguous_iterator<_Iter>);
; 4396 :     return _STD to_address(_Val);

	mov	rax, QWORD PTR [rcx]

; 4397 : }

	ret	0
??$_To_address@PEAUCrcEntry@ResTableFile@@@std@@YA?A_PAEBQEAUCrcEntry@ResTableFile@@@Z ENDP ; std::_To_address<ResTableFile::CrcEntry *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@UCrcEntry@ResTableFile@@@?$_Uninitialized_backout_al@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAAX$$QEAUCrcEntry@ResTableFile@@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@UCrcEntry@ResTableFile@@@?$_Uninitialized_backout_al@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAAX$$QEAUCrcEntry@ResTableFile@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<ResTableFile::CrcEntry> >::_Emplace_back<ResTableFile::CrcEntry>, COMDAT

; 1802 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	r8, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [r8], rax

; 1803 :         ++_Last;

	add	QWORD PTR [rcx+8], 8

; 1804 :     }

	ret	0
??$_Emplace_back@UCrcEntry@ResTableFile@@@?$_Uninitialized_backout_al@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@QEAAX$$QEAUCrcEntry@ResTableFile@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<ResTableFile::CrcEntry> >::_Emplace_back<ResTableFile::CrcEntry>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@UCrcEntry@ResTableFile@@$$V@?$_Default_allocator_traits@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@SAXAEAV?$allocator@UCrcEntry@ResTableFile@@@1@QEAUCrcEntry@ResTableFile@@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$construct@UCrcEntry@ResTableFile@@$$V@?$_Default_allocator_traits@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@SAXAEAV?$allocator@UCrcEntry@ResTableFile@@@1@QEAUCrcEntry@ResTableFile@@@Z PROC ; std::_Default_allocator_traits<std::allocator<ResTableFile::CrcEntry> >::construct<ResTableFile::CrcEntry>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	mov	QWORD PTR [rdx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@UCrcEntry@ResTableFile@@$$V@?$_Default_allocator_traits@V?$allocator@UCrcEntry@ResTableFile@@@std@@@std@@SAXAEAV?$allocator@UCrcEntry@ResTableFile@@@1@QEAUCrcEntry@ResTableFile@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<ResTableFile::CrcEntry> >::construct<ResTableFile::CrcEntry>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@UCrcEntry@ResTableFile@@@std@@YAPEAUCrcEntry@ResTableFile@@AEAU12@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@UCrcEntry@ResTableFile@@@std@@YAPEAUCrcEntry@ResTableFile@@AEAU12@@Z PROC ; std::addressof<ResTableFile::CrcEntry>, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@UCrcEntry@ResTableFile@@@std@@YAPEAUCrcEntry@ResTableFile@@AEAU12@@Z ENDP ; std::addressof<ResTableFile::CrcEntry>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@UCrcEntry@ResTableFile@@U12@$0A@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@$$QEAU12@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@UCrcEntry@ResTableFile@@U12@$0A@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@$$QEAU12@@Z PROC ; std::construct_at<ResTableFile::CrcEntry,ResTableFile::CrcEntry,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@UCrcEntry@ResTableFile@@U12@$0A@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@$$QEAU12@@Z ENDP ; std::construct_at<ResTableFile::CrcEntry,ResTableFile::CrcEntry,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Copy_backward_memmove@PEAUCrcEntry@ResTableFile@@PEAU12@@std@@YAPEAUCrcEntry@ResTableFile@@PEAU12@00@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Dest$ = 24
??$_Copy_backward_memmove@PEAUCrcEntry@ResTableFile@@PEAU12@@std@@YAPEAUCrcEntry@ResTableFile@@PEAU12@00@Z PROC ; std::_Copy_backward_memmove<ResTableFile::CrcEntry *,ResTableFile::CrcEntry *>, COMDAT

; 4834 :     // implement copy_backward-like function as memmove
; 4835 :     auto _FirstPtr              = _To_address(_First);
; 4836 :     auto _LastPtr               = _To_address(_Last);
; 4837 :     auto _DestPtr               = _To_address(_Dest);
; 4838 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4839 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4840 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4841 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rdx, rcx
	mov	rax, r8

; 4842 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	sub	rax, rdx
	mov	r8, rdx
	mov	rdx, rcx
	mov	rcx, rax
	jmp	memmove
??$_Copy_backward_memmove@PEAUCrcEntry@ResTableFile@@PEAU12@@std@@YAPEAUCrcEntry@ResTableFile@@PEAU12@00@Z ENDP ; std::_Copy_backward_memmove<ResTableFile::CrcEntry *,ResTableFile::CrcEntry *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Push_heap_by_index@PEAUCrcEntry@ResTableFile@@U12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@_J1$$QEAU12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
_TEXT	SEGMENT
_First$ = 8
_Hole$ = 16
_Top$ = 24
_Val$ = 32
_Pred$dead$ = 40
??$_Push_heap_by_index@PEAUCrcEntry@ResTableFile@@U12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@_J1$$QEAU12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z PROC ; std::_Push_heap_by_index<ResTableFile::CrcEntry *,ResTableFile::CrcEntry,`ResTableFile::ToBinary'::`2'::<lambda_1> >, COMDAT

; 6325 :     // percolate _Hole to _Top or where _Val belongs
; 6326 :     using _Diff = _Iter_diff_t<_RanIt>;
; 6327 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

	lea	rax, QWORD PTR [rdx-1]
	mov	r10, rcx
	sar	rax, 1

; 6328 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	cmp	r8, rdx
	jge	SHORT $LN12@Push_heap_
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 172  :     std::sort(this->m_CrcEntries.begin(), this->m_CrcEntries.end(), [](ResTableFile::CrcEntry A, ResTableFile::CrcEntry B) { return A.Hash < B.Hash; });

	mov	r11d, DWORD PTR [r9]
$LL4@Push_heap_:
	cmp	DWORD PTR [r10+rax*8], r11d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6328 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	jae	SHORT $LN13@Push_heap_

; 6329 :          _Idx = (_Hole - 1) >> 1) { // shift for codegen
; 6330 :         // move _Hole up to parent
; 6331 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	mov	rcx, QWORD PTR [r10+rax*8]
	mov	QWORD PTR [r10+rdx*8], rcx

; 6332 :         _Hole             = _Idx;

	mov	rdx, rax
	dec	rax
	sar	rax, 1
	cmp	r8, rdx
	jl	SHORT $LL4@Push_heap_
$LN13@Push_heap_:

; 6336 : }

	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [r10+rdx*8], rax
	ret	0
$LN12@Push_heap_:

; 6333 :     }
; 6334 : 
; 6335 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [rcx+rdx*8], rax

; 6336 : }

	ret	0
??$_Push_heap_by_index@PEAUCrcEntry@ResTableFile@@U12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@_J1$$QEAU12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z ENDP ; std::_Push_heap_by_index<ResTableFile::CrcEntry *,ResTableFile::CrcEntry,`ResTableFile::ToBinary'::`2'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Pop_heap_hole_unchecked@PEAUCrcEntry@ResTableFile@@U12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00$$QEAU12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Dest$ = 24
_Val$ = 32
_Pred$ = 40
??$_Pop_heap_hole_unchecked@PEAUCrcEntry@ResTableFile@@U12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00$$QEAU12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z PROC ; std::_Pop_heap_hole_unchecked<ResTableFile::CrcEntry *,ResTableFile::CrcEntry,`ResTableFile::ToBinary'::`2'::<lambda_1> >, COMDAT

; 6462 :     // pop *_First to *_Dest and reheap
; 6463 :     // precondition: _First != _Last
; 6464 :     // precondition: _First != _Dest
; 6465 :     *_Dest      = _STD move(*_First);

	mov	rax, QWORD PTR [rcx]

; 6466 :     using _Diff = _Iter_diff_t<_RanIt>;
; 6467 :     _STD _Pop_heap_hole_by_index(

	sub	rdx, rcx
	sar	rdx, 3
	mov	QWORD PTR [r8], rax
	mov	r8, rdx
	movzx	eax, BYTE PTR _Pred$[rsp]
	xor	edx, edx
	mov	BYTE PTR _Pred$[rsp], al
	jmp	??$_Pop_heap_hole_by_index@PEAUCrcEntry@ResTableFile@@U12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@_J1$$QEAU12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z ; std::_Pop_heap_hole_by_index<ResTableFile::CrcEntry *,ResTableFile::CrcEntry,`ResTableFile::ToBinary'::`2'::<lambda_1> >
??$_Pop_heap_hole_unchecked@PEAUCrcEntry@ResTableFile@@U12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00$$QEAU12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z ENDP ; std::_Pop_heap_hole_unchecked<ResTableFile::CrcEntry *,ResTableFile::CrcEntry,`ResTableFile::ToBinary'::`2'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Med3_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
_TEXT	SEGMENT
_First$ = 8
_Mid$ = 16
_Last$ = 24
_Pred$dead$ = 32
??$_Med3_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z PROC ; std::_Med3_unchecked<ResTableFile::CrcEntry *,`ResTableFile::ToBinary'::`2'::<lambda_1> >, COMDAT
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 172  :     std::sort(this->m_CrcEntries.begin(), this->m_CrcEntries.end(), [](ResTableFile::CrcEntry A, ResTableFile::CrcEntry B) { return A.Hash < B.Hash; });

	mov	eax, DWORD PTR [rcx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7929 : _CONSTEXPR20 void _Med3_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {

	mov	r10, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 172  :     std::sort(this->m_CrcEntries.begin(), this->m_CrcEntries.end(), [](ResTableFile::CrcEntry A, ResTableFile::CrcEntry B) { return A.Hash < B.Hash; });

	cmp	DWORD PTR [rdx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7931 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	jae	SHORT $LN19@Med3_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	mov	r9, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rdx], r9

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [rcx], rax
$LN19@Med3_unche:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 172  :     std::sort(this->m_CrcEntries.begin(), this->m_CrcEntries.end(), [](ResTableFile::CrcEntry A, ResTableFile::CrcEntry B) { return A.Hash < B.Hash; });

	mov	eax, DWORD PTR [rdx]
	cmp	DWORD PTR [r8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7935 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

	jae	SHORT $LN17@Med3_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 99   :     _Ty _Tmp = _STD move(_Left);

	mov	rax, QWORD PTR [r8]

; 100  :     _Left    = _STD move(_Right);

	mov	rcx, QWORD PTR [rdx]
	mov	QWORD PTR [r8], rcx

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [rdx], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\RESTBL.cpp

; 172  :     std::sort(this->m_CrcEntries.begin(), this->m_CrcEntries.end(), [](ResTableFile::CrcEntry A, ResTableFile::CrcEntry B) { return A.Hash < B.Hash; });

	cmp	eax, DWORD PTR [r10]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7938 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	jae	SHORT $LN17@Med3_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	mov	rcx, QWORD PTR [r10]
	mov	QWORD PTR [rdx], rcx

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [r10], rax
$LN17@Med3_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7942 : }

	ret	0
??$_Med3_unchecked@PEAUCrcEntry@ResTableFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUCrcEntry@ResTableFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z ENDP ; std::_Med3_unchecked<ResTableFile::CrcEntry *,`ResTableFile::ToBinary'::`2'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEAPEAUCrcEntry@ResTableFile@@@std@@YAAEAPEAUCrcEntry@ResTableFile@@AEAPEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAUCrcEntry@ResTableFile@@@std@@YAAEAPEAUCrcEntry@ResTableFile@@AEAPEAU12@@Z PROC ; std::forward<ResTableFile::CrcEntry * &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEAPEAUCrcEntry@ResTableFile@@@std@@YAAEAPEAUCrcEntry@ResTableFile@@AEAPEAU12@@Z ENDP ; std::forward<ResTableFile::CrcEntry * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@UNameEntry@ResTableFile@@@std@@YA$$QEAUNameEntry@ResTableFile@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@UNameEntry@ResTableFile@@@std@@YA$$QEAUNameEntry@ResTableFile@@AEAU12@@Z PROC ; std::forward<ResTableFile::NameEntry>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@UNameEntry@ResTableFile@@@std@@YA$$QEAUNameEntry@ResTableFile@@AEAU12@@Z ENDP ; std::forward<ResTableFile::NameEntry>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@UNameEntry@ResTableFile@@U12@@?$_Default_allocator_traits@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@SAXAEAV?$allocator@UNameEntry@ResTableFile@@@1@QEAUNameEntry@ResTableFile@@$$QEAU34@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@UNameEntry@ResTableFile@@U12@@?$_Default_allocator_traits@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@SAXAEAV?$allocator@UNameEntry@ResTableFile@@@1@QEAUNameEntry@ResTableFile@@$$QEAU34@@Z PROC ; std::_Default_allocator_traits<std::allocator<ResTableFile::NameEntry> >::construct<ResTableFile::NameEntry,ResTableFile::NameEntry>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rdx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rdx+16], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rdx+24], rax

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [rdx], xmm0
	movups	xmm1, XMMWORD PTR [r8+16]
	movups	XMMWORD PTR [rdx+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	mov	QWORD PTR [r8+16], rax
	mov	QWORD PTR [r8+24], 15
	mov	BYTE PTR [r8], al
	mov	eax, DWORD PTR [r8+32]
	mov	DWORD PTR [rdx+32], eax
	ret	0
??$construct@UNameEntry@ResTableFile@@U12@@?$_Default_allocator_traits@V?$allocator@UNameEntry@ResTableFile@@@std@@@std@@SAXAEAV?$allocator@UNameEntry@ResTableFile@@@1@QEAUNameEntry@ResTableFile@@$$QEAU34@@Z ENDP ; std::_Default_allocator_traits<std::allocator<ResTableFile::NameEntry> >::construct<ResTableFile::NameEntry,ResTableFile::NameEntry>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@UNameEntry@ResTableFile@@$$V$0A@@std@@YAPEAUNameEntry@ResTableFile@@QEAU12@@Z
_TEXT	SEGMENT
_Location$ = 8
??$construct_at@UNameEntry@ResTableFile@@$$V$0A@@std@@YAPEAUNameEntry@ResTableFile@@QEAU12@@Z PROC ; std::construct_at<ResTableFile::NameEntry,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	xorps	xmm0, xmm0
	mov	QWORD PTR [rcx+32], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@UNameEntry@ResTableFile@@$$V$0A@@std@@YAPEAUNameEntry@ResTableFile@@QEAU12@@Z ENDP ; std::construct_at<ResTableFile::NameEntry,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$to_address@UCrcEntry@ResTableFile@@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@@Z
_TEXT	SEGMENT
_Val$ = 8
??$to_address@UCrcEntry@ResTableFile@@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@@Z PROC ; std::to_address<ResTableFile::CrcEntry>, COMDAT

; 328  :     static_assert(!is_function_v<_Ty>, "N4950 [pointer.conversion]/1: Mandates: T is not a function type.");
; 329  :     return _Val;

	mov	rax, rcx

; 330  : }

	ret	0
??$to_address@UCrcEntry@ResTableFile@@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@@Z ENDP ; std::to_address<ResTableFile::CrcEntry>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@UCrcEntry@ResTableFile@@$$V$0A@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@@Z
_TEXT	SEGMENT
_Location$ = 8
??$construct_at@UCrcEntry@ResTableFile@@$$V$0A@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@@Z PROC ; std::construct_at<ResTableFile::CrcEntry,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@UCrcEntry@ResTableFile@@$$V$0A@@std@@YAPEAUCrcEntry@ResTableFile@@QEAU12@@Z ENDP ; std::construct_at<ResTableFile::CrcEntry,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@UNameEntry@ResTableFile@@U12@$0A@@std@@YAPEAUNameEntry@ResTableFile@@QEAU12@$$QEAU12@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@UNameEntry@ResTableFile@@U12@$0A@@std@@YAPEAUNameEntry@ResTableFile@@QEAU12@$$QEAU12@@Z PROC ; std::construct_at<ResTableFile::NameEntry,ResTableFile::NameEntry,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], rax

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR [rdx+16], rax
	mov	QWORD PTR [rdx+24], 15
	mov	BYTE PTR [rdx], al
	mov	eax, DWORD PTR [rdx+32]
	mov	DWORD PTR [rcx+32], eax
	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@UNameEntry@ResTableFile@@U12@$0A@@std@@YAPEAUNameEntry@ResTableFile@@QEAU12@$$QEAU12@@Z ENDP ; std::construct_at<ResTableFile::NameEntry,ResTableFile::NameEntry,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??0NameEntry@ResTableFile@@QEAA@$$QEAU01@@Z
_TEXT	SEGMENT
this$ = 8
__that$ = 16
??0NameEntry@ResTableFile@@QEAA@$$QEAU01@@Z PROC	; ResTableFile::NameEntry::NameEntry, COMDAT

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], rax

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1
	mov	QWORD PTR [rdx+16], rax
	mov	QWORD PTR [rdx+24], 15
	mov	BYTE PTR [rdx], al
	mov	eax, DWORD PTR [rdx+32]
	mov	DWORD PTR [rcx+32], eax
	mov	rax, rcx
	ret	0
??0NameEntry@ResTableFile@@QEAA@$$QEAU01@@Z ENDP	; ResTableFile::NameEntry::NameEntry
_TEXT	ENDS
END
