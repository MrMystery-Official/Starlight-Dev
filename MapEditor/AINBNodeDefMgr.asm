; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32822.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_02LMMGGCAJ@?3?5@				; `string'
PUBLIC	??_C@_07DCLBNMLN@generic@			; `string'
PUBLIC	??_C@_06FHFOAHML@system@			; `string'
PUBLIC	??_C@_03NONCDIOG@?3?5?$CC@			; `string'
PUBLIC	??_C@_04PHMHGEMA@?$CC?0?5?$CC@			; `string'
PUBLIC	??_C@_0BI@LBKDNGFK@directory_entry?3?3status@	; `string'
PUBLIC	??_C@_13BBDEGPLJ@?$AA?$CK@			; `string'
PUBLIC	??_C@_0DL@FMJPNKHC@recursive_directory_iterator?3?3r@ ; `string'
PUBLIC	??_C@_0CJ@OMKENMFB@recursive_directory_iterator?3?3o@ ; `string'
PUBLIC	??_C@_0BF@BPHJMEGE@Definitions?4eainbdef@	; `string'
PUBLIC	??_C@_0HF@MCIMJAFC@AINB?5node?5definition?5file?5has?5w@ ; `string'
PUBLIC	??_C@_0P@NFEGPIHE@AINBNodeDefMgr@		; `string'
PUBLIC	??_C@_06HKPINEAB@?5nodes@			; `string'
PUBLIC	??_C@_0BE@HBEOMHFO@Initialized?0?5found?5@	; `string'
PUBLIC	??_C@_02FAFNDFFG@AI@				; `string'
PUBLIC	??_C@_07DFGIDBBA@Control@			; `string'
PUBLIC	??_C@_04IKCBJMAN@Seq?5@				; `string'
PUBLIC	??_C@_02LJIJHEIM@?$DN?5@			; `string'
PUBLIC	??_C@_04FMFHEMAM@Fork@				; `string'
PUBLIC	??_C@_0BD@OMOHAHIM@?$DMname?5unavailable?$DO@	; `string'
PUBLIC	??_C@_06CNCLNMMD@Logic?1@			; `string'
PUBLIC	??_C@_0BG@JPHMGNJI@Could?5not?5open?5file?5?$CC@ ; `string'
PUBLIC	??_C@_03JAEEJBJJ@AI?1@				; `string'
PUBLIC	??_C@_0L@KDDAMAHG@Pack?1Actor@			; `string'
PUBLIC	??_C@_01KMDKNFGN@?1@				; `string'
PUBLIC	??_C@_08GKDCFHDH@EAINBDEF@			; `string'
PUBLIC	??_C@_0FC@DDDONPLO@Could?5not?5convert?5node?5definiti@ ; `string'
PUBLIC	??_R0?AVruntime_error@std@@@8			; std::runtime_error `RTTI Type Descriptor'
PUBLIC	??_R2system_error@std@@8			; std::system_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@system_error@std@@8		; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	_TI4?AVsystem_error@std@@
PUBLIC	_CT??_R0?AVfilesystem_error@filesystem@std@@@8??0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z136
PUBLIC	??_R1A@?0A@EA@?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@8 ; std::_Ref_count_obj2<std::filesystem::_Recursive_dir_enum_impl>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4runtime_error@std@@6B@			; std::runtime_error::`RTTI Complete Object Locator'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_7filesystem_error@filesystem@std@@6B@	; std::filesystem::filesystem_error::`vftable'
PUBLIC	??_R4_System_error@std@@6B@			; std::_System_error::`RTTI Complete Object Locator'
PUBLIC	??_R1A@?0A@EA@_Ref_count_base@std@@8		; std::_Ref_count_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@runtime_error@std@@8		; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2_System_error@std@@8			; std::_System_error::`RTTI Base Class Array'
PUBLIC	??_R0?AVsystem_error@std@@@8			; std::system_error `RTTI Type Descriptor'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@8 ; std::_Ref_count_obj2<std::filesystem::_Recursive_dir_enum_impl>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4system_error@std@@6B@			; std::system_error::`RTTI Complete Object Locator'
PUBLIC	?_Static@?1???$_Immortalize_memcpy_image@V_Generic_error_category@std@@@std@@YAAEBV_Generic_error_category@1@XZ@4V21@B ; `std::_Immortalize_memcpy_image<std::_Generic_error_category>'::`2'::_Static
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3_System_error@std@@8			; std::_System_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	_CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QEAA@AEBV01@@Z40
PUBLIC	?_Unknown_error@?4??message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@H@Z@4QBDB ; `std::_System_error_category::message'::`5'::_Unknown_error
PUBLIC	_TI5?AVfilesystem_error@filesystem@std@@
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	_CTA4?AVsystem_error@std@@
PUBLIC	?_Static@?1???$_Immortalize_memcpy_image@V_System_error_category@std@@@std@@YAAEBV_System_error_category@1@XZ@4V21@B ; `std::_Immortalize_memcpy_image<std::_System_error_category>'::`2'::_Static
PUBLIC	??_7?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@6B@ ; std::_Ref_count_obj2<std::filesystem::_Recursive_dir_enum_impl>::`vftable'
PUBLIC	??_7runtime_error@std@@6B@			; std::runtime_error::`vftable'
PUBLIC	??_7_System_error@std@@6B@			; std::_System_error::`vftable'
PUBLIC	??_R0?AV?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@@8 ; std::_Ref_count_obj2<std::filesystem::_Recursive_dir_enum_impl> `RTTI Type Descriptor'
PUBLIC	?_Is_slash@std@@3U_Is_slash_oper@1@B		; std::_Is_slash
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	_CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R1A@?0A@EA@_System_error@std@@8		; std::_System_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3filesystem_error@filesystem@std@@8		; std::filesystem::filesystem_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV_Ref_count_base@std@@@8			; std::_Ref_count_base `RTTI Type Descriptor'
PUBLIC	??_R0?AVfilesystem_error@filesystem@std@@@8	; std::filesystem::filesystem_error `RTTI Type Descriptor'
PUBLIC	??_R3_Ref_count_base@std@@8			; std::_Ref_count_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2filesystem_error@filesystem@std@@8		; std::filesystem::filesystem_error::`RTTI Base Class Array'
PUBLIC	_CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QEAA@AEBV01@@Z40
PUBLIC	??_R2runtime_error@std@@8			; std::runtime_error::`RTTI Base Class Array'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	_CTA5?AVfilesystem_error@filesystem@std@@
PUBLIC	??_R2_Ref_count_base@std@@8			; std::_Ref_count_base::`RTTI Base Class Array'
PUBLIC	??_R0?AV_System_error@std@@@8			; std::_System_error `RTTI Type Descriptor'
PUBLIC	??_R3system_error@std@@8			; std::system_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@filesystem_error@filesystem@std@@8 ; std::filesystem::filesystem_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@8 ; std::_Ref_count_obj2<std::filesystem::_Recursive_dir_enum_impl>::`RTTI Base Class Array'
PUBLIC	??_7system_error@std@@6B@			; std::system_error::`vftable'
PUBLIC	??_R3runtime_error@std@@8			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@6B@ ; std::_Ref_count_obj2<std::filesystem::_Recursive_dir_enum_impl>::`RTTI Complete Object Locator'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4filesystem_error@filesystem@std@@6B@	; std::filesystem::filesystem_error::`RTTI Complete Object Locator'
EXTRN	__std_fs_convert_wide_to_narrow_replace_chars:PROC
EXTRN	__std_fs_get_stats:PROC
EXTRN	__std_fs_code_page:PROC
EXTRN	__std_fs_directory_iterator_advance:PROC
EXTRN	__std_system_error_allocate_message:PROC
EXTRN	__std_fs_directory_iterator_close:PROC
EXTRN	__std_fs_directory_iterator_open:PROC
EXTRN	__imp_?_Syserror_map@std@@YAPEBDH@Z:PROC
EXTRN	__imp_?_Winerror_map@std@@YAHH@Z:PROC
EXTRN	__std_fs_convert_wide_to_narrow:PROC
EXTRN	__std_fs_convert_narrow_to_wide:PROC
EXTRN	__std_system_error_deallocate_message:PROC
;	COMDAT ??_R4filesystem_error@filesystem@std@@6B@
rdata$r	SEGMENT
??_R4filesystem_error@filesystem@std@@6B@ DD 01H	; std::filesystem::filesystem_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVfilesystem_error@filesystem@std@@@8
	DD	imagerel ??_R3filesystem_error@filesystem@std@@8
	DD	imagerel ??_R4filesystem_error@filesystem@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD imagerel ??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R4?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@6B@ DD 01H ; std::_Ref_count_obj2<std::filesystem::_Recursive_dir_enum_impl>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@@8
	DD	imagerel ??_R3?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@8
	DD	imagerel ??_R4?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R3runtime_error@std@@8
rdata$r	SEGMENT
??_R3runtime_error@std@@8 DD 00H			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7system_error@std@@6B@
CONST	SEGMENT
??_7system_error@std@@6B@ DQ FLAT:??_R4system_error@std@@6B@ ; std::system_error::`vftable'
	DQ	FLAT:??_Esystem_error@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_R2?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@8
rdata$r	SEGMENT
??_R2?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@8 ; std::_Ref_count_obj2<std::filesystem::_Recursive_dir_enum_impl>::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@_Ref_count_base@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD imagerel ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@filesystem_error@filesystem@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@filesystem_error@filesystem@std@@8 DD imagerel ??_R0?AVfilesystem_error@filesystem@std@@@8 ; std::filesystem::filesystem_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3filesystem_error@filesystem@std@@8
rdata$r	ENDS
;	COMDAT ??_R3system_error@std@@8
rdata$r	SEGMENT
??_R3system_error@std@@8 DD 00H				; std::system_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	imagerel ??_R2system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error@std@@@8
data$r	SEGMENT
??_R0?AV_System_error@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::_System_error `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV_System_error@std@@', 00H
data$r	ENDS
;	COMDAT ??_R2_Ref_count_base@std@@8
rdata$r	SEGMENT
??_R2_Ref_count_base@std@@8 DD imagerel ??_R1A@?0A@EA@_Ref_count_base@std@@8 ; std::_Ref_count_base::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT _CTA5?AVfilesystem_error@filesystem@std@@
xdata$x	SEGMENT
_CTA5?AVfilesystem_error@filesystem@std@@ DD 05H
	DD	imagerel _CT??_R0?AVfilesystem_error@filesystem@std@@@8??0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z136
	DD	imagerel _CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QEAA@AEBV01@@Z40
	DD	imagerel _CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QEAA@AEBV01@@Z40
	DD	imagerel _CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DQ FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DQ	FLAT:??_E_System_error_category@std@@UEAAPEAXI@Z
	DQ	FLAT:?name@_System_error_category@std@@UEBAPEBDXZ
	DQ	FLAT:?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DQ	FLAT:?default_error_condition@_System_error_category@std@@UEBA?AVerror_condition@2@H@Z
	DQ	FLAT:?equivalent@error_category@std@@UEBA_NAEBVerror_code@2@H@Z
	DQ	FLAT:?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_R2runtime_error@std@@8
rdata$r	SEGMENT
??_R2runtime_error@std@@8 DD imagerel ??_R1A@?0A@EA@runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT _CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QEAA@AEBV01@@Z40
xdata$x	SEGMENT
_CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QEAA@AEBV01@@Z40 DD 00H
	DD	imagerel ??_R0?AV_System_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	imagerel ??0_System_error@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R2filesystem_error@filesystem@std@@8
rdata$r	SEGMENT
??_R2filesystem_error@filesystem@std@@8 DD imagerel ??_R1A@?0A@EA@filesystem_error@filesystem@std@@8 ; std::filesystem::filesystem_error::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@system_error@std@@8
	DD	imagerel ??_R1A@?0A@EA@_System_error@std@@8
	DD	imagerel ??_R1A@?0A@EA@runtime_error@std@@8
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3_Ref_count_base@std@@8
rdata$r	SEGMENT
??_R3_Ref_count_base@std@@8 DD 00H			; std::_Ref_count_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2_Ref_count_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVfilesystem_error@filesystem@std@@@8
data$r	SEGMENT
??_R0?AVfilesystem_error@filesystem@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::filesystem::filesystem_error `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVfilesystem_error@filesystem@std@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AV_Ref_count_base@std@@@8
data$rs	SEGMENT
??_R0?AV_Ref_count_base@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::_Ref_count_base `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV_Ref_count_base@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3filesystem_error@filesystem@std@@8
rdata$r	SEGMENT
??_R3filesystem_error@filesystem@std@@8 DD 00H		; std::filesystem::filesystem_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	imagerel ??_R2filesystem_error@filesystem@std@@8
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error@std@@8 DD imagerel ??_R0?AV_System_error@std@@@8 ; std::_System_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3_System_error@std@@8
rdata$r	ENDS
;	COMDAT _CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVruntime_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0runtime_error@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD imagerel ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@error_category@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ?_Is_slash@std@@3U_Is_slash_oper@1@B
CONST	SEGMENT
?_Is_slash@std@@3U_Is_slash_oper@1@B	ORG $+1		; std::_Is_slash
CONST	ENDS
;	COMDAT ??_R0?AV?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::_Ref_count_obj2<std::filesystem::_Recursive_dir_enum_impl> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesyst'
	DB	'em@std@@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_7_System_error@std@@6B@
CONST	SEGMENT
??_7_System_error@std@@6B@ DQ FLAT:??_R4_System_error@std@@6B@ ; std::_System_error::`vftable'
	DQ	FLAT:??_E_System_error@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT
??_7runtime_error@std@@6B@ DQ FLAT:??_R4runtime_error@std@@6B@ ; std::runtime_error::`vftable'
	DQ	FLAT:??_Eruntime_error@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_7?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@6B@
CONST	SEGMENT
??_7?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@6B@ DQ FLAT:??_R4?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@6B@ ; std::_Ref_count_obj2<std::filesystem::_Recursive_dir_enum_impl>::`vftable'
	DQ	FLAT:?_Destroy@?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@EEAAXXZ
	DQ	FLAT:?_Delete_this@?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@EEAAXXZ
	DQ	FLAT:??_E?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@UEAAPEAXI@Z
	DQ	FLAT:?_Get_deleter@_Ref_count_base@std@@UEBAPEAXAEBVtype_info@@@Z
CONST	ENDS
;	COMDAT ?_Static@?1???$_Immortalize_memcpy_image@V_System_error_category@std@@@std@@YAAEBV_System_error_category@1@XZ@4V21@B
_DATA	SEGMENT
?_Static@?1???$_Immortalize_memcpy_image@V_System_error_category@std@@@std@@YAAEBV_System_error_category@1@XZ@4V21@B DQ FLAT:??_7_System_error_category@std@@6B@ ; `std::_Immortalize_memcpy_image<std::_System_error_category>'::`2'::_Static
	DQ	0000000000000007H
_DATA	ENDS
;	COMDAT _CTA4?AVsystem_error@std@@
xdata$x	SEGMENT
_CTA4?AVsystem_error@std@@ DD 04H
	DD	imagerel _CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QEAA@AEBV01@@Z40
	DD	imagerel _CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QEAA@AEBV01@@Z40
	DD	imagerel _CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD imagerel ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT _TI5?AVfilesystem_error@filesystem@std@@
xdata$x	SEGMENT
_TI5?AVfilesystem_error@filesystem@std@@ DD 00H
	DD	imagerel ??1filesystem_error@filesystem@std@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA5?AVfilesystem_error@filesystem@std@@
xdata$x	ENDS
;	COMDAT ?_Unknown_error@?4??message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@H@Z@4QBDB
CONST	SEGMENT
?_Unknown_error@?4??message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@H@Z@4QBDB DB 075H ; `std::_System_error_category::message'::`5'::_Unknown_error
	DB	06eH
	DB	06bH
	DB	06eH
	DB	06fH
	DB	077H
	DB	06eH
	DB	020H
	DB	065H
	DB	072H
	DB	072H
	DB	06fH
	DB	072H
	DB	00H
CONST	ENDS
;	COMDAT _CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QEAA@AEBV01@@Z40
xdata$x	SEGMENT
_CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QEAA@AEBV01@@Z40 DD 00H
	DD	imagerel ??_R0?AVsystem_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	imagerel ??0system_error@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD imagerel ??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@error_category@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
data$rs	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV_Generic_error_category@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R3_System_error@std@@8
rdata$r	SEGMENT
??_R3_System_error@std@@8 DD 00H			; std::_System_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD imagerel ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ?_Static@?1???$_Immortalize_memcpy_image@V_Generic_error_category@std@@@std@@YAAEBV_Generic_error_category@1@XZ@4V21@B
_DATA	SEGMENT
?_Static@?1???$_Immortalize_memcpy_image@V_Generic_error_category@std@@@std@@YAAEBV_Generic_error_category@1@XZ@4V21@B DQ FLAT:??_7_Generic_error_category@std@@6B@ ; `std::_Immortalize_memcpy_image<std::_Generic_error_category>'::`2'::_Static
	DQ	0000000000000003H
_DATA	ENDS
;	COMDAT ??_R4system_error@std@@6B@
rdata$r	SEGMENT
??_R4system_error@std@@6B@ DD 01H			; std::system_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVsystem_error@std@@@8
	DD	imagerel ??_R3system_error@std@@8
	DD	imagerel ??_R4system_error@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R3?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@8
rdata$r	SEGMENT
??_R3?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@8 DD 00H ; std::_Ref_count_obj2<std::filesystem::_Recursive_dir_enum_impl>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
data$rs	SEGMENT
??_R0?AV_System_error_category@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV_System_error_category@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R0?AVsystem_error@std@@@8
data$r	SEGMENT
??_R0?AVsystem_error@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::system_error `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVsystem_error@std@@', 00H
data$r	ENDS
;	COMDAT ??_R2_System_error@std@@8
rdata$r	SEGMENT
??_R2_System_error@std@@8 DD imagerel ??_R1A@?0A@EA@_System_error@std@@8 ; std::_System_error::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@runtime_error@std@@8
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@runtime_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@runtime_error@std@@8 DD imagerel ??_R0?AVruntime_error@std@@@8 ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
data$rs	SEGMENT
??_R0?AVerror_category@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVerror_category@std@@', 00H
data$rs	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DQ FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DQ	FLAT:??_E_Generic_error_category@std@@UEAAPEAXI@Z
	DQ	FLAT:?name@_Generic_error_category@std@@UEBAPEBDXZ
	DQ	FLAT:?message@_Generic_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DQ	FLAT:?default_error_condition@error_category@std@@UEBA?AVerror_condition@2@H@Z
	DQ	FLAT:?equivalent@error_category@std@@UEBA_NAEBVerror_code@2@H@Z
	DQ	FLAT:?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 01H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV_Generic_error_category@std@@@8
	DD	imagerel ??_R3_Generic_error_category@std@@8
	DD	imagerel ??_R4_Generic_error_category@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Ref_count_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Ref_count_base@std@@8 DD imagerel ??_R0?AV_Ref_count_base@std@@@8 ; std::_Ref_count_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3_Ref_count_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R4_System_error@std@@6B@
rdata$r	SEGMENT
??_R4_System_error@std@@6B@ DD 01H			; std::_System_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV_System_error@std@@@8
	DD	imagerel ??_R3_System_error@std@@8
	DD	imagerel ??_R4_System_error@std@@6B@
rdata$r	ENDS
;	COMDAT ??_7filesystem_error@filesystem@std@@6B@
CONST	SEGMENT
??_7filesystem_error@filesystem@std@@6B@ DQ FLAT:??_R4filesystem_error@filesystem@std@@6B@ ; std::filesystem::filesystem_error::`vftable'
	DQ	FLAT:??_Efilesystem_error@filesystem@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@filesystem_error@filesystem@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 01H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV_System_error_category@std@@@8
	DD	imagerel ??_R3_System_error_category@std@@8
	DD	imagerel ??_R4_System_error_category@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R4runtime_error@std@@6B@
rdata$r	SEGMENT
??_R4runtime_error@std@@6B@ DD 01H			; std::runtime_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVruntime_error@std@@@8
	DD	imagerel ??_R3runtime_error@std@@8
	DD	imagerel ??_R4runtime_error@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@8 DD imagerel ??_R0?AV?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@@8 ; std::_Ref_count_obj2<std::filesystem::_Recursive_dir_enum_impl>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@8
rdata$r	ENDS
;	COMDAT _CT??_R0?AVfilesystem_error@filesystem@std@@@8??0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z136
xdata$x	SEGMENT
_CT??_R0?AVfilesystem_error@filesystem@std@@@8??0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z136 DD 00H
	DD	imagerel ??_R0?AVfilesystem_error@filesystem@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	088H
	DD	imagerel ??0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z
xdata$x	ENDS
;	COMDAT _TI4?AVsystem_error@std@@
xdata$x	SEGMENT
_TI4?AVsystem_error@std@@ DD 00H
	DD	imagerel ??1system_error@std@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA4?AVsystem_error@std@@
xdata$x	ENDS
;	COMDAT ??_R1A@?0A@EA@system_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@system_error@std@@8 DD imagerel ??_R0?AVsystem_error@std@@@8 ; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2system_error@std@@8
rdata$r	SEGMENT
??_R2system_error@std@@8 DD imagerel ??_R1A@?0A@EA@system_error@std@@8 ; std::system_error::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@_System_error@std@@8
	DD	imagerel ??_R1A@?0A@EA@runtime_error@std@@8
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R0?AVruntime_error@std@@@8
data$r	SEGMENT
??_R0?AVruntime_error@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::runtime_error `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVruntime_error@std@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0FC@DDDONPLO@Could?5not?5convert?5node?5definiti@
CONST	SEGMENT
??_C@_0FC@DDDONPLO@Could?5not?5convert?5node?5definiti@ DB 'Could not con'
	DB	'vert node definition to node instance, node definition was a '
	DB	'nullptr', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08GKDCFHDH@EAINBDEF@
CONST	SEGMENT
??_C@_08GKDCFHDH@EAINBDEF@ DB 'EAINBDEF', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01KMDKNFGN@?1@
CONST	SEGMENT
??_C@_01KMDKNFGN@?1@ DB '/', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KDDAMAHG@Pack?1Actor@
CONST	SEGMENT
??_C@_0L@KDDAMAHG@Pack?1Actor@ DB 'Pack/Actor', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03JAEEJBJJ@AI?1@
CONST	SEGMENT
??_C@_03JAEEJBJJ@AI?1@ DB 'AI/', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JPHMGNJI@Could?5not?5open?5file?5?$CC@
CONST	SEGMENT
??_C@_0BG@JPHMGNJI@Could?5not?5open?5file?5?$CC@ DB 'Could not open file '
	DB	'"', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_06CNCLNMMD@Logic?1@
CONST	SEGMENT
??_C@_06CNCLNMMD@Logic?1@ DB 'Logic/', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OMOHAHIM@?$DMname?5unavailable?$DO@
CONST	SEGMENT
??_C@_0BD@OMOHAHIM@?$DMname?5unavailable?$DO@ DB '<name unavailable>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04FMFHEMAM@Fork@
CONST	SEGMENT
??_C@_04FMFHEMAM@Fork@ DB 'Fork', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LJIJHEIM@?$DN?5@
CONST	SEGMENT
??_C@_02LJIJHEIM@?$DN?5@ DB '= ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04IKCBJMAN@Seq?5@
CONST	SEGMENT
??_C@_04IKCBJMAN@Seq?5@ DB 'Seq ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07DFGIDBBA@Control@
CONST	SEGMENT
??_C@_07DFGIDBBA@Control@ DB 'Control', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02FAFNDFFG@AI@
CONST	SEGMENT
??_C@_02FAFNDFFG@AI@ DB 'AI', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@HBEOMHFO@Initialized?0?5found?5@
CONST	SEGMENT
??_C@_0BE@HBEOMHFO@Initialized?0?5found?5@ DB 'Initialized, found ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06HKPINEAB@?5nodes@
CONST	SEGMENT
??_C@_06HKPINEAB@?5nodes@ DB ' nodes', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NFEGPIHE@AINBNodeDefMgr@
CONST	SEGMENT
??_C@_0P@NFEGPIHE@AINBNodeDefMgr@ DB 'AINBNodeDefMgr', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HF@MCIMJAFC@AINB?5node?5definition?5file?5has?5w@
CONST	SEGMENT
??_C@_0HF@MCIMJAFC@AINB?5node?5definition?5file?5has?5w@ DB 'AINB node de'
	DB	'finition file has wrong version, expected 0x03. Did you updat'
	DB	'e the WorkingDir/Definitions.eainbdef file?', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BPHJMEGE@Definitions?4eainbdef@
CONST	SEGMENT
??_C@_0BF@BPHJMEGE@Definitions?4eainbdef@ DB 'Definitions.eainbdef', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@OMKENMFB@recursive_directory_iterator?3?3o@
CONST	SEGMENT
??_C@_0CJ@OMKENMFB@recursive_directory_iterator?3?3o@ DB 'recursive_direc'
	DB	'tory_iterator::operator++', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@FMJPNKHC@recursive_directory_iterator?3?3r@
CONST	SEGMENT
??_C@_0DL@FMJPNKHC@recursive_directory_iterator?3?3r@ DB 'recursive_direc'
	DB	'tory_iterator::recursive_directory_iterator', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_13BBDEGPLJ@?$AA?$CK@
CONST	SEGMENT
??_C@_13BBDEGPLJ@?$AA?$CK@ DB '*', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LBKDNGFK@directory_entry?3?3status@
CONST	SEGMENT
??_C@_0BI@LBKDNGFK@directory_entry?3?3status@ DB 'directory_entry::status'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_04PHMHGEMA@?$CC?0?5?$CC@
CONST	SEGMENT
??_C@_04PHMHGEMA@?$CC?0?5?$CC@ DB '", "', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03NONCDIOG@?3?5?$CC@
CONST	SEGMENT
??_C@_03NONCDIOG@?3?5?$CC@ DB ': "', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system@
CONST	SEGMENT
??_C@_06FHFOAHML@system@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02LMMGGCAJ@?3?5@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5@ DB ': ', 00H			; `string'
PUBLIC	??$forward@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA$$QEAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAPEAV10@@Z ; std::forward<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *>
PUBLIC	??$forward@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA$$QEAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAPEAV10@@Z ; std::forward<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > *>
PUBLIC	??$forward@PEAUInputParam@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAPEAUInputParam@NodeDef@AINBNodeDefMgr@@AEAPEAU123@@Z ; std::forward<AINBNodeDefMgr::NodeDef::InputParam *>
PUBLIC	??$forward@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEAPEAU123@@Z ; std::forward<AINBNodeDefMgr::NodeDef::ImmediateParam *>
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAA@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@00@Z ; std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAA@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@00@Z ; std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@00@Z ; std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@PEAUInputParam@NodeDef@AINBNodeDefMgr@@00@Z ; std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::InputParam> >::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::InputParam> >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@00@Z ; std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::ImmediateParam> >
PUBLIC	??$?0V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@PEAV21@PEAV21@@?$_Compressed_pair@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@$$QEAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@22@Z ; std::_Compressed_pair<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >,std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >,1>::_Compressed_pair<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >,std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >,1><std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >,std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *,std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *,std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *>
PUBLIC	??$exchange@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@$$T@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAPEAV10@$$QEA$$T@Z ; std::exchange<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *,std::nullptr_t>
PUBLIC	??$move@AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@AEAV10@@Z ; std::move<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > &>
PUBLIC	??$?0V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@PEAV21@PEAV21@@?$_Compressed_pair@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@$$QEAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@22@Z ; std::_Compressed_pair<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >,std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >,1>::_Compressed_pair<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >,std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >,1><std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >,std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > *,std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > *,std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > *>
PUBLIC	??$exchange@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@$$T@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAPEAV10@$$QEA$$T@Z ; std::exchange<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > *,std::nullptr_t>
PUBLIC	??$move@AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@AEAV10@@Z ; std::move<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > &>
PUBLIC	??$?0V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4234@PEAW4234@@?$_Compressed_pair@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@1@$$QEAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@22@Z ; std::_Compressed_pair<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum>,std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >,1>::_Compressed_pair<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum>,std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >,1><std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum>,enum AINBNodeDefMgr::NodeDef::CategoryEnum *,enum AINBNodeDefMgr::NodeDef::CategoryEnum *,enum AINBNodeDefMgr::NodeDef::CategoryEnum *>
PUBLIC	??$exchange@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@$$T@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@AEAPEAW4123@$$QEA$$T@Z ; std::exchange<enum AINBNodeDefMgr::NodeDef::CategoryEnum *,std::nullptr_t>
PUBLIC	??$move@AEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@YA$$QEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@0@AEAV10@@Z ; std::move<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> &>
PUBLIC	??$?0V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@PEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU234@PEAU234@@?$_Compressed_pair@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@1@$$QEAPEAUInputParam@NodeDef@AINBNodeDefMgr@@22@Z ; std::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::InputParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::InputParam> >,1>::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::InputParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::InputParam> >,1><std::allocator<AINBNodeDefMgr::NodeDef::InputParam>,AINBNodeDefMgr::NodeDef::InputParam *,AINBNodeDefMgr::NodeDef::InputParam *,AINBNodeDefMgr::NodeDef::InputParam *>
PUBLIC	??$exchange@PEAUInputParam@NodeDef@AINBNodeDefMgr@@$$T@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@AEAPEAU123@$$QEA$$T@Z ; std::exchange<AINBNodeDefMgr::NodeDef::InputParam *,std::nullptr_t>
PUBLIC	??$move@AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YA$$QEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@AEAV10@@Z ; std::move<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> &>
PUBLIC	??$?0V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU234@PEAU234@@?$_Compressed_pair@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@1@$$QEAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@22@Z ; std::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::ImmediateParam> >,1>::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::ImmediateParam> >,1><std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>,AINBNodeDefMgr::NodeDef::ImmediateParam *,AINBNodeDefMgr::NodeDef::ImmediateParam *,AINBNodeDefMgr::NodeDef::ImmediateParam *>
PUBLIC	??$exchange@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@$$T@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEAPEAU123@$$QEA$$T@Z ; std::exchange<AINBNodeDefMgr::NodeDef::ImmediateParam *,std::nullptr_t>
PUBLIC	??$move@AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YA$$QEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@AEAV10@@Z ; std::move<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> &>
PUBLIC	??$_Uninitialized_copy@PEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@00AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z ; std::_Uninitialized_copy<AINBNodeDefMgr::NodeDef::InputParam *,AINBNodeDefMgr::NodeDef::InputParam *,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >
PUBLIC	??$_Unwrap_sent@PEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@@ranges@std@@YA?A_T$$QEAPEAUInputParam@NodeDef@AINBNodeDefMgr@@@Z ; std::ranges::_Unwrap_sent<AINBNodeDefMgr::NodeDef::InputParam *,AINBNodeDefMgr::NodeDef::InputParam *>
PUBLIC	??$_Unwrap_iter@PEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@@ranges@std@@YA?A_T$$QEAPEAUInputParam@NodeDef@AINBNodeDefMgr@@@Z ; std::ranges::_Unwrap_iter<AINBNodeDefMgr::NodeDef::InputParam *,AINBNodeDefMgr::NodeDef::InputParam *>
PUBLIC	??$forward@AEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@@std@@YAAEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@AEBQEAU123@@Z ; std::forward<AINBNodeDefMgr::NodeDef::InputParam * const &>
PUBLIC	??$forward@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YA$$QEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@AEAV10@@Z ; std::forward<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >
PUBLIC	??$_Uninitialized_copy@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@00AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z ; std::_Uninitialized_copy<AINBNodeDefMgr::NodeDef::ImmediateParam *,AINBNodeDefMgr::NodeDef::ImmediateParam *,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >
PUBLIC	??$_Unwrap_sent@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@@ranges@std@@YA?A_T$$QEAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z ; std::ranges::_Unwrap_sent<AINBNodeDefMgr::NodeDef::ImmediateParam *,AINBNodeDefMgr::NodeDef::ImmediateParam *>
PUBLIC	??$_Unwrap_iter@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@@ranges@std@@YA?A_T$$QEAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z ; std::ranges::_Unwrap_iter<AINBNodeDefMgr::NodeDef::ImmediateParam *,AINBNodeDefMgr::NodeDef::ImmediateParam *>
PUBLIC	??$forward@AEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@YAAEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEBQEAU123@@Z ; std::forward<AINBNodeDefMgr::NodeDef::ImmediateParam * const &>
PUBLIC	??$forward@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YA$$QEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@AEAV10@@Z ; std::forward<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >
PUBLIC	??0?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAA@$$QEAV01@@Z ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >
PUBLIC	??0?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAA@$$QEAV01@@Z ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >
PUBLIC	??0?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@$$QEAV01@@Z ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >
PUBLIC	??0?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@QEAA@XZ ; std::allocator<AINBNodeDefMgr::NodeDef::InputParam>::allocator<AINBNodeDefMgr::NodeDef::InputParam>
PUBLIC	??0?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@$$QEAV01@@Z ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >
PUBLIC	?_Buy_nonzero@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Buy_nonzero
PUBLIC	??0?$_Vector_val@U?$_Simple_types@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::InputParam> >::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::InputParam> >
PUBLIC	??0?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@QEAA@XZ ; std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>
PUBLIC	??0?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@$$QEAV01@@Z ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >
PUBLIC	?_Buy_nonzero@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Buy_nonzero
PUBLIC	??0?$_Vector_val@U?$_Simple_types@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::ImmediateParam> >
PUBLIC	??1?$_Tidy_guard@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >::~_Tidy_guard<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >
PUBLIC	??1?$_Tidy_guard@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >::~_Tidy_guard<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >
PUBLIC	??0NodeDef@AINBNodeDefMgr@@QEAA@$$QEAU01@@Z	; AINBNodeDefMgr::NodeDef::NodeDef
PUBLIC	??0InputParam@NodeDef@AINBNodeDefMgr@@QEAA@$$QEAU012@@Z ; AINBNodeDefMgr::NodeDef::InputParam::InputParam
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::InputParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::InputParam> >,1>::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::InputParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::InputParam> >,1><>
PUBLIC	??$_Construct_n@AEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@AEBQEAU123@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@1@Z ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Construct_n<AINBNodeDefMgr::NodeDef::InputParam * const &,AINBNodeDefMgr::NodeDef::InputParam * const &>
PUBLIC	??$?0V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@$$V@?$_Compressed_pair@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@1@@Z ; std::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::InputParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::InputParam> >,1>::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::InputParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::InputParam> >,1><std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::ImmediateParam> >,1>::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::ImmediateParam> >,1><>
PUBLIC	??$_Construct_n@AEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEBQEAU123@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@1@Z ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Construct_n<AINBNodeDefMgr::NodeDef::ImmediateParam * const &,AINBNodeDefMgr::NodeDef::ImmediateParam * const &>
PUBLIC	??$?0V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@$$V@?$_Compressed_pair@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@1@@Z ; std::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::ImmediateParam> >,1>::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::ImmediateParam> >,1><std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >
PUBLIC	??$construct_at@UInputParam@NodeDef@AINBNodeDefMgr@@AEAU123@$0A@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@QEAU123@AEAU123@@Z ; std::construct_at<AINBNodeDefMgr::NodeDef::InputParam,AINBNodeDefMgr::NodeDef::InputParam &,0>
PUBLIC	??$construct_at@UImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@$0A@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@AEAU123@@Z ; std::construct_at<AINBNodeDefMgr::NodeDef::ImmediateParam,AINBNodeDefMgr::NodeDef::ImmediateParam &,0>
PUBLIC	??$construct_at@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V12@$0A@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@$$QEAV10@@Z ; std::construct_at<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,0>
PUBLIC	??$construct_at@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V12@$0A@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@$$QEAV10@@Z ; std::construct_at<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,0>
PUBLIC	??$construct_at@UNodeDef@AINBNodeDefMgr@@U12@$0A@@std@@YAPEAUNodeDef@AINBNodeDefMgr@@QEAU12@$$QEAU12@@Z ; std::construct_at<AINBNodeDefMgr::NodeDef,AINBNodeDefMgr::NodeDef,0>
PUBLIC	??$construct_at@UInputParam@NodeDef@AINBNodeDefMgr@@U123@$0A@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@QEAU123@$$QEAU123@@Z ; std::construct_at<AINBNodeDefMgr::NodeDef::InputParam,AINBNodeDefMgr::NodeDef::InputParam,0>
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SA?AV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@2@AEBV32@@Z ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::select_on_container_copy_construction
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SA?AV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@2@AEBV32@@Z ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::select_on_container_copy_construction
PUBLIC	??0?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >
PUBLIC	??0?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@AEBV01@@Z ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >
PUBLIC	??0?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >
PUBLIC	??0?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@AEBV01@@Z ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >
PUBLIC	??$construct@UInputParam@NodeDef@AINBNodeDefMgr@@AEAU123@@?$_Default_allocator_traits@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@1@QEAUInputParam@NodeDef@AINBNodeDefMgr@@AEAU345@@Z ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::construct<AINBNodeDefMgr::NodeDef::InputParam,AINBNodeDefMgr::NodeDef::InputParam &>
PUBLIC	??$forward@AEAUInputParam@NodeDef@AINBNodeDefMgr@@@std@@YAAEAUInputParam@NodeDef@AINBNodeDefMgr@@AEAU123@@Z ; std::forward<AINBNodeDefMgr::NodeDef::InputParam &>
PUBLIC	??$construct@UImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@@?$_Default_allocator_traits@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@1@QEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU345@@Z ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::construct<AINBNodeDefMgr::NodeDef::ImmediateParam,AINBNodeDefMgr::NodeDef::ImmediateParam &>
PUBLIC	??$forward@AEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@YAAEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@@Z ; std::forward<AINBNodeDefMgr::NodeDef::ImmediateParam &>
PUBLIC	??$construct_at@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@$0A@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV10@@Z ; std::construct_at<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > &,0>
PUBLIC	??$construct_at@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@$$V$0A@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@@Z ; std::construct_at<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,0>
PUBLIC	??$construct@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@$$QEAV31@@Z ; std::_Default_allocator_traits<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::construct<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >
PUBLIC	??$forward@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA$$QEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAV10@@Z ; std::forward<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >
PUBLIC	??$construct_at@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@$0A@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV10@@Z ; std::construct_at<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > &,0>
PUBLIC	??$construct_at@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@$$V$0A@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@@Z ; std::construct_at<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,0>
PUBLIC	??$construct@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@$$QEAV31@@Z ; std::_Default_allocator_traits<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::construct<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >
PUBLIC	??$forward@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA$$QEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAV10@@Z ; std::forward<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >
PUBLIC	??$construct_at@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@AEAW4123@$0A@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@QEAW4123@AEAW4123@@Z ; std::construct_at<enum AINBNodeDefMgr::NodeDef::CategoryEnum,enum AINBNodeDefMgr::NodeDef::CategoryEnum &,0>
PUBLIC	??$construct_at@UNodeDef@AINBNodeDefMgr@@$$V$0A@@std@@YAPEAUNodeDef@AINBNodeDefMgr@@QEAU12@@Z ; std::construct_at<AINBNodeDefMgr::NodeDef,0>
PUBLIC	??$construct@UNodeDef@AINBNodeDefMgr@@U12@@?$_Default_allocator_traits@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@1@QEAUNodeDef@AINBNodeDefMgr@@$$QEAU34@@Z ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef> >::construct<AINBNodeDefMgr::NodeDef,AINBNodeDefMgr::NodeDef>
PUBLIC	??$forward@UNodeDef@AINBNodeDefMgr@@@std@@YA$$QEAUNodeDef@AINBNodeDefMgr@@AEAU12@@Z ; std::forward<AINBNodeDefMgr::NodeDef>
PUBLIC	??$construct_at@UInputParam@NodeDef@AINBNodeDefMgr@@$$V$0A@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@QEAU123@@Z ; std::construct_at<AINBNodeDefMgr::NodeDef::InputParam,0>
PUBLIC	??$construct@UInputParam@NodeDef@AINBNodeDefMgr@@U123@@?$_Default_allocator_traits@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@1@QEAUInputParam@NodeDef@AINBNodeDefMgr@@$$QEAU345@@Z ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::construct<AINBNodeDefMgr::NodeDef::InputParam,AINBNodeDefMgr::NodeDef::InputParam>
PUBLIC	??$forward@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAUInputParam@NodeDef@AINBNodeDefMgr@@AEAU123@@Z ; std::forward<AINBNodeDefMgr::NodeDef::InputParam>
PUBLIC	??$construct_at@UOutputEntry@AINBFile@@$$V$0A@@std@@YAPEAUOutputEntry@AINBFile@@QEAU12@@Z ; std::construct_at<AINBFile::OutputEntry,0>
PUBLIC	??$construct_at@UImmediateParam@NodeDef@AINBNodeDefMgr@@$$V$0A@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@@Z ; std::construct_at<AINBNodeDefMgr::NodeDef::ImmediateParam,0>
PUBLIC	??$construct_at@U_Recursive_dir_enum_impl@filesystem@std@@U_Creator@_Dir_enum_impl@23@AEBW4directory_options@23@$0A@@std@@YAPEAU_Recursive_dir_enum_impl@filesystem@0@QEAU120@$$QEAU_Creator@_Dir_enum_impl@20@AEBW4directory_options@20@@Z ; std::construct_at<std::filesystem::_Recursive_dir_enum_impl,std::filesystem::_Dir_enum_impl::_Creator,enum std::filesystem::directory_options const &,0>
PUBLIC	??_GInputParam@NodeDef@AINBNodeDefMgr@@QEAAPEAXI@Z ; AINBNodeDefMgr::NodeDef::InputParam::`scalar deleting destructor'
PUBLIC	??_GImmediateParam@NodeDef@AINBNodeDefMgr@@QEAAPEAXI@Z ; AINBNodeDefMgr::NodeDef::ImmediateParam::`scalar deleting destructor'
PUBLIC	??$_Emplace_back@AEAUInputParam@NodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAXAEAUInputParam@NodeDef@AINBNodeDefMgr@@@Z ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Emplace_back<AINBNodeDefMgr::NodeDef::InputParam &>
PUBLIC	??$_Emplace_back@AEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAXAEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Emplace_back<AINBNodeDefMgr::NodeDef::ImmediateParam &>
PUBLIC	??$construct@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@AEAV31@@Z ; std::_Default_allocator_traits<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::construct<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > &>
PUBLIC	??$forward@AEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YAAEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAV10@@Z ; std::forward<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > &>
PUBLIC	??$construct@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@$$V@?$_Default_allocator_traits@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::construct<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >
PUBLIC	??$_Emplace_back@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAX$$QEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Emplace_back<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >
PUBLIC	??$move@AEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA$$QEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAV10@@Z ; std::move<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > &>
PUBLIC	??$construct@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@AEAV31@@Z ; std::_Default_allocator_traits<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::construct<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > &>
PUBLIC	??$forward@AEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YAAEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAV10@@Z ; std::forward<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > &>
PUBLIC	??$construct@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@$$V@?$_Default_allocator_traits@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::construct<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >
PUBLIC	??$_Emplace_back@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAX$$QEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Emplace_back<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >
PUBLIC	??$move@AEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA$$QEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAV10@@Z ; std::move<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > &>
PUBLIC	??$_Emplace_back@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX$$QEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@Z ; std::_Uninitialized_backout_al<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Emplace_back<enum AINBNodeDefMgr::NodeDef::CategoryEnum>
PUBLIC	??$construct_at@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@W4123@$0A@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@QEAW4123@$$QEAW4123@@Z ; std::construct_at<enum AINBNodeDefMgr::NodeDef::CategoryEnum,enum AINBNodeDefMgr::NodeDef::CategoryEnum,0>
PUBLIC	??$addressof@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@AEAW4123@@Z ; std::addressof<enum AINBNodeDefMgr::NodeDef::CategoryEnum>
PUBLIC	??$construct@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@AEAW4123@@?$_Default_allocator_traits@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@1@QEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@AEAW4345@@Z ; std::_Default_allocator_traits<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::construct<enum AINBNodeDefMgr::NodeDef::CategoryEnum,enum AINBNodeDefMgr::NodeDef::CategoryEnum &>
PUBLIC	??$forward@AEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YAAEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@AEAW4123@@Z ; std::forward<enum AINBNodeDefMgr::NodeDef::CategoryEnum &>
PUBLIC	??$_Emplace_back@U_Find_file_handle@filesystem@std@@@?$_Uninitialized_backout_al@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@@std@@QEAAX$$QEAU_Find_file_handle@filesystem@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::filesystem::_Find_file_handle> >::_Emplace_back<std::filesystem::_Find_file_handle>
PUBLIC	??$construct_at@U_Find_file_handle@filesystem@std@@U123@$0A@@std@@YAPEAU_Find_file_handle@filesystem@0@QEAU120@$$QEAU120@@Z ; std::construct_at<std::filesystem::_Find_file_handle,std::filesystem::_Find_file_handle,0>
PUBLIC	??$addressof@U_Find_file_handle@filesystem@std@@@std@@YAPEAU_Find_file_handle@filesystem@0@AEAU120@@Z ; std::addressof<std::filesystem::_Find_file_handle>
PUBLIC	??$construct@UNodeDef@AINBNodeDefMgr@@$$V@?$_Default_allocator_traits@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@1@QEAUNodeDef@AINBNodeDefMgr@@@Z ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef> >::construct<AINBNodeDefMgr::NodeDef>
PUBLIC	??$_Emplace_back@UNodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX$$QEAUNodeDef@AINBNodeDefMgr@@@Z ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef> >::_Emplace_back<AINBNodeDefMgr::NodeDef>
PUBLIC	??$move@AEAUNodeDef@AINBNodeDefMgr@@@std@@YA$$QEAUNodeDef@AINBNodeDefMgr@@AEAU12@@Z ; std::move<AINBNodeDefMgr::NodeDef &>
PUBLIC	??$construct@UInputParam@NodeDef@AINBNodeDefMgr@@$$V@?$_Default_allocator_traits@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@1@QEAUInputParam@NodeDef@AINBNodeDefMgr@@@Z ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::construct<AINBNodeDefMgr::NodeDef::InputParam>
PUBLIC	??$_Emplace_back@UInputParam@NodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX$$QEAUInputParam@NodeDef@AINBNodeDefMgr@@@Z ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Emplace_back<AINBNodeDefMgr::NodeDef::InputParam>
PUBLIC	??$move@AEAUInputParam@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAUInputParam@NodeDef@AINBNodeDefMgr@@AEAU123@@Z ; std::move<AINBNodeDefMgr::NodeDef::InputParam &>
PUBLIC	??$destroy_at@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@YAXQEAUInputParam@NodeDef@AINBNodeDefMgr@@@Z ; std::destroy_at<AINBNodeDefMgr::NodeDef::InputParam>
PUBLIC	??$construct@UOutputEntry@AINBFile@@$$V@?$_Default_allocator_traits@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@SAXAEAV?$allocator@UOutputEntry@AINBFile@@@1@QEAUOutputEntry@AINBFile@@@Z ; std::_Default_allocator_traits<std::allocator<AINBFile::OutputEntry> >::construct<AINBFile::OutputEntry>
PUBLIC	??$construct_at@UImmediateParam@NodeDef@AINBNodeDefMgr@@U123@$0A@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@$$QEAU123@@Z ; std::construct_at<AINBNodeDefMgr::NodeDef::ImmediateParam,AINBNodeDefMgr::NodeDef::ImmediateParam,0>
PUBLIC	??$construct@UImmediateParam@NodeDef@AINBNodeDefMgr@@$$V@?$_Default_allocator_traits@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@1@QEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::construct<AINBNodeDefMgr::NodeDef::ImmediateParam>
PUBLIC	??$_Emplace_back@UImmediateParam@NodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX$$QEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Emplace_back<AINBNodeDefMgr::NodeDef::ImmediateParam>
PUBLIC	??$destroy_at@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@YAXQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z ; std::destroy_at<AINBNodeDefMgr::NodeDef::ImmediateParam>
PUBLIC	??$_Construct_in_place@U_Recursive_dir_enum_impl@filesystem@std@@U_Creator@_Dir_enum_impl@23@AEBW4directory_options@23@@std@@YAXAEAU_Recursive_dir_enum_impl@filesystem@0@$$QEAU_Creator@_Dir_enum_impl@20@AEBW4directory_options@20@@Z ; std::_Construct_in_place<std::filesystem::_Recursive_dir_enum_impl,std::filesystem::_Dir_enum_impl::_Creator,enum std::filesystem::directory_options const &>
PUBLIC	??$?0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@_W@1@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> ><std::basic_string_view<wchar_t,std::char_traits<wchar_t> >,0>
PUBLIC	?_Tidy@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Tidy
PUBLIC	?_Tidy@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Tidy
PUBLIC	??1?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::~vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >
PUBLIC	??1?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::~vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@@std@@QEAA@PEAU_Find_file_handle@filesystem@1@AEAV?$allocator@U_Find_file_handle@filesystem@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::filesystem::_Find_file_handle> >::_Uninitialized_backout_al<std::allocator<std::filesystem::_Find_file_handle> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<std::filesystem::_Find_file_handle> >::~_Uninitialized_backout_al<std::allocator<std::filesystem::_Find_file_handle> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@@std@@QEAAPEAU_Find_file_handle@filesystem@2@XZ ; std::_Uninitialized_backout_al<std::allocator<std::filesystem::_Find_file_handle> >::_Release
PUBLIC	??_G_Recursive_dir_enum_impl@filesystem@std@@QEAAPEAXI@Z ; std::filesystem::_Recursive_dir_enum_impl::`scalar deleting destructor'
PUBLIC	??_G?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAXI@Z ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::`scalar deleting destructor'
PUBLIC	??_G?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAXI@Z ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::`scalar deleting destructor'
PUBLIC	??_GNodeDef@AINBNodeDefMgr@@QEAAPEAXI@Z		; AINBNodeDefMgr::NodeDef::`scalar deleting destructor'
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@@std@@QEAAX_K@Z ; std::_Uninitialized_backout_al<std::allocator<std::filesystem::_Find_file_handle> >::__autoclassinit2
PUBLIC	??0ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@$$QEAU012@@Z ; AINBNodeDefMgr::NodeDef::ImmediateParam::ImmediateParam
PUBLIC	??$_Get_size_of_n@$0PI@@std@@YA_K_K@Z		; std::_Get_size_of_n<248>
PUBLIC	??$_Get_size_of_n@$0JA@@std@@YA_K_K@Z		; std::_Get_size_of_n<144>
PUBLIC	??$_Refancy@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@$0A@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@@Z ; std::_Refancy<enum AINBNodeDefMgr::NodeDef::CategoryEnum *,0>
PUBLIC	??1_Recursive_dir_enum_impl@filesystem@std@@QEAA@XZ ; std::filesystem::_Recursive_dir_enum_impl::~_Recursive_dir_enum_impl
PUBLIC	??$_Destroy_in_place@U_Recursive_dir_enum_impl@filesystem@std@@@std@@YAXAEAU_Recursive_dir_enum_impl@filesystem@0@@Z ; std::_Destroy_in_place<std::filesystem::_Recursive_dir_enum_impl>
PUBLIC	??$_Copy_n_unchecked4@PEAUInputParam@NodeDef@AINBNodeDefMgr@@_KPEAU123@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0@Z ; std::_Copy_n_unchecked4<AINBNodeDefMgr::NodeDef::InputParam *,unsigned __int64,AINBNodeDefMgr::NodeDef::InputParam *>
PUBLIC	??$_Uninitialized_copy_n@PEAUInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z ; std::_Uninitialized_copy_n<AINBNodeDefMgr::NodeDef::InputParam *,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >
PUBLIC	??$_Get_unwrapped@PEAUInputParam@NodeDef@AINBNodeDefMgr@@@std@@YA?A_T$$QEAPEAUInputParam@NodeDef@AINBNodeDefMgr@@@Z ; std::_Get_unwrapped<AINBNodeDefMgr::NodeDef::InputParam *>
PUBLIC	??$move@AEAPEAUInputParam@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAPEAUInputParam@NodeDef@AINBNodeDefMgr@@AEAPEAU123@@Z ; std::move<AINBNodeDefMgr::NodeDef::InputParam * &>
PUBLIC	??$_Copy_n_unchecked4@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_KPEAU123@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0@Z ; std::_Copy_n_unchecked4<AINBNodeDefMgr::NodeDef::ImmediateParam *,unsigned __int64,AINBNodeDefMgr::NodeDef::ImmediateParam *>
PUBLIC	??$_Uninitialized_copy_n@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z ; std::_Uninitialized_copy_n<AINBNodeDefMgr::NodeDef::ImmediateParam *,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >
PUBLIC	??$_Get_unwrapped@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@YA?A_T$$QEAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z ; std::_Get_unwrapped<AINBNodeDefMgr::NodeDef::ImmediateParam *>
PUBLIC	??$move@AEAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEAPEAU123@@Z ; std::move<AINBNodeDefMgr::NodeDef::ImmediateParam * &>
PUBLIC	??$destroy_at@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YAXQEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@@Z ; std::destroy_at<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >
PUBLIC	??$destroy_at@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YAXQEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@@Z ; std::destroy_at<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >
PUBLIC	??$destroy_at@UNodeDef@AINBNodeDefMgr@@@std@@YAXQEAUNodeDef@AINBNodeDefMgr@@@Z ; std::destroy_at<AINBNodeDefMgr::NodeDef>
PUBLIC	??$_Construct_in_place@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@@Z ; std::_Construct_in_place<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Emplace_back@AEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAXAEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Emplace_back<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > &>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAXXZ ; std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Emplace_back<>
PUBLIC	??$_Uninitialized_move@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >
PUBLIC	??$_Get_unwrapped@AEBQEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA?A_TAEBQEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@@Z ; std::_Get_unwrapped<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > * const &>
PUBLIC	??$_Emplace_back@AEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAXAEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Emplace_back<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > &>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAXXZ ; std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Emplace_back<>
PUBLIC	??$_Uninitialized_move@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > *,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >
PUBLIC	??$_Get_unwrapped@AEBQEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA?A_TAEBQEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@@Z ; std::_Get_unwrapped<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > * const &>
PUBLIC	??$to_address@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@QEAW4123@@Z ; std::to_address<enum AINBNodeDefMgr::NodeDef::CategoryEnum>
PUBLIC	??$_Uninitialized_move@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@QEAW4123@0PEAW4123@AEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@0@@Z ; std::_Uninitialized_move<enum AINBNodeDefMgr::NodeDef::CategoryEnum *,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >
PUBLIC	??$_Get_unwrapped@AEBQEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YA?A_TAEBQEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@Z ; std::_Get_unwrapped<enum AINBNodeDefMgr::NodeDef::CategoryEnum * const &>
PUBLIC	??$construct@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@W4123@@?$_Default_allocator_traits@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@1@QEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@$$QEAW4345@@Z ; std::_Default_allocator_traits<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::construct<enum AINBNodeDefMgr::NodeDef::CategoryEnum,enum AINBNodeDefMgr::NodeDef::CategoryEnum>
PUBLIC	??$_Construct_in_place@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@W4123@@std@@YAXAEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@$$QEAW4123@@Z ; std::_Construct_in_place<enum AINBNodeDefMgr::NodeDef::CategoryEnum,enum AINBNodeDefMgr::NodeDef::CategoryEnum>
PUBLIC	??$_Copy_memmove@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@00@Z ; std::_Copy_memmove<enum AINBNodeDefMgr::NodeDef::CategoryEnum *,enum AINBNodeDefMgr::NodeDef::CategoryEnum *>
PUBLIC	??$_Emplace_back@AEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAXAEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@Z ; std::_Uninitialized_backout_al<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Emplace_back<enum AINBNodeDefMgr::NodeDef::CategoryEnum &>
PUBLIC	??$_Uninitialized_move@PEAU_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@YAPEAU_Find_file_handle@filesystem@0@QEAU120@0PEAU120@AEAV?$allocator@U_Find_file_handle@filesystem@std@@@0@@Z ; std::_Uninitialized_move<std::filesystem::_Find_file_handle *,std::allocator<std::filesystem::_Find_file_handle> >
PUBLIC	??$_Get_unwrapped@AEBQEAU_Find_file_handle@filesystem@std@@@std@@YA?A_TAEBQEAU_Find_file_handle@filesystem@0@@Z ; std::_Get_unwrapped<std::filesystem::_Find_file_handle * const &>
PUBLIC	??$construct@U_Find_file_handle@filesystem@std@@U123@@?$_Default_allocator_traits@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@@std@@SAXAEAV?$allocator@U_Find_file_handle@filesystem@std@@@1@QEAU_Find_file_handle@filesystem@1@$$QEAU341@@Z ; std::_Default_allocator_traits<std::allocator<std::filesystem::_Find_file_handle> >::construct<std::filesystem::_Find_file_handle,std::filesystem::_Find_file_handle>
PUBLIC	??$_Construct_in_place@U_Find_file_handle@filesystem@std@@U123@@std@@YAXAEAU_Find_file_handle@filesystem@0@$$QEAU120@@Z ; std::_Construct_in_place<std::filesystem::_Find_file_handle,std::filesystem::_Find_file_handle>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAXXZ ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef> >::_Emplace_back<>
PUBLIC	??$_Uninitialized_move@PEAUNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUNodeDef@AINBNodeDefMgr@@QEAU12@0PEAU12@AEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@0@@Z ; std::_Uninitialized_move<AINBNodeDefMgr::NodeDef *,std::allocator<AINBNodeDefMgr::NodeDef> >
PUBLIC	??$_Get_unwrapped@AEBQEAUNodeDef@AINBNodeDefMgr@@@std@@YA?A_TAEBQEAUNodeDef@AINBNodeDefMgr@@@Z ; std::_Get_unwrapped<AINBNodeDefMgr::NodeDef * const &>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAXXZ ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Emplace_back<>
PUBLIC	??$_Uninitialized_move@PEAUInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@QEAU123@0PEAU123@AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z ; std::_Uninitialized_move<AINBNodeDefMgr::NodeDef::InputParam *,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >
PUBLIC	??$_Get_unwrapped@AEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@@std@@YA?A_TAEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@@Z ; std::_Get_unwrapped<AINBNodeDefMgr::NodeDef::InputParam * const &>
PUBLIC	??$destroy@UInputParam@NodeDef@AINBNodeDefMgr@@@?$_Default_allocator_traits@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@1@QEAUInputParam@NodeDef@AINBNodeDefMgr@@@Z ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::destroy<AINBNodeDefMgr::NodeDef::InputParam>
PUBLIC	??$_Unfancy@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@@Z ; std::_Unfancy<AINBNodeDefMgr::NodeDef::InputParam>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@QEAAXXZ ; std::_Uninitialized_backout_al<std::allocator<AINBFile::OutputEntry> >::_Emplace_back<>
PUBLIC	??$construct@UImmediateParam@NodeDef@AINBNodeDefMgr@@U123@@?$_Default_allocator_traits@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@1@QEAUImmediateParam@NodeDef@AINBNodeDefMgr@@$$QEAU345@@Z ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::construct<AINBNodeDefMgr::NodeDef::ImmediateParam,AINBNodeDefMgr::NodeDef::ImmediateParam>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAXXZ ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Emplace_back<>
PUBLIC	??$_Uninitialized_move@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@0PEAU123@AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z ; std::_Uninitialized_move<AINBNodeDefMgr::NodeDef::ImmediateParam *,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >
PUBLIC	??$_Get_unwrapped@AEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@YA?A_TAEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z ; std::_Get_unwrapped<AINBNodeDefMgr::NodeDef::ImmediateParam * const &>
PUBLIC	??$destroy@UImmediateParam@NodeDef@AINBNodeDefMgr@@@?$_Default_allocator_traits@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@1@QEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::destroy<AINBNodeDefMgr::NodeDef::ImmediateParam>
PUBLIC	??$_Unfancy@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@@Z ; std::_Unfancy<AINBNodeDefMgr::NodeDef::ImmediateParam>
PUBLIC	??$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@DU?$char_traits@D@std@@@1@U_Normal_conversion@01@@Z ; std::filesystem::_Convert_stringoid_to_wide<std::filesystem::_Normal_conversion>
PUBLIC	??$forward@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@AEAPEAW4123@@Z ; std::forward<enum AINBNodeDefMgr::NodeDef::CategoryEnum *>
PUBLIC	??$_Set_ptr_rep_and_enable_shared@U_Recursive_dir_enum_impl@filesystem@std@@@?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@AEAAXQEAU_Recursive_dir_enum_impl@filesystem@1@QEAV_Ref_count_base@1@@Z ; std::shared_ptr<std::filesystem::_Recursive_dir_enum_impl>::_Set_ptr_rep_and_enable_shared<std::filesystem::_Recursive_dir_enum_impl>
PUBLIC	??$addressof@U_Recursive_dir_enum_impl@filesystem@std@@@std@@YAPEAU_Recursive_dir_enum_impl@filesystem@0@AEAU120@@Z ; std::addressof<std::filesystem::_Recursive_dir_enum_impl>
PUBLIC	??$?0U_Creator@_Dir_enum_impl@filesystem@std@@AEBW4directory_options@23@@?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAA@$$QEAU_Creator@_Dir_enum_impl@filesystem@1@AEBW4directory_options@41@@Z ; std::_Ref_count_obj2<std::filesystem::_Recursive_dir_enum_impl>::_Ref_count_obj2<std::filesystem::_Recursive_dir_enum_impl><std::filesystem::_Dir_enum_impl::_Creator,enum std::filesystem::directory_options const &>
PUBLIC	??$forward@AEBW4directory_options@filesystem@std@@@std@@YAAEBW4directory_options@filesystem@0@AEBW4120@@Z ; std::forward<enum std::filesystem::directory_options const &>
PUBLIC	??$forward@U_Creator@_Dir_enum_impl@filesystem@std@@@std@@YA$$QEAU_Creator@_Dir_enum_impl@filesystem@0@AEAU1230@@Z ; std::forward<std::filesystem::_Dir_enum_impl::_Creator>
PUBLIC	??$forward@AEBV?$allocator@_W@std@@@std@@YAAEBV?$allocator@_W@0@AEBV10@@Z ; std::forward<std::allocator<wchar_t> const &>
PUBLIC	??$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@U_Normal_conversion@01@@Z ; std::filesystem::_Convert_stringoid_to_wide<std::filesystem::_Normal_conversion>
PUBLIC	??$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@0@AEBV?$allocator@D@0@@Z ; std::_Convert_wide_to_narrow<std::char_traits<char>,std::allocator<char> >
PUBLIC	??$forward@AEAV?$reverse_iterator@PEB_W@std@@@std@@YAAEAV?$reverse_iterator@PEB_W@0@AEAV10@@Z ; std::forward<std::reverse_iterator<wchar_t const *> &>
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Find_file_handle@filesystem@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U_Find_file_handle@filesystem@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::filesystem::_Find_file_handle>,std::_Vector_val<std::_Simple_types<std::filesystem::_Find_file_handle> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UNodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UNodeDef@AINBNodeDefMgr@@@2@XZ ; std::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef> >,1>::_Get_first
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@@std@@SA_KAEBV?$allocator@U_Find_file_handle@filesystem@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::filesystem::_Find_file_handle> >::max_size
PUBLIC	?capacity@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEBA_KXZ ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::capacity
PUBLIC	?_Getal@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEBAAEBV?$allocator@U_Find_file_handle@filesystem@std@@@2@XZ ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::_Getal
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@SA_KAEBV?$allocator@UNodeDef@AINBNodeDefMgr@@@2@@Z ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef> >::max_size
PUBLIC	?capacity@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::capacity
PUBLIC	?_Getal@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEBAAEBV?$allocator@UNodeDef@AINBNodeDefMgr@@@2@XZ ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::_Getal
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SA_KAEBV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@2@@Z ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::max_size
PUBLIC	?capacity@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::capacity
PUBLIC	?_Buy_raw@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Buy_raw
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SA_KAEBV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@2@@Z ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::max_size
PUBLIC	?capacity@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::capacity
PUBLIC	?_Buy_raw@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Buy_raw
PUBLIC	??_G?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@UEAAPEAXI@Z ; std::_Ref_count_obj2<std::filesystem::_Recursive_dir_enum_impl>::`scalar deleting destructor'
PUBLIC	?_Change_array@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXQEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K1@Z ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Change_array
PUBLIC	?_Change_array@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXQEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K1@Z ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Change_array
PUBLIC	?_Change_array@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_K1@Z ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Change_array
PUBLIC	?_Orphan_range@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEBAXPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@0@Z ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Orphan_range
PUBLIC	?allocate@?$allocator@U_Find_file_handle@filesystem@std@@@std@@QEAAPEAU_Find_file_handle@filesystem@2@_K@Z ; std::allocator<std::filesystem::_Find_file_handle>::allocate
PUBLIC	?max_size@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEBA_KXZ ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::max_size
PUBLIC	?_Calculate_growth@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEBA_K_K@Z ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAXQEAU_Find_file_handle@filesystem@2@_K1@Z ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::_Change_array
PUBLIC	?_Xlength@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@CAXXZ ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::_Xlength
PUBLIC	?allocate@?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@QEAAPEAUNodeDef@AINBNodeDefMgr@@_K@Z ; std::allocator<AINBNodeDefMgr::NodeDef>::allocate
PUBLIC	?max_size@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::max_size
PUBLIC	?_Calculate_growth@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEBA_K_K@Z ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUNodeDef@AINBNodeDefMgr@@_K1@Z ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::_Change_array
PUBLIC	?_Xlength@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::_Xlength
PUBLIC	?deallocate@?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAXQEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z ; std::allocator<AINBNodeDefMgr::NodeDef::InputParam>::deallocate
PUBLIC	?allocate@?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAPEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z ; std::allocator<AINBNodeDefMgr::NodeDef::InputParam>::allocate
PUBLIC	?_Clear_and_reserve_geometric@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Clear_and_reserve_geometric
PUBLIC	?max_size@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::max_size
PUBLIC	?_Calculate_growth@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEBA_K_K@Z ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUInputParam@NodeDef@AINBNodeDefMgr@@_K1@Z ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Change_array
PUBLIC	?_Xlength@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Xlength
PUBLIC	?deallocate@?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAXQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z ; std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>::deallocate
PUBLIC	?allocate@?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z ; std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>::allocate
PUBLIC	?_Clear_and_reserve_geometric@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Clear_and_reserve_geometric
PUBLIC	?max_size@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::max_size
PUBLIC	?_Calculate_growth@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEBA_K_K@Z ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K1@Z ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Change_array
PUBLIC	?_Xlength@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Xlength
PUBLIC	?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAAXPEBW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > >::_Seek_to
PUBLIC	??1?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@UEAA@XZ ; std::_Ref_count_obj2<std::filesystem::_Recursive_dir_enum_impl>::~_Ref_count_obj2<std::filesystem::_Recursive_dir_enum_impl>
PUBLIC	?_Destroy@?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@EEAAXXZ ; std::_Ref_count_obj2<std::filesystem::_Recursive_dir_enum_impl>::_Destroy
PUBLIC	?_Delete_this@?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@EEAAXXZ ; std::_Ref_count_obj2<std::filesystem::_Recursive_dir_enum_impl>::_Delete_this
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::~_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@XZ ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Release
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@PEAUInputParam@NodeDef@AINBNodeDefMgr@@AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::~_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAUInputParam@NodeDef@AINBNodeDefMgr@@XZ ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Release
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@PEAUNodeDef@AINBNodeDefMgr@@AEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef> >::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef> >::~_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAUNodeDef@AINBNodeDefMgr@@XZ ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef> >::_Release
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@AEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Uninitialized_backout_al<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::~_Uninitialized_backout_al<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@XZ ; std::_Uninitialized_backout_al<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Release
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAA@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::~_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@XZ ; std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Release
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAA@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::~_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@XZ ; std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Release
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAX_K@Z ; std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::__autoclassinit2
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAX_K@Z ; std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::__autoclassinit2
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z ; std::_Uninitialized_backout_al<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::__autoclassinit2
PUBLIC	??_G_Find_file_handle@filesystem@std@@QEAAPEAXI@Z ; std::filesystem::_Find_file_handle::`scalar deleting destructor'
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef> >::__autoclassinit2
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::__autoclassinit2
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::__autoclassinit2
PUBLIC	?__autoclassinit2@?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAAX_K@Z ; std::shared_ptr<std::filesystem::_Recursive_dir_enum_impl>::__autoclassinit2
PUBLIC	??$construct_at@_W$$V$0A@@std@@YAPEA_WQEA_W@Z	; std::construct_at<wchar_t,0>
PUBLIC	??$_Assign_counted_range@PEAUInputParam@NodeDef@AINBNodeDefMgr@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Assign_counted_range<AINBNodeDefMgr::NodeDef::InputParam *>
PUBLIC	??$_Pocca@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAXAEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@AEBV10@@Z ; std::_Pocca<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >
PUBLIC	??$addressof@$$CBV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YAPEBV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEBV10@@Z ; std::addressof<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > const >
PUBLIC	??$_Assign_counted_range@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Assign_counted_range<AINBNodeDefMgr::NodeDef::ImmediateParam *>
PUBLIC	??$_Pocca@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAXAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@AEBV10@@Z ; std::_Pocca<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >
PUBLIC	??$addressof@$$CBV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YAPEBV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEBV10@@Z ; std::addressof<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > const >
PUBLIC	??$_Unfancy@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@@Z ; std::_Unfancy<enum AINBNodeDefMgr::NodeDef::CategoryEnum>
PUBLIC	??$construct_at@PEA_WAEBQEA_W$0A@@std@@YAPEAPEA_WQEAPEA_WAEBQEA_W@Z ; std::construct_at<wchar_t *,wchar_t * const &,0>
PUBLIC	??$forward@AEBQEA_W@std@@YAAEBQEA_WAEBQEA_W@Z	; std::forward<wchar_t * const &>
PUBLIC	??$move@AEAPEAV_Ref_count_base@std@@@std@@YA$$QEAPEAV_Ref_count_base@0@AEAPEAV10@@Z ; std::move<std::_Ref_count_base * &>
PUBLIC	??$move@AEAPEAU_Recursive_dir_enum_impl@filesystem@std@@@std@@YA$$QEAPEAU_Recursive_dir_enum_impl@filesystem@0@AEAPEAU120@@Z ; std::move<std::filesystem::_Recursive_dir_enum_impl * &>
PUBLIC	??$construct_at@PEA_WAEAPEA_W$0A@@std@@YAPEAPEA_WQEAPEA_WAEAPEA_W@Z ; std::construct_at<wchar_t *,wchar_t * &,0>
PUBLIC	??$forward@AEAPEA_W@std@@YAAEAPEA_WAEAPEA_W@Z	; std::forward<wchar_t * &>
PUBLIC	??$addressof@PEA_W@std@@YAPEAPEA_WAEAPEA_W@Z	; std::addressof<wchar_t *>
PUBLIC	??$destroy@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::destroy<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >
PUBLIC	??$_Unfancy@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@@Z ; std::_Unfancy<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >
PUBLIC	??$destroy@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::destroy<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >
PUBLIC	??$_Unfancy@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@@Z ; std::_Unfancy<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >
PUBLIC	??$destroy@UNodeDef@AINBNodeDefMgr@@@?$_Default_allocator_traits@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@1@QEAUNodeDef@AINBNodeDefMgr@@@Z ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef> >::destroy<AINBNodeDefMgr::NodeDef>
PUBLIC	??$_Unfancy@UNodeDef@AINBNodeDefMgr@@@std@@YAPEAUNodeDef@AINBNodeDefMgr@@PEAU12@@Z ; std::_Unfancy<AINBNodeDefMgr::NodeDef>
PUBLIC	??$forward@V?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z ; std::forward<std::allocator<wchar_t> >
PUBLIC	??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@$$QEAV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Emplace_back_with_unused_capacity@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back_with_unused_capacity<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$forward@AEBV?$allocator@I@std@@@std@@YAAEBV?$allocator@I@0@AEBV10@@Z ; std::forward<std::allocator<unsigned int> const &>
PUBLIC	??$forward@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@AEAV10@@Z ; std::forward<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >
PUBLIC	??$_Copy_n_unchecked4@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@_KPEAV12@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0@Z ; std::_Copy_n_unchecked4<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *,unsigned __int64,std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *>
PUBLIC	??$_Uninitialized_copy_n@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z ; std::_Uninitialized_copy_n<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >
PUBLIC	??$_Get_unwrapped@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA?A_T$$QEAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@@Z ; std::_Get_unwrapped<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *>
PUBLIC	??$move@AEAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA$$QEAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAPEAV10@@Z ; std::move<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > * &>
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_KAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$forward@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@AEAV10@@Z ; std::forward<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >
PUBLIC	??$_Copy_n_unchecked4@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@_KPEAV12@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0@Z ; std::_Copy_n_unchecked4<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > *,unsigned __int64,std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > *>
PUBLIC	??$_Uninitialized_copy_n@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z ; std::_Uninitialized_copy_n<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > *,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >
PUBLIC	??$_Get_unwrapped@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA?A_T$$QEAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@@Z ; std::_Get_unwrapped<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > *>
PUBLIC	??$move@AEAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA$$QEAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAPEAV10@@Z ; std::move<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > * &>
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_KAEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_To_address@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YA?A_PAEBQEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@Z ; std::_To_address<enum AINBNodeDefMgr::NodeDef::CategoryEnum *>
PUBLIC	??$forward@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@YA$$QEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@0@AEAV10@@Z ; std::forward<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >
PUBLIC	??$_Emplace_reallocate@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@QEAW4234@$$QEAW4234@@Z ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Emplace_reallocate<enum AINBNodeDefMgr::NodeDef::CategoryEnum>
PUBLIC	??$_Emplace_back_with_unused_capacity@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAAEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@$$QEAW4234@@Z ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Emplace_back_with_unused_capacity<enum AINBNodeDefMgr::NodeDef::CategoryEnum>
PUBLIC	??$forward@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@AEAW4123@@Z ; std::forward<enum AINBNodeDefMgr::NodeDef::CategoryEnum>
PUBLIC	??$_Copy_n_unchecked4@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_KPEAW4123@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@_K0@Z ; std::_Copy_n_unchecked4<enum AINBNodeDefMgr::NodeDef::CategoryEnum *,unsigned __int64,enum AINBNodeDefMgr::NodeDef::CategoryEnum *>
PUBLIC	??$_Copy_memmove_n@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@_K0@Z ; std::_Copy_memmove_n<enum AINBNodeDefMgr::NodeDef::CategoryEnum *,enum AINBNodeDefMgr::NodeDef::CategoryEnum *>
PUBLIC	??$_Uninitialized_copy_n@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@_K0AEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@0@@Z ; std::_Uninitialized_copy_n<enum AINBNodeDefMgr::NodeDef::CategoryEnum *,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >
PUBLIC	??$_Get_unwrapped@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YA?A_T$$QEAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@Z ; std::_Get_unwrapped<enum AINBNodeDefMgr::NodeDef::CategoryEnum *>
PUBLIC	??$move@AEAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@AEAPEAW4123@@Z ; std::move<enum AINBNodeDefMgr::NodeDef::CategoryEnum * &>
PUBLIC	??$_Emplace_reallocate@U_Find_file_handle@filesystem@std@@@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAPEAU_Find_file_handle@filesystem@1@QEAU231@$$QEAU231@@Z ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::_Emplace_reallocate<std::filesystem::_Find_file_handle>
PUBLIC	??$_Emplace_back_with_unused_capacity@U_Find_file_handle@filesystem@std@@@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAAEAU_Find_file_handle@filesystem@1@$$QEAU231@@Z ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::_Emplace_back_with_unused_capacity<std::filesystem::_Find_file_handle>
PUBLIC	??$forward@U_Find_file_handle@filesystem@std@@@std@@YA$$QEAU_Find_file_handle@filesystem@0@AEAU120@@Z ; std::forward<std::filesystem::_Find_file_handle>
PUBLIC	??$destroy_at@U_Find_file_handle@filesystem@std@@@std@@YAXQEAU_Find_file_handle@filesystem@0@@Z ; std::destroy_at<std::filesystem::_Find_file_handle>
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUNodeDef@AINBNodeDefMgr@@PEAU12@_KAEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<AINBNodeDefMgr::NodeDef> >
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@_KAEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Destroy_range@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAXPEAUInputParam@NodeDef@AINBNodeDefMgr@@QEAU123@AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z ; std::_Destroy_range<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@YAPEAUOutputEntry@AINBFile@@PEAU12@_KAEAV?$allocator@UOutputEntry@AINBFile@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<AINBFile::OutputEntry> >
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<AINBFile::OutputEntry,std::allocator<AINBFile::OutputEntry> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$forward@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@@Z ; std::forward<AINBNodeDefMgr::NodeDef::ImmediateParam>
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@_KAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Destroy_range@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAXPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z ; std::_Destroy_range<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >
PUBLIC	??$_Stringoid_from_Source@DU?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?A_PAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::filesystem::_Stringoid_from_Source<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$_Convert_Source_to_wide@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@U_Normal_conversion@01@@Z ; std::filesystem::_Convert_Source_to_wide<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::filesystem::_Normal_conversion>
PUBLIC	??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YAXAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@$$QEAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@Z ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > >,enum AINBNodeDefMgr::NodeDef::CategoryEnum *>
PUBLIC	??$_Find_unchecked@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@W4123@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@QEAW4123@AEBW4123@@Z ; std::_Find_unchecked<enum AINBNodeDefMgr::NodeDef::CategoryEnum *,enum AINBNodeDefMgr::NodeDef::CategoryEnum>
PUBLIC	??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > > >
PUBLIC	??$make_shared@U_Recursive_dir_enum_impl@filesystem@std@@U_Creator@_Dir_enum_impl@23@AEBW4directory_options@23@@std@@YA?AV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@0@$$QEAU_Creator@_Dir_enum_impl@filesystem@0@AEBW4directory_options@40@@Z ; std::make_shared<std::filesystem::_Recursive_dir_enum_impl,std::filesystem::_Dir_enum_impl::_Creator,enum std::filesystem::directory_options const &>
PUBLIC	??$append@V?$basic_string_view@DU?$char_traits@D@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV?$basic_string_view@DU?$char_traits@D@std@@@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append<std::basic_string_view<char,std::char_traits<char> >,0>
PUBLIC	??$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> const &>
PUBLIC	??$_Stringoid_from_Source@_WU?$char_traits@_W@std@@@filesystem@std@@YA?A_PAEBV?$basic_string_view@_WU?$char_traits@_W@std@@@1@@Z ; std::filesystem::_Stringoid_from_Source<wchar_t,std::char_traits<wchar_t> >
PUBLIC	??$_Convert_Source_to_wide@V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@1@U_Normal_conversion@01@@Z ; std::filesystem::_Convert_Source_to_wide<std::basic_string_view<wchar_t,std::char_traits<wchar_t> >,std::filesystem::_Normal_conversion>
PUBLIC	??$_Convert_wide_to@U?$char_traits@D@std@@V?$allocator@D@2@D@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z ; std::filesystem::_Convert_wide_to<std::char_traits<char>,std::allocator<char>,char>
PUBLIC	??$_Seek_wrapped@V?$reverse_iterator@PEB_W@std@@AEAV12@@std@@YAXAEAV?$reverse_iterator@PEB_W@0@0@Z ; std::_Seek_wrapped<std::reverse_iterator<wchar_t const *>,std::reverse_iterator<wchar_t const *> &>
PUBLIC	??$_Adl_verify_range@V?$reverse_iterator@PEB_W@std@@V12@@std@@YAXAEBV?$reverse_iterator@PEB_W@0@0@Z ; std::_Adl_verify_range<std::reverse_iterator<wchar_t const *>,std::reverse_iterator<wchar_t const *> >
PUBLIC	??$_Seek_wrapped@PEB_WAEAPEB_W@std@@YAXAEAPEB_W0@Z ; std::_Seek_wrapped<wchar_t const *,wchar_t const * &>
PUBLIC	??$forward@AEB_W@std@@YAAEB_WAEB_W@Z		; std::forward<wchar_t const &>
PUBLIC	?allocate@?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K@Z ; std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::max_size
PUBLIC	?capacity@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::capacity
PUBLIC	?allocate@?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K@Z ; std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::max_size
PUBLIC	?capacity@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::capacity
PUBLIC	?allocate@?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@QEAAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_K@Z ; std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@SA_KAEBV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@2@@Z ; std::_Default_allocator_traits<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::max_size
PUBLIC	?capacity@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::capacity
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@2@XZ ; std::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::InputParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::InputParam> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@2@XZ ; std::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::ImmediateParam> >,1>::_Get_first
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty
PUBLIC	?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CA_K_K00@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
PUBLIC	?max_size@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::max_size
PUBLIC	?_Calculate_growth@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEBA_K_K@Z ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Calculate_growth
PUBLIC	?_Buy_raw@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Buy_raw
PUBLIC	?_Xlength@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@CAXXZ ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Xlength
PUBLIC	?max_size@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::max_size
PUBLIC	?_Calculate_growth@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEBA_K_K@Z ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Calculate_growth
PUBLIC	?_Buy_raw@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Buy_raw
PUBLIC	?_Xlength@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@CAXXZ ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Xlength
PUBLIC	?max_size@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::max_size
PUBLIC	?_Calculate_growth@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEBA_K_K@Z ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Calculate_growth
PUBLIC	?_Buy_raw@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Buy_raw
PUBLIC	?_Xlength@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Xlength
PUBLIC	?_Getal@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEBAAEBV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@2@XZ ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@2@XZ ; std::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::InputParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::InputParam> >,1>::_Get_first
PUBLIC	?_Getal@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEBAAEBV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@2@XZ ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@2@XZ ; std::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::ImmediateParam> >,1>::_Get_first
PUBLIC	?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z	; std::allocator<wchar_t>::allocate
PUBLIC	??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
PUBLIC	?_Start_element_lifetimes@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAXQEA_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Start_element_lifetimes
PUBLIC	?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBA_K_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
PUBLIC	??0?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@XZ ; std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >
PUBLIC	?_Clear_and_reserve_geometric@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Clear_and_reserve_geometric
PUBLIC	?_Orphan_range@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEBAXPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@0@Z ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Orphan_range
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >
PUBLIC	??0?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@XZ ; std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >
PUBLIC	?_Clear_and_reserve_geometric@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Clear_and_reserve_geometric
PUBLIC	?_Orphan_range@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEBAXPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@0@Z ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Orphan_range
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >
PUBLIC	??0?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@QEAA@XZ ; std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum>::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum>
PUBLIC	?_Clear_and_reserve_geometric@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Clear_and_reserve_geometric
PUBLIC	??0?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >
PUBLIC	??E?$reverse_iterator@PEB_W@std@@QEAAAEAV01@XZ	; std::reverse_iterator<wchar_t const *>::operator++
PUBLIC	??0?$allocator@U_Find_file_handle@filesystem@std@@@std@@QEAA@XZ ; std::allocator<std::filesystem::_Find_file_handle>::allocator<std::filesystem::_Find_file_handle>
PUBLIC	??0?$_Vector_val@U?$_Simple_types@U_Find_file_handle@filesystem@std@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<std::filesystem::_Find_file_handle> >::_Vector_val<std::_Simple_types<std::filesystem::_Find_file_handle> >
PUBLIC	?_Incref@?$_Ptr_base@U_Recursive_dir_enum_impl@filesystem@std@@@std@@IEBAXXZ ; std::_Ptr_base<std::filesystem::_Recursive_dir_enum_impl>::_Incref
PUBLIC	??4?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::shared_ptr<std::filesystem::_Recursive_dir_enum_impl>::operator=
PUBLIC	?_Orphan_range@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEBAXPEAUNodeDef@AINBNodeDefMgr@@0@Z ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::_Orphan_range
PUBLIC	??4?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAAEAV01@AEBV01@@Z ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::operator=
PUBLIC	?_Orphan_range@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEBAXPEAUInputParam@NodeDef@AINBNodeDefMgr@@0@Z ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Orphan_range
PUBLIC	?_Getal@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAAEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@2@XZ ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Getal
PUBLIC	??4?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAAEAV01@AEBV01@@Z ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::operator=
PUBLIC	?_Orphan_range@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEBAXPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@0@Z ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Orphan_range
PUBLIC	?_Getal@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@2@XZ ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Getal
PUBLIC	?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEBAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > >::_Unwrapped
PUBLIC	??1_Creator@_Dir_enum_impl@filesystem@std@@QEAA@XZ ; std::filesystem::_Dir_enum_impl::_Creator::~_Creator
PUBLIC	??$construct_at@_WAEB_W$0A@@std@@YAPEA_WQEA_WAEB_W@Z ; std::construct_at<wchar_t,wchar_t const &,0>
PUBLIC	??$addressof@_W@std@@YAPEA_WAEA_W@Z		; std::addressof<wchar_t>
PUBLIC	??$_Construct_in_place@PEA_WAEBQEA_W@std@@YAXAEAPEA_WAEBQEA_W@Z ; std::_Construct_in_place<wchar_t *,wchar_t * const &>
PUBLIC	??$swap@PEAV_Ref_count_base@std@@$0A@@std@@YAXAEAPEAV_Ref_count_base@0@0@Z ; std::swap<std::_Ref_count_base *,0>
PUBLIC	??$swap@PEAU_Recursive_dir_enum_impl@filesystem@std@@$0A@@std@@YAXAEAPEAU_Recursive_dir_enum_impl@filesystem@0@0@Z ; std::swap<std::filesystem::_Recursive_dir_enum_impl *,0>
PUBLIC	??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KD@Z@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@0D@Z@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,unsigned __int64,char>
PUBLIC	??$_Construct_in_place@PEA_WAEAPEA_W@std@@YAXAEAPEA_W0@Z ; std::_Construct_in_place<wchar_t *,wchar_t * &>
PUBLIC	??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@_K_W@Z@_K_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@0_W@Z@_K_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<`std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append'::`2'::<lambda_1>,unsigned __int64,wchar_t>
PUBLIC	??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEB_W0@Z@PEB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_for<`std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign'::`2'::<lambda_1>,wchar_t const *>
PUBLIC	??$_Destroy_in_place@PEA_W@std@@YAXAEAPEA_W@Z	; std::_Destroy_in_place<wchar_t *>
PUBLIC	??$_Destroy_range@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YAXPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >
PUBLIC	??$_Destroy_range@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YAXPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >
PUBLIC	??$_Destroy_range@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAXPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@QEAW4123@AEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@0@@Z ; std::_Destroy_range<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >
PUBLIC	??$_Destroy_range@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@@std@@YAXPEAU_Find_file_handle@filesystem@0@QEAU120@AEAV?$allocator@U_Find_file_handle@filesystem@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::filesystem::_Find_file_handle> >
PUBLIC	??$_Destroy_range@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@YAXPEAUNodeDef@AINBNodeDefMgr@@QEAU12@AEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@0@@Z ; std::_Destroy_range<std::allocator<AINBNodeDefMgr::NodeDef> >
PUBLIC	??$_Reallocate_grow_by@V<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??reserve@01@QEAAX0@Z@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve'::`2'::<lambda_1> >
PUBLIC	??$_Construct@$01PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<2,wchar_t const *>
PUBLIC	??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<1,wchar_t const *>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><>
PUBLIC	??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@_W@1@@Z ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> >
PUBLIC	??$move@AEAV?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z ; std::move<std::allocator<wchar_t> &>
PUBLIC	??$_Pocma@V?$allocator@_W@std@@@std@@YAXAEAV?$allocator@_W@0@0@Z ; std::_Pocma<std::allocator<wchar_t> >
PUBLIC	??$_Pocca@V?$allocator@_W@std@@@std@@YAXAEAV?$allocator@_W@0@AEBV10@@Z ; std::_Pocca<std::allocator<wchar_t> >
PUBLIC	??$addressof@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@@Z ; std::addressof<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const >
PUBLIC	??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEB_W0@Z@PEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<`std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append'::`2'::<lambda_1>,wchar_t const *,unsigned __int64>
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@_W@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > >
PUBLIC	??$addressof@$$CBV?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@_W@std@@@0@AEBV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > const >
PUBLIC	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z@_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAX_W@Z@_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<`std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::push_back'::`2'::<lambda_1>,wchar_t>
PUBLIC	??$addressof@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEAV10@@Z ; std::addressof<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
PUBLIC	??$_Emplace_one_at_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_one_at_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Construct_n@$$V@?$vector@IV?$allocator@I@std@@@std@@AEAAX_K@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Construct_n<>
PUBLIC	??$?0AEBV?$allocator@I@std@@$$V@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@I@1@@Z ; std::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1><std::allocator<unsigned int> const &>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >,std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >,1>::_Compressed_pair<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >,std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >,1><>
PUBLIC	??$_Assign_counted_range@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@_K@Z ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Assign_counted_range<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *>
PUBLIC	??$_Pocca@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YAXAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@AEBV10@@Z ; std::_Pocca<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >
PUBLIC	??$addressof@$$CBV?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@@std@@YAPEBV?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@0@AEBV10@@Z ; std::addressof<std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > > const >
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Resize<std::_Value_init_tag>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >,std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >,1>::_Compressed_pair<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >,std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >,1><>
PUBLIC	??$_Assign_counted_range@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@_K@Z ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Assign_counted_range<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > *>
PUBLIC	??$_Pocca@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YAXAEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@AEBV10@@Z ; std::_Pocca<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >
PUBLIC	??$addressof@$$CBV?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@@std@@YAPEBV?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@0@AEBV10@@Z ; std::addressof<std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > > const >
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Resize<std::_Value_init_tag>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum>,std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >,1>::_Compressed_pair<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum>,std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >,1><>
PUBLIC	??$_Emplace_one_at_back@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAAEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@$$QEAW4234@@Z ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Emplace_one_at_back<enum AINBNodeDefMgr::NodeDef::CategoryEnum>
PUBLIC	??$move@AEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@AEAW4123@@Z ; std::move<enum AINBNodeDefMgr::NodeDef::CategoryEnum &>
PUBLIC	??$_Assign_counted_range@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_K@Z ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Assign_counted_range<enum AINBNodeDefMgr::NodeDef::CategoryEnum *>
PUBLIC	??$_Pocca@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAXAEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@0@AEBV10@@Z ; std::_Pocca<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >
PUBLIC	??$addressof@$$CBV?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YAPEBV?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@0@AEBV10@@Z ; std::addressof<std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > const >
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > >
PUBLIC	??$move@AEAPEB_W@std@@YA$$QEAPEB_WAEAPEB_W@Z	; std::move<wchar_t const * &>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Find_file_handle@filesystem@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::filesystem::_Find_file_handle>,std::_Vector_val<std::_Simple_types<std::filesystem::_Find_file_handle> >,1>::_Compressed_pair<std::allocator<std::filesystem::_Find_file_handle>,std::_Vector_val<std::_Simple_types<std::filesystem::_Find_file_handle> >,1><>
PUBLIC	??$_Emplace_one_at_back@U_Find_file_handle@filesystem@std@@@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAAEAU_Find_file_handle@filesystem@1@$$QEAU231@@Z ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::_Emplace_one_at_back<std::filesystem::_Find_file_handle>
PUBLIC	??$destroy@U_Find_file_handle@filesystem@std@@@?$_Default_allocator_traits@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@@std@@SAXAEAV?$allocator@U_Find_file_handle@filesystem@std@@@1@QEAU_Find_file_handle@filesystem@1@@Z ; std::_Default_allocator_traits<std::allocator<std::filesystem::_Find_file_handle> >::destroy<std::filesystem::_Find_file_handle>
PUBLIC	??$_Unfancy@U_Find_file_handle@filesystem@std@@@std@@YAPEAU_Find_file_handle@filesystem@0@PEAU120@@Z ; std::_Unfancy<std::filesystem::_Find_file_handle>
PUBLIC	??$_Copy_construct_from@U_Recursive_dir_enum_impl@filesystem@std@@@?$_Ptr_base@U_Recursive_dir_enum_impl@filesystem@std@@@std@@IEAAXAEBV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@1@@Z ; std::_Ptr_base<std::filesystem::_Recursive_dir_enum_impl>::_Copy_construct_from<std::filesystem::_Recursive_dir_enum_impl>
PUBLIC	??$_Move_construct_from@U_Recursive_dir_enum_impl@filesystem@std@@@?$_Ptr_base@U_Recursive_dir_enum_impl@filesystem@std@@@std@@IEAAX$$QEAV01@@Z ; std::_Ptr_base<std::filesystem::_Recursive_dir_enum_impl>::_Move_construct_from<std::filesystem::_Recursive_dir_enum_impl>
PUBLIC	??$move@AEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@@std@@YA$$QEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@0@AEAV10@@Z ; std::move<std::shared_ptr<std::filesystem::_Recursive_dir_enum_impl> &>
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::_Resize<std::_Value_init_tag>
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Resize<std::_Value_init_tag>
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<AINBFile::OutputEntry,std::allocator<AINBFile::OutputEntry> >::_Resize<std::_Value_init_tag>
PUBLIC	??$move@AEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@@Z ; std::move<AINBNodeDefMgr::NodeDef::ImmediateParam &>
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Resize<std::_Value_init_tag>
PUBLIC	??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@W4format@012@@Z ; std::filesystem::path::path<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,0>
PUBLIC	??$_Get_unwrapped@AEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YA?A_TAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > > const &>
PUBLIC	??$_Get_unwrapped@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > > &>
PUBLIC	??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@V10@V10@AEBW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > >,enum AINBNodeDefMgr::NodeDef::CategoryEnum>
PUBLIC	??$?8U_Recursive_dir_enum_impl@filesystem@std@@U012@@std@@YA_NAEBV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@0@0@Z ; std::operator==<std::filesystem::_Recursive_dir_enum_impl,std::filesystem::_Recursive_dir_enum_impl>
PUBLIC	??$?CU_Recursive_dir_enum_impl@filesystem@std@@$0A@@?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEBAPEAU_Recursive_dir_enum_impl@filesystem@1@XZ ; std::shared_ptr<std::filesystem::_Recursive_dir_enum_impl>::operator-><std::filesystem::_Recursive_dir_enum_impl,0>
PUBLIC	??$_Initialize_dir_enum@U_Recursive_dir_enum_impl@filesystem@std@@@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@2@AEBVpath@12@W4directory_options@12@@Z ; std::filesystem::_Dir_enum_impl::_Initialize_dir_enum<std::filesystem::_Recursive_dir_enum_impl>
PUBLIC	??$move@AEAU_Creator@_Dir_enum_impl@filesystem@std@@@std@@YA$$QEAU_Creator@_Dir_enum_impl@filesystem@0@AEAU1230@@Z ; std::move<std::filesystem::_Dir_enum_impl::_Creator &>
PUBLIC	??$?DU_Recursive_dir_enum_impl@filesystem@std@@$0A@@?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEBAAEAU_Recursive_dir_enum_impl@filesystem@1@XZ ; std::shared_ptr<std::filesystem::_Recursive_dir_enum_impl>::operator*<std::filesystem::_Recursive_dir_enum_impl,0>
PUBLIC	??$move@AEAVpath@filesystem@std@@@std@@YA$$QEAVpath@filesystem@0@AEAV120@@Z ; std::move<std::filesystem::path &>
PUBLIC	??$move@AEAU_Find_file_handle@filesystem@std@@@std@@YA$$QEAU_Find_file_handle@filesystem@0@AEAU120@@Z ; std::move<std::filesystem::_Find_file_handle &>
PUBLIC	??$_Bitmask_includes_any@W4directory_options@filesystem@std@@@std@@YA_NW4directory_options@filesystem@0@0@Z ; std::_Bitmask_includes_any<enum std::filesystem::directory_options>
PUBLIC	??$_Bitmask_includes_all@W4__std_fs_stats_flags@@@std@@YA_NW4__std_fs_stats_flags@@0@Z ; std::_Bitmask_includes_all<enum __std_fs_stats_flags>
PUBLIC	??$_Bitmask_includes_any@W4__std_fs_file_attr@@@std@@YA_NW4__std_fs_file_attr@@0@Z ; std::_Bitmask_includes_any<enum __std_fs_file_attr>
PUBLIC	??$?YV?$basic_string_view@DU?$char_traits@D@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV?$basic_string_view@DU?$char_traits@D@std@@@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=<std::basic_string_view<char,std::char_traits<char> >,0>
PUBLIC	??$_Convert_wide_to_narrow_replace_chars@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z ; std::filesystem::_Convert_wide_to_narrow_replace_chars<std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?_0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@path@filesystem@std@@QEAAAEAV012@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@2@@Z ; std::filesystem::path::operator/=<std::basic_string_view<wchar_t,std::char_traits<wchar_t> >,0>
PUBLIC	??$forward@AEAPEB_W@std@@YAAEAPEB_WAEAPEB_W@Z	; std::forward<wchar_t const * &>
PUBLIC	??$?0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@2@W4format@012@@Z ; std::filesystem::path::path<std::basic_string_view<wchar_t,std::char_traits<wchar_t> >,0>
PUBLIC	??$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV?$allocator@D@2@@Z ; std::filesystem::path::string<char,std::char_traits<char>,std::allocator<char>,0>
PUBLIC	??$?GPEB_WPEB_W@std@@YA_JAEBV?$reverse_iterator@PEB_W@0@0@Z ; std::operator-<wchar_t const *,wchar_t const *>
PUBLIC	??$find_if_not@V?$reverse_iterator@PEB_W@std@@U_Is_slash_oper@2@@std@@YA?AV?$reverse_iterator@PEB_W@0@V10@V10@U_Is_slash_oper@0@@Z ; std::find_if_not<std::reverse_iterator<wchar_t const *>,std::_Is_slash_oper>
PUBLIC	??D?$reverse_iterator@PEB_W@std@@QEBAAEB_WXZ	; std::reverse_iterator<wchar_t const *>::operator*
PUBLIC	?_Get_current@?$reverse_iterator@PEB_W@std@@QEBAAEBQEB_WXZ ; std::reverse_iterator<wchar_t const *>::_Get_current
PUBLIC	??$?9PEB_WPEB_W@std@@YA_NAEBV?$reverse_iterator@PEB_W@0@0@Z ; std::operator!=<wchar_t const *,wchar_t const *>
PUBLIC	??$_Get_unwrapped@AEBV?$reverse_iterator@PEB_W@std@@@std@@YA?A_TAEBV?$reverse_iterator@PEB_W@0@@Z ; std::_Get_unwrapped<std::reverse_iterator<wchar_t const *> const &>
PUBLIC	??$_Get_unwrapped@AEAV?$reverse_iterator@PEB_W@std@@@std@@YA?A_TAEAV?$reverse_iterator@PEB_W@0@@Z ; std::_Get_unwrapped<std::reverse_iterator<wchar_t const *> &>
PUBLIC	??$find_if@V?$reverse_iterator@PEB_W@std@@U_Is_slash_oper@2@@std@@YA?AV?$reverse_iterator@PEB_W@0@V10@V10@U_Is_slash_oper@0@@Z ; std::find_if<std::reverse_iterator<wchar_t const *>,std::_Is_slash_oper>
PUBLIC	??$exchange@W4__std_fs_dir_handle@@AEAW41@@std@@YA?AW4__std_fs_dir_handle@@AEAW41@0@Z ; std::exchange<enum __std_fs_dir_handle,enum __std_fs_dir_handle &>
PUBLIC	??$exchange@W4__std_fs_dir_handle@@W41@@std@@YA?AW4__std_fs_dir_handle@@AEAW41@$$QEAW41@@Z ; std::exchange<enum __std_fs_dir_handle,enum __std_fs_dir_handle>
PUBLIC	??$_Traits_compare@U?$char_traits@_W@std@@@std@@YAHQEB_W_K01@Z ; std::_Traits_compare<std::char_traits<wchar_t> >
PUBLIC	??$find_if_not@PEB_WU_Is_slash_oper@std@@@std@@YAPEB_WPEB_WQEB_WU_Is_slash_oper@0@@Z ; std::find_if_not<wchar_t const *,std::_Is_slash_oper>
PUBLIC	??$_Get_unwrapped@AEBQEB_W@std@@YA?A_TAEBQEB_W@Z ; std::_Get_unwrapped<wchar_t const * const &>
PUBLIC	??$_Get_unwrapped@AEAPEB_W@std@@YA?A_TAEAPEB_W@Z ; std::_Get_unwrapped<wchar_t const * &>
PUBLIC	??$find_if@PEB_WU_Is_slash_oper@std@@@std@@YAPEB_WPEB_WQEB_WU_Is_slash_oper@0@@Z ; std::find_if<wchar_t const *,std::_Is_slash_oper>
PUBLIC	??$_Unaligned_load@I@filesystem@std@@YAIPEBX@Z	; std::filesystem::_Unaligned_load<unsigned int>
PUBLIC	??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z		; std::_Unfancy<wchar_t>
PUBLIC	??$_Bitmask_includes_any@W4__std_fs_stats_flags@@@std@@YA_NW4__std_fs_stats_flags@@0@Z ; std::_Bitmask_includes_any<enum __std_fs_stats_flags>
PUBLIC	??$_Adl_verify_range@PEB_WPEB_W@std@@YAXAEBQEB_W0@Z ; std::_Adl_verify_range<wchar_t const *,wchar_t const *>
PUBLIC	??$_Immortalize_memcpy_image@V_System_error_category@std@@@std@@YAAEBV_System_error_category@0@XZ ; std::_Immortalize_memcpy_image<std::_System_error_category>
PUBLIC	??$_Immortalize_memcpy_image@V_Generic_error_category@std@@@std@@YAAEBV_Generic_error_category@0@XZ ; std::_Immortalize_memcpy_image<std::_Generic_error_category>
PUBLIC	??$_Bit_cast@_KT_Addr_storage@error_category@std@@$0A@@std@@YA_KAEBT_Addr_storage@error_category@0@@Z ; std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>
PUBLIC	?assign@?$_Char_traits@_WG@std@@SAPEA_WQEA_W_K_W@Z ; std::_Char_traits<wchar_t,unsigned short>::assign
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UNodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@2@XZ ; std::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef> >,1>::_Get_first
PUBLIC	?assign@?$_Char_traits@_WG@std@@SAXAEA_WAEB_W@Z	; std::_Char_traits<wchar_t,unsigned short>::assign
PUBLIC	?assign@?$_WChar_traits@_W@std@@SAPEA_WQEA_W_K_W@Z ; std::_WChar_traits<wchar_t>::assign
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z	; std::allocator<wchar_t>::deallocate
PUBLIC	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Activate_SSO_buffer
PUBLIC	?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Xran
PUBLIC	?_Memcpy_val_from@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEBV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Memcpy_val_from
PUBLIC	?_Swap_proxy_and_iterators@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Swap_proxy_and_iterators
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$allocator@_W@2@XZ ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEBAAEBV?$allocator@_W@2@XZ ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
PUBLIC	?deallocate@?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAAXQEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K@Z ; std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >::deallocate
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >,std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >,std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >,1>::_Get_first
PUBLIC	?deallocate@?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAAXQEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K@Z ; std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >::deallocate
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >,std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >,std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >,1>::_Get_first
PUBLIC	?deallocate@?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@QEAAXQEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_K@Z ; std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum>::deallocate
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAAAEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@2@XZ ; std::_Compressed_pair<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum>,std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEBAAEBV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@2@XZ ; std::_Compressed_pair<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum>,std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >,1>::_Get_first
PUBLIC	?deallocate@?$allocator@U_Find_file_handle@filesystem@std@@@std@@QEAAXQEAU_Find_file_handle@filesystem@2@_K@Z ; std::allocator<std::filesystem::_Find_file_handle>::deallocate
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Find_file_handle@filesystem@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U_Find_file_handle@filesystem@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::filesystem::_Find_file_handle>,std::_Vector_val<std::_Simple_types<std::filesystem::_Find_file_handle> >,1>::_Get_first
PUBLIC	?_Swap@?$_Ptr_base@U_Recursive_dir_enum_impl@filesystem@std@@@std@@IEAAXAEAV12@@Z ; std::_Ptr_base<std::filesystem::_Recursive_dir_enum_impl>::_Swap
PUBLIC	?deallocate@?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@QEAAXQEAUNodeDef@AINBNodeDefMgr@@_K@Z ; std::allocator<AINBNodeDefMgr::NodeDef>::deallocate
PUBLIC	?_Getal@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAAEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@2@XZ ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::_Getal
PUBLIC	?copy@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z ; std::_Char_traits<wchar_t,unsigned short>::copy
PUBLIC	?move@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z ; std::_Char_traits<wchar_t,unsigned short>::move
PUBLIC	?compare@?$_WChar_traits@_W@std@@SAHQEB_W0_K@Z	; std::_WChar_traits<wchar_t>::compare
PUBLIC	?length@?$_WChar_traits@_W@std@@SA_KPEB_W@Z	; std::_WChar_traits<wchar_t>::length
PUBLIC	?assign@?$_WChar_traits@_W@std@@SAXAEA_WAEB_W@Z	; std::_WChar_traits<wchar_t>::assign
PUBLIC	??R<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@_KD@Z@QEBA@QEADQEBD00D@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>::operator()
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA_KAEBV?$allocator@_W@2@@Z ; std::_Default_allocator_traits<std::allocator<wchar_t> >::max_size
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@AEBV32@@Z ; std::_Default_allocator_traits<std::allocator<wchar_t> >::select_on_container_copy_construction
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAPEB_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
PUBLIC	?_Check_offset@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAX_K@Z ; std::_String_val<std::_Simple_types<wchar_t> >::_Check_offset
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty
PUBLIC	?_Take_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Take_contents
PUBLIC	??R<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV23@_K_W@Z@QEBA@QEA_WQEB_W001@Z ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append'::`2'::<lambda_1>::operator()
PUBLIC	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@_K_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
PUBLIC	??R<lambda_1>@?1??assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV23@QEB_W_K@Z@QEBA@QEA_W10@Z ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign'::`2'::<lambda_1>::operator()
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
PUBLIC	?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAX_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos
PUBLIC	?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
PUBLIC	?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
PUBLIC	?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBAAEBV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
PUBLIC	?_Tidy@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXXZ ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Tidy
PUBLIC	?_Getal@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@XZ ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Getal
PUBLIC	?_Getal@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@XZ ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Getal
PUBLIC	?_Tidy@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXXZ ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Tidy
PUBLIC	?_Getal@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@XZ ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Getal
PUBLIC	?_Getal@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@XZ ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Getal
PUBLIC	?_Tidy@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Tidy
PUBLIC	?_Getal@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAAEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@2@XZ ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Getal
PUBLIC	?_Getal@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEBAAEBV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@2@XZ ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Getal
PUBLIC	?_Tidy@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAXXZ ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::_Tidy
PUBLIC	?_Orphan_range@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEBAXPEAU_Find_file_handle@filesystem@2@0@Z ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::_Orphan_range
PUBLIC	?_Getal@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAAEAV?$allocator@U_Find_file_handle@filesystem@std@@@2@XZ ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::_Getal
PUBLIC	?get@?$_Ptr_base@U_Recursive_dir_enum_impl@filesystem@std@@@std@@IEBAPEAU_Recursive_dir_enum_impl@filesystem@2@XZ ; std::_Ptr_base<std::filesystem::_Recursive_dir_enum_impl>::get
PUBLIC	?_Decref@?$_Ptr_base@U_Recursive_dir_enum_impl@filesystem@std@@@std@@IEAAXXZ ; std::_Ptr_base<std::filesystem::_Recursive_dir_enum_impl>::_Decref
PUBLIC	?swap@?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAAXAEAV12@@Z ; std::shared_ptr<std::filesystem::_Recursive_dir_enum_impl>::swap
PUBLIC	?_Tidy@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::_Tidy
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > >
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEBAXAEBV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > >::_Compat
PUBLIC	?size@?$basic_string_view@DU?$char_traits@D@std@@@std@@QEBA_KXZ ; std::basic_string_view<char,std::char_traits<char> >::size
PUBLIC	?empty@?$basic_string_view@DU?$char_traits@D@std@@@std@@QEBA_NXZ ; std::basic_string_view<char,std::char_traits<char> >::empty
PUBLIC	??0?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QEAA@QEB_W@Z ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::basic_string_view<wchar_t,std::char_traits<wchar_t> >
PUBLIC	?size@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QEBA_KXZ ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::size
PUBLIC	?empty@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QEBA_NXZ ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::empty
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??R<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@QEBA@QEADQEBD0@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve'::`2'::<lambda_1>::operator()
PUBLIC	?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve
PUBLIC	??0?$allocator@_W@std@@QEAA@XZ			; std::allocator<wchar_t>::allocator<wchar_t>
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
PUBLIC	??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >
PUBLIC	??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>
PUBLIC	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
PUBLIC	??R<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV23@QEB_W_K@Z@QEBA@QEA_W0101@Z ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append'::`2'::<lambda_1>::operator()
PUBLIC	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
PUBLIC	?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
PUBLIC	??B?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV?$basic_string_view@_WU?$char_traits@_W@std@@@1@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator std::basic_string_view<wchar_t,std::char_traits<wchar_t> >
PUBLIC	??R<lambda_1>@?1??push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z@QEBA@QEA_WQEB_W_K0@Z ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::push_back'::`2'::<lambda_1>::operator()
PUBLIC	?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::push_back
PUBLIC	?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAPEB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
PUBLIC	?data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAPEB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::data
PUBLIC	?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size
PUBLIC	?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
PUBLIC	?resize@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::resize
PUBLIC	?_Orphan_all@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Orphan_all
PUBLIC	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAX$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
PUBLIC	?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
PUBLIC	??0?$vector@IV?$allocator@I@std@@@std@@QEAA@_KAEBV?$allocator@I@1@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
PUBLIC	??0?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >
PUBLIC	??1?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::~vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >
PUBLIC	??4?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::operator=
PUBLIC	?resize@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAX_K@Z ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::resize
PUBLIC	??A?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAAEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@_K@Z ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::operator[]
PUBLIC	??0?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >
PUBLIC	??1?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::~vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >
PUBLIC	??4?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::operator=
PUBLIC	?resize@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAX_K@Z ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::resize
PUBLIC	??A?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAAEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@_K@Z ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::operator[]
PUBLIC	??0?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >
PUBLIC	??1?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::~vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >
PUBLIC	?push_back@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX$$QEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@Z ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::push_back
PUBLIC	??4?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAAEAV01@AEBV01@@Z ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::operator=
PUBLIC	?begin@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@XZ ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::begin
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > >
PUBLIC	?end@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@XZ ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::end
PUBLIC	??0?$reverse_iterator@PEB_W@std@@QEAA@PEB_W@Z	; std::reverse_iterator<wchar_t const *>::reverse_iterator<wchar_t const *>
PUBLIC	??0?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEAA@XZ ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >
PUBLIC	??1?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEAA@XZ ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::~vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >
PUBLIC	?push_back@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEAAX$$QEAU_Find_file_handle@filesystem@2@@Z ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::push_back
PUBLIC	?pop_back@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEAAXXZ ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::pop_back
PUBLIC	?empty@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEBA_NXZ ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::empty
PUBLIC	?back@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEAAAEAU_Find_file_handle@filesystem@2@XZ ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::back
PUBLIC	??0?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAA@AEBV01@@Z ; std::shared_ptr<std::filesystem::_Recursive_dir_enum_impl>::shared_ptr<std::filesystem::_Recursive_dir_enum_impl>
PUBLIC	??0?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAA@$$QEAV01@@Z ; std::shared_ptr<std::filesystem::_Recursive_dir_enum_impl>::shared_ptr<std::filesystem::_Recursive_dir_enum_impl>
PUBLIC	??1?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAA@XZ ; std::shared_ptr<std::filesystem::_Recursive_dir_enum_impl>::~shared_ptr<std::filesystem::_Recursive_dir_enum_impl>
PUBLIC	?reset@?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAAXXZ ; std::shared_ptr<std::filesystem::_Recursive_dir_enum_impl>::reset
PUBLIC	??1?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::~vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >
PUBLIC	?resize@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::resize
PUBLIC	?_Unchecked_begin@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAUNodeDef@AINBNodeDefMgr@@XZ ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAUNodeDef@AINBNodeDefMgr@@XZ ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::_Unchecked_end
PUBLIC	?size@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::size
PUBLIC	??A?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAAEAUNodeDef@AINBNodeDefMgr@@_K@Z ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::operator[]
PUBLIC	?resize@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::resize
PUBLIC	?_Unchecked_begin@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAUInputParam@NodeDef@AINBNodeDefMgr@@XZ ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAUInputParam@NodeDef@AINBNodeDefMgr@@XZ ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Unchecked_end
PUBLIC	?size@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::size
PUBLIC	??A?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAAEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::operator[]
PUBLIC	?resize@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@QEAAX_K@Z ; std::vector<AINBFile::OutputEntry,std::allocator<AINBFile::OutputEntry> >::resize
PUBLIC	?resize@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::resize
PUBLIC	?_Unchecked_begin@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@XZ ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@XZ ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Unchecked_end
PUBLIC	?size@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::size
PUBLIC	??A?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAAEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::operator[]
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > >::operator==
PUBLIC	?NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z ; AINBNodeDefMgr::NodeDefToNode
PUBLIC	?__autoclassinit2@recursive_directory_iterator@filesystem@std@@QEAAX_K@Z ; std::filesystem::recursive_directory_iterator::__autoclassinit2
PUBLIC	??0recursive_directory_iterator@filesystem@std@@QEAA@AEBV012@@Z ; std::filesystem::recursive_directory_iterator::recursive_directory_iterator
PUBLIC	??0ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z ; AINBNodeDefMgr::NodeDef::ImmediateParam::ImmediateParam
PUBLIC	??0InputParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z ; AINBNodeDefMgr::NodeDef::InputParam::InputParam
PUBLIC	?__autoclassinit2@AINBFile@@QEAAX_K@Z		; AINBFile::__autoclassinit2
PUBLIC	??1AINBFile@@QEAA@XZ				; AINBFile::~AINBFile
PUBLIC	?GetNodeDefinition@AINBNodeDefMgr@@YAPEAUNodeDef@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; AINBNodeDefMgr::GetNodeDefinition
PUBLIC	??4NodeDef@AINBNodeDefMgr@@QEAAAEAU01@AEBU01@@Z	; AINBNodeDefMgr::NodeDef::operator=
PUBLIC	??4ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAAAEAU012@AEBU012@@Z ; AINBNodeDefMgr::NodeDef::ImmediateParam::operator=
PUBLIC	??1ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ ; AINBNodeDefMgr::NodeDef::ImmediateParam::~ImmediateParam
PUBLIC	??4InputParam@NodeDef@AINBNodeDefMgr@@QEAAAEAU012@AEBU012@@Z ; AINBNodeDefMgr::NodeDef::InputParam::operator=
PUBLIC	??1InputParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ	; AINBNodeDefMgr::NodeDef::InputParam::~InputParam
PUBLIC	??1NodeDef@AINBNodeDefMgr@@QEAA@XZ		; AINBNodeDefMgr::NodeDef::~NodeDef
PUBLIC	??0ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ ; AINBNodeDefMgr::NodeDef::ImmediateParam::ImmediateParam
PUBLIC	??0InputParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ	; AINBNodeDefMgr::NodeDef::InputParam::InputParam
PUBLIC	??0NodeDef@AINBNodeDefMgr@@QEAA@XZ		; AINBNodeDefMgr::NodeDef::NodeDef
PUBLIC	?Initialize@AINBNodeDefMgr@@YAXXZ		; AINBNodeDefMgr::Initialize
PUBLIC	?ReadString@AINBNodeDefMgr@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@@Z ; AINBNodeDefMgr::ReadString
PUBLIC	?__autoclassinit2@EXB@@QEAAX_K@Z		; EXB::__autoclassinit2
PUBLIC	??0recursive_directory_iterator@filesystem@std@@QEAA@XZ ; std::filesystem::recursive_directory_iterator::recursive_directory_iterator
PUBLIC	?end@filesystem@std@@YA?AVrecursive_directory_iterator@12@V312@@Z ; std::filesystem::end
PUBLIC	??0recursive_directory_iterator@filesystem@std@@QEAA@$$QEAV012@@Z ; std::filesystem::recursive_directory_iterator::recursive_directory_iterator
PUBLIC	??1recursive_directory_iterator@filesystem@std@@QEAA@XZ ; std::filesystem::recursive_directory_iterator::~recursive_directory_iterator
PUBLIC	?begin@filesystem@std@@YA?AVrecursive_directory_iterator@12@V312@@Z ; std::filesystem::begin
PUBLIC	??0?$_Ptr_base@U_Recursive_dir_enum_impl@filesystem@std@@@std@@IEAA@XZ ; std::_Ptr_base<std::filesystem::_Recursive_dir_enum_impl>::_Ptr_base<std::filesystem::_Recursive_dir_enum_impl>
PUBLIC	??0?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAA@XZ ; std::shared_ptr<std::filesystem::_Recursive_dir_enum_impl>::shared_ptr<std::filesystem::_Recursive_dir_enum_impl>
PUBLIC	??8recursive_directory_iterator@filesystem@std@@QEBA_NAEBV012@@Z ; std::filesystem::recursive_directory_iterator::operator==
PUBLIC	??Erecursive_directory_iterator@filesystem@std@@QEAAAEAV012@XZ ; std::filesystem::recursive_directory_iterator::operator++
PUBLIC	??Drecursive_directory_iterator@filesystem@std@@QEBAAEBVdirectory_entry@12@XZ ; std::filesystem::recursive_directory_iterator::operator*
PUBLIC	??0recursive_directory_iterator@filesystem@std@@QEAA@AEBVpath@12@@Z ; std::filesystem::recursive_directory_iterator::recursive_directory_iterator
PUBLIC	??1_Dir_enum_impl@filesystem@std@@QEAA@XZ	; std::filesystem::_Dir_enum_impl::~_Dir_enum_impl
PUBLIC	??0_Recursive_dir_enum_impl@filesystem@std@@QEAA@$$QEAU_Creator@_Dir_enum_impl@12@W4directory_options@12@@Z ; std::filesystem::_Recursive_dir_enum_impl::_Recursive_dir_enum_impl
PUBLIC	?_Advance_and_reset_if_no_more_files@_Recursive_dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@3@@Z ; std::filesystem::_Recursive_dir_enum_impl::_Advance_and_reset_if_no_more_files
PUBLIC	?_Advance_and_skip_dots@_Recursive_dir_enum_impl@filesystem@std@@QEAA?AW4__std_win_error@@AEAU__std_fs_find_data@@@Z ; std::filesystem::_Recursive_dir_enum_impl::_Advance_and_skip_dots
PUBLIC	?_Should_recurse@_Recursive_dir_enum_impl@filesystem@std@@QEBA?AU_Should_recurse_result@23@XZ ; std::filesystem::_Recursive_dir_enum_impl::_Should_recurse
PUBLIC	??4path@filesystem@std@@QEAAAEAV012@$$QEAV012@@Z ; std::filesystem::path::operator=
PUBLIC	??1directory_entry@filesystem@std@@QEAA@XZ	; std::filesystem::directory_entry::~directory_entry
PUBLIC	??0_Find_file_handle@filesystem@std@@QEAA@XZ	; std::filesystem::_Find_file_handle::_Find_file_handle
PUBLIC	??0_Dir_enum_impl@filesystem@std@@QEAA@$$QEAU_Creator@012@W4directory_options@12@@Z ; std::filesystem::_Dir_enum_impl::_Dir_enum_impl
PUBLIC	?_Refresh@_Dir_enum_impl@filesystem@std@@QEAAXAEBU__std_fs_find_data@@@Z ; std::filesystem::_Dir_enum_impl::_Refresh
PUBLIC	??0_Creator@_Dir_enum_impl@filesystem@std@@QEAA@AEBVpath@23@W4directory_options@23@@Z ; std::filesystem::_Dir_enum_impl::_Creator::_Creator
PUBLIC	?_Open_dir@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAVpath@23@W4directory_options@23@AEAU_Find_file_handle@23@AEAU__std_fs_find_data@@@Z ; std::filesystem::_Dir_enum_impl::_Open_dir
PUBLIC	?_Skip_dots@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@W4__std_fs_dir_handle@@AEAU__std_fs_find_data@@@Z ; std::filesystem::_Dir_enum_impl::_Skip_dots
PUBLIC	??Ifilesystem@std@@YA?AW4directory_options@01@W4201@0@Z ; std::filesystem::operator&
PUBLIC	??0file_status@filesystem@std@@QEAA@XZ		; std::filesystem::file_status::file_status
PUBLIC	??0_File_status_and_error@filesystem@std@@QEAA@XZ ; std::filesystem::_File_status_and_error::_File_status_and_error
PUBLIC	?_Refresh@directory_entry@filesystem@std@@AEAAXAEBU__std_fs_find_data@@@Z ; std::filesystem::directory_entry::_Refresh
PUBLIC	?status@directory_entry@filesystem@std@@QEBA?AVfile_status@23@XZ ; std::filesystem::directory_entry::status
PUBLIC	?_Get_any_status@directory_entry@filesystem@std@@AEBA?AU_File_status_and_error@23@W4__std_fs_stats_flags@@@Z ; std::filesystem::directory_entry::_Get_any_status
PUBLIC	?_Is_symlink_or_junction@directory_entry@filesystem@std@@QEBA_NXZ ; std::filesystem::directory_entry::_Is_symlink_or_junction
PUBLIC	?is_regular_file@directory_entry@filesystem@std@@QEBA_NXZ ; std::filesystem::directory_entry::is_regular_file
PUBLIC	?path@directory_entry@filesystem@std@@QEBAAEBV023@XZ ; std::filesystem::directory_entry::path
PUBLIC	?_Has_cached_attribute@directory_entry@filesystem@std@@AEBA_NW4__std_fs_file_attr@@@Z ; std::filesystem::directory_entry::_Has_cached_attribute
PUBLIC	??0directory_entry@filesystem@std@@QEAA@XZ	; std::filesystem::directory_entry::directory_entry
PUBLIC	?_Not_good@_File_status_and_error@filesystem@std@@QEBA_NXZ ; std::filesystem::_File_status_and_error::_Not_good
PUBLIC	?is_regular_file@filesystem@std@@YA_NVfile_status@12@@Z ; std::filesystem::is_regular_file
PUBLIC	?_Refresh@file_status@filesystem@std@@QEAAXW4__std_win_error@@AEBU__std_fs_stats@@@Z ; std::filesystem::file_status::_Refresh
PUBLIC	?type@file_status@filesystem@std@@QEBA?AW4file_type@23@XZ ; std::filesystem::file_status::type
PUBLIC	?permissions@file_status@filesystem@std@@QEAAXW4perms@23@@Z ; std::filesystem::file_status::permissions
PUBLIC	?type@file_status@filesystem@std@@QEAAXW4file_type@23@@Z ; std::filesystem::file_status::type
PUBLIC	?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@AEBVpath@12@@Z ; std::filesystem::_Throw_fs_error
PUBLIC	??0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z ; std::filesystem::filesystem_error::filesystem_error
PUBLIC	?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@@Z ; std::filesystem::_Throw_fs_error
PUBLIC	??1filesystem_error@filesystem@std@@UEAA@XZ	; std::filesystem::filesystem_error::~filesystem_error
PUBLIC	??_Gfilesystem_error@filesystem@std@@UEAAPEAXI@Z ; std::filesystem::filesystem_error::`scalar deleting destructor'
PUBLIC	?_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z ; std::filesystem::filesystem_error::_Pretty_message
PUBLIC	?what@filesystem_error@filesystem@std@@UEBAPEBDXZ ; std::filesystem::filesystem_error::what
PUBLIC	??0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z ; std::filesystem::filesystem_error::filesystem_error
PUBLIC	??0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@@Z ; std::filesystem::filesystem_error::filesystem_error
PUBLIC	??0path@filesystem@std@@QEAA@AEBV012@@Z		; std::filesystem::path::path
PUBLIC	??0path@filesystem@std@@QEAA@XZ			; std::filesystem::path::path
PUBLIC	?__autoclassinit2@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QEAAX_K@Z ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::__autoclassinit2
PUBLIC	??1path@filesystem@std@@QEAA@XZ			; std::filesystem::path::~path
PUBLIC	?__autoclassinit2@?$reverse_iterator@PEB_W@std@@QEAAX_K@Z ; std::reverse_iterator<wchar_t const *>::__autoclassinit2
PUBLIC	??4path@filesystem@std@@QEAAAEAV012@AEBV012@@Z	; std::filesystem::path::operator=
PUBLIC	??0?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QEAA@QEB_W_K@Z ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::basic_string_view<wchar_t,std::char_traits<wchar_t> >
PUBLIC	?is_absolute@path@filesystem@std@@QEBA_NXZ	; std::filesystem::path::is_absolute
PUBLIC	?filename@path@filesystem@std@@QEBA?AV123@XZ	; std::filesystem::path::filename
PUBLIC	?string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ ; std::filesystem::path::string
PUBLIC	?c_str@path@filesystem@std@@QEBAPEB_WXZ		; std::filesystem::path::c_str
PUBLIC	?native@path@filesystem@std@@QEBAAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@3@XZ ; std::filesystem::path::native
PUBLIC	?replace_filename@path@filesystem@std@@QEAAAEAV123@AEBV123@@Z ; std::filesystem::path::replace_filename
PUBLIC	?_Remove_filename_and_separator@path@filesystem@std@@QEAAXXZ ; std::filesystem::path::_Remove_filename_and_separator
PUBLIC	?remove_filename@path@filesystem@std@@QEAAAEAV123@XZ ; std::filesystem::path::remove_filename
PUBLIC	??_0path@filesystem@std@@QEAAAEAV012@AEBV012@@Z	; std::filesystem::path::operator/=
PUBLIC	??1_Find_file_handle@filesystem@std@@QEAA@XZ	; std::filesystem::_Find_file_handle::~_Find_file_handle
PUBLIC	?_Open@_Find_file_handle@filesystem@std@@QEAA?AW4__std_win_error@@PEB_WPEAU__std_fs_find_data@@@Z ; std::filesystem::_Find_file_handle::_Open
PUBLIC	??4_Find_file_handle@filesystem@std@@QEAAAEAU012@$$QEAU012@@Z ; std::filesystem::_Find_file_handle::operator=
PUBLIC	??0_Find_file_handle@filesystem@std@@QEAA@$$QEAU012@@Z ; std::filesystem::_Find_file_handle::_Find_file_handle
PUBLIC	?_Is_dot_or_dotdot@filesystem@std@@YA_NAEBU__std_fs_find_data@@@Z ; std::filesystem::_Is_dot_or_dotdot
PUBLIC	?_Range_compare@filesystem@std@@YAHQEB_W000@Z	; std::filesystem::_Range_compare
PUBLIC	?_Parse_filename@filesystem@std@@YA?AV?$basic_string_view@_WU?$char_traits@_W@std@@@2@V32@@Z ; std::filesystem::_Parse_filename
PUBLIC	?_Find_filename@filesystem@std@@YAPEB_WQEB_WPEB_W@Z ; std::filesystem::_Find_filename
PUBLIC	?_Find_relative_path@filesystem@std@@YAPEB_WQEB_W0@Z ; std::filesystem::_Find_relative_path
PUBLIC	?data@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QEBAPEB_WXZ ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::data
PUBLIC	?_Find_root_name_end@filesystem@std@@YAPEB_WQEB_W0@Z ; std::filesystem::_Find_root_name_end
PUBLIC	?_Has_drive_letter_prefix@filesystem@std@@YA_NQEB_W0@Z ; std::filesystem::_Has_drive_letter_prefix
PUBLIC	?_Is_drive_prefix@filesystem@std@@YA_NQEB_W@Z	; std::filesystem::_Is_drive_prefix
PUBLIC	?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_string_engaged
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAPEA_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
PUBLIC	?data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAPEA_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::data
PUBLIC	?data@?$basic_string_view@DU?$char_traits@D@std@@@std@@QEBAPEBDXZ ; std::basic_string_view<char,std::char_traits<char> >::data
PUBLIC	?_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z ; std::filesystem::_Convert_narrow_to_wide
PUBLIC	?__autoclassinit2@?$basic_string_view@DU?$char_traits@D@std@@@std@@QEAAX_K@Z ; std::basic_string_view<char,std::char_traits<char> >::__autoclassinit2
PUBLIC	?_Check_convert_result@std@@YAHU__std_fs_convert_result@@@Z ; std::_Check_convert_result
PUBLIC	??R_Is_slash_oper@std@@QEBA_N_W@Z		; std::_Is_slash_oper::operator()
PUBLIC	?_Symlink_hint_attributes@__std_fs_stats@@QEBA?AW4__std_fs_file_attr@@XZ ; __std_fs_stats::_Symlink_hint_attributes
PUBLIC	??_5@YAAEAW4__std_fs_stats_flags@@AEAW40@W40@@Z	; operator|=
PUBLIC	??U@YA?AW4__std_fs_stats_flags@@W40@0@Z		; operator|
PUBLIC	??I@YA?AW4__std_fs_stats_flags@@W40@0@Z		; operator&
PUBLIC	??I@YA?AW4__std_fs_file_attr@@W40@0@Z		; operator&
PUBLIC	__std_is_file_not_found
PUBLIC	??0_Ref_count_base@std@@IEAA@XZ			; std::_Ref_count_base::_Ref_count_base
PUBLIC	?_Get_deleter@_Ref_count_base@std@@UEBAPEAXAEBVtype_info@@@Z ; std::_Ref_count_base::_Get_deleter
PUBLIC	?_Decwref@_Ref_count_base@std@@QEAAXXZ		; std::_Ref_count_base::_Decwref
PUBLIC	?_Decref@_Ref_count_base@std@@QEAAXXZ		; std::_Ref_count_base::_Decref
PUBLIC	?_Incref@_Ref_count_base@std@@QEAAXXZ		; std::_Ref_count_base::_Incref
PUBLIC	??1_Ref_count_base@std@@UEAA@XZ			; std::_Ref_count_base::~_Ref_count_base
PUBLIC	?_Throw_system_error_from_std_win_error@std@@YAXW4__std_win_error@@@Z ; std::_Throw_system_error_from_std_win_error
PUBLIC	?_Make_ec@std@@YA?AVerror_code@1@W4__std_win_error@@@Z ; std::_Make_ec
PUBLIC	?system_category@std@@YAAEBVerror_category@1@XZ	; std::system_category
PUBLIC	?generic_category@std@@YAAEBVerror_category@1@XZ ; std::generic_category
PUBLIC	??1_System_error_category@std@@UEAA@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UEAAPEAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	?default_error_condition@_System_error_category@std@@UEBA?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?name@_System_error_category@std@@UEBAPEBDXZ	; std::_System_error_category::name
PUBLIC	??1_Generic_error_category@std@@UEAA@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UEAAPEAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	?message@_Generic_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	?name@_Generic_error_category@std@@UEBAPEBDXZ	; std::_Generic_error_category::name
PUBLIC	??1_System_error_message@std@@QEAA@XZ		; std::_System_error_message::~_System_error_message
PUBLIC	??0_System_error_message@std@@QEAA@K@Z		; std::_System_error_message::_System_error_message
PUBLIC	??0_System_error@std@@QEAA@AEBV01@@Z		; std::_System_error::_System_error
PUBLIC	??0system_error@std@@QEAA@AEBV01@@Z		; std::system_error::system_error
PUBLIC	?_Throw_system_error@std@@YAXW4errc@1@@Z	; std::_Throw_system_error
PUBLIC	??1system_error@std@@UEAA@XZ			; std::system_error::~system_error
PUBLIC	??_Gsystem_error@std@@UEAAPEAXI@Z		; std::system_error::`scalar deleting destructor'
PUBLIC	??0system_error@std@@QEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::system_error::system_error
PUBLIC	??0system_error@std@@QEAA@Verror_code@1@@Z	; std::system_error::system_error
PUBLIC	??1_System_error@std@@UEAA@XZ			; std::_System_error::~_System_error
PUBLIC	??_G_System_error@std@@UEAAPEAXI@Z		; std::_System_error::`scalar deleting destructor'
PUBLIC	??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error
PUBLIC	??0_System_error@std@@IEAA@Verror_code@1@@Z	; std::_System_error::_System_error
PUBLIC	?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z ; std::_System_error::_Makestr
PUBLIC	?make_error_code@std@@YA?AVerror_code@1@W4errc@1@@Z ; std::make_error_code
PUBLIC	?equivalent@error_category@std@@UEBA_NAEBVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?default_error_condition@error_category@std@@UEBA?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	??8std@@YA_NAEBVerror_condition@0@0@Z		; std::operator==
PUBLIC	?category@error_condition@std@@QEBAAEBVerror_category@2@XZ ; std::error_condition::category
PUBLIC	?value@error_condition@std@@QEBAHXZ		; std::error_condition::value
PUBLIC	??0error_condition@std@@QEAA@HAEBVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::error_code::message
PUBLIC	?category@error_code@std@@QEBAAEBVerror_category@2@XZ ; std::error_code::category
PUBLIC	?value@error_code@std@@QEBAHXZ			; std::error_code::value
PUBLIC	??0error_code@std@@QEAA@HAEBVerror_category@1@@Z ; std::error_code::error_code
PUBLIC	??1error_category@std@@UEAA@XZ			; std::error_category::~error_category
PUBLIC	??8error_category@std@@QEBA_NAEBV01@@Z		; std::error_category::operator==
PUBLIC	??0runtime_error@std@@QEAA@AEBV01@@Z		; std::runtime_error::runtime_error
PUBLIC	??1runtime_error@std@@UEAA@XZ			; std::runtime_error::~runtime_error
PUBLIC	??_Gruntime_error@std@@UEAAPEAXI@Z		; std::runtime_error::`scalar deleting destructor'
PUBLIC	??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
PUBLIC	??__Ksv@string_view_literals@literals@std@@YA?AV?$basic_string_view@_WU?$char_traits@_W@std@@@3@PEB_W_K@Z ; std::literals::string_view_literals::operator "" sv
PUBLIC	??__Ksv@string_view_literals@literals@std@@YA?AV?$basic_string_view@DU?$char_traits@D@std@@@3@PEBD_K@Z ; std::literals::string_view_literals::operator "" sv
PUBLIC	??0exception@std@@QEAA@QEBD@Z			; std::exception::exception
PUBLIC	wmemset
PUBLIC	?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A ; AINBNodeDefMgr::NodeDefinitions
PUBLIC	?EXBFile@AINBNodeDefMgr@@3VEXB@@A		; AINBNodeDefMgr::EXBFile
EXTRN	??_E_System_error_category@std@@UEAAPEAXI@Z:PROC ; std::_System_error_category::`vector deleting destructor'
EXTRN	??_E_System_error@std@@UEAAPEAXI@Z:PROC		; std::_System_error::`vector deleting destructor'
EXTRN	??_E?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@UEAAPEAXI@Z:PROC ; std::_Ref_count_obj2<std::filesystem::_Recursive_dir_enum_impl>::`vector deleting destructor'
EXTRN	??_Esystem_error@std@@UEAAPEAXI@Z:PROC		; std::system_error::`vector deleting destructor'
EXTRN	??_Eruntime_error@std@@UEAAPEAXI@Z:PROC		; std::runtime_error::`vector deleting destructor'
EXTRN	??_Efilesystem_error@filesystem@std@@UEAAPEAXI@Z:PROC ; std::filesystem::filesystem_error::`vector deleting destructor'
EXTRN	??_E_Generic_error_category@std@@UEAAPEAXI@Z:PROC ; std::_Generic_error_category::`vector deleting destructor'
?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A DB 018H DUP (?) ; AINBNodeDefMgr::NodeDefinitions
?EXBFile@AINBNodeDefMgr@@3VEXB@@A DB 068H DUP (?)	; AINBNodeDefMgr::EXBFile
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy@PEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@00AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z DD imagerel $LN44
	DD	imagerel $LN44+134
	DD	imagerel $unwind$??$_Uninitialized_copy@PEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@00AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@00AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z DD imagerel $LN49
	DD	imagerel $LN49+173
	DD	imagerel $unwind$??$_Uninitialized_copy@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@00AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_nonzero@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z DD imagerel $LN10
	DD	imagerel $LN10+75
	DD	imagerel $unwind$?_Buy_nonzero@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_nonzero@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z DD imagerel $LN10
	DD	imagerel $LN10+75
	DD	imagerel $unwind$?_Buy_nonzero@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0InputParam@NodeDef@AINBNodeDefMgr@@QEAA@$$QEAU012@@Z DD imagerel $LN89
	DD	imagerel $LN89+203
	DD	imagerel $unwind$??0InputParam@NodeDef@AINBNodeDefMgr@@QEAA@$$QEAU012@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_n@AEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@AEBQEAU123@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@1@Z DD imagerel $LN59
	DD	imagerel $LN59+214
	DD	imagerel $unwind$??$_Construct_n@AEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@AEBQEAU123@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_n@AEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEBQEAU123@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@1@Z DD imagerel $LN64
	DD	imagerel $LN64+252
	DD	imagerel $unwind$??$_Construct_n@AEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEBQEAU123@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@UImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@$0A@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@AEAU123@@Z DD imagerel $LN10
	DD	imagerel $LN10+75
	DD	imagerel $unwind$??$construct_at@UImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@$0A@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@AEAU123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@UInputParam@NodeDef@AINBNodeDefMgr@@U123@$0A@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@QEAU123@$$QEAU123@@Z DD imagerel $LN92
	DD	imagerel $LN92+203
	DD	imagerel $unwind$??$construct_at@UInputParam@NodeDef@AINBNodeDefMgr@@U123@$0A@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@QEAU123@$$QEAU123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@AEBV01@@Z DD imagerel $LN65
	DD	imagerel $LN65+260
	DD	imagerel $unwind$??0?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@AEBV01@@Z DD imagerel $LN70
	DD	imagerel $LN70+312
	DD	imagerel $unwind$??0?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@UImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@@?$_Default_allocator_traits@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@1@QEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU345@@Z DD imagerel $LN12
	DD	imagerel $LN12+83
	DD	imagerel $unwind$??$construct@UImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@@?$_Default_allocator_traits@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@1@QEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU345@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@$0A@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV10@@Z DD imagerel $LN73
	DD	imagerel $LN73+312
	DD	imagerel $unwind$??$construct_at@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@$0A@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@$0A@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV10@@Z DD imagerel $LN68
	DD	imagerel $LN68+260
	DD	imagerel $unwind$??$construct_at@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@$0A@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@UNodeDef@AINBNodeDefMgr@@$$V$0A@@std@@YAPEAUNodeDef@AINBNodeDefMgr@@QEAU12@@Z DD imagerel $LN5
	DD	imagerel $LN5+35
	DD	imagerel $unwind$??$construct_at@UNodeDef@AINBNodeDefMgr@@$$V$0A@@std@@YAPEAUNodeDef@AINBNodeDefMgr@@QEAU12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@UInputParam@NodeDef@AINBNodeDefMgr@@U123@@?$_Default_allocator_traits@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@1@QEAUInputParam@NodeDef@AINBNodeDefMgr@@$$QEAU345@@Z DD imagerel $LN94
	DD	imagerel $LN94+204
	DD	imagerel $unwind$??$construct@UInputParam@NodeDef@AINBNodeDefMgr@@U123@@?$_Default_allocator_traits@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@1@QEAUInputParam@NodeDef@AINBNodeDefMgr@@$$QEAU345@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@U_Recursive_dir_enum_impl@filesystem@std@@U_Creator@_Dir_enum_impl@23@AEBW4directory_options@23@$0A@@std@@YAPEAU_Recursive_dir_enum_impl@filesystem@0@QEAU120@$$QEAU_Creator@_Dir_enum_impl@20@AEBW4directory_options@20@@Z DD imagerel $LN15
	DD	imagerel $LN15+56
	DD	imagerel $unwind$??$construct_at@U_Recursive_dir_enum_impl@filesystem@std@@U_Creator@_Dir_enum_impl@23@AEBW4directory_options@23@$0A@@std@@YAPEAU_Recursive_dir_enum_impl@filesystem@0@QEAU120@$$QEAU_Creator@_Dir_enum_impl@20@AEBW4directory_options@20@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GInputParam@NodeDef@AINBNodeDefMgr@@QEAAPEAXI@Z DD imagerel $LN6
	DD	imagerel $LN6+23
	DD	imagerel $unwind$??_GInputParam@NodeDef@AINBNodeDefMgr@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GImmediateParam@NodeDef@AINBNodeDefMgr@@QEAAPEAXI@Z DD imagerel $LN6
	DD	imagerel $LN6+23
	DD	imagerel $unwind$??_GImmediateParam@NodeDef@AINBNodeDefMgr@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@AEAUInputParam@NodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAXAEAUInputParam@NodeDef@AINBNodeDefMgr@@@Z DD imagerel $LN8
	DD	imagerel $LN8+32
	DD	imagerel $unwind$??$_Emplace_back@AEAUInputParam@NodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAXAEAUInputParam@NodeDef@AINBNodeDefMgr@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@AEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAXAEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z DD imagerel $LN14
	DD	imagerel $LN14+94
	DD	imagerel $unwind$??$_Emplace_back@AEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAXAEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@AEAV31@@Z DD imagerel $LN76
	DD	imagerel $LN76+310
	DD	imagerel $unwind$??$construct@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@AEAV31@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@AEAV31@@Z DD imagerel $LN71
	DD	imagerel $LN71+260
	DD	imagerel $unwind$??$construct@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@AEAV31@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@UNodeDef@AINBNodeDefMgr@@$$V@?$_Default_allocator_traits@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@1@QEAUNodeDef@AINBNodeDefMgr@@@Z DD imagerel $LN7
	DD	imagerel $LN7+38
	DD	imagerel $unwind$??$construct@UNodeDef@AINBNodeDefMgr@@$$V@?$_Default_allocator_traits@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@1@QEAUNodeDef@AINBNodeDefMgr@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@UNodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX$$QEAUNodeDef@AINBNodeDefMgr@@@Z DD imagerel $LN9
	DD	imagerel $LN9+29
	DD	imagerel $unwind$??$_Emplace_back@UNodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX$$QEAUNodeDef@AINBNodeDefMgr@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@UInputParam@NodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX$$QEAUInputParam@NodeDef@AINBNodeDefMgr@@@Z DD imagerel $LN96
	DD	imagerel $LN96+218
	DD	imagerel $unwind$??$_Emplace_back@UInputParam@NodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX$$QEAUInputParam@NodeDef@AINBNodeDefMgr@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@U_Recursive_dir_enum_impl@filesystem@std@@U_Creator@_Dir_enum_impl@23@AEBW4directory_options@23@@std@@YAXAEAU_Recursive_dir_enum_impl@filesystem@0@$$QEAU_Creator@_Dir_enum_impl@20@AEBW4directory_options@20@@Z DD imagerel $LN29
	DD	imagerel $LN29+53
	DD	imagerel $unwind$??$_Construct_in_place@U_Recursive_dir_enum_impl@filesystem@std@@U_Creator@_Dir_enum_impl@23@AEBW4directory_options@23@@std@@YAXAEAU_Recursive_dir_enum_impl@filesystem@0@$$QEAU_Creator@_Dir_enum_impl@20@AEBW4directory_options@20@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@_W@1@@Z DD imagerel $LN57
	DD	imagerel $LN57+113
	DD	imagerel $unwind$??$?0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@_W@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$?0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@_W@1@@Z DD imagerel $LN57+113
	DD	imagerel $LN57+207
	DD	imagerel $chain$0$??$?0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@_W@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$?0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@_W@1@@Z DD imagerel $LN57+207
	DD	imagerel $LN57+213
	DD	imagerel $chain$1$??$?0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@_W@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ DD imagerel $LN47
	DD	imagerel $LN47+21
	DD	imagerel $unwind$?_Tidy@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Tidy@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ DD imagerel $LN47+21
	DD	imagerel $LN47+105
	DD	imagerel $chain$0$?_Tidy@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Tidy@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ DD imagerel $LN47+105
	DD	imagerel $LN47+165
	DD	imagerel $chain$1$?_Tidy@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ DD imagerel $LN47
	DD	imagerel $LN47+21
	DD	imagerel $unwind$?_Tidy@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Tidy@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ DD imagerel $LN47+21
	DD	imagerel $LN47+102
	DD	imagerel $chain$0$?_Tidy@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Tidy@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ DD imagerel $LN47+102
	DD	imagerel $LN47+162
	DD	imagerel $chain$1$?_Tidy@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Uninitialized_backout_al@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@@std@@QEAA@XZ DD imagerel $LN24
	DD	imagerel $LN24+50
	DD	imagerel $unwind$??1?$_Uninitialized_backout_al@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G_Recursive_dir_enum_impl@filesystem@std@@QEAAPEAXI@Z DD imagerel $LN23
	DD	imagerel $LN23+45
	DD	imagerel $unwind$??_G_Recursive_dir_enum_impl@filesystem@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAXI@Z DD imagerel $LN8
	DD	imagerel $LN8+23
	DD	imagerel $unwind$??_G?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAXI@Z DD imagerel $LN8
	DD	imagerel $LN8+23
	DD	imagerel $unwind$??_G?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GNodeDef@AINBNodeDefMgr@@QEAAPEAXI@Z DD imagerel $LN6
	DD	imagerel $LN6+23
	DD	imagerel $unwind$??_GNodeDef@AINBNodeDefMgr@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$0PI@@std@@YA_K_K@Z DD imagerel $LN7
	DD	imagerel $LN7+37
	DD	imagerel $unwind$??$_Get_size_of_n@$0PI@@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$0JA@@std@@YA_K_K@Z DD imagerel $LN7
	DD	imagerel $LN7+38
	DD	imagerel $unwind$??$_Get_size_of_n@$0JA@@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Recursive_dir_enum_impl@filesystem@std@@QEAA@XZ DD imagerel $LN19
	DD	imagerel $LN19+41
	DD	imagerel $unwind$??1_Recursive_dir_enum_impl@filesystem@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_in_place@U_Recursive_dir_enum_impl@filesystem@std@@@std@@YAXAEAU_Recursive_dir_enum_impl@filesystem@0@@Z DD imagerel $LN25
	DD	imagerel $LN25+41
	DD	imagerel $unwind$??$_Destroy_in_place@U_Recursive_dir_enum_impl@filesystem@std@@@std@@YAXAEAU_Recursive_dir_enum_impl@filesystem@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_n_unchecked4@PEAUInputParam@NodeDef@AINBNodeDefMgr@@_KPEAU123@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0@Z DD imagerel $LN53
	DD	imagerel $LN53+25
	DD	imagerel $unwind$??$_Copy_n_unchecked4@PEAUInputParam@NodeDef@AINBNodeDefMgr@@_KPEAU123@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Copy_n_unchecked4@PEAUInputParam@NodeDef@AINBNodeDefMgr@@_KPEAU123@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0@Z DD imagerel $LN53+25
	DD	imagerel $LN53+228
	DD	imagerel $chain$1$??$_Copy_n_unchecked4@PEAUInputParam@NodeDef@AINBNodeDefMgr@@_KPEAU123@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Copy_n_unchecked4@PEAUInputParam@NodeDef@AINBNodeDefMgr@@_KPEAU123@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0@Z DD imagerel $LN53+228
	DD	imagerel $LN53+242
	DD	imagerel $chain$2$??$_Copy_n_unchecked4@PEAUInputParam@NodeDef@AINBNodeDefMgr@@_KPEAU123@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy_n@PEAUInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z DD imagerel $LN44
	DD	imagerel $LN44+135
	DD	imagerel $unwind$??$_Uninitialized_copy_n@PEAUInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_n_unchecked4@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_KPEAU123@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0@Z DD imagerel $LN41
	DD	imagerel $LN41+25
	DD	imagerel $unwind$??$_Copy_n_unchecked4@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_KPEAU123@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Copy_n_unchecked4@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_KPEAU123@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0@Z DD imagerel $LN41+25
	DD	imagerel $LN41+171
	DD	imagerel $chain$1$??$_Copy_n_unchecked4@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_KPEAU123@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Copy_n_unchecked4@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_KPEAU123@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0@Z DD imagerel $LN41+171
	DD	imagerel $LN41+185
	DD	imagerel $chain$2$??$_Copy_n_unchecked4@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_KPEAU123@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy_n@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z DD imagerel $LN49
	DD	imagerel $LN49+170
	DD	imagerel $unwind$??$_Uninitialized_copy_n@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@AEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAXAEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z DD imagerel $LN79
	DD	imagerel $LN79+313
	DD	imagerel $unwind$??$_Emplace_back@AEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAXAEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z DD imagerel $LN59
	DD	imagerel $LN59+18
	DD	imagerel $unwind$??$_Uninitialized_move@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Uninitialized_move@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z DD imagerel $LN59+18
	DD	imagerel $LN59+87
	DD	imagerel $chain$0$??$_Uninitialized_move@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Uninitialized_move@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z DD imagerel $LN59+87
	DD	imagerel $LN59+92
	DD	imagerel $chain$1$??$_Uninitialized_move@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@AEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAXAEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z DD imagerel $LN74
	DD	imagerel $LN74+263
	DD	imagerel $unwind$??$_Emplace_back@AEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAXAEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z DD imagerel $LN59
	DD	imagerel $LN59+18
	DD	imagerel $unwind$??$_Uninitialized_move@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Uninitialized_move@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z DD imagerel $LN59+18
	DD	imagerel $LN59+87
	DD	imagerel $chain$0$??$_Uninitialized_move@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Uninitialized_move@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z DD imagerel $LN59+87
	DD	imagerel $LN59+92
	DD	imagerel $chain$1$??$_Uninitialized_move@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@QEAW4123@0PEAW4123@AEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@0@@Z DD imagerel $LN23
	DD	imagerel $LN23+49
	DD	imagerel $unwind$??$_Uninitialized_move@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@QEAW4123@0PEAW4123@AEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@00@Z DD imagerel $LN4
	DD	imagerel $LN4+48
	DD	imagerel $unwind$??$_Copy_memmove@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAXXZ DD imagerel $LN9
	DD	imagerel $LN9+60
	DD	imagerel $unwind$??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAUNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUNodeDef@AINBNodeDefMgr@@QEAU12@0PEAU12@AEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@0@@Z DD imagerel $LN45
	DD	imagerel $LN45+76
	DD	imagerel $unwind$??$_Uninitialized_move@PEAUNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUNodeDef@AINBNodeDefMgr@@QEAU12@0PEAU12@AEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAUInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@QEAU123@0PEAU123@AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z DD imagerel $LN138
	DD	imagerel $LN138+24
	DD	imagerel $unwind$??$_Uninitialized_move@PEAUInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@QEAU123@0PEAU123@AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Uninitialized_move@PEAUInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@QEAU123@0PEAU123@AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z DD imagerel $LN138+24
	DD	imagerel $LN138+269
	DD	imagerel $chain$0$??$_Uninitialized_move@PEAUInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@QEAU123@0PEAU123@AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Uninitialized_move@PEAUInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@QEAU123@0PEAU123@AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z DD imagerel $LN138+269
	DD	imagerel $LN138+278
	DD	imagerel $chain$1$??$_Uninitialized_move@PEAUInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@QEAU123@0PEAU123@AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@0PEAU123@AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z DD imagerel $LN138
	DD	imagerel $LN138+20
	DD	imagerel $unwind$??$_Uninitialized_move@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@0PEAU123@AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Uninitialized_move@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@0PEAU123@AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z DD imagerel $LN138+20
	DD	imagerel $LN138+256
	DD	imagerel $chain$0$??$_Uninitialized_move@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@0PEAU123@AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Uninitialized_move@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@0PEAU123@AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z DD imagerel $LN138+256
	DD	imagerel $LN138+261
	DD	imagerel $chain$1$??$_Uninitialized_move@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@0PEAU123@AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@DU?$char_traits@D@std@@@1@U_Normal_conversion@01@@Z DD imagerel $LN47
	DD	imagerel $LN47+242
	DD	imagerel $unwind$??$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@DU?$char_traits@D@std@@@1@U_Normal_conversion@01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@DU?$char_traits@D@std@@@1@U_Normal_conversion@01@@Z@4HA DD imagerel ?dtor$1@?0???$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@DU?$char_traits@D@std@@@1@U_Normal_conversion@01@@Z@4HA
	DD	imagerel ?dtor$1@?0???$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@DU?$char_traits@D@std@@@1@U_Normal_conversion@01@@Z@4HA+38
	DD	imagerel $unwind$?dtor$1@?0???$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@DU?$char_traits@D@std@@@1@U_Normal_conversion@01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0U_Creator@_Dir_enum_impl@filesystem@std@@AEBW4directory_options@23@@?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAA@$$QEAU_Creator@_Dir_enum_impl@filesystem@1@AEBW4directory_options@41@@Z DD imagerel $LN33
	DD	imagerel $LN33+94
	DD	imagerel $unwind$??$?0U_Creator@_Dir_enum_impl@filesystem@std@@AEBW4directory_options@23@@?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAA@$$QEAU_Creator@_Dir_enum_impl@filesystem@1@AEBW4directory_options@41@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@U_Normal_conversion@01@@Z DD imagerel $LN62
	DD	imagerel $LN62+118
	DD	imagerel $unwind$??$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@U_Normal_conversion@01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@U_Normal_conversion@01@@Z DD imagerel $LN62+118
	DD	imagerel $LN62+212
	DD	imagerel $chain$0$??$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@U_Normal_conversion@01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@U_Normal_conversion@01@@Z DD imagerel $LN62+212
	DD	imagerel $LN62+218
	DD	imagerel $chain$1$??$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@U_Normal_conversion@01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@0@AEBV?$allocator@D@0@@Z DD imagerel $LN42
	DD	imagerel $LN42+219
	DD	imagerel $unwind$??$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@0@AEBV?$allocator@D@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@0@AEBV?$allocator@D@0@@Z@4HA DD imagerel ?dtor$0@?0???$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@0@AEBV?$allocator@D@0@@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@0@AEBV?$allocator@D@0@@Z@4HA+38
	DD	imagerel $unwind$?dtor$0@?0???$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@0@AEBV?$allocator@D@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_raw@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+54
	DD	imagerel $unwind$?_Buy_raw@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_raw@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+54
	DD	imagerel $unwind$?_Buy_raw@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@UEAAPEAXI@Z DD imagerel $LN8
	DD	imagerel $LN8+43
	DD	imagerel $unwind$??_G?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXQEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K1@Z DD imagerel $LN49
	DD	imagerel $LN49+31
	DD	imagerel $unwind$?_Change_array@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXQEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Change_array@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXQEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K1@Z DD imagerel $LN49+31
	DD	imagerel $LN49+115
	DD	imagerel $chain$0$?_Change_array@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXQEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Change_array@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXQEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K1@Z DD imagerel $LN49+115
	DD	imagerel $LN49+192
	DD	imagerel $chain$1$?_Change_array@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXQEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXQEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K1@Z DD imagerel $LN49
	DD	imagerel $LN49+31
	DD	imagerel $unwind$?_Change_array@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXQEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Change_array@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXQEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K1@Z DD imagerel $LN49+31
	DD	imagerel $LN49+115
	DD	imagerel $chain$0$?_Change_array@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXQEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Change_array@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXQEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K1@Z DD imagerel $LN49+115
	DD	imagerel $LN49+192
	DD	imagerel $chain$1$?_Change_array@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXQEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_K1@Z DD imagerel $LN30
	DD	imagerel $LN30+132
	DD	imagerel $unwind$?_Change_array@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@U_Find_file_handle@filesystem@std@@@std@@QEAAPEAU_Find_file_handle@filesystem@2@_K@Z DD imagerel $LN32
	DD	imagerel $LN32+112
	DD	imagerel $unwind$?allocate@?$allocator@U_Find_file_handle@filesystem@std@@@std@@QEAAPEAU_Find_file_handle@filesystem@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAXQEAU_Find_file_handle@filesystem@2@_K1@Z DD imagerel $LN49
	DD	imagerel $LN49+39
	DD	imagerel $unwind$?_Change_array@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAXQEAU_Find_file_handle@filesystem@2@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Change_array@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAXQEAU_Find_file_handle@filesystem@2@_K1@Z DD imagerel $LN49+39
	DD	imagerel $LN49+98
	DD	imagerel $chain$0$?_Change_array@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAXQEAU_Find_file_handle@filesystem@2@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Change_array@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAXQEAU_Find_file_handle@filesystem@2@_K1@Z DD imagerel $LN49+98
	DD	imagerel $LN49+173
	DD	imagerel $chain$1$?_Change_array@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAXQEAU_Find_file_handle@filesystem@2@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlength@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@QEAAPEAUNodeDef@AINBNodeDefMgr@@_K@Z DD imagerel $LN32
	DD	imagerel $LN32+111
	DD	imagerel $unwind$?allocate@?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@QEAAPEAUNodeDef@AINBNodeDefMgr@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUNodeDef@AINBNodeDefMgr@@_K1@Z DD imagerel $LN48
	DD	imagerel $LN48+46
	DD	imagerel $unwind$?_Change_array@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUNodeDef@AINBNodeDefMgr@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Change_array@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUNodeDef@AINBNodeDefMgr@@_K1@Z DD imagerel $LN48+46
	DD	imagerel $LN48+140
	DD	imagerel $chain$0$?_Change_array@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUNodeDef@AINBNodeDefMgr@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Change_array@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUNodeDef@AINBNodeDefMgr@@_K1@Z DD imagerel $LN48+140
	DD	imagerel $LN48+242
	DD	imagerel $chain$1$?_Change_array@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUNodeDef@AINBNodeDefMgr@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlength@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAXQEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z DD imagerel $LN23
	DD	imagerel $LN23+67
	DD	imagerel $unwind$?deallocate@?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAXQEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAPEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z DD imagerel $LN32
	DD	imagerel $LN32+112
	DD	imagerel $unwind$?allocate@?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAPEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Clear_and_reserve_geometric@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z DD imagerel $LN61
	DD	imagerel $LN61+29
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Clear_and_reserve_geometric@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z DD imagerel $LN61+29
	DD	imagerel $LN61+100
	DD	imagerel $chain$1$?_Clear_and_reserve_geometric@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Clear_and_reserve_geometric@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z DD imagerel $LN61+100
	DD	imagerel $LN61+174
	DD	imagerel $chain$2$?_Clear_and_reserve_geometric@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?_Clear_and_reserve_geometric@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z DD imagerel $LN61+174
	DD	imagerel $LN61+263
	DD	imagerel $chain$3$?_Clear_and_reserve_geometric@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?_Clear_and_reserve_geometric@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z DD imagerel $LN61+263
	DD	imagerel $LN61+270
	DD	imagerel $chain$5$?_Clear_and_reserve_geometric@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?_Clear_and_reserve_geometric@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z DD imagerel $LN61+270
	DD	imagerel $LN61+276
	DD	imagerel $chain$6$?_Clear_and_reserve_geometric@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUInputParam@NodeDef@AINBNodeDefMgr@@_K1@Z DD imagerel $LN47
	DD	imagerel $LN47+39
	DD	imagerel $unwind$?_Change_array@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUInputParam@NodeDef@AINBNodeDefMgr@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Change_array@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUInputParam@NodeDef@AINBNodeDefMgr@@_K1@Z DD imagerel $LN47+39
	DD	imagerel $LN47+123
	DD	imagerel $chain$0$?_Change_array@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUInputParam@NodeDef@AINBNodeDefMgr@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Change_array@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUInputParam@NodeDef@AINBNodeDefMgr@@_K1@Z DD imagerel $LN47+123
	DD	imagerel $LN47+212
	DD	imagerel $chain$1$?_Change_array@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUInputParam@NodeDef@AINBNodeDefMgr@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlength@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAXQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z DD imagerel $LN23
	DD	imagerel $LN23+67
	DD	imagerel $unwind$?deallocate@?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAXQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z DD imagerel $LN32
	DD	imagerel $LN32+112
	DD	imagerel $unwind$?allocate@?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Clear_and_reserve_geometric@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z DD imagerel $LN61
	DD	imagerel $LN61+30
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Clear_and_reserve_geometric@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z DD imagerel $LN61+30
	DD	imagerel $LN61+101
	DD	imagerel $chain$1$?_Clear_and_reserve_geometric@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Clear_and_reserve_geometric@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z DD imagerel $LN61+101
	DD	imagerel $LN61+172
	DD	imagerel $chain$2$?_Clear_and_reserve_geometric@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?_Clear_and_reserve_geometric@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z DD imagerel $LN61+172
	DD	imagerel $LN61+262
	DD	imagerel $chain$3$?_Clear_and_reserve_geometric@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?_Clear_and_reserve_geometric@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z DD imagerel $LN61+262
	DD	imagerel $LN61+269
	DD	imagerel $chain$5$?_Clear_and_reserve_geometric@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?_Clear_and_reserve_geometric@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z DD imagerel $LN61+269
	DD	imagerel $LN61+275
	DD	imagerel $chain$6$?_Clear_and_reserve_geometric@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K1@Z DD imagerel $LN47
	DD	imagerel $LN47+39
	DD	imagerel $unwind$?_Change_array@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Change_array@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K1@Z DD imagerel $LN47+39
	DD	imagerel $LN47+120
	DD	imagerel $chain$0$?_Change_array@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Change_array@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K1@Z DD imagerel $LN47+120
	DD	imagerel $LN47+209
	DD	imagerel $chain$1$?_Change_array@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlength@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Destroy@?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@EEAAXXZ DD imagerel $LN27
	DD	imagerel $LN27+41
	DD	imagerel $unwind$?_Destroy@?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@EEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ DD imagerel $LN22
	DD	imagerel $LN22+50
	DD	imagerel $unwind$??1?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ DD imagerel $LN22
	DD	imagerel $LN22+53
	DD	imagerel $unwind$??1?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Uninitialized_backout_al@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ DD imagerel $LN22
	DD	imagerel $LN22+53
	DD	imagerel $unwind$??1?$_Uninitialized_backout_al@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAA@XZ DD imagerel $LN24
	DD	imagerel $LN24+50
	DD	imagerel $unwind$??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAA@XZ DD imagerel $LN24
	DD	imagerel $LN24+50
	DD	imagerel $unwind$??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G_Find_file_handle@filesystem@std@@QEAAPEAXI@Z DD imagerel $LN8
	DD	imagerel $LN8+26
	DD	imagerel $unwind$??_G_Find_file_handle@filesystem@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Assign_counted_range@PEAUInputParam@NodeDef@AINBNodeDefMgr@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z DD imagerel $LN143
	DD	imagerel $LN143+59
	DD	imagerel $unwind$??$_Assign_counted_range@PEAUInputParam@NodeDef@AINBNodeDefMgr@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Assign_counted_range@PEAUInputParam@NodeDef@AINBNodeDefMgr@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z DD imagerel $LN143+59
	DD	imagerel $LN143+294
	DD	imagerel $chain$0$??$_Assign_counted_range@PEAUInputParam@NodeDef@AINBNodeDefMgr@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Assign_counted_range@PEAUInputParam@NodeDef@AINBNodeDefMgr@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z DD imagerel $LN143+294
	DD	imagerel $LN143+301
	DD	imagerel $chain$2$??$_Assign_counted_range@PEAUInputParam@NodeDef@AINBNodeDefMgr@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Assign_counted_range@PEAUInputParam@NodeDef@AINBNodeDefMgr@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z DD imagerel $LN143+301
	DD	imagerel $LN143+651
	DD	imagerel $chain$3$??$_Assign_counted_range@PEAUInputParam@NodeDef@AINBNodeDefMgr@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Assign_counted_range@PEAUInputParam@NodeDef@AINBNodeDefMgr@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z DD imagerel $LN143+651
	DD	imagerel $LN143+657
	DD	imagerel $chain$4$??$_Assign_counted_range@PEAUInputParam@NodeDef@AINBNodeDefMgr@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Assign_counted_range@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z DD imagerel $LN131
	DD	imagerel $LN131+59
	DD	imagerel $unwind$??$_Assign_counted_range@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Assign_counted_range@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z DD imagerel $LN131+59
	DD	imagerel $LN131+291
	DD	imagerel $chain$0$??$_Assign_counted_range@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Assign_counted_range@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z DD imagerel $LN131+291
	DD	imagerel $LN131+298
	DD	imagerel $chain$2$??$_Assign_counted_range@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Assign_counted_range@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z DD imagerel $LN131+298
	DD	imagerel $LN131+581
	DD	imagerel $chain$3$??$_Assign_counted_range@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Assign_counted_range@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z DD imagerel $LN131+581
	DD	imagerel $LN131+587
	DD	imagerel $chain$4$??$_Assign_counted_range@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@$$QEAV21@@Z DD imagerel $LN65
	DD	imagerel $LN65+74
	DD	imagerel $unwind$??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@$$QEAV21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@$$QEAV21@@Z DD imagerel $LN65+74
	DD	imagerel $LN65+264
	DD	imagerel $chain$0$??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@$$QEAV21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@$$QEAV21@@Z DD imagerel $LN65+264
	DD	imagerel $LN65+270
	DD	imagerel $chain$1$??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@$$QEAV21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_n_unchecked4@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@_KPEAV12@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0@Z DD imagerel $LN18
	DD	imagerel $LN18+29
	DD	imagerel $unwind$??$_Copy_n_unchecked4@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@_KPEAV12@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Copy_n_unchecked4@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@_KPEAV12@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0@Z DD imagerel $LN18+29
	DD	imagerel $LN18+98
	DD	imagerel $chain$0$??$_Copy_n_unchecked4@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@_KPEAV12@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Copy_n_unchecked4@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@_KPEAV12@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0@Z DD imagerel $LN18+98
	DD	imagerel $LN18+117
	DD	imagerel $chain$1$??$_Copy_n_unchecked4@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@_KPEAV12@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy_n@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z DD imagerel $LN117
	DD	imagerel $LN117+402
	DD	imagerel $unwind$??$_Uninitialized_copy_n@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN169
	DD	imagerel $LN169+395
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_n_unchecked4@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@_KPEAV12@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0@Z DD imagerel $LN18
	DD	imagerel $LN18+29
	DD	imagerel $unwind$??$_Copy_n_unchecked4@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@_KPEAV12@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Copy_n_unchecked4@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@_KPEAV12@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0@Z DD imagerel $LN18+29
	DD	imagerel $LN18+98
	DD	imagerel $chain$0$??$_Copy_n_unchecked4@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@_KPEAV12@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Copy_n_unchecked4@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@_KPEAV12@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0@Z DD imagerel $LN18+98
	DD	imagerel $LN18+117
	DD	imagerel $chain$1$??$_Copy_n_unchecked4@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@_KPEAV12@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy_n@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z DD imagerel $LN112
	DD	imagerel $LN112+353
	DD	imagerel $unwind$??$_Uninitialized_copy_n@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN169
	DD	imagerel $LN169+395
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@QEAW4234@$$QEAW4234@@Z DD imagerel $LN118
	DD	imagerel $LN118+63
	DD	imagerel $unwind$??$_Emplace_reallocate@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@QEAW4234@$$QEAW4234@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Emplace_reallocate@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@QEAW4234@$$QEAW4234@@Z DD imagerel $LN118+63
	DD	imagerel $LN118+296
	DD	imagerel $chain$1$??$_Emplace_reallocate@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@QEAW4234@$$QEAW4234@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Emplace_reallocate@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@QEAW4234@$$QEAW4234@@Z DD imagerel $LN118+296
	DD	imagerel $LN118+302
	DD	imagerel $chain$2$??$_Emplace_reallocate@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@QEAW4234@$$QEAW4234@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Emplace_reallocate@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@QEAW4234@$$QEAW4234@@Z DD imagerel $LN118+302
	DD	imagerel $LN118+308
	DD	imagerel $chain$3$??$_Emplace_reallocate@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@QEAW4234@$$QEAW4234@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_n_unchecked4@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_KPEAW4123@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@_K0@Z DD imagerel $LN16
	DD	imagerel $LN16+45
	DD	imagerel $unwind$??$_Copy_n_unchecked4@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_KPEAW4123@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove_n@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@_K0@Z DD imagerel $LN6
	DD	imagerel $LN6+45
	DD	imagerel $unwind$??$_Copy_memmove_n@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy_n@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@_K0AEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@0@@Z DD imagerel $LN25
	DD	imagerel $LN25+45
	DD	imagerel $unwind$??$_Uninitialized_copy_n@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@_K0AEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@U_Find_file_handle@filesystem@std@@@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAPEAU_Find_file_handle@filesystem@1@QEAU231@$$QEAU231@@Z DD imagerel $LN255
	DD	imagerel $LN255+69
	DD	imagerel $unwind$??$_Emplace_reallocate@U_Find_file_handle@filesystem@std@@@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAPEAU_Find_file_handle@filesystem@1@QEAU231@$$QEAU231@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Emplace_reallocate@U_Find_file_handle@filesystem@std@@@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAPEAU_Find_file_handle@filesystem@1@QEAU231@$$QEAU231@@Z DD imagerel $LN255+69
	DD	imagerel $LN255+500
	DD	imagerel $chain$2$??$_Emplace_reallocate@U_Find_file_handle@filesystem@std@@@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAPEAU_Find_file_handle@filesystem@1@QEAU231@$$QEAU231@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Emplace_reallocate@U_Find_file_handle@filesystem@std@@@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAPEAU_Find_file_handle@filesystem@1@QEAU231@$$QEAU231@@Z DD imagerel $LN255+500
	DD	imagerel $LN255+507
	DD	imagerel $chain$4$??$_Emplace_reallocate@U_Find_file_handle@filesystem@std@@@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAPEAU_Find_file_handle@filesystem@1@QEAU231@$$QEAU231@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$_Emplace_reallocate@U_Find_file_handle@filesystem@std@@@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAPEAU_Find_file_handle@filesystem@1@QEAU231@$$QEAU231@@Z DD imagerel $LN255+507
	DD	imagerel $LN255+513
	DD	imagerel $chain$5$??$_Emplace_reallocate@U_Find_file_handle@filesystem@std@@@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAPEAU_Find_file_handle@filesystem@1@QEAU231@$$QEAU231@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$??$_Emplace_reallocate@U_Find_file_handle@filesystem@std@@@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAPEAU_Find_file_handle@filesystem@1@QEAU231@$$QEAU231@@Z DD imagerel $LN255+513
	DD	imagerel $LN255+519
	DD	imagerel $chain$6$??$_Emplace_reallocate@U_Find_file_handle@filesystem@std@@@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAPEAU_Find_file_handle@filesystem@1@QEAU231@$$QEAU231@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_value_construct_n@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUNodeDef@AINBNodeDefMgr@@PEAU12@_KAEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@0@@Z DD imagerel $LN45
	DD	imagerel $LN45+83
	DD	imagerel $unwind$??$_Uninitialized_value_construct_n@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUNodeDef@AINBNodeDefMgr@@PEAU12@_KAEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN101
	DD	imagerel $LN101+56
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN101+56
	DD	imagerel $LN101+74
	DD	imagerel $chain$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN101+74
	DD	imagerel $LN101+176
	DD	imagerel $chain$3$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN101+176
	DD	imagerel $LN101+305
	DD	imagerel $chain$4$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN101+305
	DD	imagerel $LN101+311
	DD	imagerel $chain$5$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN21
	DD	imagerel $LN21+50
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN21+50
	DD	imagerel $LN21+208
	DD	imagerel $chain$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN21+208
	DD	imagerel $LN21+214
	DD	imagerel $chain$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_range@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAXPEAUInputParam@NodeDef@AINBNodeDefMgr@@QEAU123@AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z DD imagerel $LN21
	DD	imagerel $LN21+52
	DD	imagerel $unwind$??$_Destroy_range@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAXPEAUInputParam@NodeDef@AINBNodeDefMgr@@QEAU123@AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN21
	DD	imagerel $LN21+40
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN21+40
	DD	imagerel $LN21+205
	DD	imagerel $chain$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN21+205
	DD	imagerel $LN21+211
	DD	imagerel $chain$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN21
	DD	imagerel $LN21+50
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN21+50
	DD	imagerel $LN21+208
	DD	imagerel $chain$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN21+208
	DD	imagerel $LN21+214
	DD	imagerel $chain$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_range@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAXPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z DD imagerel $LN21
	DD	imagerel $LN21+49
	DD	imagerel $unwind$??$_Destroy_range@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAXPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Convert_Source_to_wide@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@U_Normal_conversion@01@@Z DD imagerel $LN63
	DD	imagerel $LN63+234
	DD	imagerel $unwind$??$_Convert_Source_to_wide@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@U_Normal_conversion@01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0???$_Convert_Source_to_wide@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@U_Normal_conversion@01@@Z@4HA DD imagerel ?dtor$2@?0???$_Convert_Source_to_wide@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@U_Normal_conversion@01@@Z@4HA
	DD	imagerel ?dtor$2@?0???$_Convert_Source_to_wide@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@U_Normal_conversion@01@@Z@4HA+38
	DD	imagerel $unwind$?dtor$2@?0???$_Convert_Source_to_wide@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@U_Normal_conversion@01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$make_shared@U_Recursive_dir_enum_impl@filesystem@std@@U_Creator@_Dir_enum_impl@23@AEBW4directory_options@23@@std@@YA?AV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@0@$$QEAU_Creator@_Dir_enum_impl@filesystem@0@AEBW4directory_options@40@@Z DD imagerel $LN48
	DD	imagerel $LN48+164
	DD	imagerel $unwind$??$make_shared@U_Recursive_dir_enum_impl@filesystem@std@@U_Creator@_Dir_enum_impl@23@AEBW4directory_options@23@@std@@YA?AV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@0@$$QEAU_Creator@_Dir_enum_impl@filesystem@0@AEBW4directory_options@40@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$make_shared@U_Recursive_dir_enum_impl@filesystem@std@@U_Creator@_Dir_enum_impl@23@AEBW4directory_options@23@@std@@YA?AV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@0@$$QEAU_Creator@_Dir_enum_impl@filesystem@0@AEBW4directory_options@40@@Z@4HA DD imagerel ?dtor$0@?0???$make_shared@U_Recursive_dir_enum_impl@filesystem@std@@U_Creator@_Dir_enum_impl@23@AEBW4directory_options@23@@std@@YA?AV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@0@$$QEAU_Creator@_Dir_enum_impl@filesystem@0@AEBW4directory_options@40@@Z@4HA
	DD	imagerel ?dtor$0@?0???$make_shared@U_Recursive_dir_enum_impl@filesystem@std@@U_Creator@_Dir_enum_impl@23@AEBW4directory_options@23@@std@@YA?AV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@0@$$QEAU_Creator@_Dir_enum_impl@filesystem@0@AEBW4directory_options@40@@Z@4HA+29
	DD	imagerel $unwind$?dtor$0@?0???$make_shared@U_Recursive_dir_enum_impl@filesystem@std@@U_Creator@_Dir_enum_impl@23@AEBW4directory_options@23@@std@@YA?AV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@0@$$QEAU_Creator@_Dir_enum_impl@filesystem@0@AEBW4directory_options@40@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Convert_Source_to_wide@V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@1@U_Normal_conversion@01@@Z DD imagerel $LN71
	DD	imagerel $LN71+112
	DD	imagerel $unwind$??$_Convert_Source_to_wide@V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@1@U_Normal_conversion@01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Convert_Source_to_wide@V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@1@U_Normal_conversion@01@@Z DD imagerel $LN71+112
	DD	imagerel $LN71+191
	DD	imagerel $chain$0$??$_Convert_Source_to_wide@V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@1@U_Normal_conversion@01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Convert_Source_to_wide@V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@1@U_Normal_conversion@01@@Z DD imagerel $LN71+191
	DD	imagerel $LN71+220
	DD	imagerel $chain$1$??$_Convert_Source_to_wide@V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@1@U_Normal_conversion@01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Convert_wide_to@U?$char_traits@D@std@@V?$allocator@D@2@D@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z DD imagerel $LN47
	DD	imagerel $LN47+242
	DD	imagerel $unwind$??$_Convert_wide_to@U?$char_traits@D@std@@V?$allocator@D@2@D@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???$_Convert_wide_to@U?$char_traits@D@std@@V?$allocator@D@2@D@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z@4HA DD imagerel ?dtor$1@?0???$_Convert_wide_to@U?$char_traits@D@std@@V?$allocator@D@2@D@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z@4HA
	DD	imagerel ?dtor$1@?0???$_Convert_wide_to@U?$char_traits@D@std@@V?$allocator@D@2@D@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z@4HA+38
	DD	imagerel $unwind$?dtor$1@?0???$_Convert_wide_to@U?$char_traits@D@std@@V?$allocator@D@2@D@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K@Z DD imagerel $LN32
	DD	imagerel $LN32+116
	DD	imagerel $unwind$?allocate@?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K@Z DD imagerel $LN32
	DD	imagerel $LN32+116
	DD	imagerel $unwind$?allocate@?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@QEAAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_K@Z DD imagerel $LN28
	DD	imagerel $LN28+89
	DD	imagerel $unwind$?allocate@?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@QEAAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_raw@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+51
	DD	imagerel $unwind$?_Buy_raw@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlength@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_raw@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+51
	DD	imagerel $unwind$?_Buy_raw@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlength@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_raw@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z DD imagerel $LN35
	DD	imagerel $LN35+116
	DD	imagerel $unwind$?_Buy_raw@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlength@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z DD imagerel $LN32
	DD	imagerel $LN32+108
	DD	imagerel $unwind$?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Clear_and_reserve_geometric@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z DD imagerel $LN63
	DD	imagerel $LN63+30
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Clear_and_reserve_geometric@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z DD imagerel $LN63+30
	DD	imagerel $LN63+101
	DD	imagerel $chain$1$?_Clear_and_reserve_geometric@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Clear_and_reserve_geometric@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z DD imagerel $LN63+101
	DD	imagerel $LN63+172
	DD	imagerel $chain$2$?_Clear_and_reserve_geometric@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?_Clear_and_reserve_geometric@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z DD imagerel $LN63+172
	DD	imagerel $LN63+259
	DD	imagerel $chain$3$?_Clear_and_reserve_geometric@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?_Clear_and_reserve_geometric@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z DD imagerel $LN63+259
	DD	imagerel $LN63+266
	DD	imagerel $chain$5$?_Clear_and_reserve_geometric@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?_Clear_and_reserve_geometric@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z DD imagerel $LN63+266
	DD	imagerel $LN63+272
	DD	imagerel $chain$6$?_Clear_and_reserve_geometric@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Clear_and_reserve_geometric@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z DD imagerel $LN63
	DD	imagerel $LN63+30
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Clear_and_reserve_geometric@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z DD imagerel $LN63+30
	DD	imagerel $LN63+101
	DD	imagerel $chain$1$?_Clear_and_reserve_geometric@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Clear_and_reserve_geometric@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z DD imagerel $LN63+101
	DD	imagerel $LN63+172
	DD	imagerel $chain$2$?_Clear_and_reserve_geometric@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?_Clear_and_reserve_geometric@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z DD imagerel $LN63+172
	DD	imagerel $LN63+259
	DD	imagerel $chain$3$?_Clear_and_reserve_geometric@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?_Clear_and_reserve_geometric@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z DD imagerel $LN63+259
	DD	imagerel $LN63+266
	DD	imagerel $chain$5$?_Clear_and_reserve_geometric@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?_Clear_and_reserve_geometric@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z DD imagerel $LN63+266
	DD	imagerel $LN63+272
	DD	imagerel $chain$6$?_Clear_and_reserve_geometric@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Clear_and_reserve_geometric@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z DD imagerel $LN40
	DD	imagerel $LN40+159
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN37
	DD	imagerel $LN37+45
	DD	imagerel $unwind$??4?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??4?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN37+45
	DD	imagerel $LN37+113
	DD	imagerel $chain$0$??4?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??4?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN37+113
	DD	imagerel $LN37+127
	DD	imagerel $chain$1$??4?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN7
	DD	imagerel $LN7+59
	DD	imagerel $unwind$??4?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN7
	DD	imagerel $LN7+59
	DD	imagerel $unwind$??4?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Creator@_Dir_enum_impl@filesystem@std@@QEAA@XZ DD imagerel $LN13
	DD	imagerel $LN13+31
	DD	imagerel $unwind$??1_Creator@_Dir_enum_impl@filesystem@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KD@Z@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@0D@Z@_KD@Z DD imagerel $LN151
	DD	imagerel $LN151+46
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KD@Z@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@0D@Z@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KD@Z@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@0D@Z@_KD@Z DD imagerel $LN151+46
	DD	imagerel $LN151+379
	DD	imagerel $chain$3$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KD@Z@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@0D@Z@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KD@Z@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@0D@Z@_KD@Z DD imagerel $LN151+379
	DD	imagerel $LN151+385
	DD	imagerel $chain$5$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KD@Z@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@0D@Z@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KD@Z@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@0D@Z@_KD@Z DD imagerel $LN151+385
	DD	imagerel $LN151+391
	DD	imagerel $chain$6$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KD@Z@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@0D@Z@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@_K_W@Z@_K_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@0_W@Z@_K_W@Z DD imagerel $LN141
	DD	imagerel $LN141+47
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@_K_W@Z@_K_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@0_W@Z@_K_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@_K_W@Z@_K_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@0_W@Z@_K_W@Z DD imagerel $LN141+47
	DD	imagerel $LN141+313
	DD	imagerel $chain$2$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@_K_W@Z@_K_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@0_W@Z@_K_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@_K_W@Z@_K_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@0_W@Z@_K_W@Z DD imagerel $LN141+313
	DD	imagerel $LN141+319
	DD	imagerel $chain$3$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@_K_W@Z@_K_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@0_W@Z@_K_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEB_W0@Z@PEB_W@Z DD imagerel $LN60
	DD	imagerel $LN60+43
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEB_W0@Z@PEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEB_W0@Z@PEB_W@Z DD imagerel $LN60+43
	DD	imagerel $LN60+219
	DD	imagerel $chain$1$??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEB_W0@Z@PEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEB_W0@Z@PEB_W@Z DD imagerel $LN60+219
	DD	imagerel $LN60+226
	DD	imagerel $chain$3$??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEB_W0@Z@PEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEB_W0@Z@PEB_W@Z DD imagerel $LN60+226
	DD	imagerel $LN60+232
	DD	imagerel $chain$4$??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEB_W0@Z@PEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_range@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YAXPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z DD imagerel $LN23
	DD	imagerel $LN23+49
	DD	imagerel $unwind$??$_Destroy_range@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YAXPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_range@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YAXPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z DD imagerel $LN23
	DD	imagerel $LN23+49
	DD	imagerel $unwind$??$_Destroy_range@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YAXPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_range@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@@std@@YAXPEAU_Find_file_handle@filesystem@0@QEAU120@AEAV?$allocator@U_Find_file_handle@filesystem@std@@@0@@Z DD imagerel $LN23
	DD	imagerel $LN23+49
	DD	imagerel $unwind$??$_Destroy_range@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@@std@@YAXPEAU_Find_file_handle@filesystem@0@QEAU120@AEAV?$allocator@U_Find_file_handle@filesystem@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_range@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@YAXPEAUNodeDef@AINBNodeDefMgr@@QEAU12@AEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@0@@Z DD imagerel $LN21
	DD	imagerel $LN21+52
	DD	imagerel $unwind$??$_Destroy_range@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@YAXPEAUNodeDef@AINBNodeDefMgr@@QEAU12@AEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??reserve@01@QEAAX0@Z@@Z DD imagerel $LN104
	DD	imagerel $LN104+41
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??reserve@01@QEAAX0@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Reallocate_grow_by@V<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??reserve@01@QEAAX0@Z@@Z DD imagerel $LN104+41
	DD	imagerel $LN104+315
	DD	imagerel $chain$2$??$_Reallocate_grow_by@V<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??reserve@01@QEAAX0@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Reallocate_grow_by@V<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??reserve@01@QEAAX0@Z@@Z DD imagerel $LN104+315
	DD	imagerel $LN104+321
	DD	imagerel $chain$4$??$_Reallocate_grow_by@V<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??reserve@01@QEAAX0@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$_Reallocate_grow_by@V<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??reserve@01@QEAAX0@Z@@Z DD imagerel $LN104+321
	DD	imagerel $LN104+327
	DD	imagerel $chain$5$??$_Reallocate_grow_by@V<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??reserve@01@QEAAX0@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct@$01PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z DD imagerel $LN49
	DD	imagerel $LN49+157
	DD	imagerel $unwind$??$_Construct@$01PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z DD imagerel $LN44
	DD	imagerel $LN44+87
	DD	imagerel $unwind$??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z DD imagerel $LN44+87
	DD	imagerel $LN44+177
	DD	imagerel $chain$0$??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z DD imagerel $LN44+177
	DD	imagerel $LN44+183
	DD	imagerel $chain$1$??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEB_W0@Z@PEB_W_K@Z DD imagerel $LN100
	DD	imagerel $LN100+58
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEB_W0@Z@PEB_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEB_W0@Z@PEB_W_K@Z DD imagerel $LN100+58
	DD	imagerel $LN100+339
	DD	imagerel $chain$3$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEB_W0@Z@PEB_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEB_W0@Z@PEB_W_K@Z DD imagerel $LN100+339
	DD	imagerel $LN100+345
	DD	imagerel $chain$4$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEB_W0@Z@PEB_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z@_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAX_W@Z@_W@Z DD imagerel $LN74
	DD	imagerel $LN74+48
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z@_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAX_W@Z@_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z@_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAX_W@Z@_W@Z DD imagerel $LN74+48
	DD	imagerel $LN74+62
	DD	imagerel $chain$1$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z@_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAX_W@Z@_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z@_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAX_W@Z@_W@Z DD imagerel $LN74+62
	DD	imagerel $LN74+154
	DD	imagerel $chain$2$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z@_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAX_W@Z@_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z@_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAX_W@Z@_W@Z DD imagerel $LN74+154
	DD	imagerel $LN74+284
	DD	imagerel $chain$3$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z@_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAX_W@Z@_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z@_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAX_W@Z@_W@Z DD imagerel $LN74+284
	DD	imagerel $LN74+290
	DD	imagerel $chain$4$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z@_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAX_W@Z@_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_n@$$V@?$vector@IV?$allocator@I@std@@@std@@AEAAX_K@Z DD imagerel $LN45
	DD	imagerel $LN45+36
	DD	imagerel $unwind$??$_Construct_n@$$V@?$vector@IV?$allocator@I@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Construct_n@$$V@?$vector@IV?$allocator@I@std@@@std@@AEAAX_K@Z DD imagerel $LN45+36
	DD	imagerel $LN45+104
	DD	imagerel $chain$0$??$_Construct_n@$$V@?$vector@IV?$allocator@I@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Construct_n@$$V@?$vector@IV?$allocator@I@std@@@std@@AEAAX_K@Z DD imagerel $LN45+104
	DD	imagerel $LN45+111
	DD	imagerel $chain$1$??$_Construct_n@$$V@?$vector@IV?$allocator@I@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Assign_counted_range@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@_K@Z DD imagerel $LN116
	DD	imagerel $LN116+59
	DD	imagerel $unwind$??$_Assign_counted_range@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Assign_counted_range@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@_K@Z DD imagerel $LN116+59
	DD	imagerel $LN116+288
	DD	imagerel $chain$0$??$_Assign_counted_range@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Assign_counted_range@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@_K@Z DD imagerel $LN116+288
	DD	imagerel $LN116+295
	DD	imagerel $chain$2$??$_Assign_counted_range@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Assign_counted_range@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@_K@Z DD imagerel $LN116+295
	DD	imagerel $LN116+514
	DD	imagerel $chain$3$??$_Assign_counted_range@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Assign_counted_range@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@_K@Z DD imagerel $LN116+514
	DD	imagerel $LN116+520
	DD	imagerel $chain$4$??$_Assign_counted_range@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN79
	DD	imagerel $LN79+50
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN79+50
	DD	imagerel $LN79+122
	DD	imagerel $chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN79+122
	DD	imagerel $LN79+212
	DD	imagerel $chain$2$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Assign_counted_range@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@_K@Z DD imagerel $LN117
	DD	imagerel $LN117+554
	DD	imagerel $unwind$??$_Assign_counted_range@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN79
	DD	imagerel $LN79+50
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN79+50
	DD	imagerel $LN79+122
	DD	imagerel $chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN79+122
	DD	imagerel $LN79+212
	DD	imagerel $chain$2$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Assign_counted_range@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_K@Z DD imagerel $LN120
	DD	imagerel $LN120+194
	DD	imagerel $unwind$??$_Assign_counted_range@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Assign_counted_range@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_K@Z DD imagerel $LN120+194
	DD	imagerel $LN120+267
	DD	imagerel $chain$0$??$_Assign_counted_range@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Assign_counted_range@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_K@Z DD imagerel $LN120+267
	DD	imagerel $LN120+295
	DD	imagerel $chain$2$??$_Assign_counted_range@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Assign_counted_range@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_K@Z DD imagerel $LN120+295
	DD	imagerel $LN120+301
	DD	imagerel $chain$3$??$_Assign_counted_range@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize@U_Value_init_tag@std@@@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN28
	DD	imagerel $LN28+49
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Resize@U_Value_init_tag@std@@@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN28+49
	DD	imagerel $LN28+123
	DD	imagerel $chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Resize@U_Value_init_tag@std@@@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN28+123
	DD	imagerel $LN28+182
	DD	imagerel $chain$2$??$_Resize@U_Value_init_tag@std@@@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize@U_Value_init_tag@std@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN28
	DD	imagerel $LN28+50
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Resize@U_Value_init_tag@std@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN28+50
	DD	imagerel $LN28+126
	DD	imagerel $chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Resize@U_Value_init_tag@std@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN28+126
	DD	imagerel $LN28+194
	DD	imagerel $chain$2$??$_Resize@U_Value_init_tag@std@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize@U_Value_init_tag@std@@@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN37
	DD	imagerel $LN37+49
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Resize@U_Value_init_tag@std@@@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN37+49
	DD	imagerel $LN37+131
	DD	imagerel $chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Resize@U_Value_init_tag@std@@@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN37+131
	DD	imagerel $LN37+197
	DD	imagerel $chain$2$??$_Resize@U_Value_init_tag@std@@@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize@U_Value_init_tag@std@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN28
	DD	imagerel $LN28+50
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Resize@U_Value_init_tag@std@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN28+50
	DD	imagerel $LN28+123
	DD	imagerel $chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Resize@U_Value_init_tag@std@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN28+123
	DD	imagerel $LN28+191
	DD	imagerel $chain$2$??$_Resize@U_Value_init_tag@std@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@W4format@012@@Z DD imagerel $LN67
	DD	imagerel $LN67+239
	DD	imagerel $unwind$??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@W4format@012@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$3@?0???$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@W4format@012@@Z@4HA DD imagerel ?dtor$3@?0???$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@W4format@012@@Z@4HA
	DD	imagerel ?dtor$3@?0???$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@W4format@012@@Z@4HA+38
	DD	imagerel $unwind$?dtor$3@?0???$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@W4format@012@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Initialize_dir_enum@U_Recursive_dir_enum_impl@filesystem@std@@@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@2@AEBVpath@12@W4directory_options@12@@Z DD imagerel $LN115
	DD	imagerel $LN115+368
	DD	imagerel $unwind$??$_Initialize_dir_enum@U_Recursive_dir_enum_impl@filesystem@std@@@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@2@AEBVpath@12@W4directory_options@12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$4@?0???$_Initialize_dir_enum@U_Recursive_dir_enum_impl@filesystem@std@@@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@2@AEBVpath@12@W4directory_options@12@@Z@4HA DD imagerel ?dtor$4@?0???$_Initialize_dir_enum@U_Recursive_dir_enum_impl@filesystem@std@@@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@2@AEBVpath@12@W4directory_options@12@@Z@4HA
	DD	imagerel ?dtor$4@?0???$_Initialize_dir_enum@U_Recursive_dir_enum_impl@filesystem@std@@@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@2@AEBVpath@12@W4directory_options@12@@Z@4HA+29
	DD	imagerel $unwind$?dtor$4@?0???$_Initialize_dir_enum@U_Recursive_dir_enum_impl@filesystem@std@@@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@2@AEBVpath@12@W4directory_options@12@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Convert_wide_to_narrow_replace_chars@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z DD imagerel $LN42
	DD	imagerel $LN42+219
	DD	imagerel $unwind$??$_Convert_wide_to_narrow_replace_chars@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Convert_wide_to_narrow_replace_chars@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z@4HA DD imagerel ?dtor$0@?0???$_Convert_wide_to_narrow_replace_chars@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Convert_wide_to_narrow_replace_chars@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z@4HA+38
	DD	imagerel $unwind$?dtor$0@?0???$_Convert_wide_to_narrow_replace_chars@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?_0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@path@filesystem@std@@QEAAAEAV012@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@2@@Z DD imagerel $LN12
	DD	imagerel $LN12+53
	DD	imagerel $unwind$??$?_0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@path@filesystem@std@@QEAAAEAV012@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@2@W4format@012@@Z DD imagerel $LN75
	DD	imagerel $LN75+112
	DD	imagerel $unwind$??$?0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@2@W4format@012@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$?0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@2@W4format@012@@Z DD imagerel $LN75+112
	DD	imagerel $LN75+191
	DD	imagerel $chain$0$??$?0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@2@W4format@012@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$?0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@2@W4format@012@@Z DD imagerel $LN75+191
	DD	imagerel $LN75+220
	DD	imagerel $chain$1$??$?0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@2@W4format@012@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV?$allocator@D@2@@Z DD imagerel $LN61
	DD	imagerel $LN61+234
	DD	imagerel $unwind$??$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV?$allocator@D@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0???$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV?$allocator@D@2@@Z@4HA DD imagerel ?dtor$2@?0???$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV?$allocator@D@2@@Z@4HA
	DD	imagerel ?dtor$2@?0???$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV?$allocator@D@2@@Z@4HA+38
	DD	imagerel $unwind$?dtor$2@?0???$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV?$allocator@D@2@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$_Char_traits@_WG@std@@SAPEA_WQEA_W_K_W@Z DD imagerel $LN25
	DD	imagerel $LN25+12
	DD	imagerel $unwind$?assign@?$_Char_traits@_WG@std@@SAPEA_WQEA_W_K_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?assign@?$_Char_traits@_WG@std@@SAPEA_WQEA_W_K_W@Z DD imagerel $LN25+12
	DD	imagerel $LN25+34
	DD	imagerel $chain$0$?assign@?$_Char_traits@_WG@std@@SAPEA_WQEA_W_K_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?assign@?$_Char_traits@_WG@std@@SAPEA_WQEA_W_K_W@Z DD imagerel $LN25+34
	DD	imagerel $LN25+42
	DD	imagerel $chain$1$?assign@?$_Char_traits@_WG@std@@SAPEA_WQEA_W_K_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$_WChar_traits@_W@std@@SAPEA_WQEA_W_K_W@Z DD imagerel $LN37
	DD	imagerel $LN37+12
	DD	imagerel $unwind$?assign@?$_WChar_traits@_W@std@@SAPEA_WQEA_W_K_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?assign@?$_WChar_traits@_W@std@@SAPEA_WQEA_W_K_W@Z DD imagerel $LN37+12
	DD	imagerel $LN37+34
	DD	imagerel $chain$0$?assign@?$_WChar_traits@_W@std@@SAPEA_WQEA_W_K_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?assign@?$_WChar_traits@_W@std@@SAPEA_WQEA_W_K_W@Z DD imagerel $LN37+34
	DD	imagerel $LN37+42
	DD	imagerel $chain$1$?assign@?$_WChar_traits@_W@std@@SAPEA_WQEA_W_K_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z DD imagerel $LN23
	DD	imagerel $LN23+63
	DD	imagerel $unwind$?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAAXQEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K@Z DD imagerel $LN23
	DD	imagerel $LN23+67
	DD	imagerel $unwind$?deallocate@?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAAXQEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAAXQEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K@Z DD imagerel $LN23
	DD	imagerel $LN23+67
	DD	imagerel $unwind$?deallocate@?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAAXQEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@QEAAXQEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_K@Z DD imagerel $LN23
	DD	imagerel $LN23+62
	DD	imagerel $unwind$?deallocate@?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@QEAAXQEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@U_Find_file_handle@filesystem@std@@@std@@QEAAXQEAU_Find_file_handle@filesystem@2@_K@Z DD imagerel $LN23
	DD	imagerel $LN23+67
	DD	imagerel $unwind$?deallocate@?$allocator@U_Find_file_handle@filesystem@std@@@std@@QEAAXQEAU_Find_file_handle@filesystem@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@QEAAXQEAUNodeDef@AINBNodeDefMgr@@_K@Z DD imagerel $LN23
	DD	imagerel $LN23+66
	DD	imagerel $unwind$?deallocate@?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@QEAAXQEAUNodeDef@AINBNodeDefMgr@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?copy@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z DD imagerel $LN15
	DD	imagerel $LN15+26
	DD	imagerel $unwind$?copy@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?move@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z DD imagerel $LN33
	DD	imagerel $LN33+26
	DD	imagerel $unwind$?move@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@_KD@Z@QEBA@QEADQEBD00D@Z DD imagerel $LN40
	DD	imagerel $LN40+66
	DD	imagerel $unwind$??R<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@_KD@Z@QEBA@QEADQEBD00D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD imagerel $LN36
	DD	imagerel $LN36+33
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD imagerel $LN36+33
	DD	imagerel $LN36+96
	DD	imagerel $chain$0$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD imagerel $LN36+96
	DD	imagerel $LN36+115
	DD	imagerel $chain$1$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z DD imagerel $LN50
	DD	imagerel $LN50+43
	DD	imagerel $unwind$?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z DD imagerel $LN50+43
	DD	imagerel $LN50+118
	DD	imagerel $chain$1$?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z DD imagerel $LN50+118
	DD	imagerel $LN50+139
	DD	imagerel $chain$3$?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Check_offset@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAX_K@Z DD imagerel $LN7
	DD	imagerel $LN7+21
	DD	imagerel $unwind$?_Check_offset@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV23@_K_W@Z@QEBA@QEA_WQEB_W001@Z DD imagerel $LN50
	DD	imagerel $LN50+86
	DD	imagerel $unwind$??R<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV23@_K_W@Z@QEBA@QEA_WQEB_W001@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@_K_W@Z DD imagerel $LN46
	DD	imagerel $LN46+101
	DD	imagerel $unwind$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@_K_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_1>@?1??assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV23@QEB_W_K@Z@QEBA@QEA_W10@Z DD imagerel $LN17
	DD	imagerel $LN17+48
	DD	imagerel $unwind$??R<lambda_1>@?1??assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV23@QEB_W_K@Z@QEBA@QEA_W10@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z DD imagerel $LN100
	DD	imagerel $LN100+273
	DD	imagerel $unwind$?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ DD imagerel $LN32
	DD	imagerel $LN32+98
	DD	imagerel $unwind$?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXXZ DD imagerel $LN49
	DD	imagerel $LN49+21
	DD	imagerel $unwind$?_Tidy@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Tidy@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXXZ DD imagerel $LN49+21
	DD	imagerel $LN49+102
	DD	imagerel $chain$0$?_Tidy@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Tidy@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXXZ DD imagerel $LN49+102
	DD	imagerel $LN49+162
	DD	imagerel $chain$1$?_Tidy@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXXZ DD imagerel $LN49
	DD	imagerel $LN49+21
	DD	imagerel $unwind$?_Tidy@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Tidy@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXXZ DD imagerel $LN49+21
	DD	imagerel $LN49+102
	DD	imagerel $chain$0$?_Tidy@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Tidy@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXXZ DD imagerel $LN49+102
	DD	imagerel $LN49+162
	DD	imagerel $chain$1$?_Tidy@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ DD imagerel $LN30
	DD	imagerel $LN30+88
	DD	imagerel $unwind$?_Tidy@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAXXZ DD imagerel $LN49
	DD	imagerel $LN49+21
	DD	imagerel $unwind$?_Tidy@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Tidy@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAXXZ DD imagerel $LN49+21
	DD	imagerel $LN49+80
	DD	imagerel $chain$0$?_Tidy@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Tidy@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAXXZ DD imagerel $LN49+80
	DD	imagerel $LN49+140
	DD	imagerel $chain$1$?_Tidy@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Decref@?$_Ptr_base@U_Recursive_dir_enum_impl@filesystem@std@@@std@@IEAAXXZ DD imagerel $LN16
	DD	imagerel $LN16+15
	DD	imagerel $unwind$?_Decref@?$_Ptr_base@U_Recursive_dir_enum_impl@filesystem@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Decref@?$_Ptr_base@U_Recursive_dir_enum_impl@filesystem@std@@@std@@IEAAXXZ DD imagerel $LN16+15
	DD	imagerel $LN16+69
	DD	imagerel $chain$0$?_Decref@?$_Ptr_base@U_Recursive_dir_enum_impl@filesystem@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Decref@?$_Ptr_base@U_Recursive_dir_enum_impl@filesystem@std@@@std@@IEAAXXZ DD imagerel $LN16+69
	DD	imagerel $LN16+75
	DD	imagerel $chain$1$?_Decref@?$_Ptr_base@U_Recursive_dir_enum_impl@filesystem@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ DD imagerel $LN47
	DD	imagerel $LN47+21
	DD	imagerel $unwind$?_Tidy@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Tidy@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ DD imagerel $LN47+21
	DD	imagerel $LN47+104
	DD	imagerel $chain$0$?_Tidy@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Tidy@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ DD imagerel $LN47+104
	DD	imagerel $LN47+164
	DD	imagerel $chain$1$?_Tidy@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z DD imagerel $LN13
	DD	imagerel $LN13+39
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z DD imagerel $LN6
	DD	imagerel $LN6+15
	DD	imagerel $unwind$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z DD imagerel $LN6+15
	DD	imagerel $LN6+41
	DD	imagerel $chain$0$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z DD imagerel $LN6+41
	DD	imagerel $LN6+47
	DD	imagerel $chain$1$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z DD imagerel $LN66
	DD	imagerel $LN66+195
	DD	imagerel $unwind$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN63
	DD	imagerel $LN63+147
	DD	imagerel $unwind$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN111
	DD	imagerel $LN111+298
	DD	imagerel $unwind$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV23@QEB_W_K@Z@QEBA@QEA_W0101@Z DD imagerel $LN29
	DD	imagerel $LN29+91
	DD	imagerel $unwind$??R<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV23@QEB_W_K@Z@QEBA@QEA_W0101@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z DD imagerel $LN43
	DD	imagerel $LN43+28
	DD	imagerel $unwind$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z DD imagerel $LN43+28
	DD	imagerel $LN43+95
	DD	imagerel $chain$1$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z DD imagerel $LN43+95
	DD	imagerel $LN43+120
	DD	imagerel $chain$2$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@_K@Z DD imagerel $LN18
	DD	imagerel $LN18+49
	DD	imagerel $unwind$?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_1>@?1??push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z@QEBA@QEA_WQEB_W_K0@Z DD imagerel $LN17
	DD	imagerel $LN17+61
	DD	imagerel $unwind$??R<lambda_1>@?1??push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z@QEBA@QEA_WQEB_W_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z DD imagerel $LN86
	DD	imagerel $LN86+56
	DD	imagerel $unwind$?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z DD imagerel $LN86+56
	DD	imagerel $LN86+92
	DD	imagerel $chain$1$?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z DD imagerel $LN86+92
	DD	imagerel $LN86+184
	DD	imagerel $chain$2$?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z DD imagerel $LN86+184
	DD	imagerel $LN86+298
	DD	imagerel $chain$3$?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z DD imagerel $LN86+298
	DD	imagerel $LN86+304
	DD	imagerel $chain$5$?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K_W@Z DD imagerel $LN59
	DD	imagerel $LN59+131
	DD	imagerel $unwind$?resize@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@IV?$allocator@I@std@@@std@@QEAA@_KAEBV?$allocator@I@1@@Z DD imagerel $LN51
	DD	imagerel $LN51+49
	DD	imagerel $unwind$??0?$vector@IV?$allocator@I@std@@@std@@QEAA@_KAEBV?$allocator@I@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??0?$vector@IV?$allocator@I@std@@@std@@QEAA@_KAEBV?$allocator@I@1@@Z DD imagerel $LN51+49
	DD	imagerel $LN51+107
	DD	imagerel $chain$0$??0?$vector@IV?$allocator@I@std@@@std@@QEAA@_KAEBV?$allocator@I@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??0?$vector@IV?$allocator@I@std@@@std@@QEAA@_KAEBV?$allocator@I@1@@Z DD imagerel $LN51+107
	DD	imagerel $LN51+127
	DD	imagerel $chain$1$??0?$vector@IV?$allocator@I@std@@@std@@QEAA@_KAEBV?$allocator@I@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN7
	DD	imagerel $LN7+59
	DD	imagerel $unwind$??4?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAX_K@Z DD imagerel $LN81
	DD	imagerel $LN81+50
	DD	imagerel $unwind$?resize@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?resize@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAX_K@Z DD imagerel $LN81+50
	DD	imagerel $LN81+122
	DD	imagerel $chain$1$?resize@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?resize@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAX_K@Z DD imagerel $LN81+122
	DD	imagerel $LN81+212
	DD	imagerel $chain$2$?resize@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN7
	DD	imagerel $LN7+59
	DD	imagerel $unwind$??4?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAX_K@Z DD imagerel $LN81
	DD	imagerel $LN81+50
	DD	imagerel $unwind$?resize@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?resize@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAX_K@Z DD imagerel $LN81+50
	DD	imagerel $LN81+122
	DD	imagerel $chain$1$?resize@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?resize@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAX_K@Z DD imagerel $LN81+122
	DD	imagerel $LN81+212
	DD	imagerel $chain$2$?resize@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ DD imagerel $LN33
	DD	imagerel $LN33+88
	DD	imagerel $unwind$??1?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN7
	DD	imagerel $LN7+41
	DD	imagerel $unwind$??4?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEAA@XZ DD imagerel $LN52
	DD	imagerel $LN52+21
	DD	imagerel $unwind$??1?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??1?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEAA@XZ DD imagerel $LN52+21
	DD	imagerel $LN52+80
	DD	imagerel $chain$0$??1?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??1?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEAA@XZ DD imagerel $LN52+80
	DD	imagerel $LN52+140
	DD	imagerel $chain$1$??1?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pop_back@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEAAXXZ DD imagerel $LN14
	DD	imagerel $LN14+33
	DD	imagerel $unwind$?pop_back@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAA@XZ DD imagerel $LN18
	DD	imagerel $LN18+15
	DD	imagerel $unwind$??1?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??1?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAA@XZ DD imagerel $LN18+15
	DD	imagerel $LN18+69
	DD	imagerel $chain$0$??1?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??1?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAA@XZ DD imagerel $LN18+69
	DD	imagerel $LN18+75
	DD	imagerel $chain$1$??1?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reset@?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAAXXZ DD imagerel $LN32
	DD	imagerel $LN32+24
	DD	imagerel $unwind$?reset@?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?reset@?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAAXXZ DD imagerel $LN32+24
	DD	imagerel $LN32+78
	DD	imagerel $chain$0$?reset@?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?reset@?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAAXXZ DD imagerel $LN32+78
	DD	imagerel $LN32+84
	DD	imagerel $chain$1$?reset@?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ DD imagerel $LN50
	DD	imagerel $LN50+21
	DD	imagerel $unwind$??1?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??1?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ DD imagerel $LN50+21
	DD	imagerel $LN50+104
	DD	imagerel $chain$0$??1?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??1?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ DD imagerel $LN50+104
	DD	imagerel $LN50+164
	DD	imagerel $chain$1$??1?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z DD imagerel $LN30
	DD	imagerel $LN30+49
	DD	imagerel $unwind$?resize@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?resize@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z DD imagerel $LN30+49
	DD	imagerel $LN30+123
	DD	imagerel $chain$1$?resize@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?resize@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z DD imagerel $LN30+123
	DD	imagerel $LN30+182
	DD	imagerel $chain$2$?resize@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z DD imagerel $LN30
	DD	imagerel $LN30+50
	DD	imagerel $unwind$?resize@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?resize@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z DD imagerel $LN30+50
	DD	imagerel $LN30+126
	DD	imagerel $chain$1$?resize@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?resize@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z DD imagerel $LN30+126
	DD	imagerel $LN30+194
	DD	imagerel $chain$2$?resize@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@QEAAX_K@Z DD imagerel $LN39
	DD	imagerel $LN39+49
	DD	imagerel $unwind$?resize@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?resize@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@QEAAX_K@Z DD imagerel $LN39+49
	DD	imagerel $LN39+131
	DD	imagerel $chain$1$?resize@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?resize@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@QEAAX_K@Z DD imagerel $LN39+131
	DD	imagerel $LN39+197
	DD	imagerel $chain$2$?resize@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z DD imagerel $LN30
	DD	imagerel $LN30+50
	DD	imagerel $unwind$?resize@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?resize@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z DD imagerel $LN30+50
	DD	imagerel $LN30+123
	DD	imagerel $chain$1$?resize@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?resize@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z DD imagerel $LN30+123
	DD	imagerel $LN30+191
	DD	imagerel $chain$2$?resize@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z DD imagerel $LN674
	DD	imagerel $LN674+2140
	DD	imagerel $unwind$?NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z DD imagerel $LN8
	DD	imagerel $LN8+75
	DD	imagerel $unwind$??0ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0InputParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z DD imagerel $LN9
	DD	imagerel $LN9+119
	DD	imagerel $unwind$??0InputParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1AINBFile@@QEAA@XZ DD imagerel $LN110
	DD	imagerel $LN110+492
	DD	imagerel $unwind$??1AINBFile@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetNodeDefinition@AINBNodeDefMgr@@YAPEAUNodeDef@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN51
	DD	imagerel $LN51+146
	DD	imagerel $unwind$?GetNodeDefinition@AINBNodeDefMgr@@YAPEAUNodeDef@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4NodeDef@AINBNodeDefMgr@@QEAAAEAU01@AEBU01@@Z DD imagerel $LN54
	DD	imagerel $LN54+391
	DD	imagerel $unwind$??4NodeDef@AINBNodeDefMgr@@QEAAAEAU01@AEBU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAAAEAU012@AEBU012@@Z DD imagerel $LN30
	DD	imagerel $LN30+120
	DD	imagerel $unwind$??4ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAAAEAU012@AEBU012@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ DD imagerel $LN42
	DD	imagerel $LN42+106
	DD	imagerel $unwind$??1ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4InputParam@NodeDef@AINBNodeDefMgr@@QEAAAEAU012@AEBU012@@Z DD imagerel $LN41
	DD	imagerel $LN41+182
	DD	imagerel $unwind$??4InputParam@NodeDef@AINBNodeDefMgr@@QEAAAEAU012@AEBU012@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1InputParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ DD imagerel $LN105
	DD	imagerel $LN105+164
	DD	imagerel $unwind$??1InputParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1NodeDef@AINBNodeDefMgr@@QEAA@XZ DD imagerel $LN81
	DD	imagerel $LN81+270
	DD	imagerel $unwind$??1NodeDef@AINBNodeDefMgr@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Initialize@AINBNodeDefMgr@@YAXXZ DD imagerel $LN1956
	DD	imagerel $LN1956+6692
	DD	imagerel $unwind$?Initialize@AINBNodeDefMgr@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$57@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA DD imagerel ?dtor$57@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA
	DD	imagerel ?dtor$57@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA+44
	DD	imagerel $unwind$?dtor$57@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$52@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA DD imagerel ?dtor$52@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA
	DD	imagerel ?dtor$52@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA+44
	DD	imagerel $unwind$?dtor$52@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$35@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA DD imagerel ?dtor$35@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA
	DD	imagerel ?dtor$35@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA+44
	DD	imagerel $unwind$?dtor$35@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$40@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA DD imagerel ?dtor$40@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA
	DD	imagerel ?dtor$40@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA+44
	DD	imagerel $unwind$?dtor$40@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ReadString@AINBNodeDefMgr@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@@Z DD imagerel $LN62
	DD	imagerel $LN62+247
	DD	imagerel $unwind$?ReadString@AINBNodeDefMgr@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??ReadString@AINBNodeDefMgr@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@@Z@4HA DD imagerel ?dtor$0@?0??ReadString@AINBNodeDefMgr@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@@Z@4HA
	DD	imagerel ?dtor$0@?0??ReadString@AINBNodeDefMgr@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@@Z@4HA+38
	DD	imagerel $unwind$?dtor$0@?0??ReadString@AINBNodeDefMgr@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__FEXBFile@AINBNodeDefMgr@@YAXXZ DD imagerel ??__FEXBFile@AINBNodeDefMgr@@YAXXZ
	DD	imagerel ??__FEXBFile@AINBNodeDefMgr@@YAXXZ+32
	DD	imagerel $unwind$??__FEXBFile@AINBNodeDefMgr@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__FNodeDefinitions@AINBNodeDefMgr@@YAXXZ DD imagerel ??__FNodeDefinitions@AINBNodeDefMgr@@YAXXZ
	DD	imagerel ??__FNodeDefinitions@AINBNodeDefMgr@@YAXXZ+22
	DD	imagerel $unwind$??__FNodeDefinitions@AINBNodeDefMgr@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??__FNodeDefinitions@AINBNodeDefMgr@@YAXXZ DD imagerel ??__FNodeDefinitions@AINBNodeDefMgr@@YAXXZ+22
	DD	imagerel ??__FNodeDefinitions@AINBNodeDefMgr@@YAXXZ+115
	DD	imagerel $chain$0$??__FNodeDefinitions@AINBNodeDefMgr@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??__FNodeDefinitions@AINBNodeDefMgr@@YAXXZ DD imagerel ??__FNodeDefinitions@AINBNodeDefMgr@@YAXXZ+115
	DD	imagerel ??__FNodeDefinitions@AINBNodeDefMgr@@YAXXZ+182
	DD	imagerel $chain$1$??__FNodeDefinitions@AINBNodeDefMgr@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?end@filesystem@std@@YA?AVrecursive_directory_iterator@12@V312@@Z DD imagerel $LN33
	DD	imagerel $LN33+31
	DD	imagerel $unwind$?end@filesystem@std@@YA?AVrecursive_directory_iterator@12@V312@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?end@filesystem@std@@YA?AVrecursive_directory_iterator@12@V312@@Z DD imagerel $LN33+31
	DD	imagerel $LN33+99
	DD	imagerel $chain$0$?end@filesystem@std@@YA?AVrecursive_directory_iterator@12@V312@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?end@filesystem@std@@YA?AVrecursive_directory_iterator@12@V312@@Z DD imagerel $LN33+99
	DD	imagerel $LN33+113
	DD	imagerel $chain$1$?end@filesystem@std@@YA?AVrecursive_directory_iterator@12@V312@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1recursive_directory_iterator@filesystem@std@@QEAA@XZ DD imagerel $LN20
	DD	imagerel $LN20+15
	DD	imagerel $unwind$??1recursive_directory_iterator@filesystem@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??1recursive_directory_iterator@filesystem@std@@QEAA@XZ DD imagerel $LN20+15
	DD	imagerel $LN20+69
	DD	imagerel $chain$0$??1recursive_directory_iterator@filesystem@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??1recursive_directory_iterator@filesystem@std@@QEAA@XZ DD imagerel $LN20+69
	DD	imagerel $LN20+75
	DD	imagerel $chain$1$??1recursive_directory_iterator@filesystem@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??Erecursive_directory_iterator@filesystem@std@@QEAAAEAV012@XZ DD imagerel $LN8
	DD	imagerel $LN8+42
	DD	imagerel $unwind$??Erecursive_directory_iterator@filesystem@std@@QEAAAEAV012@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0recursive_directory_iterator@filesystem@std@@QEAA@AEBVpath@12@@Z DD imagerel $LN125
	DD	imagerel $LN125+417
	DD	imagerel $unwind$??0recursive_directory_iterator@filesystem@std@@QEAA@AEBVpath@12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$5@?0???0recursive_directory_iterator@filesystem@std@@QEAA@AEBVpath@12@@Z@4HA DD imagerel ?dtor$5@?0???0recursive_directory_iterator@filesystem@std@@QEAA@AEBVpath@12@@Z@4HA
	DD	imagerel ?dtor$5@?0???0recursive_directory_iterator@filesystem@std@@QEAA@AEBVpath@12@@Z@4HA+29
	DD	imagerel $unwind$?dtor$5@?0???0recursive_directory_iterator@filesystem@std@@QEAA@AEBVpath@12@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Dir_enum_impl@filesystem@std@@QEAA@XZ DD imagerel $LN16
	DD	imagerel $LN16+32
	DD	imagerel $unwind$??1_Dir_enum_impl@filesystem@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Recursive_dir_enum_impl@filesystem@std@@QEAA@$$QEAU_Creator@_Dir_enum_impl@12@W4directory_options@12@@Z DD imagerel $LN13
	DD	imagerel $LN13+56
	DD	imagerel $unwind$??0_Recursive_dir_enum_impl@filesystem@std@@QEAA@$$QEAU_Creator@_Dir_enum_impl@12@W4directory_options@12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Advance_and_reset_if_no_more_files@_Recursive_dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@3@@Z DD imagerel $LN327
	DD	imagerel $LN327+931
	DD	imagerel $unwind$?_Advance_and_reset_if_no_more_files@_Recursive_dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Advance_and_skip_dots@_Recursive_dir_enum_impl@filesystem@std@@QEAA?AW4__std_win_error@@AEAU__std_fs_find_data@@@Z DD imagerel $LN18
	DD	imagerel $LN18+88
	DD	imagerel $unwind$?_Advance_and_skip_dots@_Recursive_dir_enum_impl@filesystem@std@@QEAA?AW4__std_win_error@@AEAU__std_fs_find_data@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Should_recurse@_Recursive_dir_enum_impl@filesystem@std@@QEBA?AU_Should_recurse_result@23@XZ DD imagerel $LN73
	DD	imagerel $LN73+224
	DD	imagerel $unwind$?_Should_recurse@_Recursive_dir_enum_impl@filesystem@std@@QEBA?AU_Should_recurse_result@23@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4path@filesystem@std@@QEAAAEAV012@$$QEAV012@@Z DD imagerel $LN65
	DD	imagerel $LN65+147
	DD	imagerel $unwind$??4path@filesystem@std@@QEAAAEAV012@$$QEAV012@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Dir_enum_impl@filesystem@std@@QEAA@$$QEAU_Creator@012@W4directory_options@12@@Z DD imagerel $LN89
	DD	imagerel $LN89+221
	DD	imagerel $unwind$??0_Dir_enum_impl@filesystem@std@@QEAA@$$QEAU_Creator@012@W4directory_options@12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Refresh@_Dir_enum_impl@filesystem@std@@QEAAXAEBU__std_fs_find_data@@@Z DD imagerel $LN168
	DD	imagerel $LN168+474
	DD	imagerel $unwind$?_Refresh@_Dir_enum_impl@filesystem@std@@QEAAXAEBU__std_fs_find_data@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Creator@_Dir_enum_impl@filesystem@std@@QEAA@AEBVpath@23@W4directory_options@23@@Z DD imagerel $LN14
	DD	imagerel $LN14+111
	DD	imagerel $unwind$??0_Creator@_Dir_enum_impl@filesystem@std@@QEAA@AEBVpath@23@W4directory_options@23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Open_dir@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAVpath@23@W4directory_options@23@AEAU_Find_file_handle@23@AEAU__std_fs_find_data@@@Z DD imagerel $LN49
	DD	imagerel $LN49+218
	DD	imagerel $unwind$?_Open_dir@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAVpath@23@W4directory_options@23@AEAU_Find_file_handle@23@AEAU__std_fs_find_data@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Skip_dots@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@W4__std_fs_dir_handle@@AEAU__std_fs_find_data@@@Z DD imagerel $LN14
	DD	imagerel $LN14+72
	DD	imagerel $unwind$?_Skip_dots@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@W4__std_fs_dir_handle@@AEAU__std_fs_find_data@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?status@directory_entry@filesystem@std@@QEBA?AVfile_status@23@XZ DD imagerel $LN16
	DD	imagerel $LN16+92
	DD	imagerel $unwind$?status@directory_entry@filesystem@std@@QEBA?AVfile_status@23@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_any_status@directory_entry@filesystem@std@@AEBA?AU_File_status_and_error@23@W4__std_fs_stats_flags@@@Z DD imagerel $LN109
	DD	imagerel $LN109+344
	DD	imagerel $unwind$?_Get_any_status@directory_entry@filesystem@std@@AEBA?AU_File_status_and_error@23@W4__std_fs_stats_flags@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?is_regular_file@directory_entry@filesystem@std@@QEBA_NXZ DD imagerel $LN21
	DD	imagerel $LN21+80
	DD	imagerel $unwind$?is_regular_file@directory_entry@filesystem@std@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@AEBVpath@12@@Z DD imagerel $LN13
	DD	imagerel $LN13+98
	DD	imagerel $unwind$?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@AEBVpath@12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z DD imagerel $LN20
	DD	imagerel $LN20+135
	DD	imagerel $unwind$??0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@@Z DD imagerel $LN13
	DD	imagerel $LN13+90
	DD	imagerel $unwind$?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1filesystem_error@filesystem@std@@UEAA@XZ DD imagerel $LN31
	DD	imagerel $LN31+62
	DD	imagerel $unwind$??1filesystem_error@filesystem@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gfilesystem_error@filesystem@std@@UEAAPEAXI@Z DD imagerel $LN37
	DD	imagerel $LN37+94
	DD	imagerel $unwind$??_Gfilesystem_error@filesystem@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z DD imagerel $LN302
	DD	imagerel $LN302+611
	DD	imagerel $unwind$?_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z@4HA DD imagerel ?dtor$0@?0??_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z@4HA
	DD	imagerel ?dtor$0@?0??_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z@4HA+38
	DD	imagerel $unwind$?dtor$0@?0??_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z DD imagerel $LN60
	DD	imagerel $LN60+224
	DD	imagerel $unwind$??0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@@Z DD imagerel $LN61
	DD	imagerel $LN61+169
	DD	imagerel $unwind$??0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0path@filesystem@std@@QEAA@AEBV012@@Z DD imagerel $LN70
	DD	imagerel $LN70+200
	DD	imagerel $unwind$??0path@filesystem@std@@QEAA@AEBV012@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4path@filesystem@std@@QEAAAEAV012@AEBV012@@Z DD imagerel $LN113
	DD	imagerel $LN113+298
	DD	imagerel $unwind$??4path@filesystem@std@@QEAAAEAV012@AEBV012@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?is_absolute@path@filesystem@std@@QEBA_NXZ DD imagerel $LN27
	DD	imagerel $LN27+112
	DD	imagerel $unwind$?is_absolute@path@filesystem@std@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?filename@path@filesystem@std@@QEBA?AV123@XZ DD imagerel $LN61
	DD	imagerel $LN61+163
	DD	imagerel $unwind$?filename@path@filesystem@std@@QEBA?AV123@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ DD imagerel $LN66
	DD	imagerel $LN66+234
	DD	imagerel $unwind$?string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$3@?0??string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ@4HA DD imagerel ?dtor$3@?0??string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ@4HA
	DD	imagerel ?dtor$3@?0??string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ@4HA+38
	DD	imagerel $unwind$?dtor$3@?0??string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?replace_filename@path@filesystem@std@@QEAAAEAV123@AEBV123@@Z DD imagerel $LN69
	DD	imagerel $LN69+169
	DD	imagerel $unwind$?replace_filename@path@filesystem@std@@QEAAAEAV123@AEBV123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Remove_filename_and_separator@path@filesystem@std@@QEAAXXZ DD imagerel $LN110
	DD	imagerel $LN110+189
	DD	imagerel $unwind$?_Remove_filename_and_separator@path@filesystem@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?remove_filename@path@filesystem@std@@QEAAAEAV123@XZ DD imagerel $LN65
	DD	imagerel $LN65+157
	DD	imagerel $unwind$?remove_filename@path@filesystem@std@@QEAAAEAV123@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_0path@filesystem@std@@QEAAAEAV012@AEBV012@@Z DD imagerel $LN129
	DD	imagerel $LN129+108
	DD	imagerel $unwind$??_0path@filesystem@std@@QEAAAEAV012@AEBV012@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??_0path@filesystem@std@@QEAAAEAV012@AEBV012@@Z DD imagerel $LN129+108
	DD	imagerel $LN129+349
	DD	imagerel $chain$4$??_0path@filesystem@std@@QEAAAEAV012@AEBV012@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??_0path@filesystem@std@@QEAAAEAV012@AEBV012@@Z DD imagerel $LN129+349
	DD	imagerel $LN129+384
	DD	imagerel $chain$5$??_0path@filesystem@std@@QEAAAEAV012@AEBV012@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$??_0path@filesystem@std@@QEAAAEAV012@AEBV012@@Z DD imagerel $LN129+384
	DD	imagerel $LN129+494
	DD	imagerel $chain$6$??_0path@filesystem@std@@QEAAAEAV012@AEBV012@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$??_0path@filesystem@std@@QEAAAEAV012@AEBV012@@Z DD imagerel $LN129+494
	DD	imagerel $LN129+500
	DD	imagerel $chain$8$??_0path@filesystem@std@@QEAAAEAV012@AEBV012@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4_Find_file_handle@filesystem@std@@QEAAAEAU012@$$QEAU012@@Z DD imagerel $LN9
	DD	imagerel $LN9+39
	DD	imagerel $unwind$??4_Find_file_handle@filesystem@std@@QEAAAEAU012@$$QEAU012@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Parse_filename@filesystem@std@@YA?AV?$basic_string_view@_WU?$char_traits@_W@std@@@2@V32@@Z DD imagerel $LN47
	DD	imagerel $LN47+116
	DD	imagerel $unwind$?_Parse_filename@filesystem@std@@YA?AV?$basic_string_view@_WU?$char_traits@_W@std@@@2@V32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Find_filename@filesystem@std@@YAPEB_WQEB_WPEB_W@Z DD imagerel $LN39
	DD	imagerel $LN39+87
	DD	imagerel $unwind$?_Find_filename@filesystem@std@@YAPEB_WQEB_WPEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Find_relative_path@filesystem@std@@YAPEB_WQEB_W0@Z DD imagerel $LN26
	DD	imagerel $LN26+40
	DD	imagerel $unwind$?_Find_relative_path@filesystem@std@@YAPEB_WQEB_W0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z DD imagerel $LN42
	DD	imagerel $LN42+220
	DD	imagerel $unwind$?_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z@4HA DD imagerel ?dtor$0@?0??_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z@4HA
	DD	imagerel ?dtor$0@?0??_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z@4HA+38
	DD	imagerel $unwind$?dtor$0@?0??_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Check_convert_result@std@@YAHU__std_fs_convert_result@@@Z DD imagerel $LN7
	DD	imagerel $LN7+30
	DD	imagerel $unwind$?_Check_convert_result@std@@YAHU__std_fs_convert_result@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Decref@_Ref_count_base@std@@QEAAXXZ DD imagerel $LN11
	DD	imagerel $LN11+65
	DD	imagerel $unwind$?_Decref@_Ref_count_base@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Throw_system_error_from_std_win_error@std@@YAXW4__std_win_error@@@Z DD imagerel $LN4
	DD	imagerel $LN4+57
	DD	imagerel $unwind$?_Throw_system_error_from_std_win_error@std@@YAXW4__std_win_error@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G_System_error_category@std@@UEAAPEAXI@Z DD imagerel $LN8
	DD	imagerel $LN8+33
	DD	imagerel $unwind$??_G_System_error_category@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?default_error_condition@_System_error_category@std@@UEBA?AVerror_condition@2@H@Z DD imagerel $LN16
	DD	imagerel $LN16+115
	DD	imagerel $unwind$?default_error_condition@_System_error_category@std@@UEBA?AVerror_condition@2@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z DD imagerel $LN39
	DD	imagerel $LN39+144
	DD	imagerel $unwind$?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G_Generic_error_category@std@@UEAAPEAXI@Z DD imagerel $LN8
	DD	imagerel $LN8+33
	DD	imagerel $unwind$??_G_Generic_error_category@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?message@_Generic_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z DD imagerel $LN21
	DD	imagerel $LN21+78
	DD	imagerel $unwind$?message@_Generic_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_System_error_message@std@@QEAA@K@Z DD imagerel $LN5
	DD	imagerel $LN5+41
	DD	imagerel $unwind$??0_System_error_message@std@@QEAA@K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_System_error@std@@QEAA@AEBV01@@Z DD imagerel $LN10
	DD	imagerel $LN10+78
	DD	imagerel $unwind$??0_System_error@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0system_error@std@@QEAA@AEBV01@@Z DD imagerel $LN13
	DD	imagerel $LN13+88
	DD	imagerel $unwind$??0system_error@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Throw_system_error@std@@YAXW4errc@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$?_Throw_system_error@std@@YAXW4errc@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gsystem_error@std@@UEAAPEAXI@Z DD imagerel $LN19
	DD	imagerel $LN19+67
	DD	imagerel $unwind$??_Gsystem_error@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0system_error@std@@QEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD imagerel $LN6
	DD	imagerel $LN6+47
	DD	imagerel $unwind$??0system_error@std@@QEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0system_error@std@@QEAA@Verror_code@1@@Z DD imagerel $LN49
	DD	imagerel $LN49+162
	DD	imagerel $unwind$??0system_error@std@@QEAA@Verror_code@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G_System_error@std@@UEAAPEAXI@Z DD imagerel $LN16
	DD	imagerel $LN16+67
	DD	imagerel $unwind$??_G_System_error@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD imagerel $LN170
	DD	imagerel $LN170+460
	DD	imagerel $unwind$??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_System_error@std@@IEAA@Verror_code@1@@Z DD imagerel $LN45
	DD	imagerel $LN45+147
	DD	imagerel $unwind$??0_System_error@std@@IEAA@Verror_code@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z DD imagerel $LN135
	DD	imagerel $LN135+332
	DD	imagerel $unwind$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z DD imagerel $LN13
	DD	imagerel $LN13+63
	DD	imagerel $unwind$?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD imagerel $LN7
	DD	imagerel $LN7+31
	DD	imagerel $unwind$?message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0runtime_error@std@@QEAA@AEBV01@@Z DD imagerel $LN7
	DD	imagerel $LN7+61
	DD	imagerel $unwind$??0runtime_error@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gruntime_error@std@@UEAAPEAXI@Z DD imagerel $LN13
	DD	imagerel $LN13+67
	DD	imagerel $unwind$??_Gruntime_error@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD imagerel $LN15
	DD	imagerel $LN15+110
	DD	imagerel $unwind$??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@QEBD@Z DD imagerel $LN5
	DD	imagerel $LN5+90
	DD	imagerel $unwind$??0exception@std@@QEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$wmemset DD imagerel $LN13
	DD	imagerel $LN13+12
	DD	imagerel $unwind$wmemset
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$wmemset DD imagerel $LN13+12
	DD	imagerel $LN13+34
	DD	imagerel $chain$0$wmemset
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$wmemset DD imagerel $LN13+34
	DD	imagerel $LN13+42
	DD	imagerel $chain$1$wmemset
;	COMDAT xdata
xdata	SEGMENT
$chain$1$wmemset DD 021H
	DD	imagerel $LN13
	DD	imagerel $LN13+12
	DD	imagerel $unwind$wmemset
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$wmemset DD 020421H
	DD	07404H
	DD	imagerel $LN13
	DD	imagerel $LN13+12
	DD	imagerel $unwind$wmemset
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$wmemset DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@QEBD@Z DD 021519H
	DD	030027206H
	DD	imagerel __GSHandlerCheck
	DD	030H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 021519H
	DD	030027206H
	DD	imagerel __GSHandlerCheck
	DD	030H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gruntime_error@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0runtime_error@std@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z DB 08H
	DB	09H, 02H
	DB	02H
	DB	'0'
	DB	04H
	DB	'>'
	DB	02H
	DB	0fcH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z DB 04H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0b0H
	DB	032H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	070H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z DB 028H
	DD	imagerel $stateUnwindMap$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
	DD	imagerel $ip2state$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z DD 061b19H
	DD	015340cH
	DD	07008d20cH
	DD	050066007H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
	DD	062H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_System_error@std@@IEAA@Verror_code@1@@Z DD 040a01H
	DD	0e340aH
	DD	07006920aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DB 08H
	DB	'F'
	DB	00H
	DB	0c4H
	DB	02H
	DB	'H'
	DB	04H
	DB	'>'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DB 04H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	060H
	DB	032H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	080H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	imagerel $ip2state$??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 071111H
	DD	0a6811H
	DD	016010dH
	DD	060057006H
	DD	03004H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G_System_error@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0system_error@std@@QEAA@Verror_code@1@@Z DD 040a01H
	DD	0e340aH
	DD	07006920aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0system_error@std@@QEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gsystem_error@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Throw_system_error@std@@YAXW4errc@1@@Z DD 010401H
	DD	0e204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0system_error@std@@QEAA@AEBV01@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_System_error@std@@QEAA@AEBV01@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_System_error_message@std@@QEAA@K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?message@_Generic_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G_Generic_error_category@std@@UEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z DB 04H
	DB	0caH
	DB	02H
	DB	'6'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z DB 02H
	DB	0aH
	DD	imagerel ??1_System_error_message@std@@QEAA@XZ
	DB	050H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z DB 028H
	DD	imagerel $stateUnwindMap$?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	imagerel $ip2state$?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z DD 041919H
	DD	0a340aH
	DD	07006720aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	03aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?default_error_condition@_System_error_category@std@@UEBA?AVerror_condition@2@H@Z DB 02H
	DB	'f'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?default_error_condition@_System_error_category@std@@UEBA?AVerror_condition@2@H@Z DB 060H
	DD	imagerel $ip2state$?default_error_condition@_System_error_category@std@@UEBA?AVerror_condition@2@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?default_error_condition@_System_error_category@std@@UEBA?AVerror_condition@2@H@Z DD 040a19H
	DD	06340aH
	DD	07006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?default_error_condition@_System_error_category@std@@UEBA?AVerror_condition@2@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G_System_error_category@std@@UEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Throw_system_error_from_std_win_error@std@@YAXW4__std_win_error@@@Z DD 010401H
	DD	0e204H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	014H
	DB	023H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Decref@_Ref_count_base@std@@QEAAXXZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	05H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Check_convert_result@std@@YAHU__std_fs_convert_result@@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z DB 02H
	DB	0f6H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z DB 028H
	DD	imagerel $stateUnwindMap$?_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z
	DD	imagerel $ip2state$?_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z DD 081711H
	DD	0e5417H
	DD	0d3417H
	DD	0e0137217H
	DD	060107011H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Find_relative_path@filesystem@std@@YAPEB_WQEB_W0@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Find_filename@filesystem@std@@YAPEB_WQEB_WPEB_W@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Parse_filename@filesystem@std@@YA?AV?$basic_string_view@_WU?$char_traits@_W@std@@@2@V32@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4_Find_file_handle@filesystem@std@@QEAAAEAU012@$$QEAU012@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$??_0path@filesystem@std@@QEAAAEAV012@AEBV012@@Z DD 0a0021H
	DD	04f400H
	DD	05e400H
	DD	06d400H
	DD	07c400H
	DD	0e5400H
	DD	imagerel $LN129
	DD	imagerel $LN129+108
	DD	imagerel $unwind$??_0path@filesystem@std@@QEAAAEAV012@AEBV012@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$??_0path@filesystem@std@@QEAAAEAV012@AEBV012@@Z DD 0a0021H
	DD	04f400H
	DD	05e400H
	DD	06d400H
	DD	07c400H
	DD	0e5400H
	DD	imagerel $LN129
	DD	imagerel $LN129+108
	DD	imagerel $unwind$??_0path@filesystem@std@@QEAAAEAV012@AEBV012@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??_0path@filesystem@std@@QEAAAEAV012@AEBV012@@Z DD 021H
	DD	imagerel $LN129
	DD	imagerel $LN129+108
	DD	imagerel $unwind$??_0path@filesystem@std@@QEAAAEAV012@AEBV012@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??_0path@filesystem@std@@QEAAAEAV012@AEBV012@@Z DD 0a2021H
	DD	04f420H
	DD	05e418H
	DD	06d40fH
	DD	07c40aH
	DD	0e5405H
	DD	imagerel $LN129
	DD	imagerel $LN129+108
	DD	imagerel $unwind$??_0path@filesystem@std@@QEAAAEAV012@AEBV012@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_0path@filesystem@std@@QEAAAEAV012@AEBV012@@Z DD 040801H
	DD	070047208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?remove_filename@path@filesystem@std@@QEAAAEAV123@XZ DB 02H
	DB	']', 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?remove_filename@path@filesystem@std@@QEAAAEAV123@XZ DB 060H
	DD	imagerel $ip2state$?remove_filename@path@filesystem@std@@QEAAAEAV123@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?remove_filename@path@filesystem@std@@QEAAAEAV123@XZ DD 020619H
	DD	070023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?remove_filename@path@filesystem@std@@QEAAAEAV123@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Remove_filename_and_separator@path@filesystem@std@@QEAAXXZ DB 02H
	DB	0ddH, 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Remove_filename_and_separator@path@filesystem@std@@QEAAXXZ DB 060H
	DD	imagerel $ip2state$?_Remove_filename_and_separator@path@filesystem@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Remove_filename_and_separator@path@filesystem@std@@QEAAXXZ DD 040a19H
	DD	07640aH
	DD	07006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Remove_filename_and_separator@path@filesystem@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?replace_filename@path@filesystem@std@@QEAAAEAV123@AEBV123@@Z DB 02H
	DB	08dH, 02H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?replace_filename@path@filesystem@std@@QEAAAEAV123@AEBV123@@Z DB 02H
	DB	0eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?replace_filename@path@filesystem@std@@QEAAAEAV123@AEBV123@@Z DB 028H
	DD	imagerel $stateUnwindMap$?replace_filename@path@filesystem@std@@QEAAAEAV123@AEBV123@@Z
	DD	imagerel $ip2state$?replace_filename@path@filesystem@std@@QEAAAEAV123@AEBV123@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?replace_filename@path@filesystem@std@@QEAAAEAV123@AEBV123@@Z DD 040a11H
	DD	08640aH
	DD	07006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?replace_filename@path@filesystem@std@@QEAAAEAV123@AEBV123@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$3@?0??string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ DB 02H
	DB	'%', 02H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$3@?0??string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ DB 028H
	DD	imagerel $stateUnwindMap$?string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ
	DD	imagerel $ip2state$?string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ DD 081211H
	DD	0e5412H
	DD	0c3412H
	DD	0e00e7212H
	DD	0600b700cH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?filename@path@filesystem@std@@QEBA?AV123@XZ DD 020601H
	DD	030027206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?is_absolute@path@filesystem@std@@QEBA_NXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4path@filesystem@std@@QEAAAEAV012@AEBV012@@Z DD 081001H
	DD	0c3410H
	DD	0f00c3210H
	DD	07008e00aH
	DD	050066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0path@filesystem@std@@QEAA@AEBV012@@Z DD 060d01H
	DD	0c340dH
	DD	0e009520dH
	DD	060067007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@@Z DB 04H
	DB	'>'
	DB	00H
	DB	0f6H
	DB	06H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@@Z DB 06H
	DB	0cH
	DD	imagerel ??1system_error@std@@UEAA@XZ
	DB	080H
	DB	036H
	DD	imagerel ?dtor$1@?0???0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@@Z
	DD	imagerel $ip2state$??0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@@Z DD 020a11H
	DD	03006520aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z DB 06H
	DB	'N'
	DB	00H
	DB	'.'
	DB	02H
	DB	0dH, 02H
	DB	08H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z DB 08H
	DB	0cH
	DD	imagerel ??1system_error@std@@UEAA@XZ
	DB	0c0H
	DB	036H
	DD	imagerel ?dtor$1@?0???0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z@4HA
	DB	02aH
	DD	imagerel ??1path@filesystem@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z
	DD	imagerel $ip2state$??0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z DD 040f11H
	DD	0d340fH
	DD	0700b920fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z DB 0aH
	DB	'Q', 02H
	DB	02H
	DB	'f'
	DB	04H
	DB	'j'
	DB	06H
	DB	0bdH, 02H
	DB	04H
	DB	'Y', 02H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0??_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z@4HA
	DB	02aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0c0H
	DB	032H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	080H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z DB 028H
	DD	imagerel $stateUnwindMap$?_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z
	DD	imagerel $ip2state$?_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z DD 0b2c19H
	DD	01b641eH
	DD	01a341eH
	DD	012011eH
	DD	0e010f012H
	DD	0700cc00eH
	DD	0500bH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z
	DD	082H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gfilesystem_error@filesystem@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1filesystem_error@filesystem@std@@UEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@@Z DB 04H
	DB	'H'
	DB	00H
	DB	'>'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	080H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@@Z
	DD	imagerel $ip2state$?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@@Z DD 020711H
	DD	01f0107H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z DB 06H
	DB	0aeH
	DB	02H
	DB	01cH
	DB	04H
	DB	01cH
	DB	06H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z DB 06H
	DB	0cH
	DD	imagerel ??1system_error@std@@UEAA@XZ
	DB	060H
	DB	036H
	DD	imagerel ?dtor$1@?0???0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z
	DD	imagerel $ip2state$??0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z DD 040f11H
	DD	07340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@AEBVpath@12@@Z DB 04H
	DB	'R'
	DB	00H
	DB	'D'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@AEBVpath@12@@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	080H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@AEBVpath@12@@Z DB 028H
	DD	imagerel $stateUnwindMap$?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@AEBVpath@12@@Z
	DD	imagerel $ip2state$?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@AEBVpath@12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@AEBVpath@12@@Z DD 030911H
	DD	01e0109H
	DD	03002H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@AEBVpath@12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?is_regular_file@directory_entry@filesystem@std@@QEBA_NXZ DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_any_status@directory_entry@filesystem@std@@AEBA?AU_File_status_and_error@23@W4__std_fs_stats_flags@@@Z DD 041919H
	DD	0f340aH
	DD	07006920aH
	DD	imagerel __GSHandlerCheck
	DD	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?status@directory_entry@filesystem@std@@QEBA?AVfile_status@23@XZ DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Skip_dots@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@W4__std_fs_dir_handle@@AEAU__std_fs_find_data@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Open_dir@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAVpath@23@W4directory_options@23@AEAU_Find_file_handle@23@AEAU__std_fs_find_data@@@Z DB 04H
	DB	0caH
	DB	00H
	DB	018H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Open_dir@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAVpath@23@W4directory_options@23@AEAU_Find_file_handle@23@AEAU__std_fs_find_data@@@Z DB 02H
	DB	0aH
	DD	imagerel ??1path@filesystem@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Open_dir@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAVpath@23@W4directory_options@23@AEAU_Find_file_handle@23@AEAU__std_fs_find_data@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?_Open_dir@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAVpath@23@W4directory_options@23@AEAU_Find_file_handle@23@AEAU__std_fs_find_data@@@Z
	DD	imagerel $ip2state$?_Open_dir@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAVpath@23@W4directory_options@23@AEAU_Find_file_handle@23@AEAU__std_fs_find_data@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Open_dir@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAVpath@23@W4directory_options@23@AEAU_Find_file_handle@23@AEAU__std_fs_find_data@@@Z DD 081511H
	DD	0e7415H
	DD	0d6415H
	DD	0c3415H
	DD	0e0119215H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Open_dir@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAVpath@23@W4directory_options@23@AEAU_Find_file_handle@23@AEAU__std_fs_find_data@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0_Creator@_Dir_enum_impl@filesystem@std@@QEAA@AEBVpath@23@W4directory_options@23@@Z DB 04H
	DB	'*'
	DB	00H
	DB	'4'
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0_Creator@_Dir_enum_impl@filesystem@std@@QEAA@AEBVpath@23@W4directory_options@23@@Z DB 04H
	DB	0cH
	DD	imagerel ??1path@filesystem@std@@QEAA@XZ
	DB	060H
	DB	036H
	DD	imagerel ?dtor$1@?0???0_Creator@_Dir_enum_impl@filesystem@std@@QEAA@AEBVpath@23@W4directory_options@23@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0_Creator@_Dir_enum_impl@filesystem@std@@QEAA@AEBVpath@23@W4directory_options@23@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0_Creator@_Dir_enum_impl@filesystem@std@@QEAA@AEBVpath@23@W4directory_options@23@@Z
	DD	imagerel $ip2state$??0_Creator@_Dir_enum_impl@filesystem@std@@QEAA@AEBVpath@23@W4directory_options@23@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Creator@_Dir_enum_impl@filesystem@std@@QEAA@AEBVpath@23@W4directory_options@23@@Z DD 040f11H
	DD	07340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0_Creator@_Dir_enum_impl@filesystem@std@@QEAA@AEBVpath@23@W4directory_options@23@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Refresh@_Dir_enum_impl@filesystem@std@@QEAAXAEBU__std_fs_find_data@@@Z DB 08H
	DB	0b5H, 03H
	DB	00H
	DB	0ddH, 02H
	DB	02H
	DB	'T'
	DB	04H
	DB	0cH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Refresh@_Dir_enum_impl@filesystem@std@@QEAAXAEBU__std_fs_find_data@@@Z DB 04H
	DB	0aH
	DD	imagerel ??1path@filesystem@std@@QEAA@XZ
	DB	040H
	DB	036H
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Refresh@_Dir_enum_impl@filesystem@std@@QEAAXAEBU__std_fs_find_data@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?_Refresh@_Dir_enum_impl@filesystem@std@@QEAAXAEBU__std_fs_find_data@@@Z
	DD	imagerel $ip2state$?_Refresh@_Dir_enum_impl@filesystem@std@@QEAAXAEBU__std_fs_find_data@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Refresh@_Dir_enum_impl@filesystem@std@@QEAAXAEBU__std_fs_find_data@@@Z DD 0a1811H
	DD	0116418H
	DD	0105418H
	DD	0f3418H
	DD	0f0149218H
	DD	07010e012H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Refresh@_Dir_enum_impl@filesystem@std@@QEAAXAEBU__std_fs_find_data@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0_Dir_enum_impl@filesystem@std@@QEAA@$$QEAU_Creator@012@W4directory_options@12@@Z DB 02H
	DB	01H, 03H
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0_Dir_enum_impl@filesystem@std@@QEAA@$$QEAU_Creator@012@W4directory_options@12@@Z DB 04H
	DB	0cH
	DD	imagerel ??1directory_entry@filesystem@std@@QEAA@XZ
	DB	040H
	DB	036H
	DD	imagerel ?dtor$1@?0???0_Dir_enum_impl@filesystem@std@@QEAA@$$QEAU_Creator@012@W4directory_options@12@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0_Dir_enum_impl@filesystem@std@@QEAA@$$QEAU_Creator@012@W4directory_options@12@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0_Dir_enum_impl@filesystem@std@@QEAA@$$QEAU_Creator@012@W4directory_options@12@@Z
	DD	imagerel $ip2state$??0_Dir_enum_impl@filesystem@std@@QEAA@$$QEAU_Creator@012@W4directory_options@12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Dir_enum_impl@filesystem@std@@QEAA@$$QEAU_Creator@012@W4directory_options@12@@Z DD 060c11H
	DD	0c340cH
	DD	07008520cH
	DD	050066007H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0_Dir_enum_impl@filesystem@std@@QEAA@$$QEAU_Creator@012@W4directory_options@12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4path@filesystem@std@@QEAAAEAV012@$$QEAV012@@Z DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Should_recurse@_Recursive_dir_enum_impl@filesystem@std@@QEBA?AU_Should_recurse_result@23@XZ DD 061e19H
	DD	0f640fH
	DD	0e340fH
	DD	0700b920fH
	DD	imagerel __GSHandlerCheck
	DD	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Advance_and_skip_dots@_Recursive_dir_enum_impl@filesystem@std@@QEAA?AW4__std_win_error@@AEAU__std_fs_find_data@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0e4H
	DW	0f6H
	DW	0372H
	DW	0384H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Advance_and_reset_if_no_more_files@_Recursive_dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@3@@Z DB 08H
	DB	'-', 05H
	DB	00H
	DB	019H, 03H
	DB	02H
	DB	'5', 04H
	DB	00H
	DB	0feH
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Advance_and_reset_if_no_more_files@_Recursive_dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@3@@Z DB 02H
	DB	0eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Advance_and_reset_if_no_more_files@_Recursive_dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@3@@Z DB 028H
	DD	imagerel $stateUnwindMap$?_Advance_and_reset_if_no_more_files@_Recursive_dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@3@@Z
	DD	imagerel $ip2state$?_Advance_and_reset_if_no_more_files@_Recursive_dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@3@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Advance_and_reset_if_no_more_files@_Recursive_dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@3@@Z DD 0d3119H
	DD	05f641fH
	DD	05e541fH
	DD	05d341fH
	DD	056011fH
	DD	0e016f018H
	DD	0c012d014H
	DD	07010H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?_Advance_and_reset_if_no_more_files@_Recursive_dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@3@@Z
	DD	02a2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Recursive_dir_enum_impl@filesystem@std@@QEAA@$$QEAU_Creator@_Dir_enum_impl@12@W4directory_options@12@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Dir_enum_impl@filesystem@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	011eH
	DW	0130H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$5@?0???0recursive_directory_iterator@filesystem@std@@QEAA@AEBVpath@12@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0recursive_directory_iterator@filesystem@std@@QEAA@AEBVpath@12@@Z DB 0cH
	DB	098H
	DB	02H
	DB	'F'
	DB	06H
	DB	09aH
	DB	08H
	DB	'n'
	DB	0aH
	DB	0f6H
	DB	00H
	DB	'Z'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0recursive_directory_iterator@filesystem@std@@QEAA@AEBVpath@12@@Z DB 0aH
	DB	0cH
	DD	imagerel ??1?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAA@XZ
	DB	050H
	DB	032H
	DD	imagerel ??1path@filesystem@std@@QEAA@XZ
	DB	060H
	DB	036H
	DD	imagerel ?dtor$4@?0???0recursive_directory_iterator@filesystem@std@@QEAA@AEBVpath@12@@Z@4HA
	DB	08aH
	DD	imagerel ??1_Creator@_Dir_enum_impl@filesystem@std@@QEAA@XZ
	DB	060H
	DB	036H
	DD	imagerel ?dtor$5@?0???0recursive_directory_iterator@filesystem@std@@QEAA@AEBVpath@12@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0recursive_directory_iterator@filesystem@std@@QEAA@AEBVpath@12@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0recursive_directory_iterator@filesystem@std@@QEAA@AEBVpath@12@@Z
	DD	imagerel $ip2state$??0recursive_directory_iterator@filesystem@std@@QEAA@AEBVpath@12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0recursive_directory_iterator@filesystem@std@@QEAA@AEBVpath@12@@Z DD 0b3219H
	DD	0616421H
	DD	0603421H
	DD	0580121H
	DD	0e010f012H
	DD	0700cc00eH
	DD	0500bH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??0recursive_directory_iterator@filesystem@std@@QEAA@AEBVpath@12@@Z
	DD	02b2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??Erecursive_directory_iterator@filesystem@std@@QEAAAEAV012@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01bH
	DB	02dH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??1recursive_directory_iterator@filesystem@std@@QEAA@XZ DD 021H
	DD	imagerel $LN20
	DD	imagerel $LN20+15
	DD	imagerel $unwind$??1recursive_directory_iterator@filesystem@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??1recursive_directory_iterator@filesystem@std@@QEAA@XZ DD 020521H
	DD	067405H
	DD	imagerel $LN20
	DD	imagerel $LN20+15
	DD	imagerel $unwind$??1recursive_directory_iterator@filesystem@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1recursive_directory_iterator@filesystem@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	02bH
	DB	03dH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?end@filesystem@std@@YA?AVrecursive_directory_iterator@12@V312@@Z DD 021H
	DD	imagerel $LN33
	DD	imagerel $LN33+31
	DD	imagerel $unwind$?end@filesystem@std@@YA?AVrecursive_directory_iterator@12@V312@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?end@filesystem@std@@YA?AVrecursive_directory_iterator@12@V312@@Z DD 020521H
	DD	066405H
	DD	imagerel $LN33
	DD	imagerel $LN33+31
	DD	imagerel $unwind$?end@filesystem@std@@YA?AVrecursive_directory_iterator@12@V312@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?end@filesystem@std@@YA?AVrecursive_directory_iterator@12@V312@@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??__FNodeDefinitions@AINBNodeDefMgr@@YAXXZ DD 021H
	DD	imagerel ??__FNodeDefinitions@AINBNodeDefMgr@@YAXXZ
	DD	imagerel ??__FNodeDefinitions@AINBNodeDefMgr@@YAXXZ+22
	DD	imagerel $unwind$??__FNodeDefinitions@AINBNodeDefMgr@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??__FNodeDefinitions@AINBNodeDefMgr@@YAXXZ DD 020521H
	DD	067405H
	DD	imagerel ??__FNodeDefinitions@AINBNodeDefMgr@@YAXXZ
	DD	imagerel ??__FNodeDefinitions@AINBNodeDefMgr@@YAXXZ+22
	DD	imagerel $unwind$??__FNodeDefinitions@AINBNodeDefMgr@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__FNodeDefinitions@AINBNodeDefMgr@@YAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__FEXBFile@AINBNodeDefMgr@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??ReadString@AINBNodeDefMgr@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?ReadString@AINBNodeDefMgr@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@@Z DB 02H
	DB	'a', 03H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?ReadString@AINBNodeDefMgr@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??ReadString@AINBNodeDefMgr@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?ReadString@AINBNodeDefMgr@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?ReadString@AINBNodeDefMgr@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@@Z
	DD	imagerel $ip2state$?ReadString@AINBNodeDefMgr@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ReadString@AINBNodeDefMgr@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@@Z DD 060f11H
	DD	0b640fH
	DD	0a340fH
	DD	0700b520fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?ReadString@AINBNodeDefMgr@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$40@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$35@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$52@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$57@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?Initialize@AINBNodeDefMgr@@YAXXZ DB '@'
	DB	0b8H
	DB	00H
	DB	'&'
	DB	02H
	DB	01aH
	DB	06H
	DB	'5', 02H
	DB	08H
	DB	'!', 02H
	DB	0aH
	DB	'$'
	DB	08H
	DB	088H
	DB	0cH
	DB	0cdH, 02H
	DB	0eH
	DB	'Q', 08H
	DB	010H
	DB	01H, 09H
	DB	02H
	DB	089H, 07H
	DB	010H
	DB	015H, 04H
	DB	0eH
	DB	019H, 08H
	DB	014H
	DB	0c1H, 04H
	DB	016H
	DB	'=', 02H
	DB	012H
	DB	088H
	DB	0eH
	DB	'5', 06H
	DB	01aH
	DB	0c1H, 04H
	DB	01cH
	DB	095H, 03H
	DB	018H
	DB	0e5H, 02H
	DB	0eH
	DB	0a1H, 03H
	DB	01eH
	DB	0acH
	DB	0eH
	DB	094H
	DB	01eH
	DB	0acH
	DB	0eH
	DB	'I', 0bH
	DB	0cH
	DB	'M', 06H
	DB	' '
	DB	0dcH
	DB	'"'
	DB	'('
	DB	'$'
	DB	'.'
	DB	'&'
	DB	'$'
	DB	'$'
	DB	018H
	DB	'"'
	DB	09cH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?Initialize@AINBNodeDefMgr@@YAXXZ DB 026H
	DB	0aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0c0H
	DB	032H
	DD	imagerel ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	DB	0c1H
	DB	05H
	DB	072H
	DD	imagerel ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	DB	0c1H
	DB	05H
	DB	03aH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	01H
	DB	013H
	DB	03cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	021H
	DB	02H
	DB	072H
	DD	imagerel ??1?$vector@IV?$allocator@I@std@@@std@@QEAA@XZ
	DB	021H
	DB	014H
	DB	03aH
	DD	imagerel ??1NodeDef@AINBNodeDefMgr@@QEAA@XZ
	DB	0c1H
	DB	0dH
	DB	03aH
	DD	imagerel ??1InputParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ
	DB	01H
	DB	0aH
	DB	072H
	DD	imagerel ??1OutputEntry@AINBFile@@QEAA@XZ
	DB	0c1H
	DB	011H
	DB	03eH
	DD	imagerel ?dtor$57@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA
	DB	066H
	DD	imagerel ?dtor$52@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA
	DB	0faH
	DD	imagerel ??1ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ
	DB	041H
	DB	0cH
	DB	03eH
	DD	imagerel ?dtor$35@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA
	DB	066H
	DD	imagerel ?dtor$40@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA
	DB	05H
	DB	03H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	070H
	DB	0e5H
	DB	03H
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	0c1H
	DB	013H
	DB	042H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	061H
	DB	03H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0e1H
	DB	02H
	DB	03cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	021H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?Initialize@AINBNodeDefMgr@@YAXXZ DB 028H
	DD	imagerel $stateUnwindMap$?Initialize@AINBNodeDefMgr@@YAXXZ
	DD	imagerel $ip2state$?Initialize@AINBNodeDefMgr@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Initialize@AINBNodeDefMgr@@YAXXZ DD 0f3b19H
	DD	053682aH
	DD	0b07426H
	DD	0af6426H
	DD	0ae3426H
	DD	0a80126H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?Initialize@AINBNodeDefMgr@@YAXXZ
	DD	0522H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1NodeDef@AINBNodeDefMgr@@QEAA@XZ DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1InputParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4InputParam@NodeDef@AINBNodeDefMgr@@QEAAAEAU012@AEBU012@@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAAAEAU012@AEBU012@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4NodeDef@AINBNodeDefMgr@@QEAAAEAU01@AEBU01@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetNodeDefinition@AINBNodeDefMgr@@YAPEAUNodeDef@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 081201H
	DD	0a5412H
	DD	093412H
	DD	0e00e3212H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1AINBFile@@QEAA@XZ DB 02H
	DB	09dH, 04H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1AINBFile@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1AINBFile@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1AINBFile@@QEAA@XZ DD 040a19H
	DD	07340aH
	DD	07006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1AINBFile@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0InputParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z DB 08H
	DB	'*'
	DB	00H
	DB	01cH
	DB	02H
	DB	01cH
	DB	04H
	DB	01cH
	DB	06H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0InputParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z DB 06H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	060H
	DB	036H
	DD	imagerel ?dtor$1@?0???0InputParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???0InputParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0InputParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0InputParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z
	DD	imagerel $ip2state$??0InputParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0InputParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z DD 040f11H
	DD	07340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0InputParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z DB 06H
	DB	'*'
	DB	00H
	DB	'('
	DB	02H
	DB	01cH
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z DB 04H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	060H
	DB	036H
	DD	imagerel ?dtor$1@?0???0ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z
	DD	imagerel $ip2state$??0ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z DD 040f11H
	DD	07340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	012H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z DB '*'
	DB	0eeH
	DB	00H
	DB	'P'
	DB	02H
	DB	' '
	DB	00H
	DB	'd'
	DB	04H
	DB	'q', 04H
	DB	06H
	DB	'"'
	DB	08H
	DB	'"'
	DB	0aH
	DB	'j'
	DB	0cH
	DB	08dH, 02H
	DB	0eH
	DB	0d5H, 02H
	DB	0cH
	DB	'-', 05H
	DB	04H
	DB	'4'
	DB	06H
	DB	'"'
	DB	010H
	DB	'Q', 02H
	DB	014H
	DB	0eaH
	DB	016H
	DB	01cH
	DB	018H
	DB	'('
	DB	01aH
	DB	01cH
	DB	01cH
	DB	'N'
	DB	014H
	DB	'4'
	DB	012H
	DB	0edH, 04H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z DB 01cH
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	060H
	DB	03aH
	DD	imagerel ??1Node@AINBFile@@QEAA@XZ
	DB	01H
	DB	08H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0c1H
	DB	05H
	DB	03eH
	DD	imagerel ?dtor$67@?0??NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$68@?0??NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z@4HA
	DB	0c2H
	DD	imagerel ??1InputParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ
	DB	0c1H
	DB	05H
	DB	03aH
	DD	imagerel ??1InputEntry@AINBFile@@QEAA@XZ
	DB	01H
	DB	02H
	DB	0feH
	DD	imagerel ?dtor$24@?0??NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z@4HA
	DB	0b5H
	DB	02H
	DD	imagerel ??1ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ
	DB	0c1H
	DB	05H
	DB	042H
	DD	imagerel ??1ImmediateParameter@AINBFile@@QEAA@XZ
	DB	01H
	DB	02H
	DB	03cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	040H
	DB	036H
	DD	imagerel ?dtor$27@?0??NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$28@?0??NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$29@?0??NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$?NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z
	DD	imagerel $ip2state$?NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z DD 0b3019H
	DD	0a0341fH
	DD	096011fH
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z
	DD	04a2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?resize@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z DD 021H
	DD	imagerel $LN30
	DD	imagerel $LN30+50
	DD	imagerel $unwind$?resize@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?resize@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z DD 040a21H
	DD	07640aH
	DD	063405H
	DD	imagerel $LN30
	DD	imagerel $LN30+50
	DD	imagerel $unwind$?resize@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z DD 040b01H
	DD	08740bH
	DD	0e007320bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?resize@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@QEAAX_K@Z DD 021H
	DD	imagerel $LN39
	DD	imagerel $LN39+49
	DD	imagerel $unwind$?resize@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?resize@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@QEAAX_K@Z DD 040e21H
	DD	07540eH
	DD	063405H
	DD	imagerel $LN39
	DD	imagerel $LN39+49
	DD	imagerel $unwind$?resize@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@QEAAX_K@Z DD 040a01H
	DD	08640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?resize@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z DD 021H
	DD	imagerel $LN30
	DD	imagerel $LN30+50
	DD	imagerel $unwind$?resize@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?resize@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z DD 040a21H
	DD	07640aH
	DD	063405H
	DD	imagerel $LN30
	DD	imagerel $LN30+50
	DD	imagerel $unwind$?resize@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z DD 040b01H
	DD	08740bH
	DD	0e007320bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?resize@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z DD 021H
	DD	imagerel $LN30
	DD	imagerel $LN30+49
	DD	imagerel $unwind$?resize@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?resize@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z DD 040a21H
	DD	07640aH
	DD	063405H
	DD	imagerel $LN30
	DD	imagerel $LN30+49
	DD	imagerel $unwind$?resize@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??1?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ DD 021H
	DD	imagerel $LN50
	DD	imagerel $LN50+21
	DD	imagerel $unwind$??1?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??1?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ DD 020521H
	DD	076405H
	DD	imagerel $LN50
	DD	imagerel $LN50+21
	DD	imagerel $unwind$??1?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	036H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?reset@?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAAXXZ DD 021H
	DD	imagerel $LN32
	DD	imagerel $LN32+24
	DD	imagerel $unwind$?reset@?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?reset@?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAAXXZ DD 020521H
	DD	067405H
	DD	imagerel $LN32
	DD	imagerel $LN32+24
	DD	imagerel $unwind$?reset@?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reset@?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01bH
	DB	02dH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??1?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAA@XZ DD 021H
	DD	imagerel $LN18
	DD	imagerel $LN18+15
	DD	imagerel $unwind$??1?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??1?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAA@XZ DD 020521H
	DD	067405H
	DD	imagerel $LN18
	DD	imagerel $LN18+15
	DD	imagerel $unwind$??1?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	012H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pop_back@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??1?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEAA@XZ DD 021H
	DD	imagerel $LN52
	DD	imagerel $LN52+21
	DD	imagerel $unwind$??1?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??1?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEAA@XZ DD 020521H
	DD	077405H
	DD	imagerel $LN52
	DD	imagerel $LN52+21
	DD	imagerel $unwind$??1?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEAA@XZ DD 040a01H
	DD	08340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAAEAV01@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?resize@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAX_K@Z DD 021H
	DD	imagerel $LN81
	DD	imagerel $LN81+50
	DD	imagerel $unwind$?resize@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?resize@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAX_K@Z DD 041121H
	DD	087411H
	DD	075405H
	DD	imagerel $LN81
	DD	imagerel $LN81+50
	DD	imagerel $unwind$?resize@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAX_K@Z DD 040a01H
	DD	09340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?resize@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAX_K@Z DD 021H
	DD	imagerel $LN81
	DD	imagerel $LN81+50
	DD	imagerel $unwind$?resize@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?resize@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAX_K@Z DD 041121H
	DD	087411H
	DD	075405H
	DD	imagerel $LN81
	DD	imagerel $LN81+50
	DD	imagerel $unwind$?resize@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAX_K@Z DD 040a01H
	DD	09340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??0?$vector@IV?$allocator@I@std@@@std@@QEAA@_KAEBV?$allocator@I@1@@Z DD 021H
	DD	imagerel $LN51
	DD	imagerel $LN51+49
	DD	imagerel $unwind$??0?$vector@IV?$allocator@I@std@@@std@@QEAA@_KAEBV?$allocator@I@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??0?$vector@IV?$allocator@I@std@@@std@@QEAA@_KAEBV?$allocator@I@1@@Z DD 020521H
	DD	087405H
	DD	imagerel $LN51
	DD	imagerel $LN51+49
	DD	imagerel $unwind$??0?$vector@IV?$allocator@I@std@@@std@@QEAA@_KAEBV?$allocator@I@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@IV?$allocator@I@std@@@std@@QEAA@_KAEBV?$allocator@I@1@@Z DD 040a01H
	DD	09340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K_W@Z DD 020601H
	DD	070025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z DD 020021H
	DD	097400H
	DD	imagerel $LN86
	DD	imagerel $LN86+56
	DD	imagerel $unwind$?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z DD 021H
	DD	imagerel $LN86+56
	DD	imagerel $LN86+92
	DD	imagerel $chain$1$?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z DD 020521H
	DD	0bf405H
	DD	imagerel $LN86+56
	DD	imagerel $LN86+92
	DD	imagerel $chain$1$?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z DD 042421H
	DD	0ae424H
	DD	097405H
	DD	imagerel $LN86
	DD	imagerel $LN86+56
	DD	imagerel $unwind$?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z DD 040801H
	DD	060043208H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_1>@?1??push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z@QEBA@QEA_WQEB_W_K0@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z DD 021H
	DD	imagerel $LN43
	DD	imagerel $LN43+28
	DD	imagerel $unwind$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z DD 040e21H
	DD	09740eH
	DD	086405H
	DD	imagerel $LN43
	DD	imagerel $LN43+28
	DD	imagerel $unwind$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV23@QEB_W_K@Z@QEBA@QEA_W0101@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z DD 081001H
	DD	0c3410H
	DD	0f00c3210H
	DD	07008e00aH
	DD	050066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@$$QEAV01@@Z DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z DD 060d01H
	DD	0a340dH
	DD	0e009320dH
	DD	060067007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z DD 021H
	DD	imagerel $LN6
	DD	imagerel $LN6+15
	DD	imagerel $unwind$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z DD 020521H
	DD	063405H
	DD	imagerel $LN6
	DD	imagerel $LN6+15
	DD	imagerel $unwind$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Tidy@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ DD 021H
	DD	imagerel $LN47
	DD	imagerel $LN47+21
	DD	imagerel $unwind$?_Tidy@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Tidy@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ DD 020521H
	DD	076405H
	DD	imagerel $LN47
	DD	imagerel $LN47+21
	DD	imagerel $unwind$?_Tidy@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01bH
	DB	02dH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Decref@?$_Ptr_base@U_Recursive_dir_enum_impl@filesystem@std@@@std@@IEAAXXZ DD 021H
	DD	imagerel $LN16
	DD	imagerel $LN16+15
	DD	imagerel $unwind$?_Decref@?$_Ptr_base@U_Recursive_dir_enum_impl@filesystem@std@@@std@@IEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Decref@?$_Ptr_base@U_Recursive_dir_enum_impl@filesystem@std@@@std@@IEAAXXZ DD 020521H
	DD	067405H
	DD	imagerel $LN16
	DD	imagerel $LN16+15
	DD	imagerel $unwind$?_Decref@?$_Ptr_base@U_Recursive_dir_enum_impl@filesystem@std@@@std@@IEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Decref@?$_Ptr_base@U_Recursive_dir_enum_impl@filesystem@std@@@std@@IEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Tidy@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAXXZ DD 021H
	DD	imagerel $LN49
	DD	imagerel $LN49+21
	DD	imagerel $unwind$?_Tidy@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Tidy@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAXXZ DD 020521H
	DD	077405H
	DD	imagerel $LN49
	DD	imagerel $LN49+21
	DD	imagerel $unwind$?_Tidy@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAXXZ DD 040a01H
	DD	08340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Tidy@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXXZ DD 021H
	DD	imagerel $LN49
	DD	imagerel $LN49+21
	DD	imagerel $unwind$?_Tidy@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Tidy@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXXZ DD 020521H
	DD	077405H
	DD	imagerel $LN49
	DD	imagerel $LN49+21
	DD	imagerel $unwind$?_Tidy@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXXZ DD 040a01H
	DD	08340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Tidy@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXXZ DD 021H
	DD	imagerel $LN49
	DD	imagerel $LN49+21
	DD	imagerel $unwind$?_Tidy@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Tidy@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXXZ DD 020521H
	DD	077405H
	DD	imagerel $LN49
	DD	imagerel $LN49+21
	DD	imagerel $unwind$?_Tidy@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXXZ DD 040a01H
	DD	08340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z DD 081001H
	DD	0d3410H
	DD	0f00c3210H
	DD	07008e00aH
	DD	050066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_1>@?1??assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV23@QEB_W_K@Z@QEBA@QEA_W10@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@_K_W@Z DD 020601H
	DD	070025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV23@_K_W@Z@QEBA@QEA_WQEB_W001@Z DD 060d01H
	DD	08340dH
	DD	0e009320dH
	DD	060067007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Check_offset@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z DD 020021H
	DD	067400H
	DD	imagerel $LN50
	DD	imagerel $LN50+43
	DD	imagerel $unwind$?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z DD 041b21H
	DD	0a341bH
	DD	067405H
	DD	imagerel $LN50
	DD	imagerel $LN50+43
	DD	imagerel $unwind$?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD 021H
	DD	imagerel $LN36
	DD	imagerel $LN36+33
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD 020521H
	DD	0c6405H
	DD	imagerel $LN36
	DD	imagerel $LN36+33
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD 040801H
	DD	070045208H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@_KD@Z@QEBA@QEADQEBD00D@Z DD 040801H
	DD	070043208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?move@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?copy@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@QEAAXQEAUNodeDef@AINBNodeDefMgr@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@U_Find_file_handle@filesystem@std@@@std@@QEAAXQEAU_Find_file_handle@filesystem@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@QEAAXQEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAAXQEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAAXQEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?assign@?$_WChar_traits@_W@std@@SAPEA_WQEA_W_K_W@Z DD 021H
	DD	imagerel $LN37
	DD	imagerel $LN37+12
	DD	imagerel $unwind$?assign@?$_WChar_traits@_W@std@@SAPEA_WQEA_W_K_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?assign@?$_WChar_traits@_W@std@@SAPEA_WQEA_W_K_W@Z DD 020421H
	DD	07404H
	DD	imagerel $LN37
	DD	imagerel $LN37+12
	DD	imagerel $unwind$?assign@?$_WChar_traits@_W@std@@SAPEA_WQEA_W_K_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$_WChar_traits@_W@std@@SAPEA_WQEA_W_K_W@Z DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?assign@?$_Char_traits@_WG@std@@SAPEA_WQEA_W_K_W@Z DD 021H
	DD	imagerel $LN25
	DD	imagerel $LN25+12
	DD	imagerel $unwind$?assign@?$_Char_traits@_WG@std@@SAPEA_WQEA_W_K_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?assign@?$_Char_traits@_WG@std@@SAPEA_WQEA_W_K_W@Z DD 020421H
	DD	07404H
	DD	imagerel $LN25
	DD	imagerel $LN25+12
	DD	imagerel $unwind$?assign@?$_Char_traits@_WG@std@@SAPEA_WQEA_W_K_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$_Char_traits@_WG@std@@SAPEA_WQEA_W_K_W@Z DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0???$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV?$allocator@D@2@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV?$allocator@D@2@@Z DB 02H
	DB	'%', 02H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV?$allocator@D@2@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$2@?0???$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV?$allocator@D@2@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV?$allocator@D@2@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV?$allocator@D@2@@Z
	DD	imagerel $ip2state$??$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV?$allocator@D@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV?$allocator@D@2@@Z DD 081211H
	DD	0e5412H
	DD	0c3412H
	DD	0e00e7212H
	DD	0600b700cH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV?$allocator@D@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$?0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@2@W4format@012@@Z DD 021H
	DD	imagerel $LN75
	DD	imagerel $LN75+112
	DD	imagerel $unwind$??$?0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@2@W4format@012@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$?0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@2@W4format@012@@Z DD 020521H
	DD	0b7405H
	DD	imagerel $LN75
	DD	imagerel $LN75+112
	DD	imagerel $unwind$??$?0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@2@W4format@012@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@2@W4format@012@@Z DD 081301H
	DD	0d5413H
	DD	0c3413H
	DD	0f00f5213H
	DD	0600be00dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?_0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@path@filesystem@std@@QEAAAEAV012@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@2@@Z DB 04H
	DB	01cH
	DB	00H
	DB	018H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?_0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@path@filesystem@std@@QEAAAEAV012@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@2@@Z DB 02H
	DB	0aH
	DD	imagerel ??1path@filesystem@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?_0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@path@filesystem@std@@QEAAAEAV012@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@2@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$?_0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@path@filesystem@std@@QEAAAEAV012@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@2@@Z
	DD	imagerel $ip2state$??$?_0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@path@filesystem@std@@QEAAAEAV012@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?_0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@path@filesystem@std@@QEAAAEAV012@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@2@@Z DD 020611H
	DD	030027206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?_0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@path@filesystem@std@@QEAAAEAV012@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Convert_wide_to_narrow_replace_chars@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Convert_wide_to_narrow_replace_chars@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z DB 02H
	DB	0f4H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Convert_wide_to_narrow_replace_chars@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Convert_wide_to_narrow_replace_chars@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Convert_wide_to_narrow_replace_chars@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Convert_wide_to_narrow_replace_chars@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z
	DD	imagerel $ip2state$??$_Convert_wide_to_narrow_replace_chars@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Convert_wide_to_narrow_replace_chars@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z DD 081711H
	DD	0e5417H
	DD	0d3417H
	DD	0e0137217H
	DD	060107011H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Convert_wide_to_narrow_replace_chars@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0109H
	DW	011bH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$4@?0???$_Initialize_dir_enum@U_Recursive_dir_enum_impl@filesystem@std@@@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@2@AEBVpath@12@W4directory_options@12@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Initialize_dir_enum@U_Recursive_dir_enum_impl@filesystem@std@@@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@2@AEBVpath@12@W4directory_options@12@@Z DB 0aH
	DB	'n'
	DB	00H
	DB	'F'
	DB	04H
	DB	09aH
	DB	06H
	DB	'n'
	DB	08H
	DB	0ecH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Initialize_dir_enum@U_Recursive_dir_enum_impl@filesystem@std@@@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@2@AEBVpath@12@W4directory_options@12@@Z DB 08H
	DB	0aH
	DD	imagerel ??1path@filesystem@std@@QEAA@XZ
	DB	060H
	DB	036H
	DD	imagerel ?dtor$3@?0???$_Initialize_dir_enum@U_Recursive_dir_enum_impl@filesystem@std@@@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@2@AEBVpath@12@W4directory_options@12@@Z@4HA
	DB	062H
	DD	imagerel ??1_Creator@_Dir_enum_impl@filesystem@std@@QEAA@XZ
	DB	060H
	DB	036H
	DD	imagerel ?dtor$4@?0???$_Initialize_dir_enum@U_Recursive_dir_enum_impl@filesystem@std@@@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@2@AEBVpath@12@W4directory_options@12@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Initialize_dir_enum@U_Recursive_dir_enum_impl@filesystem@std@@@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@2@AEBVpath@12@W4directory_options@12@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Initialize_dir_enum@U_Recursive_dir_enum_impl@filesystem@std@@@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@2@AEBVpath@12@W4directory_options@12@@Z
	DD	imagerel $ip2state$??$_Initialize_dir_enum@U_Recursive_dir_enum_impl@filesystem@std@@@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@2@AEBVpath@12@W4directory_options@12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Initialize_dir_enum@U_Recursive_dir_enum_impl@filesystem@std@@@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@2@AEBVpath@12@W4directory_options@12@@Z DD 092c19H
	DD	060341bH
	DD	058011bH
	DD	0e00af00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Initialize_dir_enum@U_Recursive_dir_enum_impl@filesystem@std@@@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@2@AEBVpath@12@W4directory_options@12@@Z
	DD	02b2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$3@?0???$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@W4format@012@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@W4format@012@@Z DB 02H
	DB	'9', 02H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@W4format@012@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$3@?0???$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@W4format@012@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@W4format@012@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@W4format@012@@Z
	DD	imagerel $ip2state$??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@W4format@012@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@W4format@012@@Z DD 081211H
	DD	0e5412H
	DD	0d3412H
	DD	0e00e7212H
	DD	0600b700cH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@W4format@012@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Resize@U_Value_init_tag@std@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN28
	DD	imagerel $LN28+50
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040a21H
	DD	07640aH
	DD	063405H
	DD	imagerel $LN28
	DD	imagerel $LN28+50
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040b01H
	DD	08740bH
	DD	0e007320bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Resize@U_Value_init_tag@std@@@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN37
	DD	imagerel $LN37+49
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040e21H
	DD	07540eH
	DD	063405H
	DD	imagerel $LN37
	DD	imagerel $LN37+49
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040a01H
	DD	08640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Resize@U_Value_init_tag@std@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN28
	DD	imagerel $LN28+50
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040a21H
	DD	07640aH
	DD	063405H
	DD	imagerel $LN28
	DD	imagerel $LN28+50
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040b01H
	DD	08740bH
	DD	0e007320bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Resize@U_Value_init_tag@std@@@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN28
	DD	imagerel $LN28+49
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040a21H
	DD	07640aH
	DD	063405H
	DD	imagerel $LN28
	DD	imagerel $LN28+49
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Assign_counted_range@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_K@Z DD 021H
	DD	imagerel $LN120
	DD	imagerel $LN120+194
	DD	imagerel $unwind$??$_Assign_counted_range@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Assign_counted_range@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_K@Z DD 020021H
	DD	045400H
	DD	imagerel $LN120
	DD	imagerel $LN120+194
	DD	imagerel $unwind$??$_Assign_counted_range@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Assign_counted_range@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_K@Z DD 020521H
	DD	045405H
	DD	imagerel $LN120
	DD	imagerel $LN120+194
	DD	imagerel $unwind$??$_Assign_counted_range@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Assign_counted_range@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_K@Z DD 050a01H
	DD	0e006420aH
	DD	060037004H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN79
	DD	imagerel $LN79+50
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 041121H
	DD	087411H
	DD	075405H
	DD	imagerel $LN79
	DD	imagerel $LN79+50
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040a01H
	DD	09340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Assign_counted_range@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@_K@Z DD 080f01H
	DD	0f00b320fH
	DD	0c007e009H
	DD	060047005H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN79
	DD	imagerel $LN79+50
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 041121H
	DD	087411H
	DD	075405H
	DD	imagerel $LN79
	DD	imagerel $LN79+50
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040a01H
	DD	09340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Assign_counted_range@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@_K@Z DD 020021H
	DD	04f400H
	DD	imagerel $LN116
	DD	imagerel $LN116+59
	DD	imagerel $unwind$??$_Assign_counted_range@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Assign_counted_range@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@_K@Z DD 021H
	DD	imagerel $LN116
	DD	imagerel $LN116+59
	DD	imagerel $unwind$??$_Assign_counted_range@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Assign_counted_range@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@_K@Z DD 020021H
	DD	04f400H
	DD	imagerel $LN116
	DD	imagerel $LN116+59
	DD	imagerel $unwind$??$_Assign_counted_range@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Assign_counted_range@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@_K@Z DD 020521H
	DD	04f405H
	DD	imagerel $LN116
	DD	imagerel $LN116+59
	DD	imagerel $unwind$??$_Assign_counted_range@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Assign_counted_range@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@_K@Z DD 070d01H
	DD	0e009420dH
	DD	07005c007H
	DD	050036004H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Construct_n@$$V@?$vector@IV?$allocator@I@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN45
	DD	imagerel $LN45+36
	DD	imagerel $unwind$??$_Construct_n@$$V@?$vector@IV?$allocator@I@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Construct_n@$$V@?$vector@IV?$allocator@I@std@@@std@@AEAAX_K@Z DD 020521H
	DD	087405H
	DD	imagerel $LN45
	DD	imagerel $LN45+36
	DD	imagerel $unwind$??$_Construct_n@$$V@?$vector@IV?$allocator@I@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_n@$$V@?$vector@IV?$allocator@I@std@@@std@@AEAAX_K@Z DD 040f01H
	DD	09340fH
	DD	0600b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z@_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAX_W@Z@_W@Z DD 021H
	DD	imagerel $LN74
	DD	imagerel $LN74+48
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z@_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAX_W@Z@_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z@_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAX_W@Z@_W@Z DD 021H
	DD	imagerel $LN74+48
	DD	imagerel $LN74+62
	DD	imagerel $chain$1$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z@_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAX_W@Z@_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z@_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAX_W@Z@_W@Z DD 020521H
	DD	04c405H
	DD	imagerel $LN74+48
	DD	imagerel $LN74+62
	DD	imagerel $chain$1$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z@_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAX_W@Z@_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z@_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAX_W@Z@_W@Z DD 040e21H
	DD	0c640eH
	DD	0b5405H
	DD	imagerel $LN74
	DD	imagerel $LN74+48
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z@_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAX_W@Z@_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z@_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAX_W@Z@_W@Z DD 050b01H
	DD	0f007420bH
	DD	07003e005H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEB_W0@Z@PEB_W_K@Z DD 021H
	DD	imagerel $LN100
	DD	imagerel $LN100+58
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEB_W0@Z@PEB_W_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEB_W0@Z@PEB_W_K@Z DD 081421H
	DD	06f414H
	DD	07c410H
	DD	08640cH
	DD	0105404H
	DD	imagerel $LN100
	DD	imagerel $LN100+58
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEB_W0@Z@PEB_W_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEB_W0@Z@PEB_W_K@Z DD 050d01H
	DD	0e009820dH
	DD	07005d007H
	DD	03004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z DD 021H
	DD	imagerel $LN44
	DD	imagerel $LN44+87
	DD	imagerel $unwind$??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z DD 020521H
	DD	047405H
	DD	imagerel $LN44
	DD	imagerel $LN44+87
	DD	imagerel $unwind$??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z DD 050a01H
	DD	0e006420aH
	DD	050036004H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct@$01PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z DD 060c01H
	DD	0b340cH
	DD	07008320cH
	DD	050066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$_Reallocate_grow_by@V<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??reserve@01@QEAAX0@Z@@Z DD 021H
	DD	imagerel $LN104
	DD	imagerel $LN104+41
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??reserve@01@QEAAX0@Z@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Reallocate_grow_by@V<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??reserve@01@QEAAX0@Z@@Z DD 060021H
	DD	04f400H
	DD	057400H
	DD	0c5400H
	DD	imagerel $LN104
	DD	imagerel $LN104+41
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??reserve@01@QEAAX0@Z@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Reallocate_grow_by@V<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??reserve@01@QEAAX0@Z@@Z DD 064521H
	DD	057445H
	DD	04f40eH
	DD	0c5405H
	DD	imagerel $LN104
	DD	imagerel $LN104+41
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??reserve@01@QEAAX0@Z@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??reserve@01@QEAAX0@Z@@Z DD 040901H
	DD	0e0055209H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_range@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@YAXPEAUNodeDef@AINBNodeDefMgr@@QEAU12@AEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@0@@Z DD 040f01H
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_range@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@@std@@YAXPEAU_Find_file_handle@filesystem@0@QEAU120@AEAV?$allocator@U_Find_file_handle@filesystem@std@@@0@@Z DD 040f01H
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_range@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YAXPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z DD 040f01H
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_range@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YAXPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z DD 040f01H
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEB_W0@Z@PEB_W@Z DD 021H
	DD	imagerel $LN60
	DD	imagerel $LN60+43
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEB_W0@Z@PEB_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEB_W0@Z@PEB_W@Z DD 040021H
	DD	046400H
	DD	0c5400H
	DD	imagerel $LN60
	DD	imagerel $LN60+43
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEB_W0@Z@PEB_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEB_W0@Z@PEB_W@Z DD 040a21H
	DD	04640aH
	DD	0c5405H
	DD	imagerel $LN60
	DD	imagerel $LN60+43
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEB_W0@Z@PEB_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEB_W0@Z@PEB_W@Z DD 050b01H
	DD	0f007420bH
	DD	07003e005H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@_K_W@Z@_K_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@0_W@Z@_K_W@Z DD 021H
	DD	imagerel $LN141
	DD	imagerel $LN141+47
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@_K_W@Z@_K_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@0_W@Z@_K_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@_K_W@Z@_K_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@0_W@Z@_K_W@Z DD 061e21H
	DD	04641eH
	DD	05540eH
	DD	063405H
	DD	imagerel $LN141
	DD	imagerel $LN141+47
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@_K_W@Z@_K_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@0_W@Z@_K_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@_K_W@Z@_K_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@0_W@Z@_K_W@Z DD 050c01H
	DD	0f008620cH
	DD	0c004e006H
	DD	07002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KD@Z@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@0D@Z@_KD@Z DD 021H
	DD	imagerel $LN151
	DD	imagerel $LN151+46
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KD@Z@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@0D@Z@_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KD@Z@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@0D@Z@_KD@Z DD 080021H
	DD	04e400H
	DD	05d400H
	DD	067400H
	DD	0e5400H
	DD	imagerel $LN151
	DD	imagerel $LN151+46
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KD@Z@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@0D@Z@_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KD@Z@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@0D@Z@_KD@Z DD 084e21H
	DD	04e44eH
	DD	067445H
	DD	05d411H
	DD	0e5405H
	DD	imagerel $LN151
	DD	imagerel $LN151+46
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KD@Z@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@0D@Z@_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KD@Z@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@0D@Z@_KD@Z DD 050b01H
	DD	0f007620bH
	DD	06003c005H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Creator@_Dir_enum_impl@filesystem@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAAEAV01@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAAEAV01@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	039H
	DB	04bH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??4?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD 021H
	DD	imagerel $LN37
	DD	imagerel $LN37+45
	DD	imagerel $unwind$??4?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??4?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD 020521H
	DD	066405H
	DD	imagerel $LN37
	DD	imagerel $LN37+45
	DD	imagerel $unwind$??4?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Clear_and_reserve_geometric@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?_Clear_and_reserve_geometric@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN63
	DD	imagerel $LN63+30
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?_Clear_and_reserve_geometric@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z DD 040021H
	DD	0b5400H
	DD	0a3400H
	DD	imagerel $LN63
	DD	imagerel $LN63+30
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?_Clear_and_reserve_geometric@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN63+30
	DD	imagerel $LN63+101
	DD	imagerel $chain$1$?_Clear_and_reserve_geometric@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Clear_and_reserve_geometric@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z DD 020521H
	DD	046405H
	DD	imagerel $LN63+30
	DD	imagerel $LN63+101
	DD	imagerel $chain$1$?_Clear_and_reserve_geometric@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Clear_and_reserve_geometric@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z DD 041721H
	DD	0b5417H
	DD	0a3405H
	DD	imagerel $LN63
	DD	imagerel $LN63+30
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Clear_and_reserve_geometric@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z DD 030801H
	DD	0e0044208H
	DD	07002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?_Clear_and_reserve_geometric@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN63
	DD	imagerel $LN63+30
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?_Clear_and_reserve_geometric@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z DD 040021H
	DD	0b5400H
	DD	0a3400H
	DD	imagerel $LN63
	DD	imagerel $LN63+30
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?_Clear_and_reserve_geometric@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN63+30
	DD	imagerel $LN63+101
	DD	imagerel $chain$1$?_Clear_and_reserve_geometric@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Clear_and_reserve_geometric@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z DD 020521H
	DD	046405H
	DD	imagerel $LN63+30
	DD	imagerel $LN63+101
	DD	imagerel $chain$1$?_Clear_and_reserve_geometric@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Clear_and_reserve_geometric@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z DD 041721H
	DD	0b5417H
	DD	0a3405H
	DD	imagerel $LN63
	DD	imagerel $LN63+30
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Clear_and_reserve_geometric@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z DD 030801H
	DD	0e0044208H
	DD	07002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_raw@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_raw@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_raw@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@QEAAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???$_Convert_wide_to@U?$char_traits@D@std@@V?$allocator@D@2@D@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Convert_wide_to@U?$char_traits@D@std@@V?$allocator@D@2@D@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z DB 02H
	DB	'E', 02H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Convert_wide_to@U?$char_traits@D@std@@V?$allocator@D@2@D@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$1@?0???$_Convert_wide_to@U?$char_traits@D@std@@V?$allocator@D@2@D@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Convert_wide_to@U?$char_traits@D@std@@V?$allocator@D@2@D@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Convert_wide_to@U?$char_traits@D@std@@V?$allocator@D@2@D@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z
	DD	imagerel $ip2state$??$_Convert_wide_to@U?$char_traits@D@std@@V?$allocator@D@2@D@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Convert_wide_to@U?$char_traits@D@std@@V?$allocator@D@2@D@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z DD 081211H
	DD	0f5412H
	DD	0e3412H
	DD	0e00e7212H
	DD	0600b700cH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Convert_wide_to@U?$char_traits@D@std@@V?$allocator@D@2@D@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Convert_Source_to_wide@V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@1@U_Normal_conversion@01@@Z DD 021H
	DD	imagerel $LN71
	DD	imagerel $LN71+112
	DD	imagerel $unwind$??$_Convert_Source_to_wide@V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@1@U_Normal_conversion@01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Convert_Source_to_wide@V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@1@U_Normal_conversion@01@@Z DD 020521H
	DD	0b7405H
	DD	imagerel $LN71
	DD	imagerel $LN71+112
	DD	imagerel $unwind$??$_Convert_Source_to_wide@V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@1@U_Normal_conversion@01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Convert_Source_to_wide@V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@1@U_Normal_conversion@01@@Z DD 081301H
	DD	0d5413H
	DD	0c3413H
	DD	0f00f5213H
	DD	0600be00dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$make_shared@U_Recursive_dir_enum_impl@filesystem@std@@U_Creator@_Dir_enum_impl@23@AEBW4directory_options@23@@std@@YA?AV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@0@$$QEAU_Creator@_Dir_enum_impl@filesystem@0@AEBW4directory_options@40@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$make_shared@U_Recursive_dir_enum_impl@filesystem@std@@U_Creator@_Dir_enum_impl@23@AEBW4directory_options@23@@std@@YA?AV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@0@$$QEAU_Creator@_Dir_enum_impl@filesystem@0@AEBW4directory_options@40@@Z DB 04H
	DB	'V'
	DB	00H
	DB	'n'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$make_shared@U_Recursive_dir_enum_impl@filesystem@std@@U_Creator@_Dir_enum_impl@23@AEBW4directory_options@23@@std@@YA?AV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@0@$$QEAU_Creator@_Dir_enum_impl@filesystem@0@AEBW4directory_options@40@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$make_shared@U_Recursive_dir_enum_impl@filesystem@std@@U_Creator@_Dir_enum_impl@23@AEBW4directory_options@23@@std@@YA?AV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@0@$$QEAU_Creator@_Dir_enum_impl@filesystem@0@AEBW4directory_options@40@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$make_shared@U_Recursive_dir_enum_impl@filesystem@std@@U_Creator@_Dir_enum_impl@23@AEBW4directory_options@23@@std@@YA?AV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@0@$$QEAU_Creator@_Dir_enum_impl@filesystem@0@AEBW4directory_options@40@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$make_shared@U_Recursive_dir_enum_impl@filesystem@std@@U_Creator@_Dir_enum_impl@23@AEBW4directory_options@23@@std@@YA?AV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@0@$$QEAU_Creator@_Dir_enum_impl@filesystem@0@AEBW4directory_options@40@@Z
	DD	imagerel $ip2state$??$make_shared@U_Recursive_dir_enum_impl@filesystem@std@@U_Creator@_Dir_enum_impl@23@AEBW4directory_options@23@@std@@YA?AV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@0@$$QEAU_Creator@_Dir_enum_impl@filesystem@0@AEBW4directory_options@40@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$make_shared@U_Recursive_dir_enum_impl@filesystem@std@@U_Creator@_Dir_enum_impl@23@AEBW4directory_options@23@@std@@YA?AV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@0@$$QEAU_Creator@_Dir_enum_impl@filesystem@0@AEBW4directory_options@40@@Z DD 0a1d11H
	DD	0d641dH
	DD	0c541dH
	DD	0b341dH
	DD	0f019521dH
	DD	07015e017H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$make_shared@U_Recursive_dir_enum_impl@filesystem@std@@U_Creator@_Dir_enum_impl@23@AEBW4directory_options@23@@std@@YA?AV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@0@$$QEAU_Creator@_Dir_enum_impl@filesystem@0@AEBW4directory_options@40@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0???$_Convert_Source_to_wide@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@U_Normal_conversion@01@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Convert_Source_to_wide@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@U_Normal_conversion@01@@Z DB 02H
	DB	'%', 02H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Convert_Source_to_wide@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@U_Normal_conversion@01@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$2@?0???$_Convert_Source_to_wide@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@U_Normal_conversion@01@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Convert_Source_to_wide@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@U_Normal_conversion@01@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Convert_Source_to_wide@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@U_Normal_conversion@01@@Z
	DD	imagerel $ip2state$??$_Convert_Source_to_wide@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@U_Normal_conversion@01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Convert_Source_to_wide@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@U_Normal_conversion@01@@Z DD 081211H
	DD	0e5412H
	DD	0d3412H
	DD	0e00e7212H
	DD	0600b700cH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Convert_Source_to_wide@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@U_Normal_conversion@01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_range@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAXPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z DD 040f01H
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN21
	DD	imagerel $LN21+50
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040a21H
	DD	07e40aH
	DD	065405H
	DD	imagerel $LN21
	DD	imagerel $LN21+50
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN21
	DD	imagerel $LN21+40
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 043821H
	DD	07f438H
	DD	06e405H
	DD	imagerel $LN21
	DD	imagerel $LN21+40
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_range@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAXPEAUInputParam@NodeDef@AINBNodeDefMgr@@QEAU123@AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z DD 040f01H
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN21
	DD	imagerel $LN21+50
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040a21H
	DD	07e40aH
	DD	065405H
	DD	imagerel $LN21
	DD	imagerel $LN21+50
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN101
	DD	imagerel $LN101+56
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 020021H
	DD	04f400H
	DD	imagerel $LN101+56
	DD	imagerel $LN101+74
	DD	imagerel $chain$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 042321H
	DD	04f423H
	DD	0be405H
	DD	imagerel $LN101+56
	DD	imagerel $LN101+74
	DD	imagerel $chain$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 041221H
	DD	0a7412H
	DD	083405H
	DD	imagerel $LN101
	DD	imagerel $LN101+56
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 030701H
	DD	060034207H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_value_construct_n@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUNodeDef@AINBNodeDefMgr@@PEAU12@_KAEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@0@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$??$_Emplace_reallocate@U_Find_file_handle@filesystem@std@@@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAPEAU_Find_file_handle@filesystem@1@QEAU231@$$QEAU231@@Z DD 060021H
	DD	04e400H
	DD	05c400H
	DD	067400H
	DD	imagerel $LN255
	DD	imagerel $LN255+69
	DD	imagerel $unwind$??$_Emplace_reallocate@U_Find_file_handle@filesystem@std@@@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAPEAU_Find_file_handle@filesystem@1@QEAU231@$$QEAU231@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$_Emplace_reallocate@U_Find_file_handle@filesystem@std@@@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAPEAU_Find_file_handle@filesystem@1@QEAU231@$$QEAU231@@Z DD 021H
	DD	imagerel $LN255
	DD	imagerel $LN255+69
	DD	imagerel $unwind$??$_Emplace_reallocate@U_Find_file_handle@filesystem@std@@@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAPEAU_Find_file_handle@filesystem@1@QEAU231@$$QEAU231@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Emplace_reallocate@U_Find_file_handle@filesystem@std@@@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAPEAU_Find_file_handle@filesystem@1@QEAU231@$$QEAU231@@Z DD 060021H
	DD	04e400H
	DD	05c400H
	DD	067400H
	DD	imagerel $LN255
	DD	imagerel $LN255+69
	DD	imagerel $unwind$??$_Emplace_reallocate@U_Find_file_handle@filesystem@std@@@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAPEAU_Find_file_handle@filesystem@1@QEAU231@$$QEAU231@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Emplace_reallocate@U_Find_file_handle@filesystem@std@@@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAPEAU_Find_file_handle@filesystem@1@QEAU231@$$QEAU231@@Z DD 062021H
	DD	04e420H
	DD	05c40eH
	DD	067405H
	DD	imagerel $LN255
	DD	imagerel $LN255+69
	DD	imagerel $unwind$??$_Emplace_reallocate@U_Find_file_handle@filesystem@std@@@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAPEAU_Find_file_handle@filesystem@1@QEAU231@$$QEAU231@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@U_Find_file_handle@filesystem@std@@@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAPEAU_Find_file_handle@filesystem@1@QEAU231@$$QEAU231@@Z DD 050a01H
	DD	0f006620aH
	DD	050036004H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy_n@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@_K0AEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@0@@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove_n@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@_K0@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_n_unchecked4@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_KPEAW4123@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@_K0@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Emplace_reallocate@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@QEAW4234@$$QEAW4234@@Z DD 040021H
	DD	0df400H
	DD	0c7400H
	DD	imagerel $LN118
	DD	imagerel $LN118+63
	DD	imagerel $unwind$??$_Emplace_reallocate@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@QEAW4234@$$QEAW4234@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Emplace_reallocate@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@QEAW4234@$$QEAW4234@@Z DD 021H
	DD	imagerel $LN118
	DD	imagerel $LN118+63
	DD	imagerel $unwind$??$_Emplace_reallocate@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@QEAW4234@$$QEAW4234@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Emplace_reallocate@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@QEAW4234@$$QEAW4234@@Z DD 040d21H
	DD	0df40dH
	DD	0c7405H
	DD	imagerel $LN118
	DD	imagerel $LN118+63
	DD	imagerel $unwind$??$_Emplace_reallocate@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@QEAW4234@$$QEAW4234@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@QEAW4234@$$QEAW4234@@Z DD 060c01H
	DD	0e008320cH
	DD	06004c006H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 0a1801H
	DD	0b6418H
	DD	0a5418H
	DD	093418H
	DD	0f0143218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_copy_n@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z DB 08H
	DB	'}', 02H
	DB	02H
	DB	098H
	DB	06H
	DB	09aH
	DB	00H
	DB	'F'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_copy_n@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z DB 06H
	DB	0aH
	DD	imagerel ??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAA@XZ
	DB	080H
	DB	032H
	DD	imagerel ??1?$_Tidy_guard@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@XZ
	DB	040H
	DB	032H
	DD	imagerel ??1?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ
	DB	050H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Uninitialized_copy_n@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_copy_n@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z
	DD	imagerel $ip2state$??$_Uninitialized_copy_n@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy_n@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z DD 0c2b19H
	DD	015641cH
	DD	014541cH
	DD	013341cH
	DD	0f018b21cH
	DD	0d014e016H
	DD	07010c012H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Uninitialized_copy_n@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z
	DD	05aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Copy_n_unchecked4@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@_KPEAV12@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0@Z DD 021H
	DD	imagerel $LN18
	DD	imagerel $LN18+29
	DD	imagerel $unwind$??$_Copy_n_unchecked4@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@_KPEAV12@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Copy_n_unchecked4@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@_KPEAV12@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0@Z DD 020521H
	DD	065405H
	DD	imagerel $LN18
	DD	imagerel $LN18+29
	DD	imagerel $unwind$??$_Copy_n_unchecked4@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@_KPEAV12@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_n_unchecked4@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@_KPEAV12@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0@Z DD 060f01H
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 0a1801H
	DD	0b6418H
	DD	0a5418H
	DD	093418H
	DD	0f0143218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_copy_n@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z DB 0cH
	DB	'}', 02H
	DB	02H
	DB	0baH
	DB	06H
	DB	'&'
	DB	08H
	DB	01cH
	DB	0aH
	DB	098H
	DB	00H
	DB	'F'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_copy_n@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z DB 0aH
	DB	0aH
	DD	imagerel ??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAA@XZ
	DB	090H
	DB	032H
	DD	imagerel ??1?$_Tidy_guard@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@XZ
	DB	040H
	DB	032H
	DD	imagerel ??1?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ
	DB	060H
	DB	034H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	050H
	DB	036H
	DD	imagerel ?dtor$4@?0???$_Uninitialized_copy_n@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Uninitialized_copy_n@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_copy_n@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z
	DD	imagerel $ip2state$??$_Uninitialized_copy_n@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy_n@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z DD 0c2b19H
	DD	017641cH
	DD	016541cH
	DD	015341cH
	DD	0f018d21cH
	DD	0d014e016H
	DD	07010c012H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Uninitialized_copy_n@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z
	DD	062H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Copy_n_unchecked4@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@_KPEAV12@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0@Z DD 021H
	DD	imagerel $LN18
	DD	imagerel $LN18+29
	DD	imagerel $unwind$??$_Copy_n_unchecked4@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@_KPEAV12@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Copy_n_unchecked4@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@_KPEAV12@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0@Z DD 020521H
	DD	065405H
	DD	imagerel $LN18
	DD	imagerel $LN18+29
	DD	imagerel $unwind$??$_Copy_n_unchecked4@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@_KPEAV12@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_n_unchecked4@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@_KPEAV12@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0@Z DD 060f01H
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@$$QEAV21@@Z DD 021H
	DD	imagerel $LN65
	DD	imagerel $LN65+74
	DD	imagerel $unwind$??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@$$QEAV21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@$$QEAV21@@Z DD 020521H
	DD	085405H
	DD	imagerel $LN65
	DD	imagerel $LN65+74
	DD	imagerel $unwind$??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@$$QEAV21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@$$QEAV21@@Z DD 081301H
	DD	0a6413H
	DD	093413H
	DD	0f00f3213H
	DD	0700be00dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Assign_counted_range@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z DD 020021H
	DD	04c400H
	DD	imagerel $LN131
	DD	imagerel $LN131+59
	DD	imagerel $unwind$??$_Assign_counted_range@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Assign_counted_range@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z DD 021H
	DD	imagerel $LN131
	DD	imagerel $LN131+59
	DD	imagerel $unwind$??$_Assign_counted_range@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Assign_counted_range@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z DD 020021H
	DD	04c400H
	DD	imagerel $LN131
	DD	imagerel $LN131+59
	DD	imagerel $unwind$??$_Assign_counted_range@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Assign_counted_range@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z DD 020521H
	DD	04c405H
	DD	imagerel $LN131
	DD	imagerel $LN131+59
	DD	imagerel $unwind$??$_Assign_counted_range@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Assign_counted_range@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z DD 070d01H
	DD	0f009420dH
	DD	07005e007H
	DD	050036004H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Assign_counted_range@PEAUInputParam@NodeDef@AINBNodeDefMgr@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z DD 020021H
	DD	06c400H
	DD	imagerel $LN143
	DD	imagerel $LN143+59
	DD	imagerel $unwind$??$_Assign_counted_range@PEAUInputParam@NodeDef@AINBNodeDefMgr@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Assign_counted_range@PEAUInputParam@NodeDef@AINBNodeDefMgr@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z DD 021H
	DD	imagerel $LN143
	DD	imagerel $LN143+59
	DD	imagerel $unwind$??$_Assign_counted_range@PEAUInputParam@NodeDef@AINBNodeDefMgr@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Assign_counted_range@PEAUInputParam@NodeDef@AINBNodeDefMgr@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z DD 020021H
	DD	06c400H
	DD	imagerel $LN143
	DD	imagerel $LN143+59
	DD	imagerel $unwind$??$_Assign_counted_range@PEAUInputParam@NodeDef@AINBNodeDefMgr@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Assign_counted_range@PEAUInputParam@NodeDef@AINBNodeDefMgr@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z DD 020521H
	DD	06c405H
	DD	imagerel $LN143
	DD	imagerel $LN143+59
	DD	imagerel $unwind$??$_Assign_counted_range@PEAUInputParam@NodeDef@AINBNodeDefMgr@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Assign_counted_range@PEAUInputParam@NodeDef@AINBNodeDefMgr@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z DD 070d01H
	DD	0f009620dH
	DD	07005e007H
	DD	050036004H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G_Find_file_handle@filesystem@std@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAA@XZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAA@XZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Uninitialized_backout_al@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Destroy@?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@EEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Change_array@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K1@Z DD 021H
	DD	imagerel $LN47
	DD	imagerel $LN47+39
	DD	imagerel $unwind$?_Change_array@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Change_array@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K1@Z DD 020521H
	DD	097405H
	DD	imagerel $LN47
	DD	imagerel $LN47+39
	DD	imagerel $unwind$?_Change_array@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K1@Z DD 081301H
	DD	0b5413H
	DD	0a3413H
	DD	0f00f3213H
	DD	0600be00dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?_Clear_and_reserve_geometric@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN61
	DD	imagerel $LN61+30
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?_Clear_and_reserve_geometric@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z DD 040021H
	DD	0b5400H
	DD	0a3400H
	DD	imagerel $LN61
	DD	imagerel $LN61+30
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?_Clear_and_reserve_geometric@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN61+30
	DD	imagerel $LN61+101
	DD	imagerel $chain$1$?_Clear_and_reserve_geometric@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Clear_and_reserve_geometric@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z DD 020521H
	DD	046405H
	DD	imagerel $LN61+30
	DD	imagerel $LN61+101
	DD	imagerel $chain$1$?_Clear_and_reserve_geometric@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Clear_and_reserve_geometric@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z DD 041721H
	DD	0b5417H
	DD	0a3405H
	DD	imagerel $LN61
	DD	imagerel $LN61+30
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Clear_and_reserve_geometric@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z DD 030801H
	DD	0e0044208H
	DD	07002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAXQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Change_array@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUInputParam@NodeDef@AINBNodeDefMgr@@_K1@Z DD 021H
	DD	imagerel $LN47
	DD	imagerel $LN47+39
	DD	imagerel $unwind$?_Change_array@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUInputParam@NodeDef@AINBNodeDefMgr@@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Change_array@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUInputParam@NodeDef@AINBNodeDefMgr@@_K1@Z DD 020521H
	DD	097405H
	DD	imagerel $LN47
	DD	imagerel $LN47+39
	DD	imagerel $unwind$?_Change_array@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUInputParam@NodeDef@AINBNodeDefMgr@@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUInputParam@NodeDef@AINBNodeDefMgr@@_K1@Z DD 081301H
	DD	0b5413H
	DD	0a3413H
	DD	0f00f3213H
	DD	0600be00dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?_Clear_and_reserve_geometric@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN61
	DD	imagerel $LN61+29
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?_Clear_and_reserve_geometric@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z DD 040021H
	DD	04e400H
	DD	0a3400H
	DD	imagerel $LN61
	DD	imagerel $LN61+29
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?_Clear_and_reserve_geometric@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN61+29
	DD	imagerel $LN61+100
	DD	imagerel $chain$1$?_Clear_and_reserve_geometric@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Clear_and_reserve_geometric@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z DD 020521H
	DD	0b5405H
	DD	imagerel $LN61+29
	DD	imagerel $LN61+100
	DD	imagerel $chain$1$?_Clear_and_reserve_geometric@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Clear_and_reserve_geometric@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z DD 041721H
	DD	04e417H
	DD	0a3405H
	DD	imagerel $LN61
	DD	imagerel $LN61+29
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Clear_and_reserve_geometric@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z DD 030701H
	DD	070034207H
	DD	06002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAPEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAXQEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Change_array@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUNodeDef@AINBNodeDefMgr@@_K1@Z DD 021H
	DD	imagerel $LN48
	DD	imagerel $LN48+46
	DD	imagerel $unwind$?_Change_array@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUNodeDef@AINBNodeDefMgr@@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Change_array@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUNodeDef@AINBNodeDefMgr@@_K1@Z DD 020521H
	DD	067405H
	DD	imagerel $LN48
	DD	imagerel $LN48+46
	DD	imagerel $unwind$?_Change_array@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUNodeDef@AINBNodeDefMgr@@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUNodeDef@AINBNodeDefMgr@@_K1@Z DD 081501H
	DD	096415H
	DD	085415H
	DD	073415H
	DD	0e0113215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@QEAAPEAUNodeDef@AINBNodeDefMgr@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Change_array@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAXQEAU_Find_file_handle@filesystem@2@_K1@Z DD 021H
	DD	imagerel $LN49
	DD	imagerel $LN49+39
	DD	imagerel $unwind$?_Change_array@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAXQEAU_Find_file_handle@filesystem@2@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Change_array@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAXQEAU_Find_file_handle@filesystem@2@_K1@Z DD 020521H
	DD	097405H
	DD	imagerel $LN49
	DD	imagerel $LN49+39
	DD	imagerel $unwind$?_Change_array@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAXQEAU_Find_file_handle@filesystem@2@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAXQEAU_Find_file_handle@filesystem@2@_K1@Z DD 081301H
	DD	0b5413H
	DD	0a3413H
	DD	0f00f3213H
	DD	0600be00dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@U_Find_file_handle@filesystem@std@@@std@@QEAAPEAU_Find_file_handle@filesystem@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_K1@Z DD 081401H
	DD	096414H
	DD	085414H
	DD	073414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Change_array@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXQEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K1@Z DD 021H
	DD	imagerel $LN49
	DD	imagerel $LN49+31
	DD	imagerel $unwind$?_Change_array@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXQEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Change_array@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXQEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K1@Z DD 020521H
	DD	097405H
	DD	imagerel $LN49
	DD	imagerel $LN49+31
	DD	imagerel $unwind$?_Change_array@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXQEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXQEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K1@Z DD 060e01H
	DD	0a340eH
	DD	0f00a320eH
	DD	06006e008H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Change_array@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXQEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K1@Z DD 021H
	DD	imagerel $LN49
	DD	imagerel $LN49+31
	DD	imagerel $unwind$?_Change_array@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXQEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Change_array@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXQEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K1@Z DD 020521H
	DD	097405H
	DD	imagerel $LN49
	DD	imagerel $LN49+31
	DD	imagerel $unwind$?_Change_array@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXQEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXQEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K1@Z DD 060e01H
	DD	0a340eH
	DD	0f00a320eH
	DD	06006e008H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@UEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_raw@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_raw@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@0@AEBV?$allocator@D@0@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@0@AEBV?$allocator@D@0@@Z DB 02H
	DB	0f4H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@0@AEBV?$allocator@D@0@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@0@AEBV?$allocator@D@0@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@0@AEBV?$allocator@D@0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@0@AEBV?$allocator@D@0@@Z
	DD	imagerel $ip2state$??$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@0@AEBV?$allocator@D@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@0@AEBV?$allocator@D@0@@Z DD 081711H
	DD	0e5417H
	DD	0d3417H
	DD	0e0137217H
	DD	060107011H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@0@AEBV?$allocator@D@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@U_Normal_conversion@01@@Z DD 021H
	DD	imagerel $LN62
	DD	imagerel $LN62+118
	DD	imagerel $unwind$??$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@U_Normal_conversion@01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@U_Normal_conversion@01@@Z DD 020521H
	DD	0e7405H
	DD	imagerel $LN62
	DD	imagerel $LN62+118
	DD	imagerel $unwind$??$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@U_Normal_conversion@01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@U_Normal_conversion@01@@Z DD 060c01H
	DD	0f008520cH
	DD	06004e006H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0U_Creator@_Dir_enum_impl@filesystem@std@@AEBW4directory_options@23@@?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAA@$$QEAU_Creator@_Dir_enum_impl@filesystem@1@AEBW4directory_options@41@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@DU?$char_traits@D@std@@@1@U_Normal_conversion@01@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@DU?$char_traits@D@std@@@1@U_Normal_conversion@01@@Z DB 02H
	DB	'E', 02H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@DU?$char_traits@D@std@@@1@U_Normal_conversion@01@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$1@?0???$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@DU?$char_traits@D@std@@@1@U_Normal_conversion@01@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@DU?$char_traits@D@std@@@1@U_Normal_conversion@01@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@DU?$char_traits@D@std@@@1@U_Normal_conversion@01@@Z
	DD	imagerel $ip2state$??$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@DU?$char_traits@D@std@@@1@U_Normal_conversion@01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@DU?$char_traits@D@std@@@1@U_Normal_conversion@01@@Z DD 081211H
	DD	0f5412H
	DD	0e3412H
	DD	0e00e7212H
	DD	0600b700cH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@DU?$char_traits@D@std@@@1@U_Normal_conversion@01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Uninitialized_move@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@0PEAU123@AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z DD 021H
	DD	imagerel $LN138
	DD	imagerel $LN138+20
	DD	imagerel $unwind$??$_Uninitialized_move@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@0PEAU123@AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Uninitialized_move@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@0PEAU123@AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z DD 020521H
	DD	037405H
	DD	imagerel $LN138
	DD	imagerel $LN138+20
	DD	imagerel $unwind$??$_Uninitialized_move@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@0PEAU123@AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@0PEAU123@AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z DD 010201H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Uninitialized_move@PEAUInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@QEAU123@0PEAU123@AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z DD 021H
	DD	imagerel $LN138
	DD	imagerel $LN138+24
	DD	imagerel $unwind$??$_Uninitialized_move@PEAUInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@QEAU123@0PEAU123@AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Uninitialized_move@PEAUInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@QEAU123@0PEAU123@AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z DD 020521H
	DD	077405H
	DD	imagerel $LN138
	DD	imagerel $LN138+24
	DD	imagerel $unwind$??$_Uninitialized_move@PEAUInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@QEAU123@0PEAU123@AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAUInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@QEAU123@0PEAU123@AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAUNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUNodeDef@AINBNodeDefMgr@@QEAU12@0PEAU12@AEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@0@@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAXXZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@00@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@QEAW4123@0PEAW4123@AEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@0@@Z DD 040801H
	DD	070043208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Uninitialized_move@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z DD 021H
	DD	imagerel $LN59
	DD	imagerel $LN59+18
	DD	imagerel $unwind$??$_Uninitialized_move@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Uninitialized_move@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z DD 020421H
	DD	03404H
	DD	imagerel $LN59
	DD	imagerel $LN59+18
	DD	imagerel $unwind$??$_Uninitialized_move@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Emplace_back@AEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAXAEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z DB 06H
	DB	0dcH
	DB	00H
	DB	098H
	DB	04H
	DB	'\'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Emplace_back@AEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAXAEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$_Tidy_guard@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@XZ
	DB	040H
	DB	032H
	DD	imagerel ??1?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ
	DB	050H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Emplace_back@AEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAXAEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Emplace_back@AEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAXAEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z
	DD	imagerel $ip2state$??$_Emplace_back@AEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAXAEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@AEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAXAEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z DD 081f19H
	DD	0123410H
	DD	0f00c9210H
	DD	07008e00aH
	DD	050066007H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Emplace_back@AEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAXAEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z
	DD	042H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Uninitialized_move@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z DD 021H
	DD	imagerel $LN59
	DD	imagerel $LN59+18
	DD	imagerel $unwind$??$_Uninitialized_move@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Uninitialized_move@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z DD 020421H
	DD	03404H
	DD	imagerel $LN59
	DD	imagerel $LN59+18
	DD	imagerel $unwind$??$_Uninitialized_move@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Emplace_back@AEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAXAEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z DB 0aH
	DB	0dcH
	DB	00H
	DB	0bcH
	DB	04H
	DB	'&'
	DB	06H
	DB	01cH
	DB	08H
	DB	'Z'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Emplace_back@AEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAXAEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z DB 08H
	DB	0aH
	DD	imagerel ??1?$_Tidy_guard@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@XZ
	DB	040H
	DB	032H
	DD	imagerel ??1?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ
	DB	060H
	DB	034H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	050H
	DB	036H
	DD	imagerel ?dtor$3@?0???$_Emplace_back@AEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAXAEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Emplace_back@AEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAXAEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Emplace_back@AEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAXAEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z
	DD	imagerel $ip2state$??$_Emplace_back@AEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAXAEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@AEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAXAEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z DD 081f19H
	DD	0123410H
	DD	0f00c9210H
	DD	07008e00aH
	DD	050066007H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Emplace_back@AEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAXAEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z
	DD	04aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_copy_n@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z DB 08H
	DB	0a0H
	DB	02H
	DB	'&'
	DB	04H
	DB	01cH
	DB	06H
	DB	'H'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_copy_n@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z DB 06H
	DB	0aH
	DD	imagerel ??1?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ
	DB	050H
	DB	034H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	040H
	DB	036H
	DD	imagerel ?dtor$2@?0???$_Uninitialized_copy_n@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Uninitialized_copy_n@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_copy_n@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z
	DD	imagerel $ip2state$??$_Uninitialized_copy_n@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy_n@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z DD 061e19H
	DD	0e640fH
	DD	0d340fH
	DD	0700b920fH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Uninitialized_copy_n@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z
	DD	042H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Copy_n_unchecked4@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_KPEAU123@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0@Z DD 021H
	DD	imagerel $LN41
	DD	imagerel $LN41+25
	DD	imagerel $unwind$??$_Copy_n_unchecked4@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_KPEAU123@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Copy_n_unchecked4@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_KPEAU123@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0@Z DD 040e21H
	DD	07740eH
	DD	063405H
	DD	imagerel $LN41
	DD	imagerel $LN41+25
	DD	imagerel $unwind$??$_Copy_n_unchecked4@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_KPEAU123@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_n_unchecked4@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_KPEAU123@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0@Z DD 040a01H
	DD	08540aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_copy_n@PEAUInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z DB 04H
	DB	092H
	DB	02H
	DB	'R'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_copy_n@PEAUInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Uninitialized_copy_n@PEAUInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_copy_n@PEAUInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z
	DD	imagerel $ip2state$??$_Uninitialized_copy_n@PEAUInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy_n@PEAUInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z DD 061e19H
	DD	0c640fH
	DD	0b340fH
	DD	0700b720fH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Uninitialized_copy_n@PEAUInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z
	DD	03aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Copy_n_unchecked4@PEAUInputParam@NodeDef@AINBNodeDefMgr@@_KPEAU123@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0@Z DD 021H
	DD	imagerel $LN53
	DD	imagerel $LN53+25
	DD	imagerel $unwind$??$_Copy_n_unchecked4@PEAUInputParam@NodeDef@AINBNodeDefMgr@@_KPEAU123@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Copy_n_unchecked4@PEAUInputParam@NodeDef@AINBNodeDefMgr@@_KPEAU123@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0@Z DD 040e21H
	DD	08740eH
	DD	063405H
	DD	imagerel $LN53
	DD	imagerel $LN53+25
	DD	imagerel $unwind$??$_Copy_n_unchecked4@PEAUInputParam@NodeDef@AINBNodeDefMgr@@_KPEAU123@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_n_unchecked4@PEAUInputParam@NodeDef@AINBNodeDefMgr@@_KPEAU123@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0@Z DD 040a01H
	DD	09540aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_in_place@U_Recursive_dir_enum_impl@filesystem@std@@@std@@YAXAEAU_Recursive_dir_enum_impl@filesystem@0@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Recursive_dir_enum_impl@filesystem@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$0JA@@std@@YA_K_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$0PI@@std@@YA_K_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GNodeDef@AINBNodeDefMgr@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G_Recursive_dir_enum_impl@filesystem@std@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Uninitialized_backout_al@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@@std@@QEAA@XZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Tidy@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ DD 021H
	DD	imagerel $LN47
	DD	imagerel $LN47+21
	DD	imagerel $unwind$?_Tidy@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Tidy@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ DD 020521H
	DD	077405H
	DD	imagerel $LN47
	DD	imagerel $LN47+21
	DD	imagerel $unwind$?_Tidy@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ DD 040a01H
	DD	08340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Tidy@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ DD 021H
	DD	imagerel $LN47
	DD	imagerel $LN47+21
	DD	imagerel $unwind$?_Tidy@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Tidy@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ DD 020521H
	DD	076405H
	DD	imagerel $LN47
	DD	imagerel $LN47+21
	DD	imagerel $unwind$?_Tidy@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$?0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@_W@1@@Z DD 021H
	DD	imagerel $LN57
	DD	imagerel $LN57+113
	DD	imagerel $unwind$??$?0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@_W@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$?0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@_W@1@@Z DD 020521H
	DD	0c7405H
	DD	imagerel $LN57
	DD	imagerel $LN57+113
	DD	imagerel $unwind$??$?0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@_W@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@_W@1@@Z DD 060c01H
	DD	0f008320cH
	DD	06004e006H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@U_Recursive_dir_enum_impl@filesystem@std@@U_Creator@_Dir_enum_impl@23@AEBW4directory_options@23@@std@@YAXAEAU_Recursive_dir_enum_impl@filesystem@0@$$QEAU_Creator@_Dir_enum_impl@20@AEBW4directory_options@20@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@UInputParam@NodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX$$QEAUInputParam@NodeDef@AINBNodeDefMgr@@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@UNodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX$$QEAUNodeDef@AINBNodeDefMgr@@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@UNodeDef@AINBNodeDefMgr@@$$V@?$_Default_allocator_traits@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@1@QEAUNodeDef@AINBNodeDefMgr@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$construct@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@AEAV31@@Z DB 06H
	DB	0daH
	DB	00H
	DB	098H
	DB	04H
	DB	'R'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$construct@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@AEAV31@@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$_Tidy_guard@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@XZ
	DB	040H
	DB	032H
	DD	imagerel ??1?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ
	DB	050H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$construct@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@AEAV31@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$construct@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@AEAV31@@Z
	DD	imagerel $ip2state$??$construct@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@AEAV31@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@AEAV31@@Z DD 082219H
	DD	0116413H
	DD	0e3413H
	DD	0f00f9213H
	DD	0700be00dH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$construct@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@AEAV31@@Z
	DD	042H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$construct@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@AEAV31@@Z DB 0aH
	DB	0d8H
	DB	00H
	DB	0c0H
	DB	04H
	DB	'&'
	DB	06H
	DB	01cH
	DB	08H
	DB	'P'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$construct@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@AEAV31@@Z DB 08H
	DB	0aH
	DD	imagerel ??1?$_Tidy_guard@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@XZ
	DB	040H
	DB	032H
	DD	imagerel ??1?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ
	DB	060H
	DB	034H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	050H
	DB	036H
	DD	imagerel ?dtor$3@?0???$construct@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@AEAV31@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$construct@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@AEAV31@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$construct@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@AEAV31@@Z
	DD	imagerel $ip2state$??$construct@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@AEAV31@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@AEAV31@@Z DD 082119H
	DD	0115412H
	DD	0e3412H
	DD	0e00e9212H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$construct@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@AEAV31@@Z
	DD	04aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Emplace_back@AEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAXAEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z DB 06H
	DB	'B'
	DB	00H
	DB	'('
	DB	02H
	DB	01cH
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Emplace_back@AEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAXAEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z DB 04H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	060H
	DB	036H
	DD	imagerel ?dtor$1@?0???$_Emplace_back@AEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAXAEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Emplace_back@AEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAXAEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Emplace_back@AEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAXAEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z
	DD	imagerel $ip2state$??$_Emplace_back@AEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAXAEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@AEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAXAEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z DD 060f11H
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Emplace_back@AEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAXAEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@AEAUInputParam@NodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAXAEAUInputParam@NodeDef@AINBNodeDefMgr@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GImmediateParam@NodeDef@AINBNodeDefMgr@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GInputParam@NodeDef@AINBNodeDefMgr@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@U_Recursive_dir_enum_impl@filesystem@std@@U_Creator@_Dir_enum_impl@23@AEBW4directory_options@23@$0A@@std@@YAPEAU_Recursive_dir_enum_impl@filesystem@0@QEAU120@$$QEAU_Creator@_Dir_enum_impl@20@AEBW4directory_options@20@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@UInputParam@NodeDef@AINBNodeDefMgr@@U123@@?$_Default_allocator_traits@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@1@QEAUInputParam@NodeDef@AINBNodeDefMgr@@$$QEAU345@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@UNodeDef@AINBNodeDefMgr@@$$V$0A@@std@@YAPEAUNodeDef@AINBNodeDefMgr@@QEAU12@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$construct_at@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@$0A@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV10@@Z DB 06H
	DB	0d8H
	DB	00H
	DB	098H
	DB	04H
	DB	'X'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$construct_at@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@$0A@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV10@@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$_Tidy_guard@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@XZ
	DB	040H
	DB	032H
	DD	imagerel ??1?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ
	DB	050H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$construct_at@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@$0A@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV10@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$construct_at@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@$0A@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV10@@Z
	DD	imagerel $ip2state$??$construct_at@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@$0A@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@$0A@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV10@@Z DD 082119H
	DD	0115412H
	DD	0103412H
	DD	0e00e9212H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$construct_at@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@$0A@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV10@@Z
	DD	042H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$construct_at@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@$0A@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV10@@Z DB 0aH
	DB	0d8H
	DB	00H
	DB	0c0H
	DB	04H
	DB	'&'
	DB	06H
	DB	01cH
	DB	08H
	DB	'V'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$construct_at@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@$0A@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV10@@Z DB 08H
	DB	0aH
	DD	imagerel ??1?$_Tidy_guard@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@XZ
	DB	040H
	DB	032H
	DD	imagerel ??1?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ
	DB	060H
	DB	034H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	050H
	DB	036H
	DD	imagerel ?dtor$3@?0???$construct_at@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@$0A@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV10@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$construct_at@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@$0A@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV10@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$construct_at@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@$0A@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV10@@Z
	DD	imagerel $ip2state$??$construct_at@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@$0A@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@$0A@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV10@@Z DD 082119H
	DD	0115412H
	DD	0103412H
	DD	0e00e9212H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$construct_at@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@$0A@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV10@@Z
	DD	04aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$construct@UImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@@?$_Default_allocator_traits@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@1@QEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU345@@Z DB 06H
	DB	'@'
	DB	00H
	DB	'('
	DB	02H
	DB	01cH
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$construct@UImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@@?$_Default_allocator_traits@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@1@QEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU345@@Z DB 04H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	060H
	DB	036H
	DD	imagerel ?dtor$1@?0???$construct@UImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@@?$_Default_allocator_traits@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@1@QEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU345@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$construct@UImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@@?$_Default_allocator_traits@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@1@QEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU345@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$construct@UImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@@?$_Default_allocator_traits@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@1@QEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU345@@Z
	DD	imagerel $ip2state$??$construct@UImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@@?$_Default_allocator_traits@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@1@QEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU345@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@UImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@@?$_Default_allocator_traits@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@1@QEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU345@@Z DD 040f11H
	DD	07340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$construct@UImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@@?$_Default_allocator_traits@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@1@QEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU345@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@AEBV01@@Z DB 0aH
	DB	0d8H
	DB	00H
	DB	0c0H
	DB	04H
	DB	'&'
	DB	06H
	DB	01cH
	DB	08H
	DB	'V'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@AEBV01@@Z DB 08H
	DB	0aH
	DD	imagerel ??1?$_Tidy_guard@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@XZ
	DB	040H
	DB	032H
	DD	imagerel ??1?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ
	DB	060H
	DB	034H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	050H
	DB	036H
	DD	imagerel ?dtor$3@?0???0?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@AEBV01@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@AEBV01@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@AEBV01@@Z
	DD	imagerel $ip2state$??0?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@AEBV01@@Z DD 082119H
	DD	0115412H
	DD	0103412H
	DD	0e00e9212H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??0?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@AEBV01@@Z
	DD	04aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@AEBV01@@Z DB 06H
	DB	0d8H
	DB	00H
	DB	098H
	DB	04H
	DB	'X'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@AEBV01@@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$_Tidy_guard@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@XZ
	DB	040H
	DB	032H
	DD	imagerel ??1?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ
	DB	050H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@AEBV01@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@AEBV01@@Z
	DD	imagerel $ip2state$??0?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@AEBV01@@Z DD 082119H
	DD	0115412H
	DD	0103412H
	DD	0e00e9212H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??0?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@AEBV01@@Z
	DD	042H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@UInputParam@NodeDef@AINBNodeDefMgr@@U123@$0A@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@QEAU123@$$QEAU123@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$construct_at@UImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@$0A@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@AEAU123@@Z DB 06H
	DB	'*'
	DB	00H
	DB	'('
	DB	02H
	DB	01cH
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$construct_at@UImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@$0A@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@AEAU123@@Z DB 04H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	060H
	DB	036H
	DD	imagerel ?dtor$1@?0???$construct_at@UImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@$0A@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@AEAU123@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$construct_at@UImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@$0A@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@AEAU123@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$construct_at@UImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@$0A@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@AEAU123@@Z
	DD	imagerel $ip2state$??$construct_at@UImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@$0A@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@AEAU123@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@UImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@$0A@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@AEAU123@@Z DD 040a11H
	DD	07340aH
	DD	07006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$construct_at@UImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@$0A@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@AEAU123@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Construct_n@AEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEBQEAU123@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@1@Z DB 0aH
	DB	084H
	DB	00H
	DB	0b4H
	DB	04H
	DB	'&'
	DB	06H
	DB	01cH
	DB	08H
	DB	'P'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Construct_n@AEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEBQEAU123@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@1@Z DB 08H
	DB	0aH
	DD	imagerel ??1?$_Tidy_guard@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@XZ
	DB	040H
	DB	032H
	DD	imagerel ??1?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ
	DB	060H
	DB	034H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	050H
	DB	036H
	DD	imagerel ?dtor$3@?0???$_Construct_n@AEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEBQEAU123@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@1@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Construct_n@AEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEBQEAU123@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@1@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Construct_n@AEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEBQEAU123@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@1@Z
	DD	imagerel $ip2state$??$_Construct_n@AEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEBQEAU123@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_n@AEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEBQEAU123@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@1@Z DD 062319H
	DD	0f0109214H
	DD	0700ce00eH
	DD	0300a600bH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Construct_n@AEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEBQEAU123@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@1@Z
	DD	04aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Construct_n@AEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@AEBQEAU123@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@1@Z DB 06H
	DB	084H
	DB	00H
	DB	0a8H
	DB	04H
	DB	'R'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Construct_n@AEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@AEBQEAU123@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@1@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$_Tidy_guard@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@XZ
	DB	040H
	DB	032H
	DD	imagerel ??1?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ
	DB	050H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Construct_n@AEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@AEBQEAU123@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@1@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Construct_n@AEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@AEBQEAU123@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@1@Z
	DD	imagerel $ip2state$??$_Construct_n@AEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@AEBQEAU123@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_n@AEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@AEBQEAU123@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@1@Z DD 062319H
	DD	0f0109214H
	DD	0700ce00eH
	DD	0300a600bH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Construct_n@AEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@AEBQEAU123@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@1@Z
	DD	042H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0InputParam@NodeDef@AINBNodeDefMgr@@QEAA@$$QEAU012@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_nonzero@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_nonzero@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_copy@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@00AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z DB 08H
	DB	0a0H
	DB	02H
	DB	'&'
	DB	04H
	DB	01cH
	DB	06H
	DB	'N'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_copy@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@00AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z DB 06H
	DB	0aH
	DD	imagerel ??1?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ
	DB	050H
	DB	034H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	040H
	DB	036H
	DD	imagerel ?dtor$2@?0???$_Uninitialized_copy@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@00AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Uninitialized_copy@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@00AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_copy@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@00AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z
	DD	imagerel $ip2state$??$_Uninitialized_copy@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@00AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@00AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z DD 061e19H
	DD	0e640fH
	DD	0d340fH
	DD	0700b920fH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Uninitialized_copy@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@00AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z
	DD	042H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_copy@PEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@00AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z DB 04H
	DB	092H
	DB	02H
	DB	'P'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_copy@PEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@00AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Uninitialized_copy@PEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@00AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_copy@PEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@00AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z
	DD	imagerel $ip2state$??$_Uninitialized_copy@PEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@00AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy@PEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@00AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z DD 061e19H
	DD	0c640fH
	DD	0b340fH
	DD	0700b720fH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Uninitialized_copy@PEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@00AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z
	DD	03aH
?NodeDefinitions$initializer$@AINBNodeDefMgr@@3P6AXXZEA DQ FLAT:??__FNodeDefinitions@AINBNodeDefMgr@@YAXXZ ; AINBNodeDefMgr::NodeDefinitions$initializer$
?EXBFile$initializer$@AINBNodeDefMgr@@3P6AXXZEA DQ FLAT:??__EEXBFile@AINBNodeDefMgr@@YAXXZ ; AINBNodeDefMgr::EXBFile$initializer$
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\wchar.h
;	COMDAT wmemset
_TEXT	SEGMENT
_S$ = 16
_C$dead$ = 24
_N$ = 32
wmemset	PROC						; COMDAT

; 257  :     {

$LN13:
	sub	rsp, 8
	mov	rdx, rcx

; 258  :         wchar_t *_Su = _S;
; 259  :         for (; 0 < _N; ++_Su, --_N)

	test	r8, r8
	je	SHORT $LN10@wmemset
	mov	QWORD PTR [rsp], rdi
	xor	eax, eax
	mov	rdi, rcx
	movzx	eax, ax
	mov	rcx, r8
	rep stosw

; 260  :         {
; 261  :             *_Su = _C;
; 262  :         }
; 263  :         return _S;

	mov	rdi, QWORD PTR [rsp]
$LN10@wmemset:

; 264  :     }

	mov	rax, rdx
	add	rsp, 8
	ret	0
wmemset	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@QEBD@Z
_TEXT	SEGMENT
_InitData$ = 32
__$ArrayPad$ = 48
this$ = 80
_Message$ = 88
??0exception@std@@QEAA@QEBD@Z PROC			; std::exception::exception, COMDAT

; 59   :     {

$LN5:
	push	rbx
	sub	rsp, 64					; 00000040H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r8, rdx

; 60   :         __std_exception_data _InitData = { _Message, true };

	mov	BYTE PTR _InitData$[rsp+8], 1
	lea	rdx, QWORD PTR [rcx+8]
	mov	QWORD PTR _InitData$[rsp], r8
	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	rbx, rcx
	mov	QWORD PTR [rcx], rax
	xorps	xmm0, xmm0

; 61   :         __std_exception_copy(&_InitData, &_Data);

	lea	rcx, QWORD PTR _InitData$[rsp]
	movups	XMMWORD PTR [rdx], xmm0
	call	QWORD PTR __imp___std_exception_copy

; 62   :     }

	mov	rax, rbx
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
??0exception@std@@QEAA@QEBD@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??__Ksv@string_view_literals@literals@std@@YA?AV?$basic_string_view@DU?$char_traits@D@std@@@3@PEBD_K@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Str$ = 16
_Len$ = 24
??__Ksv@string_view_literals@literals@std@@YA?AV?$basic_string_view@DU?$char_traits@D@std@@@3@PEBD_K@Z PROC ; std::literals::string_view_literals::operator "" sv, COMDAT

; 1209 :         : _Mydata(_Cts), _Mysize(_Count) {

	mov	QWORD PTR [rcx], rdx

; 1813 :             return string_view(_Str, _Len);

	mov	rax, rcx

; 1209 :         : _Mydata(_Cts), _Mysize(_Count) {

	mov	QWORD PTR [rcx+8], r8

; 1814 :         }

	ret	0
??__Ksv@string_view_literals@literals@std@@YA?AV?$basic_string_view@DU?$char_traits@D@std@@@3@PEBD_K@Z ENDP ; std::literals::string_view_literals::operator "" sv
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??__Ksv@string_view_literals@literals@std@@YA?AV?$basic_string_view@_WU?$char_traits@_W@std@@@3@PEB_W_K@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Str$dead$ = 16
_Len$dead$ = 24
??__Ksv@string_view_literals@literals@std@@YA?AV?$basic_string_view@_WU?$char_traits@_W@std@@@3@PEB_W_K@Z PROC ; std::literals::string_view_literals::operator "" sv, COMDAT

; 1209 :         : _Mydata(_Cts), _Mysize(_Count) {

	lea	rax, OFFSET FLAT:??_C@_13BBDEGPLJ@?$AA?$CK@
	mov	QWORD PTR [rcx+8], 1
	mov	QWORD PTR [rcx], rax

; 1817 :             return wstring_view(_Str, _Len);

	mov	rax, rcx

; 1818 :         }

	ret	0
??__Ksv@string_view_literals@literals@std@@YA?AV?$basic_string_view@_WU?$char_traits@_W@std@@@3@PEB_W_K@Z ENDP ; std::literals::string_view_literals::operator "" sv
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stdexcept
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stdexcept
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vcruntime_exception.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stdexcept
;	COMDAT ??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_InitData$1 = 32
__$ArrayPad$ = 48
this$ = 80
_Message$ = 88
??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::runtime_error::runtime_error, COMDAT

; 105  :     explicit runtime_error(const string& _Message) : _Mybase(_Message.c_str()) {}

$LN15:
	push	rbx
	sub	rsp, 64					; 00000040H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 16
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stdexcept

; 105  :     explicit runtime_error(const string& _Message) : _Mybase(_Message.c_str()) {}

	mov	r8, rdx
	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN6@runtime_er

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r8, QWORD PTR [rdx]
$LN6@runtime_er:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vcruntime_exception.h

; 58   :         : _Data()

	lea	rdx, QWORD PTR [rcx+8]

; 59   :     {
; 60   :         __std_exception_data _InitData = { _Message, true };

	mov	QWORD PTR _InitData$1[rsp], r8
	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	BYTE PTR _InitData$1[rsp+8], 1
	mov	QWORD PTR [rcx], rax
	xorps	xmm0, xmm0

; 61   :         __std_exception_copy(&_InitData, &_Data);

	lea	rcx, QWORD PTR _InitData$1[rsp]
	movups	XMMWORD PTR [rdx], xmm0
	call	QWORD PTR __imp___std_exception_copy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stdexcept

; 105  :     explicit runtime_error(const string& _Message) : _Mybase(_Message.c_str()) {}

	lea	rax, OFFSET FLAT:??_7runtime_error@std@@6B@
	mov	QWORD PTR [rbx], rax
	mov	rax, rbx
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vcruntime_exception.h
;	COMDAT ??_Gruntime_error@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gruntime_error@std@@UEAAPEAXI@Z PROC			; std::runtime_error::`scalar deleting destructor', COMDAT
$LN13:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 89   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	rdi, rcx
	mov	QWORD PTR [rcx], rax
	mov	ebx, edx

; 90   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	call	QWORD PTR __imp___std_exception_destroy
	test	bl, 1
	je	SHORT $LN9@scalar
	mov	edx, 24
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN9@scalar:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_Gruntime_error@std@@UEAAPEAXI@Z ENDP			; std::runtime_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vcruntime_exception.h
;	COMDAT ??1runtime_error@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1runtime_error@std@@UEAA@XZ PROC			; std::runtime_error::~runtime_error, COMDAT

; 89   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax

; 90   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	rex_jmp	QWORD PTR __imp___std_exception_destroy
??1runtime_error@std@@UEAA@XZ ENDP			; std::runtime_error::~runtime_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vcruntime_exception.h
;	COMDAT ??0runtime_error@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0runtime_error@std@@QEAA@AEBV01@@Z PROC		; std::runtime_error::runtime_error, COMDAT
$LN7:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rax, rdx

; 72   :     {

	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	xorps	xmm0, xmm0

; 71   :         : _Data()

	lea	rdx, QWORD PTR [rbx+8]

; 72   :     {

	mov	QWORD PTR [rbx], rcx

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

	lea	rcx, QWORD PTR [rax+8]
	movups	XMMWORD PTR [rdx], xmm0
	call	QWORD PTR __imp___std_exception_copy
	lea	rax, OFFSET FLAT:??_7runtime_error@std@@6B@
	mov	QWORD PTR [rbx], rax
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0runtime_error@std@@QEAA@AEBV01@@Z ENDP		; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
;	COMDAT ??8error_category@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??8error_category@std@@QEBA_NAEBV01@@Z PROC		; std::error_category::operator==, COMDAT

; 95   : #ifdef _M_CEE_PURE
; 96   :         return _Addr == _Right._Addr;
; 97   : #else // ^^^ defined(_M_CEE_PURE) / !defined(_M_CEE_PURE) vvv
; 98   :         return _Bit_cast<uintptr_t>(_Addr) == _Bit_cast<uintptr_t>(_Right._Addr);

	mov	rax, QWORD PTR [rdx+8]
	cmp	QWORD PTR [rcx+8], rax
	sete	al

; 99   : #endif // ^^^ !defined(_M_CEE_PURE) ^^^
; 100  :     }

	ret	0
??8error_category@std@@QEBA_NAEBV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
;	COMDAT ??1error_category@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1error_category@std@@UEAA@XZ PROC			; std::error_category::~error_category, COMDAT

; 82   :     _CONSTEXPR20 virtual ~error_category() noexcept = default;

	ret	0
??1error_category@std@@UEAA@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
;	COMDAT ??0error_code@std@@QEAA@HAEBVerror_category@1@@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
_Cat$ = 24
??0error_code@std@@QEAA@HAEBVerror_category@1@@Z PROC	; std::error_code::error_code, COMDAT

; 168  :     error_code(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) {}

	mov	DWORD PTR [rcx], edx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], r8
	ret	0
??0error_code@std@@QEAA@HAEBVerror_category@1@@Z ENDP	; std::error_code::error_code
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
;	COMDAT ?value@error_code@std@@QEBAHXZ
_TEXT	SEGMENT
this$ = 8
?value@error_code@std@@QEBAHXZ PROC			; std::error_code::value, COMDAT

; 194  :         return _Myval;

	mov	eax, DWORD PTR [rcx]

; 195  :     }

	ret	0
?value@error_code@std@@QEBAHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
;	COMDAT ?category@error_code@std@@QEBAAEBVerror_category@2@XZ
_TEXT	SEGMENT
this$ = 8
?category@error_code@std@@QEBAAEBVerror_category@2@XZ PROC ; std::error_code::category, COMDAT

; 198  :         return *_Mycat;

	mov	rax, QWORD PTR [rcx+8]

; 199  :     }

	ret	0
?category@error_code@std@@QEBAAEBVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
;	COMDAT ?message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
this$ = 64
__$ReturnUdt$ = 72
?message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::error_code::message, COMDAT

; 203  :     _NODISCARD string message() const {

$LN7:
	push	rbx
	sub	rsp, 48					; 00000030H

; 204  :         return category().message(value());

	mov	r8d, DWORD PTR [rcx]
	mov	rbx, rdx
	mov	rcx, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+16]
	mov	rax, rbx

; 205  :     }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
?message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::error_code::message
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
;	COMDAT ??0error_condition@std@@QEAA@HAEBVerror_category@1@@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
_Cat$ = 24
??0error_condition@std@@QEAA@HAEBVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT

; 261  :     error_condition(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) {}

	mov	DWORD PTR [rcx], edx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], r8
	ret	0
??0error_condition@std@@QEAA@HAEBVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
;	COMDAT ?value@error_condition@std@@QEBAHXZ
_TEXT	SEGMENT
this$ = 8
?value@error_condition@std@@QEBAHXZ PROC		; std::error_condition::value, COMDAT

; 287  :         return _Myval;

	mov	eax, DWORD PTR [rcx]

; 288  :     }

	ret	0
?value@error_condition@std@@QEBAHXZ ENDP		; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
;	COMDAT ?category@error_condition@std@@QEBAAEBVerror_category@2@XZ
_TEXT	SEGMENT
this$ = 8
?category@error_condition@std@@QEBAAEBVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT

; 291  :         return *_Mycat;

	mov	rax, QWORD PTR [rcx+8]

; 292  :     }

	ret	0
?category@error_condition@std@@QEBAAEBVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
;	COMDAT ??8std@@YA_NAEBVerror_condition@0@0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??8std@@YA_NAEBVerror_condition@0@0@Z PROC		; std::operator==, COMDAT

; 98   :         return _Bit_cast<uintptr_t>(_Addr) == _Bit_cast<uintptr_t>(_Right._Addr);

	mov	rax, QWORD PTR [rdx+8]
	mov	r9, QWORD PTR [rcx+8]
	mov	r8, QWORD PTR [rax+8]
	cmp	QWORD PTR [r9+8], r8

; 304  :         return _Left.category() == _Right.category() && _Left.value() == _Right.value();

	jne	SHORT $LN3@operator
	mov	eax, DWORD PTR [rdx]
	cmp	DWORD PTR [rcx], eax
	jne	SHORT $LN3@operator
	mov	al, 1

; 305  :     }

	ret	0
$LN3@operator:

; 304  :         return _Left.category() == _Right.category() && _Left.value() == _Right.value();

	xor	al, al

; 305  :     }

	ret	0
??8std@@YA_NAEBVerror_condition@0@0@Z ENDP		; std::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UEBA?AVerror_condition@2@H@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
_Errval$ = 24
?default_error_condition@error_category@std@@UEBA?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT

; 261  :     error_condition(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) {}

	mov	DWORD PTR [rdx], r8d

; 411  :     // make error_condition for error code
; 412  :     return error_condition(_Errval, *this);

	mov	rax, rdx

; 261  :     error_condition(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) {}

	mov	QWORD PTR [rdx+8], rcx

; 413  : }

	ret	0
?default_error_condition@error_category@std@@UEBA?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
;	COMDAT ?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Errval$ = 72
_Cond$ = 80
?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT

; 415  : _NODISCARD inline bool error_category::equivalent(int _Errval, const error_condition& _Cond) const noexcept {

$LN13:
	push	rbx
	sub	rsp, 48					; 00000030H

; 416  :     return default_error_condition(_Errval) == _Cond;

	mov	rax, QWORD PTR [rcx]
	mov	rbx, r8
	mov	r8d, edx
	lea	rdx, QWORD PTR $T1[rsp]
	call	QWORD PTR [rax+24]

; 98   :         return _Bit_cast<uintptr_t>(_Addr) == _Bit_cast<uintptr_t>(_Right._Addr);

	mov	rcx, QWORD PTR [rbx+8]
	mov	r9, QWORD PTR [rax+8]
	mov	rdx, QWORD PTR [rcx+8]
	cmp	QWORD PTR [r9+8], rdx

; 304  :         return _Left.category() == _Right.category() && _Left.value() == _Right.value();

	jne	SHORT $LN5@equivalent
	mov	ecx, DWORD PTR [rbx]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN5@equivalent

; 416  :     return default_error_condition(_Errval) == _Cond;

	mov	al, 1

; 417  : }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
$LN5@equivalent:

; 416  :     return default_error_condition(_Errval) == _Cond;

	xor	al, al

; 417  : }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
;	COMDAT ?equivalent@error_category@std@@UEBA_NAEBVerror_code@2@H@Z
_TEXT	SEGMENT
this$ = 8
_Code$ = 16
_Errval$ = 24
?equivalent@error_category@std@@UEBA_NAEBVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT

; 98   :         return _Bit_cast<uintptr_t>(_Addr) == _Bit_cast<uintptr_t>(_Right._Addr);

	mov	rax, QWORD PTR [rdx+8]
	mov	r9, QWORD PTR [rax+8]
	cmp	QWORD PTR [rcx+8], r9

; 420  :     return *this == _Code.category() && _Code.value() == _Errval;

	jne	SHORT $LN3@equivalent
	cmp	DWORD PTR [rdx], r8d
	jne	SHORT $LN3@equivalent
	mov	al, 1

; 421  : }

	ret	0
$LN3@equivalent:

; 420  :     return *this == _Code.category() && _Code.value() == _Errval;

	xor	al, al

; 421  : }

	ret	0
?equivalent@error_category@std@@UEBA_NAEBVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
;	COMDAT ?make_error_code@std@@YA?AVerror_code@1@W4errc@1@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Ec$ = 16
?make_error_code@std@@YA?AVerror_code@1@W4errc@1@@Z PROC ; std::make_error_code, COMDAT

; 168  :     error_code(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) {}

	lea	rax, OFFSET FLAT:?_Static@?1???$_Immortalize_memcpy_image@V_Generic_error_category@std@@@std@@YAAEBV_Generic_error_category@1@XZ@4V21@B ; `std::_Immortalize_memcpy_image<std::_Generic_error_category>'::`2'::_Static
	mov	DWORD PTR [rcx], edx
	mov	QWORD PTR [rcx+8], rax

; 429  :     return error_code(static_cast<int>(_Ec), _STD generic_category());

	mov	rax, rcx

; 430  : }

	ret	0
?make_error_code@std@@YA?AVerror_code@1@W4errc@1@@Z ENDP ; std::make_error_code
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
;	COMDAT ?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
_TEXT	SEGMENT
$T1 = 56
_Message$GSCopy$ = 88
__$ReturnUdt$GSCopy$ = 88
__$ArrayPad$ = 96
__$ReturnUdt$ = 144
_Errcode$ = 152
_Message$ = 160
?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z PROC ; std::_System_error::_Makestr, COMDAT

; 466  :     static string _Makestr(error_code _Errcode, string _Message) { // compose error message

$LN135:
	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 112				; 00000070H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbx, r8
	mov	rsi, rdx
	mov	rdi, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
	mov	QWORD PTR _Message$GSCopy$[rsp], rbx
	xor	ebp, ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4228 :         return _Mypair._Myval2._Mysize == 0;

	mov	rcx, QWORD PTR [r8+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error

; 467  :         if (!_Message.empty()) {

	test	rcx, rcx
	je	SHORT $LN14@Makestr
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3271 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	rdx, QWORD PTR [r8+24]
	mov	rax, rdx
	sub	rax, rcx
	cmp	rax, 2
	jb	SHORT $LN15@Makestr

; 3272 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 3273 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	rax, QWORD PTR [rcx+2]
	mov	QWORD PTR [r8+16], rax

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	rax, rbx

; 2227 :         if (_Large_string_engaged()) {

	cmp	rdx, 16
	jb	SHORT $LN18@Makestr

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [r8]
$LN18@Makestr:

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	WORD PTR [rax+rcx], 8250		; 0000203aH

; 3276 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [rax+rcx+2], 0

; 3277 :             return *this;

	jmp	SHORT $LN14@Makestr
$LN15@Makestr:

; 3278 :         }
; 3279 : 
; 3280 :         return _Reallocate_grow_by(

	mov	QWORD PTR [rsp+32], 2
	lea	r9, OFFSET FLAT:??_C@_02LMMGGCAJ@?3?5@
	mov	edx, 2
	mov	rcx, rbx
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned __int64>
$LN14@Makestr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error

; 204  :         return category().message(value());

	mov	rcx, QWORD PTR [rsi+8]
	mov	rax, QWORD PTR [rcx]
	mov	r8d, DWORD PTR [rsi]
	lea	rdx, QWORD PTR $T1[rsp]
	call	QWORD PTR [rax+16]
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR $T1[rsp]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR $T1[rsp+24], 16
	cmovae	rdx, QWORD PTR $T1[rsp]

; 3241 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR $T1[rsp+16]
	mov	rcx, rbx
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	npad	1

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T1[rsp+24]
	cmp	rdx, 16
	jb	SHORT $LN60@Makestr

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T1[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN72@Makestr

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN72@Makestr
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN72@Makestr:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN60@Makestr:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rdi], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rdi+16], rbp

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rdi+24], rbp

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rbx]
	movups	XMMWORD PTR [rdi], xmm0
	movups	xmm1, XMMWORD PTR [rbx+16]
	movups	XMMWORD PTR [rdi+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error

; 472  :         return _Message;

	mov	QWORD PTR [rbx+16], rbp
	mov	QWORD PTR [rbx+24], 15
	mov	BYTE PTR [rbx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error

; 472  :         return _Message;

	mov	rax, rdi

; 473  :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+168]
	add	rsp, 112				; 00000070H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN132@Makestr:
?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z ENDP ; std::_System_error::_Makestr
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 56
_Message$GSCopy$ = 88
__$ReturnUdt$GSCopy$ = 88
__$ArrayPad$ = 96
__$ReturnUdt$ = 144
_Errcode$ = 152
_Message$ = 160
?dtor$0@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA PROC ; `std::_System_error::_Makestr'::`1'::dtor$0
	mov	rcx, QWORD PTR _Message$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA ENDP ; `std::_System_error::_Makestr'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 56
_Message$GSCopy$ = 88
__$ReturnUdt$GSCopy$ = 88
__$ArrayPad$ = 96
__$ReturnUdt$ = 144
_Errcode$ = 152
_Message$ = 160
?dtor$1@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA PROC ; `std::_System_error::_Makestr'::`1'::dtor$1
	lea	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA ENDP ; `std::_System_error::_Makestr'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
;	COMDAT ??0_System_error@std@@IEAA@Verror_code@1@@Z
_TEXT	SEGMENT
this$GSCopy$ = 32
$T1 = 40
this$ = 96
_Errcode$ = 104
??0_System_error@std@@IEAA@Verror_code@1@@Z PROC	; std::_System_error::_System_error, COMDAT

; 476  :     _System_error(error_code _Errcode) : runtime_error(_Errcode.message()), _Mycode(_Errcode) {}

$LN45:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 80					; 00000050H

; 204  :         return category().message(value());

	mov	r8d, DWORD PTR [rdx]

; 476  :     _System_error(error_code _Errcode) : runtime_error(_Errcode.message()), _Mycode(_Errcode) {}

	mov	rbx, rcx
	mov	QWORD PTR this$GSCopy$[rsp], rcx
	mov	rdi, rdx

; 204  :         return category().message(value());

	mov	rcx, QWORD PTR [rdx+8]
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+16]

; 476  :     _System_error(error_code _Errcode) : runtime_error(_Errcode.message()), _Mycode(_Errcode) {}

	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rbx
	call	??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR $T1[rsp+24]
	cmp	rdx, 16

; 4832 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN21@System_err
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T1[rsp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN33@System_err

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN33@System_err
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN33@System_err:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN21@System_err:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error

; 476  :     _System_error(error_code _Errcode) : runtime_error(_Errcode.message()), _Mycode(_Errcode) {}

	movaps	xmm0, XMMWORD PTR [rdi]
	lea	rax, OFFSET FLAT:??_7_System_error@std@@6B@
	mov	QWORD PTR [rbx], rax
	mov	rax, rbx
	movups	XMMWORD PTR [rbx+24], xmm0
	mov	rbx, QWORD PTR [rsp+112]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
$LN42@System_err:
??0_System_error@std@@IEAA@Verror_code@1@@Z ENDP	; std::_System_error::_System_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
;	COMDAT ??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
$T1 = 48
this$GSCopy$ = 48
$T2 = 64
$T3 = 96
this$ = 208
_Errcode$ = 216
_Message$ = 224
??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_System_error::_System_error, COMDAT

; 478  :     _System_error(error_code _Errcode, const string& _Message)

$LN170:
	mov	rax, rsp
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 176				; 000000b0H
	movaps	XMMWORD PTR [rax-40], xmm6
	mov	rsi, rdx
	mov	rdi, rcx
	mov	QWORD PTR this$GSCopy$[rsp], rcx

; 479  :         : runtime_error(_Makestr(_Errcode, _Message)), _Mycode(_Errcode) {}

	mov	rdx, r8
	lea	rcx, QWORD PTR [rax-72]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rbx, rax
	mov	QWORD PTR $T1[rsp], rax
	movaps	xmm6, XMMWORD PTR [rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4228 :         return _Mypair._Myval2._Mysize == 0;

	mov	rcx, QWORD PTR [rax+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error

; 467  :         if (!_Message.empty()) {

	test	rcx, rcx
	je	SHORT $LN19@System_err
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3271 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	rdx, QWORD PTR [rax+24]
	mov	rax, rdx
	sub	rax, rcx
	cmp	rax, 2
	jb	SHORT $LN20@System_err

; 3272 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 3273 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	rax, QWORD PTR [rcx+2]
	mov	QWORD PTR [rbx+16], rax

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	rax, rbx

; 2227 :         if (_Large_string_engaged()) {

	cmp	rdx, 16
	jb	SHORT $LN23@System_err

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rbx]
$LN23@System_err:

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	WORD PTR [rax+rcx], 8250		; 0000203aH

; 3276 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [rax+rcx+2], 0

; 3277 :             return *this;

	jmp	SHORT $LN19@System_err
$LN20@System_err:

; 3278 :         }
; 3279 : 
; 3280 :         return _Reallocate_grow_by(

	mov	QWORD PTR [rsp+32], 2
	lea	r9, OFFSET FLAT:??_C@_02LMMGGCAJ@?3?5@
	mov	edx, 2
	mov	rcx, rbx
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned __int64>
$LN19@System_err:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error

; 204  :         return category().message(value());

	movdqa	xmm0, xmm6
	psrldq	xmm0, 8
	movq	rcx, xmm0
	mov	rax, QWORD PTR [rcx]
	movd	r8d, xmm6
	lea	rdx, QWORD PTR $T2[rsp]
	call	QWORD PTR [rax+16]
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR $T2[rsp]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR $T2[rsp+24], 16
	cmovae	rdx, QWORD PTR $T2[rsp]

; 3241 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR $T2[rsp+16]
	mov	rcx, rbx
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	npad	1

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T2[rsp+24]
	cmp	rdx, 16
	jb	SHORT $LN65@System_err

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T2[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN77@System_err

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN77@System_err
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN77@System_err:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN65@System_err:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqu	XMMWORD PTR $T2[rsp+16], xmm0

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;
; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T2[rsp], 0
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T3[rsp], xmm0
	xorps	xmm1, xmm1

; 2293 :     size_type _Mysize = 0; // current length of string

	movdqu	XMMWORD PTR $T3[rsp+16], xmm1

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rbx]
	movups	XMMWORD PTR $T3[rsp], xmm0
	movups	xmm1, XMMWORD PTR [rbx+16]
	movups	XMMWORD PTR $T3[rsp+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error

; 472  :         return _Message;

	mov	QWORD PTR [rbx+16], 0
	mov	QWORD PTR [rbx+24], 15
	mov	BYTE PTR [rbx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error

; 479  :         : runtime_error(_Makestr(_Errcode, _Message)), _Mycode(_Errcode) {}

	lea	rdx, QWORD PTR $T3[rsp]
	mov	rcx, rdi
	call	??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR $T3[rsp+24]
	cmp	rdx, 16

; 4832 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN129@System_err

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T3[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN141@System_err

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN141@System_err
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN141@System_err:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN129@System_err:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error

; 479  :         : runtime_error(_Makestr(_Errcode, _Message)), _Mycode(_Errcode) {}

	lea	rax, OFFSET FLAT:??_7_System_error@std@@6B@
	mov	QWORD PTR [rdi], rax
	movaps	xmm0, XMMWORD PTR [rsi]
	movups	XMMWORD PTR [rdi+24], xmm0
	mov	rax, rdi
	movaps	xmm6, XMMWORD PTR [rsp+160]
	add	rsp, 176				; 000000b0H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN167@System_err:
??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_System_error::_System_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
this$GSCopy$ = 48
$T2 = 64
$T3 = 96
this$ = 208
_Errcode$ = 216
_Message$ = 224
?dtor$3@?0???0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA PROC ; `std::_System_error::_System_error'::`1'::dtor$3
	mov	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0???0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA ENDP ; `std::_System_error::_System_error'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
this$GSCopy$ = 48
$T2 = 64
$T3 = 96
this$ = 208
_Errcode$ = 216
_Message$ = 224
?dtor$4@?0???0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA PROC ; `std::_System_error::_System_error'::`1'::dtor$4
	lea	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0???0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA ENDP ; `std::_System_error::_System_error'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vcruntime_exception.h
;	COMDAT ??_G_System_error@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G_System_error@std@@UEAAPEAXI@Z PROC			; std::_System_error::`scalar deleting destructor', COMDAT
$LN16:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 89   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	rdi, rcx
	mov	QWORD PTR [rcx], rax
	mov	ebx, edx

; 90   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	call	QWORD PTR __imp___std_exception_destroy
	test	bl, 1
	je	SHORT $LN12@scalar
	mov	edx, 40					; 00000028H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN12@scalar:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_G_System_error@std@@UEAAPEAXI@Z ENDP			; std::_System_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vcruntime_exception.h
;	COMDAT ??1_System_error@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_System_error@std@@UEAA@XZ PROC			; std::_System_error::~_System_error, COMDAT

; 89   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax

; 90   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	rex_jmp	QWORD PTR __imp___std_exception_destroy
??1_System_error@std@@UEAA@XZ ENDP			; std::_System_error::~_System_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
;	COMDAT ??0system_error@std@@QEAA@Verror_code@1@@Z
_TEXT	SEGMENT
this$GSCopy$ = 32
$T1 = 40
this$ = 96
_Errcode$ = 104
??0system_error@std@@QEAA@Verror_code@1@@Z PROC		; std::system_error::system_error, COMDAT

; 489  :     system_error(error_code _Errcode) : _Mybase(_Errcode) {}

$LN49:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 80					; 00000050H
	movaps	xmm1, XMMWORD PTR [rdx]
	mov	rbx, rcx

; 204  :         return category().message(value());

	movdqa	xmm0, xmm1

; 489  :     system_error(error_code _Errcode) : _Mybase(_Errcode) {}

	mov	QWORD PTR this$GSCopy$[rsp], rcx

; 204  :         return category().message(value());

	psrldq	xmm0, 8

; 489  :     system_error(error_code _Errcode) : _Mybase(_Errcode) {}

	mov	rdi, rdx

; 204  :         return category().message(value());

	movq	rcx, xmm0
	movd	r8d, xmm1
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+16]

; 476  :     _System_error(error_code _Errcode) : runtime_error(_Errcode.message()), _Mycode(_Errcode) {}

	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rbx
	call	??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR $T1[rsp+24]
	cmp	rdx, 16

; 4832 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN24@system_err
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T1[rsp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN36@system_err

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN36@system_err
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN36@system_err:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN24@system_err:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error

; 476  :     _System_error(error_code _Errcode) : runtime_error(_Errcode.message()), _Mycode(_Errcode) {}

	movaps	xmm0, XMMWORD PTR [rdi]

; 489  :     system_error(error_code _Errcode) : _Mybase(_Errcode) {}

	lea	rax, OFFSET FLAT:??_7system_error@std@@6B@
	mov	QWORD PTR [rbx], rax
	mov	rax, rbx

; 476  :     _System_error(error_code _Errcode) : runtime_error(_Errcode.message()), _Mycode(_Errcode) {}

	movups	XMMWORD PTR [rbx+24], xmm0

; 489  :     system_error(error_code _Errcode) : _Mybase(_Errcode) {}

	mov	rbx, QWORD PTR [rsp+112]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
$LN46@system_err:
??0system_error@std@@QEAA@Verror_code@1@@Z ENDP		; std::system_error::system_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
;	COMDAT ??0system_error@std@@QEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Errcode$ = 72
_Message$ = 80
??0system_error@std@@QEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::system_error::system_error, COMDAT

; 491  :     system_error(error_code _Errcode, const string& _Message) : _Mybase(_Errcode, _Message) {}

$LN6:
	push	rbx
	sub	rsp, 48					; 00000030H
	movaps	xmm0, XMMWORD PTR [rdx]
	mov	rbx, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	movdqa	XMMWORD PTR $T1[rsp], xmm0
	call	??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error
	lea	rax, OFFSET FLAT:??_7system_error@std@@6B@
	mov	QWORD PTR [rbx], rax
	mov	rax, rbx
	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
??0system_error@std@@QEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::system_error::system_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vcruntime_exception.h
;	COMDAT ??_Gsystem_error@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gsystem_error@std@@UEAAPEAXI@Z PROC			; std::system_error::`scalar deleting destructor', COMDAT
$LN19:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 89   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	rdi, rcx
	mov	QWORD PTR [rcx], rax
	mov	ebx, edx

; 90   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	call	QWORD PTR __imp___std_exception_destroy
	test	bl, 1
	je	SHORT $LN15@scalar
	mov	edx, 40					; 00000028H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN15@scalar:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_Gsystem_error@std@@UEAAPEAXI@Z ENDP			; std::system_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vcruntime_exception.h
;	COMDAT ??1system_error@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1system_error@std@@UEAA@XZ PROC			; std::system_error::~system_error, COMDAT

; 89   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax

; 90   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	rex_jmp	QWORD PTR __imp___std_exception_destroy
??1system_error@std@@UEAA@XZ ENDP			; std::system_error::~system_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
;	COMDAT ?_Throw_system_error@std@@YAXW4errc@1@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 48
$T3 = 64
_Ec$dead$ = 128
?_Throw_system_error@std@@YAXW4errc@1@@Z PROC		; std::_Throw_system_error, COMDAT

; 515  : [[noreturn]] inline void _Throw_system_error(const errc _Ec) {

$LN4:
	sub	rsp, 120				; 00000078H

; 516  :     _THROW(system_error{_STD make_error_code(_Ec)});

	mov	edx, 22
	lea	rcx, QWORD PTR $T2[rsp]
	call	?make_error_code@std@@YA?AVerror_code@1@W4errc@1@@Z ; std::make_error_code
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	movups	xmm0, XMMWORD PTR [rax]
	movaps	XMMWORD PTR $T1[rsp], xmm0
	call	??0system_error@std@@QEAA@Verror_code@1@@Z ; std::system_error::system_error
	lea	rdx, OFFSET FLAT:_TI4?AVsystem_error@std@@
	lea	rcx, QWORD PTR $T3[rsp]
	call	_CxxThrowException
	int	3
$LN3@Throw_syst:
?_Throw_system_error@std@@YAXW4errc@1@@Z ENDP		; std::_Throw_system_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vcruntime_exception.h
;	COMDAT ??0system_error@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0system_error@std@@QEAA@AEBV01@@Z PROC		; std::system_error::system_error, COMDAT
$LN13:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx

; 72   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax
	lea	rdx, QWORD PTR [rcx+8]
	mov	rdi, rcx
	xorps	xmm0, xmm0

; 71   :         : _Data()

	movups	XMMWORD PTR [rdx], xmm0

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

	lea	rcx, QWORD PTR [rbx+8]
	call	QWORD PTR __imp___std_exception_copy
	lea	rax, OFFSET FLAT:??_7_System_error@std@@6B@
	mov	QWORD PTR [rdi], rax
	lea	rax, OFFSET FLAT:??_7system_error@std@@6B@
	movups	xmm0, XMMWORD PTR [rbx+24]
	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [rdi], rax
	mov	rax, rdi
	movups	XMMWORD PTR [rdi+24], xmm0
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0system_error@std@@QEAA@AEBV01@@Z ENDP		; std::system_error::system_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vcruntime_exception.h
;	COMDAT ??0_System_error@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0_System_error@std@@QEAA@AEBV01@@Z PROC		; std::_System_error::_System_error, COMDAT
$LN10:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx

; 72   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax
	lea	rdx, QWORD PTR [rcx+8]
	mov	rdi, rcx
	xorps	xmm0, xmm0

; 71   :         : _Data()

	movups	XMMWORD PTR [rdx], xmm0

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

	lea	rcx, QWORD PTR [rbx+8]
	call	QWORD PTR __imp___std_exception_copy
	lea	rax, OFFSET FLAT:??_7_System_error@std@@6B@
	mov	QWORD PTR [rdi], rax
	mov	rax, rdi
	movups	xmm0, XMMWORD PTR [rbx+24]
	mov	rbx, QWORD PTR [rsp+48]
	movups	XMMWORD PTR [rdi+24], xmm0
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0_System_error@std@@QEAA@AEBV01@@Z ENDP		; std::_System_error::_System_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
;	COMDAT ??0_System_error_message@std@@QEAA@K@Z
_TEXT	SEGMENT
this$ = 48
_Ec$ = 56
??0_System_error_message@std@@QEAA@K@Z PROC		; std::_System_error_message::_System_error_message, COMDAT

; 526  :     explicit _System_error_message(const unsigned long _Ec) noexcept

$LN5:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	eax, edx

; 527  :         : _Str(nullptr), _Length(_CSTD __std_system_error_allocate_message(_Ec, &_Str)) {}

	mov	QWORD PTR [rcx], 0
	mov	rdx, rcx
	mov	rbx, rcx
	mov	ecx, eax
	call	__std_system_error_allocate_message
	mov	QWORD PTR [rbx+8], rax
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0_System_error_message@std@@QEAA@K@Z ENDP		; std::_System_error_message::_System_error_message
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
;	COMDAT ??1_System_error_message@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_System_error_message@std@@QEAA@XZ PROC		; std::_System_error_message::~_System_error_message, COMDAT

; 533  :         _CSTD __std_system_error_deallocate_message(_Str);

	mov	rcx, QWORD PTR [rcx]
	jmp	__std_system_error_deallocate_message
??1_System_error_message@std@@QEAA@XZ ENDP		; std::_System_error_message::~_System_error_message
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?name@_Generic_error_category@std@@UEBAPEBDXZ PROC	; std::_Generic_error_category::name, COMDAT

; 542  :         return "generic";

	lea	rax, OFFSET FLAT:??_C@_07DCLBNMLN@generic@

; 543  :     }

	ret	0
?name@_Generic_error_category@std@@UEBAPEBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
this$ = 64
__$ReturnUdt$ = 72
_Errcode$ = 80
?message@_Generic_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT

; 545  :     _NODISCARD string message(int _Errcode) const override {

$LN21:
	push	rbx
	sub	rsp, 48					; 00000030H

; 546  :         return _Syserror_map(_Errcode);

	mov	ecx, r8d
	mov	rbx, rdx
	call	QWORD PTR __imp_?_Syserror_map@std@@YAPEBDH@Z
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 400  :             return __builtin_strlen(_First);

	mov	r8, -1

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rbx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rbx+16], 0

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rbx+24], 0
	npad	1
$LL17@message:

; 400  :             return __builtin_strlen(_First);

	inc	r8
	cmp	BYTE PTR [rax+r8], 0
	jne	SHORT $LL17@message

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	rdx, rax
	mov	rcx, rbx
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error

; 546  :         return _Syserror_map(_Errcode);

	mov	rax, rbx

; 547  :     }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
?message@_Generic_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_G_Generic_error_category@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G_Generic_error_category@std@@UEAAPEAXI@Z PROC	; std::_Generic_error_category::`scalar deleting destructor', COMDAT
$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	test	dl, 1
	je	SHORT $LN4@scalar
	mov	edx, 16
	call	??3@YAXPEAX_K@Z				; operator delete
$LN4@scalar:
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_G_Generic_error_category@std@@UEAAPEAXI@Z ENDP	; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1_Generic_error_category@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_Generic_error_category@std@@UEAA@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
	ret	0
??1_Generic_error_category@std@@UEAA@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
;	COMDAT ?name@_System_error_category@std@@UEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?name@_System_error_category@std@@UEBAPEBDXZ PROC	; std::_System_error_category::name, COMDAT

; 574  :         return "system";

	lea	rax, OFFSET FLAT:??_C@_06FHFOAHML@system@

; 575  :     }

	ret	0
?name@_System_error_category@std@@UEBAPEBDXZ ENDP	; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
;	COMDAT ?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
__$ReturnUdt$GSCopy$ = 40
_Msg$ = 40
__$ArrayPad$ = 56
this$ = 80
__$ReturnUdt$ = 88
_Errcode$ = 96
?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT

; 577  :     _NODISCARD string message(int _Errcode) const override {

$LN39:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbx, rdx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rdx
	xor	edi, edi

; 527  :         : _Str(nullptr), _Length(_CSTD __std_system_error_allocate_message(_Ec, &_Str)) {}

	mov	QWORD PTR _Msg$[rsp], rdi
	lea	rdx, QWORD PTR _Msg$[rsp]
	mov	ecx, r8d
	call	__std_system_error_allocate_message
	mov	QWORD PTR _Msg$[rsp+8], rax

; 579  :         if (_Msg._Length == 0) {

	xorps	xmm0, xmm0
	mov	rcx, rbx
	movups	XMMWORD PTR [rbx], xmm0
	mov	QWORD PTR [rbx+16], rdi
	mov	QWORD PTR [rbx+24], rdi

; 578  :         const _System_error_message _Msg(static_cast<unsigned long>(_Errcode));

	test	rax, rax

; 579  :         if (_Msg._Length == 0) {

	jne	SHORT $LN2@message
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2530 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Count);

	lea	r8d, QWORD PTR [rdi+13]
	lea	rdx, OFFSET FLAT:?_Unknown_error@?4??message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@H@Z@4QBDB ; `std::_System_error_category::message'::`5'::_Unknown_error
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error

; 582  :             return string{_Unknown_error, _Unknown_error_length};

	jmp	SHORT $LN36@message
$LN2@message:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2530 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Count);

	mov	r8, rax
	mov	rdx, QWORD PTR _Msg$[rsp]
$LN36@message:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error

; 587  :     }

	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
	mov	rcx, QWORD PTR _Msg$[rsp]
	call	__std_system_error_deallocate_message
	mov	rax, rbx
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
__$ReturnUdt$GSCopy$ = 40
_Msg$ = 40
__$ArrayPad$ = 56
this$ = 80
__$ReturnUdt$ = 88
_Errcode$ = 96
?dtor$0@?0??message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z@4HA PROC ; `std::_System_error_category::message'::`1'::dtor$0
	lea	rcx, QWORD PTR _Msg$[rdx]
	jmp	??1_System_error_message@std@@QEAA@XZ	; std::_System_error_message::~_System_error_message
?dtor$0@?0??message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z@4HA ENDP ; `std::_System_error_category::message'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UEBA?AVerror_condition@2@H@Z
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
_Errval$ = 64
?default_error_condition@_System_error_category@std@@UEBA?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT

; 589  :     _NODISCARD error_condition default_error_condition(int _Errval) const noexcept override {

$LN16:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	edi, r8d
	mov	rbx, rdx

; 590  :         if (_Errval == 0) {

	test	r8d, r8d
	jne	SHORT $LN2@default_er

; 261  :     error_condition(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) {}

	mov	DWORD PTR [rdx], r8d
	lea	rax, OFFSET FLAT:?_Static@?1???$_Immortalize_memcpy_image@V_Generic_error_category@std@@@std@@YAAEBV_Generic_error_category@1@XZ@4V21@B ; `std::_Immortalize_memcpy_image<std::_Generic_error_category>'::`2'::_Static
	mov	QWORD PTR [rdx+8], rax

; 597  :             return error_condition(_Errval, _STD system_category());
; 598  :         } else {
; 599  :             return error_condition(_Posv, _STD generic_category());
; 600  :         }
; 601  :     }

	mov	rax, rdx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@default_er:

; 591  :             return error_condition(0, _STD generic_category());
; 592  :         }
; 593  : 
; 594  :         // make error_condition for error code (generic if possible)
; 595  :         const int _Posv = _Winerror_map(_Errval);

	mov	ecx, edi
	call	QWORD PTR __imp_?_Winerror_map@std@@YAHH@Z

; 596  :         if (_Posv == 0) {

	test	eax, eax
	jne	SHORT $LN3@default_er

; 261  :     error_condition(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) {}

	mov	DWORD PTR [rbx], edi
	lea	rax, OFFSET FLAT:?_Static@?1???$_Immortalize_memcpy_image@V_System_error_category@std@@@std@@YAAEBV_System_error_category@1@XZ@4V21@B ; `std::_Immortalize_memcpy_image<std::_System_error_category>'::`2'::_Static

; 597  :             return error_condition(_Errval, _STD system_category());
; 598  :         } else {
; 599  :             return error_condition(_Posv, _STD generic_category());
; 600  :         }
; 601  :     }

	mov	QWORD PTR [rbx+8], rax
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN3@default_er:

; 261  :     error_condition(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) {}

	mov	DWORD PTR [rbx], eax
	lea	rax, OFFSET FLAT:?_Static@?1???$_Immortalize_memcpy_image@V_Generic_error_category@std@@@std@@YAAEBV_Generic_error_category@1@XZ@4V21@B ; `std::_Immortalize_memcpy_image<std::_Generic_error_category>'::`2'::_Static

; 597  :             return error_condition(_Errval, _STD system_category());
; 598  :         } else {
; 599  :             return error_condition(_Posv, _STD generic_category());
; 600  :         }
; 601  :     }

	mov	QWORD PTR [rbx+8], rax
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?default_error_condition@_System_error_category@std@@UEBA?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_G_System_error_category@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G_System_error_category@std@@UEAAPEAXI@Z PROC	; std::_System_error_category::`scalar deleting destructor', COMDAT
$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	test	dl, 1
	je	SHORT $LN4@scalar
	mov	edx, 16
	call	??3@YAXPEAX_K@Z				; operator delete
$LN4@scalar:
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_G_System_error_category@std@@UEAAPEAXI@Z ENDP	; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1_System_error_category@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_System_error_category@std@@UEAA@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
	ret	0
??1_System_error_category@std@@UEAA@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
;	COMDAT ?generic_category@std@@YAAEBVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAAEBVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 696  :     return _Immortalize_memcpy_image<_Generic_error_category>();

	lea	rax, OFFSET FLAT:?_Static@?1???$_Immortalize_memcpy_image@V_Generic_error_category@std@@@std@@YAAEBV_Generic_error_category@1@XZ@4V21@B ; `std::_Immortalize_memcpy_image<std::_Generic_error_category>'::`2'::_Static

; 697  : }

	ret	0
?generic_category@std@@YAAEBVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
;	COMDAT ?system_category@std@@YAAEBVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAAEBVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 704  :     return _Immortalize_memcpy_image<_System_error_category>();

	lea	rax, OFFSET FLAT:?_Static@?1???$_Immortalize_memcpy_image@V_System_error_category@std@@@std@@YAAEBV_System_error_category@1@XZ@4V21@B ; `std::_Immortalize_memcpy_image<std::_System_error_category>'::`2'::_Static

; 705  : }

	ret	0
?system_category@std@@YAAEBVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
;	COMDAT ?_Make_ec@std@@YA?AVerror_code@1@W4__std_win_error@@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Errno$ = 16
?_Make_ec@std@@YA?AVerror_code@1@W4__std_win_error@@@Z PROC ; std::_Make_ec, COMDAT

; 168  :     error_code(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) {}

	lea	rax, OFFSET FLAT:?_Static@?1???$_Immortalize_memcpy_image@V_System_error_category@std@@@std@@YAAEBV_System_error_category@1@XZ@4V21@B ; `std::_Immortalize_memcpy_image<std::_System_error_category>'::`2'::_Static
	mov	DWORD PTR [rcx], edx
	mov	QWORD PTR [rcx+8], rax

; 722  :     return {static_cast<int>(_Errno), _STD system_category()};

	mov	rax, rcx

; 723  : }

	ret	0
?_Make_ec@std@@YA?AVerror_code@1@W4__std_win_error@@@Z ENDP ; std::_Make_ec
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
;	COMDAT ?_Throw_system_error_from_std_win_error@std@@YAXW4__std_win_error@@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 48
$T3 = 64
_Errno$ = 128
?_Throw_system_error_from_std_win_error@std@@YAXW4__std_win_error@@@Z PROC ; std::_Throw_system_error_from_std_win_error, COMDAT

; 725  : [[noreturn]] inline void _Throw_system_error_from_std_win_error(const __std_win_error _Errno) {

$LN4:
	sub	rsp, 120				; 00000078H

; 726  :     _THROW(system_error{_Make_ec(_Errno)});

	mov	edx, ecx
	lea	rcx, QWORD PTR $T2[rsp]
	call	?_Make_ec@std@@YA?AVerror_code@1@W4__std_win_error@@@Z ; std::_Make_ec
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	movups	xmm0, XMMWORD PTR [rax]
	movaps	XMMWORD PTR $T1[rsp], xmm0
	call	??0system_error@std@@QEAA@Verror_code@1@@Z ; std::system_error::system_error
	lea	rdx, OFFSET FLAT:_TI4?AVsystem_error@std@@
	lea	rcx, QWORD PTR $T3[rsp]
	call	_CxxThrowException
	int	3
$LN3@Throw_syst:
?_Throw_system_error_from_std_win_error@std@@YAXW4__std_win_error@@@Z ENDP ; std::_Throw_system_error_from_std_win_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??1_Ref_count_base@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_Ref_count_base@std@@UEAA@XZ PROC			; std::_Ref_count_base::~_Ref_count_base, COMDAT

; 1147 :     virtual ~_Ref_count_base() noexcept {} // TRANSITION, should be non-virtual

	ret	0
??1_Ref_count_base@std@@UEAA@XZ ENDP			; std::_Ref_count_base::~_Ref_count_base
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ?_Incref@_Ref_count_base@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Incref@_Ref_count_base@std@@QEAAXXZ PROC		; std::_Ref_count_base::_Incref, COMDAT

; 1169 :         _MT_INCR(_Uses);

	lock inc DWORD PTR [rcx+8]

; 1170 :     }

	ret	0
?_Incref@_Ref_count_base@std@@QEAAXXZ ENDP		; std::_Ref_count_base::_Incref
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ?_Decref@_Ref_count_base@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Decref@_Ref_count_base@std@@QEAAXXZ PROC		; std::_Ref_count_base::_Decref, COMDAT

; 1176 :     void _Decref() noexcept { // decrement use count

$LN11:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1177 :         if (_MT_DECR(_Uses) == 0) {

	mov	edi, -1
	mov	rbx, rcx
	mov	eax, edi
	lock xadd DWORD PTR [rcx+8], eax
	cmp	eax, 1
	jne	SHORT $LN5@Decref

; 1178 :             _Destroy();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax]

; 1184 :         if (_MT_DECR(_Weaks) == 0) {

	lock xadd DWORD PTR [rbx+12], edi
	cmp	edi, 1
	jne	SHORT $LN5@Decref

; 1185 :             _Delete_this();

	mov	rax, QWORD PTR [rbx]
	mov	rcx, rbx
	call	QWORD PTR [rax+8]
$LN5@Decref:

; 1179 :             _Decwref();
; 1180 :         }
; 1181 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_Decref@_Ref_count_base@std@@QEAAXXZ ENDP		; std::_Ref_count_base::_Decref
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ?_Decwref@_Ref_count_base@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Decwref@_Ref_count_base@std@@QEAAXXZ PROC		; std::_Ref_count_base::_Decwref, COMDAT

; 1184 :         if (_MT_DECR(_Weaks) == 0) {

	mov	eax, -1
	lock xadd DWORD PTR [rcx+12], eax
	cmp	eax, 1
	jne	SHORT $LN2@Decwref

; 1185 :             _Delete_this();

	mov	rax, QWORD PTR [rcx]
	rex_jmp	QWORD PTR [rax+8]
$LN2@Decwref:

; 1186 :         }
; 1187 :     }

	ret	0
?_Decwref@_Ref_count_base@std@@QEAAXXZ ENDP		; std::_Ref_count_base::_Decwref
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ?_Get_deleter@_Ref_count_base@std@@UEBAPEAXAEBVtype_info@@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?_Get_deleter@_Ref_count_base@std@@UEBAPEAXAEBVtype_info@@@Z PROC ; std::_Ref_count_base::_Get_deleter, COMDAT

; 1194 :         return nullptr;

	xor	eax, eax

; 1195 :     }

	ret	0
?_Get_deleter@_Ref_count_base@std@@UEBAPEAXAEBVtype_info@@@Z ENDP ; std::_Ref_count_base::_Get_deleter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??0_Ref_count_base@std@@IEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0_Ref_count_base@std@@IEAA@XZ PROC			; std::_Ref_count_base::_Ref_count_base, COMDAT

; 1137 :     _Atomic_counter_t _Uses  = 1;

	mov	DWORD PTR [rcx+8], 1

; 1141 :     constexpr _Ref_count_base() noexcept = default; // non-atomic initializations

	mov	rax, rcx
	mov	DWORD PTR [rcx+12], 1
	ret	0
??0_Ref_count_base@std@@IEAA@XZ ENDP			; std::_Ref_count_base::_Ref_count_base
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
;	COMDAT __std_is_file_not_found
_TEXT	SEGMENT
_Error$ = 8
__std_is_file_not_found PROC				; COMDAT

; 52   :     switch (_Error) {

	sub	ecx, 2
	je	SHORT $LN4@std_is_fil
	sub	ecx, 1
	je	SHORT $LN4@std_is_fil
	sub	ecx, 50					; 00000032H
	je	SHORT $LN4@std_is_fil
	cmp	ecx, 70					; 00000046H
	je	SHORT $LN4@std_is_fil

; 58   :     default:
; 59   :         return false;

	xor	al, al

; 60   :     }
; 61   : }

	ret	0
$LN4@std_is_fil:

; 53   :     case __std_win_error::_File_not_found:
; 54   :     case __std_win_error::_Path_not_found:
; 55   :     case __std_win_error::_Error_bad_netpath:
; 56   :     case __std_win_error::_Invalid_name:
; 57   :         return true;

	mov	al, 1

; 60   :     }
; 61   : }

	ret	0
__std_is_file_not_found ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
;	COMDAT ??I@YA?AW4__std_fs_file_attr@@W40@0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??I@YA?AW4__std_fs_file_attr@@W40@0@Z PROC		; operator&, COMDAT

; 82   : _BITMASK_OPS(_EMPTY_ARGUMENT, __std_fs_file_attr)

	and	ecx, edx
	mov	eax, ecx
	ret	0
??I@YA?AW4__std_fs_file_attr@@W40@0@Z ENDP		; operator&
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
;	COMDAT ??I@YA?AW4__std_fs_stats_flags@@W40@0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??I@YA?AW4__std_fs_stats_flags@@W40@0@Z PROC		; operator&, COMDAT

; 127  : _BITMASK_OPS(_EMPTY_ARGUMENT, __std_fs_stats_flags)

	and	ecx, edx
	mov	eax, ecx
	ret	0
??I@YA?AW4__std_fs_stats_flags@@W40@0@Z ENDP		; operator&
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
;	COMDAT ??U@YA?AW4__std_fs_stats_flags@@W40@0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??U@YA?AW4__std_fs_stats_flags@@W40@0@Z PROC		; operator|, COMDAT

; 127  : _BITMASK_OPS(_EMPTY_ARGUMENT, __std_fs_stats_flags)

	or	ecx, edx
	mov	eax, ecx
	ret	0
??U@YA?AW4__std_fs_stats_flags@@W40@0@Z ENDP		; operator|
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
;	COMDAT ??_5@YAAEAW4__std_fs_stats_flags@@AEAW40@W40@@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??_5@YAAEAW4__std_fs_stats_flags@@AEAW40@W40@@Z PROC	; operator|=, COMDAT

; 127  : _BITMASK_OPS(_EMPTY_ARGUMENT, __std_fs_stats_flags)

	or	DWORD PTR [rcx], edx
	mov	rax, rcx
	ret	0
??_5@YAAEAW4__std_fs_stats_flags@@AEAW40@W40@@Z ENDP	; operator|=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
;	COMDAT ?_Symlink_hint_attributes@__std_fs_stats@@QEBA?AW4__std_fs_file_attr@@XZ
_TEXT	SEGMENT
this$ = 8
?_Symlink_hint_attributes@__std_fs_stats@@QEBA?AW4__std_fs_file_attr@@XZ PROC ; __std_fs_stats::_Symlink_hint_attributes, COMDAT

; 127  : _BITMASK_OPS(_EMPTY_ARGUMENT, __std_fs_stats_flags)

	mov	eax, DWORD PTR [rcx+28]
	shr	eax, 1
	test	al, 1

; 139  :         if (_STD _Bitmask_includes_any(_Available, __std_fs_stats_flags::_Attributes)) {

	je	SHORT $LN2@Symlink_hi

; 140  :             return _Attributes;

	mov	eax, DWORD PTR [rcx+16]

; 144  :     }

	ret	0
$LN2@Symlink_hi:

; 141  :         }
; 142  : 
; 143  :         return __std_fs_file_attr::_Invalid;

	mov	eax, -1					; ffffffffH

; 144  :     }

	ret	0
?_Symlink_hint_attributes@__std_fs_stats@@QEBA?AW4__std_fs_file_attr@@XZ ENDP ; __std_fs_stats::_Symlink_hint_attributes
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
;	COMDAT ??R_Is_slash_oper@std@@QEBA_N_W@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ch$ = 16
??R_Is_slash_oper@std@@QEBA_N_W@Z PROC			; std::_Is_slash_oper::operator(), COMDAT

; 384  :         return _Ch == L'\\' || _Ch == L'/';

	cmp	dx, 92					; 0000005cH
	je	SHORT $LN3@operator
	cmp	dx, 47					; 0000002fH
	je	SHORT $LN3@operator
	xor	al, al

; 385  :     }

	ret	0
$LN3@operator:

; 384  :         return _Ch == L'\\' || _Ch == L'/';

	mov	al, 1

; 385  :     }

	ret	0
??R_Is_slash_oper@std@@QEBA_N_W@Z ENDP			; std::_Is_slash_oper::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono
;	COMDAT ?_Check_convert_result@std@@YAHU__std_fs_convert_result@@@Z
_TEXT	SEGMENT
_Result$ = 48
?_Check_convert_result@std@@YAHU__std_fs_convert_result@@@Z PROC ; std::_Check_convert_result, COMDAT

; 51   : _NODISCARD inline int _Check_convert_result(const __std_fs_convert_result _Result) {

$LN7:
	sub	rsp, 40					; 00000028H

; 52   :     if (_Result._Err != __std_win_error::_Success) {

	mov	rax, rcx
	shr	rax, 32					; 00000020H
	test	eax, eax
	jne	SHORT $LN6@Check_conv

; 54   :     }
; 55   : 
; 56   :     return _Result._Len;

	mov	eax, ecx

; 57   : }

	add	rsp, 40					; 00000028H
	ret	0
$LN6@Check_conv:

; 53   :         _Throw_system_error_from_std_win_error(_Result._Err);

	mov	ecx, eax
	call	?_Throw_system_error_from_std_win_error@std@@YAXW4__std_win_error@@@Z ; std::_Throw_system_error_from_std_win_error
	int	3
$LN4@Check_conv:
?_Check_convert_result@std@@YAHU__std_fs_convert_result@@@Z ENDP ; std::_Check_convert_result
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$basic_string_view@DU?$char_traits@D@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$basic_string_view@DU?$char_traits@D@std@@@std@@QEAAX_K@Z PROC ; std::basic_string_view<char,std::char_traits<char> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rcx], xmm0
	ret	0
?__autoclassinit2@?$basic_string_view@DU?$char_traits@D@std@@@std@@QEAAX_K@Z ENDP ; std::basic_string_view<char,std::char_traits<char> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ?_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z
_TEXT	SEGMENT
$T1 = 48
__$ReturnUdt$ = 96
_Code_page$ = 104
_Input$ = 112
?_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z PROC ; std::filesystem::_Convert_narrow_to_wide, COMDAT

; 41   :     _NODISCARD inline wstring _Convert_narrow_to_wide(const __std_code_page _Code_page, const string_view _Input) {

$LN42:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 64					; 00000040H
	mov	r14d, edx
	mov	rbx, rcx
	xor	eax, eax
	mov	DWORD PTR $T1[rsp], eax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 7

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	WORD PTR [rcx], ax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 58   :         return _Output;

	mov	DWORD PTR $T1[rsp], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 1296 :         return _Mysize == 0;

	mov	rsi, QWORD PTR [r8+8]
	test	rsi, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 44   :         if (!_Input.empty()) {

	je	SHORT $LN34@Convert_na

; 45   :             if (_Input.size() > static_cast<size_t>(INT_MAX)) {

	cmp	rsi, 2147483647				; 7fffffffH
	ja	SHORT $LN38@Convert_na

; 47   :             }
; 48   : 
; 49   :             const int _Len = _Check_convert_result(__std_fs_convert_narrow_to_wide(

	mov	rbp, QWORD PTR [r8]
	mov	DWORD PTR [rsp+32], eax
	xor	r9d, r9d
	mov	r8d, esi
	mov	rdx, rbp
	mov	ecx, r14d
	call	__std_fs_convert_narrow_to_wide
	mov	rdi, rax
	shr	rax, 32					; 00000020H
	test	eax, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono

; 52   :     if (_Result._Err != __std_win_error::_Success) {

	jne	SHORT $LN39@Convert_na
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 52   :             _Output.resize(static_cast<size_t>(_Len));

	movsxd	rdx, edi
	mov	rcx, rbx
	call	?resize@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::resize
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	r9, rbx

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rbx+24], 8

; 2227 :         if (_Large_string_engaged()) {

	jb	SHORT $LN29@Convert_na

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r9, QWORD PTR [rbx]
$LN29@Convert_na:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 54   :             (void) _Check_convert_result(__std_fs_convert_narrow_to_wide(

	mov	DWORD PTR [rsp+32], edi
	mov	r8d, esi
	mov	rdx, rbp
	mov	ecx, r14d
	call	__std_fs_convert_narrow_to_wide
	mov	rcx, rax
	shr	rax, 32					; 00000020H
	test	eax, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono

; 52   :     if (_Result._Err != __std_win_error::_Success) {

	jne	SHORT $LN40@Convert_na
$LN34@Convert_na:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 58   :         return _Output;

	mov	rax, rbx

; 59   :     }

	mov	rbx, QWORD PTR [rsp+104]
	mov	rbp, QWORD PTR [rsp+112]
	add	rsp, 64					; 00000040H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN40@Convert_na:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono

; 53   :         _Throw_system_error_from_std_win_error(_Result._Err);

	shr	rcx, 32					; 00000020H
	call	?_Throw_system_error_from_std_win_error@std@@YAXW4__std_win_error@@@Z ; std::_Throw_system_error_from_std_win_error
	int	3
$LN38@Convert_na:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 46   :                 _Throw_system_error(errc::invalid_argument);

	call	?_Throw_system_error@std@@YAXW4errc@1@@Z ; std::_Throw_system_error
	int	3
$LN39@Convert_na:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono

; 53   :         _Throw_system_error_from_std_win_error(_Result._Err);

	shr	rdi, 32					; 00000020H
	mov	ecx, edi
	call	?_Throw_system_error_from_std_win_error@std@@YAXW4__std_win_error@@@Z ; std::_Throw_system_error_from_std_win_error
	int	3
$LN36@Convert_na:
?_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z ENDP ; std::filesystem::_Convert_narrow_to_wide
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
__$ReturnUdt$ = 96
_Code_page$ = 104
_Input$ = 112
?dtor$0@?0??_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z@4HA PROC ; `std::filesystem::_Convert_narrow_to_wide'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN6@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
$LN6@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z@4HA ENDP ; `std::filesystem::_Convert_narrow_to_wide'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?data@?$basic_string_view@DU?$char_traits@D@std@@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$basic_string_view@DU?$char_traits@D@std@@@std@@QEBAPEBDXZ PROC ; std::basic_string_view<char,std::char_traits<char> >::data, COMDAT

; 1300 :         return _Mydata;

	mov	rax, QWORD PTR [rcx]

; 1301 :     }

	ret	0
?data@?$basic_string_view@DU?$char_traits@D@std@@@std@@QEBAPEBDXZ ENDP ; std::basic_string_view<char,std::char_traits<char> >::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAPEA_WXZ
_TEXT	SEGMENT
this$ = 8
?data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAPEA_WXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::data, COMDAT

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 8

; 2227 :         if (_Large_string_engaged()) {

	jb	SHORT $LN8@data

; 4116 :         return _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR [rcx]

; 4117 :     }

	ret	0
$LN8@data:

; 4116 :         return _Mypair._Myval2._Myptr();

	mov	rax, rcx

; 4117 :     }

	ret	0
?data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAPEA_WXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAPEA_WXZ
_TEXT	SEGMENT
this$ = 8
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAPEA_WXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr, COMDAT

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 8

; 2226 :         value_type* _Result = _Bx._Buf;
; 2227 :         if (_Large_string_engaged()) {

	jb	SHORT $LN6@Myptr

; 2228 :             _Result = _Unfancy(_Bx._Ptr);
; 2229 :         }
; 2230 : 
; 2231 :         return _Result;

	mov	rax, QWORD PTR [rcx]

; 2232 :     }

	ret	0
$LN6@Myptr:

; 2228 :             _Result = _Unfancy(_Bx._Ptr);
; 2229 :         }
; 2230 : 
; 2231 :         return _Result;

	mov	rax, rcx

; 2232 :     }

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAPEA_WXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_NXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_string_engaged, COMDAT

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 8
	setae	al

; 2245 :     }

	ret	0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_NXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ?_Is_drive_prefix@filesystem@std@@YA_NQEB_W@Z
_TEXT	SEGMENT
_First$ = 8
?_Is_drive_prefix@filesystem@std@@YA_NQEB_W@Z PROC	; std::filesystem::_Is_drive_prefix, COMDAT

; 358  :         // test if _First points to a prefix of the form X:
; 359  :         // pre: _First points to at least 2 wchar_t instances
; 360  :         // pre: Little endian
; 361  :         auto _Value = _Unaligned_load<unsigned int>(_First);
; 362  :         _Value &= 0xFFFF'FFDFu; // transform lowercase drive letters into uppercase ones

	mov	eax, DWORD PTR [rcx]
	and	eax, -33				; ffffffdfH

; 363  :         _Value -= (static_cast<unsigned int>(L':') << (sizeof(wchar_t) * CHAR_BIT)) | L'A';

	sub	eax, 3801153				; 003a0041H

; 364  :         return _Value < 26;

	cmp	eax, 26
	setb	al

; 365  :     }

	ret	0
?_Is_drive_prefix@filesystem@std@@YA_NQEB_W@Z ENDP	; std::filesystem::_Is_drive_prefix
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ?_Has_drive_letter_prefix@filesystem@std@@YA_NQEB_W0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
?_Has_drive_letter_prefix@filesystem@std@@YA_NQEB_W0@Z PROC ; std::filesystem::_Has_drive_letter_prefix, COMDAT

; 368  :         // test if [_First, _Last) has a prefix of the form X:
; 369  :         return _Last - _First >= 2 && _Is_drive_prefix(_First);

	sub	rdx, rcx
	and	rdx, -2
	cmp	rdx, 4
	jl	SHORT $LN3@Has_drive_

; 362  :         _Value &= 0xFFFF'FFDFu; // transform lowercase drive letters into uppercase ones

	mov	eax, DWORD PTR [rcx]
	and	eax, -33				; ffffffdfH

; 363  :         _Value -= (static_cast<unsigned int>(L':') << (sizeof(wchar_t) * CHAR_BIT)) | L'A';

	sub	eax, 3801153				; 003a0041H

; 364  :         return _Value < 26;

	cmp	eax, 26

; 368  :         // test if [_First, _Last) has a prefix of the form X:
; 369  :         return _Last - _First >= 2 && _Is_drive_prefix(_First);

	jae	SHORT $LN3@Has_drive_
	mov	al, 1

; 370  :     }

	ret	0
$LN3@Has_drive_:

; 368  :         // test if [_First, _Last) has a prefix of the form X:
; 369  :         return _Last - _First >= 2 && _Is_drive_prefix(_First);

	xor	al, al

; 370  :     }

	ret	0
?_Has_drive_letter_prefix@filesystem@std@@YA_NQEB_W0@Z ENDP ; std::filesystem::_Has_drive_letter_prefix
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ?_Find_root_name_end@filesystem@std@@YAPEB_WQEB_W0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
?_Find_root_name_end@filesystem@std@@YAPEB_WQEB_W0@Z PROC ; std::filesystem::_Find_root_name_end, COMDAT

; 373  :         // attempt to parse [_First, _Last) as a path and return the end of root-name if it exists; otherwise, _First
; 374  : 
; 375  :         // This is the place in the generic grammar where library implementations have the most freedom.
; 376  :         // Below are example Windows paths, and what we've decided to do with them:
; 377  :         // * X:DriveRelative, X:\DosAbsolute
; 378  :         //   We parse X: as root-name, if and only if \ is present we consider that root-directory
; 379  :         // * \RootRelative
; 380  :         //   We parse no root-name, and \ as root-directory
; 381  :         // * \\server\share
; 382  :         //   We parse \\server as root-name, \ as root-directory, and share as the first element in relative-path.
; 383  :         //   Technically, Windows considers all of \\server\share the logical "root", but for purposes
; 384  :         //   of decomposition we want those split, so that path{R"(\\server\share)"}.replace_filename("other_share")
; 385  :         //   is \\server\other_share
; 386  :         // * \\?\device
; 387  :         // * \??\device
; 388  :         // * \\.\device
; 389  :         //   CreateFile appears to treat these as the same thing; we will set the first three characters as root-name
; 390  :         //   and the first \ as root-directory. Support for these prefixes varies by particular Windows version, but
; 391  :         //   for the purposes of path decomposition we don't need to worry about that.
; 392  :         // * \\?\UNC\server\share
; 393  :         //   MSDN explicitly documents the \\?\UNC syntax as a special case. What actually happens is that the device
; 394  :         //   Mup, or "Multiple UNC provider", owns the path \\?\UNC in the NT namespace, and is responsible for the
; 395  :         //   network file access. When the user says \\server\share, CreateFile translates that into
; 396  :         //   \\?\UNC\server\share to get the remote server access behavior. Because NT treats this like any other
; 397  :         //   device, we have chosen to treat this as the \\?\ case above.
; 398  :         if (_Last - _First < 2) {

	mov	r8, rdx
	sub	r8, rcx
	sar	r8, 1
	cmp	r8, 2
	jl	$LN9@Find_root_

; 362  :         _Value &= 0xFFFF'FFDFu; // transform lowercase drive letters into uppercase ones

	mov	r9d, DWORD PTR [rcx]
	mov	eax, r9d
	and	eax, -33				; ffffffdfH

; 363  :         _Value -= (static_cast<unsigned int>(L':') << (sizeof(wchar_t) * CHAR_BIT)) | L'A';

	sub	eax, 3801153				; 003a0041H

; 364  :         return _Value < 26;

	cmp	eax, 26

; 369  :         return _Last - _First >= 2 && _Is_drive_prefix(_First);

	jae	SHORT $LN55@Find_root_

; 399  :             return _First;
; 400  :         }
; 401  : 
; 402  :         if (_Has_drive_letter_prefix(_First, _Last)) { // check for X: first because it's the most common root-name
; 403  :             return _First + 2;

	lea	rax, QWORD PTR [rcx+4]

; 424  :     }

	ret	0
$LN55@Find_root_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 384  :         return _Ch == L'\\' || _Ch == L'/';

	cmp	r9w, 92					; 0000005cH
	je	SHORT $LN4@Find_root_
	cmp	r9w, 47					; 0000002fH
	jne	$LN9@Find_root_
$LN4@Find_root_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 413  :             && ((_Is_slash(_First[1]) && (_First[2] == L'?' || _First[2] == L'.')) // \\?\$ or \\.\$

	cmp	r8, 4
	jl	SHORT $LN5@Find_root_
	movzx	eax, WORD PTR [rcx+6]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 384  :         return _Ch == L'\\' || _Ch == L'/';

	cmp	ax, 92					; 0000005cH
	je	SHORT $LN64@Find_root_
	cmp	ax, 47					; 0000002fH
	jne	SHORT $LN62@Find_root_
$LN64@Find_root_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 413  :             && ((_Is_slash(_First[1]) && (_First[2] == L'?' || _First[2] == L'.')) // \\?\$ or \\.\$

	cmp	r8, 4
	je	SHORT $LN6@Find_root_
	movzx	eax, WORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 384  :         return _Ch == L'\\' || _Ch == L'/';

	cmp	ax, 92					; 0000005cH
	je	SHORT $LN62@Find_root_
	cmp	ax, 47					; 0000002fH
	je	SHORT $LN62@Find_root_
$LN6@Find_root_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 413  :             && ((_Is_slash(_First[1]) && (_First[2] == L'?' || _First[2] == L'.')) // \\?\$ or \\.\$

	movzx	eax, WORD PTR [rcx+2]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 384  :         return _Ch == L'\\' || _Ch == L'/';

	cmp	ax, 92					; 0000005cH
	je	SHORT $LN63@Find_root_
	cmp	ax, 47					; 0000002fH
	jne	SHORT $LN56@Find_root_
$LN63@Find_root_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 413  :             && ((_Is_slash(_First[1]) && (_First[2] == L'?' || _First[2] == L'.')) // \\?\$ or \\.\$

	movzx	r8d, WORD PTR [rcx+4]
	cmp	r8w, 63					; 0000003fH
	je	SHORT $LN7@Find_root_
	cmp	r8w, 46					; 0000002eH
	je	SHORT $LN7@Find_root_
$LN56@Find_root_:
	cmp	ax, 63					; 0000003fH
	jne	SHORT $LN62@Find_root_
	cmp	WORD PTR [rcx+4], ax
	jne	SHORT $LN62@Find_root_
$LN7@Find_root_:

; 414  :                 || (_First[1] == L'?' && _First[2] == L'?'))) { // \??\$
; 415  :             return _First + 3;

	lea	rax, QWORD PTR [rcx+6]

; 424  :     }

	ret	0
$LN5@Find_root_:

; 418  :         if (_Last - _First >= 3 && _Is_slash(_First[1]) && !_Is_slash(_First[2])) { // \\server

	cmp	r8, 3
	jl	SHORT $LN9@Find_root_
$LN62@Find_root_:
	movzx	eax, WORD PTR [rcx+2]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 384  :         return _Ch == L'\\' || _Ch == L'/';

	cmp	ax, 92					; 0000005cH
	je	SHORT $LN61@Find_root_
	cmp	ax, 47					; 0000002fH
	jne	SHORT $LN9@Find_root_
$LN61@Find_root_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 418  :         if (_Last - _First >= 3 && _Is_slash(_First[1]) && !_Is_slash(_First[2])) { // \\server

	movzx	eax, WORD PTR [rcx+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 384  :         return _Ch == L'\\' || _Ch == L'/';

	cmp	ax, 92					; 0000005cH
	je	SHORT $LN9@Find_root_
	cmp	ax, 47					; 0000002fH
	je	SHORT $LN9@Find_root_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 419  :             return _STD find_if(_First + 3, _Last, _Is_slash);

	lea	rax, QWORD PTR [rcx+6]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 6315 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rax, rdx
	je	SHORT $LN1@Find_root_
	npad	4
$LL44@Find_root_:

; 6316 :         if (_Pred(*_UFirst)) {

	movzx	ecx, WORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 384  :         return _Ch == L'\\' || _Ch == L'/';

	cmp	cx, 92					; 0000005cH
	je	SHORT $LN1@Find_root_
	cmp	cx, 47					; 0000002fH
	je	SHORT $LN1@Find_root_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 6315 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	rax, 2
	cmp	rax, rdx
	jne	SHORT $LL44@Find_root_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 424  :     }

	ret	0
$LN9@Find_root_:

; 420  :         }
; 421  : 
; 422  :         // no match
; 423  :         return _First;

	mov	rax, rcx
$LN1@Find_root_:

; 424  :     }

	ret	0
?_Find_root_name_end@filesystem@std@@YAPEB_WQEB_W0@Z ENDP ; std::filesystem::_Find_root_name_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?data@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QEBAPEB_WXZ
_TEXT	SEGMENT
this$ = 8
?data@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QEBAPEB_WXZ PROC ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::data, COMDAT

; 1300 :         return _Mydata;

	mov	rax, QWORD PTR [rcx]

; 1301 :     }

	ret	0
?data@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QEBAPEB_WXZ ENDP ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ?_Find_relative_path@filesystem@std@@YAPEB_WQEB_W0@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
?_Find_relative_path@filesystem@std@@YAPEB_WQEB_W0@Z PROC ; std::filesystem::_Find_relative_path, COMDAT

; 433  :     _NODISCARD inline const wchar_t* _Find_relative_path(const wchar_t* const _First, const wchar_t* const _Last) {

$LN26:
	sub	rsp, 40					; 00000028H

; 434  :         // attempt to parse [_First, _Last) as a path and return the start of relative-path
; 435  :         return _STD find_if_not(_Find_root_name_end(_First, _Last), _Last, _Is_slash);

	call	?_Find_root_name_end@filesystem@std@@YAPEB_WQEB_W0@Z ; std::filesystem::_Find_root_name_end
$LN24@Find_relat:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 371  :         if (!_Pred(*_UFirst)) {

	cmp	rax, rdx
	je	SHORT $LN21@Find_relat
	movzx	ecx, WORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 384  :         return _Ch == L'\\' || _Ch == L'/';

	cmp	cx, 92					; 0000005cH
	je	SHORT $LN18@Find_relat
	cmp	cx, 47					; 0000002fH
	jne	SHORT $LN21@Find_relat
$LN18@Find_relat:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 370  :     for (; _UFirst != _ULast; ++_UFirst) {

	add	rax, 2
	jmp	SHORT $LN24@Find_relat
$LN21@Find_relat:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 436  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Find_relative_path@filesystem@std@@YAPEB_WQEB_W0@Z ENDP ; std::filesystem::_Find_relative_path
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ?_Find_filename@filesystem@std@@YAPEB_WQEB_WPEB_W@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
?_Find_filename@filesystem@std@@YAPEB_WQEB_WPEB_W@Z PROC ; std::filesystem::_Find_filename, COMDAT

; 484  :     _NODISCARD inline const wchar_t* _Find_filename(const wchar_t* const _First, const wchar_t* _Last) {

$LN39:
	sub	rsp, 40					; 00000028H

; 435  :         return _STD find_if_not(_Find_root_name_end(_First, _Last), _Last, _Is_slash);

	call	?_Find_root_name_end@filesystem@std@@YAPEB_WQEB_W0@Z ; std::filesystem::_Find_root_name_end
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 370  :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rax, rdx
	je	SHORT $LN33@Find_filen
	npad	2
$LL10@Find_filen:

; 371  :         if (!_Pred(*_UFirst)) {

	movzx	ecx, WORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 384  :         return _Ch == L'\\' || _Ch == L'/';

	cmp	cx, 92					; 0000005cH
	je	SHORT $LN31@Find_filen
	cmp	cx, 47					; 0000002fH
	jne	SHORT $LN32@Find_filen
$LN31@Find_filen:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 370  :     for (; _UFirst != _ULast; ++_UFirst) {

	add	rax, 2
	cmp	rax, rdx
	jne	SHORT $LL10@Find_filen
$LN32@Find_filen:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 487  :         while (_Relative_path != _Last && !_Is_slash(_Last[-1])) {

	cmp	rax, rdx
	je	SHORT $LN33@Find_filen
	npad	3
$LL2@Find_filen:
	movzx	r8d, WORD PTR [rdx-2]
	lea	rcx, QWORD PTR [rdx-2]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 384  :         return _Ch == L'\\' || _Ch == L'/';

	cmp	r8w, 92					; 0000005cH
	je	SHORT $LN33@Find_filen
	cmp	r8w, 47					; 0000002fH
	je	SHORT $LN33@Find_filen
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 487  :         while (_Relative_path != _Last && !_Is_slash(_Last[-1])) {

	mov	rdx, rcx
	cmp	rax, rcx
	jne	SHORT $LL2@Find_filen
$LN33@Find_filen:

; 488  :             --_Last;
; 489  :         }
; 490  : 
; 491  :         return _Last;
; 492  :     }

	mov	rax, rdx
	add	rsp, 40					; 00000028H
	ret	0
?_Find_filename@filesystem@std@@YAPEB_WQEB_WPEB_W@Z ENDP ; std::filesystem::_Find_filename
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ?_Parse_filename@filesystem@std@@YA?AV?$basic_string_view@_WU?$char_traits@_W@std@@@2@V32@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 48
_Str$ = 56
?_Parse_filename@filesystem@std@@YA?AV?$basic_string_view@_WU?$char_traits@_W@std@@@2@V32@@Z PROC ; std::filesystem::_Parse_filename, COMDAT

; 494  :     _NODISCARD inline wstring_view _Parse_filename(const wstring_view _Str) {

$LN47:
	push	rbx
	sub	rsp, 32					; 00000020H

; 495  :         // attempt to parse _Str as a path and return the filename if it exists; otherwise, an empty view
; 496  :         const auto _First    = _Str.data();
; 497  :         const auto _Last     = _First + _Str.size();

	mov	rax, QWORD PTR [rdx+8]
	mov	rbx, rcx
	mov	rcx, QWORD PTR [rdx]
	lea	r11, QWORD PTR [rcx+rax*2]

; 435  :         return _STD find_if_not(_Find_root_name_end(_First, _Last), _Last, _Is_slash);

	mov	rdx, r11

; 498  :         const auto _Filename = _Find_filename(_First, _Last);

	mov	r10, r11

; 435  :         return _STD find_if_not(_Find_root_name_end(_First, _Last), _Last, _Is_slash);

	call	?_Find_root_name_end@filesystem@std@@YAPEB_WQEB_W0@Z ; std::filesystem::_Find_root_name_end
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 370  :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rax, r11
	je	SHORT $LN38@Parse_file
$LL12@Parse_file:

; 371  :         if (!_Pred(*_UFirst)) {

	movzx	ecx, WORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 384  :         return _Ch == L'\\' || _Ch == L'/';

	cmp	cx, 92					; 0000005cH
	je	SHORT $LN35@Parse_file
	cmp	cx, 47					; 0000002fH
	jne	SHORT $LN37@Parse_file
$LN35@Parse_file:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 370  :     for (; _UFirst != _ULast; ++_UFirst) {

	add	rax, 2
	cmp	rax, r11
	jne	SHORT $LL12@Parse_file
$LN37@Parse_file:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 487  :         while (_Relative_path != _Last && !_Is_slash(_Last[-1])) {

	cmp	rax, r11
	je	SHORT $LN38@Parse_file
$LL4@Parse_file:
	movzx	edx, WORD PTR [r10-2]
	lea	rcx, QWORD PTR [r10-2]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 384  :         return _Ch == L'\\' || _Ch == L'/';

	cmp	dx, 92					; 0000005cH
	je	SHORT $LN38@Parse_file
	cmp	dx, 47					; 0000002fH
	je	SHORT $LN38@Parse_file
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 487  :         while (_Relative_path != _Last && !_Is_slash(_Last[-1])) {

	mov	r10, rcx
	cmp	rax, rcx
	jne	SHORT $LL4@Parse_file
$LN38@Parse_file:

; 499  :         return wstring_view(_Filename, static_cast<size_t>(_Last - _Filename));

	sub	r11, r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 1209 :         : _Mydata(_Cts), _Mysize(_Count) {

	mov	QWORD PTR [rbx], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 499  :         return wstring_view(_Filename, static_cast<size_t>(_Last - _Filename));

	sar	r11, 1
	mov	rax, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 1209 :         : _Mydata(_Cts), _Mysize(_Count) {

	mov	QWORD PTR [rbx+8], r11
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 500  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Parse_filename@filesystem@std@@YA?AV?$basic_string_view@_WU?$char_traits@_W@std@@@2@V32@@Z ENDP ; std::filesystem::_Parse_filename
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ?_Range_compare@filesystem@std@@YAHQEB_W000@Z
_TEXT	SEGMENT
_Lfirst$ = 8
_Llast$ = 16
_Rfirst$ = 24
_Rlast$ = 32
?_Range_compare@filesystem@std@@YAHQEB_W000@Z PROC	; std::filesystem::_Range_compare, COMDAT

; 559  :         return _Traits_compare<char_traits<wchar_t>>(

	sub	r9, r8
	mov	r11, rdx
	sub	r11, rcx
	sar	r9, 1
	sar	r11, 1
	mov	r10, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 70   :     return _Right < _Left ? _Right : _Left;

	cmp	r9, r11
	mov	rax, r11
	cmovb	rax, r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 247  :             return __builtin_wmemcmp(_First1, _First2, _Count);

	test	rax, rax
	je	SHORT $LN4@Range_comp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 559  :         return _Traits_compare<char_traits<wchar_t>>(

	sub	r10, r8
$LL13@Range_comp:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 247  :             return __builtin_wmemcmp(_First1, _First2, _Count);

	movzx	ecx, WORD PTR [r10+r8]
	cmp	cx, WORD PTR [r8]
	jne	SHORT $LN14@Range_comp
	add	r8, 2
	sub	rax, 1
	jne	SHORT $LL13@Range_comp
$LN4@Range_comp:

; 561  :     if (_Left_size < _Right_size) {

	cmp	r11, r9
	jae	SHORT $LN5@Range_comp

; 562  :         return -1;

	mov	eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 561  :     }

	ret	0
$LN14@Range_comp:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 247  :             return __builtin_wmemcmp(_First1, _First2, _Count);

	mov	eax, 1
	mov	r8d, -1
	cmovb	eax, r8d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 561  :     }

	ret	0
$LN5@Range_comp:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 565  :     if (_Left_size > _Right_size) {

	xor	eax, eax
	cmp	r11, r9
	seta	al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 561  :     }

	ret	0
?_Range_compare@filesystem@std@@YAHQEB_W000@Z ENDP	; std::filesystem::_Range_compare
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ?_Is_dot_or_dotdot@filesystem@std@@YA_NAEBU__std_fs_find_data@@@Z
_TEXT	SEGMENT
_Data$ = 8
?_Is_dot_or_dotdot@filesystem@std@@YA_NAEBU__std_fs_find_data@@@Z PROC ; std::filesystem::_Is_dot_or_dotdot, COMDAT

; 569  :         // tests if _File_name of __std_fs_find_data is . or ..
; 570  :         if (_Data._File_name[0] != L'.') {

	cmp	WORD PTR [rcx+44], 46			; 0000002eH
	jne	SHORT $LN6@Is_dot_or_

; 571  :             return false;
; 572  :         }
; 573  : 
; 574  :         const auto _Second_char = _Data._File_name[1];

	movzx	eax, WORD PTR [rcx+46]

; 575  :         if (_Second_char == 0) {

	test	ax, ax
	jne	SHORT $LN3@Is_dot_or_

; 576  :             return true;

	mov	al, 1

; 584  :     }

	ret	0
$LN3@Is_dot_or_:

; 577  :         }
; 578  : 
; 579  :         if (_Second_char != L'.') {

	cmp	ax, 46					; 0000002eH
	jne	SHORT $LN6@Is_dot_or_

; 581  :         }
; 582  : 
; 583  :         return _Data._File_name[2] == 0;

	cmp	WORD PTR [rcx+48], 0
	sete	al

; 584  :     }

	ret	0
$LN6@Is_dot_or_:

; 580  :             return false;

	xor	al, al

; 584  :     }

	ret	0
?_Is_dot_or_dotdot@filesystem@std@@YA_NAEBU__std_fs_find_data@@@Z ENDP ; std::filesystem::_Is_dot_or_dotdot
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ??0_Find_file_handle@filesystem@std@@QEAA@$$QEAU012@@Z
_TEXT	SEGMENT
this$ = 8
_Rhs$ = 16
??0_Find_file_handle@filesystem@std@@QEAA@$$QEAU012@@Z PROC ; std::filesystem::_Find_file_handle::_Find_file_handle, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx], -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 591  :             : _Handle(_STD exchange(_Rhs._Handle, __std_fs_dir_handle::_Invalid)) {}

	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??0_Find_file_handle@filesystem@std@@QEAA@$$QEAU012@@Z ENDP ; std::filesystem::_Find_file_handle::_Find_file_handle
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ??4_Find_file_handle@filesystem@std@@QEAAAEAU012@$$QEAU012@@Z
_TEXT	SEGMENT
this$ = 48
_Rhs$ = 56
??4_Find_file_handle@filesystem@std@@QEAAAEAU012@$$QEAU012@@Z PROC ; std::filesystem::_Find_file_handle::operator=, COMDAT

; 593  :         _Find_file_handle& operator=(_Find_file_handle&& _Rhs) noexcept {

$LN9:
	push	rbx
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 593  :         _Find_file_handle& operator=(_Find_file_handle&& _Rhs) noexcept {

	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx], -1

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [rcx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rbx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 596  :             __std_fs_directory_iterator_close(_Tmp);

	call	__std_fs_directory_iterator_close

; 597  :             return *this;

	mov	rax, rbx

; 598  :         }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??4_Find_file_handle@filesystem@std@@QEAAAEAU012@$$QEAU012@@Z ENDP ; std::filesystem::_Find_file_handle::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ?_Open@_Find_file_handle@filesystem@std@@QEAA?AW4__std_win_error@@PEB_WPEAU__std_fs_find_data@@@Z
_TEXT	SEGMENT
this$ = 8
_Path_spec$ = 16
_Results$ = 24
?_Open@_Find_file_handle@filesystem@std@@QEAA?AW4__std_win_error@@PEB_WPEAU__std_fs_find_data@@@Z PROC ; std::filesystem::_Find_file_handle::_Open, COMDAT

; 600  :         _NODISCARD __std_win_error _Open(const wchar_t* _Path_spec, __std_fs_find_data* _Results) noexcept {

	mov	rax, rdx

; 601  :             return __std_fs_directory_iterator_open(_Path_spec, &_Handle, _Results);

	mov	rdx, rcx
	mov	rcx, rax
	jmp	__std_fs_directory_iterator_open
?_Open@_Find_file_handle@filesystem@std@@QEAA?AW4__std_win_error@@PEB_WPEAU__std_fs_find_data@@@Z ENDP ; std::filesystem::_Find_file_handle::_Open
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ??1_Find_file_handle@filesystem@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_Find_file_handle@filesystem@std@@QEAA@XZ PROC	; std::filesystem::_Find_file_handle::~_Find_file_handle, COMDAT

; 605  :             __std_fs_directory_iterator_close(_Handle);

	mov	rcx, QWORD PTR [rcx]
	jmp	__std_fs_directory_iterator_close
??1_Find_file_handle@filesystem@std@@QEAA@XZ ENDP	; std::filesystem::_Find_file_handle::~_Find_file_handle
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ??_0path@filesystem@std@@QEAAAEAV012@AEBV012@@Z
_TEXT	SEGMENT
this$ = 96
_Other$ = 104
??_0path@filesystem@std@@QEAAAEAV012@AEBV012@@Z PROC	; std::filesystem::path::operator/=, COMDAT

; 706  :         path& operator/=(const path& _Other) {

$LN129:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 64					; 00000040H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rsi, QWORD PTR [rdx+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 706  :         path& operator/=(const path& _Other) {

	mov	rdi, rdx
	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r10, rdx

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	rsi, 8

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN91@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r10, QWORD PTR [rdx]
$LN91@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 1172 :             const auto _Last  = _First + _Text.size();

	mov	r11, QWORD PTR [rdx+16]
	add	r11, r11

; 369  :         return _Last - _First >= 2 && _Is_drive_prefix(_First);

	mov	rcx, r11
	sar	rcx, 1

; 1172 :             const auto _Last  = _First + _Text.size();

	lea	rdx, QWORD PTR [r11+r10]

; 369  :         return _Last - _First >= 2 && _Is_drive_prefix(_First);

	cmp	rcx, 2
	jl	$LN12@operator

; 362  :         _Value &= 0xFFFF'FFDFu; // transform lowercase drive letters into uppercase ones

	mov	eax, DWORD PTR [r10]
	and	eax, -33				; ffffffdfH

; 363  :         _Value -= (static_cast<unsigned int>(L':') << (sizeof(wchar_t) * CHAR_BIT)) | L'A';

	sub	eax, 3801153				; 003a0041H

; 364  :         return _Value < 26;

	cmp	eax, 26

; 369  :         return _Last - _First >= 2 && _Is_drive_prefix(_First);

	jae	$LN12@operator

; 1174 :                 return _Last - _First >= 3 && _Is_slash(_First[2]);

	cmp	rcx, 3
	jl	SHORT $LN2@operator
	movzx	eax, WORD PTR [r10+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 384  :         return _Ch == L'\\' || _Ch == L'/';

	cmp	ax, 92					; 0000005cH
	je	$LN89@operator
	cmp	ax, 47					; 0000002fH
	je	$LN89@operator
$LN2@operator:
	mov	QWORD PTR [rsp+112], rbp
	mov	QWORD PTR [rsp+56], r12
	mov	QWORD PTR [rsp+48], r13
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	r13, QWORD PTR [rbx+24]
	mov	QWORD PTR [rsp+40], r14

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	r14, rbx
	mov	QWORD PTR [rsp+32], r15

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	r13, 8

; 2227 :         if (_Large_string_engaged()) {

	jb	SHORT $LN36@operator

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r14, QWORD PTR [rbx]
$LN36@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 722  :             const auto _My_last             = _My_first + _Text.size();

	mov	r12, QWORD PTR [rbx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r10, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 722  :             const auto _My_last             = _My_first + _Text.size();

	lea	rbp, QWORD PTR [r14+r12*2]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	rsi, 8

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN43@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r10, QWORD PTR [rdi]
$LN43@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 725  :             const auto _My_root_name_end    = _Find_root_name_end(_My_first, _My_last);

	mov	rdx, rbp
	lea	rsi, QWORD PTR [r11+r10]
	mov	rcx, r14
	call	?_Find_root_name_end@filesystem@std@@YAPEB_WQEB_W0@Z ; std::filesystem::_Find_root_name_end

; 726  :             const auto _Other_root_name_end = _Find_root_name_end(_Other_first, _Other_last);

	mov	rcx, r10
	mov	rdx, rsi
	mov	r11, rax
	call	?_Find_root_name_end@filesystem@std@@YAPEB_WQEB_W0@Z ; std::filesystem::_Find_root_name_end

; 728  :                 && _Range_compare(_My_first, _My_root_name_end, _Other_first, _Other_root_name_end) != 0) {

	mov	rdx, r11
	mov	r15, rax
	sub	rdx, r14
	cmp	r10, rax
	je	SHORT $LN87@operator

; 559  :         return _Traits_compare<char_traits<wchar_t>>(

	mov	r9, rax
	mov	r12, rdx
	sub	r9, r10
	sar	r12, 1
	sar	r9, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 70   :     return _Right < _Left ? _Right : _Left;

	mov	rcx, r12
	cmp	r9, r12
	cmovb	rcx, r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 247  :             return __builtin_wmemcmp(_First1, _First2, _Count);

	test	rcx, rcx
	je	SHORT $LN50@operator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 559  :         return _Traits_compare<char_traits<wchar_t>>(

	mov	r8, r14
	sub	r8, r10
	npad	8
$LL59@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 247  :             return __builtin_wmemcmp(_First1, _First2, _Count);

	movzx	eax, WORD PTR [r8+r10]
	cmp	ax, WORD PTR [r10]
	jne	SHORT $LN49@operator
	add	r10, 2
	sub	rcx, 1
	jne	SHORT $LL59@operator
$LN50@operator:

; 561  :     if (_Left_size < _Right_size) {

	cmp	r12, r9
	jb	SHORT $LN49@operator

; 562  :         return -1;
; 563  :     }
; 564  : 
; 565  :     if (_Left_size > _Right_size) {

	ja	SHORT $LN49@operator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 728  :                 && _Range_compare(_My_first, _My_root_name_end, _Other_first, _Other_root_name_end) != 0) {

	mov	r12, QWORD PTR [rbx+16]
$LN87@operator:

; 731  :             }
; 732  : 
; 733  :             if (_Other_root_name_end != _Other_last && _Is_slash(*_Other_root_name_end)) {

	cmp	r15, rsi
	je	SHORT $LN4@operator
	movzx	eax, WORD PTR [r15]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 384  :         return _Ch == L'\\' || _Ch == L'/';

	cmp	ax, 92					; 0000005cH
	je	SHORT $LN95@operator
	cmp	ax, 47					; 0000002fH
	jne	SHORT $LN4@operator
$LN95@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 735  :                 _Text.erase(static_cast<size_t>(_My_root_name_end - _My_first));

	sub	r11, r14
	sar	r11, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2260 :         if (_Mysize < _Off) {

	cmp	r12, r11
	jb	$LN127@operator

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	rax, rbx

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	r13, 8

; 2227 :         if (_Large_string_engaged()) {

	jb	SHORT $LN79@operator

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rbx]
$LN79@operator:

; 4815 :         _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _New_size], _Elem());

	xor	ecx, ecx
	mov	QWORD PTR [rbx+16], r11
	mov	WORD PTR [rax+r11*2], cx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 736  :             } else {

	jmp	SHORT $LN9@operator
$LN12@operator:

; 1179 :             return _First != _Find_root_name_end(_First, _Last);

	mov	rcx, r10
	call	?_Find_root_name_end@filesystem@std@@YAPEB_WQEB_W0@Z ; std::filesystem::_Find_root_name_end

; 707  :             // set *this to the path lexically resolved by _Other relative to *this
; 708  :             // examples:
; 709  :             // path{"cat"} / "c:/dog"; // yields "c:/dog"
; 710  :             // path{"cat"} / "c:"; // yields "c:"
; 711  :             // path{"c:"} / ""; // yields "c:"
; 712  :             // path{"c:cat"} / "/dog"; // yields "c:/dog"
; 713  :             // path{"c:cat"} / "c:dog"; // yields "c:cat/dog"
; 714  :             // path{"c:cat"} / "d:dog"; // yields "d:dog"
; 715  :             // several places herein quote the standard, but the standard's variable p is replaced with _Other
; 716  : 
; 717  :             if (_Other.is_absolute()) { // if _Other.is_absolute(), then op=(_Other)

	cmp	r10, rax
	je	$LN2@operator
$LN89@operator:

; 718  :                 return operator=(_Other);

	mov	rdx, rdi
	mov	rcx, rbx

; 770  :         }

	add	rsp, 64					; 00000040H
	pop	rdi
	pop	rsi
	pop	rbx

; 718  :                 return operator=(_Other);

	jmp	??4path@filesystem@std@@QEAAAEAV012@AEBV012@@Z ; std::filesystem::path::operator=
$LN49@operator:

; 729  :                 // if _Other.has_root_name() && _Other.root_name() != root_name(), then op=(_Other)
; 730  :                 return operator=(_Other);

	mov	rdx, rdi
	mov	rcx, rbx
	call	??4path@filesystem@std@@QEAAAEAV012@AEBV012@@Z ; std::filesystem::path::operator=
	jmp	SHORT $LN123@operator
$LN4@operator:

; 737  :                 // Otherwise, if (!has_root_directory && is_absolute) || has_filename appends path::preferred_separator
; 738  :                 if (_My_root_name_end == _My_last) {

	cmp	r11, rbp
	jne	SHORT $LN6@operator

; 739  :                     // Here, !has_root_directory && !has_filename
; 740  :                     // Going through our root_name kinds:
; 741  :                     // X: can't be absolute here, since those paths are absolute only when has_root_directory
; 742  :                     // \\?\ can't exist without has_root_directory
; 743  :                     // \\server can be absolute here
; 744  :                     if (_My_root_name_end - _My_first >= 3) {

	and	rdx, -2
	cmp	rdx, 6
	jl	SHORT $LN9@operator

; 745  :                         _Text.push_back(preferred_separator);
; 746  :                     }
; 747  :                 } else {

	jmp	SHORT $LN125@operator
$LN6@operator:

; 748  :                     // Here, has_root_directory || has_filename
; 749  :                     // If there is a trailing slash, the trailing slash might be part of root_directory.
; 750  :                     // If it is, has_root_directory && !has_filename, so the test fails.
; 751  :                     // If there is a trailing slash not part of root_directory, then !has_filename, so only
; 752  :                     // (!has_root_directory && is_absolute) remains
; 753  :                     // Going through our root_name kinds:
; 754  :                     // X:cat\ needs a root_directory to be absolute
; 755  :                     // \\server\cat must have a root_directory to exist with a relative_path
; 756  :                     // \\?\ must have a root_directory to exist
; 757  :                     // As a result, the test fails if there is a trailing slash.
; 758  :                     // If there is no trailing slash, then has_filename, so the test passes.
; 759  :                     // Therefore, the test passes if and only if there is no trailing slash.
; 760  :                     if (!_Is_slash(_My_last[-1])) {

	movzx	eax, WORD PTR [rbp-2]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 384  :         return _Ch == L'\\' || _Ch == L'/';

	cmp	ax, 92					; 0000005cH
	je	SHORT $LN9@operator
	cmp	ax, 47					; 0000002fH
	je	SHORT $LN9@operator
$LN125@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 768  :             _Text.append(_Other_root_name_end, static_cast<size_t>(_Other_last - _Other_root_name_end));

	mov	rcx, rbx
	call	?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::push_back
$LN9@operator:
	sub	rsi, r15
	mov	rdx, r15
	sar	rsi, 1
	mov	rcx, rbx
	mov	r8, rsi
	call	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append

; 769  :             return *this;

	mov	rax, rbx
$LN123@operator:
	mov	r14, QWORD PTR [rsp+40]
	mov	r13, QWORD PTR [rsp+48]
	mov	r12, QWORD PTR [rsp+56]
	mov	rbp, QWORD PTR [rsp+112]
	mov	r15, QWORD PTR [rsp+32]

; 770  :         }

	add	rsp, 64					; 00000040H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN127@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2261 :             _Xran();

	call	?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Xran
	int	3
$LN124@operator:
??_0path@filesystem@std@@QEAAAEAV012@AEBV012@@Z ENDP	; std::filesystem::path::operator/=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ?remove_filename@path@filesystem@std@@QEAAAEAV123@XZ
_TEXT	SEGMENT
this$ = 48
?remove_filename@path@filesystem@std@@QEAAAEAV123@XZ PROC ; std::filesystem::path::remove_filename, COMDAT

; 849  :         path& remove_filename() noexcept /* strengthened */ {

$LN65:
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	r10, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	r11, rcx

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 8

; 2227 :         if (_Large_string_engaged()) {

	jb	SHORT $LN54@remove_fil

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r11, QWORD PTR [rcx]
$LN54@remove_fil:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 852  :             const auto _Last     = _First + _Text.size();

	mov	rdi, QWORD PTR [rcx+16]
	lea	rdx, QWORD PTR [r11+rdi*2]

; 435  :         return _STD find_if_not(_Find_root_name_end(_First, _Last), _Last, _Is_slash);

	mov	rcx, r11
	call	?_Find_root_name_end@filesystem@std@@YAPEB_WQEB_W0@Z ; std::filesystem::_Find_root_name_end
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 370  :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rax, rdx
	je	SHORT $LN12@remove_fil
	npad	5
$LL19@remove_fil:

; 371  :         if (!_Pred(*_UFirst)) {

	movzx	ecx, WORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 384  :         return _Ch == L'\\' || _Ch == L'/';

	cmp	cx, 92					; 0000005cH
	je	SHORT $LN56@remove_fil
	cmp	cx, 47					; 0000002fH
	jne	SHORT $LN57@remove_fil
$LN56@remove_fil:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 370  :     for (; _UFirst != _ULast; ++_UFirst) {

	add	rax, 2
	cmp	rax, rdx
	jne	SHORT $LL19@remove_fil
$LN57@remove_fil:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 487  :         while (_Relative_path != _Last && !_Is_slash(_Last[-1])) {

	cmp	rax, rdx
	je	SHORT $LN12@remove_fil
	npad	3
$LL11@remove_fil:
	lea	r8, QWORD PTR [rdx-2]
	movzx	ecx, WORD PTR [r8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 384  :         return _Ch == L'\\' || _Ch == L'/';

	cmp	cx, 92					; 0000005cH
	je	SHORT $LN12@remove_fil
	cmp	cx, 47					; 0000002fH
	je	SHORT $LN12@remove_fil
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 488  :             --_Last;

	mov	rdx, r8

; 487  :         while (_Relative_path != _Last && !_Is_slash(_Last[-1])) {

	cmp	rax, r8
	jne	SHORT $LL11@remove_fil
$LN12@remove_fil:

; 853  :             const auto _Filename = _Find_filename(_First, _Last);
; 854  :             _Text._Orphan_all();
; 855  :             _Text.erase(static_cast<size_t>(_Filename - _First));

	sub	rdx, r11
	sar	rdx, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2260 :         if (_Mysize < _Off) {

	cmp	rdi, rdx
	jb	SHORT $LN63@remove_fil

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	rax, r10

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [r10+24], 8

; 2227 :         if (_Large_string_engaged()) {

	jb	SHORT $LN39@remove_fil

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [r10]
$LN39@remove_fil:

; 4815 :         _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _New_size], _Elem());

	mov	QWORD PTR [r10+16], rdx
	xor	ecx, ecx
	mov	WORD PTR [rax+rdx*2], cx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 856  :             return *this;

	mov	rax, r10

; 857  :         }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN63@remove_fil:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2261 :             _Xran();

	call	?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Xran
	int	3
$LN60@remove_fil:
?remove_filename@path@filesystem@std@@QEAAAEAV123@XZ ENDP ; std::filesystem::path::remove_filename
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ?_Remove_filename_and_separator@path@filesystem@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Remove_filename_and_separator@path@filesystem@std@@QEAAXXZ PROC ; std::filesystem::path::_Remove_filename_and_separator, COMDAT

; 859  :         void _Remove_filename_and_separator() noexcept { // remove filename and preceding non-root directory-separator

$LN110:
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	r10, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	r11, rcx

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 8

; 2227 :         if (_Large_string_engaged()) {

	jb	SHORT $LN8@Remove_fil

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r11, QWORD PTR [rcx]
$LN8@Remove_fil:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 861  :             const auto _Last          = _First + _Text.size();

	lea	rdi, QWORD PTR [rcx+16]
	mov	rsi, QWORD PTR [rdi]
	lea	rdx, QWORD PTR [r11+rsi*2]

; 862  :             const auto _Root_name_end = _Find_root_name_end(_First, _Last);

	mov	rcx, r11
	call	?_Find_root_name_end@filesystem@std@@YAPEB_WQEB_W0@Z ; std::filesystem::_Find_root_name_end

; 863  :             const auto _Root_dir_end =

	cmp	rdx, rax
	je	SHORT $LN101@Remove_fil
	movzx	ecx, WORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 384  :         return _Ch == L'\\' || _Ch == L'/';

	cmp	cx, 92					; 0000005cH
	je	SHORT $LN100@Remove_fil
	cmp	cx, 47					; 0000002fH
	jne	SHORT $LN4@Remove_fil
$LN100@Remove_fil:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 863  :             const auto _Root_dir_end =

	add	rax, 2
$LN4@Remove_fil:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 1681 :     return _Left._Get_current() != _Right._Get_current();

	cmp	rdx, rax

; 6315 :     for (; _UFirst != _ULast; ++_UFirst) {

	je	SHORT $LN101@Remove_fil
	npad	6
$LL33@Remove_fil:

; 6316 :         if (_Pred(*_UFirst)) {

	lea	r8, QWORD PTR [rdx-2]
	movzx	ecx, WORD PTR [r8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 384  :         return _Ch == L'\\' || _Ch == L'/';

	cmp	cx, 92					; 0000005cH
	je	SHORT $LN90@Remove_fil
	cmp	cx, 47					; 0000002fH
	je	SHORT $LN90@Remove_fil
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 1544 :         --current;

	mov	rdx, r8

; 1681 :     return _Left._Get_current() != _Right._Get_current();

	cmp	r8, rax

; 6315 :     for (; _UFirst != _ULast; ++_UFirst) {

	jne	SHORT $LL33@Remove_fil
$LN90@Remove_fil:

; 1681 :     return _Left._Get_current() != _Right._Get_current();

	cmp	rdx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 370  :     for (; _UFirst != _ULast; ++_UFirst) {

	je	SHORT $LN101@Remove_fil
$LL55@Remove_fil:

; 371  :         if (!_Pred(*_UFirst)) {

	lea	r8, QWORD PTR [rdx-2]
	movzx	ecx, WORD PTR [r8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 384  :         return _Ch == L'\\' || _Ch == L'/';

	cmp	cx, 92					; 0000005cH
	je	SHORT $LN98@Remove_fil
	cmp	cx, 47					; 0000002fH
	jne	SHORT $LN101@Remove_fil
$LN98@Remove_fil:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 1544 :         --current;

	mov	rdx, r8

; 1681 :     return _Left._Get_current() != _Right._Get_current();

	cmp	r8, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 370  :     for (; _UFirst != _ULast; ++_UFirst) {

	jne	SHORT $LL55@Remove_fil
$LN101@Remove_fil:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 1758 :     return _Right._Get_current() - _Left._Get_current();

	sub	rdx, r11
	sar	rdx, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2260 :         if (_Mysize < _Off) {

	cmp	rsi, rdx
	jb	SHORT $LN108@Remove_fil

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [r10+24], 8

; 2227 :         if (_Large_string_engaged()) {

	jb	SHORT $LN79@Remove_fil

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r10, QWORD PTR [r10]
$LN79@Remove_fil:

; 4815 :         _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _New_size], _Elem());

	mov	QWORD PTR [rdi], rdx
	xor	eax, eax
	mov	WORD PTR [r10+rdx*2], ax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 878  :         }

	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN108@Remove_fil:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2261 :             _Xran();

	call	?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Xran
	int	3
$LN104@Remove_fil:
?_Remove_filename_and_separator@path@filesystem@std@@QEAAXXZ ENDP ; std::filesystem::path::_Remove_filename_and_separator
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ?replace_filename@path@filesystem@std@@QEAAAEAV123@AEBV123@@Z
_TEXT	SEGMENT
this$ = 48
_Replacement$ = 56
?replace_filename@path@filesystem@std@@QEAAAEAV123@AEBV123@@Z PROC ; std::filesystem::path::replace_filename, COMDAT

; 880  :         path& replace_filename(const path& _Replacement) { // remove any filename from *this and append _Replacement

$LN69:
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, rdx
	mov	r10, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	r11, rcx

; 2227 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rcx+24], 8
	jb	SHORT $LN58@replace_fi

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r11, QWORD PTR [rcx]
$LN58@replace_fi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 852  :             const auto _Last     = _First + _Text.size();

	mov	rdi, QWORD PTR [rcx+16]
	lea	rdx, QWORD PTR [r11+rdi*2]

; 435  :         return _STD find_if_not(_Find_root_name_end(_First, _Last), _Last, _Is_slash);

	mov	rcx, r11
	call	?_Find_root_name_end@filesystem@std@@YAPEB_WQEB_W0@Z ; std::filesystem::_Find_root_name_end
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 370  :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rax, rdx
	je	SHORT $LN15@replace_fi
$LL22@replace_fi:

; 371  :         if (!_Pred(*_UFirst)) {

	movzx	ecx, WORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 384  :         return _Ch == L'\\' || _Ch == L'/';

	cmp	cx, 92					; 0000005cH
	je	SHORT $LN60@replace_fi
	cmp	cx, 47					; 0000002fH
	jne	SHORT $LN61@replace_fi
$LN60@replace_fi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 370  :     for (; _UFirst != _ULast; ++_UFirst) {

	add	rax, 2
	cmp	rax, rdx
	jne	SHORT $LL22@replace_fi
$LN61@replace_fi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 487  :         while (_Relative_path != _Last && !_Is_slash(_Last[-1])) {

	cmp	rax, rdx
	je	SHORT $LN15@replace_fi
	npad	1
$LL14@replace_fi:
	lea	r8, QWORD PTR [rdx-2]
	movzx	ecx, WORD PTR [r8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 384  :         return _Ch == L'\\' || _Ch == L'/';

	cmp	cx, 92					; 0000005cH
	je	SHORT $LN15@replace_fi
	cmp	cx, 47					; 0000002fH
	je	SHORT $LN15@replace_fi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 488  :             --_Last;

	mov	rdx, r8

; 487  :         while (_Relative_path != _Last && !_Is_slash(_Last[-1])) {

	cmp	rax, r8
	jne	SHORT $LL14@replace_fi
$LN15@replace_fi:

; 855  :             _Text.erase(static_cast<size_t>(_Filename - _First));

	sub	rdx, r11
	sar	rdx, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2260 :         if (_Mysize < _Off) {

	cmp	rdi, rdx
	jb	SHORT $LN67@replace_fi

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	rax, r10

; 2227 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [r10+24], 8
	jb	SHORT $LN42@replace_fi

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [r10]
$LN42@replace_fi:

; 4815 :         _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _New_size], _Elem());

	mov	QWORD PTR [r10+16], rdx
	xor	ecx, ecx
	mov	WORD PTR [rax+rdx*2], cx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 882  :             return operator/=(_Replacement);

	mov	rdx, rsi
	mov	rcx, r10

; 883  :         }

	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi

; 882  :             return operator/=(_Replacement);

	jmp	??_0path@filesystem@std@@QEAAAEAV012@AEBV012@@Z ; std::filesystem::path::operator/=
$LN67@replace_fi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2261 :             _Xran();

	call	?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Xran
	npad	1
$LN64@replace_fi:
?replace_filename@path@filesystem@std@@QEAAAEAV123@AEBV123@@Z ENDP ; std::filesystem::path::replace_filename
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ?native@path@filesystem@std@@QEBAAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@3@XZ
_TEXT	SEGMENT
this$ = 8
?native@path@filesystem@std@@QEBAAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@3@XZ PROC ; std::filesystem::path::native, COMDAT

; 913  :             // return a reference to the internally stored wstring in the native format
; 914  :             return _Text;

	mov	rax, rcx

; 915  :         }

	ret	0
?native@path@filesystem@std@@QEBAAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@3@XZ ENDP ; std::filesystem::path::native
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ?c_str@path@filesystem@std@@QEBAPEB_WXZ
_TEXT	SEGMENT
this$ = 8
?c_str@path@filesystem@std@@QEBAPEB_WXZ PROC		; std::filesystem::path::c_str, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 8

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN10@c_str
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 919  :             return _Text.c_str();

	mov	rax, QWORD PTR [rcx]

; 920  :         }

	ret	0
$LN10@c_str:

; 919  :             return _Text.c_str();

	mov	rax, rcx

; 920  :         }

	ret	0
?c_str@path@filesystem@std@@QEBAPEB_WXZ ENDP		; std::filesystem::path::c_str
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ?string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ
_TEXT	SEGMENT
$T1 = 48
__$ReturnUdt$GSCopy$ = 56
this$ = 96
__$ReturnUdt$ = 104
?string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ PROC ; std::filesystem::path::string, COMDAT

; 933  :         _NODISCARD _STD string string() const { // convert the native path from this instance into a string

$LN66:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 64					; 00000040H
	mov	rbx, rdx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rdx
	xor	edi, edi
	mov	DWORD PTR $T1[rsp], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rsi, rcx

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rcx+24], 8
	jb	SHORT $LN12@string

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rsi, QWORD PTR [rcx]
$LN12@string:

; 4041 :         return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize};

	mov	rbp, QWORD PTR [rcx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 152  :             return _Convert_wide_to_narrow<_Traits>(__std_fs_code_page(), _Input, _Al);

	call	__std_fs_code_page
	mov	r14d, eax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rbx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], rdi

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono

; 80   :     return _Output;

	mov	DWORD PTR $T1[rsp], 8
	test	rbp, rbp

; 54   :     }
; 55   : 
; 56   :     return _Result._Len;
; 57   : }
; 58   : 
; 59   : template <class _Traits, class _Alloc>
; 60   : _NODISCARD basic_string<typename _Traits::char_type, _Traits, _Alloc> _Convert_wide_to_narrow(
; 61   :     const __std_code_page _Code_page, const wstring_view _Input, const _Alloc& _Al) {
; 62   :     basic_string<typename _Traits::char_type, _Traits, _Alloc> _Output(_Al);
; 63   : 
; 64   :     if (!_Input.empty()) {

	je	SHORT $LN55@string

; 65   :         if (_Input.size() > static_cast<size_t>(INT_MAX)) {

	cmp	rbp, 2147483647				; 7fffffffH
	ja	SHORT $LN62@string

; 67   :         }
; 68   : 
; 69   :         const int _Len = _Check_convert_result(

	mov	DWORD PTR [rsp+32], edi
	xor	r9d, r9d
	mov	r8d, ebp
	mov	rdx, rsi
	mov	ecx, eax
	call	__std_fs_convert_wide_to_narrow
	mov	rdi, rax
	shr	rax, 32					; 00000020H
	test	eax, eax

; 52   :     if (_Result._Err != __std_win_error::_Success) {

	jne	SHORT $LN63@string

; 72   :         _Output.resize(static_cast<size_t>(_Len));

	movsxd	rdx, edi
	mov	rcx, rbx
	call	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	r9, rbx

; 2227 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rbx+24], 16
	jb	SHORT $LN50@string

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r9, QWORD PTR [rbx]
$LN50@string:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono

; 76   :         (void) _Check_convert_result(__std_fs_convert_wide_to_narrow(

	mov	DWORD PTR [rsp+32], edi
	mov	r8d, ebp
	mov	rdx, rsi
	mov	ecx, r14d
	call	__std_fs_convert_wide_to_narrow
	mov	rcx, rax
	shr	rax, 32					; 00000020H
	test	eax, eax

; 52   :     if (_Result._Err != __std_win_error::_Success) {

	jne	SHORT $LN64@string
$LN55@string:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 934  :             return string<char>();

	mov	rax, rbx

; 935  :         }

	mov	rbx, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+112]
	add	rsp, 64					; 00000040H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN64@string:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono

; 53   :         _Throw_system_error_from_std_win_error(_Result._Err);

	shr	rcx, 32					; 00000020H
	call	?_Throw_system_error_from_std_win_error@std@@YAXW4__std_win_error@@@Z ; std::_Throw_system_error_from_std_win_error
	int	3
$LN62@string:

; 66   :             _Throw_system_error(errc::invalid_argument);

	call	?_Throw_system_error@std@@YAXW4errc@1@@Z ; std::_Throw_system_error
	int	3
$LN63@string:

; 53   :         _Throw_system_error_from_std_win_error(_Result._Err);

	shr	rdi, 32					; 00000020H
	mov	ecx, edi
	call	?_Throw_system_error_from_std_win_error@std@@YAXW4__std_win_error@@@Z ; std::_Throw_system_error_from_std_win_error
	int	3
$LN60@string:
?string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ ENDP ; std::filesystem::path::string
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
__$ReturnUdt$GSCopy$ = 56
this$ = 96
__$ReturnUdt$ = 104
?dtor$3@?0??string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ@4HA PROC ; `std::filesystem::path::string'::`1'::dtor$3
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN27@dtor$3
	and	DWORD PTR $T1[rbp], -9
	mov	rcx, QWORD PTR __$ReturnUdt$GSCopy$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN27@dtor$3:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$3@?0??string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ@4HA ENDP ; `std::filesystem::path::string'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ?filename@path@filesystem@std@@QEBA?AV123@XZ
_TEXT	SEGMENT
__$ReturnUdt$GSCopy$ = 40
$T1 = 40
this$ = 80
__$ReturnUdt$ = 88
?filename@path@filesystem@std@@QEBA?AV123@XZ PROC	; std::filesystem::path::filename, COMDAT

; 1107 :         _NODISCARD path filename() const {

$LN61:
	push	rbx
	sub	rsp, 64					; 00000040H
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rdx
	mov	rbx, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 8

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r8, rcx

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN8@filename

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r8, QWORD PTR [rcx]
$LN8@filename:

; 1209 :         : _Mydata(_Cts), _Mysize(_Count) {

	mov	rax, QWORD PTR [rcx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 435  :         return _STD find_if_not(_Find_root_name_end(_First, _Last), _Last, _Is_slash);

	mov	rcx, r8

; 497  :         const auto _Last     = _First + _Str.size();

	lea	r11, QWORD PTR [r8+rax*2]

; 435  :         return _STD find_if_not(_Find_root_name_end(_First, _Last), _Last, _Is_slash);

	mov	rdx, r11

; 498  :         const auto _Filename = _Find_filename(_First, _Last);

	mov	r10, r11

; 435  :         return _STD find_if_not(_Find_root_name_end(_First, _Last), _Last, _Is_slash);

	call	?_Find_root_name_end@filesystem@std@@YAPEB_WQEB_W0@Z ; std::filesystem::_Find_root_name_end
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 370  :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rax, r11
	je	SHORT $LN51@filename
$LL25@filename:

; 371  :         if (!_Pred(*_UFirst)) {

	movzx	ecx, WORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 384  :         return _Ch == L'\\' || _Ch == L'/';

	cmp	cx, 92					; 0000005cH
	je	SHORT $LN48@filename
	cmp	cx, 47					; 0000002fH
	jne	SHORT $LN50@filename
$LN48@filename:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 370  :     for (; _UFirst != _ULast; ++_UFirst) {

	add	rax, 2
	cmp	rax, r11
	jne	SHORT $LL25@filename
$LN50@filename:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 487  :         while (_Relative_path != _Last && !_Is_slash(_Last[-1])) {

	cmp	rax, r11
	je	SHORT $LN51@filename
	npad	13
$LL17@filename:
	movzx	edx, WORD PTR [r10-2]
	lea	rcx, QWORD PTR [r10-2]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 384  :         return _Ch == L'\\' || _Ch == L'/';

	cmp	dx, 92					; 0000005cH
	je	SHORT $LN51@filename
	cmp	dx, 47					; 0000002fH
	je	SHORT $LN51@filename
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 487  :         while (_Relative_path != _Last && !_Is_slash(_Last[-1])) {

	mov	r10, rcx
	cmp	rax, rcx
	jne	SHORT $LL17@filename
$LN51@filename:

; 499  :         return wstring_view(_Filename, static_cast<size_t>(_Last - _Filename));

	sub	r11, r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 1209 :         : _Mydata(_Cts), _Mysize(_Count) {

	mov	QWORD PTR $T1[rsp], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 499  :         return wstring_view(_Filename, static_cast<size_t>(_Last - _Filename));

	sar	r11, 1

; 1109 :             return _Parse_filename(_Text);

	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 1209 :         : _Mydata(_Cts), _Mysize(_Count) {

	mov	QWORD PTR $T1[rsp+8], r11
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 1109 :             return _Parse_filename(_Text);

	call	??$?0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@2@W4format@012@@Z ; std::filesystem::path::path<std::basic_string_view<wchar_t,std::char_traits<wchar_t> >,0>
	mov	rax, rbx

; 1110 :         }

	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
?filename@path@filesystem@std@@QEBA?AV123@XZ ENDP	; std::filesystem::path::filename
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ?is_absolute@path@filesystem@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 48
?is_absolute@path@filesystem@std@@QEBA_NXZ PROC		; std::filesystem::path::is_absolute, COMDAT

; 1166 :         _NODISCARD bool is_absolute() const noexcept /* strengthened */ {

$LN27:
	sub	rsp, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 8

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r10, rcx

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN9@is_absolut

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r10, QWORD PTR [rcx]
$LN9@is_absolut:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 1172 :             const auto _Last  = _First + _Text.size();

	mov	rdx, QWORD PTR [rcx+16]
	add	rdx, rdx
	lea	rcx, QWORD PTR [rdx+r10]

; 369  :         return _Last - _First >= 2 && _Is_drive_prefix(_First);

	sar	rdx, 1
	cmp	rdx, 2
	jl	SHORT $LN2@is_absolut

; 362  :         _Value &= 0xFFFF'FFDFu; // transform lowercase drive letters into uppercase ones

	mov	eax, DWORD PTR [r10]
	and	eax, -33				; ffffffdfH

; 363  :         _Value -= (static_cast<unsigned int>(L':') << (sizeof(wchar_t) * CHAR_BIT)) | L'A';

	sub	eax, 3801153				; 003a0041H

; 364  :         return _Value < 26;

	cmp	eax, 26

; 369  :         return _Last - _First >= 2 && _Is_drive_prefix(_First);

	jae	SHORT $LN2@is_absolut

; 1174 :                 return _Last - _First >= 3 && _Is_slash(_First[2]);

	cmp	rdx, 3
	jl	SHORT $LN4@is_absolut
	movzx	eax, WORD PTR [r10+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 384  :         return _Ch == L'\\' || _Ch == L'/';

	cmp	ax, 92					; 0000005cH
	je	SHORT $LN23@is_absolut
	cmp	ax, 47					; 0000002fH
	jne	SHORT $LN4@is_absolut
$LN23@is_absolut:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 1174 :                 return _Last - _First >= 3 && _Is_slash(_First[2]);

	mov	al, 1

; 1180 :         }

	add	rsp, 40					; 00000028H
	ret	0
$LN4@is_absolut:

; 1174 :                 return _Last - _First >= 3 && _Is_slash(_First[2]);

	xor	al, al

; 1180 :         }

	add	rsp, 40					; 00000028H
	ret	0
$LN2@is_absolut:

; 1175 :             }
; 1176 : 
; 1177 :             // if root-name is otherwise nonempty, then it must be one of the always-absolute prefixes like
; 1178 :             // \\?\ or \\server, so the path is absolute. Otherwise it is relative.
; 1179 :             return _First != _Find_root_name_end(_First, _Last);

	mov	rdx, rcx
	mov	rcx, r10
	call	?_Find_root_name_end@filesystem@std@@YAPEB_WQEB_W0@Z ; std::filesystem::_Find_root_name_end
	cmp	r10, rax
	setne	al

; 1180 :         }

	add	rsp, 40					; 00000028H
	ret	0
?is_absolute@path@filesystem@std@@QEBA_NXZ ENDP		; std::filesystem::path::is_absolute
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??0?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QEAA@QEB_W_K@Z
_TEXT	SEGMENT
this$ = 8
_Cts$ = 16
_Count$ = 24
??0?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QEAA@QEB_W_K@Z PROC ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::basic_string_view<wchar_t,std::char_traits<wchar_t> >, COMDAT

; 1209 :         : _Mydata(_Cts), _Mysize(_Count) {

	mov	QWORD PTR [rcx], rdx

; 1210 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1211 :         _STL_VERIFY(_Count == 0 || _Cts, "non-zero size null string_view");
; 1212 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1213 :     }

	mov	rax, rcx
	mov	QWORD PTR [rcx+8], r8
	ret	0
??0?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QEAA@QEB_W_K@Z ENDP ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::basic_string_view<wchar_t,std::char_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ??4path@filesystem@std@@QEAAAEAV012@AEBV012@@Z
_TEXT	SEGMENT
this$ = 80
__that$ = 88
??4path@filesystem@std@@QEAAAEAV012@AEBV012@@Z PROC	; std::filesystem::path::operator=, COMDAT

; 639  :         path& operator=(const path&)     = default;

$LN113:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H
	mov	rsi, rdx
	mov	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3156 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	$LN37@operator

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 8

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r14, QWORD PTR [rdx+16]

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN7@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rsi, QWORD PTR [rdx]
$LN7@operator:

; 3376 :         if (_Count <= _Mypair._Myval2._Myres) {

	mov	rbp, QWORD PTR [rcx+24]
	cmp	r14, rbp
	ja	SHORT $LN12@operator

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	r15, rdi

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	rbp, 8

; 2227 :         if (_Large_string_engaged()) {

	jb	SHORT $LN15@operator

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r15, QWORD PTR [rcx]
$LN15@operator:

; 3379 :             _Mypair._Myval2._Mysize = _Count;

	mov	QWORD PTR [rcx+16], r14
	lea	rbx, QWORD PTR [r14+r14]

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rbx
	mov	rdx, rsi
	mov	rcx, r15
	call	memmove

; 3381 :             _Traits::assign(_Old_ptr[_Count], _Elem());

	xor	eax, eax
	mov	WORD PTR [rbx+r15], ax

; 3382 :             return *this;

	jmp	$LN37@operator
$LN12@operator:

; 4734 :         if (_New_size > max_size()) {

	mov	rbx, 9223372036854775806		; 7ffffffffffffffeH
	cmp	r14, rbx
	ja	$LN111@operator

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rcx, r14
	or	rcx, 7
	cmp	rcx, rbx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN41@operator

; 4716 :             return _Max;
; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	rdx, rbp
	mov	rax, rbx
	shr	rdx, 1
	sub	rax, rdx
	cmp	rbp, rax
	ja	SHORT $LN41@operator

; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	rax, QWORD PTR [rdx+rbp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	mov	rbx, rcx
	cmp	rcx, rax
	cmovb	rbx, rax
$LN41@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4741 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	rdx, QWORD PTR [rbx+1]
	call	?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z ; std::allocator<wchar_t>::allocate

; 4747 :         _Mypair._Myval2._Myres  = _New_capacity;

	mov	QWORD PTR [rdi+24], rbx

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rsi
	lea	rbx, QWORD PTR [r14+r14]

; 4746 :         _Mypair._Myval2._Mysize = _New_size;

	mov	QWORD PTR [rdi+16], r14

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rbx
	mov	rcx, rax

; 4741 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	r15, rax

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy

; 3389 :                 _Traits::assign(_New_ptr[_Count], _Elem());

	xor	eax, eax
	mov	WORD PTR [rbx+r15], ax

; 4749 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	rbp, 8
	jb	SHORT $LN36@operator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]
	lea	rdx, QWORD PTR [rbp*2+2]

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN71@operator

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN68@operator

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN71@operator:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN36@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 639  :         path& operator=(const path&)     = default;

	mov	QWORD PTR [rdi], r15
$LN37@operator:
	mov	rbx, QWORD PTR [rsp+96]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN68@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN111@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4735 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN109@operator:
??4path@filesystem@std@@QEAAAEAV012@AEBV012@@Z ENDP	; std::filesystem::path::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$reverse_iterator@PEB_W@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$reverse_iterator@PEB_W@std@@QEAAX_K@Z PROC ; std::reverse_iterator<wchar_t const *>::__autoclassinit2, COMDAT
	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	ret	0
?__autoclassinit2@?$reverse_iterator@PEB_W@std@@QEAAX_K@Z ENDP ; std::reverse_iterator<wchar_t const *>::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ??1path@filesystem@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1path@filesystem@std@@QEAA@XZ PROC			; std::filesystem::path::~path, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	jmp	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
??1path@filesystem@std@@QEAA@XZ ENDP			; std::filesystem::path::~path
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QEAAX_K@Z PROC ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rcx], xmm0
	ret	0
?__autoclassinit2@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QEAAX_K@Z ENDP ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ??0path@filesystem@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0path@filesystem@std@@QEAA@XZ PROC			; std::filesystem::path::path, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4821 :         _My_data._Mysize = 0;

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 7

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	WORD PTR [rcx], ax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 635  :         path()                           = default;

	mov	rax, rcx
	ret	0
??0path@filesystem@std@@QEAA@XZ ENDP			; std::filesystem::path::path
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ??0path@filesystem@std@@QEAA@AEBV012@@Z
_TEXT	SEGMENT
this$GSCopy$ = 32
this$ = 80
__that$ = 88
??0path@filesystem@std@@QEAA@AEBV012@@Z PROC		; std::filesystem::path::path, COMDAT

; 636  :         path(const path&)                = default;

$LN70:
	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 48					; 00000030H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 636  :         path(const path&)                = default;

	mov	QWORD PTR this$GSCopy$[rsp], rcx
	xorps	xmm0, xmm0
	mov	r14, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 636  :         path(const path&)                = default;

	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], rax

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 8

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rsi, QWORD PTR [rdx+16]

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN15@path

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r14, QWORD PTR [rdx]
$LN15@path:

; 2620 :         if (_Count > max_size()) {

	mov	rdi, 9223372036854775806		; 7ffffffffffffffeH
	cmp	rsi, rdi
	ja	SHORT $LN68@path

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR [rcx+24], 7
	cmp	rsi, 8
	jae	SHORT $LN21@path

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR [rcx+16], rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 636  :         path(const path&)                = default;

	mov	rax, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR [rcx], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 636  :         path(const path&)                = default;

	mov	rbx, QWORD PTR [rsp+96]
	add	rsp, 48					; 00000030H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN21@path:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rax, rsi
	or	rax, 7
	cmp	rax, rdi

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN31@path
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	mov	ecx, 10
	mov	rdi, rax
	cmp	rax, rcx
	cmovb	rdi, rcx
$LN31@path:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	rdx, QWORD PTR [rdi+1]
	call	?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z ; std::allocator<wchar_t>::allocate

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	lea	r8, QWORD PTR [rsi*2+2]

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR [rbx], rax

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14

; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR [rbx+16], rsi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rcx, rax

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR [rbx+24], rdi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 636  :         path(const path&)                = default;

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+96]
	add	rsp, 48					; 00000030H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN68@path:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN66@path:
??0path@filesystem@std@@QEAA@AEBV012@@Z ENDP		; std::filesystem::path::path
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vcruntime_exception.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ??0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Message$ = 72
_Errcode$ = 80
??0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@@Z PROC ; std::filesystem::filesystem_error::filesystem_error, COMDAT

; 1751 :         filesystem_error(const string& _Message, const error_code _Errcode)

$LN61:
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error

; 491  :     system_error(error_code _Errcode, const string& _Message) : _Mybase(_Errcode, _Message) {}

	movaps	xmm0, XMMWORD PTR [r8]
	movdqa	XMMWORD PTR $T1[rsp], xmm0
	mov	r8, rdx
	lea	rdx, QWORD PTR $T1[rsp]
	call	??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 1752 :             : system_error(_Errcode, _Message), _What(runtime_error::what()) {}

	lea	rax, OFFSET FLAT:??_7filesystem_error@filesystem@std@@6B@
	mov	QWORD PTR [rbx], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rbx+40], xmm0

; 4821 :         _My_data._Mysize = 0;

	xor	r8d, r8d
	mov	QWORD PTR [rbx+56], r8

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+64], 7

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	WORD PTR [rbx+40], r8w

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rbx+72], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+88], r8

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+96], 7

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	WORD PTR [rbx+72], r8w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 1752 :             : system_error(_Errcode, _Message), _What(runtime_error::what()) {}

	lea	rcx, QWORD PTR [rbx+104]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vcruntime_exception.h

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

	mov	rax, QWORD PTR [rbx+8]
	lea	rdx, OFFSET FLAT:??_C@_0BC@EOODALEL@Unknown?5exception@
	test	rax, rax
	cmovne	rdx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], r8

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], r8

; 400  :             return __builtin_strlen(_First);

	mov	r8, -1
	npad	9
$LL58@filesystem:
	inc	r8
	cmp	BYTE PTR [rdx+r8], 0
	jne	SHORT $LL58@filesystem

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 1752 :             : system_error(_Errcode, _Message), _What(runtime_error::what()) {}

	mov	rax, rbx
	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
??0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@@Z ENDP ; std::filesystem::filesystem_error::filesystem_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Message$ = 72
_Errcode$ = 80
?dtor$0@?0???0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@@Z@4HA PROC ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1system_error@std@@UEAA@XZ
?dtor$0@?0???0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@@Z@4HA ENDP ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Message$ = 72
_Errcode$ = 80
?dtor$1@?0???0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@@Z@4HA PROC ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$1
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 40					; 00000028H
	jmp	??1path@filesystem@std@@QEAA@XZ		; std::filesystem::path::~path
?dtor$1@?0???0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@@Z@4HA ENDP ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Message$ = 72
_Errcode$ = 80
?dtor$2@?0???0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@@Z@4HA PROC ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$2
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 72					; 00000048H
	jmp	??1path@filesystem@std@@QEAA@XZ		; std::filesystem::path::~path
?dtor$2@?0???0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@@Z@4HA ENDP ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vcruntime_exception.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ??0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 48
this$ = 96
_Message$ = 104
_Path1_arg$ = 112
_Errcode$ = 120
??0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z PROC ; std::filesystem::filesystem_error::filesystem_error, COMDAT

; 1756 :               _What(_Pretty_message(runtime_error::what(), _Path1_arg)) {}

$LN60:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rdi, r8
	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error

; 491  :     system_error(error_code _Errcode, const string& _Message) : _Mybase(_Errcode, _Message) {}

	movaps	xmm0, XMMWORD PTR [r9]
	movdqa	XMMWORD PTR $T1[rsp], xmm0
	mov	r8, rdx
	lea	rdx, QWORD PTR $T1[rsp]
	call	??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 1756 :               _What(_Pretty_message(runtime_error::what(), _Path1_arg)) {}

	lea	rax, OFFSET FLAT:??_7filesystem_error@filesystem@std@@6B@
	mov	QWORD PTR [rbx], rax

; 1755 :             : system_error(_Errcode, _Message), _Path1(_Path1_arg), _Path2(),

	lea	rcx, QWORD PTR [rbx+40]
	mov	rdx, rdi
	call	??0path@filesystem@std@@QEAA@AEBV012@@Z	; std::filesystem::path::path
	npad	1
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rbx+88], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rbx+72], xmm0

; 4821 :         _My_data._Mysize = 0;

	xor	eax, eax
	mov	QWORD PTR [rbx+88], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+96], 7

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	WORD PTR [rbx+72], ax

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T4[rsp], xmm0

; 4821 :         _My_data._Mysize = 0;

	movdqa	xmm1, XMMWORD PTR __xmm@00000000000000070000000000000000
	movdqu	XMMWORD PTR $T4[rsp+16], xmm1

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	WORD PTR $T4[rsp], ax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vcruntime_exception.h

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

	mov	rax, QWORD PTR [rbx+8]
	lea	rcx, OFFSET FLAT:??_C@_0BC@EOODALEL@Unknown?5exception@
	test	rax, rax
	cmovne	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 1201 :         : _Mydata(_Ntcts), _Mysize(_Traits::length(_Ntcts)) {}

	mov	QWORD PTR $T3[rsp], rcx

; 400  :             return __builtin_strlen(_First);

	mov	rax, -1
$LL57@filesystem:
	inc	rax
	cmp	BYTE PTR [rcx+rax], 0
	jne	SHORT $LL57@filesystem
	mov	QWORD PTR $T3[rsp+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 1756 :               _What(_Pretty_message(runtime_error::what(), _Path1_arg)) {}

	movaps	xmm0, XMMWORD PTR $T3[rsp]
	movdqa	XMMWORD PTR $T2[rsp], xmm0
	lea	rcx, QWORD PTR [rbx+104]
	lea	r9, QWORD PTR $T4[rsp]
	mov	r8, rdi
	lea	rdx, QWORD PTR $T2[rsp]
	call	?_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z ; std::filesystem::filesystem_error::_Pretty_message
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T4[rsp]
	call	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 1756 :               _What(_Pretty_message(runtime_error::what(), _Path1_arg)) {}

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+104]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
??0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z ENDP ; std::filesystem::filesystem_error::filesystem_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 48
this$ = 96
_Message$ = 104
_Path1_arg$ = 112
_Errcode$ = 120
?dtor$0@?0???0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z@4HA PROC ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1system_error@std@@UEAA@XZ
?dtor$0@?0???0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z@4HA ENDP ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 48
this$ = 96
_Message$ = 104
_Path1_arg$ = 112
_Errcode$ = 120
?dtor$1@?0???0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z@4HA PROC ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$1
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 40					; 00000028H
	jmp	??1path@filesystem@std@@QEAA@XZ		; std::filesystem::path::~path
?dtor$1@?0???0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z@4HA ENDP ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 48
this$ = 96
_Message$ = 104
_Path1_arg$ = 112
_Errcode$ = 120
?dtor$2@?0???0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z@4HA PROC ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$2
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 72					; 00000048H
	jmp	??1path@filesystem@std@@QEAA@XZ		; std::filesystem::path::~path
?dtor$2@?0???0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z@4HA ENDP ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 48
this$ = 96
_Message$ = 104
_Path1_arg$ = 112
_Errcode$ = 120
?dtor$3@?0???0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z@4HA PROC ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$3
	lea	rcx, QWORD PTR $T4[rdx]
	jmp	??1path@filesystem@std@@QEAA@XZ		; std::filesystem::path::~path
?dtor$3@?0???0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z@4HA ENDP ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ?what@filesystem_error@filesystem@std@@UEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?what@filesystem_error@filesystem@std@@UEBAPEBDXZ PROC	; std::filesystem::filesystem_error::what, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4107 :         return _Mypair._Myval2._Myptr();

	lea	rax, QWORD PTR [rcx+104]

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rax+24], 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN10@what
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 1772 :             return _What.c_str();

	mov	rax, QWORD PTR [rax]
$LN10@what:

; 1773 :         }

	ret	0
?what@filesystem_error@filesystem@std@@UEBAPEBDXZ ENDP	; std::filesystem::filesystem_error::what
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ?_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 48
__$ReturnUdt$GSCopy$ = 56
_Path2_str$ = 64
_Path1_str$ = 96
__$ArrayPad$ = 128
__$ReturnUdt$ = 192
_Op$ = 200
_Path1$ = 208
_Path2$ = 216
?_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z PROC ; std::filesystem::filesystem_error::_Pretty_message, COMDAT

; 1776 :         static string _Pretty_message(const string_view _Op, const path& _Path1, const path& _Path2 = {}) {

$LN302:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rbp
	push	rdi
	push	r12
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-55]
	sub	rsp, 144				; 00000090H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-89], rax
	mov	rbx, r9
	mov	rsi, r8
	mov	r15, rdx
	mov	rdi, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rbp-89], rcx
	xor	r12d, r12d
	mov	DWORD PTR $T5[rbp-89], r12d
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], r12

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], r12b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 1793 :             return _Result;

	mov	DWORD PTR $T5[rbp-89], 1

; 1777 :             string _Result;
; 1778 :             // Convert the paths to narrow encoding in a way that gracefully handles non-encodable characters
; 1779 :             const auto _Code_page   = __std_fs_code_page();

	call	__std_fs_code_page
	mov	r14d, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rsi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rsi+24], 8
	jb	SHORT $LN24@Pretty_mes

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rsi]
$LN24@Pretty_mes:

; 4041 :         return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize};

	mov	rax, QWORD PTR [rsi+16]

; 1209 :         : _Mydata(_Cts), _Mysize(_Count) {

	mov	QWORD PTR $T4[rbp-89], rcx
	mov	QWORD PTR $T4[rbp-81], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 1780 :             const string _Path1_str = _Convert_wide_to_narrow_replace_chars<char_traits<char>>(

	movaps	xmm0, XMMWORD PTR $T4[rbp-89]
	movdqa	XMMWORD PTR $T2[rbp-89], xmm0
	lea	r8, QWORD PTR $T2[rbp-89]
	mov	edx, r14d
	lea	rcx, QWORD PTR _Path1_str$[rbp-89]
	call	??$_Convert_wide_to_narrow_replace_chars@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z ; std::filesystem::_Convert_wide_to_narrow_replace_chars<std::char_traits<char>,std::allocator<char> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rbx

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rbx+24], 8
	jb	SHORT $LN102@Pretty_mes

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rbx]
$LN102@Pretty_mes:

; 4041 :         return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize};

	mov	rax, QWORD PTR [rbx+16]

; 1209 :         : _Mydata(_Cts), _Mysize(_Count) {

	mov	QWORD PTR $T3[rbp-89], rcx
	mov	QWORD PTR $T3[rbp-81], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 1782 :             const string _Path2_str = _Convert_wide_to_narrow_replace_chars<char_traits<char>>(

	movaps	xmm0, XMMWORD PTR $T3[rbp-89]
	movdqa	XMMWORD PTR $T1[rbp-89], xmm0
	lea	r8, QWORD PTR $T1[rbp-89]
	mov	edx, r14d
	lea	rcx, QWORD PTR _Path2_str$[rbp-89]
	call	??$_Convert_wide_to_narrow_replace_chars@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z ; std::filesystem::_Convert_wide_to_narrow_replace_chars<std::char_traits<char>,std::allocator<char> >
	npad	1

; 1783 :                 _Code_page, _Path2.native(), allocator<char>{});
; 1784 :             _Result.reserve(_Op.size() + (_Path2_str.empty() ? 4 : 8) + _Path1_str.size() + _Path2_str.size());

	mov	edx, 8
	mov	esi, 4
	mov	rax, QWORD PTR _Path2_str$[rbp-73]
	test	rax, rax
	cmove	edx, esi
	add	rdx, QWORD PTR [r15+8]
	add	rdx, QWORD PTR _Path1_str$[rbp-73]
	add	rdx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4178 :         if (_Mypair._Myval2._Myres >= _Newcap) { // requested capacity is not larger than current capacity, ignore

	cmp	QWORD PTR [rdi+24], rdx
	jae	SHORT $LN298@Pretty_mes

; 4179 :             return; // nothing to do
; 4180 :         }
; 4181 : 
; 4182 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rbx, QWORD PTR [rdi+16]

; 4183 :         _Reallocate_grow_by(

	sub	rdx, rbx
	mov	rcx, rdi
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??reserve@01@QEAAX0@Z@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve'::`2'::<lambda_1> >

; 4184 :             _Newcap - _Old_size, [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size) {
; 4185 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);
; 4186 :             });
; 4187 : 
; 4188 :         _Mypair._Myval2._Mysize = _Old_size;

	mov	QWORD PTR [rdi+16], rbx
$LN298@Pretty_mes:

; 3255 :         return append(_As_view.data(), _Convert_size<size_type>(_As_view.size()));

	mov	r8, QWORD PTR [r15+8]
	mov	rdx, QWORD PTR [r15]
	mov	rcx, rdi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	mov	r8d, 3
	lea	rdx, OFFSET FLAT:??_C@_03NONCDIOG@?3?5?$CC@
	mov	rcx, rdi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR _Path1_str$[rbp-89]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR _Path1_str$[rbp-65], 16
	cmovae	rdx, QWORD PTR _Path1_str$[rbp-89]

; 3241 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR _Path1_str$[rbp-73]
	mov	rcx, rdi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 1788 :             if (!_Path2_str.empty()) {

	cmp	QWORD PTR _Path2_str$[rbp-73], 0
	je	SHORT $LN2@Pretty_mes
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3255 :         return append(_As_view.data(), _Convert_size<size_type>(_As_view.size()));

	mov	r8, rsi
	lea	rdx, OFFSET FLAT:??_C@_04PHMHGEMA@?$CC?0?5?$CC@
	mov	rcx, rdi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR _Path2_str$[rbp-89]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR _Path2_str$[rbp-65], 16
	cmovae	rdx, QWORD PTR _Path2_str$[rbp-89]

; 3241 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR _Path2_str$[rbp-73]
	mov	rcx, rdi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN2@Pretty_mes:

; 4046 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR [rdi+16]

; 4047 :         if (_Old_size < _Mypair._Myval2._Myres) {

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rcx, rdx
	jae	SHORT $LN212@Pretty_mes

; 4048 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 4049 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rdi+16], rax

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	rax, rdi

; 2227 :         if (_Large_string_engaged()) {

	cmp	rdx, 16
	jb	SHORT $LN215@Pretty_mes

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rdi]
$LN215@Pretty_mes:

; 4051 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	WORD PTR [rcx+rax], 34			; 00000022H

; 4052 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());
; 4053 :             return;

	jmp	SHORT $LN211@Pretty_mes
$LN212@Pretty_mes:

; 4054 :         }
; 4055 : 
; 4056 :         _Reallocate_grow_by(

	mov	r9b, 34					; 00000022H
	mov	rcx, rdi
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
	npad	1
$LN211@Pretty_mes:

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR _Path2_str$[rbp-65]
	cmp	rdx, 16
	jb	SHORT $LN231@Pretty_mes

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR _Path2_str$[rbp-89]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN243@Pretty_mes

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN243@Pretty_mes
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN243@Pretty_mes:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN231@Pretty_mes:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	mov	QWORD PTR _Path2_str$[rbp-73], r12

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR _Path2_str$[rbp-65], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR _Path2_str$[rbp-89], 0

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR _Path1_str$[rbp-65]
	cmp	rdx, 16

; 4832 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN261@Pretty_mes

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR _Path1_str$[rbp-89]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN273@Pretty_mes

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN273@Pretty_mes
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN273@Pretty_mes:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN261@Pretty_mes:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 1793 :             return _Result;

	mov	rax, rdi

; 1794 :         }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-89]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+144]
	mov	rbx, QWORD PTR [r11+64]
	mov	rsi, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rbp
	ret	0
	int	3
$LN299@Pretty_mes:
?_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z ENDP ; std::filesystem::filesystem_error::_Pretty_message
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 48
__$ReturnUdt$GSCopy$ = 56
_Path2_str$ = 64
_Path1_str$ = 96
__$ArrayPad$ = 128
__$ReturnUdt$ = 192
_Op$ = 200
_Path1$ = 208
_Path2$ = 216
?dtor$0@?0??_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z@4HA PROC ; `std::filesystem::filesystem_error::_Pretty_message'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T5[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN5@dtor$0
	and	DWORD PTR $T5[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$GSCopy$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN5@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z@4HA ENDP ; `std::filesystem::filesystem_error::_Pretty_message'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 48
__$ReturnUdt$GSCopy$ = 56
_Path2_str$ = 64
_Path1_str$ = 96
__$ArrayPad$ = 128
__$ReturnUdt$ = 192
_Op$ = 200
_Path1$ = 208
_Path2$ = 216
?dtor$1@?0??_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z@4HA PROC ; `std::filesystem::filesystem_error::_Pretty_message'::`1'::dtor$1
	lea	rcx, QWORD PTR _Path1_str$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z@4HA ENDP ; `std::filesystem::filesystem_error::_Pretty_message'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 48
__$ReturnUdt$GSCopy$ = 56
_Path2_str$ = 64
_Path1_str$ = 96
__$ArrayPad$ = 128
__$ReturnUdt$ = 192
_Op$ = 200
_Path1$ = 208
_Path2$ = 216
?dtor$2@?0??_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z@4HA PROC ; `std::filesystem::filesystem_error::_Pretty_message'::`1'::dtor$2
	lea	rcx, QWORD PTR _Path2_str$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0??_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z@4HA ENDP ; `std::filesystem::filesystem_error::_Pretty_message'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vcruntime_exception.h
;	COMDAT ??_Gfilesystem_error@filesystem@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gfilesystem_error@filesystem@std@@UEAAPEAXI@Z PROC	; std::filesystem::filesystem_error::`scalar deleting destructor', COMDAT
$LN37:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx
	mov	ebx, edx
	add	rcx, 104				; 00000068H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 638  :         ~path()                          = default;

	lea	rcx, QWORD PTR [rdi+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	call	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 638  :         ~path()                          = default;

	lea	rcx, QWORD PTR [rdi+40]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	call	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vcruntime_exception.h

; 89   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

	lea	rcx, QWORD PTR [rdi+8]
	mov	QWORD PTR [rdi], rax
	call	QWORD PTR __imp___std_exception_destroy
	test	bl, 1
	je	SHORT $LN33@scalar
	mov	edx, 136				; 00000088H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN33@scalar:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_Gfilesystem_error@filesystem@std@@UEAAPEAXI@Z ENDP	; std::filesystem::filesystem_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vcruntime_exception.h
;	COMDAT ??1filesystem_error@filesystem@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1filesystem_error@filesystem@std@@UEAA@XZ PROC	; std::filesystem::filesystem_error::~filesystem_error, COMDAT
$LN31:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	add	rcx, 104				; 00000068H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 638  :         ~path()                          = default;

	lea	rcx, QWORD PTR [rbx+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	call	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 638  :         ~path()                          = default;

	lea	rcx, QWORD PTR [rbx+40]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	call	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vcruntime_exception.h

; 89   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

	lea	rcx, QWORD PTR [rbx+8]
	mov	QWORD PTR [rbx], rax
	add	rsp, 32					; 00000020H
	pop	rbx
	rex_jmp	QWORD PTR __imp___std_exception_destroy
??1filesystem_error@filesystem@std@@UEAA@XZ ENDP	; std::filesystem::filesystem_error::~filesystem_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 48
$T4 = 64
$T5 = 96
_Op$ = 256
_Error$ = 264
?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@@Z PROC ; std::filesystem::_Throw_fs_error, COMDAT

; 1808 :     [[noreturn]] inline void _Throw_fs_error(const char* _Op, __std_win_error _Error) {

$LN13:
	sub	rsp, 248				; 000000f8H
	mov	r8, rcx

; 1809 :         _THROW(filesystem_error(_Op, _Make_ec(_Error)));

	lea	rcx, QWORD PTR $T3[rsp]
	call	?_Make_ec@std@@YA?AVerror_code@1@W4__std_win_error@@@Z ; std::_Make_ec
	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T1[rsp], xmm0
	mov	rdx, r8
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	movups	xmm0, XMMWORD PTR $T1[rsp]
	movaps	XMMWORD PTR $T2[rsp], xmm0
	lea	r8, QWORD PTR $T2[rsp]
	lea	rdx, QWORD PTR $T4[rsp]
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@@Z ; std::filesystem::filesystem_error::filesystem_error
	lea	rdx, OFFSET FLAT:_TI5?AVfilesystem_error@filesystem@std@@
	lea	rcx, QWORD PTR $T5[rsp]
	call	_CxxThrowException
	int	3
$LN12@Throw_fs_e:
?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@@Z ENDP ; std::filesystem::_Throw_fs_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 48
$T4 = 64
$T5 = 96
_Op$ = 256
_Error$ = 264
?dtor$0@?0??_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@@Z@4HA PROC ; `std::filesystem::_Throw_fs_error'::`1'::dtor$0
	lea	rcx, QWORD PTR $T4[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@@Z@4HA ENDP ; `std::filesystem::_Throw_fs_error'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vcruntime_exception.h
;	COMDAT ??0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z PROC ; std::filesystem::filesystem_error::filesystem_error, COMDAT
$LN20:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx

; 72   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax

; 71   :         : _Data()

	lea	rdx, QWORD PTR [rcx+8]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rdx], xmm0

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

	lea	rcx, QWORD PTR [rbx+8]
	call	QWORD PTR __imp___std_exception_copy
	lea	rax, OFFSET FLAT:??_7_System_error@std@@6B@
	mov	QWORD PTR [rdi], rax
	movups	xmm0, XMMWORD PTR [rbx+24]
	movups	XMMWORD PTR [rdi+24], xmm0
	lea	rax, OFFSET FLAT:??_7filesystem_error@filesystem@std@@6B@
	mov	QWORD PTR [rdi], rax
	lea	rcx, QWORD PTR [rdi+40]
	lea	rdx, QWORD PTR [rbx+40]
	call	??0path@filesystem@std@@QEAA@AEBV012@@Z	; std::filesystem::path::path
	npad	1
	lea	rcx, QWORD PTR [rdi+72]
	lea	rdx, QWORD PTR [rbx+72]
	call	??0path@filesystem@std@@QEAA@AEBV012@@Z	; std::filesystem::path::path
	npad	1
	lea	rcx, QWORD PTR [rdi+104]
	lea	rdx, QWORD PTR [rbx+104]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z ENDP ; std::filesystem::filesystem_error::filesystem_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$0@?0???0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z@4HA PROC ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1system_error@std@@UEAA@XZ
?dtor$0@?0???0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z@4HA ENDP ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$1@?0???0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z@4HA PROC ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$1
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 40					; 00000028H
	jmp	??1path@filesystem@std@@QEAA@XZ		; std::filesystem::path::~path
?dtor$1@?0???0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z@4HA ENDP ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$2@?0???0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z@4HA PROC ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$2
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 72					; 00000048H
	jmp	??1path@filesystem@std@@QEAA@XZ		; std::filesystem::path::~path
?dtor$2@?0???0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z@4HA ENDP ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@AEBVpath@12@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 48
$T4 = 64
$T5 = 96
_Op$ = 256
_Error$ = 264
_Path1$ = 272
?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@AEBVpath@12@@Z PROC ; std::filesystem::_Throw_fs_error, COMDAT

; 1812 :     [[noreturn]] inline void _Throw_fs_error(const char* _Op, __std_win_error _Error, const path& _Path1) {

$LN13:
	push	rbx
	sub	rsp, 240				; 000000f0H
	mov	rbx, r8
	mov	r9, rcx

; 1813 :         _THROW(filesystem_error(_Op, _Path1, _Make_ec(_Error)));

	lea	rcx, QWORD PTR $T3[rsp]
	call	?_Make_ec@std@@YA?AVerror_code@1@W4__std_win_error@@@Z ; std::_Make_ec
	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T1[rsp], xmm0
	mov	rdx, r9
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	movups	xmm0, XMMWORD PTR $T1[rsp]
	movaps	XMMWORD PTR $T2[rsp], xmm0
	lea	r9, QWORD PTR $T2[rsp]
	mov	r8, rbx
	lea	rdx, QWORD PTR $T4[rsp]
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z ; std::filesystem::filesystem_error::filesystem_error
	lea	rdx, OFFSET FLAT:_TI5?AVfilesystem_error@filesystem@std@@
	lea	rcx, QWORD PTR $T5[rsp]
	call	_CxxThrowException
	int	3
$LN12@Throw_fs_e:
?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@AEBVpath@12@@Z ENDP ; std::filesystem::_Throw_fs_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 48
$T4 = 64
$T5 = 96
_Op$ = 256
_Error$ = 264
_Path1$ = 272
?dtor$0@?0??_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@AEBVpath@12@@Z@4HA PROC ; `std::filesystem::_Throw_fs_error'::`1'::dtor$0
	lea	rcx, QWORD PTR $T4[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@AEBVpath@12@@Z@4HA ENDP ; `std::filesystem::_Throw_fs_error'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ?type@file_status@filesystem@std@@QEAAXW4file_type@23@@Z
_TEXT	SEGMENT
this$ = 8
_Ft$ = 16
?type@file_status@filesystem@std@@QEAAXW4file_type@23@@Z PROC ; std::filesystem::file_status::type, COMDAT

; 1919 :             _Myftype = _Ft;

	mov	DWORD PTR [rcx], edx

; 1920 :         }

	ret	0
?type@file_status@filesystem@std@@QEAAXW4file_type@23@@Z ENDP ; std::filesystem::file_status::type
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ?permissions@file_status@filesystem@std@@QEAAXW4perms@23@@Z
_TEXT	SEGMENT
this$ = 8
_Perms$ = 16
?permissions@file_status@filesystem@std@@QEAAXW4perms@23@@Z PROC ; std::filesystem::file_status::permissions, COMDAT

; 1923 :             _Myperms = _Perms;

	mov	DWORD PTR [rcx+4], edx

; 1924 :         }

	ret	0
?permissions@file_status@filesystem@std@@QEAAXW4perms@23@@Z ENDP ; std::filesystem::file_status::permissions
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ?type@file_status@filesystem@std@@QEBA?AW4file_type@23@XZ
_TEXT	SEGMENT
this$ = 8
?type@file_status@filesystem@std@@QEBA?AW4file_type@23@XZ PROC ; std::filesystem::file_status::type, COMDAT

; 1928 :             return _Myftype;

	mov	eax, DWORD PTR [rcx]

; 1929 :         }

	ret	0
?type@file_status@filesystem@std@@QEBA?AW4file_type@23@XZ ENDP ; std::filesystem::file_status::type
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ?_Refresh@file_status@filesystem@std@@QEAAXW4__std_win_error@@AEBU__std_fs_stats@@@Z
_TEXT	SEGMENT
this$ = 8
_Error$ = 16
_Stats$ = 24
?_Refresh@file_status@filesystem@std@@QEAAXW4__std_win_error@@AEBU__std_fs_stats@@@Z PROC ; std::filesystem::file_status::_Refresh, COMDAT

; 1942 :             if (_Error == __std_win_error::_Success) {

	test	edx, edx
	jne	SHORT $LN2@Refresh

; 1943 :                 const auto _Attrs = _Stats._Attributes;

	mov	edx, DWORD PTR [r8+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 82   : _BITMASK_OPS(_EMPTY_ARGUMENT, __std_fs_file_attr)

	mov	eax, 365				; 0000016dH
	test	dl, 1
	mov	r9d, 511				; 000001ffH
	cmove	eax, r9d
	mov	DWORD PTR [rcx+4], eax
	mov	eax, edx
	shr	eax, 10
	test	al, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 1951 :                 if (_Bitmask_includes_any(_Attrs, __std_fs_file_attr::_Reparse_point)) {

	je	SHORT $LN7@Refresh

; 1952 :                     if (_Stats._Reparse_point_tag == __std_fs_reparse_tag::_Symlink) {

	mov	eax, DWORD PTR [r8+20]
	cmp	eax, -1610612724			; a000000cH
	jne	SHORT $LN6@Refresh

; 1976 :         }

	mov	DWORD PTR [rcx], 4
	ret	0
$LN6@Refresh:

; 1953 :                         this->type(file_type::symlink);
; 1954 :                         return;
; 1955 :                     }
; 1956 : 
; 1957 :                     if (_Stats._Reparse_point_tag == __std_fs_reparse_tag::_Mount_point) {

	cmp	eax, -1610612733			; a0000003H
	jne	SHORT $LN7@Refresh

; 1976 :         }

	mov	DWORD PTR [rcx], 10
	ret	0
$LN7@Refresh:

; 1958 :                         this->type(file_type::junction);
; 1959 :                         return;
; 1960 :                     }
; 1961 : 
; 1962 :                     // All other reparse points considered ordinary files or directories
; 1963 :                 }
; 1964 : 
; 1965 :                 if (_Bitmask_includes_any(_Attrs, __std_fs_file_attr::_Directory)) {
; 1966 :                     this->type(file_type::directory);
; 1967 :                 } else {
; 1968 :                     this->type(file_type::regular);
; 1969 :                 }
; 1970 : 
; 1971 :                 return;

	shr	edx, 4
	and	edx, 1
	add	edx, 2

; 1976 :         }

	mov	DWORD PTR [rcx], edx
	ret	0
$LN2@Refresh:

; 1972 :             }
; 1973 : 
; 1974 :             this->permissions(perms::unknown);

	mov	DWORD PTR [rcx+4], 65535		; 0000ffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 52   :     switch (_Error) {

	sub	edx, 2
	je	SHORT $LN26@Refresh
	sub	edx, 1
	je	SHORT $LN26@Refresh
	sub	edx, 50					; 00000032H
	je	SHORT $LN26@Refresh
	cmp	edx, 70					; 00000046H
	je	SHORT $LN26@Refresh

; 58   :     default:
; 59   :         return false;

	xor	eax, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 1976 :         }

	mov	DWORD PTR [rcx], eax
	ret	0
$LN26@Refresh:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 57   :         return true;

	mov	eax, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 1976 :         }

	mov	DWORD PTR [rcx], eax
	ret	0
?_Refresh@file_status@filesystem@std@@QEAAXW4__std_win_error@@AEBU__std_fs_stats@@@Z ENDP ; std::filesystem::file_status::_Refresh
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ?is_regular_file@filesystem@std@@YA_NVfile_status@12@@Z
_TEXT	SEGMENT
_Status$ = 8
?is_regular_file@filesystem@std@@YA_NVfile_status@12@@Z PROC ; std::filesystem::is_regular_file, COMDAT

; 2044 :         // tests whether _Status indicates a regular file
; 2045 :         return _Status.type() == file_type::regular;

	cmp	ecx, 2
	sete	al

; 2046 :     }

	ret	0
?is_regular_file@filesystem@std@@YA_NVfile_status@12@@Z ENDP ; std::filesystem::is_regular_file
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ?_Not_good@_File_status_and_error@filesystem@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?_Not_good@_File_status_and_error@filesystem@std@@QEBA_NXZ PROC ; std::filesystem::_File_status_and_error::_Not_good, COMDAT

; 2063 :             // [fs.op.status]/Throws: result values of file_status(file_type::not_found) and
; 2064 :             // file_status(file_type::unknown) are not considered failures and do not cause an exception to be thrown.
; 2065 :             return _Error != __std_win_error::_Success && _Status.type() != file_type::not_found

	cmp	DWORD PTR [rcx+8], 0
	je	SHORT $LN3@Not_good
	mov	eax, DWORD PTR [rcx]
	dec	eax
	test	eax, -9					; fffffff7H
	je	SHORT $LN3@Not_good
	mov	al, 1

; 2066 :                 && _Status.type() != file_type::unknown;
; 2067 :         }

	ret	0
$LN3@Not_good:

; 2063 :             // [fs.op.status]/Throws: result values of file_status(file_type::not_found) and
; 2064 :             // file_status(file_type::unknown) are not considered failures and do not cause an exception to be thrown.
; 2065 :             return _Error != __std_win_error::_Success && _Status.type() != file_type::not_found

	xor	al, al

; 2066 :                 && _Status.type() != file_type::unknown;
; 2067 :         }

	ret	0
?_Not_good@_File_status_and_error@filesystem@std@@QEBA_NXZ ENDP ; std::filesystem::_File_status_and_error::_Not_good
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ??0directory_entry@filesystem@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0directory_entry@filesystem@std@@QEAA@XZ PROC		; std::filesystem::directory_entry::directory_entry, COMDAT

; 2088 :         directory_entry() noexcept : _Cached_data{}, _Path() {}

	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	movups	XMMWORD PTR [rcx+16], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx+32], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+48], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+56], 7

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	WORD PTR [rcx+32], ax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2088 :         directory_entry() noexcept : _Cached_data{}, _Path() {}

	mov	rax, rcx
	ret	0
??0directory_entry@filesystem@std@@QEAA@XZ ENDP		; std::filesystem::directory_entry::directory_entry
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ?_Has_cached_attribute@directory_entry@filesystem@std@@AEBA_NW4__std_fs_file_attr@@@Z
_TEXT	SEGMENT
this$ = 8
_Attrs$ = 16
?_Has_cached_attribute@directory_entry@filesystem@std@@AEBA_NW4__std_fs_file_attr@@@Z PROC ; std::filesystem::directory_entry::_Has_cached_attribute, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 82   : _BITMASK_OPS(_EMPTY_ARGUMENT, __std_fs_file_attr)

	test	DWORD PTR [rcx+16], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2324 :     return (_Left & _Elements) != _Bitmask{};

	setne	al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2150 :         }

	ret	0
?_Has_cached_attribute@directory_entry@filesystem@std@@AEBA_NW4__std_fs_file_attr@@@Z ENDP ; std::filesystem::directory_entry::_Has_cached_attribute
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ?path@directory_entry@filesystem@std@@QEBAAEBV023@XZ
_TEXT	SEGMENT
this$ = 8
?path@directory_entry@filesystem@std@@QEBAAEBV023@XZ PROC ; std::filesystem::directory_entry::path, COMDAT

; 2155 :             return _Path;

	lea	rax, QWORD PTR [rcx+32]

; 2156 :         }

	ret	0
?path@directory_entry@filesystem@std@@QEBAAEBV023@XZ ENDP ; std::filesystem::directory_entry::path
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ?is_regular_file@directory_entry@filesystem@std@@QEBA_NXZ
_TEXT	SEGMENT
_Result$1 = 32
this$ = 64
?is_regular_file@directory_entry@filesystem@std@@QEBA_NXZ PROC ; std::filesystem::directory_entry::is_regular_file, COMDAT

; 2215 :         _NODISCARD bool is_regular_file() const {

$LN21:
	push	rbx
	sub	rsp, 48					; 00000030H

; 2381 :             const auto _Result = _Get_any_status(_Status_stats_flags);

	mov	r8d, 3
	lea	rdx, QWORD PTR _Result$1[rsp]

; 2215 :         _NODISCARD bool is_regular_file() const {

	mov	rbx, rcx

; 2381 :             const auto _Result = _Get_any_status(_Status_stats_flags);

	call	?_Get_any_status@directory_entry@filesystem@std@@AEBA?AU_File_status_and_error@23@W4__std_fs_stats_flags@@@Z ; std::filesystem::directory_entry::_Get_any_status

; 2065 :             return _Error != __std_win_error::_Success && _Status.type() != file_type::not_found

	mov	edx, DWORD PTR _Result$1[rsp+8]
	mov	rax, QWORD PTR _Result$1[rsp]
	test	edx, edx
	je	SHORT $LN4@is_regular
	lea	r8d, DWORD PTR [rax-1]
	test	r8d, -9					; fffffff7H
	jne	SHORT $LN19@is_regular
$LN4@is_regular:

; 2386 :             return _Result._Status;

	cmp	eax, 2

; 2045 :         return _Status.type() == file_type::regular;

	sete	al

; 2216 :             return _STD filesystem::is_regular_file(this->status());
; 2217 :         }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
$LN19@is_regular:

; 2383 :                 _Throw_fs_error("directory_entry::status", _Result._Error, _Path);

	lea	r8, QWORD PTR [rbx+32]
	lea	rcx, OFFSET FLAT:??_C@_0BI@LBKDNGFK@directory_entry?3?3status@
	call	?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@AEBVpath@12@@Z ; std::filesystem::_Throw_fs_error
	int	3
$LN17@is_regular:
?is_regular_file@directory_entry@filesystem@std@@QEBA_NXZ ENDP ; std::filesystem::directory_entry::is_regular_file
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ?_Is_symlink_or_junction@directory_entry@filesystem@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?_Is_symlink_or_junction@directory_entry@filesystem@std@@QEBA_NXZ PROC ; std::filesystem::directory_entry::_Is_symlink_or_junction, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 82   : _BITMASK_OPS(_EMPTY_ARGUMENT, __std_fs_file_attr)

	mov	eax, DWORD PTR [rcx+16]
	shr	eax, 10
	test	al, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2233 :             return _Has_cached_attribute(__std_fs_file_attr::_Reparse_point)

	je	SHORT $LN4@Is_symlink
	mov	eax, DWORD PTR [rcx+20]
	cmp	eax, -1610612724			; a000000cH
	je	SHORT $LN3@Is_symlink
	cmp	eax, -1610612733			; a0000003H
	jne	SHORT $LN4@Is_symlink
$LN3@Is_symlink:
	mov	al, 1

; 2234 :                 && (_Cached_data._Reparse_point_tag == __std_fs_reparse_tag::_Symlink
; 2235 :                     || _Cached_data._Reparse_point_tag == __std_fs_reparse_tag::_Mount_point);
; 2236 :         }

	ret	0
$LN4@Is_symlink:

; 2233 :             return _Has_cached_attribute(__std_fs_file_attr::_Reparse_point)

	xor	al, al

; 2234 :                 && (_Cached_data._Reparse_point_tag == __std_fs_reparse_tag::_Symlink
; 2235 :                     || _Cached_data._Reparse_point_tag == __std_fs_reparse_tag::_Mount_point);
; 2236 :         }

	ret	0
?_Is_symlink_or_junction@directory_entry@filesystem@std@@QEBA_NXZ ENDP ; std::filesystem::directory_entry::_Is_symlink_or_junction
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ?_Get_any_status@directory_entry@filesystem@std@@AEBA?AU_File_status_and_error@23@W4__std_fs_stats_flags@@@Z
_TEXT	SEGMENT
_Stats$ = 32
__$ArrayPad$ = 64
this$ = 96
__$ReturnUdt$ = 104
_Flags$ = 112
?_Get_any_status@directory_entry@filesystem@std@@AEBA?AU_File_status_and_error@23@W4__std_fs_stats_flags@@@Z PROC ; std::filesystem::directory_entry::_Get_any_status, COMDAT

; 2362 :         _NODISCARD _File_status_and_error _Get_any_status(const __std_fs_stats_flags _Flags) const noexcept {

$LN109:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx

; 1979 :         file_type _Myftype = file_type::none;

	xor	ebx, ebx

; 2362 :         _NODISCARD _File_status_and_error _Get_any_status(const __std_fs_stats_flags _Flags) const noexcept {

	mov	rdx, rcx

; 1979 :         file_type _Myftype = file_type::none;

	mov	DWORD PTR [rdi], ebx

; 1980 :         perms _Myperms     = perms::unknown;

	mov	DWORD PTR [rdi+4], 65535		; 0000ffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 127  : _BITMASK_OPS(_EMPTY_ARGUMENT, __std_fs_stats_flags)

	mov	ecx, DWORD PTR [rcx+28]
	mov	eax, ecx
	and	eax, r8d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2329 :     return (_Left & _Elements) == _Elements;

	cmp	eax, r8d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2366 :             if (_Bitmask_includes_all(_Cached_data._Available, _Flags)) {

	jne	SHORT $LN2@Get_any_st

; 2367 :                 _Result._Error = __std_win_error::_Success;

	mov	DWORD PTR [rdi+8], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 82   : _BITMASK_OPS(_EMPTY_ARGUMENT, __std_fs_file_attr)

	mov	eax, 365				; 0000016dH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 1943 :                 const auto _Attrs = _Stats._Attributes;

	mov	ecx, DWORD PTR [rdx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 82   : _BITMASK_OPS(_EMPTY_ARGUMENT, __std_fs_file_attr)

	mov	r8d, 511				; 000001ffH
	test	cl, 1
	cmove	eax, r8d
	mov	DWORD PTR [rdi+4], eax
	mov	eax, ecx
	shr	eax, 10
	test	al, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 1951 :                 if (_Bitmask_includes_any(_Attrs, __std_fs_file_attr::_Reparse_point)) {

	je	SHORT $LN19@Get_any_st

; 1952 :                     if (_Stats._Reparse_point_tag == __std_fs_reparse_tag::_Symlink) {

	mov	eax, DWORD PTR [rdx+20]
	cmp	eax, -1610612724			; a000000cH
	jne	SHORT $LN18@Get_any_st
$LN105@Get_any_st:

; 2376 :             return _Result;

	mov	ebx, 4
	jmp	$LN82@Get_any_st
$LN18@Get_any_st:

; 1957 :                     if (_Stats._Reparse_point_tag == __std_fs_reparse_tag::_Mount_point) {

	cmp	eax, -1610612733			; a0000003H
	jne	SHORT $LN19@Get_any_st
$LN106@Get_any_st:

; 2376 :             return _Result;

	mov	ebx, 10
	jmp	$LN82@Get_any_st
$LN19@Get_any_st:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 82   : _BITMASK_OPS(_EMPTY_ARGUMENT, __std_fs_file_attr)

	shr	ecx, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 1965 :                 if (_Bitmask_includes_any(_Attrs, __std_fs_file_attr::_Directory)) {

	mov	rax, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 82   : _BITMASK_OPS(_EMPTY_ARGUMENT, __std_fs_file_attr)

	test	cl, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 1965 :                 if (_Bitmask_includes_any(_Attrs, __std_fs_file_attr::_Directory)) {

	je	SHORT $LN20@Get_any_st

; 1966 :                     this->type(file_type::directory);

	mov	ebx, 3

; 1967 :                 } else {

	jmp	$LN60@Get_any_st
$LN20@Get_any_st:

; 1968 :                     this->type(file_type::regular);

	mov	ebx, 2

; 2368 :                 _Result._Status._Refresh(__std_win_error::_Success, _Cached_data);
; 2369 :             } else {

	jmp	$LN60@Get_any_st
$LN2@Get_any_st:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 127  : _BITMASK_OPS(_EMPTY_ARGUMENT, __std_fs_stats_flags)

	shr	ecx, 1
	test	cl, 1

; 139  :         if (_STD _Bitmask_includes_any(_Available, __std_fs_stats_flags::_Attributes)) {

	je	SHORT $LN45@Get_any_st

; 140  :             return _Attributes;

	mov	r9d, DWORD PTR [rdx+16]
	jmp	SHORT $LN44@Get_any_st
$LN45@Get_any_st:

; 141  :         }
; 142  : 
; 143  :         return __std_fs_file_attr::_Invalid;

	mov	r9d, -1					; ffffffffH
$LN44@Get_any_st:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+56], 8

; 4107 :         return _Mypair._Myval2._Myptr();

	lea	rcx, QWORD PTR [rdx+32]

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN56@Get_any_st

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rcx]
$LN56@Get_any_st:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2370 :                 const auto _Error =

	lea	rdx, QWORD PTR _Stats$[rsp]
	call	__std_fs_get_stats

; 2371 :                     __std_fs_get_stats(_Path.c_str(), &_Stats, _Flags, _Cached_data._Symlink_hint_attributes());
; 2372 :                 _Result._Error = _Error;

	mov	DWORD PTR [rdi+8], eax

; 1942 :             if (_Error == __std_win_error::_Success) {

	test	eax, eax
	jne	SHORT $LN61@Get_any_st

; 1943 :                 const auto _Attrs = _Stats._Attributes;

	mov	ebx, DWORD PTR _Stats$[rsp+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 82   : _BITMASK_OPS(_EMPTY_ARGUMENT, __std_fs_file_attr)

	mov	eax, 365				; 0000016dH
	test	bl, 1
	mov	r8d, 511				; 000001ffH
	cmove	eax, r8d
	mov	DWORD PTR [rdi+4], eax
	mov	eax, ebx
	shr	eax, 10
	test	al, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 1951 :                 if (_Bitmask_includes_any(_Attrs, __std_fs_file_attr::_Reparse_point)) {

	je	SHORT $LN66@Get_any_st

; 1952 :                     if (_Stats._Reparse_point_tag == __std_fs_reparse_tag::_Symlink) {

	mov	eax, DWORD PTR _Stats$[rsp+20]
	cmp	eax, -1610612724			; a000000cH
	je	$LN105@Get_any_st

; 1953 :                         this->type(file_type::symlink);
; 1954 :                         return;
; 1955 :                     }
; 1956 : 
; 1957 :                     if (_Stats._Reparse_point_tag == __std_fs_reparse_tag::_Mount_point) {

	cmp	eax, -1610612733			; a0000003H
	je	$LN106@Get_any_st
$LN66@Get_any_st:

; 1969 :                 }
; 1970 : 
; 1971 :                 return;

	shr	ebx, 4
	and	ebx, 1
	add	ebx, 2
	jmp	SHORT $LN82@Get_any_st
$LN61@Get_any_st:

; 1972 :             }
; 1973 : 
; 1974 :             this->permissions(perms::unknown);

	mov	DWORD PTR [rdi+4], 65535		; 0000ffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 52   :     switch (_Error) {

	sub	eax, 2
	je	SHORT $LN85@Get_any_st
	sub	eax, 1
	je	SHORT $LN85@Get_any_st
	sub	eax, 50					; 00000032H
	je	SHORT $LN85@Get_any_st
	cmp	eax, 70					; 00000046H
	jne	SHORT $LN82@Get_any_st
$LN85@Get_any_st:

; 53   :     case __std_win_error::_File_not_found:
; 54   :     case __std_win_error::_Path_not_found:
; 55   :     case __std_win_error::_Error_bad_netpath:
; 56   :     case __std_win_error::_Invalid_name:
; 57   :         return true;

	mov	ebx, 1
$LN82@Get_any_st:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2376 :             return _Result;

	mov	rax, rdi
$LN60@Get_any_st:
	mov	DWORD PTR [rax], ebx
	mov	rax, rdi

; 2377 :         }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+120]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
?_Get_any_status@directory_entry@filesystem@std@@AEBA?AU_File_status_and_error@23@W4__std_fs_stats_flags@@@Z ENDP ; std::filesystem::directory_entry::_Get_any_status
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ?status@directory_entry@filesystem@std@@QEBA?AVfile_status@23@XZ
_TEXT	SEGMENT
_Result$ = 32
this$ = 64
__$ReturnUdt$ = 72
?status@directory_entry@filesystem@std@@QEBA?AVfile_status@23@XZ PROC ; std::filesystem::directory_entry::status, COMDAT

; 2380 :         _NODISCARD file_status status() const {

$LN16:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, rdx

; 2381 :             const auto _Result = _Get_any_status(_Status_stats_flags);

	mov	r8d, 3
	lea	rdx, QWORD PTR _Result$[rsp]
	mov	rdi, rcx
	call	?_Get_any_status@directory_entry@filesystem@std@@AEBA?AU_File_status_and_error@23@W4__std_fs_stats_flags@@@Z ; std::filesystem::directory_entry::_Get_any_status

; 2065 :             return _Error != __std_win_error::_Success && _Status.type() != file_type::not_found

	mov	edx, DWORD PTR _Result$[rsp+8]
	mov	rax, QWORD PTR _Result$[rsp]
	test	edx, edx
	je	SHORT $LN2@status
	lea	r8d, DWORD PTR [rax-1]
	test	r8d, -9					; fffffff7H
	jne	SHORT $LN14@status
$LN2@status:

; 2384 :             }
; 2385 : 
; 2386 :             return _Result._Status;

	mov	QWORD PTR [rbx], rax
	mov	rax, rbx

; 2387 :         }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN14@status:

; 2382 :             if (_Result._Not_good()) {
; 2383 :                 _Throw_fs_error("directory_entry::status", _Result._Error, _Path);

	lea	r8, QWORD PTR [rdi+32]
	lea	rcx, OFFSET FLAT:??_C@_0BI@LBKDNGFK@directory_entry?3?3status@
	call	?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@AEBVpath@12@@Z ; std::filesystem::_Throw_fs_error
	int	3
$LN12@status:
?status@directory_entry@filesystem@std@@QEBA?AVfile_status@23@XZ ENDP ; std::filesystem::directory_entry::status
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ?_Refresh@directory_entry@filesystem@std@@AEAAXAEBU__std_fs_find_data@@@Z
_TEXT	SEGMENT
this$ = 8
_Data$ = 16
?_Refresh@directory_entry@filesystem@std@@AEAAXAEBU__std_fs_find_data@@@Z PROC ; std::filesystem::directory_entry::_Refresh, COMDAT

; 2450 :             _Cached_data._Attributes        = _Data._Attributes;

	mov	eax, DWORD PTR [rdx]
	mov	r8, rcx
	mov	DWORD PTR [rcx+16], eax

; 2451 :             _Cached_data._Reparse_point_tag = _Data._Reparse_point_tag;

	mov	eax, DWORD PTR [rdx+36]
	mov	DWORD PTR [rcx+20], eax

; 2452 :             _Cached_data._Available         = __std_fs_stats_flags::_Attributes | __std_fs_stats_flags::_Reparse_tag;

	mov	DWORD PTR [rcx+28], 6
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 82   : _BITMASK_OPS(_EMPTY_ARGUMENT, __std_fs_file_attr)

	mov	eax, DWORD PTR [rdx]
	shr	eax, 10
	test	al, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2453 :             if (!_Bitmask_includes_any(_Data._Attributes, __std_fs_file_attr::_Reparse_point)) {

	jne	SHORT $LN13@Refresh

; 2454 :                 _Cached_data._File_size = (static_cast<uintmax_t>(_Data._File_size_high) << 32)

	mov	eax, DWORD PTR [rdx+32]
	mov	ecx, DWORD PTR [rdx+28]
	shl	rcx, 32					; 00000020H
	add	rcx, rax
	mov	QWORD PTR [r8+8], rcx

; 2455 :                                         + static_cast<uintmax_t>(_Data._File_size_low);
; 2456 :                 _CSTD memcpy(

	mov	rax, QWORD PTR [rdx+20]
	mov	QWORD PTR [r8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 127  : _BITMASK_OPS(_EMPTY_ARGUMENT, __std_fs_stats_flags)

	mov	DWORD PTR [r8+28], 46			; 0000002eH
$LN13@Refresh:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2460 :         }

	ret	0
?_Refresh@directory_entry@filesystem@std@@AEAAXAEBU__std_fs_find_data@@@Z ENDP ; std::filesystem::directory_entry::_Refresh
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ??0_File_status_and_error@filesystem@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0_File_status_and_error@filesystem@std@@QEAA@XZ PROC	; std::filesystem::_File_status_and_error::_File_status_and_error, COMDAT

; 1979 :         file_type _Myftype = file_type::none;

	mov	DWORD PTR [rcx], 0
	mov	rax, rcx

; 1980 :         perms _Myperms     = perms::unknown;

	mov	DWORD PTR [rcx+4], 65535		; 0000ffffH
	ret	0
??0_File_status_and_error@filesystem@std@@QEAA@XZ ENDP	; std::filesystem::_File_status_and_error::_File_status_and_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ??0file_status@filesystem@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0file_status@filesystem@std@@QEAA@XZ PROC		; std::filesystem::file_status::file_status, COMDAT

; 1908 :         explicit file_status(file_type _Ft, perms _Perms = perms::unknown) noexcept : _Myftype(_Ft), _Myperms(_Perms) {}
; 1909 :         file_status(const file_status&) noexcept = default;
; 1910 :         file_status(file_status&&) noexcept      = default;
; 1911 :         ~file_status() noexcept                  = default;
; 1912 : 
; 1913 :         // assignments
; 1914 :         file_status& operator=(const file_status&) noexcept = default;
; 1915 :         file_status& operator=(file_status&&) noexcept      = default;
; 1916 : 
; 1917 :         // [fs.file_status.mods], modifiers
; 1918 :         void type(file_type _Ft) noexcept {
; 1919 :             _Myftype = _Ft;
; 1920 :         }
; 1921 : 
; 1922 :         void permissions(perms _Perms) noexcept {
; 1923 :             _Myperms = _Perms;
; 1924 :         }
; 1925 : 
; 1926 :         // [fs.file_status.obs], observers
; 1927 :         _NODISCARD file_type type() const noexcept {
; 1928 :             return _Myftype;
; 1929 :         }
; 1930 : 
; 1931 :         _NODISCARD perms permissions() const noexcept {
; 1932 :             return _Myperms;
; 1933 :         }
; 1934 : 
; 1935 : #if _HAS_CXX20
; 1936 :         _NODISCARD_FRIEND bool operator==(const file_status& _Lhs, const file_status& _Rhs) noexcept {
; 1937 :             return _Lhs._Myftype == _Rhs._Myftype && _Lhs._Myperms == _Rhs._Myperms;
; 1938 :         }
; 1939 : #endif // _HAS_CXX20
; 1940 : 
; 1941 :         void _Refresh(const __std_win_error _Error, const __std_fs_stats& _Stats) noexcept {
; 1942 :             if (_Error == __std_win_error::_Success) {
; 1943 :                 const auto _Attrs = _Stats._Attributes;
; 1944 : 
; 1945 :                 if (_Bitmask_includes_any(_Attrs, __std_fs_file_attr::_Readonly)) {
; 1946 :                     this->permissions(perms::_File_attribute_readonly);
; 1947 :                 } else {
; 1948 :                     this->permissions(perms::all);
; 1949 :                 }
; 1950 : 
; 1951 :                 if (_Bitmask_includes_any(_Attrs, __std_fs_file_attr::_Reparse_point)) {
; 1952 :                     if (_Stats._Reparse_point_tag == __std_fs_reparse_tag::_Symlink) {
; 1953 :                         this->type(file_type::symlink);
; 1954 :                         return;
; 1955 :                     }
; 1956 : 
; 1957 :                     if (_Stats._Reparse_point_tag == __std_fs_reparse_tag::_Mount_point) {
; 1958 :                         this->type(file_type::junction);
; 1959 :                         return;
; 1960 :                     }
; 1961 : 
; 1962 :                     // All other reparse points considered ordinary files or directories
; 1963 :                 }
; 1964 : 
; 1965 :                 if (_Bitmask_includes_any(_Attrs, __std_fs_file_attr::_Directory)) {
; 1966 :                     this->type(file_type::directory);
; 1967 :                 } else {
; 1968 :                     this->type(file_type::regular);
; 1969 :                 }
; 1970 : 
; 1971 :                 return;
; 1972 :             }
; 1973 : 
; 1974 :             this->permissions(perms::unknown);
; 1975 :             this->type(__std_is_file_not_found(_Error) ? file_type::not_found : file_type::none);
; 1976 :         }
; 1977 : 
; 1978 :     private:
; 1979 :         file_type _Myftype = file_type::none;

	mov	DWORD PTR [rcx], 0
	mov	rax, rcx

; 1980 :         perms _Myperms     = perms::unknown;

	mov	DWORD PTR [rcx+4], 65535		; 0000ffffH
	ret	0
??0file_status@filesystem@std@@QEAA@XZ ENDP		; std::filesystem::file_status::file_status
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ??Ifilesystem@std@@YA?AW4directory_options@01@W4201@0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??Ifilesystem@std@@YA?AW4directory_options@01@W4201@0@Z PROC ; std::filesystem::operator&, COMDAT

; 2487 :     _BITMASK_OPS(_EXPORT_STD, directory_options)

	and	ecx, edx
	mov	eax, ecx
	ret	0
??Ifilesystem@std@@YA?AW4directory_options@01@W4201@0@Z ENDP ; std::filesystem::operator&
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ?_Skip_dots@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@W4__std_fs_dir_handle@@AEAU__std_fs_find_data@@@Z
_TEXT	SEGMENT
_Dir_handle$ = 48
_Data$ = 56
?_Skip_dots@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@W4__std_fs_dir_handle@@AEAU__std_fs_find_data@@@Z PROC ; std::filesystem::_Dir_enum_impl::_Skip_dots, COMDAT

; 2509 :             __std_fs_dir_handle _Dir_handle, __std_fs_find_data& _Data) noexcept {

$LN14:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx
	mov	rbx, rdx

; 2510 :             while (_Is_dot_or_dotdot(_Data)) {

	mov	rcx, rdx
	call	?_Is_dot_or_dotdot@filesystem@std@@YA_NAEBU__std_fs_find_data@@@Z ; std::filesystem::_Is_dot_or_dotdot
	test	al, al
	je	SHORT $LN3@Skip_dots
	npad	4
$LL2@Skip_dots:

; 2511 :                 const auto _Error = __std_fs_directory_iterator_advance(_Dir_handle, &_Data);

	mov	rdx, rbx
	mov	rcx, rdi
	call	__std_fs_directory_iterator_advance

; 2512 :                 if (_Error != __std_win_error::_Success) {

	test	eax, eax
	jne	SHORT $LN1@Skip_dots

; 2510 :             while (_Is_dot_or_dotdot(_Data)) {

	mov	rcx, rbx
	call	?_Is_dot_or_dotdot@filesystem@std@@YA_NAEBU__std_fs_find_data@@@Z ; std::filesystem::_Is_dot_or_dotdot
	test	al, al
	jne	SHORT $LL2@Skip_dots
$LN3@Skip_dots:

; 2513 :                     return _Error;
; 2514 :                 }
; 2515 :             }
; 2516 : 
; 2517 :             return __std_win_error::_Success;

	xor	eax, eax
$LN1@Skip_dots:

; 2518 :         }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_Skip_dots@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@W4__std_fs_dir_handle@@AEAU__std_fs_find_data@@@Z ENDP ; std::filesystem::_Dir_enum_impl::_Skip_dots
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ?_Open_dir@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAVpath@23@W4directory_options@23@AEAU_Find_file_handle@23@AEAU__std_fs_find_data@@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 48
_Path$ = 96
_Options_arg$ = 104
_Dir$ = 112
_Data$ = 120
?_Open_dir@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAVpath@23@W4directory_options@23@AEAU_Find_file_handle@23@AEAU__std_fs_find_data@@@Z PROC ; std::filesystem::_Dir_enum_impl::_Open_dir, COMDAT

; 2521 :             path& _Path, const directory_options _Options_arg, _Find_file_handle& _Dir, __std_fs_find_data& _Data) {

$LN49:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	push	r14
	sub	rsp, 80					; 00000050H
	mov	rsi, r9
	mov	r14, r8
	mov	edi, edx
	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rcx+24], 8
	jb	SHORT $LN45@Open_dir

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rcx]
$LN45@Open_dir:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2522 :             const size_t _Null_term_len = _CSTD wcslen(_Path.c_str());

	mov	rax, -1
$LL46@Open_dir:
	inc	rax
	cmp	WORD PTR [rcx+rax*2], 0
	jne	SHORT $LL46@Open_dir

; 2523 :             if (_Null_term_len == 0 || _Null_term_len != _Path.native().size()) {

	test	rax, rax
	je	SHORT $LN3@Open_dir
	cmp	rax, QWORD PTR [rbx+16]
	jne	SHORT $LN3@Open_dir
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 1209 :         : _Mydata(_Cts), _Mysize(_Count) {

	lea	rax, OFFSET FLAT:??_C@_13BBDEGPLJ@?$AA?$CK@
	mov	QWORD PTR $T1[rsp], rax
	mov	QWORD PTR $T1[rsp+8], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 774  :             return operator/=(path{_Source});

	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??$?0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@2@W4format@012@@Z ; std::filesystem::path::path<std::basic_string_view<wchar_t,std::char_traits<wchar_t> >,0>
	npad	1
	mov	rdx, rax
	mov	rcx, rbx
	call	??_0path@filesystem@std@@QEAAAEAV012@AEBV012@@Z ; std::filesystem::path::operator/=
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T2[rsp]
	call	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rbx+24], 8

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN34@Open_dir

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rbx, QWORD PTR [rbx]
$LN34@Open_dir:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 601  :             return __std_fs_directory_iterator_open(_Path_spec, &_Handle, _Results);

	mov	r8, rsi
	mov	rdx, r14
	mov	rcx, rbx
	call	__std_fs_directory_iterator_open

; 2525 :             }
; 2526 : 
; 2527 :             _Path /= L"*"sv;
; 2528 :             auto _Error = _Dir._Open(_Path.c_str(), &_Data);
; 2529 :             if (_Error == __std_win_error::_Success) {

	test	eax, eax
	jne	SHORT $LN4@Open_dir

; 2530 :                 return _Skip_dots(_Dir._Handle, _Data);

	mov	rdx, rsi
	mov	rcx, QWORD PTR [r14]
	call	?_Skip_dots@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@W4__std_fs_dir_handle@@AEAU__std_fs_find_data@@@Z ; std::filesystem::_Dir_enum_impl::_Skip_dots
	jmp	SHORT $LN1@Open_dir
$LN4@Open_dir:

; 2531 :             }
; 2532 : 
; 2533 :             if (_Error == __std_win_error::_Access_denied
; 2534 :                 && _Bitmask_includes_any(_Options_arg, directory_options::skip_permission_denied)) {

	cmp	eax, 5
	jne	SHORT $LN1@Open_dir

; 2487 :     _BITMASK_OPS(_EXPORT_STD, directory_options)

	shr	edi, 1
	test	dil, 1

; 2531 :             }
; 2532 : 
; 2533 :             if (_Error == __std_win_error::_Access_denied
; 2534 :                 && _Bitmask_includes_any(_Options_arg, directory_options::skip_permission_denied)) {

	mov	ecx, 18
	cmovne	eax, ecx

; 2535 :                 _Error = __std_win_error::_No_more_files;
; 2536 :             }
; 2537 : 
; 2538 :             return _Error;

	jmp	SHORT $LN1@Open_dir
$LN3@Open_dir:

; 2524 :                 return __std_win_error::_File_not_found;

	mov	eax, 2
$LN1@Open_dir:

; 2539 :         }

	mov	rbx, QWORD PTR [rsp+96]
	mov	rsi, QWORD PTR [rsp+104]
	mov	rdi, QWORD PTR [rsp+112]
	add	rsp, 80					; 00000050H
	pop	r14
	ret	0
?_Open_dir@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAVpath@23@W4directory_options@23@AEAU_Find_file_handle@23@AEAU__std_fs_find_data@@@Z ENDP ; std::filesystem::_Dir_enum_impl::_Open_dir
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 48
_Path$ = 96
_Options_arg$ = 104
_Dir$ = 112
_Data$ = 120
?dtor$0@?0??_Open_dir@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAVpath@23@W4directory_options@23@AEAU_Find_file_handle@23@AEAU__std_fs_find_data@@@Z@4HA PROC ; `std::filesystem::_Dir_enum_impl::_Open_dir'::`1'::dtor$0
	lea	rcx, QWORD PTR $T2[rdx]
	jmp	??1path@filesystem@std@@QEAA@XZ		; std::filesystem::path::~path
?dtor$0@?0??_Open_dir@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAVpath@23@W4directory_options@23@AEAU_Find_file_handle@23@AEAU__std_fs_find_data@@@Z@4HA ENDP ; `std::filesystem::_Dir_enum_impl::_Open_dir'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ??0_Creator@_Dir_enum_impl@filesystem@std@@QEAA@AEBVpath@23@W4directory_options@23@@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 48
$T3 = 48
this$ = 48
_Path_arg$ = 56
_Options$ = 64
??0_Creator@_Dir_enum_impl@filesystem@std@@QEAA@AEBVpath@23@W4directory_options@23@@Z PROC ; std::filesystem::_Dir_enum_impl::_Creator::_Creator, COMDAT

; 2553 :             _Creator(const path& _Path_arg, const directory_options _Options) : _Path(_Path_arg) {

$LN14:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	ebx, r8d
	mov	rdi, rcx
	call	??0path@filesystem@std@@QEAA@AEBV012@@Z	; std::filesystem::path::path
	npad	1
	lea	r8, QWORD PTR [rdi+32]

; 587  :         __std_fs_dir_handle _Handle = __std_fs_dir_handle::_Invalid;

	mov	QWORD PTR [r8], -1

; 2554 :                 const auto _Error = _Open_dir(_Path, _Options, _Dir, _Find_data);

	lea	r9, QWORD PTR [rdi+40]
	mov	edx, ebx
	mov	rcx, rdi
	call	?_Open_dir@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAVpath@23@W4directory_options@23@AEAU_Find_file_handle@23@AEAU__std_fs_find_data@@@Z ; std::filesystem::_Dir_enum_impl::_Open_dir

; 2555 :                 if (_Error == __std_win_error::_Success) {

	mov	DWORD PTR $T3[rsp+4], 0
	test	eax, eax
	jne	SHORT $LN2@Creator

; 2556 :                     _Status = {true, __std_win_error::_Success};

	mov	BYTE PTR $T3[rsp], 1
	jmp	SHORT $LN11@Creator
$LN2@Creator:

; 2557 :                 } else if (_Error == __std_win_error::_No_more_files) {

	mov	BYTE PTR $T2[rsp], 0
	cmp	eax, 18
	je	SHORT $LN11@Creator

; 2558 :                     _Status = {false, __std_win_error::_Success};
; 2559 :                 } else {
; 2560 :                     _Status = {false, _Error};

	mov	DWORD PTR $T1[rsp+4], eax
$LN11@Creator:

; 2561 :                 }
; 2562 :             }

	mov	rax, QWORD PTR $T1[rsp]
	mov	QWORD PTR [rdi+632], rax
	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0_Creator@_Dir_enum_impl@filesystem@std@@QEAA@AEBVpath@23@W4directory_options@23@@Z ENDP ; std::filesystem::_Dir_enum_impl::_Creator::_Creator
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 48
$T3 = 48
this$ = 48
_Path_arg$ = 56
_Options$ = 64
?dtor$0@?0???0_Creator@_Dir_enum_impl@filesystem@std@@QEAA@AEBVpath@23@W4directory_options@23@@Z@4HA PROC ; `std::filesystem::_Dir_enum_impl::_Creator::_Creator'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1path@filesystem@std@@QEAA@XZ		; std::filesystem::path::~path
?dtor$0@?0???0_Creator@_Dir_enum_impl@filesystem@std@@QEAA@AEBVpath@23@W4directory_options@23@@Z@4HA ENDP ; `std::filesystem::_Dir_enum_impl::_Creator::_Creator'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 48
$T3 = 48
this$ = 48
_Path_arg$ = 56
_Options$ = 64
?dtor$1@?0???0_Creator@_Dir_enum_impl@filesystem@std@@QEAA@AEBVpath@23@W4directory_options@23@@Z@4HA PROC ; `std::filesystem::_Dir_enum_impl::_Creator::_Creator'::`1'::dtor$1
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 32					; 00000020H
	jmp	??1_Find_file_handle@filesystem@std@@QEAA@XZ ; std::filesystem::_Find_file_handle::~_Find_file_handle
?dtor$1@?0???0_Creator@_Dir_enum_impl@filesystem@std@@QEAA@AEBVpath@23@W4directory_options@23@@Z@4HA ENDP ; `std::filesystem::_Dir_enum_impl::_Creator::_Creator'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ?_Refresh@_Dir_enum_impl@filesystem@std@@QEAAXAEBU__std_fs_find_data@@@Z
_TEXT	SEGMENT
$T2 = 32
this$ = 112
_Data$ = 120
?_Refresh@_Dir_enum_impl@filesystem@std@@QEAAXAEBU__std_fs_find_data@@@Z PROC ; std::filesystem::_Dir_enum_impl::_Refresh, COMDAT

; 2565 :         void _Refresh(const __std_fs_find_data& _Data) {

$LN168:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H
	mov	r8, rcx
	xor	r15d, r15d

; 2450 :             _Cached_data._Attributes        = _Data._Attributes;

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+16], eax

; 2451 :             _Cached_data._Reparse_point_tag = _Data._Reparse_point_tag;

	mov	eax, DWORD PTR [rdx+36]
	mov	DWORD PTR [rcx+20], eax

; 2452 :             _Cached_data._Available         = __std_fs_stats_flags::_Attributes | __std_fs_stats_flags::_Reparse_tag;

	mov	DWORD PTR [rcx+28], 6
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 82   : _BITMASK_OPS(_EMPTY_ARGUMENT, __std_fs_file_attr)

	test	DWORD PTR [rdx], 1024			; 00000400H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2453 :             if (!_Bitmask_includes_any(_Data._Attributes, __std_fs_file_attr::_Reparse_point)) {

	jne	SHORT $LN16@Refresh

; 2454 :                 _Cached_data._File_size = (static_cast<uintmax_t>(_Data._File_size_high) << 32)

	mov	ecx, DWORD PTR [rdx+28]
	shl	rcx, 32					; 00000020H
	mov	eax, DWORD PTR [rdx+32]
	add	rcx, rax
	mov	QWORD PTR [r8+8], rcx

; 2455 :                                         + static_cast<uintmax_t>(_Data._File_size_low);
; 2456 :                 _CSTD memcpy(

	mov	rax, QWORD PTR [rdx+20]
	mov	QWORD PTR [r8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 127  : _BITMASK_OPS(_EMPTY_ARGUMENT, __std_fs_stats_flags)

	mov	DWORD PTR [r8+28], 46			; 0000002eH
$LN16@Refresh:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2567 :             _Entry._Path.replace_filename(wstring_view{_Data._File_name});

	lea	r14, QWORD PTR [r8+32]
	lea	rsi, QWORD PTR [rdx+44]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 261  :             return __builtin_wcslen(_First);

	mov	rbx, -1
	npad	9
$LL159@Refresh:
	inc	rbx
	cmp	WORD PTR [rsi+rbx*2], r15w
	jne	SHORT $LL159@Refresh
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T2[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T2[rsp+16], r15

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T2[rsp+24], r15
	mov	rbp, 9223372036854775806		; 7ffffffffffffffeH
	cmp	rbx, rbp

; 2620 :         if (_Count > max_size()) {

	ja	$LN165@Refresh

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T2[rsp+24], 7
	cmp	rbx, 8
	jae	SHORT $LN52@Refresh

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T2[rsp+16], rbx

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	add	rbx, rbx
	mov	r8, rbx
	mov	rdx, rsi
	lea	rcx, QWORD PTR $T2[rsp]
	call	memcpy

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	WORD PTR $T2[rsp+rbx], r15w

; 2638 :             } else { // _Strat == _Construct_strategy::_From_string
; 2639 : #ifdef _INSERT_STRING_ANNOTATION
; 2640 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 2641 : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 2642 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 2643 : #endif // !_INSERT_STRING_ANNOTATION
; 2644 :             }
; 2645 : 
; 2646 :             _Proxy._Release();
; 2647 :             return;

	jmp	SHORT $LN50@Refresh
$LN52@Refresh:

; 2648 :         }
; 2649 : 
; 2650 :         _My_data._Myres               = _BUF_SIZE - 1;

	mov	rax, rbx
	or	rax, 7

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	cmp	rax, rbp

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN62@Refresh

; 4716 :             return _Max;
; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	mov	rbp, rax
	mov	ecx, 10
	cmp	rax, rcx
	cmovb	rbp, rcx
$LN62@Refresh:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	rdx, QWORD PTR [rbp+1]
	call	?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z ; std::allocator<wchar_t>::allocate
	mov	rdi, rax

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T2[rsp], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T2[rsp+16], rbx

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T2[rsp+24], rbp

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	add	rbx, rbx
	mov	r8, rbx
	mov	rdx, rsi
	mov	rcx, rax
	call	memcpy

; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	mov	WORD PTR [rbx+rdi], r15w
$LN50@Refresh:

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	r10, r14

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	r11, QWORD PTR [r14+24]

; 2227 :         if (_Large_string_engaged()) {

	cmp	r11, 8
	jb	SHORT $LN155@Refresh

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r10, QWORD PTR [r14]
$LN155@Refresh:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 852  :             const auto _Last     = _First + _Text.size();

	mov	rbx, QWORD PTR [r14+16]
	lea	rdx, QWORD PTR [r10+rbx*2]

; 435  :         return _STD find_if_not(_Find_root_name_end(_First, _Last), _Last, _Is_slash);

	mov	rcx, r10
	call	?_Find_root_name_end@filesystem@std@@YAPEB_WQEB_W0@Z ; std::filesystem::_Find_root_name_end
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 370  :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rax, rdx
	je	SHORT $LN93@Refresh
	npad	1
$LL100@Refresh:

; 371  :         if (!_Pred(*_UFirst)) {

	movzx	ecx, WORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 384  :         return _Ch == L'\\' || _Ch == L'/';

	cmp	cx, 92					; 0000005cH
	je	SHORT $LN157@Refresh
	cmp	cx, 47					; 0000002fH
	jne	SHORT $LN158@Refresh
$LN157@Refresh:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 370  :     for (; _UFirst != _ULast; ++_UFirst) {

	add	rax, 2
	cmp	rax, rdx
	jne	SHORT $LL100@Refresh
$LN158@Refresh:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 487  :         while (_Relative_path != _Last && !_Is_slash(_Last[-1])) {

	cmp	rax, rdx
	je	SHORT $LN93@Refresh
	npad	3
$LL92@Refresh:
	lea	r8, QWORD PTR [rdx-2]
	movzx	ecx, WORD PTR [r8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 384  :         return _Ch == L'\\' || _Ch == L'/';

	cmp	cx, 92					; 0000005cH
	je	SHORT $LN93@Refresh
	cmp	cx, 47					; 0000002fH
	je	SHORT $LN93@Refresh
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 488  :             --_Last;

	mov	rdx, r8

; 487  :         while (_Relative_path != _Last && !_Is_slash(_Last[-1])) {

	cmp	rax, r8
	jne	SHORT $LL92@Refresh
$LN93@Refresh:

; 855  :             _Text.erase(static_cast<size_t>(_Filename - _First));

	sub	rdx, r10
	sar	rdx, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2260 :         if (_Mysize < _Off) {

	cmp	rbx, rdx
	jb	SHORT $LN166@Refresh

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	rax, r14

; 2227 :         if (_Large_string_engaged()) {

	cmp	r11, 8
	jb	SHORT $LN120@Refresh

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [r14]
$LN120@Refresh:

; 4815 :         _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _New_size], _Elem());

	mov	QWORD PTR [r14+16], rdx
	mov	WORD PTR [rax+rdx*2], r15w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 882  :             return operator/=(_Replacement);

	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, r14
	call	??_0path@filesystem@std@@QEAAAEAV012@AEBV012@@Z ; std::filesystem::path::operator/=
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T2[rsp]
	call	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2568 :         }

	lea	r11, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [r11+40]
	mov	rbp, QWORD PTR [r11+48]
	mov	rsi, QWORD PTR [r11+56]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	rdi
	ret	0
$LN166@Refresh:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2261 :             _Xran();

	call	?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Xran
	npad	1
$LN165@Refresh:

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN162@Refresh:
?_Refresh@_Dir_enum_impl@filesystem@std@@QEAAXAEBU__std_fs_find_data@@@Z ENDP ; std::filesystem::_Dir_enum_impl::_Refresh
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 32
this$ = 112
_Data$ = 120
?dtor$0@?0??_Refresh@_Dir_enum_impl@filesystem@std@@QEAAXAEBU__std_fs_find_data@@@Z@4HA PROC ; `std::filesystem::_Dir_enum_impl::_Refresh'::`1'::dtor$0
	lea	rcx, QWORD PTR $T2[rdx]
	jmp	??1path@filesystem@std@@QEAA@XZ		; std::filesystem::path::~path
?dtor$0@?0??_Refresh@_Dir_enum_impl@filesystem@std@@QEAAXAEBU__std_fs_find_data@@@Z@4HA ENDP ; `std::filesystem::_Dir_enum_impl::_Refresh'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ??0_Dir_enum_impl@filesystem@std@@QEAA@$$QEAU_Creator@012@W4directory_options@12@@Z
_TEXT	SEGMENT
this$GSCopy$ = 32
this$ = 80
_Create_data$ = 88
__formal$dead$ = 96
??0_Dir_enum_impl@filesystem@std@@QEAA@$$QEAU_Creator@012@W4directory_options@12@@Z PROC ; std::filesystem::_Dir_enum_impl::_Dir_enum_impl, COMDAT

; 2570 :         explicit _Dir_enum_impl(_Creator&& _Create_data, const directory_options = {})

$LN89:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rdx
	mov	rsi, rcx
	mov	QWORD PTR this$GSCopy$[rsp], rcx
	xorps	xmm0, xmm0

; 2088 :         directory_entry() noexcept : _Cached_data{}, _Path() {}

	movups	XMMWORD PTR [rcx], xmm0
	movups	XMMWORD PTR [rcx+16], xmm0
	lea	rbx, QWORD PTR [rcx+32]
	movups	XMMWORD PTR [rbx+16], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rbx], xmm0

; 4821 :         _My_data._Mysize = 0;

	xor	ebp, ebp
	mov	QWORD PTR [rbx+16], rbp

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 7

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	WORD PTR [rbx], bp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx+32]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+32], -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 591  :             : _Handle(_STD exchange(_Rhs._Handle, __std_fs_dir_handle::_Invalid)) {}

	mov	QWORD PTR [rcx+64], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2961 :         if (this == _STD addressof(_Right)) {

	cmp	rbx, rdx
	je	SHORT $LN77@Dir_enum_i

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR [rbx+24]

; 4832 :         if (_My_data._Large_string_engaged()) {

	cmp	rdx, 8
	jb	SHORT $LN42@Dir_enum_i

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;

	mov	rcx, QWORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rdx*2+2]

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN54@Dir_enum_i

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN51@Dir_enum_i

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN54@Dir_enum_i:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN42@Dir_enum_i:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], rbp

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 7

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	WORD PTR [rbx], bp

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdi]
	movups	XMMWORD PTR [rbx], xmm0
	movups	xmm1, XMMWORD PTR [rdi+16]
	movups	XMMWORD PTR [rbx+16], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], rbp

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdi+24], 7

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	WORD PTR [rdi], bp
$LN77@Dir_enum_i:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2574 :             _Refresh(_Create_data._Find_data);

	lea	rdx, QWORD PTR [rdi+40]
	mov	rcx, rsi
	call	?_Refresh@_Dir_enum_impl@filesystem@std@@QEAAXAEBU__std_fs_find_data@@@Z ; std::filesystem::_Dir_enum_impl::_Refresh
	npad	1

; 2575 :         }

	mov	rax, rsi
	mov	rbx, QWORD PTR [rsp+96]
	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN51@Dir_enum_i:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN86@Dir_enum_i:
??0_Dir_enum_impl@filesystem@std@@QEAA@$$QEAU_Creator@012@W4directory_options@12@@Z ENDP ; std::filesystem::_Dir_enum_impl::_Dir_enum_impl
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$GSCopy$ = 32
this$ = 80
_Create_data$ = 88
__formal$dead$ = 96
?dtor$0@?0???0_Dir_enum_impl@filesystem@std@@QEAA@$$QEAU_Creator@012@W4directory_options@12@@Z@4HA PROC ; `std::filesystem::_Dir_enum_impl::_Dir_enum_impl'::`1'::dtor$0
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	jmp	??1directory_entry@filesystem@std@@QEAA@XZ ; std::filesystem::directory_entry::~directory_entry
?dtor$0@?0???0_Dir_enum_impl@filesystem@std@@QEAA@$$QEAU_Creator@012@W4directory_options@12@@Z@4HA ENDP ; `std::filesystem::_Dir_enum_impl::_Dir_enum_impl'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$GSCopy$ = 32
this$ = 80
_Create_data$ = 88
__formal$dead$ = 96
?dtor$1@?0???0_Dir_enum_impl@filesystem@std@@QEAA@$$QEAU_Creator@012@W4directory_options@12@@Z@4HA PROC ; `std::filesystem::_Dir_enum_impl::_Dir_enum_impl'::`1'::dtor$1
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 64					; 00000040H
	jmp	??1_Find_file_handle@filesystem@std@@QEAA@XZ ; std::filesystem::_Find_file_handle::~_Find_file_handle
?dtor$1@?0???0_Dir_enum_impl@filesystem@std@@QEAA@$$QEAU_Creator@012@W4directory_options@12@@Z@4HA ENDP ; `std::filesystem::_Dir_enum_impl::_Dir_enum_impl'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ??0_Find_file_handle@filesystem@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0_Find_file_handle@filesystem@std@@QEAA@XZ PROC	; std::filesystem::_Find_file_handle::_Find_file_handle, COMDAT

; 587  :         __std_fs_dir_handle _Handle = __std_fs_dir_handle::_Invalid;

	mov	QWORD PTR [rcx], -1

; 589  :         _Find_file_handle() noexcept = default;

	mov	rax, rcx
	ret	0
??0_Find_file_handle@filesystem@std@@QEAA@XZ ENDP	; std::filesystem::_Find_file_handle::_Find_file_handle
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ??1directory_entry@filesystem@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1directory_entry@filesystem@std@@QEAA@XZ PROC		; std::filesystem::directory_entry::~directory_entry, COMDAT

; 638  :         ~path()                          = default;

	add	rcx, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	jmp	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
??1directory_entry@filesystem@std@@QEAA@XZ ENDP		; std::filesystem::directory_entry::~directory_entry
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ??4path@filesystem@std@@QEAAAEAV012@$$QEAV012@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??4path@filesystem@std@@QEAAAEAV012@$$QEAV012@@Z PROC	; std::filesystem::path::operator=, COMDAT

; 640  :         path& operator=(path&&) noexcept = default;

$LN65:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx
	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2961 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN50@operator

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR [rcx+24]
	cmp	rdx, 8

; 4832 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN15@operator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rcx]
	lea	rdx, QWORD PTR [rdx*2+2]

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN27@operator

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN24@operator

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN27@operator:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN15@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 7
	xor	eax, eax
	mov	QWORD PTR [rbx+16], rax

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	WORD PTR [rbx], ax

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdi]
	movups	XMMWORD PTR [rbx], xmm0
	movups	xmm1, XMMWORD PTR [rdi+16]
	movups	XMMWORD PTR [rbx+16], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdi+24], 7

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	WORD PTR [rdi], ax
$LN50@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 640  :         path& operator=(path&&) noexcept = default;

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN24@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN62@operator:
??4path@filesystem@std@@QEAAAEAV012@$$QEAV012@@Z ENDP	; std::filesystem::path::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ?_Should_recurse@_Recursive_dir_enum_impl@filesystem@std@@QEBA?AU_Should_recurse_result@23@XZ
_TEXT	SEGMENT
_Target_stats$1 = 32
__$ArrayPad$ = 64
this$ = 96
__$ReturnUdt$ = 104
?_Should_recurse@_Recursive_dir_enum_impl@filesystem@std@@QEBA?AU_Should_recurse_result@23@XZ PROC ; std::filesystem::_Recursive_dir_enum_impl::_Should_recurse, COMDAT

; 2718 :         _NODISCARD _Should_recurse_result _Should_recurse() const noexcept {

$LN73:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 2719 :             bool _Should_recurse   = false;

	xor	bl, bl

; 2720 :             __std_win_error _Error = __std_win_error::_Success;

	xor	r8d, r8d
	mov	rsi, rdx
	mov	rdi, rcx

; 2721 :             if (_Recursion_pending) {

	cmp	BYTE PTR [rcx+100], bl
	je	$LN53@Should_rec
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 82   : _BITMASK_OPS(_EMPTY_ARGUMENT, __std_fs_file_attr)

	mov	edx, DWORD PTR [rcx+16]
	mov	eax, edx
	shr	eax, 10
	test	al, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2233 :             return _Has_cached_attribute(__std_fs_file_attr::_Reparse_point)

	je	SHORT $LN3@Should_rec
	mov	eax, DWORD PTR [rcx+20]
	cmp	eax, -1610612724			; a000000cH
	je	SHORT $LN58@Should_rec
	cmp	eax, -1610612733			; a0000003H
	jne	SHORT $LN3@Should_rec
$LN58@Should_rec:

; 2487 :     _BITMASK_OPS(_EXPORT_STD, directory_options)

	test	BYTE PTR [rcx+96], 1

; 2722 :                 if (_Entry._Is_symlink_or_junction()) {
; 2723 :                     if (_Bitmask_includes_any(_Options, directory_options::follow_directory_symlink)) {

	je	SHORT $LN53@Should_rec
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4107 :         return _Mypair._Myval2._Myptr();

	add	rcx, 32					; 00000020H

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 8

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN31@Should_rec

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rcx]
$LN31@Should_rec:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2728 :                         _Error = __std_fs_get_stats(

	mov	r9d, edx
	mov	r8d, 3
	lea	rdx, QWORD PTR _Target_stats$1[rsp]
	call	__std_fs_get_stats
	mov	r8d, eax

; 2729 :                             _Entry._Path.c_str(), &_Target_stats, _Flags, _Entry._Cached_data._Attributes);
; 2730 :                         if (_Error == __std_win_error::_Success) {

	test	eax, eax
	jne	SHORT $LN6@Should_rec
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 82   : _BITMASK_OPS(_EMPTY_ARGUMENT, __std_fs_file_attr)

	mov	ebx, DWORD PTR _Target_stats$1[rsp+16]
	shr	ebx, 4
	and	bl, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2733 :                         } else if (__std_is_file_not_found(_Error)

	jmp	SHORT $LN53@Should_rec
$LN6@Should_rec:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 52   :     switch (_Error) {

	sub	eax, 2
	je	SHORT $LN9@Should_rec
	sub	eax, 1
	je	SHORT $LN9@Should_rec
	sub	eax, 50					; 00000032H
	je	SHORT $LN9@Should_rec
	cmp	eax, 70					; 00000046H
	je	SHORT $LN9@Should_rec
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2734 :                                    || (_Error == __std_win_error::_Access_denied

	cmp	r8d, 5
	jne	SHORT $LN53@Should_rec

; 2487 :     _BITMASK_OPS(_EXPORT_STD, directory_options)

	mov	eax, DWORD PTR [rdi+96]
	shr	eax, 1
	test	al, 1

; 2734 :                                    || (_Error == __std_win_error::_Access_denied

	je	SHORT $LN53@Should_rec
$LN9@Should_rec:

; 2735 :                                        && _Bitmask_includes_any(_Options, directory_options::skip_permission_denied))) {
; 2736 :                             // skip broken symlinks and permission denied (when configured)
; 2737 :                             _Error = __std_win_error::_Success;

	xor	r8d, r8d

; 2738 :                         }
; 2739 :                     }
; 2740 :                 } else {

	jmp	SHORT $LN53@Should_rec
$LN3@Should_rec:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 82   : _BITMASK_OPS(_EMPTY_ARGUMENT, __std_fs_file_attr)

	shr	edx, 4
	and	dl, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2149 :             return _Bitmask_includes_any(_Cached_data._Attributes, _Attrs);

	movzx	ebx, dl
$LN53@Should_rec:

; 2741 :                     _Should_recurse = _Entry._Has_cached_attribute(__std_fs_file_attr::_Directory);
; 2742 :                 }
; 2743 :             }
; 2744 : 
; 2745 :             return {_Should_recurse, _Error};

	mov	BYTE PTR [rsi], bl
	mov	rax, rsi
	mov	DWORD PTR [rsi+4], r8d

; 2746 :         }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+112]
	mov	rsi, QWORD PTR [rsp+120]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
?_Should_recurse@_Recursive_dir_enum_impl@filesystem@std@@QEBA?AU_Should_recurse_result@23@XZ ENDP ; std::filesystem::_Recursive_dir_enum_impl::_Should_recurse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ?_Advance_and_skip_dots@_Recursive_dir_enum_impl@filesystem@std@@QEAA?AW4__std_win_error@@AEAU__std_fs_find_data@@@Z
_TEXT	SEGMENT
this$ = 48
_Data$ = 56
?_Advance_and_skip_dots@_Recursive_dir_enum_impl@filesystem@std@@QEAA?AW4__std_win_error@@AEAU__std_fs_find_data@@@Z PROC ; std::filesystem::_Recursive_dir_enum_impl::_Advance_and_skip_dots, COMDAT

; 2748 :         _NODISCARD __std_win_error _Advance_and_skip_dots(__std_fs_find_data& _Data) noexcept {

$LN18:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx
	mov	rbx, rdx

; 2749 :             const auto _Error = __std_fs_directory_iterator_advance(_Dir._Handle, &_Data);

	mov	rcx, QWORD PTR [rcx+64]
	call	__std_fs_directory_iterator_advance

; 2750 :             if (_Error != __std_win_error::_Success) {

	test	eax, eax
	jne	SHORT $LN4@Advance_an

; 2751 :                 return _Error;
; 2752 :             }
; 2753 : 
; 2754 :             return _Skip_dots(_Dir._Handle, _Data);

	mov	rdi, QWORD PTR [rdi+64]

; 2510 :             while (_Is_dot_or_dotdot(_Data)) {

	mov	rcx, rbx
	call	?_Is_dot_or_dotdot@filesystem@std@@YA_NAEBU__std_fs_find_data@@@Z ; std::filesystem::_Is_dot_or_dotdot
	test	al, al
	je	SHORT $LN6@Advance_an
	npad	3
$LL5@Advance_an:

; 2511 :                 const auto _Error = __std_fs_directory_iterator_advance(_Dir_handle, &_Data);

	mov	rdx, rbx
	mov	rcx, rdi
	call	__std_fs_directory_iterator_advance

; 2512 :                 if (_Error != __std_win_error::_Success) {

	test	eax, eax
	jne	SHORT $LN4@Advance_an

; 2510 :             while (_Is_dot_or_dotdot(_Data)) {

	mov	rcx, rbx
	call	?_Is_dot_or_dotdot@filesystem@std@@YA_NAEBU__std_fs_find_data@@@Z ; std::filesystem::_Is_dot_or_dotdot
	test	al, al
	jne	SHORT $LL5@Advance_an
$LN6@Advance_an:

; 2513 :                     return _Error;
; 2514 :                 }
; 2515 :             }
; 2516 : 
; 2517 :             return __std_win_error::_Success;

	xor	eax, eax
$LN4@Advance_an:

; 2755 :         }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_Advance_and_skip_dots@_Recursive_dir_enum_impl@filesystem@std@@QEAA?AW4__std_win_error@@AEAU__std_fs_find_data@@@Z ENDP ; std::filesystem::_Recursive_dir_enum_impl::_Advance_and_skip_dots
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ?_Advance_and_reset_if_no_more_files@_Recursive_dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@3@@Z
_TEXT	SEGMENT
_Target_stats$1 = 40
_Data$ = 80
__$ArrayPad$ = 672
_Ptr$ = 736
?_Advance_and_reset_if_no_more_files@_Recursive_dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@3@@Z PROC ; std::filesystem::_Recursive_dir_enum_impl::_Advance_and_reset_if_no_more_files, COMDAT

; 2786 :             shared_ptr<_Recursive_dir_enum_impl>& _Ptr) {

$LN327:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 688				; 000002b0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r12, rcx

; 2787 :             auto& _Impl = *_Ptr;

	mov	rbp, QWORD PTR [rcx]

; 2719 :             bool _Should_recurse   = false;

	xor	bl, bl

; 2720 :             __std_win_error _Error = __std_win_error::_Success;

	xor	esi, esi
	mov	edi, esi

; 2721 :             if (_Recursion_pending) {

	cmp	BYTE PTR [rbp+100], bl
	je	$LN5@Advance_an
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 82   : _BITMASK_OPS(_EMPTY_ARGUMENT, __std_fs_file_attr)

	mov	edx, DWORD PTR [rbp+16]
	bt	edx, 10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2233 :             return _Has_cached_attribute(__std_fs_file_attr::_Reparse_point)

	jae	$LN14@Advance_an
	mov	eax, DWORD PTR [rbp+20]
	cmp	eax, -1610612724			; a000000cH
	je	SHORT $LN306@Advance_an
	cmp	eax, -1610612733			; a0000003H
	jne	$LN14@Advance_an
$LN306@Advance_an:

; 2487 :     _BITMASK_OPS(_EXPORT_STD, directory_options)

	test	BYTE PTR [rbp+96], 1

; 2723 :                     if (_Bitmask_includes_any(_Options, directory_options::follow_directory_symlink)) {

	je	SHORT $LN19@Advance_an
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4107 :         return _Mypair._Myval2._Myptr();

	lea	rcx, QWORD PTR [rbp+32]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rcx+24], 8
	jb	SHORT $LN42@Advance_an

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rcx]
$LN42@Advance_an:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2728 :                         _Error = __std_fs_get_stats(

	mov	r9d, edx
	mov	r8d, 3
	lea	rdx, QWORD PTR _Target_stats$1[rsp]
	call	__std_fs_get_stats
	mov	edi, eax

; 2729 :                             _Entry._Path.c_str(), &_Target_stats, _Flags, _Entry._Cached_data._Attributes);
; 2730 :                         if (_Error == __std_win_error::_Success) {

	test	eax, eax
	jne	SHORT $LN17@Advance_an
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 82   : _BITMASK_OPS(_EMPTY_ARGUMENT, __std_fs_file_attr)

	test	DWORD PTR _Target_stats$1[rsp+16], 16
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2324 :     return (_Left & _Elements) != _Bitmask{};

	setne	bl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2733 :                         } else if (__std_is_file_not_found(_Error)

	jmp	SHORT $LN19@Advance_an
$LN17@Advance_an:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 52   :     switch (_Error) {

	sub	eax, 2
	je	SHORT $LN20@Advance_an
	sub	eax, 1
	je	SHORT $LN20@Advance_an
	sub	eax, 50					; 00000032H
	je	SHORT $LN20@Advance_an
	cmp	eax, 70					; 00000046H
	je	SHORT $LN20@Advance_an
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2734 :                                    || (_Error == __std_win_error::_Access_denied

	cmp	edi, 5
	jne	SHORT $LN19@Advance_an

; 2487 :     _BITMASK_OPS(_EXPORT_STD, directory_options)

	test	BYTE PTR [rbp+96], 2

; 2734 :                                    || (_Error == __std_win_error::_Access_denied

	je	SHORT $LN19@Advance_an
$LN20@Advance_an:

; 2735 :                                        && _Bitmask_includes_any(_Options, directory_options::skip_permission_denied))) {
; 2736 :                             // skip broken symlinks and permission denied (when configured)
; 2737 :                             _Error = __std_win_error::_Success;

	mov	edi, esi
$LN19@Advance_an:

; 2738 :                         }
; 2739 :                     }
; 2740 :                 } else {
; 2741 :                     _Should_recurse = _Entry._Has_cached_attribute(__std_fs_file_attr::_Directory);
; 2742 :                 }
; 2743 :             }
; 2744 : 
; 2745 :             return {_Should_recurse, _Error};

	test	edi, edi

; 2788 :             __std_fs_find_data _Data;
; 2789 :             auto [_Should_recurse, _Error] = _Impl._Should_recurse();
; 2790 :             if (_Error != __std_win_error::_Success) {

	je	SHORT $LN5@Advance_an
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [r12], rsi

; 100  :     _Left    = _STD move(_Right);

	mov	rbx, QWORD PTR [r12+8]

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [r12+8], rsi
	test	rbx, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 1402 :         if (_Rep) {

	je	SHORT $LN93@Advance_an

; 1177 :         if (_MT_DECR(_Uses) == 0) {

	mov	r14, -1
	mov	eax, r14d
	lock xadd DWORD PTR [rbx+8], eax
	cmp	eax, 1
	jne	SHORT $LN93@Advance_an

; 1178 :             _Destroy();

	mov	rax, QWORD PTR [rbx]
	mov	rcx, rbx
	call	QWORD PTR [rax]

; 1184 :         if (_MT_DECR(_Weaks) == 0) {

	lock xadd DWORD PTR [rbx+12], r14d
	cmp	r14d, 1
	jne	SHORT $LN93@Advance_an

; 1185 :             _Delete_this();

	mov	rax, QWORD PTR [rbx]
	mov	rcx, rbx
	call	QWORD PTR [rax+8]
$LN93@Advance_an:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2792 :                 return _Error;

	mov	eax, edi
	jmp	$LN1@Advance_an
$LN14@Advance_an:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 82   : _BITMASK_OPS(_EMPTY_ARGUMENT, __std_fs_file_attr)

	bt	edx, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2324 :     return (_Left & _Elements) != _Bitmask{};

	setb	bl
$LN5@Advance_an:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2795 :             if (_Should_recurse) {

	mov	r14, -1
	test	bl, bl
	je	SHORT $LN6@Advance_an

; 2796 :                 _Impl._Stack.push_back(_STD move(_Impl._Dir));

	lea	r13, QWORD PTR [rbp+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rbp+80]
	cmp	rdx, QWORD PTR [rbp+88]
	je	SHORT $LN98@Advance_an

; 806  :         ++_Mylast;

	mov	rax, QWORD PTR [rbp+64]
	mov	QWORD PTR [rbp+64], r14
	mov	QWORD PTR [rdx], rax
	add	QWORD PTR [rbp+80], 8

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN97@Advance_an
$LN98@Advance_an:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR [rbp+64]
	mov	rcx, r13
	call	??$_Emplace_reallocate@U_Find_file_handle@filesystem@std@@@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAPEAU_Find_file_handle@filesystem@1@QEAU231@$$QEAU231@@Z ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::_Emplace_reallocate<std::filesystem::_Find_file_handle>
$LN97@Advance_an:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2797 :                 _Error = _Open_dir(_Impl._Entry._Path, _Impl._Options, _Impl._Dir, _Data);

	lea	rsi, QWORD PTR [rbp+32]
	lea	r9, QWORD PTR _Data$[rsp]
	lea	r8, QWORD PTR [rbp+64]
	mov	edx, DWORD PTR [rbp+96]
	mov	rcx, rsi
	call	?_Open_dir@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAVpath@23@W4directory_options@23@AEAU_Find_file_handle@23@AEAU__std_fs_find_data@@@Z ; std::filesystem::_Dir_enum_impl::_Open_dir
	mov	ebx, eax

; 2798 :             } else {

	jmp	SHORT $LN7@Advance_an
$LN6@Advance_an:

; 2749 :             const auto _Error = __std_fs_directory_iterator_advance(_Dir._Handle, &_Data);

	lea	rdx, QWORD PTR _Data$[rsp]
	mov	rcx, QWORD PTR [rbp+64]
	call	__std_fs_directory_iterator_advance
	mov	ebx, eax

; 2750 :             if (_Error != __std_win_error::_Success) {

	test	eax, eax
	jne	SHORT $LN116@Advance_an

; 2751 :                 return _Error;
; 2752 :             }
; 2753 : 
; 2754 :             return _Skip_dots(_Dir._Handle, _Data);

	mov	rdi, QWORD PTR [rbp+64]
$LL120@Advance_an:

; 570  :         if (_Data._File_name[0] != L'.') {

	cmp	WORD PTR _Data$[rsp+44], 46		; 0000002eH
	jne	SHORT $LN121@Advance_an

; 571  :             return false;
; 572  :         }
; 573  : 
; 574  :         const auto _Second_char = _Data._File_name[1];
; 575  :         if (_Second_char == 0) {

	movzx	eax, WORD PTR _Data$[rsp+46]
	test	ax, ax
	je	SHORT $LN308@Advance_an

; 576  :             return true;
; 577  :         }
; 578  : 
; 579  :         if (_Second_char != L'.') {

	cmp	ax, 46					; 0000002eH
	jne	SHORT $LN121@Advance_an

; 2510 :             while (_Is_dot_or_dotdot(_Data)) {

	cmp	WORD PTR _Data$[rsp+48], si
	jne	SHORT $LN121@Advance_an
$LN308@Advance_an:

; 2511 :                 const auto _Error = __std_fs_directory_iterator_advance(_Dir_handle, &_Data);

	lea	rdx, QWORD PTR _Data$[rsp]
	mov	rcx, rdi
	call	__std_fs_directory_iterator_advance
	mov	ebx, eax

; 2512 :                 if (_Error != __std_win_error::_Success) {

	test	eax, eax
	je	SHORT $LL120@Advance_an

; 2513 :                     return _Error;

	jmp	SHORT $LN116@Advance_an
$LN121@Advance_an:

; 2514 :                 }
; 2515 :             }
; 2516 : 
; 2517 :             return __std_win_error::_Success;

	mov	ebx, esi
$LN116@Advance_an:

; 2799 :                 _Error = _Impl._Advance_and_skip_dots(_Data);

	lea	r13, QWORD PTR [rbp+72]
	lea	rsi, QWORD PTR [rbp+32]
$LN7@Advance_an:

; 2800 :             }
; 2801 : 
; 2802 :             _Impl._Recursion_pending = true;

	mov	BYTE PTR [rbp+100], 1

; 2803 :             for (;; _Error = _Impl._Advance_and_skip_dots(_Data)) {
; 2804 :                 if (_Error == __std_win_error::_Success) {

	test	ebx, ebx
	je	$LN288@Advance_an
	xor	edi, edi
$LL4@Advance_an:

; 2807 :                 }
; 2808 : 
; 2809 :                 if (_Error != __std_win_error::_No_more_files) {

	cmp	ebx, 18
	jne	$LN3@Advance_an
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1864 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rcx, QWORD PTR [r13+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2814 :                 if (_Impl._Stack.empty()) { // nothing to pop, clear the error, reset and return

	cmp	QWORD PTR [r13], rcx
	je	$LN290@Advance_an
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rcx-8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rcx-8], r14

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [rbp+64]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rbp+64], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 596  :             __std_fs_directory_iterator_close(_Tmp);

	call	__std_fs_directory_iterator_close
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1711 :         _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));

	mov	rcx, QWORD PTR [rbp+80]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 605  :             __std_fs_directory_iterator_close(_Handle);

	mov	rcx, QWORD PTR [rcx-8]
	call	__std_fs_directory_iterator_close
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1713 :         --_Mylast;

	add	QWORD PTR [rbp+80], -8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	r11, rsi

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rdi, QWORD PTR [rsi+24]

; 2227 :         if (_Large_string_engaged()) {

	cmp	rdi, 8
	jb	SHORT $LN171@Advance_an

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r11, QWORD PTR [rsi]
$LN171@Advance_an:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 861  :             const auto _Last          = _First + _Text.size();

	mov	rbx, QWORD PTR [rsi+16]
	lea	rdx, QWORD PTR [r11+rbx*2]

; 862  :             const auto _Root_name_end = _Find_root_name_end(_First, _Last);

	mov	rcx, r11
	call	?_Find_root_name_end@filesystem@std@@YAPEB_WQEB_W0@Z ; std::filesystem::_Find_root_name_end
	mov	r10, rax

; 863  :             const auto _Root_dir_end =

	cmp	rax, rdx
	je	SHORT $LN166@Advance_an
	movzx	eax, WORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 384  :         return _Ch == L'\\' || _Ch == L'/';

	cmp	ax, 92					; 0000005cH
	je	SHORT $LN319@Advance_an
	cmp	ax, 47					; 0000002fH
	jne	SHORT $LN166@Advance_an
$LN319@Advance_an:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 863  :             const auto _Root_dir_end =

	add	r10, 2
$LN166@Advance_an:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 6315 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rdx, r10
	je	SHORT $LN320@Advance_an
$LL196@Advance_an:

; 1524 :         return *--_Tmp;

	lea	rax, QWORD PTR [rdx-2]

; 6316 :         if (_Pred(*_UFirst)) {

	movzx	ecx, WORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 384  :         return _Ch == L'\\' || _Ch == L'/';

	cmp	cx, 92					; 0000005cH
	je	SHORT $LN285@Advance_an
	cmp	cx, 47					; 0000002fH
	je	SHORT $LN285@Advance_an
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 1544 :         --current;

	mov	rdx, rax

; 6315 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rax, r10
	jne	SHORT $LL196@Advance_an
$LN285@Advance_an:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 370  :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rdx, r10
	je	SHORT $LN320@Advance_an
$LL218@Advance_an:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 1524 :         return *--_Tmp;

	lea	rax, QWORD PTR [rdx-2]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 371  :         if (!_Pred(*_UFirst)) {

	movzx	ecx, WORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 384  :         return _Ch == L'\\' || _Ch == L'/';

	cmp	cx, 92					; 0000005cH
	je	SHORT $LN317@Advance_an
	cmp	cx, 47					; 0000002fH
	jne	SHORT $LN320@Advance_an
$LN317@Advance_an:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 1544 :         --current;

	mov	rdx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 370  :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rax, r10
	jne	SHORT $LL218@Advance_an
$LN320@Advance_an:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 1758 :     return _Right._Get_current() - _Left._Get_current();

	sub	rdx, r11
	sar	rdx, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2260 :         if (_Mysize < _Off) {

	cmp	rbx, rdx
	jb	$LN291@Advance_an

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	rax, rsi

; 2227 :         if (_Large_string_engaged()) {

	cmp	rdi, 8
	jb	SHORT $LN316@Advance_an

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rsi]
$LN316@Advance_an:

; 4815 :         _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _New_size], _Elem());

	mov	QWORD PTR [rsi+16], rdx
	xor	edi, edi
	mov	WORD PTR [rax+rdx*2], di
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2749 :             const auto _Error = __std_fs_directory_iterator_advance(_Dir._Handle, &_Data);

	lea	rdx, QWORD PTR _Data$[rsp]
	mov	rcx, QWORD PTR [rbp+64]
	call	__std_fs_directory_iterator_advance
	mov	ebx, eax

; 2750 :             if (_Error != __std_win_error::_Success) {

	test	eax, eax
	jne	$LL4@Advance_an

; 2751 :                 return _Error;
; 2752 :             }
; 2753 : 
; 2754 :             return _Skip_dots(_Dir._Handle, _Data);

	mov	rdi, QWORD PTR [rbp+64]
	npad	3
$LL133@Advance_an:

; 570  :         if (_Data._File_name[0] != L'.') {

	cmp	WORD PTR _Data$[rsp+44], 46		; 0000002eH
	jne	SHORT $LN134@Advance_an

; 571  :             return false;
; 572  :         }
; 573  : 
; 574  :         const auto _Second_char = _Data._File_name[1];
; 575  :         if (_Second_char == 0) {

	movzx	eax, WORD PTR _Data$[rsp+46]
	test	ax, ax
	je	SHORT $LN309@Advance_an

; 576  :             return true;
; 577  :         }
; 578  : 
; 579  :         if (_Second_char != L'.') {

	cmp	ax, 46					; 0000002eH
	jne	SHORT $LN134@Advance_an

; 2510 :             while (_Is_dot_or_dotdot(_Data)) {

	cmp	WORD PTR _Data$[rsp+48], 0
	jne	SHORT $LN134@Advance_an
$LN309@Advance_an:

; 2511 :                 const auto _Error = __std_fs_directory_iterator_advance(_Dir_handle, &_Data);

	lea	rdx, QWORD PTR _Data$[rsp]
	mov	rcx, rdi
	call	__std_fs_directory_iterator_advance
	mov	ebx, eax

; 2512 :                 if (_Error != __std_win_error::_Success) {

	test	eax, eax
	je	SHORT $LL133@Advance_an

; 2513 :                     return _Error;

	xor	edi, edi
	jmp	SHORT $LN132@Advance_an
$LN134@Advance_an:

; 2514 :                 }
; 2515 :             }
; 2516 : 
; 2517 :             return __std_win_error::_Success;

	xor	edi, edi
	mov	ebx, edi
$LN132@Advance_an:

; 2803 :             for (;; _Error = _Impl._Advance_and_skip_dots(_Data)) {
; 2804 :                 if (_Error == __std_win_error::_Success) {

	test	ebx, ebx
	jne	$LL4@Advance_an
$LN288@Advance_an:

; 2805 :                     _Impl._Refresh(_Data);

	lea	rdx, QWORD PTR _Data$[rsp]
	mov	rcx, rbp
	call	?_Refresh@_Dir_enum_impl@filesystem@std@@QEAAXAEBU__std_fs_find_data@@@Z ; std::filesystem::_Dir_enum_impl::_Refresh

; 2806 :                     return __std_win_error::_Success;

	xor	eax, eax
$LN1@Advance_an:

; 2826 :         }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+688]
	mov	rbx, QWORD PTR [r11+56]
	mov	rbp, QWORD PTR [r11+64]
	mov	rsi, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
$LN290@Advance_an:

; 2815 :                     _Error = __std_win_error::_Success;

	mov	ebx, edi
$LN3@Advance_an:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [r12], rdi

; 100  :     _Left    = _STD move(_Right);

	mov	rdi, QWORD PTR [r12+8]

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [r12+8], 0
	test	rdi, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 1402 :         if (_Rep) {

	je	SHORT $LN276@Advance_an

; 1177 :         if (_MT_DECR(_Uses) == 0) {

	mov	eax, r14d
	lock xadd DWORD PTR [rdi+8], eax
	cmp	eax, 1
	jne	SHORT $LN276@Advance_an

; 1178 :             _Destroy();

	mov	rax, QWORD PTR [rdi]
	mov	rcx, rdi
	call	QWORD PTR [rax]

; 1184 :         if (_MT_DECR(_Weaks) == 0) {

	lock xadd DWORD PTR [rdi+12], r14d
	cmp	r14d, 1
	jne	SHORT $LN276@Advance_an

; 1185 :             _Delete_this();

	mov	rax, QWORD PTR [rdi]
	mov	rcx, rdi
	call	QWORD PTR [rax+8]
$LN276@Advance_an:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2825 :             return _Error;

	mov	eax, ebx
	jmp	SHORT $LN1@Advance_an
$LN291@Advance_an:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2261 :             _Xran();

	call	?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Xran
	npad	1
$LN323@Advance_an:
?_Advance_and_reset_if_no_more_files@_Recursive_dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@3@@Z ENDP ; std::filesystem::_Recursive_dir_enum_impl::_Advance_and_reset_if_no_more_files
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ??0_Recursive_dir_enum_impl@filesystem@std@@QEAA@$$QEAU_Creator@_Dir_enum_impl@12@W4directory_options@12@@Z
_TEXT	SEGMENT
this$ = 48
_Create_data$ = 56
_Options_arg$ = 64
??0_Recursive_dir_enum_impl@filesystem@std@@QEAA@$$QEAU_Creator@_Dir_enum_impl@12@W4directory_options@12@@Z PROC ; std::filesystem::_Recursive_dir_enum_impl::_Recursive_dir_enum_impl, COMDAT

; 2828 :         _Recursive_dir_enum_impl(_Dir_enum_impl::_Creator&& _Create_data, const directory_options _Options_arg)

$LN13:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	ebx, r8d
	mov	rdi, rcx

; 2829 :             : _Dir_enum_impl(_STD move(_Create_data)), _Options(_Options_arg) {}

	call	??0_Dir_enum_impl@filesystem@std@@QEAA@$$QEAU_Creator@012@W4directory_options@12@@Z ; std::filesystem::_Dir_enum_impl::_Dir_enum_impl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rdi+72], rax
	mov	QWORD PTR [rdi+80], rax
	mov	QWORD PTR [rdi+88], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2829 :             : _Dir_enum_impl(_STD move(_Create_data)), _Options(_Options_arg) {}

	mov	rax, rdi
	mov	DWORD PTR [rdi+96], ebx
	mov	rbx, QWORD PTR [rsp+48]
	mov	BYTE PTR [rdi+100], 1
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0_Recursive_dir_enum_impl@filesystem@std@@QEAA@$$QEAU_Creator@_Dir_enum_impl@12@W4directory_options@12@@Z ENDP ; std::filesystem::_Recursive_dir_enum_impl::_Recursive_dir_enum_impl
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??1_Dir_enum_impl@filesystem@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1_Dir_enum_impl@filesystem@std@@QEAA@XZ PROC		; std::filesystem::_Dir_enum_impl::~_Dir_enum_impl, COMDAT
$LN16:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 605  :             __std_fs_directory_iterator_close(_Handle);

	mov	rcx, QWORD PTR [rcx+64]
	call	__std_fs_directory_iterator_close

; 638  :         ~path()                          = default;

	lea	rcx, QWORD PTR [rbx+32]
	add	rsp, 32					; 00000020H
	pop	rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	jmp	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
??1_Dir_enum_impl@filesystem@std@@QEAA@XZ ENDP		; std::filesystem::_Dir_enum_impl::~_Dir_enum_impl
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ??0recursive_directory_iterator@filesystem@std@@QEAA@AEBVpath@12@@Z
_TEXT	SEGMENT
$T4 = 32
$T3 = 32
this$GSCopy$ = 40
_Create_data$5 = 48
__$ArrayPad$ = 688
this$ = 752
_Path$ = 760
??0recursive_directory_iterator@filesystem@std@@QEAA@AEBVpath@12@@Z PROC ; std::filesystem::recursive_directory_iterator::recursive_directory_iterator, COMDAT

; 2843 :         explicit recursive_directory_iterator(const path& _Path) {

$LN125:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rbp
	push	rdi
	push	r12
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-448]
	sub	rsp, 704				; 000002c0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	r15, rdx
	mov	r14, rcx
	mov	QWORD PTR this$GSCopy$[rsp], rcx
	xor	r12d, r12d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 1470 :     element_type* _Ptr{nullptr};

	mov	QWORD PTR [rcx], r12

; 1471 :     _Ref_count_base* _Rep{nullptr};

	mov	QWORD PTR [rcx+8], r12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2553 :             _Creator(const path& _Path_arg, const directory_options _Options) : _Path(_Path_arg) {

	lea	rcx, QWORD PTR _Create_data$5[rsp]
	call	??0path@filesystem@std@@QEAA@AEBV012@@Z	; std::filesystem::path::path
	npad	1

; 587  :         __std_fs_dir_handle _Handle = __std_fs_dir_handle::_Invalid;

	mov	rsi, -1
	mov	QWORD PTR _Create_data$5[rsp+32], rsi

; 2554 :                 const auto _Error = _Open_dir(_Path, _Options, _Dir, _Find_data);

	lea	r9, QWORD PTR _Create_data$5[rsp+40]
	lea	r8, QWORD PTR _Create_data$5[rsp+32]
	xor	edx, edx
	lea	rcx, QWORD PTR _Create_data$5[rsp]
	call	?_Open_dir@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAVpath@23@W4directory_options@23@AEAU_Find_file_handle@23@AEAU__std_fs_find_data@@@Z ; std::filesystem::_Dir_enum_impl::_Open_dir
	mov	edx, eax

; 2555 :                 if (_Error == __std_win_error::_Success) {

	mov	DWORD PTR _Create_data$5[rbp+380], r12d
	test	eax, eax
	jne	SHORT $LN15@recursive_

; 2556 :                     _Status = {true, __std_win_error::_Success};

	mov	cl, 1
	jmp	SHORT $LN121@recursive_
$LN15@recursive_:

; 2557 :                 } else if (_Error == __std_win_error::_No_more_files) {

	xor	cl, cl
	cmp	edx, 18
	je	SHORT $LN121@recursive_

; 2558 :                     _Status = {false, __std_win_error::_Success};
; 2559 :                 } else {
; 2560 :                     _Status = {false, _Error};

	mov	DWORD PTR _Create_data$5[rbp+380], edx
$LN121@recursive_:

; 2561 :                 }
; 2562 :             }

	movzx	eax, WORD PTR $T3[rsp+1]
	mov	WORD PTR _Create_data$5[rbp+377], ax
	movzx	eax, BYTE PTR $T3[rsp+3]
	mov	BYTE PTR _Create_data$5[rbp+376], cl
	mov	BYTE PTR _Create_data$5[rbp+379], al

; 2581 :             if (_Create_data._Status._Should_create_impl) {

	test	cl, cl
	je	$LN119@recursive_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 2779 :     const auto _Rx = new _Ref_count_obj2<_Ty>(_STD forward<_Types>(_Args)...);

	mov	ecx, 120				; 00000078H
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax
	mov	QWORD PTR $T4[rsp], rax
	xorps	xmm0, xmm0

; 2096 :     explicit _Ref_count_obj2(_Types&&... _Args) : _Ref_count_base() {

	movups	XMMWORD PTR [rax], xmm0

; 1137 :     _Atomic_counter_t _Uses  = 1;

	mov	DWORD PTR [rax+8], 1

; 1138 :     _Atomic_counter_t _Weaks = 1;

	mov	DWORD PTR [rax+12], 1

; 2096 :     explicit _Ref_count_obj2(_Types&&... _Args) : _Ref_count_base() {

	lea	rax, OFFSET FLAT:??_7?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@6B@
	mov	QWORD PTR [rdi], rax

; 2097 : #if _HAS_CXX20
; 2098 :         if constexpr (sizeof...(_Types) == 1 && (is_same_v<_For_overwrite_tag, remove_cvref_t<_Types>> && ...)) {
; 2099 :             _STD _Default_construct_in_place(_Storage._Value);
; 2100 :             ((void) _Args, ...);
; 2101 :         } else
; 2102 : #endif // _HAS_CXX20
; 2103 :         {
; 2104 :             _STD _Construct_in_place(_Storage._Value, _STD forward<_Types>(_Args)...);

	lea	rbx, QWORD PTR [rdi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2829 :             : _Dir_enum_impl(_STD move(_Create_data)), _Options(_Options_arg) {}

	lea	rdx, QWORD PTR _Create_data$5[rsp]
	mov	rcx, rbx
	call	??0_Dir_enum_impl@filesystem@std@@QEAA@$$QEAU_Creator@012@W4directory_options@12@@Z ; std::filesystem::_Dir_enum_impl::_Dir_enum_impl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rbx+72], r12
	mov	QWORD PTR [rbx+80], r12
	mov	QWORD PTR [rbx+88], r12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2829 :             : _Dir_enum_impl(_STD move(_Create_data)), _Options(_Options_arg) {}

	mov	DWORD PTR [rbx+96], r12d

; 2585 :         }
; 2586 : 
; 2587 :         directory_entry _Entry;
; 2588 :         _Find_file_handle _Dir;
; 2589 :     };
; 2590 : 
; 2591 :     _EXPORT_STD class directory_iterator;
; 2592 :     _EXPORT_STD class recursive_directory_iterator;
; 2593 : 
; 2594 :     struct _Directory_entry_proxy {
; 2595 :         _NODISCARD directory_entry operator*() && noexcept {
; 2596 :             return _STD move(_Entry);
; 2597 :         }
; 2598 : 
; 2599 :     private:
; 2600 :         friend directory_iterator;
; 2601 :         friend recursive_directory_iterator;
; 2602 : 
; 2603 :         explicit _Directory_entry_proxy(const directory_entry& _Entry_arg) : _Entry(_Entry_arg) {}
; 2604 : 
; 2605 :         directory_entry _Entry;
; 2606 :     };
; 2607 : 
; 2608 :     _EXPORT_STD class directory_iterator {
; 2609 :     public:
; 2610 :         using iterator_category = input_iterator_tag;
; 2611 :         using value_type        = directory_entry;
; 2612 :         using difference_type   = ptrdiff_t;
; 2613 :         using pointer           = const directory_entry*;
; 2614 :         using reference         = const directory_entry&;
; 2615 : 
; 2616 :         // [fs.dir.itr.members], member functions
; 2617 :         directory_iterator() noexcept = default;
; 2618 :         explicit directory_iterator(const path& _Path) {
; 2619 :             const auto _Error = _Dir_enum_impl::_Initialize_dir_enum(_Impl, _Path);
; 2620 :             if (_Error != __std_win_error::_Success) {
; 2621 :                 _Throw_fs_error("directory_iterator::directory_iterator", _Error, _Path);
; 2622 :             }
; 2623 :         }
; 2624 : 
; 2625 :         directory_iterator(const path& _Path, const directory_options _Options) {
; 2626 :             const auto _Error = _Dir_enum_impl::_Initialize_dir_enum(_Impl, _Path, _Options);
; 2627 :             if (_Error != __std_win_error::_Success) {
; 2628 :                 _Throw_fs_error("directory_iterator::directory_iterator", _Error, _Path);
; 2629 :             }
; 2630 :         }
; 2631 : 
; 2632 :         directory_iterator(const path& _Path, error_code& _Ec) {
; 2633 :             _Ec = _Make_ec(_Dir_enum_impl::_Initialize_dir_enum(_Impl, _Path));
; 2634 :         }
; 2635 : 
; 2636 :         directory_iterator(const path& _Path, const directory_options _Options, error_code& _Ec) {
; 2637 :             _Ec = _Make_ec(_Dir_enum_impl::_Initialize_dir_enum(_Impl, _Path, _Options));
; 2638 :         }
; 2639 : 
; 2640 :         directory_iterator(const directory_iterator&) noexcept = default; // strengthened
; 2641 :         directory_iterator(directory_iterator&&) noexcept      = default;
; 2642 :         ~directory_iterator() noexcept                         = default;
; 2643 : 
; 2644 :         directory_iterator& operator=(const directory_iterator&) noexcept = default; // strengthened
; 2645 :         directory_iterator& operator=(directory_iterator&&) noexcept      = default;
; 2646 : 
; 2647 :         _NODISCARD const directory_entry& operator*() const noexcept /* strengthened */ {
; 2648 :             return _Impl->_Entry;
; 2649 :         }
; 2650 : 
; 2651 :         _NODISCARD const directory_entry* operator->() const noexcept /* strengthened */ {
; 2652 :             return &**this;
; 2653 :         }
; 2654 : 
; 2655 :         directory_iterator& operator++() {
; 2656 :             const auto _Error = _Dir_enum_impl::_Advance_and_reset_if_no_more_files(_Impl);
; 2657 :             if (_Error != __std_win_error::_Success) {
; 2658 :                 _Throw_fs_error("directory_iterator::operator++", _Error);
; 2659 :             }
; 2660 : 
; 2661 :             return *this;
; 2662 :         }
; 2663 : 
; 2664 :         directory_iterator& increment(error_code& _Ec) {
; 2665 :             _Ec = _Make_ec(_Dir_enum_impl::_Advance_and_reset_if_no_more_files(_Impl));
; 2666 :             return *this;
; 2667 :         }
; 2668 : 
; 2669 :         // other members as required by [input.iterators]:
; 2670 :         _NODISCARD bool operator==(const directory_iterator& _Rhs) const noexcept /* strengthened */ {
; 2671 :             return _Impl == _Rhs._Impl;
; 2672 :         }
; 2673 : 
; 2674 : #if !_HAS_CXX20
; 2675 :         _NODISCARD bool operator!=(const directory_iterator& _Rhs) const noexcept /* strengthened */ {
; 2676 :             return _Impl != _Rhs._Impl;
; 2677 :         }
; 2678 : #endif // !_HAS_CXX20
; 2679 : 
; 2680 : #ifdef __cpp_lib_concepts
; 2681 :         _NODISCARD bool operator==(default_sentinel_t) const noexcept {
; 2682 :             return !_Impl;
; 2683 :         }
; 2684 : #endif // __cpp_lib_concepts
; 2685 : 
; 2686 :         _Directory_entry_proxy operator++(int) {
; 2687 :             _Directory_entry_proxy _Proxy(**this);
; 2688 :             ++*this;
; 2689 :             return _Proxy;
; 2690 :         }
; 2691 : 
; 2692 :         _NODISCARD bool _At_end() const noexcept {
; 2693 :             return !_Impl;
; 2694 :         }
; 2695 : 
; 2696 :     private:
; 2697 :         shared_ptr<_Dir_enum_impl> _Impl;
; 2698 :     };
; 2699 : 
; 2700 :     _EXPORT_STD _NODISCARD inline directory_iterator begin(directory_iterator _Iter) noexcept {
; 2701 :         return _Iter;
; 2702 :     }
; 2703 : 
; 2704 :     _EXPORT_STD _NODISCARD inline directory_iterator end(directory_iterator) noexcept {
; 2705 :         return {};
; 2706 :     }
; 2707 : 
; 2708 :     struct _Should_recurse_result {
; 2709 :         bool _Should_recurse;
; 2710 :         __std_win_error _Error;
; 2711 :     };
; 2712 : 
; 2713 :     struct _Recursive_dir_enum_impl : _Dir_enum_impl {
; 2714 :         vector<_Find_file_handle> _Stack;
; 2715 :         directory_options _Options = {};
; 2716 :         bool _Recursion_pending    = true;

	mov	BYTE PTR [rbx+100], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [r14], rbx

; 100  :     _Left    = _STD move(_Right);

	mov	rbx, QWORD PTR [r14+8]

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [r14+8], rdi
	test	rbx, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 1402 :         if (_Rep) {

	je	SHORT $LN119@recursive_

; 1177 :         if (_MT_DECR(_Uses) == 0) {

	mov	eax, esi
	lock xadd DWORD PTR [rbx+8], eax
	cmp	eax, 1
	jne	SHORT $LN119@recursive_

; 1178 :             _Destroy();

	mov	rax, QWORD PTR [rbx]
	mov	rcx, rbx
	call	QWORD PTR [rax]

; 1184 :         if (_MT_DECR(_Weaks) == 0) {

	lock xadd DWORD PTR [rbx+12], esi
	cmp	esi, 1
	jne	SHORT $LN119@recursive_

; 1185 :             _Delete_this();

	mov	rax, QWORD PTR [rbx]
	mov	rcx, rbx
	call	QWORD PTR [rax+8]
$LN119@recursive_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2584 :             return _Create_data._Status._Error;

	mov	ebx, DWORD PTR _Create_data$5[rbp+380]

; 605  :             __std_fs_directory_iterator_close(_Handle);

	mov	rcx, QWORD PTR _Create_data$5[rsp+32]
	call	__std_fs_directory_iterator_close
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR _Create_data$5[rsp]
	call	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2845 :             if (_Error != __std_win_error::_Success) {

	test	ebx, ebx
	jne	SHORT $LN123@recursive_

; 2847 :             }
; 2848 :         }

	mov	rax, r14
	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+704]
	mov	rbx, QWORD PTR [r11+64]
	mov	rsi, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rbp
	ret	0
$LN123@recursive_:

; 2846 :                 _Throw_fs_error("recursive_directory_iterator::recursive_directory_iterator", _Error, _Path);

	mov	r8, r15
	mov	edx, ebx
	lea	rcx, OFFSET FLAT:??_C@_0DL@FMJPNKHC@recursive_directory_iterator?3?3r@
	call	?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@AEBVpath@12@@Z ; std::filesystem::_Throw_fs_error
	int	3
$LN120@recursive_:
??0recursive_directory_iterator@filesystem@std@@QEAA@AEBVpath@12@@Z ENDP ; std::filesystem::recursive_directory_iterator::recursive_directory_iterator
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 32
$T3 = 32
this$GSCopy$ = 40
_Create_data$5 = 48
__$ArrayPad$ = 688
this$ = 752
_Path$ = 760
?dtor$0@?0???0recursive_directory_iterator@filesystem@std@@QEAA@AEBVpath@12@@Z@4HA PROC ; `std::filesystem::recursive_directory_iterator::recursive_directory_iterator'::`1'::dtor$0
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	jmp	??1?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAA@XZ ; std::shared_ptr<std::filesystem::_Recursive_dir_enum_impl>::~shared_ptr<std::filesystem::_Recursive_dir_enum_impl>
?dtor$0@?0???0recursive_directory_iterator@filesystem@std@@QEAA@AEBVpath@12@@Z@4HA ENDP ; `std::filesystem::recursive_directory_iterator::recursive_directory_iterator'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 32
$T3 = 32
this$GSCopy$ = 40
_Create_data$5 = 48
__$ArrayPad$ = 688
this$ = 752
_Path$ = 760
?dtor$3@?0???0recursive_directory_iterator@filesystem@std@@QEAA@AEBVpath@12@@Z@4HA PROC ; `std::filesystem::recursive_directory_iterator::recursive_directory_iterator'::`1'::dtor$3
	lea	rcx, QWORD PTR _Create_data$5[rdx]
	jmp	??1path@filesystem@std@@QEAA@XZ		; std::filesystem::path::~path
?dtor$3@?0???0recursive_directory_iterator@filesystem@std@@QEAA@AEBVpath@12@@Z@4HA ENDP ; `std::filesystem::recursive_directory_iterator::recursive_directory_iterator'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 32
$T3 = 32
this$GSCopy$ = 40
_Create_data$5 = 48
__$ArrayPad$ = 688
this$ = 752
_Path$ = 760
?dtor$4@?0???0recursive_directory_iterator@filesystem@std@@QEAA@AEBVpath@12@@Z@4HA PROC ; `std::filesystem::recursive_directory_iterator::recursive_directory_iterator'::`1'::dtor$4
	lea	rcx, QWORD PTR _Create_data$5[rdx]
	add	rcx, 32					; 00000020H
	jmp	??1_Find_file_handle@filesystem@std@@QEAA@XZ ; std::filesystem::_Find_file_handle::~_Find_file_handle
?dtor$4@?0???0recursive_directory_iterator@filesystem@std@@QEAA@AEBVpath@12@@Z@4HA ENDP ; `std::filesystem::recursive_directory_iterator::recursive_directory_iterator'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 32
$T3 = 32
this$GSCopy$ = 40
_Create_data$5 = 48
__$ArrayPad$ = 688
this$ = 752
_Path$ = 760
?dtor$1@?0???0recursive_directory_iterator@filesystem@std@@QEAA@AEBVpath@12@@Z@4HA PROC ; `std::filesystem::recursive_directory_iterator::recursive_directory_iterator'::`1'::dtor$1
	lea	rcx, QWORD PTR _Create_data$5[rdx]
	jmp	??1_Creator@_Dir_enum_impl@filesystem@std@@QEAA@XZ
?dtor$1@?0???0recursive_directory_iterator@filesystem@std@@QEAA@AEBVpath@12@@Z@4HA ENDP ; `std::filesystem::recursive_directory_iterator::recursive_directory_iterator'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 32
$T3 = 32
this$GSCopy$ = 40
_Create_data$5 = 48
__$ArrayPad$ = 688
this$ = 752
_Path$ = 760
?dtor$5@?0???0recursive_directory_iterator@filesystem@std@@QEAA@AEBVpath@12@@Z@4HA PROC ; `std::filesystem::recursive_directory_iterator::recursive_directory_iterator'::`1'::dtor$5
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 120				; 00000078H
	mov	rcx, QWORD PTR $T4[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$5@?0???0recursive_directory_iterator@filesystem@std@@QEAA@AEBVpath@12@@Z@4HA ENDP ; `std::filesystem::recursive_directory_iterator::recursive_directory_iterator'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ??Drecursive_directory_iterator@filesystem@std@@QEBAAEBVdirectory_entry@12@XZ
_TEXT	SEGMENT
this$ = 8
??Drecursive_directory_iterator@filesystem@std@@QEBAAEBVdirectory_entry@12@XZ PROC ; std::filesystem::recursive_directory_iterator::operator*, COMDAT

; 2886 :             return _Impl->_Entry;

	mov	rax, QWORD PTR [rcx]

; 2887 :         }

	ret	0
??Drecursive_directory_iterator@filesystem@std@@QEBAAEBVdirectory_entry@12@XZ ENDP ; std::filesystem::recursive_directory_iterator::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ??Erecursive_directory_iterator@filesystem@std@@QEAAAEAV012@XZ
_TEXT	SEGMENT
this$ = 48
??Erecursive_directory_iterator@filesystem@std@@QEAAAEAV012@XZ PROC ; std::filesystem::recursive_directory_iterator::operator++, COMDAT

; 2897 :         recursive_directory_iterator& operator++() {

$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 2898 :             const auto _Error = _Recursive_dir_enum_impl::_Advance_and_reset_if_no_more_files(_Impl);

	call	?_Advance_and_reset_if_no_more_files@_Recursive_dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@3@@Z ; std::filesystem::_Recursive_dir_enum_impl::_Advance_and_reset_if_no_more_files

; 2899 :             if (_Error != __std_win_error::_Success) {

	test	eax, eax
	jne	SHORT $LN7@operator

; 2901 :             }
; 2902 :             return *this;

	mov	rax, rbx

; 2903 :         }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN7@operator:

; 2900 :                 _Throw_fs_error("recursive_directory_iterator::operator++", _Error);

	mov	edx, eax
	lea	rcx, OFFSET FLAT:??_C@_0CJ@OMKENMFB@recursive_directory_iterator?3?3o@
	call	?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@@Z ; std::filesystem::_Throw_fs_error
	int	3
$LN5@operator:
??Erecursive_directory_iterator@filesystem@std@@QEAAAEAV012@XZ ENDP ; std::filesystem::recursive_directory_iterator::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ??8recursive_directory_iterator@filesystem@std@@QEBA_NAEBV012@@Z
_TEXT	SEGMENT
this$ = 8
_Rhs$ = 16
??8recursive_directory_iterator@filesystem@std@@QEBA_NAEBV012@@Z PROC ; std::filesystem::recursive_directory_iterator::operator==, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 1880 :     return _Left.get() == _Right.get();

	mov	rax, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rax
	sete	al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2928 :         }

	ret	0
??8recursive_directory_iterator@filesystem@std@@QEBA_NAEBV012@@Z ENDP ; std::filesystem::recursive_directory_iterator::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??0?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAA@XZ PROC ; std::shared_ptr<std::filesystem::_Recursive_dir_enum_impl>::shared_ptr<std::filesystem::_Recursive_dir_enum_impl>, COMDAT

; 1470 :     element_type* _Ptr{nullptr};

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 1471 :     _Ref_count_base* _Rep{nullptr};

	mov	QWORD PTR [rcx+8], rax

; 1573 :     constexpr shared_ptr() noexcept = default;

	mov	rax, rcx
	ret	0
??0?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAA@XZ ENDP ; std::shared_ptr<std::filesystem::_Recursive_dir_enum_impl>::shared_ptr<std::filesystem::_Recursive_dir_enum_impl>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??0?$_Ptr_base@U_Recursive_dir_enum_impl@filesystem@std@@@std@@IEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Ptr_base@U_Recursive_dir_enum_impl@filesystem@std@@@std@@IEAA@XZ PROC ; std::_Ptr_base<std::filesystem::_Recursive_dir_enum_impl>::_Ptr_base<std::filesystem::_Recursive_dir_enum_impl>, COMDAT

; 1339 : 
; 1340 :     ~_Ptr_base() = default;
; 1341 : 
; 1342 :     template <class _Ty2>
; 1343 :     void _Move_construct_from(_Ptr_base<_Ty2>&& _Right) noexcept {
; 1344 :         // implement shared_ptr's (converting) move ctor and weak_ptr's move ctor
; 1345 :         _Ptr = _Right._Ptr;
; 1346 :         _Rep = _Right._Rep;
; 1347 : 
; 1348 :         _Right._Ptr = nullptr;
; 1349 :         _Right._Rep = nullptr;
; 1350 :     }
; 1351 : 
; 1352 :     template <class _Ty2>
; 1353 :     void _Copy_construct_from(const shared_ptr<_Ty2>& _Other) noexcept {
; 1354 :         // implement shared_ptr's (converting) copy ctor
; 1355 :         _Other._Incref();
; 1356 : 
; 1357 :         _Ptr = _Other._Ptr;
; 1358 :         _Rep = _Other._Rep;
; 1359 :     }
; 1360 : 
; 1361 :     template <class _Ty2>
; 1362 :     void _Alias_construct_from(const shared_ptr<_Ty2>& _Other, element_type* _Px) noexcept {
; 1363 :         // implement shared_ptr's aliasing ctor
; 1364 :         _Other._Incref();
; 1365 : 
; 1366 :         _Ptr = _Px;
; 1367 :         _Rep = _Other._Rep;
; 1368 :     }
; 1369 : 
; 1370 :     template <class _Ty2>
; 1371 :     void _Alias_move_construct_from(shared_ptr<_Ty2>&& _Other, element_type* _Px) noexcept {
; 1372 :         // implement shared_ptr's aliasing move ctor
; 1373 :         _Ptr = _Px;
; 1374 :         _Rep = _Other._Rep;
; 1375 : 
; 1376 :         _Other._Ptr = nullptr;
; 1377 :         _Other._Rep = nullptr;
; 1378 :     }
; 1379 : 
; 1380 :     template <class _Ty0>
; 1381 :     friend class weak_ptr; // specifically, weak_ptr::lock()
; 1382 : 
; 1383 :     template <class _Ty2>
; 1384 :     bool _Construct_from_weak(const weak_ptr<_Ty2>& _Other) noexcept {
; 1385 :         // implement shared_ptr's ctor from weak_ptr, and weak_ptr::lock()
; 1386 :         if (_Other._Rep && _Other._Rep->_Incref_nz()) {
; 1387 :             _Ptr = _Other._Ptr;
; 1388 :             _Rep = _Other._Rep;
; 1389 :             return true;
; 1390 :         }
; 1391 : 
; 1392 :         return false;
; 1393 :     }
; 1394 : 
; 1395 :     void _Incref() const noexcept {
; 1396 :         if (_Rep) {
; 1397 :             _Rep->_Incref();
; 1398 :         }
; 1399 :     }
; 1400 : 
; 1401 :     void _Decref() noexcept { // decrement reference count
; 1402 :         if (_Rep) {
; 1403 :             _Rep->_Decref();
; 1404 :         }
; 1405 :     }
; 1406 : 
; 1407 :     void _Swap(_Ptr_base& _Right) noexcept { // swap pointers
; 1408 :         _STD swap(_Ptr, _Right._Ptr);
; 1409 :         _STD swap(_Rep, _Right._Rep);
; 1410 :     }
; 1411 : 
; 1412 :     template <class _Ty2>
; 1413 :     void _Weakly_construct_from(const _Ptr_base<_Ty2>& _Other) noexcept { // implement weak_ptr's ctors
; 1414 :         if (_Other._Rep) {
; 1415 :             _Ptr = _Other._Ptr;
; 1416 :             _Rep = _Other._Rep;
; 1417 :             _Rep->_Incwref();
; 1418 :         } else {
; 1419 :             _STL_INTERNAL_CHECK(!_Ptr && !_Rep);
; 1420 :         }
; 1421 :     }
; 1422 : 
; 1423 :     template <class _Ty2>
; 1424 :     void _Weakly_convert_lvalue_avoiding_expired_conversions(const _Ptr_base<_Ty2>& _Other) noexcept {
; 1425 :         // implement weak_ptr's copy converting ctor
; 1426 :         if (_Other._Rep) {
; 1427 :             _Rep = _Other._Rep; // always share ownership
; 1428 :             _Rep->_Incwref();
; 1429 : 
; 1430 :             if (_Rep->_Incref_nz()) {
; 1431 :                 _Ptr = _Other._Ptr; // keep resource alive during conversion, handling virtual inheritance
; 1432 :                 _Rep->_Decref();
; 1433 :             } else {
; 1434 :                 _STL_INTERNAL_CHECK(!_Ptr);
; 1435 :             }
; 1436 :         } else {
; 1437 :             _STL_INTERNAL_CHECK(!_Ptr && !_Rep);
; 1438 :         }
; 1439 :     }
; 1440 : 
; 1441 :     template <class _Ty2>
; 1442 :     void _Weakly_convert_rvalue_avoiding_expired_conversions(_Ptr_base<_Ty2>&& _Other) noexcept {
; 1443 :         // implement weak_ptr's move converting ctor
; 1444 :         _Rep        = _Other._Rep; // always transfer ownership
; 1445 :         _Other._Rep = nullptr;
; 1446 : 
; 1447 :         if (_Rep && _Rep->_Incref_nz()) {
; 1448 :             _Ptr = _Other._Ptr; // keep resource alive during conversion, handling virtual inheritance
; 1449 :             _Rep->_Decref();
; 1450 :         } else {
; 1451 :             _STL_INTERNAL_CHECK(!_Ptr);
; 1452 :         }
; 1453 : 
; 1454 :         _Other._Ptr = nullptr;
; 1455 :     }
; 1456 : 
; 1457 :     void _Incwref() const noexcept {
; 1458 :         if (_Rep) {
; 1459 :             _Rep->_Incwref();
; 1460 :         }
; 1461 :     }
; 1462 : 
; 1463 :     void _Decwref() noexcept { // decrement weak reference count
; 1464 :         if (_Rep) {
; 1465 :             _Rep->_Decwref();
; 1466 :         }
; 1467 :     }
; 1468 : 
; 1469 : private:
; 1470 :     element_type* _Ptr{nullptr};

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 1471 :     _Ref_count_base* _Rep{nullptr};

	mov	QWORD PTR [rcx+8], rax
	mov	rax, rcx
	ret	0
??0?$_Ptr_base@U_Recursive_dir_enum_impl@filesystem@std@@@std@@IEAA@XZ ENDP ; std::_Ptr_base<std::filesystem::_Recursive_dir_enum_impl>::_Ptr_base<std::filesystem::_Recursive_dir_enum_impl>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ?begin@filesystem@std@@YA?AVrecursive_directory_iterator@12@V312@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Iter$ = 16
?begin@filesystem@std@@YA?AVrecursive_directory_iterator@12@V312@@Z PROC ; std::filesystem::begin, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 1470 :     element_type* _Ptr{nullptr};

	xor	r8d, r8d
	mov	QWORD PTR [rcx], r8

; 1471 :     _Ref_count_base* _Rep{nullptr};

	mov	QWORD PTR [rcx+8], r8

; 1345 :         _Ptr = _Right._Ptr;

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 1346 :         _Rep = _Right._Rep;

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rcx+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2953 :         return _Iter;

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 1348 :         _Right._Ptr = nullptr;

	mov	QWORD PTR [rdx], r8

; 1349 :         _Right._Rep = nullptr;

	mov	QWORD PTR [rdx+8], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2954 :     }

	ret	0
?begin@filesystem@std@@YA?AVrecursive_directory_iterator@12@V312@@Z ENDP ; std::filesystem::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ??1recursive_directory_iterator@filesystem@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1recursive_directory_iterator@filesystem@std@@QEAA@XZ PROC ; std::filesystem::recursive_directory_iterator::~recursive_directory_iterator, COMDAT

; 2867 :         ~recursive_directory_iterator() noexcept                                   = default;

$LN20:
	push	rbx
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 1402 :         if (_Rep) {

	mov	rbx, QWORD PTR [rcx+8]
	test	rbx, rbx
	je	SHORT $LN12@recursive_
	mov	QWORD PTR [rsp+48], rdi

; 1177 :         if (_MT_DECR(_Uses) == 0) {

	mov	edi, -1
	mov	eax, edi
	lock xadd DWORD PTR [rbx+8], eax
	cmp	eax, 1
	jne	SHORT $LN17@recursive_

; 1178 :             _Destroy();

	mov	rax, QWORD PTR [rbx]
	mov	rcx, rbx
	call	QWORD PTR [rax]

; 1184 :         if (_MT_DECR(_Weaks) == 0) {

	lock xadd DWORD PTR [rbx+12], edi
	cmp	edi, 1
	jne	SHORT $LN17@recursive_

; 1185 :             _Delete_this();

	mov	rax, QWORD PTR [rbx]
	mov	rcx, rbx
	call	QWORD PTR [rax+8]
$LN17@recursive_:
	mov	rdi, QWORD PTR [rsp+48]
$LN12@recursive_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2867 :         ~recursive_directory_iterator() noexcept                                   = default;

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1recursive_directory_iterator@filesystem@std@@QEAA@XZ ENDP ; std::filesystem::recursive_directory_iterator::~recursive_directory_iterator
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ??0recursive_directory_iterator@filesystem@std@@QEAA@$$QEAV012@@Z
_TEXT	SEGMENT
this$ = 8
__that$ = 16
??0recursive_directory_iterator@filesystem@std@@QEAA@$$QEAV012@@Z PROC ; std::filesystem::recursive_directory_iterator::recursive_directory_iterator, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 1470 :     element_type* _Ptr{nullptr};

	xor	r8d, r8d
	mov	QWORD PTR [rcx], r8

; 1471 :     _Ref_count_base* _Rep{nullptr};

	mov	QWORD PTR [rcx+8], r8

; 1345 :         _Ptr = _Right._Ptr;

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 1346 :         _Rep = _Right._Rep;

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rcx+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2866 :         recursive_directory_iterator(recursive_directory_iterator&&) noexcept      = default;

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 1348 :         _Right._Ptr = nullptr;

	mov	QWORD PTR [rdx], r8

; 1349 :         _Right._Rep = nullptr;

	mov	QWORD PTR [rdx+8], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2866 :         recursive_directory_iterator(recursive_directory_iterator&&) noexcept      = default;

	ret	0
??0recursive_directory_iterator@filesystem@std@@QEAA@$$QEAV012@@Z ENDP ; std::filesystem::recursive_directory_iterator::recursive_directory_iterator
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ?end@filesystem@std@@YA?AVrecursive_directory_iterator@12@V312@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 48
__formal$ = 56
?end@filesystem@std@@YA?AVrecursive_directory_iterator@12@V312@@Z PROC ; std::filesystem::end, COMDAT

; 2956 :     _EXPORT_STD _NODISCARD inline recursive_directory_iterator end(recursive_directory_iterator) noexcept {

$LN33:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 1470 :     element_type* _Ptr{nullptr};

	xor	eax, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2956 :     _EXPORT_STD _NODISCARD inline recursive_directory_iterator end(recursive_directory_iterator) noexcept {

	mov	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 1470 :     element_type* _Ptr{nullptr};

	mov	QWORD PTR [rcx], rax

; 1471 :     _Ref_count_base* _Rep{nullptr};

	mov	QWORD PTR [rcx+8], rax

; 1402 :         if (_Rep) {

	mov	rbx, QWORD PTR [rdx+8]
	test	rbx, rbx
	je	SHORT $LN26@end
	mov	QWORD PTR [rsp+48], rsi

; 1177 :         if (_MT_DECR(_Uses) == 0) {

	mov	esi, -1
	mov	eax, esi
	lock xadd DWORD PTR [rbx+8], eax
	cmp	eax, 1
	jne	SHORT $LN25@end

; 1178 :             _Destroy();

	mov	rax, QWORD PTR [rbx]
	mov	rcx, rbx
	call	QWORD PTR [rax]

; 1184 :         if (_MT_DECR(_Weaks) == 0) {

	lock xadd DWORD PTR [rbx+12], esi
	cmp	esi, 1
	jne	SHORT $LN25@end

; 1185 :             _Delete_this();

	mov	rax, QWORD PTR [rbx]
	mov	rcx, rbx
	call	QWORD PTR [rax+8]
$LN25@end:
	mov	rsi, QWORD PTR [rsp+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2957 :         return {};

	mov	rax, rdi

; 2958 :     }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN26@end:
	mov	rbx, QWORD PTR [rsp+56]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?end@filesystem@std@@YA?AVrecursive_directory_iterator@12@V312@@Z ENDP ; std::filesystem::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ??0recursive_directory_iterator@filesystem@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0recursive_directory_iterator@filesystem@std@@QEAA@XZ PROC ; std::filesystem::recursive_directory_iterator::recursive_directory_iterator, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 1470 :     element_type* _Ptr{nullptr};

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 1471 :     _Ref_count_base* _Rep{nullptr};

	mov	QWORD PTR [rcx+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2842 :         recursive_directory_iterator() noexcept = default;

	mov	rax, rcx
	ret	0
??0recursive_directory_iterator@filesystem@std@@QEAA@XZ ENDP ; std::filesystem::recursive_directory_iterator::recursive_directory_iterator
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
;	COMDAT ??__FNodeDefinitions@AINBNodeDefMgr@@YAXXZ
text$di	SEGMENT
??__FNodeDefinitions@AINBNodeDefMgr@@YAXXZ PROC		; AINBNodeDefMgr::`dynamic atexit destructor for 'NodeDefinitions'', COMDAT

; 11   : std::vector<AINBNodeDefMgr::NodeDef> AINBNodeDefMgr::NodeDefinitions;

	lea	rcx, OFFSET FLAT:??__FNodeDefinitions@AINBNodeDefMgr@@YAXXZ ; AINBNodeDefMgr::`dynamic atexit destructor for 'NodeDefinitions''
	jmp	atexit
??__FNodeDefinitions@AINBNodeDefMgr@@YAXXZ ENDP		; AINBNodeDefMgr::`dynamic atexit destructor for 'NodeDefinitions''
text$di	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??__FNodeDefinitions@AINBNodeDefMgr@@YAXXZ
text$yd	SEGMENT
??__FNodeDefinitions@AINBNodeDefMgr@@YAXXZ PROC		; AINBNodeDefMgr::`dynamic atexit destructor for 'NodeDefinitions'', COMDAT
	push	rbx
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR ?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A
	test	rbx, rbx
	je	$LN6@dynamic
	mov	QWORD PTR [rsp+48], rdi

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdi, QWORD PTR ?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A+8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN10@dynamic
$LL11@dynamic:
	mov	rcx, rbx
	call	??1NodeDef@AINBNodeDefMgr@@QEAA@XZ
	add	rbx, 248				; 000000f8H
	cmp	rbx, rdi
	jne	SHORT $LL11@dynamic
	mov	rbx, QWORD PTR ?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A
$LN10@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR ?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A+16
	mov	rcx, -1190112520884487201		; ef7bdef7bdef7bdfH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdi, QWORD PTR [rsp+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rax, rbx
	sar	rax, 3
	imul	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	imul	rdx, rax, 248				; 000000f8H

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN36@dynamic

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rax, QWORD PTR [rbx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rbx, rax

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rbx, -8
	cmp	rbx, 31
	ja	SHORT $LN33@dynamic

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rbx, rax
$LN36@dynamic:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	mov	QWORD PTR ?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A, 0

; 2050 :             _Mylast  = nullptr;

	movdqu	XMMWORD PTR ?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A+8, xmm0
$LN6@dynamic:
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN33@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN51@dynamic:
??__FNodeDefinitions@AINBNodeDefMgr@@YAXXZ ENDP		; AINBNodeDefMgr::`dynamic atexit destructor for 'NodeDefinitions''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
;	COMDAT ??__EEXBFile@AINBNodeDefMgr@@YAXXZ
text$di	SEGMENT
??__EEXBFile@AINBNodeDefMgr@@YAXXZ PROC			; AINBNodeDefMgr::`dynamic initializer for 'EXBFile'', COMDAT

; 12   : EXB AINBNodeDefMgr::EXBFile;

	lea	rcx, OFFSET FLAT:??__FEXBFile@AINBNodeDefMgr@@YAXXZ ; AINBNodeDefMgr::`dynamic atexit destructor for 'EXBFile''
	jmp	atexit
??__EEXBFile@AINBNodeDefMgr@@YAXXZ ENDP			; AINBNodeDefMgr::`dynamic initializer for 'EXBFile''
text$di	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??__FEXBFile@AINBNodeDefMgr@@YAXXZ
text$yd	SEGMENT
??__FEXBFile@AINBNodeDefMgr@@YAXXZ PROC			; AINBNodeDefMgr::`dynamic atexit destructor for 'EXBFile'', COMDAT
	sub	rsp, 40					; 00000028H

; 767  :         _Tidy();

	lea	rcx, OFFSET FLAT:?EXBFile@AINBNodeDefMgr@@3VEXB@@A+72
	call	?_Tidy@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAXXZ ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::_Tidy
	lea	rcx, OFFSET FLAT:?EXBFile@AINBNodeDefMgr@@3VEXB@@A+48
	add	rsp, 40					; 00000028H
	jmp	?_Tidy@?$vector@UCommandInfoStruct@EXB@@V?$allocator@UCommandInfoStruct@EXB@@@std@@@std@@AEAAXXZ ; std::vector<EXB::CommandInfoStruct,std::allocator<EXB::CommandInfoStruct> >::_Tidy
??__FEXBFile@AINBNodeDefMgr@@YAXXZ ENDP			; AINBNodeDefMgr::`dynamic atexit destructor for 'EXBFile''
text$yd	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@EXB@@QEAAX_K@Z
_TEXT	SEGMENT
this$dead$ = 8
classSize$dead$ = 16
?__autoclassinit2@EXB@@QEAAX_K@Z PROC			; EXB::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR ?EXBFile@AINBNodeDefMgr@@3VEXB@@A, xmm0
	mov	QWORD PTR ?EXBFile@AINBNodeDefMgr@@3VEXB@@A+96, rax
	movups	XMMWORD PTR ?EXBFile@AINBNodeDefMgr@@3VEXB@@A+16, xmm0
	movups	XMMWORD PTR ?EXBFile@AINBNodeDefMgr@@3VEXB@@A+32, xmm0
	movups	XMMWORD PTR ?EXBFile@AINBNodeDefMgr@@3VEXB@@A+48, xmm0
	movups	XMMWORD PTR ?EXBFile@AINBNodeDefMgr@@3VEXB@@A+64, xmm0
	movups	XMMWORD PTR ?EXBFile@AINBNodeDefMgr@@3VEXB@@A+80, xmm0
	ret	0
?__autoclassinit2@EXB@@QEAAX_K@Z ENDP			; EXB::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
;	COMDAT ?ReadString@AINBNodeDefMgr@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@@Z
_TEXT	SEGMENT
$T1 = 32
__$ReturnUdt$GSCopy$ = 40
__$ReturnUdt$ = 64
Reader$ = 72
?ReadString@AINBNodeDefMgr@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@@Z PROC ; AINBNodeDefMgr::ReadString, COMDAT

; 15   : {

$LN62:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
	xor	r11d, r11d
	mov	DWORD PTR $T1[rsp], r11d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 76   : 	this->m_Offset += 4;

	movsxd	r9, DWORD PTR [rdx+8]
	lea	eax, DWORD PTR [r9+4]
	mov	DWORD PTR [rdx+8], eax
	mov	rcx, r9
	mov	rax, QWORD PTR [rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rdx, QWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 76   : 	this->m_Offset += 4;

	lea	eax, DWORD PTR [r9+2]
	movsxd	r8, eax
	lea	eax, DWORD PTR [r9+1]
	movsxd	r9, eax

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movzx	r10d, BYTE PTR [rcx+rdx+3]
	shl	r10d, 8
	movzx	eax, BYTE PTR [r8+rdx]
	or	r10d, eax
	shl	r10d, 8
	movzx	eax, BYTE PTR [rcx+rdx+4]
	shl	eax, 24
	or	r10d, eax
	movzx	eax, BYTE PTR [r9+rdx]
	or	r10d, eax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rbx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], r11

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], r11b
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 22   : 	return Result;

	mov	DWORD PTR $T1[rsp], 1

; 18   : 	for (int i = 0; i < Length; i++)

	jle	SHORT $LN59@ReadString
	mov	esi, r10d
	npad	1
$LL4@ReadString:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 50   : 	this->m_Offset++;

	movsxd	rcx, DWORD PTR [rdi+8]
	lea	eax, DWORD PTR [rcx+1]
	mov	DWORD PTR [rdi+8], eax

; 51   : 	return this->m_Bytes[this->m_Offset];

	mov	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3236 :         push_back(_Ch);

	mov	rcx, QWORD PTR [rax]
	movzx	r9d, BYTE PTR [rdx+rcx+1]

; 4046 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR [rbx+16]

; 4047 :         if (_Old_size < _Mypair._Myval2._Myres) {

	mov	rdx, QWORD PTR [rbx+24]
	cmp	rax, rdx
	jae	SHORT $LN48@ReadString

; 4048 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 4049 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rcx, QWORD PTR [rax+1]
	mov	QWORD PTR [rbx+16], rcx

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	rcx, rbx

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	rdx, 16

; 2227 :         if (_Large_string_engaged()) {

	jb	SHORT $LN51@ReadString

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rbx]
$LN51@ReadString:

; 4051 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	BYTE PTR [rcx+rax], r9b

; 4052 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [rcx+rax+1], 0

; 4053 :             return;

	jmp	SHORT $LN2@ReadString
$LN48@ReadString:

; 4054 :         }
; 4055 : 
; 4056 :         _Reallocate_grow_by(

	mov	rcx, rbx
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
$LN2@ReadString:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 18   : 	for (int i = 0; i < Length; i++)

	sub	rsi, 1
	jne	SHORT $LL4@ReadString
$LN59@ReadString:

; 23   : }

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
	int	3
?ReadString@AINBNodeDefMgr@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@@Z ENDP ; AINBNodeDefMgr::ReadString
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
__$ReturnUdt$GSCopy$ = 40
__$ReturnUdt$ = 64
Reader$ = 72
?dtor$0@?0??ReadString@AINBNodeDefMgr@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@@Z@4HA PROC ; `AINBNodeDefMgr::ReadString'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN7@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$GSCopy$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN7@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??ReadString@AINBNodeDefMgr@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@@Z@4HA ENDP ; `AINBNodeDefMgr::ReadString'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\iosfwd
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\iosfwd
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Vector3F.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
;	COMDAT ?Initialize@AINBNodeDefMgr@@YAXXZ
_TEXT	SEGMENT
$T1 = 48
$T2 = 48
FlagCount$1$ = 49
$T3 = 49
AllowedAINBCount$1$ = 50
$T4 = 50
$T5 = 52
$T6 = 56
$T7 = 56
$T8 = 56
$T9 = 56
$T10 = 56
$T11 = 56
$T12 = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
$T17 = 56
$T18 = 56
$T19 = 56
LinkedNodeParamCount$1$ = 88
FileNameCount$1$ = 89
$T20 = 96
$T21 = 96
$T22 = 96
Reader$23 = 96
$T24 = 96
$T25 = 128
$T26 = 128
$T27 = 136
$T28 = 136
$T29 = 136
Type$1$ = 144
j$1$ = 148
tv9913 = 152
$T30 = 160
$T31 = 168
$T32 = 184
$T33 = 216
$T34 = 256
File$ = 368
Param$35 = 640
Param$36 = 784
Definition$37 = 880
Param$38 = 1136
Bytes$39 = 1216
FileSize$40 = 1240
EXBBytes$41 = 1264
Offsets$42 = 1288
__$ArrayPad$ = 1312
?Initialize@AINBNodeDefMgr@@YAXXZ PROC			; AINBNodeDefMgr::Initialize, COMDAT

; 27   : {

$LN1956:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rsi
	mov	QWORD PTR [rax+24], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-1128]
	sub	rsp, 1344				; 00000540H
	movaps	XMMWORD PTR [rax-56], xmm6
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	xor	r12d, r12d
	mov	DWORD PTR $T5[rsp], r12d
	mov	DWORD PTR $T26[rbp-256], r12d

; 28   : 	std::ifstream File(Editor::GetWorkingDirFile("Definitions.eainbdef"), std::ios::binary);

	lea	rcx, QWORD PTR File$[rbp-256]
	call	?__autoclassinit2@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z
	lea	rdx, OFFSET FLAT:??_C@_0BF@BPHJMEGE@Definitions?4eainbdef@
	lea	rcx, QWORD PTR $T19[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	lea	rcx, QWORD PTR $T24[rsp]
	call	?GetWorkingDirFile@Editor@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z ; Editor::GetWorkingDirFile
	npad	1
	mov	rdx, rax
	lea	rcx, QWORD PTR File$[rbp-256]
	call	??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T24[rsp]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 30   : 	if (!File.eof() && !File.fail())

	mov	rax, QWORD PTR File$[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	rax, QWORD PTR File$[rbp-256]
	add	rcx, rax
	call	QWORD PTR __imp_?eof@ios_base@std@@QEBA_NXZ
	test	al, al
	jne	$LN43@Initialize
	mov	rax, QWORD PTR File$[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	rax, QWORD PTR File$[rbp-256]
	add	rcx, rax
	call	QWORD PTR __imp_?fail@ios_base@std@@QEBA_NXZ
	test	al, al
	jne	$LN43@Initialize

; 31   : 	{
; 32   : 		File.seekg(0, std::ios_base::end);

	xor	edx, edx
	lea	r8d, QWORD PTR [r12+2]
	lea	rcx, QWORD PTR File$[rbp-256]
	call	QWORD PTR __imp_?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@_JH@Z

; 33   : 		std::streampos FileSize = File.tellg();

	lea	rdx, QWORD PTR FileSize$40[rbp-256]
	lea	rcx, QWORD PTR File$[rbp-256]
	call	QWORD PTR __imp_?tellg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA?AV?$fpos@U_Mbstatet@@@2@XZ

; 35   : 		std::vector<unsigned char> Bytes(FileSize);

	lea	rcx, QWORD PTR Bytes$39[rbp-256]
	call	?__autoclassinit2@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\iosfwd

; 68   :         return _Myoff + _Fpos;

	mov	rdx, QWORD PTR FileSize$40[rbp-248]
	add	rdx, QWORD PTR FileSize$40[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 35   : 		std::vector<unsigned char> Bytes(FileSize);

	lea	rcx, QWORD PTR Bytes$39[rbp-256]
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@_KAEBV?$allocator@E@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	npad	1

; 36   : 
; 37   : 		File.seekg(0, std::ios_base::beg);

	xor	r8d, r8d
	xor	edx, edx
	lea	rcx, QWORD PTR File$[rbp-256]
	call	QWORD PTR __imp_?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@_JH@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\iosfwd

; 68   :         return _Myoff + _Fpos;

	mov	r8, QWORD PTR FileSize$40[rbp-248]
	add	r8, QWORD PTR FileSize$40[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 38   : 		File.read(reinterpret_cast<char*>(Bytes.data()), FileSize);

	mov	rdx, QWORD PTR Bytes$39[rbp-256]
	lea	rcx, QWORD PTR File$[rbp-256]
	call	QWORD PTR __imp_?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z

; 39   : 		File.close();

	lea	rcx, QWORD PTR File$[rbp-256]
	call	?close@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ ; std::basic_ifstream<char,std::char_traits<char> >::close
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 6    : BinaryVectorReader::BinaryVectorReader(std::vector<unsigned char>& Bytes, bool BigEndian) : m_Bytes(Bytes) {}

	lea	rax, QWORD PTR Bytes$39[rbp-256]
	mov	QWORD PTR Reader$23[rsp], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.h

; 39   : 	int m_Offset = -1;

	mov	DWORD PTR Reader$23[rsp+8], -1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 43   : 		Reader.Seek(8, BinaryVectorReader::Position::Begin); //Skip magic

	xor	r8d, r8d
	lea	edx, QWORD PTR [r12+8]
	lea	rcx, QWORD PTR Reader$23[rsp]
	call	?Seek@BinaryVectorReader@@QEAAXHW4Position@1@@Z ; BinaryVectorReader::Seek

; 44   : 		uint8_t Version = Reader.ReadUInt8();

	lea	rcx, QWORD PTR Reader$23[rsp]
	call	?ReadUInt8@BinaryVectorReader@@QEAAEXZ	; BinaryVectorReader::ReadUInt8

; 45   : 		if (Version != 0x03)

	cmp	al, 3
	je	SHORT $LN44@Initialize

; 46   : 		{
; 47   : 			Logger::Error("AINBNodeDefMgr", "AINB node definition file has wrong version, expected 0x03. Did you update the WorkingDir/Definitions.eainbdef file?");

	lea	rax, QWORD PTR $T18[rsp]
	mov	QWORD PTR $T29[rbp-256], rax
	lea	rdx, OFFSET FLAT:??_C@_0HF@MCIMJAFC@AINB?5node?5definition?5file?5has?5w@
	lea	rcx, QWORD PTR $T18[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rbx, rax
	lea	rdx, OFFSET FLAT:??_C@_0P@NFEGPIHE@AINBNodeDefMgr@
	lea	rcx, QWORD PTR $T22[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rdx, rbx
	mov	rcx, rax
	call	?Error@Logger@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; Logger::Error
	jmp	$LN1951@Initialize
$LN44@Initialize:

; 48   : 			return;
; 49   : 		}
; 50   : 
; 51   : 		AINBNodeDefMgr::NodeDefinitions.resize(Reader.ReadUInt32());

	xor	edx, edx
	lea	rcx, QWORD PTR Reader$23[rsp]
	call	?ReadUInt32@BinaryVectorReader@@QEAAI_N@Z ; BinaryVectorReader::ReadUInt32
	mov	edx, eax
	call	?resize@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::resize

; 52   : 
; 53   : 		std::vector<uint32_t> Offsets(AINBNodeDefMgr::NodeDefinitions.size());

	lea	rcx, QWORD PTR Offsets$42[rbp-256]
	call	?__autoclassinit2@?$vector@IV?$allocator@I@std@@@std@@QEAAX_K@Z
	call	?size@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::size
	mov	rdx, rax
	lea	rcx, QWORD PTR Offsets$42[rbp-256]
	call	??0?$vector@IV?$allocator@I@std@@@std@@QEAA@_KAEBV?$allocator@I@1@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
	npad	1

; 54   : 		for (int i = 0; i < AINBNodeDefMgr::NodeDefinitions.size(); i++)

	xor	ebx, ebx
	call	?size@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::size
	test	rax, rax
	je	SHORT $LN3@Initialize
	xor	r10d, r10d
	npad	10
$LL4@Initialize:

; 55   : 		{
; 56   : 			Offsets[i] = Reader.ReadUInt32();

	xor	edx, edx
	lea	rcx, QWORD PTR Reader$23[rsp]
	call	?ReadUInt32@BinaryVectorReader@@QEAAI_N@Z ; BinaryVectorReader::ReadUInt32
	mov	rcx, QWORD PTR Offsets$42[rbp-256]
	mov	DWORD PTR [rcx+r10], eax

; 54   : 		for (int i = 0; i < AINBNodeDefMgr::NodeDefinitions.size(); i++)

	inc	ebx
	lea	r10, QWORD PTR [r10+4]
	call	?size@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::size
	movsxd	rcx, ebx
	cmp	rcx, rax
	jb	SHORT $LL4@Initialize
$LN3@Initialize:

; 59   : 		for (int j = 0; j < AINBNodeDefMgr::NodeDefinitions.size(); j++)

	mov	DWORD PTR j$1$[rbp-256], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR ?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A+8
	sub	rax, QWORD PTR ?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A
	sar	rax, 3
	mov	rcx, -1190112520884487201		; ef7bdef7bdef7bdfH
	imul	rax, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 59   : 		for (int j = 0; j < AINBNodeDefMgr::NodeDefinitions.size(); j++)

	test	rax, rax
	je	$LN1925@Initialize
	xor	r14d, r14d
	mov	QWORD PTR $T27[rbp-256], r14
$LN1953@Initialize:

; 60   : 		{
; 61   : 			Reader.Seek(Offsets[j], BinaryVectorReader::Position::Begin);

	mov	r13, -8198552921648689607		; 8e38e38e38e38e39H
	xor	r8d, r8d
	mov	rdx, QWORD PTR Offsets$42[rbp-256]
	mov	edx, DWORD PTR [rdx+r14*4]
	lea	rcx, QWORD PTR Reader$23[rsp]
	call	?Seek@BinaryVectorReader@@QEAAXHW4Position@1@@Z ; BinaryVectorReader::Seek

; 62   : 			AINBNodeDefMgr::NodeDef Definition;

	lea	rcx, QWORD PTR Definition$37[rbp-256]
	call	??0NodeDef@AINBNodeDefMgr@@QEAA@XZ
	npad	1

; 63   : 			Definition.Name = ReadString(Reader);

	lea	rdx, QWORD PTR Reader$23[rsp]
	lea	rcx, QWORD PTR $T17[rsp]
	call	?ReadString@AINBNodeDefMgr@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@@Z ; AINBNodeDefMgr::ReadString
	mov	rdx, rax
	lea	rcx, QWORD PTR Definition$37[rbp-248]
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T17[rsp]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 64   : 			Definition.DisplayName = ReadString(Reader);

	lea	rdx, QWORD PTR Reader$23[rsp]
	lea	rcx, QWORD PTR $T16[rsp]
	call	?ReadString@AINBNodeDefMgr@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@@Z ; AINBNodeDefMgr::ReadString
	mov	rdx, rax
	lea	rcx, QWORD PTR Definition$37[rbp-216]
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T16[rsp]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 65   : 			Definition.NameHash = Reader.ReadUInt32();

	xor	edx, edx
	lea	rcx, QWORD PTR Reader$23[rsp]
	call	?ReadUInt32@BinaryVectorReader@@QEAAI_N@Z ; BinaryVectorReader::ReadUInt32
	mov	DWORD PTR Definition$37[rbp-184], eax

; 66   : 			Definition.Type = Reader.ReadUInt16();

	lea	rcx, QWORD PTR Reader$23[rsp]
	call	?ReadUInt16@BinaryVectorReader@@QEAAG_N@Z ; BinaryVectorReader::ReadUInt16
	mov	WORD PTR Definition$37[rbp-180], ax

; 67   : 			Definition.Category = (AINBNodeDefMgr::NodeDef::CategoryEnum)Reader.ReadUInt8();

	lea	rcx, QWORD PTR Reader$23[rsp]
	call	?ReadUInt8@BinaryVectorReader@@QEAAEXZ	; BinaryVectorReader::ReadUInt8
	mov	BYTE PTR Definition$37[rbp-256], al

; 68   : 			uint8_t LinkedNodeParamCount = Reader.ReadUInt8();

	lea	rcx, QWORD PTR Reader$23[rsp]
	call	?ReadUInt8@BinaryVectorReader@@QEAAEXZ	; BinaryVectorReader::ReadUInt8
	mov	BYTE PTR LinkedNodeParamCount$1$[rsp], al

; 69   : 			uint8_t FileNameCount = Reader.ReadUInt8();

	lea	rcx, QWORD PTR Reader$23[rsp]
	call	?ReadUInt8@BinaryVectorReader@@QEAAEXZ	; BinaryVectorReader::ReadUInt8
	mov	BYTE PTR FileNameCount$1$[rsp], al

; 70   : 			uint8_t FlagCount = Reader.ReadUInt8();

	lea	rcx, QWORD PTR Reader$23[rsp]
	call	?ReadUInt8@BinaryVectorReader@@QEAAEXZ	; BinaryVectorReader::ReadUInt8
	mov	BYTE PTR FlagCount$1$[rsp], al

; 71   : 			uint8_t AllowedAINBCount = Reader.ReadUInt8();

	lea	rcx, QWORD PTR Reader$23[rsp]
	call	?ReadUInt8@BinaryVectorReader@@QEAAEXZ	; BinaryVectorReader::ReadUInt8
	mov	BYTE PTR AllowedAINBCount$1$[rsp], al

; 72   : 
; 73   : 			Definition.InputParameters.resize(6);

	lea	rcx, QWORD PTR Definition$37[rbp-152]
	call	?resize@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAX_K@Z ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::resize

; 74   : 			Definition.OutputParameters.resize(6);

	lea	rcx, QWORD PTR Definition$37[rbp-128]
	call	?resize@?$vector@V?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@V?$allocator@V?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@@2@@std@@QEAAX_K@Z ; std::vector<std::vector<AINBFile::OutputEntry,std::allocator<AINBFile::OutputEntry> >,std::allocator<std::vector<AINBFile::OutputEntry,std::allocator<AINBFile::OutputEntry> > > >::resize

; 75   : 			Definition.ImmediateParameters.resize(6);

	lea	rcx, QWORD PTR Definition$37[rbp-176]
	call	?resize@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAX_K@Z ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::resize

; 60   : 		{
; 61   : 			Reader.Seek(Offsets[j], BinaryVectorReader::Position::Begin);

	xor	edi, edi
$LL10@Initialize:

; 78   : 			{
; 79   : 				Definition.InputParameters[Type].resize(Reader.ReadUInt8());

	movsxd	rbx, edi
	mov	rdx, rbx
	lea	rcx, QWORD PTR Definition$37[rbp-152]
	call	??A?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAAEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@_K@Z ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::operator[]
	mov	r8, rax
	lea	rcx, QWORD PTR Reader$23[rsp]
	call	?ReadUInt8@BinaryVectorReader@@QEAAEXZ	; BinaryVectorReader::ReadUInt8
	movzx	edx, al
	mov	rcx, r8
	call	?resize@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::resize

; 80   : 				Definition.OutputParameters[Type].resize(Reader.ReadUInt8());

	mov	rdx, rbx
	lea	rcx, QWORD PTR Definition$37[rbp-128]
	call	??A?$vector@V?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@V?$allocator@V?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@@2@@std@@QEAAAEAV?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@1@_K@Z ; std::vector<std::vector<AINBFile::OutputEntry,std::allocator<AINBFile::OutputEntry> >,std::allocator<std::vector<AINBFile::OutputEntry,std::allocator<AINBFile::OutputEntry> > > >::operator[]
	mov	r8, rax
	lea	rcx, QWORD PTR Reader$23[rsp]
	call	?ReadUInt8@BinaryVectorReader@@QEAAEXZ	; BinaryVectorReader::ReadUInt8
	movzx	edx, al
	mov	rcx, r8
	call	?resize@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@QEAAX_K@Z ; std::vector<AINBFile::OutputEntry,std::allocator<AINBFile::OutputEntry> >::resize

; 81   : 				Definition.ImmediateParameters[Type].resize(Reader.ReadUInt8());

	mov	rdx, rbx
	lea	rcx, QWORD PTR Definition$37[rbp-176]
	call	??A?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAAEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@_K@Z ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::operator[]
	mov	r8, rax
	lea	rcx, QWORD PTR Reader$23[rsp]
	call	?ReadUInt8@BinaryVectorReader@@QEAAEXZ	; BinaryVectorReader::ReadUInt8
	movzx	edx, al
	mov	rcx, r8
	call	?resize@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::resize

; 76   : 
; 77   : 			for (int Type = 0; Type < AINBFile::ValueTypeCount; Type++)

	inc	edi
	cmp	edi, 6
	jb	SHORT $LL10@Initialize

; 82   : 			}
; 83   : 			for (int Type = 0; Type < AINBFile::ValueTypeCount; Type++)

	xor	edx, edx
	mov	DWORD PTR Type$1$[rbp-256], edx
	mov	eax, edx
	mov	QWORD PTR $T30[rbp-256], rdx
	mov	edi, DWORD PTR Reader$23[rsp+8]
	mov	rsi, QWORD PTR Reader$23[rsp]
	jmp	SHORT $LN13@Initialize
	npad	10
$LL1948@Initialize:
	xor	edx, edx
$LN13@Initialize:

; 85   : 				for (int i = 0; i < Definition.InputParameters[Type].size(); i++)

	mov	r15d, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	rbx, QWORD PTR [rax+rax*2]
	mov	QWORD PTR tv9913[rbp-256], rbx
	mov	rax, QWORD PTR Definition$37[rbp-152]

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rax+rbx*8+8]
	sub	rcx, QWORD PTR [rax+rbx*8]
	sar	rcx, 4
	imul	rcx, r13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 85   : 				for (int i = 0; i < Definition.InputParameters[Type].size(); i++)

	test	rcx, rcx
	je	$LN1938@Initialize
	mov	r14, rdx
$LL16@Initialize:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR Param$35[rbp-256], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR Param$35[rbp-240], rdx

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	edi, 15
	mov	QWORD PTR Param$35[rbp-232], rdi

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR Param$35[rbp-256], 0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR Param$35[rbp-224], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR Param$35[rbp-208], rdx

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR Param$35[rbp-200], rdi

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR Param$35[rbp-224], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqa	XMMWORD PTR Param$35[rbp-192], xmm0
	mov	QWORD PTR Param$35[rbp-176], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	mov	DWORD PTR Param$35[rbp-168], edx

; 795  :           _Which{static_cast<_Index_t>(_Idx)} { // initialize alternative _Idx from _Args...

	mov	BYTE PTR Param$35[rbp-136], 0
	mov	BYTE PTR Param$35[rbp-124], 0
	mov	DWORD PTR Param$35[rbp-120], 65535	; 0000ffffH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 88   : 					Param.Name = ReadString(Reader);

	lea	rdx, QWORD PTR Reader$23[rsp]
	lea	rcx, QWORD PTR $T15[rsp]
	call	?ReadString@AINBNodeDefMgr@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@@Z ; AINBNodeDefMgr::ReadString
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2961 :         if (this == _STD addressof(_Right)) {

	lea	rax, QWORD PTR Param$35[rbp-256]
	cmp	rax, rbx
	je	SHORT $LN1946@Initialize

; 2962 :             return *this;
; 2963 :         }
; 2964 : 
; 2965 :         auto& _Al                 = _Getal();
; 2966 :         auto& _Right_al           = _Right._Getal();
; 2967 :         constexpr auto _Pocma_val = _Choose_pocma_v<_Alty>;
; 2968 :         if constexpr (_Pocma_val == _Pocma_values::_Propagate_allocators) {
; 2969 :             if (_Al != _Right_al) {
; 2970 :                 // intentionally slams into noexcept on OOM, TRANSITION, VSO-466800
; 2971 :                 _Mypair._Myval2._Orphan_all();
; 2972 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 2973 :             }
; 2974 :         } else if constexpr (_Pocma_val == _Pocma_values::_No_propagate_allocators) {
; 2975 :             if (_Al != _Right_al) {
; 2976 :                 assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 2977 :                 return *this;
; 2978 :             }
; 2979 :         }
; 2980 : 
; 2981 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR Param$35[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rbx]
	movaps	XMMWORD PTR Param$35[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rbx+16]
	movaps	XMMWORD PTR Param$35[rbp-240], xmm1

; 4821 :         _My_data._Mysize = 0;

	xor	r13d, r13d
	mov	QWORD PTR [rbx+16], r13

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], rdi

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], r13b

; 2961 :         if (this == _STD addressof(_Right)) {

	jmp	SHORT $LN1350@Initialize
$LN1946@Initialize:
	xor	r13d, r13d
$LN1350@Initialize:

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T15[rsp]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 89   : 					Param.Class = ReadString(Reader);

	lea	rdx, QWORD PTR Reader$23[rsp]
	lea	rcx, QWORD PTR $T14[rsp]
	call	?ReadString@AINBNodeDefMgr@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@@Z ; AINBNodeDefMgr::ReadString
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2961 :         if (this == _STD addressof(_Right)) {

	lea	rax, QWORD PTR Param$35[rbp-224]
	cmp	rax, rbx
	je	SHORT $LN1262@Initialize

; 2962 :             return *this;
; 2963 :         }
; 2964 : 
; 2965 :         auto& _Al                 = _Getal();
; 2966 :         auto& _Right_al           = _Right._Getal();
; 2967 :         constexpr auto _Pocma_val = _Choose_pocma_v<_Alty>;
; 2968 :         if constexpr (_Pocma_val == _Pocma_values::_Propagate_allocators) {
; 2969 :             if (_Al != _Right_al) {
; 2970 :                 // intentionally slams into noexcept on OOM, TRANSITION, VSO-466800
; 2971 :                 _Mypair._Myval2._Orphan_all();
; 2972 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 2973 :             }
; 2974 :         } else if constexpr (_Pocma_val == _Pocma_values::_No_propagate_allocators) {
; 2975 :             if (_Al != _Right_al) {
; 2976 :                 assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 2977 :                 return *this;
; 2978 :             }
; 2979 :         }
; 2980 : 
; 2981 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR Param$35[rbp-224]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rbx]
	movaps	XMMWORD PTR Param$35[rbp-224], xmm0
	movups	xmm1, XMMWORD PTR [rbx+16]
	movaps	XMMWORD PTR Param$35[rbp-208], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], r13

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], rdi

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0
$LN1262@Initialize:

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	r8, QWORD PTR $T14[rsp+24]
	cmp	r8, 16
	jb	SHORT $LN1156@Initialize

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	r8
	mov	rdx, QWORD PTR $T14[rsp]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
$LN1156@Initialize:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 44   : 	this->m_Offset++;

	mov	r11d, DWORD PTR Reader$23[rsp+8]
	inc	r11d
	movsxd	rax, r11d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rsi, QWORD PTR Reader$23[rsp]
	add	rax, QWORD PTR [rsi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 90   : 					Param.ValueType = (AINBFile::ValueType)Reader.ReadUInt8();

	movzx	r9d, BYTE PTR [rax]
	mov	DWORD PTR Param$35[rbp-128], r9d
	lea	ebx, DWORD PTR [r11+2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 56   : 	this->m_Offset += 2;

	mov	edi, ebx
	mov	DWORD PTR Reader$23[rsp+8], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rdx, QWORD PTR [rsi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 56   : 	this->m_Offset += 2;

	movsxd	rax, r11d

; 57   : 	return !BigEndian ? ((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)) : _byteswap_ushort(((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)));

	movsxd	rcx, r11d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 91   : 					Param.EXBIndex = Reader.ReadUInt16();

	movzx	r8d, BYTE PTR [rax+rdx+2]
	shl	r8d, 8
	movzx	eax, BYTE PTR [rcx+rdx+1]
	or	r8d, eax
	mov	DWORD PTR Param$35[rbp-120], r8d
	cmp	r8d, 65535				; 0000ffffH

; 92   : 					Param.HasEXBFunction = Param.EXBIndex != 0xFFFF;

	setne	BYTE PTR Param$35[rbp-124]

; 93   : 
; 94   : 					switch (Param.ValueType)

	test	r9d, r9d
	je	$LN46@Initialize
	sub	r9d, 1
	je	$LN45@Initialize
	sub	r9d, 1
	je	$LN47@Initialize
	sub	r9d, 1
	je	$LN48@Initialize
	cmp	r9d, 1
	jne	$LN1531@Initialize

; 109  : 						Param.Value = Vector3F(Reader.ReadFloat(), Reader.ReadFloat(), Reader.ReadFloat());

	xor	edx, edx
	lea	rcx, QWORD PTR Reader$23[rsp]
	call	?ReadFloat@BinaryVectorReader@@QEAAM_N@Z ; BinaryVectorReader::ReadFloat
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 76   : 	this->m_Offset += 4;

	mov	r9d, DWORD PTR Reader$23[rsp+8]
	add	r9d, 4
	mov	DWORD PTR Reader$23[rsp+8], r9d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rsi, QWORD PTR Reader$23[rsp]
	mov	rbx, QWORD PTR [rsi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 76   : 	this->m_Offset += 4;

	movsxd	r8, r9d

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movsxd	rax, r9d
	movsxd	rcx, r9d
	movsxd	rdx, r9d
	movzx	r11d, BYTE PTR [rax+rbx-1]
	shl	r11d, 8
	movzx	eax, BYTE PTR [rcx+rbx-2]
	or	r11d, eax
	shl	r11d, 8
	movzx	eax, BYTE PTR [r8+rbx]
	shl	eax, 24
	or	r11d, eax
	movzx	eax, BYTE PTR [rdx+rbx-3]
	or	r11d, eax
	lea	edi, DWORD PTR [r9+4]

; 76   : 	this->m_Offset += 4;

	movsxd	r10, r9d

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movsxd	rcx, r9d
	movsxd	rdx, r9d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	eax, DWORD PTR [r9+1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movsxd	r8, eax
	movzx	r9d, BYTE PTR [rcx+rbx+3]
	shl	r9d, 8
	movzx	eax, BYTE PTR [rdx+rbx+2]
	or	r9d, eax
	shl	r9d, 8
	movzx	eax, BYTE PTR [r10+rbx+4]
	shl	eax, 24
	or	r9d, eax
	movzx	eax, BYTE PTR [r8+rbx]
	or	r9d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Vector3F.cpp

; 8    : 	this->m_Data[0] = x;

	mov	DWORD PTR $T31[rbp-256], r9d

; 9    : 	this->m_Data[1] = y;

	mov	DWORD PTR $T31[rbp-252], r11d

; 10   : 	this->m_Data[2] = z;

	movss	DWORD PTR $T31[rbp-248], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 109  : 						Param.Value = Vector3F(Reader.ReadFloat(), Reader.ReadFloat(), Reader.ReadFloat());

	lea	rdx, QWORD PTR $T31[rbp-256]
	lea	rcx, QWORD PTR Param$35[rbp-168]
	call	??$?4VVector3F@@$0A@@?$variant@I_NMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VVector3F@@@std@@QEAAAEAV01@$$QEAVVector3F@@@Z ; std::variant<unsigned int,bool,float,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Vector3F>::operator=<Vector3F,0>
	jmp	$LN1531@Initialize
$LN48@Initialize:

; 105  : 					case AINBFile::ValueType::String:
; 106  : 						Param.Value = ReadString(Reader);

	lea	rdx, QWORD PTR Reader$23[rsp]
	lea	rcx, QWORD PTR $T13[rsp]
	call	?ReadString@AINBNodeDefMgr@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@@Z ; AINBNodeDefMgr::ReadString
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 803  :         return static_cast<size_t>(_Which);

	movsx	rcx, BYTE PTR Param$35[rbp-136]

; 1031 :         if (index() == _TargetIdx) {

	cmp	rcx, 3
	jne	SHORT $LN1631@Initialize

; 1032 :             auto& _Target = _STD _Variant_raw_get<_TargetIdx>(_Storage());
; 1033 :             _Target       = static_cast<_Ty&&>(_Obj);

	mov	rdx, rax
	lea	rcx, QWORD PTR Param$35[rbp-168]
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 1034 :         } else {

	jmp	SHORT $LN1731@Initialize
$LN1631@Initialize:

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	lea	rdx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN1916@Initialize[rdx+rcx*4+4]
	add	rax, rdx
	jmp	rax
$LN1651@Initialize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR Param$35[rbp-168]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN1669@Initialize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR Param$35[rbp-136], -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 254  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	r8, rbx
	lea	rcx, QWORD PTR Param$35[rbp-168]
	call	??$?0$02V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$_Variant_storage_@$0A@I_NMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VVector3F@@@std@@QEAA@U?$integral_constant@_K$02@1@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Variant_storage_<0,unsigned int,bool,float,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Vector3F>::_Variant_storage_<0,unsigned int,bool,float,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Vector3F><3,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,0>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR Param$35[rbp-136], 3
$LN1731@Initialize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T13[rsp]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 107  : 						break;

	mov	edi, DWORD PTR Reader$23[rsp+8]
	mov	rsi, QWORD PTR Reader$23[rsp]
	jmp	$LN1531@Initialize
$LN47@Initialize:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 76   : 	this->m_Offset += 4;

	lea	edi, DWORD PTR [rbx+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r10, QWORD PTR [rsi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 76   : 	this->m_Offset += 4;

	movsxd	r9, r11d

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movsxd	rcx, r11d
	movsxd	rdx, r11d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	eax, DWORD PTR [rbx+1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movsxd	r8, eax
	movzx	ebx, BYTE PTR [rcx+r10+5]
	shl	ebx, 8
	movzx	eax, BYTE PTR [rdx+r10+4]
	or	ebx, eax
	shl	ebx, 8
	movzx	eax, BYTE PTR [r9+r10+6]
	shl	eax, 24
	or	ebx, eax
	movzx	eax, BYTE PTR [r8+r10]
	or	ebx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 803  :         return static_cast<size_t>(_Which);

	movsx	rax, BYTE PTR Param$35[rbp-136]

; 1031 :         if (index() == _TargetIdx) {

	cmp	rax, 2
	je	$LN1952@Initialize

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN1915@Initialize[rcx+rax*4+4]
	add	rax, rcx
	jmp	rax
$LN1575@Initialize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR Param$35[rbp-168]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN1593@Initialize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR Param$35[rbp-136], 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 104  : 						break;

	jmp	$LN1952@Initialize
$LN45@Initialize:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 44   : 	this->m_Offset++;

	lea	edi, DWORD PTR [rbx+1]
	movsxd	rcx, r11d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rsi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 97   : 						Param.Value = (bool)Reader.ReadUInt8();

	cmp	BYTE PTR [rcx+rax+3], 0
	setne	bl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 803  :         return static_cast<size_t>(_Which);

	movsx	rax, BYTE PTR Param$35[rbp-136]

; 1031 :         if (index() == _TargetIdx) {

	cmp	rax, 1
	jne	SHORT $LN1355@Initialize

; 1032 :             auto& _Target = _STD _Variant_raw_get<_TargetIdx>(_Storage());
; 1033 :             _Target       = static_cast<_Ty&&>(_Obj);

	mov	BYTE PTR Param$35[rbp-168], bl

; 1034 :         } else {

	jmp	$LN1531@Initialize
$LN1355@Initialize:

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN1914@Initialize[rcx+rax*4+4]
	add	rax, rcx
	jmp	rax
$LN1375@Initialize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR Param$35[rbp-168]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN1393@Initialize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 1170 :         _STD _Construct_in_place(_Storage(), integral_constant<size_t, _Idx>{}, static_cast<_ArgTypes&&>(_Args)...);

	mov	BYTE PTR Param$35[rbp-168], bl

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR Param$35[rbp-136], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 98   : 						break;

	jmp	SHORT $LN1531@Initialize
$LN46@Initialize:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 76   : 	this->m_Offset += 4;

	lea	edi, DWORD PTR [rbx+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r10, QWORD PTR [rsi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 76   : 	this->m_Offset += 4;

	movsxd	r9, r11d

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movsxd	rcx, r11d
	movsxd	rdx, r11d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	eax, DWORD PTR [rbx+1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movsxd	r8, eax
	movzx	ebx, BYTE PTR [rcx+r10+5]
	shl	ebx, 8
	movzx	eax, BYTE PTR [rdx+r10+4]
	or	ebx, eax
	shl	ebx, 8
	movzx	eax, BYTE PTR [r9+r10+6]
	shl	eax, 24
	or	ebx, eax
	movzx	eax, BYTE PTR [r8+r10]
	or	ebx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 803  :         return static_cast<size_t>(_Which);

	movsx	rax, BYTE PTR Param$35[rbp-136]

; 1031 :         if (index() == _TargetIdx) {

	test	rax, rax
	je	SHORT $LN1952@Initialize

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN1913@Initialize[rcx+rax*4+4]
	add	rax, rcx
	jmp	rax
$LN1499@Initialize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR Param$35[rbp-168]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN1517@Initialize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR Param$35[rbp-136], 0
$LN1952@Initialize:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 44   : 	this->m_Offset++;

	mov	DWORD PTR Param$35[rbp-168], ebx
$LN1531@Initialize:
	inc	edi
	mov	DWORD PTR Reader$23[rsp+8], edi
	movsxd	rax, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR [rsi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 113  : 					for (int k = 0; k < FlagsSize; k++)

	movzx	ecx, BYTE PTR [rax]
	mov	r9, QWORD PTR Param$35[rbp-184]
	test	ecx, ecx
	je	SHORT $LN20@Initialize
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 44   : 	this->m_Offset++;

	mov	ebx, ecx
$LL21@Initialize:
	movsxd	rcx, edi
	inc	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rsi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 115  : 						Param.Flags.push_back((AINBFile::FlagsStruct)Reader.ReadUInt8());

	movzx	edx, BYTE PTR [rcx+rax+1]
	mov	BYTE PTR $T2[rsp], dl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	cmp	r9, QWORD PTR Param$35[rbp-176]
	je	SHORT $LN1034@Initialize

; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	BYTE PTR [r9], dl

; 806  :         ++_Mylast;

	mov	r9, QWORD PTR Param$35[rbp-184]
	inc	r9
	mov	QWORD PTR Param$35[rbp-184], r9

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN19@Initialize
$LN1034@Initialize:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T2[rsp]
	mov	rdx, r9
	lea	rcx, QWORD PTR Param$35[rbp-192]
	call	??$_Emplace_reallocate@W4FlagsStruct@AINBFile@@@?$vector@W4FlagsStruct@AINBFile@@V?$allocator@W4FlagsStruct@AINBFile@@@std@@@std@@AEAAPEAW4FlagsStruct@AINBFile@@QEAW423@$$QEAW423@@Z ; std::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >::_Emplace_reallocate<enum AINBFile::FlagsStruct>
	mov	r9, QWORD PTR Param$35[rbp-184]
$LN19@Initialize:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 113  : 					for (int k = 0; k < FlagsSize; k++)

	sub	rbx, 1
	jne	SHORT $LL21@Initialize
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 44   : 	this->m_Offset++;

	mov	DWORD PTR Reader$23[rsp+8], edi
$LN20@Initialize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR Definition$37[rbp-152]
	mov	rdx, QWORD PTR tv9913[rbp-256]
	mov	rbx, QWORD PTR [rax+rdx*8]
	add	rbx, r14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3156 :         if (this == _STD addressof(_Right)) {

	lea	rax, QWORD PTR Param$35[rbp-256]
	cmp	rbx, rax
	je	SHORT $LN996@Initialize

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR Param$35[rbp-256]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR Param$35[rbp-232], 16
	cmovae	rdx, QWORD PTR Param$35[rbp-256]

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR Param$35[rbp-240]
	mov	rcx, rbx
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	r9, QWORD PTR Param$35[rbp-184]
$LN996@Initialize:
	lea	rcx, QWORD PTR [rbx+32]

; 3156 :         if (this == _STD addressof(_Right)) {

	lea	rax, QWORD PTR Param$35[rbp-224]
	cmp	rcx, rax
	je	SHORT $LN1004@Initialize

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR Param$35[rbp-224]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR Param$35[rbp-200], 16
	cmovae	rdx, QWORD PTR Param$35[rbp-224]

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR Param$35[rbp-208]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	r9, QWORD PTR Param$35[rbp-184]
$LN1004@Initialize:
	lea	rcx, QWORD PTR [rbx+64]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1483 :         if (this == _STD addressof(_Right)) {

	lea	rax, QWORD PTR Param$35[rbp-192]
	cmp	rcx, rax
	je	SHORT $LN1012@Initialize

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR Param$35[rbp-192]
	sub	r9, rdx
	mov	r8, r9
	call	??$_Assign_counted_range@PEAW4FlagsStruct@AINBFile@@@?$vector@W4FlagsStruct@AINBFile@@V?$allocator@W4FlagsStruct@AINBFile@@@std@@@std@@AEAAXPEAW4FlagsStruct@AINBFile@@_K@Z ; std::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >::_Assign_counted_range<enum AINBFile::FlagsStruct *>
$LN1012@Initialize:
	lea	rax, QWORD PTR [rbx+88]
	mov	QWORD PTR $T25[rbp-256], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 803  :         return static_cast<size_t>(_Which);

	movsx	rcx, BYTE PTR Param$35[rbp-136]

; 691  :     ++_Idx; // bias index by +1 to map {variant_npos} U [0, _Size) to the contiguous range [0, _Size]

	inc	rcx

; 692  :     return _Variant_raw_visit1<_Strategy>::_Visit(_Idx, static_cast<_Fn&&>(_Func), static_cast<_Storage&&>(_Obj));

	lea	r8, QWORD PTR Param$35[rbp-168]
	lea	rdx, QWORD PTR $T25[rbp-256]
	call	??$_Visit@U?$_Variant_assign_visitor@I_NMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VVector3F@@@std@@AEBV?$_Variant_storage_@$0A@I_NMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VVector3F@@@2@@?$_Variant_raw_visit1@$01@std@@SAX_K$$QEAU?$_Variant_assign_visitor@I_NMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VVector3F@@@1@AEBV?$_Variant_storage_@$0A@I_NMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VVector3F@@@1@@Z ; std::_Variant_raw_visit1<2>::_Visit<std::_Variant_assign_visitor<unsigned int,bool,float,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Vector3F>,std::_Variant_storage_<0,unsigned int,bool,float,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Vector3F> const &>
	mov	eax, DWORD PTR Param$35[rbp-128]
	mov	DWORD PTR [rbx+128], eax
	movzx	eax, BYTE PTR Param$35[rbp-124]
	mov	BYTE PTR [rbx+132], al
	mov	eax, DWORD PTR Param$35[rbp-120]
	mov	DWORD PTR [rbx+136], eax

; 803  :         return static_cast<size_t>(_Which);

	movsx	rax, BYTE PTR Param$35[rbp-136]

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN1912@Initialize[rcx+rax*4+4]
	add	rax, rcx
	jmp	rax
$LN930@Initialize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR Param$35[rbp-168]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN948@Initialize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR Param$35[rbp-192]
	test	rcx, rcx
	je	SHORT $LN965@Initialize

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR Param$35[rbp-176]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN983@Initialize

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN980@Initialize
$LN983@Initialize:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	movdqa	XMMWORD PTR Param$35[rbp-192], xmm0

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR Param$35[rbp-176], r13
$LN965@Initialize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR Param$35[rbp-224]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR Param$35[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 85   : 				for (int i = 0; i < Definition.InputParameters[Type].size(); i++)

	inc	r15d
	add	r14, 144				; 00000090H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR Definition$37[rbp-152]

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rbx, QWORD PTR tv9913[rbp-256]
	mov	rcx, QWORD PTR [rax+rbx*8+8]
	sub	rcx, QWORD PTR [rax+rbx*8]
	sar	rcx, 4
	mov	rax, -8198552921648689607		; 8e38e38e38e38e39H
	imul	rcx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 85   : 				for (int i = 0; i < Definition.InputParameters[Type].size(); i++)

	movsxd	rax, r15d
	cmp	rax, rcx
	mov	edx, 0
	jb	$LL16@Initialize
$LN1938@Initialize:

; 120  : 				for (int i = 0; i < Definition.OutputParameters[Type].size(); i++)

	mov	r13d, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR Definition$37[rbp-128]

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rax+rbx*8+8]
	sub	rcx, QWORD PTR [rax+rbx*8]
	sar	rcx, 3
	mov	rax, -8198552921648689607		; 8e38e38e38e38e39H
	imul	rcx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 120  : 				for (int i = 0; i < Definition.OutputParameters[Type].size(); i++)

	test	rcx, rcx
	je	$LN1907@Initialize
	mov	r12, rdx
	npad	8
$LL24@Initialize:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR Param$38[rbp-256], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR Param$38[rbp-240], rdx

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	r11d, 15
	mov	QWORD PTR Param$38[rbp-232], r11

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR Param$38[rbp-256], 0
	mov	BYTE PTR Param$38[rbp-224], 0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR Param$38[rbp-216], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR Param$38[rbp-200], rdx

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR Param$38[rbp-192], r11

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR Param$38[rbp-216], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 76   : 	this->m_Offset += 4;

	add	edi, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r9, QWORD PTR [rsi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 76   : 	this->m_Offset += 4;

	movsxd	r8, edi

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movsxd	rax, edi
	movsxd	rcx, edi
	movsxd	rdx, edi
	movzx	r10d, BYTE PTR [rax+r9-1]
	shl	r10d, 8
	movzx	eax, BYTE PTR [rcx+r9-2]
	or	r10d, eax
	shl	r10d, 8
	movzx	eax, BYTE PTR [r8+r9]
	shl	eax, 24
	or	r10d, eax
	movzx	eax, BYTE PTR [rdx+r9-3]
	or	r10d, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T12[rsp], xmm0

; 4821 :         _My_data._Mysize = 0;

	xor	ebx, ebx
	mov	QWORD PTR $T12[rsp+16], rbx

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	r14d, r11d
	mov	QWORD PTR $T12[rsp+24], r11

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T12[rsp], bl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 22   : 	return Result;

	mov	eax, DWORD PTR $T5[rsp]
	or	eax, 8
	mov	DWORD PTR $T5[rsp], eax
	mov	DWORD PTR $T26[rbp-256], eax

; 18   : 	for (int i = 0; i < Length; i++)

	test	r10d, r10d
	jle	SHORT $LN815@Initialize
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	mov	r15d, r10d
	npad	13
$LL816@Initialize:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 50   : 	this->m_Offset++;

	movsxd	rcx, edi
	inc	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3236 :         push_back(_Ch);

	movzx	r9d, BYTE PTR [rcx+rax+1]

; 4046 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	cmp	rbx, r14

; 4047 :         if (_Old_size < _Mypair._Myval2._Myres) {

	jae	SHORT $LN860@Initialize

; 4048 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 4049 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rbx+1]
	mov	QWORD PTR $T12[rsp+16], rax

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR $T12[rsp]

; 2227 :         if (_Large_string_engaged()) {

	cmp	r14, 16
	cmovae	rax, QWORD PTR $T12[rsp]

; 4051 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	BYTE PTR [rax+rbx], r9b

; 4052 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [rax+rbx+1], 0

; 4053 :             return;

	jmp	SHORT $LN814@Initialize
$LN860@Initialize:

; 4054 :         }
; 4055 : 
; 4056 :         _Reallocate_grow_by(

	lea	rcx, QWORD PTR $T12[rsp]
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
$LN814@Initialize:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 18   : 	for (int i = 0; i < Length; i++)

	sub	r15, 1
	mov	r14, QWORD PTR $T12[rsp+24]
	mov	rbx, QWORD PTR $T12[rsp+16]
	jne	SHORT $LL816@Initialize
	mov	r11d, 15
$LN815@Initialize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	movsxd	r15, edi

; 4832 :         if (_My_data._Large_string_engaged()) {

	cmp	r11, 16
	jb	SHORT $LN777@Initialize

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	lea	rdx, QWORD PTR [r11+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR Param$38[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN789@Initialize

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN786@Initialize
$LN789@Initialize:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN777@Initialize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm6, XMMWORD PTR $T12[rsp]
	movaps	XMMWORD PTR Param$38[rbp-256], xmm6
	movups	xmm0, XMMWORD PTR $T12[rsp+16]
	movaps	XMMWORD PTR Param$38[rbp-240], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 123  : 					Param.Name = ReadString(Reader);

	and	DWORD PTR $T5[rsp], -9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 76   : 	this->m_Offset += 4;

	add	edi, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r10, QWORD PTR [rsi]
	lea	eax, DWORD PTR [r15+3]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movsxd	rdx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	eax, DWORD PTR [r15+2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movsxd	rcx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	eax, DWORD PTR [r15+1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movsxd	r8, eax
	movzx	r11d, BYTE PTR [rdx+r10]
	shl	r11d, 8
	movzx	eax, BYTE PTR [rcx+r10]
	or	r11d, eax
	shl	r11d, 8
	movzx	eax, BYTE PTR [r15+r10+4]
	shl	eax, 24
	or	r11d, eax
	movzx	eax, BYTE PTR [r8+r10]
	or	r11d, eax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T11[rsp], xmm0

; 4821 :         _My_data._Mysize = 0;

	xor	edx, edx
	mov	QWORD PTR $T11[rsp+16], rdx

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	eax, 15
	mov	r8d, eax
	mov	QWORD PTR $T11[rsp+24], rax

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T11[rsp], dl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 22   : 	return Result;

	mov	ecx, DWORD PTR $T5[rsp]
	or	ecx, 4
	mov	DWORD PTR $T5[rsp], ecx
	mov	DWORD PTR $T26[rbp-256], ecx

; 18   : 	for (int i = 0; i < Length; i++)

	test	r11d, r11d
	jle	SHORT $LN1940@Initialize
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	mov	r15d, r11d
	npad	5
$LL685@Initialize:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 50   : 	this->m_Offset++;

	movsxd	rcx, edi
	inc	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3236 :         push_back(_Ch);

	movzx	r9d, BYTE PTR [rcx+rax+1]

; 4046 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	cmp	rdx, r8

; 4047 :         if (_Old_size < _Mypair._Myval2._Myres) {

	jae	SHORT $LN729@Initialize

; 4048 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 4049 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rdx+1]
	mov	QWORD PTR $T11[rsp+16], rax

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR $T11[rsp]

; 2227 :         if (_Large_string_engaged()) {

	cmp	r8, 16
	cmovae	rax, QWORD PTR $T11[rsp]

; 4051 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	BYTE PTR [rax+rdx], r9b

; 4052 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [rax+rdx+1], 0

; 4053 :             return;

	jmp	SHORT $LN683@Initialize
$LN729@Initialize:

; 4054 :         }
; 4055 : 
; 4056 :         _Reallocate_grow_by(

	lea	rcx, QWORD PTR $T11[rsp]
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
$LN683@Initialize:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 18   : 	for (int i = 0; i < Length; i++)

	sub	r15, 1
	je	SHORT $LN1944@Initialize
	mov	r8, QWORD PTR $T11[rsp+24]
	mov	rdx, QWORD PTR $T11[rsp+16]
	jmp	SHORT $LL685@Initialize
$LN1944@Initialize:
	mov	ecx, DWORD PTR $T5[rsp]
$LN1940@Initialize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movsxd	rax, edi
	movups	xmm0, XMMWORD PTR $T11[rsp]
	movups	XMMWORD PTR Param$38[rbp-216], xmm0
	movups	xmm1, XMMWORD PTR $T11[rsp+16]
	movups	XMMWORD PTR Param$38[rbp-200], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 124  : 					Param.Class = ReadString(Reader);

	and	ecx, -5
	mov	DWORD PTR $T5[rsp], ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 44   : 	this->m_Offset++;

	inc	edi
	mov	DWORD PTR Reader$23[rsp+8], edi
	mov	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rsi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 125  : 					Param.SetPointerFlagsBitZero = (bool)Reader.ReadUInt8();

	cmp	BYTE PTR [rcx+rax+1], 0
	setne	cl
	mov	BYTE PTR Param$38[rbp-224], cl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR Definition$37[rbp-128]
	mov	rdx, QWORD PTR tv9913[rbp-256]
	mov	r15, QWORD PTR [rax+rdx*8]
	add	r15, r12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3156 :         if (this == _STD addressof(_Right)) {

	lea	rax, QWORD PTR Param$38[rbp-256]
	cmp	r15, rax
	je	SHORT $LN610@Initialize

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR Param$38[rbp-256]

; 2236 :         if (_Large_string_engaged()) {

	movq	rax, xmm6
	cmp	r14, 16
	cmovae	rdx, rax

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, rbx
	mov	rcx, r15
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	movzx	ecx, BYTE PTR Param$38[rbp-224]
$LN610@Initialize:
	mov	BYTE PTR [r15+32], cl
	lea	rcx, QWORD PTR [r15+40]

; 3156 :         if (this == _STD addressof(_Right)) {

	lea	rax, QWORD PTR Param$38[rbp-216]
	cmp	rcx, rax
	je	SHORT $LN618@Initialize

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR Param$38[rbp-216]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR Param$38[rbp-192], 16
	cmovae	rdx, QWORD PTR Param$38[rbp-216]

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR Param$38[rbp-200]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
$LN618@Initialize:

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR Param$38[rbp-216]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR Param$38[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 120  : 				for (int i = 0; i < Definition.OutputParameters[Type].size(); i++)

	inc	r13d
	add	r12, 72					; 00000048H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR Definition$37[rbp-128]

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rbx, QWORD PTR tv9913[rbp-256]
	mov	rcx, QWORD PTR [rax+rbx*8+8]
	sub	rcx, QWORD PTR [rax+rbx*8]
	sar	rcx, 3
	mov	rax, -8198552921648689607		; 8e38e38e38e38e39H
	imul	rcx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 120  : 				for (int i = 0; i < Definition.OutputParameters[Type].size(); i++)

	movsxd	rax, r13d
	cmp	rax, rcx
	mov	edx, 0
	jb	$LL24@Initialize
	mov	r12d, DWORD PTR $T5[rsp]
$LN1907@Initialize:

; 129  : 				for (int i = 0; i < Definition.ImmediateParameters[Type].size(); i++)

	mov	r15d, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR Definition$37[rbp-176]

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rax+rbx*8+8]
	sub	rcx, QWORD PTR [rax+rbx*8]
	sar	rcx, 5
	mov	rax, -6148914691236517205		; aaaaaaaaaaaaaaabH
	imul	rcx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 129  : 				for (int i = 0; i < Definition.ImmediateParameters[Type].size(); i++)

	test	rcx, rcx
	je	$LN11@Initialize
	mov	r14, rdx
	mov	r13, QWORD PTR tv9913[rbp-256]
	jmp	SHORT $LN27@Initialize
$LL1947@Initialize:
	xor	edx, edx
$LN27@Initialize:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR Param$36[rbp-256], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR Param$36[rbp-240], rdx

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	ebx, 15
	mov	r11d, ebx
	mov	QWORD PTR Param$36[rbp-232], rbx

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR Param$36[rbp-256], 0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR Param$36[rbp-216], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR Param$36[rbp-200], rdx

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR Param$36[rbp-192], rbx

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR Param$36[rbp-216], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR Param$36[rbp-184], rdx
	movdqa	XMMWORD PTR Param$36[rbp-176], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 76   : 	this->m_Offset += 4;

	add	edi, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r9, QWORD PTR [rsi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 76   : 	this->m_Offset += 4;

	movsxd	r8, edi

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movsxd	rax, edi
	movsxd	rcx, edi
	movsxd	rdx, edi
	movzx	r10d, BYTE PTR [rax+r9-1]
	shl	r10d, 8
	movzx	eax, BYTE PTR [rcx+r9-2]
	or	r10d, eax
	shl	r10d, 8
	movzx	eax, BYTE PTR [r8+r9]
	shl	eax, 24
	or	r10d, eax
	movzx	eax, BYTE PTR [rdx+r9-3]
	or	r10d, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T10[rsp], xmm0

; 4821 :         _My_data._Mysize = 0;

	xor	edx, edx
	mov	QWORD PTR $T10[rsp+16], rdx

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	r8d, ebx
	mov	QWORD PTR $T10[rsp+24], rbx

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T10[rsp], dl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 22   : 	return Result;

	or	r12d, 1
	mov	DWORD PTR $T26[rbp-256], r12d

; 18   : 	for (int i = 0; i < Length; i++)

	test	r10d, r10d
	jle	SHORT $LN297@Initialize
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	mov	ebx, r10d
	npad	7
$LL298@Initialize:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 50   : 	this->m_Offset++;

	movsxd	rcx, edi
	inc	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3236 :         push_back(_Ch);

	movzx	r9d, BYTE PTR [rcx+rax+1]

; 4046 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	cmp	rdx, r8

; 4047 :         if (_Old_size < _Mypair._Myval2._Myres) {

	jae	SHORT $LN342@Initialize

; 4048 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 4049 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rdx+1]
	mov	QWORD PTR $T10[rsp+16], rax

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR $T10[rsp]

; 2227 :         if (_Large_string_engaged()) {

	cmp	r8, 16
	cmovae	rax, QWORD PTR $T10[rsp]

; 4051 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	BYTE PTR [rax+rdx], r9b

; 4052 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [rax+rdx+1], 0

; 4053 :             return;

	jmp	SHORT $LN296@Initialize
$LN342@Initialize:

; 4054 :         }
; 4055 : 
; 4056 :         _Reallocate_grow_by(

	lea	rcx, QWORD PTR $T10[rsp]
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
$LN296@Initialize:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 18   : 	for (int i = 0; i < Length; i++)

	sub	rbx, 1
	je	SHORT $LN1941@Initialize
	mov	r8, QWORD PTR $T10[rsp+24]
	mov	rdx, QWORD PTR $T10[rsp+16]
	jmp	SHORT $LL298@Initialize
$LN1941@Initialize:
	mov	r11, QWORD PTR Param$36[rbp-232]
$LN297@Initialize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	movsxd	rbx, edi

; 4832 :         if (_My_data._Large_string_engaged()) {

	cmp	r11, 16
	jb	SHORT $LN529@Initialize

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	lea	rdx, QWORD PTR [r11+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR Param$36[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN541@Initialize

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN538@Initialize
$LN541@Initialize:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN529@Initialize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR $T10[rsp]
	movaps	XMMWORD PTR Param$36[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR $T10[rsp+16]
	movaps	XMMWORD PTR Param$36[rbp-240], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 132  : 					Param.Name = ReadString(Reader);

	and	r12d, -2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 76   : 	this->m_Offset += 4;

	add	edi, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r10, QWORD PTR [rsi]
	lea	eax, DWORD PTR [rbx+3]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movsxd	rdx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	eax, DWORD PTR [rbx+2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movsxd	rcx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	eax, DWORD PTR [rbx+1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movsxd	r8, eax
	movzx	r11d, BYTE PTR [rdx+r10]
	shl	r11d, 8
	movzx	eax, BYTE PTR [rcx+r10]
	or	r11d, eax
	shl	r11d, 8
	movzx	eax, BYTE PTR [rbx+r10+4]
	shl	eax, 24
	or	r11d, eax
	movzx	eax, BYTE PTR [r8+r10]
	or	r11d, eax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T9[rsp], xmm0

; 4821 :         _My_data._Mysize = 0;

	xor	edx, edx
	mov	QWORD PTR $T9[rsp+16], rdx

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	eax, 15
	mov	r8d, eax
	mov	QWORD PTR $T9[rsp+24], rax

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T9[rsp], dl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 22   : 	return Result;

	or	r12d, 2
	mov	DWORD PTR $T26[rbp-256], r12d

; 18   : 	for (int i = 0; i < Length; i++)

	test	r11d, r11d
	jle	SHORT $LN1942@Initialize
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	mov	ebx, r11d
	npad	12
$LL437@Initialize:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 50   : 	this->m_Offset++;

	movsxd	rcx, edi
	inc	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3236 :         push_back(_Ch);

	movzx	r9d, BYTE PTR [rcx+rax+1]

; 4046 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	cmp	rdx, r8

; 4047 :         if (_Old_size < _Mypair._Myval2._Myres) {

	jae	SHORT $LN481@Initialize

; 4048 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 4049 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rdx+1]
	mov	QWORD PTR $T9[rsp+16], rax

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR $T9[rsp]

; 2227 :         if (_Large_string_engaged()) {

	cmp	r8, 16
	cmovae	rax, QWORD PTR $T9[rsp]

; 4051 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	BYTE PTR [rax+rdx], r9b

; 4052 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [rax+rdx+1], 0

; 4053 :             return;

	jmp	SHORT $LN435@Initialize
$LN481@Initialize:

; 4054 :         }
; 4055 : 
; 4056 :         _Reallocate_grow_by(

	lea	rcx, QWORD PTR $T9[rsp]
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
$LN435@Initialize:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 18   : 	for (int i = 0; i < Length; i++)

	sub	rbx, 1
	je	SHORT $LN1942@Initialize
	mov	r8, QWORD PTR $T9[rsp+24]
	mov	rdx, QWORD PTR $T9[rsp+16]
	jmp	SHORT $LL437@Initialize
$LN1942@Initialize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	movsxd	rbx, edi

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR Param$36[rbp-192]
	cmp	rdx, 16
	jb	SHORT $LN398@Initialize

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR Param$36[rbp-216]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN410@Initialize

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN407@Initialize
$LN410@Initialize:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN398@Initialize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR $T9[rsp]
	movups	XMMWORD PTR Param$36[rbp-216], xmm0
	movups	xmm1, XMMWORD PTR $T9[rsp+16]
	movups	XMMWORD PTR Param$36[rbp-200], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 133  : 					Param.Class = ReadString(Reader);

	and	r12d, -3
	mov	DWORD PTR $T5[rsp], r12d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rsi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 134  : 					Param.ValueType = (AINBFile::ValueType)Reader.ReadUInt8();

	movzx	eax, BYTE PTR [rbx+rax+1]
	mov	DWORD PTR Param$36[rbp-224], eax
	lea	edi, DWORD PTR [rbx+2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 44   : 	this->m_Offset++;

	mov	DWORD PTR Reader$23[rsp+8], edi
	movsxd	rax, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR [rsi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 136  : 					for (int k = 0; k < FlagsSize; k++)

	movzx	ecx, BYTE PTR [rax]
	test	ecx, ecx
	je	SHORT $LN29@Initialize
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	mov	ebx, ecx
	mov	rdx, QWORD PTR Param$36[rbp-176]
$LL30@Initialize:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 44   : 	this->m_Offset++;

	movsxd	rcx, edi
	inc	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rsi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 138  : 						Param.Flags.push_back((AINBFile::FlagsStruct)Reader.ReadUInt8());

	movzx	r8d, BYTE PTR [rcx+rax+1]
	mov	BYTE PTR $T1[rsp], r8b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	cmp	rdx, QWORD PTR Param$36[rbp-168]
	je	SHORT $LN90@Initialize

; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	BYTE PTR [rdx], r8b

; 806  :         ++_Mylast;

	mov	rdx, QWORD PTR Param$36[rbp-176]
	inc	rdx
	mov	QWORD PTR Param$36[rbp-176], rdx

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN28@Initialize
$LN90@Initialize:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR Param$36[rbp-184]
	call	??$_Emplace_reallocate@W4FlagsStruct@AINBFile@@@?$vector@W4FlagsStruct@AINBFile@@V?$allocator@W4FlagsStruct@AINBFile@@@std@@@std@@AEAAPEAW4FlagsStruct@AINBFile@@QEAW423@$$QEAW423@@Z ; std::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >::_Emplace_reallocate<enum AINBFile::FlagsStruct>
	mov	rdx, QWORD PTR Param$36[rbp-176]
$LN28@Initialize:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 136  : 					for (int k = 0; k < FlagsSize; k++)

	sub	rbx, 1
	jne	SHORT $LL30@Initialize
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 44   : 	this->m_Offset++;

	mov	DWORD PTR Reader$23[rsp+8], edi
$LN29@Initialize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR Definition$37[rbp-176]
	mov	rbx, QWORD PTR [rax+r13*8]
	add	rbx, r14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3156 :         if (this == _STD addressof(_Right)) {

	lea	rax, QWORD PTR Param$36[rbp-256]
	cmp	rbx, rax
	je	SHORT $LN205@Initialize

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR Param$36[rbp-256]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR Param$36[rbp-232], 16
	cmovae	rdx, QWORD PTR Param$36[rbp-256]

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR Param$36[rbp-240]
	mov	rcx, rbx
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN205@Initialize:
	mov	eax, DWORD PTR Param$36[rbp-224]
	mov	DWORD PTR [rbx+32], eax
	lea	rcx, QWORD PTR [rbx+40]

; 3156 :         if (this == _STD addressof(_Right)) {

	lea	rax, QWORD PTR Param$36[rbp-216]
	cmp	rcx, rax
	je	SHORT $LN213@Initialize

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR Param$36[rbp-216]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR Param$36[rbp-192], 16
	cmovae	rdx, QWORD PTR Param$36[rbp-216]

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR Param$36[rbp-200]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN213@Initialize:
	lea	rcx, QWORD PTR [rbx+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1483 :         if (this == _STD addressof(_Right)) {

	lea	rax, QWORD PTR Param$36[rbp-184]
	cmp	rcx, rax
	je	SHORT $LN221@Initialize

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	r8, QWORD PTR Param$36[rbp-176]
	mov	rdx, QWORD PTR Param$36[rbp-184]
	sub	r8, rdx
	call	??$_Assign_counted_range@PEAW4FlagsStruct@AINBFile@@@?$vector@W4FlagsStruct@AINBFile@@V?$allocator@W4FlagsStruct@AINBFile@@@std@@@std@@AEAAXPEAW4FlagsStruct@AINBFile@@_K@Z ; std::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >::_Assign_counted_range<enum AINBFile::FlagsStruct *>
	npad	1
$LN221@Initialize:

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR Param$36[rbp-184]
	test	rcx, rcx
	je	SHORT $LN173@Initialize

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR Param$36[rbp-168]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN191@Initialize

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN188@Initialize
$LN191@Initialize:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	mov	QWORD PTR Param$36[rbp-184], 0
	xorps	xmm0, xmm0

; 2050 :             _Mylast  = nullptr;

	movdqa	XMMWORD PTR Param$36[rbp-176], xmm0
$LN173@Initialize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR Param$36[rbp-216]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR Param$36[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 129  : 				for (int i = 0; i < Definition.ImmediateParameters[Type].size(); i++)

	inc	r15d
	add	r14, 96					; 00000060H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR Definition$37[rbp-176]

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rax+r13*8+8]
	sub	rcx, QWORD PTR [rax+r13*8]
	sar	rcx, 5
	mov	rax, -6148914691236517205		; aaaaaaaaaaaaaaabH
	imul	rcx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 129  : 				for (int i = 0; i < Definition.ImmediateParameters[Type].size(); i++)

	movsxd	rax, r15d
	cmp	rax, rcx
	jb	$LL1947@Initialize
$LN11@Initialize:

; 82   : 			}
; 83   : 			for (int Type = 0; Type < AINBFile::ValueTypeCount; Type++)

	mov	edx, DWORD PTR Type$1$[rbp-256]
	inc	edx
	mov	DWORD PTR Type$1$[rbp-256], edx
	mov	rax, QWORD PTR $T30[rbp-256]
	inc	rax
	mov	QWORD PTR $T30[rbp-256], rax
	cmp	edx, 6
	mov	r13, -8198552921648689607		; 8e38e38e38e38e39H
	jb	$LL1948@Initialize

; 143  : 			for (int i = 0; i < LinkedNodeParamCount; i++)

	movzx	eax, BYTE PTR LinkedNodeParamCount$1$[rsp]
	test	eax, eax
	je	$LN32@Initialize
	mov	ebx, eax
$LL33@Initialize:

; 144  : 			{
; 145  : 				Definition.LinkedNodeParams.push_back(ReadString(Reader));

	lea	rdx, QWORD PTR Reader$23[rsp]
	lea	rcx, QWORD PTR $T8[rsp]
	call	?ReadString@AINBNodeDefMgr@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@@Z ; AINBNodeDefMgr::ReadString
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR Definition$37[rbp-96]
	cmp	rdx, QWORD PTR Definition$37[rbp-88]
	je	SHORT $LN1171@Initialize
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rdx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	ecx, ecx
	mov	QWORD PTR [rdx+16], rcx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rdx+24], rcx

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR [rdx], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR [rdx+16], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rax+16], rcx

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rax+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rax], cl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 806  :         ++_Mylast;

	add	QWORD PTR Definition$37[rbp-96], 32	; 00000020H

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN1170@Initialize
$LN1171@Initialize:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	r8, rax
	lea	rcx, QWORD PTR Definition$37[rbp-104]
	call	??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@$$QEAV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	npad	1
$LN1170@Initialize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	r8, QWORD PTR $T8[rsp+24]
	cmp	r8, 16
	jb	SHORT $LN1164@Initialize

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	r8
	mov	rdx, QWORD PTR $T8[rsp]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
$LN1164@Initialize:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 143  : 			for (int i = 0; i < LinkedNodeParamCount; i++)

	sub	rbx, 1
	jne	$LL33@Initialize
	mov	edi, DWORD PTR Reader$23[rsp+8]
	mov	rsi, QWORD PTR Reader$23[rsp]
$LN32@Initialize:

; 147  : 			for (int i = 0; i < FileNameCount; i++)

	movzx	eax, BYTE PTR FileNameCount$1$[rsp]
	test	eax, eax
	je	$LN35@Initialize
	mov	ebx, eax
$LL36@Initialize:

; 148  : 			{
; 149  : 				Definition.FileNames.push_back(ReadString(Reader));

	lea	rdx, QWORD PTR Reader$23[rsp]
	lea	rcx, QWORD PTR $T7[rsp]
	call	?ReadString@AINBNodeDefMgr@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@@Z ; AINBNodeDefMgr::ReadString
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR Definition$37[rbp-72]
	cmp	rdx, QWORD PTR Definition$37[rbp-64]
	je	SHORT $LN1053@Initialize
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rdx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	ecx, ecx
	mov	QWORD PTR [rdx+16], rcx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rdx+24], rcx

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR [rdx], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR [rdx+16], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rax+16], rcx

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rax+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rax], cl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 806  :         ++_Mylast;

	add	QWORD PTR Definition$37[rbp-72], 32	; 00000020H

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN1052@Initialize
$LN1053@Initialize:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	r8, rax
	lea	rcx, QWORD PTR Definition$37[rbp-80]
	call	??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@$$QEAV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	npad	1
$LN1052@Initialize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	r8, QWORD PTR $T7[rsp+24]
	cmp	r8, 16
	jb	SHORT $LN1127@Initialize

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	r8
	mov	rdx, QWORD PTR $T7[rsp]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
$LN1127@Initialize:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 147  : 			for (int i = 0; i < FileNameCount; i++)

	sub	rbx, 1
	jne	$LL36@Initialize
	mov	edi, DWORD PTR Reader$23[rsp+8]
	mov	rsi, QWORD PTR Reader$23[rsp]
$LN35@Initialize:

; 151  : 			for (int i = 0; i < FlagCount; i++)

	movzx	eax, BYTE PTR FlagCount$1$[rsp]
	test	eax, eax
	je	SHORT $LN38@Initialize
	mov	ebx, eax
	mov	rdx, QWORD PTR Definition$37[rbp-48]
	npad	12
$LL39@Initialize:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 44   : 	this->m_Offset++;

	inc	edi
	movsxd	rax, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR [rsi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 153  : 				Definition.Flags.push_back((AINBFile::FlagsStruct)Reader.ReadUInt8());

	movzx	ecx, BYTE PTR [rax]
	mov	BYTE PTR $T3[rsp], cl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	cmp	rdx, QWORD PTR Definition$37[rbp-40]
	je	SHORT $LN287@Initialize

; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	BYTE PTR [rdx], cl

; 806  :         ++_Mylast;

	mov	rdx, QWORD PTR Definition$37[rbp-48]
	inc	rdx
	mov	QWORD PTR Definition$37[rbp-48], rdx

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN37@Initialize
$LN287@Initialize:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T3[rsp]
	lea	rcx, QWORD PTR Definition$37[rbp-56]
	call	??$_Emplace_reallocate@W4FlagsStruct@AINBFile@@@?$vector@W4FlagsStruct@AINBFile@@V?$allocator@W4FlagsStruct@AINBFile@@@std@@@std@@AEAAPEAW4FlagsStruct@AINBFile@@QEAW423@$$QEAW423@@Z ; std::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >::_Emplace_reallocate<enum AINBFile::FlagsStruct>
	mov	rdx, QWORD PTR Definition$37[rbp-48]
$LN37@Initialize:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 151  : 			for (int i = 0; i < FlagCount; i++)

	sub	rbx, 1
	jne	SHORT $LL39@Initialize
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 44   : 	this->m_Offset++;

	mov	DWORD PTR Reader$23[rsp+8], edi
$LN38@Initialize:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 155  : 			for (int i = 0; i < AllowedAINBCount; i++)

	movzx	eax, BYTE PTR AllowedAINBCount$1$[rsp]
	test	eax, eax
	je	SHORT $LN41@Initialize
	mov	ebx, eax
	mov	rdx, QWORD PTR Definition$37[rbp-24]
$LL42@Initialize:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 44   : 	this->m_Offset++;

	inc	edi
	movsxd	rax, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR [rsi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 157  : 				Definition.AllowedAINBCategories.push_back((AINBNodeDefMgr::NodeDef::CategoryEnum)Reader.ReadUInt8());

	movzx	ecx, BYTE PTR [rax]
	mov	BYTE PTR $T4[rsp], cl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	cmp	rdx, QWORD PTR Definition$37[rbp-16]
	je	SHORT $LN239@Initialize

; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	BYTE PTR [rdx], cl

; 806  :         ++_Mylast;

	mov	rdx, QWORD PTR Definition$37[rbp-24]
	inc	rdx
	mov	QWORD PTR Definition$37[rbp-24], rdx

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN40@Initialize
$LN239@Initialize:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T4[rsp]
	lea	rcx, QWORD PTR Definition$37[rbp-32]
	call	??$_Emplace_reallocate@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@QEAW4234@$$QEAW4234@@Z ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Emplace_reallocate<enum AINBNodeDefMgr::NodeDef::CategoryEnum>
	mov	rdx, QWORD PTR Definition$37[rbp-24]
$LN40@Initialize:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 155  : 			for (int i = 0; i < AllowedAINBCount; i++)

	sub	rbx, 1
	jne	SHORT $LL42@Initialize
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 44   : 	this->m_Offset++;

	mov	DWORD PTR Reader$23[rsp+8], edi
$LN41@Initialize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r14, QWORD PTR $T27[rbp-256]
	imul	rbx, r14, 248				; 000000f8H
	add	rbx, QWORD PTR ?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A
	movzx	eax, BYTE PTR Definition$37[rbp-256]
	mov	BYTE PTR [rbx], al
	lea	rcx, QWORD PTR [rbx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3156 :         if (this == _STD addressof(_Right)) {

	lea	rax, QWORD PTR Definition$37[rbp-248]
	cmp	rcx, rax
	je	SHORT $LN247@Initialize

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR Definition$37[rbp-248]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR Definition$37[rbp-224], 16
	cmovae	rdx, QWORD PTR Definition$37[rbp-248]

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR Definition$37[rbp-232]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN247@Initialize:
	lea	rcx, QWORD PTR [rbx+40]

; 3156 :         if (this == _STD addressof(_Right)) {

	lea	rax, QWORD PTR Definition$37[rbp-216]
	cmp	rcx, rax
	je	SHORT $LN255@Initialize

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR Definition$37[rbp-216]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR Definition$37[rbp-192], 16
	cmovae	rdx, QWORD PTR Definition$37[rbp-216]

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR Definition$37[rbp-200]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN255@Initialize:
	mov	eax, DWORD PTR Definition$37[rbp-184]
	mov	DWORD PTR [rbx+72], eax
	movzx	eax, WORD PTR Definition$37[rbp-180]
	mov	WORD PTR [rbx+76], ax
	lea	rcx, QWORD PTR [rbx+80]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1483 :         if (this == _STD addressof(_Right)) {

	lea	rax, QWORD PTR Definition$37[rbp-176]
	mov	r15, -6148914691236517205		; aaaaaaaaaaaaaaabH
	cmp	rcx, rax
	je	SHORT $LN263@Initialize

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	r8, QWORD PTR Definition$37[rbp-168]
	mov	rdx, QWORD PTR Definition$37[rbp-176]
	sub	r8, rdx
	sar	r8, 3
	imul	r8, r15
	call	??$_Assign_counted_range@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@_K@Z ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Assign_counted_range<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *>
$LN263@Initialize:
	lea	rcx, QWORD PTR [rbx+104]

; 1483 :         if (this == _STD addressof(_Right)) {

	lea	rax, QWORD PTR Definition$37[rbp-152]
	cmp	rcx, rax
	je	SHORT $LN266@Initialize

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	r8, QWORD PTR Definition$37[rbp-144]
	mov	rdx, QWORD PTR Definition$37[rbp-152]
	sub	r8, rdx
	sar	r8, 3
	imul	r8, r15
	call	??$_Assign_counted_range@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@_K@Z ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Assign_counted_range<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > *>
$LN266@Initialize:
	lea	rcx, QWORD PTR [rbx+128]

; 1483 :         if (this == _STD addressof(_Right)) {

	lea	rax, QWORD PTR Definition$37[rbp-128]
	cmp	rcx, rax
	je	SHORT $LN269@Initialize

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	r8, QWORD PTR Definition$37[rbp-120]
	mov	rdx, QWORD PTR Definition$37[rbp-128]
	sub	r8, rdx
	sar	r8, 3
	imul	r8, r15
	call	??$_Assign_counted_range@PEAV?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@@?$vector@V?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@V?$allocator@V?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@@2@@std@@AEAAXPEAV?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@1@_K@Z ; std::vector<std::vector<AINBFile::OutputEntry,std::allocator<AINBFile::OutputEntry> >,std::allocator<std::vector<AINBFile::OutputEntry,std::allocator<AINBFile::OutputEntry> > > >::_Assign_counted_range<std::vector<AINBFile::OutputEntry,std::allocator<AINBFile::OutputEntry> > *>
$LN269@Initialize:
	lea	rcx, QWORD PTR [rbx+152]

; 1483 :         if (this == _STD addressof(_Right)) {

	lea	rax, QWORD PTR Definition$37[rbp-104]
	cmp	rcx, rax
	je	SHORT $LN272@Initialize

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	r8, QWORD PTR Definition$37[rbp-96]
	mov	rdx, QWORD PTR Definition$37[rbp-104]
	sub	r8, rdx
	sar	r8, 5
	call	??$_Assign_counted_range@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Assign_counted_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
$LN272@Initialize:
	lea	rcx, QWORD PTR [rbx+176]

; 1483 :         if (this == _STD addressof(_Right)) {

	lea	rax, QWORD PTR Definition$37[rbp-80]
	cmp	rcx, rax
	je	SHORT $LN275@Initialize

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	r8, QWORD PTR Definition$37[rbp-72]
	mov	rdx, QWORD PTR Definition$37[rbp-80]
	sub	r8, rdx
	sar	r8, 5
	call	??$_Assign_counted_range@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Assign_counted_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
$LN275@Initialize:
	lea	rcx, QWORD PTR [rbx+200]

; 1483 :         if (this == _STD addressof(_Right)) {

	lea	rax, QWORD PTR Definition$37[rbp-56]
	cmp	rcx, rax
	je	SHORT $LN278@Initialize

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	r8, QWORD PTR Definition$37[rbp-48]
	mov	rdx, QWORD PTR Definition$37[rbp-56]
	sub	r8, rdx
	call	??$_Assign_counted_range@PEAW4FlagsStruct@AINBFile@@@?$vector@W4FlagsStruct@AINBFile@@V?$allocator@W4FlagsStruct@AINBFile@@@std@@@std@@AEAAXPEAW4FlagsStruct@AINBFile@@_K@Z ; std::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >::_Assign_counted_range<enum AINBFile::FlagsStruct *>
$LN278@Initialize:
	lea	rcx, QWORD PTR [rbx+224]

; 1483 :         if (this == _STD addressof(_Right)) {

	lea	rax, QWORD PTR Definition$37[rbp-32]
	cmp	rcx, rax
	je	SHORT $LN281@Initialize

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	r8, QWORD PTR Definition$37[rbp-24]
	mov	rdx, QWORD PTR Definition$37[rbp-32]
	sub	r8, rdx
	call	??$_Assign_counted_range@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_K@Z ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Assign_counted_range<enum AINBNodeDefMgr::NodeDef::CategoryEnum *>
	npad	1
$LN281@Initialize:

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR Definition$37[rbp-32]
	test	rcx, rcx
	je	SHORT $LN100@Initialize

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR Definition$37[rbp-16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN118@Initialize

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN142@Initialize
$LN118@Initialize:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	movdqa	XMMWORD PTR Definition$37[rbp-32], xmm0

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR Definition$37[rbp-16], 0
$LN100@Initialize:

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR Definition$37[rbp-56]
	test	rcx, rcx
	je	SHORT $LN127@Initialize

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR Definition$37[rbp-40]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN145@Initialize

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN142@Initialize
$LN145@Initialize:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	mov	QWORD PTR Definition$37[rbp-56], 0
	xorps	xmm0, xmm0

; 2050 :             _Mylast  = nullptr;

	movdqa	XMMWORD PTR Definition$37[rbp-48], xmm0
$LN127@Initialize:

; 767  :         _Tidy();

	lea	rcx, QWORD PTR Definition$37[rbp-80]
	call	?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
	lea	rcx, QWORD PTR Definition$37[rbp-104]
	call	?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
	lea	rcx, QWORD PTR Definition$37[rbp-128]
	call	?_Tidy@?$vector@V?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@V?$allocator@V?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@@2@@std@@AEAAXXZ ; std::vector<std::vector<AINBFile::OutputEntry,std::allocator<AINBFile::OutputEntry> >,std::allocator<std::vector<AINBFile::OutputEntry,std::allocator<AINBFile::OutputEntry> > > >::_Tidy
	lea	rcx, QWORD PTR Definition$37[rbp-152]
	call	?_Tidy@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXXZ ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Tidy
	lea	rcx, QWORD PTR Definition$37[rbp-176]
	call	?_Tidy@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXXZ ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR Definition$37[rbp-216]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR Definition$37[rbp-248]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 59   : 		for (int j = 0; j < AINBNodeDefMgr::NodeDefinitions.size(); j++)

	mov	ebx, DWORD PTR j$1$[rbp-256]
	inc	ebx
	mov	DWORD PTR j$1$[rbp-256], ebx
	inc	r14
	mov	QWORD PTR $T27[rbp-256], r14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR ?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A+8
	sub	rcx, QWORD PTR ?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A
	sar	rcx, 3
	mov	rax, -1190112520884487201		; ef7bdef7bdef7bdfH
	imul	rcx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 59   : 		for (int j = 0; j < AINBNodeDefMgr::NodeDefinitions.size(); j++)

	movsxd	rax, ebx
	cmp	rax, rcx
	jae	SHORT $LN1909@Initialize
	jmp	$LN1953@Initialize
$LN1664@Initialize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

$LN1588@Initialize:
$LN1388@Initialize:
$LN980@Initialize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN943@Initialize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

$LN1512@Initialize:
$LN786@Initialize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN538@Initialize:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN407@Initialize:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN188@Initialize:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN142@Initialize:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN1925@Initialize:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 59   : 		for (int j = 0; j < AINBNodeDefMgr::NodeDefinitions.size(); j++)

	mov	edi, DWORD PTR Reader$23[rsp+8]
	mov	rsi, QWORD PTR Reader$23[rsp]
$LN1909@Initialize:

; 162  : 		std::vector<unsigned char> EXBBytes(Reader.GetSize() - Reader.GetPosition());

	lea	rcx, QWORD PTR EXBBytes$41[rbp-256]
	call	?__autoclassinit2@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [rsi+8]
	sub	rdx, QWORD PTR [rsi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 162  : 		std::vector<unsigned char> EXBBytes(Reader.GetSize() - Reader.GetPosition());

	sub	edx, edi
	dec	edx
	lea	rcx, QWORD PTR EXBBytes$41[rbp-256]
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@_KAEBV?$allocator@E@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r8, QWORD PTR [rsi+8]
	sub	r8, QWORD PTR [rsi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 163  : 		Reader.ReadStruct(EXBBytes.data(), Reader.GetSize() - Reader.GetPosition());

	sub	r8d, edi
	dec	r8d
	mov	rdx, QWORD PTR EXBBytes$41[rbp-256]
	lea	rcx, QWORD PTR Reader$23[rsp]
	call	?ReadStruct@BinaryVectorReader@@QEAAXPEAXIH@Z ; BinaryVectorReader::ReadStruct

; 164  : 		EXBFile = EXB(EXBBytes);

	lea	rdx, QWORD PTR EXBBytes$41[rbp-256]
	lea	rcx, QWORD PTR $T21[rsp]
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	mov	rdx, rax
	lea	rcx, QWORD PTR $T34[rbp-256]
	call	??0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z ; EXB::EXB
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:?EXBFile@AINBNodeDefMgr@@3VEXB@@A ; AINBNodeDefMgr::EXBFile
	call	??4EXB@@QEAAAEAV0@$$QEAV0@@Z
	lea	rcx, QWORD PTR $T34[rbp-256]
	call	??1EXB@@QEAA@XZ

; 165  : 
; 166  : 		Logger::Info("AINBNodeDefMgr", "Initialized, found " + std::to_string(AINBNodeDefMgr::NodeDefinitions.size()) + " nodes");

	lea	rax, QWORD PTR $T6[rsp]
	mov	QWORD PTR $T28[rbp-256], rax
	call	?size@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::size
	mov	rdx, rax
	lea	rcx, QWORD PTR $T33[rbp-256]
	call	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z ; std::to_string
	npad	1
	mov	r8, rax
	lea	rdx, OFFSET FLAT:??_C@_0BE@HBEOMHFO@Initialized?0?5found?5@
	lea	rcx, QWORD PTR $T32[rbp-256]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	r8, OFFSET FLAT:??_C@_06HKPINEAB@?5nodes@
	mov	rdx, rax
	lea	rcx, QWORD PTR $T6[rsp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	mov	rbx, rax
	lea	rdx, OFFSET FLAT:??_C@_0P@NFEGPIHE@AINBNodeDefMgr@
	lea	rcx, QWORD PTR $T20[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rdx, rbx
	mov	rcx, rax
	call	?Info@Logger@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; Logger::Info
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T32[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1
	lea	rcx, QWORD PTR $T33[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 167  : 	}

	lea	rcx, QWORD PTR EXBBytes$41[rbp-256]
	call	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
	npad	1
	lea	rcx, QWORD PTR Offsets$42[rbp-256]
	call	??1?$vector@IV?$allocator@I@std@@@std@@QEAA@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
	npad	1
$LN1951@Initialize:

; 168  : }

	lea	rcx, QWORD PTR Bytes$39[rbp-256]
	call	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
	npad	1
$LN43@Initialize:
	lea	rcx, QWORD PTR File$[rbp-256]
	call	??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+1344]
	mov	rbx, QWORD PTR [r11+48]
	mov	rsi, QWORD PTR [r11+56]
	mov	rdi, QWORD PTR [r11+64]
	movaps	xmm6, XMMWORD PTR [r11-16]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
$LN1950@Initialize:
$LN1916@Initialize:
	DD	$LN1669@Initialize
	DD	$LN1669@Initialize
	DD	$LN1669@Initialize
	DD	$LN1669@Initialize
	DD	$LN1651@Initialize
	DD	$LN1669@Initialize
$LN1915@Initialize:
	DD	$LN1593@Initialize
	DD	$LN1593@Initialize
	DD	$LN1593@Initialize
	DD	$LN1593@Initialize
	DD	$LN1575@Initialize
	DD	$LN1593@Initialize
$LN1914@Initialize:
	DD	$LN1393@Initialize
	DD	$LN1393@Initialize
	DD	$LN1393@Initialize
	DD	$LN1393@Initialize
	DD	$LN1375@Initialize
	DD	$LN1393@Initialize
$LN1913@Initialize:
	DD	$LN1517@Initialize
	DD	$LN1517@Initialize
	DD	$LN1517@Initialize
	DD	$LN1517@Initialize
	DD	$LN1499@Initialize
	DD	$LN1517@Initialize
$LN1912@Initialize:
	DD	$LN948@Initialize
	DD	$LN948@Initialize
	DD	$LN948@Initialize
	DD	$LN948@Initialize
	DD	$LN930@Initialize
	DD	$LN948@Initialize
?Initialize@AINBNodeDefMgr@@YAXXZ ENDP			; AINBNodeDefMgr::Initialize
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 48
FlagCount$1$ = 49
$T3 = 49
AllowedAINBCount$1$ = 50
$T4 = 50
$T5 = 52
$T6 = 56
$T7 = 56
$T8 = 56
$T9 = 56
$T10 = 56
$T11 = 56
$T12 = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
$T17 = 56
$T18 = 56
$T19 = 56
LinkedNodeParamCount$1$ = 88
FileNameCount$1$ = 89
$T20 = 96
$T21 = 96
$T22 = 96
Reader$23 = 96
$T24 = 96
$T25 = 128
$T26 = 128
$T27 = 136
$T28 = 136
$T29 = 136
Type$1$ = 144
j$1$ = 148
tv9913 = 152
$T30 = 160
$T31 = 168
$T32 = 184
$T33 = 216
$T34 = 256
File$ = 368
Param$35 = 640
Param$36 = 784
Definition$37 = 880
Param$38 = 1136
Bytes$39 = 1216
FileSize$40 = 1240
EXBBytes$41 = 1264
Offsets$42 = 1288
__$ArrayPad$ = 1312
?dtor$1@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA PROC	; `AINBNodeDefMgr::Initialize'::`1'::dtor$1
	lea	rcx, QWORD PTR $T24[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA ENDP	; `AINBNodeDefMgr::Initialize'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 48
FlagCount$1$ = 49
$T3 = 49
AllowedAINBCount$1$ = 50
$T4 = 50
$T5 = 52
$T6 = 56
$T7 = 56
$T8 = 56
$T9 = 56
$T10 = 56
$T11 = 56
$T12 = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
$T17 = 56
$T18 = 56
$T19 = 56
LinkedNodeParamCount$1$ = 88
FileNameCount$1$ = 89
$T20 = 96
$T21 = 96
$T22 = 96
Reader$23 = 96
$T24 = 96
$T25 = 128
$T26 = 128
$T27 = 136
$T28 = 136
$T29 = 136
Type$1$ = 144
j$1$ = 148
tv9913 = 152
$T30 = 160
$T31 = 168
$T32 = 184
$T33 = 216
$T34 = 256
File$ = 368
Param$35 = 640
Param$36 = 784
Definition$37 = 880
Param$38 = 1136
Bytes$39 = 1216
FileSize$40 = 1240
EXBBytes$41 = 1264
Offsets$42 = 1288
__$ArrayPad$ = 1312
?dtor$2@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA PROC	; `AINBNodeDefMgr::Initialize'::`1'::dtor$2
	lea	rcx, QWORD PTR File$[rdx]
	jmp	??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
?dtor$2@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA ENDP	; `AINBNodeDefMgr::Initialize'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 48
FlagCount$1$ = 49
$T3 = 49
AllowedAINBCount$1$ = 50
$T4 = 50
$T5 = 52
$T6 = 56
$T7 = 56
$T8 = 56
$T9 = 56
$T10 = 56
$T11 = 56
$T12 = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
$T17 = 56
$T18 = 56
$T19 = 56
LinkedNodeParamCount$1$ = 88
FileNameCount$1$ = 89
$T20 = 96
$T21 = 96
$T22 = 96
Reader$23 = 96
$T24 = 96
$T25 = 128
$T26 = 128
$T27 = 136
$T28 = 136
$T29 = 136
Type$1$ = 144
j$1$ = 148
tv9913 = 152
$T30 = 160
$T31 = 168
$T32 = 184
$T33 = 216
$T34 = 256
File$ = 368
Param$35 = 640
Param$36 = 784
Definition$37 = 880
Param$38 = 1136
Bytes$39 = 1216
FileSize$40 = 1240
EXBBytes$41 = 1264
Offsets$42 = 1288
__$ArrayPad$ = 1312
?dtor$3@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA PROC	; `AINBNodeDefMgr::Initialize'::`1'::dtor$3
	lea	rcx, QWORD PTR Bytes$39[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$3@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA ENDP	; `AINBNodeDefMgr::Initialize'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 48
FlagCount$1$ = 49
$T3 = 49
AllowedAINBCount$1$ = 50
$T4 = 50
$T5 = 52
$T6 = 56
$T7 = 56
$T8 = 56
$T9 = 56
$T10 = 56
$T11 = 56
$T12 = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
$T17 = 56
$T18 = 56
$T19 = 56
LinkedNodeParamCount$1$ = 88
FileNameCount$1$ = 89
$T20 = 96
$T21 = 96
$T22 = 96
Reader$23 = 96
$T24 = 96
$T25 = 128
$T26 = 128
$T27 = 136
$T28 = 136
$T29 = 136
Type$1$ = 144
j$1$ = 148
tv9913 = 152
$T30 = 160
$T31 = 168
$T32 = 184
$T33 = 216
$T34 = 256
File$ = 368
Param$35 = 640
Param$36 = 784
Definition$37 = 880
Param$38 = 1136
Bytes$39 = 1216
FileSize$40 = 1240
EXBBytes$41 = 1264
Offsets$42 = 1288
__$ArrayPad$ = 1312
?dtor$4@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA PROC	; `AINBNodeDefMgr::Initialize'::`1'::dtor$4
	mov	rcx, QWORD PTR $T29[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA ENDP	; `AINBNodeDefMgr::Initialize'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 48
FlagCount$1$ = 49
$T3 = 49
AllowedAINBCount$1$ = 50
$T4 = 50
$T5 = 52
$T6 = 56
$T7 = 56
$T8 = 56
$T9 = 56
$T10 = 56
$T11 = 56
$T12 = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
$T17 = 56
$T18 = 56
$T19 = 56
LinkedNodeParamCount$1$ = 88
FileNameCount$1$ = 89
$T20 = 96
$T21 = 96
$T22 = 96
Reader$23 = 96
$T24 = 96
$T25 = 128
$T26 = 128
$T27 = 136
$T28 = 136
$T29 = 136
Type$1$ = 144
j$1$ = 148
tv9913 = 152
$T30 = 160
$T31 = 168
$T32 = 184
$T33 = 216
$T34 = 256
File$ = 368
Param$35 = 640
Param$36 = 784
Definition$37 = 880
Param$38 = 1136
Bytes$39 = 1216
FileSize$40 = 1240
EXBBytes$41 = 1264
Offsets$42 = 1288
__$ArrayPad$ = 1312
?dtor$6@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA PROC	; `AINBNodeDefMgr::Initialize'::`1'::dtor$6
	lea	rcx, QWORD PTR Offsets$42[rdx]
	jmp	??1?$vector@IV?$allocator@I@std@@@std@@QEAA@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
?dtor$6@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA ENDP	; `AINBNodeDefMgr::Initialize'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 48
FlagCount$1$ = 49
$T3 = 49
AllowedAINBCount$1$ = 50
$T4 = 50
$T5 = 52
$T6 = 56
$T7 = 56
$T8 = 56
$T9 = 56
$T10 = 56
$T11 = 56
$T12 = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
$T17 = 56
$T18 = 56
$T19 = 56
LinkedNodeParamCount$1$ = 88
FileNameCount$1$ = 89
$T20 = 96
$T21 = 96
$T22 = 96
Reader$23 = 96
$T24 = 96
$T25 = 128
$T26 = 128
$T27 = 136
$T28 = 136
$T29 = 136
Type$1$ = 144
j$1$ = 148
tv9913 = 152
$T30 = 160
$T31 = 168
$T32 = 184
$T33 = 216
$T34 = 256
File$ = 368
Param$35 = 640
Param$36 = 784
Definition$37 = 880
Param$38 = 1136
Bytes$39 = 1216
FileSize$40 = 1240
EXBBytes$41 = 1264
Offsets$42 = 1288
__$ArrayPad$ = 1312
?dtor$7@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA PROC	; `AINBNodeDefMgr::Initialize'::`1'::dtor$7
	lea	rcx, QWORD PTR Definition$37[rdx]
	jmp	??1NodeDef@AINBNodeDefMgr@@QEAA@XZ
?dtor$7@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA ENDP	; `AINBNodeDefMgr::Initialize'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 48
FlagCount$1$ = 49
$T3 = 49
AllowedAINBCount$1$ = 50
$T4 = 50
$T5 = 52
$T6 = 56
$T7 = 56
$T8 = 56
$T9 = 56
$T10 = 56
$T11 = 56
$T12 = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
$T17 = 56
$T18 = 56
$T19 = 56
LinkedNodeParamCount$1$ = 88
FileNameCount$1$ = 89
$T20 = 96
$T21 = 96
$T22 = 96
Reader$23 = 96
$T24 = 96
$T25 = 128
$T26 = 128
$T27 = 136
$T28 = 136
$T29 = 136
Type$1$ = 144
j$1$ = 148
tv9913 = 152
$T30 = 160
$T31 = 168
$T32 = 184
$T33 = 216
$T34 = 256
File$ = 368
Param$35 = 640
Param$36 = 784
Definition$37 = 880
Param$38 = 1136
Bytes$39 = 1216
FileSize$40 = 1240
EXBBytes$41 = 1264
Offsets$42 = 1288
__$ArrayPad$ = 1312
?dtor$10@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA PROC	; `AINBNodeDefMgr::Initialize'::`1'::dtor$10
	lea	rcx, QWORD PTR Param$35[rdx]
	jmp	??1InputParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ
?dtor$10@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA ENDP	; `AINBNodeDefMgr::Initialize'::`1'::dtor$10
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 48
FlagCount$1$ = 49
$T3 = 49
AllowedAINBCount$1$ = 50
$T4 = 50
$T5 = 52
$T6 = 56
$T7 = 56
$T8 = 56
$T9 = 56
$T10 = 56
$T11 = 56
$T12 = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
$T17 = 56
$T18 = 56
$T19 = 56
LinkedNodeParamCount$1$ = 88
FileNameCount$1$ = 89
$T20 = 96
$T21 = 96
$T22 = 96
Reader$23 = 96
$T24 = 96
$T25 = 128
$T26 = 128
$T27 = 136
$T28 = 136
$T29 = 136
Type$1$ = 144
j$1$ = 148
tv9913 = 152
$T30 = 160
$T31 = 168
$T32 = 184
$T33 = 216
$T34 = 256
File$ = 368
Param$35 = 640
Param$36 = 784
Definition$37 = 880
Param$38 = 1136
Bytes$39 = 1216
FileSize$40 = 1240
EXBBytes$41 = 1264
Offsets$42 = 1288
__$ArrayPad$ = 1312
?dtor$14@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA PROC	; `AINBNodeDefMgr::Initialize'::`1'::dtor$14
	lea	rcx, QWORD PTR Param$38[rdx]
	jmp	??1OutputEntry@AINBFile@@QEAA@XZ
?dtor$14@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA ENDP	; `AINBNodeDefMgr::Initialize'::`1'::dtor$14
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 48
FlagCount$1$ = 49
$T3 = 49
AllowedAINBCount$1$ = 50
$T4 = 50
$T5 = 52
$T6 = 56
$T7 = 56
$T8 = 56
$T9 = 56
$T10 = 56
$T11 = 56
$T12 = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
$T17 = 56
$T18 = 56
$T19 = 56
LinkedNodeParamCount$1$ = 88
FileNameCount$1$ = 89
$T20 = 96
$T21 = 96
$T22 = 96
Reader$23 = 96
$T24 = 96
$T25 = 128
$T26 = 128
$T27 = 136
$T28 = 136
$T29 = 136
Type$1$ = 144
j$1$ = 148
tv9913 = 152
$T30 = 160
$T31 = 168
$T32 = 184
$T33 = 216
$T34 = 256
File$ = 368
Param$35 = 640
Param$36 = 784
Definition$37 = 880
Param$38 = 1136
Bytes$39 = 1216
FileSize$40 = 1240
EXBBytes$41 = 1264
Offsets$42 = 1288
__$ArrayPad$ = 1312
?dtor$57@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA PROC	; `AINBNodeDefMgr::Initialize'::`1'::dtor$57
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T26[rbp]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN819@dtor$57
	and	DWORD PTR $T26[rbp], -9
	lea	rcx, QWORD PTR $T12[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN819@dtor$57:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$57@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA ENDP	; `AINBNodeDefMgr::Initialize'::`1'::dtor$57
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 48
FlagCount$1$ = 49
$T3 = 49
AllowedAINBCount$1$ = 50
$T4 = 50
$T5 = 52
$T6 = 56
$T7 = 56
$T8 = 56
$T9 = 56
$T10 = 56
$T11 = 56
$T12 = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
$T17 = 56
$T18 = 56
$T19 = 56
LinkedNodeParamCount$1$ = 88
FileNameCount$1$ = 89
$T20 = 96
$T21 = 96
$T22 = 96
Reader$23 = 96
$T24 = 96
$T25 = 128
$T26 = 128
$T27 = 136
$T28 = 136
$T29 = 136
Type$1$ = 144
j$1$ = 148
tv9913 = 152
$T30 = 160
$T31 = 168
$T32 = 184
$T33 = 216
$T34 = 256
File$ = 368
Param$35 = 640
Param$36 = 784
Definition$37 = 880
Param$38 = 1136
Bytes$39 = 1216
FileSize$40 = 1240
EXBBytes$41 = 1264
Offsets$42 = 1288
__$ArrayPad$ = 1312
?dtor$52@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA PROC	; `AINBNodeDefMgr::Initialize'::`1'::dtor$52
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T26[rbp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN688@dtor$52
	and	DWORD PTR $T26[rbp], -5
	lea	rcx, QWORD PTR $T11[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN688@dtor$52:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$52@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA ENDP	; `AINBNodeDefMgr::Initialize'::`1'::dtor$52
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 48
FlagCount$1$ = 49
$T3 = 49
AllowedAINBCount$1$ = 50
$T4 = 50
$T5 = 52
$T6 = 56
$T7 = 56
$T8 = 56
$T9 = 56
$T10 = 56
$T11 = 56
$T12 = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
$T17 = 56
$T18 = 56
$T19 = 56
LinkedNodeParamCount$1$ = 88
FileNameCount$1$ = 89
$T20 = 96
$T21 = 96
$T22 = 96
Reader$23 = 96
$T24 = 96
$T25 = 128
$T26 = 128
$T27 = 136
$T28 = 136
$T29 = 136
Type$1$ = 144
j$1$ = 148
tv9913 = 152
$T30 = 160
$T31 = 168
$T32 = 184
$T33 = 216
$T34 = 256
File$ = 368
Param$35 = 640
Param$36 = 784
Definition$37 = 880
Param$38 = 1136
Bytes$39 = 1216
FileSize$40 = 1240
EXBBytes$41 = 1264
Offsets$42 = 1288
__$ArrayPad$ = 1312
?dtor$17@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA PROC	; `AINBNodeDefMgr::Initialize'::`1'::dtor$17
	lea	rcx, QWORD PTR Param$36[rdx]
	jmp	??1ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ
?dtor$17@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA ENDP	; `AINBNodeDefMgr::Initialize'::`1'::dtor$17
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 48
FlagCount$1$ = 49
$T3 = 49
AllowedAINBCount$1$ = 50
$T4 = 50
$T5 = 52
$T6 = 56
$T7 = 56
$T8 = 56
$T9 = 56
$T10 = 56
$T11 = 56
$T12 = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
$T17 = 56
$T18 = 56
$T19 = 56
LinkedNodeParamCount$1$ = 88
FileNameCount$1$ = 89
$T20 = 96
$T21 = 96
$T22 = 96
Reader$23 = 96
$T24 = 96
$T25 = 128
$T26 = 128
$T27 = 136
$T28 = 136
$T29 = 136
Type$1$ = 144
j$1$ = 148
tv9913 = 152
$T30 = 160
$T31 = 168
$T32 = 184
$T33 = 216
$T34 = 256
File$ = 368
Param$35 = 640
Param$36 = 784
Definition$37 = 880
Param$38 = 1136
Bytes$39 = 1216
FileSize$40 = 1240
EXBBytes$41 = 1264
Offsets$42 = 1288
__$ArrayPad$ = 1312
?dtor$35@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA PROC	; `AINBNodeDefMgr::Initialize'::`1'::dtor$35
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T26[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN301@dtor$35
	and	DWORD PTR $T26[rbp], -2
	lea	rcx, QWORD PTR $T10[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN301@dtor$35:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$35@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA ENDP	; `AINBNodeDefMgr::Initialize'::`1'::dtor$35
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 48
FlagCount$1$ = 49
$T3 = 49
AllowedAINBCount$1$ = 50
$T4 = 50
$T5 = 52
$T6 = 56
$T7 = 56
$T8 = 56
$T9 = 56
$T10 = 56
$T11 = 56
$T12 = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
$T17 = 56
$T18 = 56
$T19 = 56
LinkedNodeParamCount$1$ = 88
FileNameCount$1$ = 89
$T20 = 96
$T21 = 96
$T22 = 96
Reader$23 = 96
$T24 = 96
$T25 = 128
$T26 = 128
$T27 = 136
$T28 = 136
$T29 = 136
Type$1$ = 144
j$1$ = 148
tv9913 = 152
$T30 = 160
$T31 = 168
$T32 = 184
$T33 = 216
$T34 = 256
File$ = 368
Param$35 = 640
Param$36 = 784
Definition$37 = 880
Param$38 = 1136
Bytes$39 = 1216
FileSize$40 = 1240
EXBBytes$41 = 1264
Offsets$42 = 1288
__$ArrayPad$ = 1312
?dtor$40@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA PROC	; `AINBNodeDefMgr::Initialize'::`1'::dtor$40
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T26[rbp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN440@dtor$40
	and	DWORD PTR $T26[rbp], -3
	lea	rcx, QWORD PTR $T9[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN440@dtor$40:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$40@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA ENDP	; `AINBNodeDefMgr::Initialize'::`1'::dtor$40
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 48
FlagCount$1$ = 49
$T3 = 49
AllowedAINBCount$1$ = 50
$T4 = 50
$T5 = 52
$T6 = 56
$T7 = 56
$T8 = 56
$T9 = 56
$T10 = 56
$T11 = 56
$T12 = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
$T17 = 56
$T18 = 56
$T19 = 56
LinkedNodeParamCount$1$ = 88
FileNameCount$1$ = 89
$T20 = 96
$T21 = 96
$T22 = 96
Reader$23 = 96
$T24 = 96
$T25 = 128
$T26 = 128
$T27 = 136
$T28 = 136
$T29 = 136
Type$1$ = 144
j$1$ = 148
tv9913 = 152
$T30 = 160
$T31 = 168
$T32 = 184
$T33 = 216
$T34 = 256
File$ = 368
Param$35 = 640
Param$36 = 784
Definition$37 = 880
Param$38 = 1136
Bytes$39 = 1216
FileSize$40 = 1240
EXBBytes$41 = 1264
Offsets$42 = 1288
__$ArrayPad$ = 1312
?dtor$20@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA PROC	; `AINBNodeDefMgr::Initialize'::`1'::dtor$20
	lea	rcx, QWORD PTR $T8[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$20@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA ENDP	; `AINBNodeDefMgr::Initialize'::`1'::dtor$20
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 48
FlagCount$1$ = 49
$T3 = 49
AllowedAINBCount$1$ = 50
$T4 = 50
$T5 = 52
$T6 = 56
$T7 = 56
$T8 = 56
$T9 = 56
$T10 = 56
$T11 = 56
$T12 = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
$T17 = 56
$T18 = 56
$T19 = 56
LinkedNodeParamCount$1$ = 88
FileNameCount$1$ = 89
$T20 = 96
$T21 = 96
$T22 = 96
Reader$23 = 96
$T24 = 96
$T25 = 128
$T26 = 128
$T27 = 136
$T28 = 136
$T29 = 136
Type$1$ = 144
j$1$ = 148
tv9913 = 152
$T30 = 160
$T31 = 168
$T32 = 184
$T33 = 216
$T34 = 256
File$ = 368
Param$35 = 640
Param$36 = 784
Definition$37 = 880
Param$38 = 1136
Bytes$39 = 1216
FileSize$40 = 1240
EXBBytes$41 = 1264
Offsets$42 = 1288
__$ArrayPad$ = 1312
?dtor$21@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA PROC	; `AINBNodeDefMgr::Initialize'::`1'::dtor$21
	lea	rcx, QWORD PTR $T7[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$21@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA ENDP	; `AINBNodeDefMgr::Initialize'::`1'::dtor$21
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 48
FlagCount$1$ = 49
$T3 = 49
AllowedAINBCount$1$ = 50
$T4 = 50
$T5 = 52
$T6 = 56
$T7 = 56
$T8 = 56
$T9 = 56
$T10 = 56
$T11 = 56
$T12 = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
$T17 = 56
$T18 = 56
$T19 = 56
LinkedNodeParamCount$1$ = 88
FileNameCount$1$ = 89
$T20 = 96
$T21 = 96
$T22 = 96
Reader$23 = 96
$T24 = 96
$T25 = 128
$T26 = 128
$T27 = 136
$T28 = 136
$T29 = 136
Type$1$ = 144
j$1$ = 148
tv9913 = 152
$T30 = 160
$T31 = 168
$T32 = 184
$T33 = 216
$T34 = 256
File$ = 368
Param$35 = 640
Param$36 = 784
Definition$37 = 880
Param$38 = 1136
Bytes$39 = 1216
FileSize$40 = 1240
EXBBytes$41 = 1264
Offsets$42 = 1288
__$ArrayPad$ = 1312
?dtor$22@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA PROC	; `AINBNodeDefMgr::Initialize'::`1'::dtor$22
	lea	rcx, QWORD PTR EXBBytes$41[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$22@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA ENDP	; `AINBNodeDefMgr::Initialize'::`1'::dtor$22
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 48
FlagCount$1$ = 49
$T3 = 49
AllowedAINBCount$1$ = 50
$T4 = 50
$T5 = 52
$T6 = 56
$T7 = 56
$T8 = 56
$T9 = 56
$T10 = 56
$T11 = 56
$T12 = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
$T17 = 56
$T18 = 56
$T19 = 56
LinkedNodeParamCount$1$ = 88
FileNameCount$1$ = 89
$T20 = 96
$T21 = 96
$T22 = 96
Reader$23 = 96
$T24 = 96
$T25 = 128
$T26 = 128
$T27 = 136
$T28 = 136
$T29 = 136
Type$1$ = 144
j$1$ = 148
tv9913 = 152
$T30 = 160
$T31 = 168
$T32 = 184
$T33 = 216
$T34 = 256
File$ = 368
Param$35 = 640
Param$36 = 784
Definition$37 = 880
Param$38 = 1136
Bytes$39 = 1216
FileSize$40 = 1240
EXBBytes$41 = 1264
Offsets$42 = 1288
__$ArrayPad$ = 1312
?dtor$25@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA PROC	; `AINBNodeDefMgr::Initialize'::`1'::dtor$25
	lea	rcx, QWORD PTR $T33[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$25@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA ENDP	; `AINBNodeDefMgr::Initialize'::`1'::dtor$25
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 48
FlagCount$1$ = 49
$T3 = 49
AllowedAINBCount$1$ = 50
$T4 = 50
$T5 = 52
$T6 = 56
$T7 = 56
$T8 = 56
$T9 = 56
$T10 = 56
$T11 = 56
$T12 = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
$T17 = 56
$T18 = 56
$T19 = 56
LinkedNodeParamCount$1$ = 88
FileNameCount$1$ = 89
$T20 = 96
$T21 = 96
$T22 = 96
Reader$23 = 96
$T24 = 96
$T25 = 128
$T26 = 128
$T27 = 136
$T28 = 136
$T29 = 136
Type$1$ = 144
j$1$ = 148
tv9913 = 152
$T30 = 160
$T31 = 168
$T32 = 184
$T33 = 216
$T34 = 256
File$ = 368
Param$35 = 640
Param$36 = 784
Definition$37 = 880
Param$38 = 1136
Bytes$39 = 1216
FileSize$40 = 1240
EXBBytes$41 = 1264
Offsets$42 = 1288
__$ArrayPad$ = 1312
?dtor$26@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA PROC	; `AINBNodeDefMgr::Initialize'::`1'::dtor$26
	lea	rcx, QWORD PTR $T32[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$26@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA ENDP	; `AINBNodeDefMgr::Initialize'::`1'::dtor$26
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 48
FlagCount$1$ = 49
$T3 = 49
AllowedAINBCount$1$ = 50
$T4 = 50
$T5 = 52
$T6 = 56
$T7 = 56
$T8 = 56
$T9 = 56
$T10 = 56
$T11 = 56
$T12 = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
$T17 = 56
$T18 = 56
$T19 = 56
LinkedNodeParamCount$1$ = 88
FileNameCount$1$ = 89
$T20 = 96
$T21 = 96
$T22 = 96
Reader$23 = 96
$T24 = 96
$T25 = 128
$T26 = 128
$T27 = 136
$T28 = 136
$T29 = 136
Type$1$ = 144
j$1$ = 148
tv9913 = 152
$T30 = 160
$T31 = 168
$T32 = 184
$T33 = 216
$T34 = 256
File$ = 368
Param$35 = 640
Param$36 = 784
Definition$37 = 880
Param$38 = 1136
Bytes$39 = 1216
FileSize$40 = 1240
EXBBytes$41 = 1264
Offsets$42 = 1288
__$ArrayPad$ = 1312
?dtor$27@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA PROC	; `AINBNodeDefMgr::Initialize'::`1'::dtor$27
	mov	rcx, QWORD PTR $T28[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$27@?0??Initialize@AINBNodeDefMgr@@YAXXZ@4HA ENDP	; `AINBNodeDefMgr::Initialize'::`1'::dtor$27
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0NodeDef@AINBNodeDefMgr@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0NodeDef@AINBNodeDefMgr@@QEAA@XZ PROC			; AINBNodeDefMgr::NodeDef::NodeDef, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4821 :         _My_data._Mysize = 0;

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx+8], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+24], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+32], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx+8], al

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx+40], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+56], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+64], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx+40], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+80], rax
	mov	QWORD PTR [rcx+88], rax
	mov	QWORD PTR [rcx+96], rax
	mov	QWORD PTR [rcx+104], rax
	mov	QWORD PTR [rcx+112], rax
	mov	QWORD PTR [rcx+120], rax
	mov	QWORD PTR [rcx+128], rax
	mov	QWORD PTR [rcx+136], rax
	mov	QWORD PTR [rcx+144], rax
	mov	QWORD PTR [rcx+152], rax
	mov	QWORD PTR [rcx+160], rax
	mov	QWORD PTR [rcx+168], rax
	mov	QWORD PTR [rcx+176], rax
	mov	QWORD PTR [rcx+184], rax
	mov	QWORD PTR [rcx+192], rax
	mov	QWORD PTR [rcx+200], rax
	mov	QWORD PTR [rcx+208], rax
	mov	QWORD PTR [rcx+216], rax
	mov	QWORD PTR [rcx+224], rax
	mov	QWORD PTR [rcx+232], rax
	mov	QWORD PTR [rcx+240], rax
	mov	rax, rcx
	ret	0
??0NodeDef@AINBNodeDefMgr@@QEAA@XZ ENDP			; AINBNodeDefMgr::NodeDef::NodeDef
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ??0InputParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0InputParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ PROC	; AINBNodeDefMgr::NodeDef::InputParam::InputParam, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4821 :         _My_data._Mysize = 0;

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], al

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx+32], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+48], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+56], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx+32], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+64], rax
	mov	QWORD PTR [rcx+72], rax
	mov	QWORD PTR [rcx+80], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	mov	DWORD PTR [rcx+88], eax

; 795  :           _Which{static_cast<_Index_t>(_Idx)} { // initialize alternative _Idx from _Args...

	mov	BYTE PTR [rcx+120], al
	mov	BYTE PTR [rcx+132], al
	mov	rax, rcx
	mov	DWORD PTR [rcx+136], 65535		; 0000ffffH
	ret	0
??0InputParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ ENDP	; AINBNodeDefMgr::NodeDef::InputParam::InputParam
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ PROC	; AINBNodeDefMgr::NodeDef::ImmediateParam::ImmediateParam, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4821 :         _My_data._Mysize = 0;

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], al

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx+40], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+56], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+64], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx+40], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+72], rax
	mov	QWORD PTR [rcx+80], rax
	mov	QWORD PTR [rcx+88], rax
	mov	rax, rcx
	ret	0
??0ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ ENDP	; AINBNodeDefMgr::NodeDef::ImmediateParam::ImmediateParam
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1NodeDef@AINBNodeDefMgr@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1NodeDef@AINBNodeDefMgr@@QEAA@XZ PROC			; AINBNodeDefMgr::NodeDef::~NodeDef, COMDAT
$LN81:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	xor	edi, edi
	mov	rcx, QWORD PTR [rcx+224]
	test	rcx, rcx
	je	SHORT $LN6@NodeDef

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+240]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN24@NodeDef

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN48@NodeDef

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN24@NodeDef:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	mov	QWORD PTR [rbx+224], rdi

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+232], rdi

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+240], rdi
$LN6@NodeDef:

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rbx+200]
	test	rcx, rcx
	je	SHORT $LN33@NodeDef

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+216]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN51@NodeDef

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN48@NodeDef

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN51@NodeDef:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	mov	QWORD PTR [rbx+200], rdi

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+208], rdi

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+216], rdi
$LN33@NodeDef:
	lea	rcx, QWORD PTR [rbx+176]

; 767  :         _Tidy();

	call	?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
	lea	rcx, QWORD PTR [rbx+152]
	call	?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
	lea	rcx, QWORD PTR [rbx+128]
	call	?_Tidy@?$vector@V?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@V?$allocator@V?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@@2@@std@@AEAAXXZ ; std::vector<std::vector<AINBFile::OutputEntry,std::allocator<AINBFile::OutputEntry> >,std::allocator<std::vector<AINBFile::OutputEntry,std::allocator<AINBFile::OutputEntry> > > >::_Tidy
	lea	rcx, QWORD PTR [rbx+104]
	call	?_Tidy@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXXZ ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Tidy
	lea	rcx, QWORD PTR [rbx+80]
	call	?_Tidy@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXXZ ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Tidy
	lea	rcx, QWORD PTR [rbx+40]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR [rbx+8]
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	jmp	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN48@NodeDef:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN78@NodeDef:
??1NodeDef@AINBNodeDefMgr@@QEAA@XZ ENDP			; AINBNodeDefMgr::NodeDef::~NodeDef
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ??1InputParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1InputParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ PROC	; AINBNodeDefMgr::NodeDef::InputParam::~InputParam, COMDAT
$LN105:
	push	rbx
	sub	rsp, 32					; 00000020H

; 803  :         return static_cast<size_t>(_Which);

	movsx	rax, BYTE PTR [rcx+120]

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	lea	rdx, OFFSET FLAT:__ImageBase
	mov	rbx, rcx
	add	rcx, 88					; 00000058H
	mov	eax, DWORD PTR $LN98@InputParam[rdx+rax*4+4]
	add	rax, rdx
	jmp	rax
$LN34@InputParam:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN52@InputParam:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rbx+64]
	test	rcx, rcx
	je	SHORT $LN69@InputParam

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+80]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN87@InputParam

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN84@InputParam

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN87@InputParam:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx+64], rax

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+72], rax

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+80], rax
$LN69@InputParam:
	lea	rcx, QWORD PTR [rbx+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	mov	rcx, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN84@InputParam:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN47@InputParam:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

$LN102@InputParam:
	npad	1
$LN98@InputParam:
	DD	$LN52@InputParam
	DD	$LN52@InputParam
	DD	$LN52@InputParam
	DD	$LN52@InputParam
	DD	$LN34@InputParam
	DD	$LN52@InputParam
??1InputParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ ENDP	; AINBNodeDefMgr::NodeDef::InputParam::~InputParam
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ??4InputParam@NodeDef@AINBNodeDefMgr@@QEAAAEAU012@AEBU012@@Z
_TEXT	SEGMENT
$T1 = 48
this$ = 48
__that$ = 56
??4InputParam@NodeDef@AINBNodeDefMgr@@QEAAAEAU012@AEBU012@@Z PROC ; AINBNodeDefMgr::NodeDef::InputParam::operator=, COMDAT
$LN41:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3156 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN3@operator

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN7@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN7@operator:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rbx+16]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN3@operator:
	lea	rdx, QWORD PTR [rbx+32]
	lea	rcx, QWORD PTR [rdi+32]

; 3156 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN11@operator

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 16

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rdx+16]

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN15@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN15@operator:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN11@operator:
	lea	r8, QWORD PTR [rbx+64]
	lea	rcx, QWORD PTR [rdi+64]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, r8
	je	SHORT $LN19@operator

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [r8]
	mov	r8, QWORD PTR [r8+8]
	sub	r8, rdx
	call	??$_Assign_counted_range@PEAW4FlagsStruct@AINBFile@@@?$vector@W4FlagsStruct@AINBFile@@V?$allocator@W4FlagsStruct@AINBFile@@@std@@@std@@AEAAXPEAW4FlagsStruct@AINBFile@@_K@Z ; std::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >::_Assign_counted_range<enum AINBFile::FlagsStruct *>
$LN19@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 803  :         return static_cast<size_t>(_Which);

	movsx	rcx, BYTE PTR [rbx+120]
	lea	r8, QWORD PTR [rbx+88]
	lea	rax, QWORD PTR [rdi+88]

; 691  :     ++_Idx; // bias index by +1 to map {variant_npos} U [0, _Size) to the contiguous range [0, _Size]

	inc	rcx

; 692  :     return _Variant_raw_visit1<_Strategy>::_Visit(_Idx, static_cast<_Fn&&>(_Func), static_cast<_Storage&&>(_Obj));

	lea	rdx, QWORD PTR $T1[rsp]
	mov	QWORD PTR $T1[rsp], rax
	call	??$_Visit@U?$_Variant_assign_visitor@I_NMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VVector3F@@@std@@AEBV?$_Variant_storage_@$0A@I_NMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VVector3F@@@2@@?$_Variant_raw_visit1@$01@std@@SAX_K$$QEAU?$_Variant_assign_visitor@I_NMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VVector3F@@@1@AEBV?$_Variant_storage_@$0A@I_NMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VVector3F@@@1@@Z ; std::_Variant_raw_visit1<2>::_Visit<std::_Variant_assign_visitor<unsigned int,bool,float,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Vector3F>,std::_Variant_storage_<0,unsigned int,bool,float,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Vector3F> const &>
	mov	eax, DWORD PTR [rbx+128]
	mov	DWORD PTR [rdi+128], eax
	movzx	eax, BYTE PTR [rbx+132]
	mov	BYTE PTR [rdi+132], al
	mov	eax, DWORD PTR [rbx+136]
	mov	rbx, QWORD PTR [rsp+56]
	mov	DWORD PTR [rdi+136], eax
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??4InputParam@NodeDef@AINBNodeDefMgr@@QEAAAEAU012@AEBU012@@Z ENDP ; AINBNodeDefMgr::NodeDef::InputParam::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ PROC	; AINBNodeDefMgr::NodeDef::ImmediateParam::~ImmediateParam, COMDAT
$LN42:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx+72]
	test	rcx, rcx
	je	SHORT $LN6@ImmediateP

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+88]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN24@ImmediateP

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN21@ImmediateP

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN24@ImmediateP:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx+72], rax

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+80], rax

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+88], rax
$LN6@ImmediateP:
	lea	rcx, QWORD PTR [rbx+40]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	mov	rcx, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN21@ImmediateP:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN39@ImmediateP:
??1ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ ENDP	; AINBNodeDefMgr::NodeDef::ImmediateParam::~ImmediateParam
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??4ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAAAEAU012@AEBU012@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??4ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAAAEAU012@AEBU012@@Z PROC ; AINBNodeDefMgr::NodeDef::ImmediateParam::operator=, COMDAT
$LN30:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3156 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN3@operator

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN7@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN7@operator:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rbx+16]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN3@operator:
	mov	eax, DWORD PTR [rbx+32]
	lea	rdx, QWORD PTR [rbx+40]
	lea	rcx, QWORD PTR [rdi+40]
	mov	DWORD PTR [rdi+32], eax

; 3156 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN11@operator

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 16

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rdx+16]

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN15@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN15@operator:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN11@operator:
	lea	r8, QWORD PTR [rbx+72]
	lea	rcx, QWORD PTR [rdi+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, r8
	je	SHORT $LN22@operator

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [r8]
	mov	r8, QWORD PTR [r8+8]
	sub	r8, rdx
	call	??$_Assign_counted_range@PEAW4FlagsStruct@AINBFile@@@?$vector@W4FlagsStruct@AINBFile@@V?$allocator@W4FlagsStruct@AINBFile@@@std@@@std@@AEAAXPEAW4FlagsStruct@AINBFile@@_K@Z ; std::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >::_Assign_counted_range<enum AINBFile::FlagsStruct *>
$LN22@operator:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??4ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAAAEAU012@AEBU012@@Z ENDP ; AINBNodeDefMgr::NodeDef::ImmediateParam::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??4NodeDef@AINBNodeDefMgr@@QEAAAEAU01@AEBU01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??4NodeDef@AINBNodeDefMgr@@QEAAAEAU01@AEBU01@@Z PROC	; AINBNodeDefMgr::NodeDef::operator=, COMDAT
$LN54:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	movzx	eax, BYTE PTR [rdx]
	mov	rdi, rdx
	mov	BYTE PTR [rcx], al
	mov	rbx, rcx
	add	rcx, 8
	add	rdx, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3156 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN3@operator

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 16

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rdx+16]

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN7@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN7@operator:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN3@operator:
	lea	rdx, QWORD PTR [rdi+40]
	lea	rcx, QWORD PTR [rbx+40]

; 3156 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN11@operator

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 16

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rdx+16]

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN15@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN15@operator:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN11@operator:
	mov	eax, DWORD PTR [rdi+72]
	lea	r8, QWORD PTR [rdi+80]
	mov	DWORD PTR [rbx+72], eax
	lea	rcx, QWORD PTR [rbx+80]
	movzx	eax, WORD PTR [rdi+76]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1483 :         if (this == _STD addressof(_Right)) {

	mov	rsi, -6148914691236517205		; aaaaaaaaaaaaaaabH
	mov	WORD PTR [rbx+76], ax
	cmp	rcx, r8
	je	SHORT $LN19@operator

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [r8]
	mov	r8, QWORD PTR [r8+8]
	sub	r8, rdx
	sar	r8, 3
	imul	r8, rsi
	call	??$_Assign_counted_range@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@_K@Z ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Assign_counted_range<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *>
$LN19@operator:
	lea	r8, QWORD PTR [rdi+104]
	lea	rcx, QWORD PTR [rbx+104]

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, r8
	je	SHORT $LN22@operator

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [r8]
	mov	r8, QWORD PTR [r8+8]
	sub	r8, rdx
	sar	r8, 3
	imul	r8, rsi
	call	??$_Assign_counted_range@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@_K@Z ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Assign_counted_range<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > *>
$LN22@operator:
	lea	r8, QWORD PTR [rdi+128]
	lea	rcx, QWORD PTR [rbx+128]

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, r8
	je	SHORT $LN25@operator

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [r8]
	mov	r8, QWORD PTR [r8+8]
	sub	r8, rdx
	sar	r8, 3
	imul	r8, rsi
	call	??$_Assign_counted_range@PEAV?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@@?$vector@V?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@V?$allocator@V?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@@2@@std@@AEAAXPEAV?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@1@_K@Z ; std::vector<std::vector<AINBFile::OutputEntry,std::allocator<AINBFile::OutputEntry> >,std::allocator<std::vector<AINBFile::OutputEntry,std::allocator<AINBFile::OutputEntry> > > >::_Assign_counted_range<std::vector<AINBFile::OutputEntry,std::allocator<AINBFile::OutputEntry> > *>
$LN25@operator:
	lea	r8, QWORD PTR [rdi+152]
	lea	rcx, QWORD PTR [rbx+152]

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, r8
	je	SHORT $LN28@operator

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [r8]
	mov	r8, QWORD PTR [r8+8]
	sub	r8, rdx
	sar	r8, 5
	call	??$_Assign_counted_range@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Assign_counted_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
$LN28@operator:
	lea	r8, QWORD PTR [rdi+176]
	lea	rcx, QWORD PTR [rbx+176]

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, r8
	je	SHORT $LN31@operator

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [r8]
	mov	r8, QWORD PTR [r8+8]
	sub	r8, rdx
	sar	r8, 5
	call	??$_Assign_counted_range@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Assign_counted_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
$LN31@operator:
	lea	r8, QWORD PTR [rdi+200]
	lea	rcx, QWORD PTR [rbx+200]

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, r8
	je	SHORT $LN34@operator

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [r8]
	mov	r8, QWORD PTR [r8+8]
	sub	r8, rdx
	call	??$_Assign_counted_range@PEAW4FlagsStruct@AINBFile@@@?$vector@W4FlagsStruct@AINBFile@@V?$allocator@W4FlagsStruct@AINBFile@@@std@@@std@@AEAAXPEAW4FlagsStruct@AINBFile@@_K@Z ; std::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >::_Assign_counted_range<enum AINBFile::FlagsStruct *>
$LN34@operator:
	lea	r8, QWORD PTR [rdi+224]
	lea	rcx, QWORD PTR [rbx+224]

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, r8
	je	SHORT $LN40@operator

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [r8]
	mov	r8, QWORD PTR [r8+8]
	sub	r8, rdx
	call	??$_Assign_counted_range@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_K@Z ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Assign_counted_range<enum AINBNodeDefMgr::NodeDef::CategoryEnum *>
$LN40@operator:
	mov	rsi, QWORD PTR [rsp+56]
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??4NodeDef@AINBNodeDefMgr@@QEAAAEAU01@AEBU01@@Z ENDP	; AINBNodeDefMgr::NodeDef::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
;	COMDAT ?GetNodeDefinition@AINBNodeDefMgr@@YAPEAUNodeDef@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
Name$ = 64
?GetNodeDefinition@AINBNodeDefMgr@@YAPEAUNodeDef@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; AINBNodeDefMgr::GetNodeDefinition, COMDAT

; 171  : {

$LN51:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1847 :         return _Mypair._Myval2._Myfirst;

	mov	rbx, QWORD PTR ?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 171  : {

	mov	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1855 :         return _Mypair._Myval2._Mylast;

	mov	rsi, QWORD PTR ?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A+8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 172  : 	for (AINBNodeDefMgr::NodeDef& Def : AINBNodeDefMgr::NodeDefinitions)

	cmp	rbx, rsi
	je	SHORT $LN3@GetNodeDef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rbp, QWORD PTR [rcx+24]

; 4584 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	r14, QWORD PTR [rcx+16]
$LL4@GetNodeDef:

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rdx, rdi

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	rbp, 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN16@GetNodeDef

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdi]
$LN16@GetNodeDef:

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rbx+64], 16

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR [rbx+40]

; 4584 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	r8, QWORD PTR [rbx+56]

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN21@GetNodeDef

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rcx]
$LN21@GetNodeDef:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	r8, r14
	jne	SHORT $LN27@GetNodeDef

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	je	SHORT $LN38@GetNodeDef
$LN27@GetNodeDef:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 172  : 	for (AINBNodeDefMgr::NodeDef& Def : AINBNodeDefMgr::NodeDefinitions)

	add	rbx, 248				; 000000f8H
	cmp	rbx, rsi
	jne	SHORT $LL4@GetNodeDef
$LN3@GetNodeDef:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rdi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 179  : 	return nullptr;

	xor	eax, eax
$LN1@GetNodeDef:

; 180  : }

	mov	rbx, QWORD PTR [rsp+72]
	mov	rbp, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN38@GetNodeDef:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rdi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 176  : 			return &Def;

	mov	rax, rbx
	jmp	SHORT $LN1@GetNodeDef
?GetNodeDefinition@AINBNodeDefMgr@@YAPEAUNodeDef@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; AINBNodeDefMgr::GetNodeDefinition
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1AINBFile@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1AINBFile@@QEAA@XZ PROC				; AINBFile::~AINBFile, COMDAT
$LN110:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	add	rcx, 1048				; 00000418H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	call	?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
	lea	rcx, QWORD PTR [rbx+800]
	call	??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
	lea	rcx, QWORD PTR [rbx+776]
	call	?_Tidy@?$vector@UCommandInfoStruct@EXB@@V?$allocator@UCommandInfoStruct@EXB@@@std@@@std@@AEAAXXZ ; std::vector<EXB::CommandInfoStruct,std::allocator<EXB::CommandInfoStruct> >::_Tidy
	lea	rcx, QWORD PTR [rbx+744]
	call	?_Tidy@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAXXZ ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::_Tidy
	lea	rcx, QWORD PTR [rbx+720]
	call	?_Tidy@?$vector@UCommandInfoStruct@EXB@@V?$allocator@UCommandInfoStruct@EXB@@@std@@@std@@AEAAXXZ ; std::vector<EXB::CommandInfoStruct,std::allocator<EXB::CommandInfoStruct> >::_Tidy
	lea	rcx, QWORD PTR [rbx+632]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rbx+600]
	xor	edi, edi
	test	rcx, rcx
	je	SHORT $LN20@AINBFile

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+616]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN38@AINBFile

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN82@AINBFile

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN38@AINBFile:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	mov	QWORD PTR [rbx+600], rdi

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+608], rdi

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+616], rdi
$LN20@AINBFile:
	lea	rcx, QWORD PTR [rbx+576]

; 767  :         _Tidy();

	call	?_Tidy@?$vector@UEmbeddedAinb@AINBFile@@V?$allocator@UEmbeddedAinb@AINBFile@@@std@@@std@@AEAAXXZ ; std::vector<AINBFile::EmbeddedAinb,std::allocator<AINBFile::EmbeddedAinb> >::_Tidy
	lea	rcx, QWORD PTR [rbx+552]
	call	?_Tidy@?$vector@UChildReplace@AINBFile@@V?$allocator@UChildReplace@AINBFile@@@std@@@std@@AEAAXXZ ; std::vector<AINBFile::ChildReplace,std::allocator<AINBFile::ChildReplace> >::_Tidy
	lea	rcx, QWORD PTR [rbx+528]
	call	?_Tidy@?$vector@UNode@AINBFile@@V?$allocator@UNode@AINBFile@@@std@@@std@@AEAAXXZ ; std::vector<AINBFile::Node,std::allocator<AINBFile::Node> >::_Tidy
	lea	rcx, QWORD PTR [rbx+504]
	call	?_Tidy@?$vector@UEntryStringEntry@AINBFile@@V?$allocator@UEntryStringEntry@AINBFile@@@std@@@std@@AEAAXXZ ; std::vector<AINBFile::EntryStringEntry,std::allocator<AINBFile::EntryStringEntry> >::_Tidy
	lea	rcx, QWORD PTR [rbx+480]
	call	?_Tidy@?$vector@GV?$allocator@G@std@@@std@@AEAAXXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::_Tidy
	lea	rcx, QWORD PTR [rbx+456]
	call	?_Tidy@?$vector@UResidentEntry@AINBFile@@V?$allocator@UResidentEntry@AINBFile@@@std@@@std@@AEAAXXZ ; std::vector<AINBFile::ResidentEntry,std::allocator<AINBFile::ResidentEntry> >::_Tidy
	lea	rcx, QWORD PTR [rbx+432]
	call	?_Tidy@?$vector@V?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@V?$allocator@V?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@@2@@std@@AEAAXXZ ; std::vector<std::vector<AINBFile::OutputEntry,std::allocator<AINBFile::OutputEntry> >,std::allocator<std::vector<AINBFile::OutputEntry,std::allocator<AINBFile::OutputEntry> > > >::_Tidy
	lea	rcx, QWORD PTR [rbx+408]
	call	?_Tidy@?$vector@V?$vector@UInputEntry@AINBFile@@V?$allocator@UInputEntry@AINBFile@@@std@@@std@@V?$allocator@V?$vector@UInputEntry@AINBFile@@V?$allocator@UInputEntry@AINBFile@@@std@@@std@@@2@@std@@AEAAXXZ ; std::vector<std::vector<AINBFile::InputEntry,std::allocator<AINBFile::InputEntry> >,std::allocator<std::vector<AINBFile::InputEntry,std::allocator<AINBFile::InputEntry> > > >::_Tidy
	lea	rcx, QWORD PTR [rbx+360]
	lea	r9, OFFSET FLAT:??1?$vector@IV?$allocator@I@std@@@std@@QEAA@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
	mov	edx, 24
	lea	r8d, QWORD PTR [rdx-22]
	call	??_M@YAXPEAX_K1P6AX0@Z@Z
	lea	rcx, QWORD PTR [rbx+336]
	call	?_Tidy@?$vector@UAttachmentEntry@AINBFile@@V?$allocator@UAttachmentEntry@AINBFile@@@std@@@std@@AEAAXXZ ; std::vector<AINBFile::AttachmentEntry,std::allocator<AINBFile::AttachmentEntry> >::_Tidy
	lea	rcx, QWORD PTR [rbx+312]
	call	?_Tidy@?$vector@V?$vector@UImmediateParameter@AINBFile@@V?$allocator@UImmediateParameter@AINBFile@@@std@@@std@@V?$allocator@V?$vector@UImmediateParameter@AINBFile@@V?$allocator@UImmediateParameter@AINBFile@@@std@@@std@@@2@@std@@AEAAXXZ ; std::vector<std::vector<AINBFile::ImmediateParameter,std::allocator<AINBFile::ImmediateParameter> >,std::allocator<std::vector<AINBFile::ImmediateParameter,std::allocator<AINBFile::ImmediateParameter> > > >::_Tidy

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rbx+288]
	test	rcx, rcx
	je	SHORT $LN67@AINBFile

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+304]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN85@AINBFile

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN82@AINBFile

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN85@AINBFile:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	mov	QWORD PTR [rbx+288], rdi

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+296], rdi

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+304], rdi
$LN67@AINBFile:
	lea	rcx, QWORD PTR [rbx+256]

; 767  :         _Tidy();

	call	?_Tidy@?$vector@UGlobalFileRef@AINBFile@@V?$allocator@UGlobalFileRef@AINBFile@@@std@@@std@@AEAAXXZ ; std::vector<AINBFile::GlobalFileRef,std::allocator<AINBFile::GlobalFileRef> >::_Tidy
	lea	rcx, QWORD PTR [rbx+232]
	call	?_Tidy@?$vector@V?$vector@UGlobalEntry@AINBFile@@V?$allocator@UGlobalEntry@AINBFile@@@std@@@std@@V?$allocator@V?$vector@UGlobalEntry@AINBFile@@V?$allocator@UGlobalEntry@AINBFile@@@std@@@std@@@2@@std@@AEAAXXZ ; std::vector<std::vector<AINBFile::GlobalEntry,std::allocator<AINBFile::GlobalEntry> >,std::allocator<std::vector<AINBFile::GlobalEntry,std::allocator<AINBFile::GlobalEntry> > > >::_Tidy
	lea	rcx, QWORD PTR [rbx+208]
	call	?_Tidy@?$vector@UGlobalHeaderEntry@AINBFile@@V?$allocator@UGlobalHeaderEntry@AINBFile@@@std@@@std@@AEAAXXZ ; std::vector<AINBFile::GlobalHeaderEntry,std::allocator<AINBFile::GlobalHeaderEntry> >::_Tidy
	lea	rcx, QWORD PTR [rbx+184]
	call	?_Tidy@?$vector@UCommand@AINBFile@@V?$allocator@UCommand@AINBFile@@@std@@@std@@AEAAXXZ ; std::vector<AINBFile::Command,std::allocator<AINBFile::Command> >::_Tidy
	lea	rcx, QWORD PTR [rbx+40]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR [rbx+8]
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	jmp	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN82@AINBFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN107@AINBFile:
??1AINBFile@@QEAA@XZ ENDP				; AINBFile::~AINBFile
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@AINBFile@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@AINBFile@@QEAAX_K@Z PROC		; AINBFile::__autoclassinit2, COMDAT
	xor	edx, edx
	mov	r8d, 1072				; 00000430H
	jmp	memset
?__autoclassinit2@AINBFile@@QEAAX_K@Z ENDP		; AINBFile::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??0InputParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0InputParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z PROC ; AINBNodeDefMgr::NodeDef::InputParam::InputParam, COMDAT
$LN9:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rdi+32]
	lea	rdx, QWORD PTR [rbx+32]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rdi+64]
	lea	rdx, QWORD PTR [rbx+64]
	call	??0?$vector@W4FlagsStruct@AINBFile@@V?$allocator@W4FlagsStruct@AINBFile@@@std@@@std@@QEAA@AEBV01@@Z ; std::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >
	npad	1
	lea	rcx, QWORD PTR [rdi+88]
	lea	rdx, QWORD PTR [rbx+88]
	call	??0?$variant@I_NMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VVector3F@@@std@@QEAA@AEBV01@@Z
	mov	eax, DWORD PTR [rbx+128]
	mov	DWORD PTR [rdi+128], eax
	movzx	eax, BYTE PTR [rbx+132]
	mov	BYTE PTR [rdi+132], al
	mov	eax, DWORD PTR [rbx+136]
	mov	DWORD PTR [rdi+136], eax
	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0InputParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z ENDP ; AINBNodeDefMgr::NodeDef::InputParam::InputParam
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$0@?0???0InputParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z@4HA PROC ; `AINBNodeDefMgr::NodeDef::InputParam::InputParam'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???0InputParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z@4HA ENDP ; `AINBNodeDefMgr::NodeDef::InputParam::InputParam'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$1@?0???0InputParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z@4HA PROC ; `AINBNodeDefMgr::NodeDef::InputParam::InputParam'::`1'::dtor$1
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 32					; 00000020H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0???0InputParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z@4HA ENDP ; `AINBNodeDefMgr::NodeDef::InputParam::InputParam'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$2@?0???0InputParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z@4HA PROC ; `AINBNodeDefMgr::NodeDef::InputParam::InputParam'::`1'::dtor$2
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 64					; 00000040H
	jmp	??1?$vector@W4FlagsStruct@AINBFile@@V?$allocator@W4FlagsStruct@AINBFile@@@std@@@std@@QEAA@XZ ; std::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >::~vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >
?dtor$2@?0???0InputParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z@4HA ENDP ; `AINBNodeDefMgr::NodeDef::InputParam::InputParam'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??0ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z PROC ; AINBNodeDefMgr::NodeDef::ImmediateParam::ImmediateParam, COMDAT
$LN8:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, DWORD PTR [rbx+32]
	mov	DWORD PTR [rdi+32], eax
	lea	rcx, QWORD PTR [rdi+40]
	lea	rdx, QWORD PTR [rbx+40]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rdi+72]
	lea	rdx, QWORD PTR [rbx+72]
	call	??0?$vector@W4FlagsStruct@AINBFile@@V?$allocator@W4FlagsStruct@AINBFile@@@std@@@std@@QEAA@AEBV01@@Z ; std::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >
	npad	1
	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z ENDP ; AINBNodeDefMgr::NodeDef::ImmediateParam::ImmediateParam
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$0@?0???0ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z@4HA PROC ; `AINBNodeDefMgr::NodeDef::ImmediateParam::ImmediateParam'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???0ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z@4HA ENDP ; `AINBNodeDefMgr::NodeDef::ImmediateParam::ImmediateParam'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$1@?0???0ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z@4HA PROC ; `AINBNodeDefMgr::NodeDef::ImmediateParam::ImmediateParam'::`1'::dtor$1
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 40					; 00000028H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0???0ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z@4HA ENDP ; `AINBNodeDefMgr::NodeDef::ImmediateParam::ImmediateParam'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ??0recursive_directory_iterator@filesystem@std@@QEAA@AEBV012@@Z
_TEXT	SEGMENT
this$ = 8
__that$ = 16
??0recursive_directory_iterator@filesystem@std@@QEAA@AEBV012@@Z PROC ; std::filesystem::recursive_directory_iterator::recursive_directory_iterator, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 1470 :     element_type* _Ptr{nullptr};

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 1471 :     _Ref_count_base* _Rep{nullptr};

	mov	QWORD PTR [rcx+8], rax

; 1396 :         if (_Rep) {

	mov	rax, QWORD PTR [rdx+8]
	test	rax, rax
	je	SHORT $LN13@recursive_

; 1169 :         _MT_INCR(_Uses);

	lock inc DWORD PTR [rax+8]
$LN13@recursive_:

; 1357 :         _Ptr = _Other._Ptr;

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 1358 :         _Rep = _Other._Rep;

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rcx+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2865 :         recursive_directory_iterator(const recursive_directory_iterator&) noexcept = default; // strengthened

	mov	rax, rcx
	ret	0
??0recursive_directory_iterator@filesystem@std@@QEAA@AEBV012@@Z ENDP ; std::filesystem::recursive_directory_iterator::recursive_directory_iterator
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@recursive_directory_iterator@filesystem@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@recursive_directory_iterator@filesystem@std@@QEAAX_K@Z PROC ; std::filesystem::recursive_directory_iterator::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rcx], xmm0
	ret	0
?__autoclassinit2@recursive_directory_iterator@filesystem@std@@QEAAX_K@Z ENDP ; std::filesystem::recursive_directory_iterator::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp
;	COMDAT ?NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z
_TEXT	SEGMENT
__$ReturnUdt$GSCopy$ = 32
$T1 = 32
$T2 = 32
__$ReturnUdt$GSCopy$1$ = 48
$T3 = 48
$T4 = 64
$T5 = 96
Entry$6 = 128
Entry$7 = 128
Param$8 = 368
Param$9 = 368
NewNode$ = 512
__$ArrayPad$ = 1184
__$ReturnUdt$ = 1264
Def$ = 1272
?NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z PROC ; AINBNodeDefMgr::NodeDefToNode, COMDAT

; 630  : {

$LN674:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-944]
	sub	rsp, 1200				; 000004b0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	r13, rdx
	mov	rbx, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$1$[rsp], rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
	xor	edi, edi

; 631  : 	if (Def == nullptr)

	test	rdx, rdx
	jne	$LN11@NodeDefToN

; 633  : 		Logger::Error("AINBNodeDefMgr", "Could not convert node definition to node instance, node definition was a nullptr");

	lea	rax, QWORD PTR $T4[rsp]
	mov	QWORD PTR $T3[rsp], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T4[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T4[rsp+16], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T4[rsp+24], rdi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rdx+81]
	lea	rdx, OFFSET FLAT:??_C@_0FC@DDDONPLO@Could?5not?5convert?5node?5definiti@
	lea	rcx, QWORD PTR $T4[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T5[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T5[rsp+16], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T5[rsp+24], rdi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [r13+14]
	lea	rdx, OFFSET FLAT:??_C@_0P@NFEGPIHE@AINBNodeDefMgr@
	lea	rcx, QWORD PTR $T5[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 633  : 		Logger::Error("AINBNodeDefMgr", "Could not convert node definition to node instance, node definition was a nullptr");

	lea	rdx, QWORD PTR $T4[rsp]
	lea	rcx, QWORD PTR $T5[rsp]
	call	?Error@Logger@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; Logger::Error

; 634  : 		return AINBFile::Node();

	xor	edx, edx
	mov	r8d, 664				; 00000298H
	mov	rcx, rbx
	call	memset
	mov	rcx, rbx
	call	??0Node@AINBFile@@QEAA@XZ
	mov	rax, rbx
	jmp	$LN1@NodeDefToN
$LN11@NodeDefToN:

; 635  : 	}
; 636  : 
; 637  : 	AINBFile::Node NewNode;

	lea	rcx, QWORD PTR NewNode$[rbp-256]
	call	??0Node@AINBFile@@QEAA@XZ
	npad	1

; 638  : 	NewNode.Name = Def->Name;

	lea	rdx, QWORD PTR [r13+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3156 :         if (this == _STD addressof(_Right)) {

	lea	rax, QWORD PTR NewNode$[rbp-224]
	cmp	rax, rdx
	je	SHORT $LN624@NodeDefToN

; 3157 :             return *this;
; 3158 :         }
; 3159 : 
; 3160 :         auto& _Al             = _Getal();
; 3161 :         const auto& _Right_al = _Right._Getal();
; 3162 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 3163 :             if (_Al != _Right_al) {
; 3164 :                 auto&& _Alproxy       = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 3165 :                 auto&& _Right_alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Right_al);
; 3166 :                 _Container_proxy_ptr<_Alty> _New_proxy(_Right_alproxy, _Leave_proxy_unbound{}); // throws
; 3167 : 
; 3168 :                 if (_Right._Mypair._Myval2._Large_string_engaged()) {
; 3169 :                     const auto _New_size     = _Right._Mypair._Myval2._Mysize;
; 3170 :                     const auto _New_capacity = _Calculate_growth(_New_size, 0, _Right.max_size());
; 3171 :                     auto _Right_al_non_const = _Right_al;
; 3172 :                     const auto _New_ptr      = _Right_al_non_const.allocate(_New_capacity + 1); // throws
; 3173 : 
; 3174 :                     _Start_element_lifetimes(_Unfancy(_New_ptr), _New_size + 1);
; 3175 : 
; 3176 :                     _Traits::copy(_Unfancy(_New_ptr), _Unfancy(_Right._Mypair._Myval2._Bx._Ptr), _New_size + 1);
; 3177 :                     _Tidy_deallocate();
; 3178 :                     _Mypair._Myval2._Bx._Ptr = _New_ptr;
; 3179 :                     _Mypair._Myval2._Mysize  = _New_size;
; 3180 :                     _Mypair._Myval2._Myres   = _New_capacity;
; 3181 :                 } else {
; 3182 :                     _Copy_assign_val_from_small(_Right);
; 3183 :                 }
; 3184 : 
; 3185 :                 _Pocca(_Al, _Right_al);
; 3186 :                 _New_proxy._Bind(_Alproxy, _STD addressof(_Mypair._Myval2));
; 3187 :                 return *this;
; 3188 :             }
; 3189 :         }
; 3190 : 
; 3191 :         _Pocca(_Al, _Right_al);
; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rdx+16]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rdx+24], 16
	jb	SHORT $LN628@NodeDefToN

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN628@NodeDefToN:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	lea	rcx, QWORD PTR NewNode$[rbp-224]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN624@NodeDefToN:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 639  : 	NewNode.NameHash = Def->NameHash;

	mov	eax, DWORD PTR [r13+72]
	mov	DWORD PTR NewNode$[rbp-192], eax

; 640  : 	NewNode.Type = Def->Type;

	movzx	eax, WORD PTR [r13+76]
	mov	WORD PTR NewNode$[rbp-256], ax

; 641  : 	NewNode.OutputParameters = Def->OutputParameters;

	lea	r8, QWORD PTR [r13+128]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1483 :         if (this == _STD addressof(_Right)) {

	lea	rax, QWORD PTR NewNode$[rbp-56]
	cmp	rax, r8
	je	SHORT $LN621@NodeDefToN

; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [r8]
	mov	r8, QWORD PTR [r8+8]
	sub	r8, rdx
	sar	r8, 3
	mov	rax, -6148914691236517205		; aaaaaaaaaaaaaaabH
	imul	r8, rax
	lea	rcx, QWORD PTR NewNode$[rbp-56]
	call	??$_Assign_counted_range@PEAV?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@@?$vector@V?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@V?$allocator@V?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@@2@@std@@AEAAXPEAV?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@1@_K@Z ; std::vector<std::vector<AINBFile::OutputEntry,std::allocator<AINBFile::OutputEntry> >,std::allocator<std::vector<AINBFile::OutputEntry,std::allocator<AINBFile::OutputEntry> > > >::_Assign_counted_range<std::vector<AINBFile::OutputEntry,std::allocator<AINBFile::OutputEntry> > *>
$LN621@NodeDefToN:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 642  : 	NewNode.EditorFlowLinkParams = Def->LinkedNodeParams;

	lea	r8, QWORD PTR [r13+152]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1483 :         if (this == _STD addressof(_Right)) {

	lea	rax, QWORD PTR NewNode$[rbp+384]
	cmp	rax, r8
	je	SHORT $LN618@NodeDefToN

; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [r8]
	mov	r8, QWORD PTR [r8+8]
	sub	r8, rdx
	sar	r8, 5
	lea	rcx, QWORD PTR NewNode$[rbp+384]
	call	??$_Assign_counted_range@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Assign_counted_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
$LN618@NodeDefToN:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 643  : 	NewNode.Flags = Def->Flags;

	lea	r8, QWORD PTR [r13+200]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1483 :         if (this == _STD addressof(_Right)) {

	lea	rax, QWORD PTR NewNode$[rbp-248]
	cmp	rax, r8
	je	SHORT $LN615@NodeDefToN

; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [r8]
	mov	r8, QWORD PTR [r8+8]
	sub	r8, rdx
	lea	rcx, QWORD PTR NewNode$[rbp-248]
	call	??$_Assign_counted_range@PEAW4FlagsStruct@AINBFile@@@?$vector@W4FlagsStruct@AINBFile@@V?$allocator@W4FlagsStruct@AINBFile@@@std@@@std@@AEAAXPEAW4FlagsStruct@AINBFile@@_K@Z ; std::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >::_Assign_counted_range<enum AINBFile::FlagsStruct *>
$LN615@NodeDefToN:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 645  : 	NewNode.InputParameters.resize(6);

	lea	rcx, QWORD PTR NewNode$[rbp-80]
	call	?resize@?$vector@V?$vector@UInputEntry@AINBFile@@V?$allocator@UInputEntry@AINBFile@@@std@@@std@@V?$allocator@V?$vector@UInputEntry@AINBFile@@V?$allocator@UInputEntry@AINBFile@@@std@@@std@@@2@@std@@QEAAX_K@Z ; std::vector<std::vector<AINBFile::InputEntry,std::allocator<AINBFile::InputEntry> >,std::allocator<std::vector<AINBFile::InputEntry,std::allocator<AINBFile::InputEntry> > > >::resize

; 646  : 	NewNode.ImmediateParameters.resize(6);

	lea	rcx, QWORD PTR NewNode$[rbp-104]
	call	?resize@?$vector@V?$vector@UImmediateParameter@AINBFile@@V?$allocator@UImmediateParameter@AINBFile@@@std@@@std@@V?$allocator@V?$vector@UImmediateParameter@AINBFile@@V?$allocator@UImmediateParameter@AINBFile@@@std@@@std@@@2@@std@@QEAAX_K@Z ; std::vector<std::vector<AINBFile::ImmediateParameter,std::allocator<AINBFile::ImmediateParameter> >,std::allocator<std::vector<AINBFile::ImmediateParameter,std::allocator<AINBFile::ImmediateParameter> > > >::resize

; 647  : 
; 648  : 	for (int Type = 0; Type < AINBFile::ValueTypeCount; Type++)

	xor	ebx, ebx
	mov	r12d, ebx

; 645  : 	NewNode.InputParameters.resize(6);

	mov	r14d, ebx
$LN671@NodeDefToN:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	r15, OFFSET FLAT:__ImageBase
	mov	rax, QWORD PTR [r13+104]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 650  : 		for (AINBNodeDefMgr::NodeDef::InputParam Param : Def->InputParameters[Type])

	mov	rdi, QWORD PTR [r14+rax]
	mov	rsi, QWORD PTR [r14+rax+8]
	cmp	rdi, rsi
	je	$LN6@NodeDefToN
	npad	1
$LL7@NodeDefToN:
	mov	rdx, rdi
	lea	rcx, QWORD PTR Param$9[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rdx, QWORD PTR [rdi+32]
	lea	rcx, QWORD PTR Param$9[rbp-224]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rdx, QWORD PTR [rdi+64]
	lea	rcx, QWORD PTR Param$9[rbp-192]
	call	??0?$vector@W4FlagsStruct@AINBFile@@V?$allocator@W4FlagsStruct@AINBFile@@@std@@@std@@QEAA@AEBV01@@Z ; std::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >
	npad	1
	lea	rdx, QWORD PTR [rdi+88]
	lea	rcx, QWORD PTR Param$9[rbp-168]
	call	??0?$variant@I_NMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VVector3F@@@std@@QEAA@AEBV01@@Z
	mov	eax, DWORD PTR [rdi+128]
	mov	DWORD PTR Param$9[rbp-128], eax
	movzx	eax, BYTE PTR [rdi+132]
	mov	BYTE PTR Param$9[rbp-124], al
	mov	eax, DWORD PTR [rdi+136]
	mov	DWORD PTR Param$9[rbp-120], eax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR Entry$7[rbp-256], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR Entry$7[rbp-240], rbx

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR Entry$7[rbp-232], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR Entry$7[rbp-256], 0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR Entry$7[rbp-224], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR Entry$7[rbp-208], rbx

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR Entry$7[rbp-200], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR Entry$7[rbp-224], 0
	mov	DWORD PTR Entry$7[rbp-192], 65535	; 0000ffffH
	mov	DWORD PTR Entry$7[rbp-188], -1		; ffffffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR Entry$7[rbp-184], rbx
	movdqa	XMMWORD PTR Entry$7[rbp-176], xmm0
	mov	eax, 65535				; 0000ffffH
	mov	WORD PTR Entry$7[rbp-160], ax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	mov	DWORD PTR Entry$7[rbp-152], ebx

; 795  :           _Which{static_cast<_Index_t>(_Idx)} { // initialize alternative _Idx from _Args...

	mov	BYTE PTR Entry$7[rbp-120], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR Entry$7[rbp-104], rbx
	movdqa	XMMWORD PTR Entry$7[rbp-96], xmm0
	mov	WORD PTR Entry$7[rbp-80], ax
	mov	QWORD PTR Entry$7[rbp-72], 0
	mov	QWORD PTR Entry$7[rbp-64], 0
	mov	QWORD PTR Entry$7[rbp-56], 0
	mov	DWORD PTR Entry$7[rbp-48], 0
	mov	QWORD PTR Entry$7[rbp-40], rbx
	movdqa	XMMWORD PTR Entry$7[rbp-32], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR Param$9[rbp-256]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR Param$9[rbp-232], 16
	cmovae	rdx, QWORD PTR Param$9[rbp-256]

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR Param$9[rbp-240]
	lea	rcx, QWORD PTR Entry$7[rbp-256]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR Param$9[rbp-224]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR Param$9[rbp-200], 16
	cmovae	rdx, QWORD PTR Param$9[rbp-224]

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR Param$9[rbp-208]
	lea	rcx, QWORD PTR Entry$7[rbp-224]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	r8, QWORD PTR Param$9[rbp-184]
	mov	rdx, QWORD PTR Param$9[rbp-192]
	sub	r8, rdx
	lea	rcx, QWORD PTR Entry$7[rbp-184]
	call	??$_Assign_counted_range@PEAW4FlagsStruct@AINBFile@@@?$vector@W4FlagsStruct@AINBFile@@V?$allocator@W4FlagsStruct@AINBFile@@@std@@@std@@AEAAXPEAW4FlagsStruct@AINBFile@@_K@Z ; std::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >::_Assign_counted_range<enum AINBFile::FlagsStruct *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 656  : 			Entry.ValueType = (int)Param.ValueType;

	mov	eax, DWORD PTR Param$9[rbp-128]
	mov	DWORD PTR Entry$7[rbp-112], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 865  :         _STD _Variant_raw_visit(_That.index(), _That._Storage(), _Variant_assign_visitor<_Types...>{*this});

	lea	rax, QWORD PTR Entry$7[rbp-152]
	mov	QWORD PTR $T1[rsp], rax

; 803  :         return static_cast<size_t>(_Which);

	movsx	rcx, BYTE PTR Param$9[rbp-136]

; 691  :     ++_Idx; // bias index by +1 to map {variant_npos} U [0, _Size) to the contiguous range [0, _Size]

	inc	rcx

; 692  :     return _Variant_raw_visit1<_Strategy>::_Visit(_Idx, static_cast<_Fn&&>(_Func), static_cast<_Storage&&>(_Obj));

	lea	r8, QWORD PTR Param$9[rbp-168]
	lea	rdx, QWORD PTR $T1[rsp]
	call	??$_Visit@U?$_Variant_assign_visitor@I_NMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VVector3F@@@std@@AEBV?$_Variant_storage_@$0A@I_NMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VVector3F@@@2@@?$_Variant_raw_visit1@$01@std@@SAX_K$$QEAU?$_Variant_assign_visitor@I_NMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VVector3F@@@1@AEBV?$_Variant_storage_@$0A@I_NMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VVector3F@@@1@@Z ; std::_Variant_raw_visit1<2>::_Visit<std::_Variant_assign_visitor<unsigned int,bool,float,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Vector3F>,std::_Variant_storage_<0,unsigned int,bool,float,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Vector3F> const &>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 658  : 			Entry.NodeIndex = -1;

	mov	DWORD PTR Entry$7[rbp-192], 65535	; 0000ffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rbx, QWORD PTR NewNode$[rbp-80]
	add	rbx, r14

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rax, QWORD PTR [rbx+8]
	cmp	rax, QWORD PTR [rbx+16]
	je	SHORT $LN493@NodeDefToN
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	lea	rdx, QWORD PTR Entry$7[rbp-256]
	mov	rcx, rax
	call	??0InputEntry@AINBFile@@QEAA@AEBU01@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 806  :         ++_Mylast;

	add	QWORD PTR [rbx+8], 240			; 000000f0H

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN492@NodeDefToN
$LN493@NodeDefToN:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR Entry$7[rbp-256]
	mov	rdx, rax
	mov	rcx, rbx
	call	??$_Emplace_reallocate@AEBUInputEntry@AINBFile@@@?$vector@UInputEntry@AINBFile@@V?$allocator@UInputEntry@AINBFile@@@std@@@std@@AEAAPEAUInputEntry@AINBFile@@QEAU23@AEBU23@@Z ; std::vector<AINBFile::InputEntry,std::allocator<AINBFile::InputEntry> >::_Emplace_reallocate<AINBFile::InputEntry const &>
	npad	1
$LN492@NodeDefToN:

; 767  :         _Tidy();

	lea	rcx, QWORD PTR Entry$7[rbp-40]
	call	?_Tidy@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAXXZ ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::_Tidy
	lea	rcx, QWORD PTR Entry$7[rbp-104]
	call	?_Tidy@?$vector@UMultiEntry@AINBFile@@V?$allocator@UMultiEntry@AINBFile@@@std@@@std@@AEAAXXZ ; std::vector<AINBFile::MultiEntry,std::allocator<AINBFile::MultiEntry> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 803  :         return static_cast<size_t>(_Which);

	movsx	rax, BYTE PTR Entry$7[rbp-120]

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	mov	eax, DWORD PTR $LN663@NodeDefToN[r15+rax*4+4]
	add	rax, r15
	jmp	rax
$LN426@NodeDefToN:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR Entry$7[rbp-152]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN444@NodeDefToN:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR Entry$7[rbp-184]
	test	rcx, rcx
	je	SHORT $LN669@NodeDefToN

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR Entry$7[rbp-168]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN479@NodeDefToN

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN476@NodeDefToN
$LN479@NodeDefToN:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	xor	ebx, ebx
	mov	QWORD PTR Entry$7[rbp-184], rbx
	xorps	xmm0, xmm0

; 2050 :             _Mylast  = nullptr;

	movdqa	XMMWORD PTR Entry$7[rbp-176], xmm0

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	jmp	SHORT $LN461@NodeDefToN
$LN669@NodeDefToN:
	xor	ebx, ebx
$LN461@NodeDefToN:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR Entry$7[rbp-224]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR Entry$7[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 803  :         return static_cast<size_t>(_Which);

	movsx	rax, BYTE PTR Param$9[rbp-136]

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	mov	eax, DWORD PTR $LN662@NodeDefToN[r15+rax*4+4]
	add	rax, r15
	jmp	rax
$LN321@NodeDefToN:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR Param$9[rbp-168]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN339@NodeDefToN:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR Param$9[rbp-192]
	test	rcx, rcx
	je	SHORT $LN356@NodeDefToN

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR Param$9[rbp-176]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN374@NodeDefToN

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN371@NodeDefToN
$LN374@NodeDefToN:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	movdqa	XMMWORD PTR Param$9[rbp-192], xmm0

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR Param$9[rbp-176], rbx
$LN356@NodeDefToN:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR Param$9[rbp-224]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR Param$9[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 650  : 		for (AINBNodeDefMgr::NodeDef::InputParam Param : Def->InputParameters[Type])

	add	rdi, 144				; 00000090H
	cmp	rdi, rsi
	jne	$LL7@NodeDefToN
$LN6@NodeDefToN:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r13+80]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 670  : 		for (AINBNodeDefMgr::NodeDef::ImmediateParam Param : Def->ImmediateParameters[Type])

	mov	rsi, QWORD PTR [r14+rax]
	mov	r15, QWORD PTR [r14+rax+8]
	cmp	rsi, r15
	je	$LN2@NodeDefToN
	npad	10
$LL10@NodeDefToN:
	mov	rdx, rsi
	lea	rcx, QWORD PTR Param$8[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, DWORD PTR [rsi+32]
	mov	DWORD PTR Param$8[rbp-224], eax
	lea	rdx, QWORD PTR [rsi+40]
	lea	rcx, QWORD PTR Param$8[rbp-216]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rdx, QWORD PTR [rsi+72]
	lea	rcx, QWORD PTR Param$8[rbp-184]
	call	??0?$vector@W4FlagsStruct@AINBFile@@V?$allocator@W4FlagsStruct@AINBFile@@@std@@@std@@QEAA@AEBV01@@Z ; std::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >
	npad	1
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR Entry$6[rbp-256], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR Entry$6[rbp-240], rbx

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR Entry$6[rbp-232], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR Entry$6[rbp-256], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	mov	DWORD PTR Entry$6[rbp-224], ebx

; 795  :           _Which{static_cast<_Index_t>(_Idx)} { // initialize alternative _Idx from _Args...

	mov	BYTE PTR Entry$6[rbp-192], 0
	mov	eax, -1
	mov	DWORD PTR Entry$6[rbp-184], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR Entry$6[rbp-176], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR Entry$6[rbp-160], rbx

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR Entry$6[rbp-152], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR Entry$6[rbp-176], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqa	XMMWORD PTR Entry$6[rbp-144], xmm0
	mov	QWORD PTR Entry$6[rbp-128], rbx
	mov	DWORD PTR Entry$6[rbp-120], -1		; ffffffffH
	mov	QWORD PTR Entry$6[rbp-112], 0
	mov	QWORD PTR Entry$6[rbp-104], 0
	mov	QWORD PTR Entry$6[rbp-96], 0
	mov	DWORD PTR Entry$6[rbp-88], 0
	movdqa	XMMWORD PTR Entry$6[rbp-80], xmm0
	mov	QWORD PTR Entry$6[rbp-64], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR Param$8[rbp-256]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR Param$8[rbp-232], 16
	cmovae	rdx, QWORD PTR Param$8[rbp-256]

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR Param$8[rbp-240]
	lea	rcx, QWORD PTR Entry$6[rbp-256]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR Param$8[rbp-216]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR Param$8[rbp-192], 16
	cmovae	rdx, QWORD PTR Param$8[rbp-216]

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR Param$8[rbp-200]
	lea	rcx, QWORD PTR Entry$6[rbp-176]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	r8, QWORD PTR Param$8[rbp-176]
	mov	rdx, QWORD PTR Param$8[rbp-184]
	sub	r8, rdx
	lea	rcx, QWORD PTR Entry$6[rbp-144]
	call	??$_Assign_counted_range@PEAW4FlagsStruct@AINBFile@@@?$vector@W4FlagsStruct@AINBFile@@V?$allocator@W4FlagsStruct@AINBFile@@@std@@@std@@AEAAXPEAW4FlagsStruct@AINBFile@@_K@Z ; std::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >::_Assign_counted_range<enum AINBFile::FlagsStruct *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 676  : 			Entry.ValueType = (int)Param.ValueType;

	mov	eax, DWORD PTR Param$8[rbp-224]
	mov	DWORD PTR Entry$6[rbp-184], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rdi, QWORD PTR NewNode$[rbp-104]
	add	rdi, r14

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rbx, QWORD PTR [rdi+8]
	cmp	rbx, QWORD PTR [rdi+16]
	je	SHORT $LN118@NodeDefToN
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T2[rsp], rbx
	lea	rdx, QWORD PTR Entry$6[rbp-256]
	mov	rcx, rbx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rbx+32]
	lea	rdx, QWORD PTR Entry$6[rbp-224]
	call	??0?$variant@I_NMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VVector3F@@@std@@QEAA@AEBV01@@Z
	npad	1
	mov	eax, DWORD PTR Entry$6[rbp-184]
	mov	DWORD PTR [rbx+72], eax
	lea	rcx, QWORD PTR [rbx+80]
	lea	rdx, QWORD PTR Entry$6[rbp-176]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rbx+112]
	lea	rdx, QWORD PTR Entry$6[rbp-144]
	call	??0?$vector@W4FlagsStruct@AINBFile@@V?$allocator@W4FlagsStruct@AINBFile@@@std@@@std@@QEAA@AEBV01@@Z ; std::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >
	npad	1
	movzx	eax, WORD PTR Entry$6[rbp-120]
	mov	WORD PTR [rbx+136], ax
	movzx	eax, WORD PTR Entry$6[rbp-118]
	mov	WORD PTR [rbx+138], ax
	lea	rcx, QWORD PTR [rbx+144]
	lea	rdx, QWORD PTR Entry$6[rbp-112]
	call	??0CommandInfoStruct@EXB@@QEAA@AEBU01@@Z
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 806  :         ++_Mylast;

	add	QWORD PTR [rdi+8], 200			; 000000c8H

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN117@NodeDefToN
$LN118@NodeDefToN:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR Entry$6[rbp-256]
	mov	rdx, rbx
	mov	rcx, rdi
	call	??$_Emplace_reallocate@AEBUImmediateParameter@AINBFile@@@?$vector@UImmediateParameter@AINBFile@@V?$allocator@UImmediateParameter@AINBFile@@@std@@@std@@AEAAPEAUImmediateParameter@AINBFile@@QEAU23@AEBU23@@Z ; std::vector<AINBFile::ImmediateParameter,std::allocator<AINBFile::ImmediateParameter> >::_Emplace_reallocate<AINBFile::ImmediateParameter const &>
	npad	1
$LN117@NodeDefToN:

; 767  :         _Tidy();

	lea	rcx, QWORD PTR Entry$6[rbp-80]
	call	?_Tidy@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAXXZ ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::_Tidy

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR Entry$6[rbp-144]
	test	rcx, rcx
	je	SHORT $LN668@NodeDefToN

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR Entry$6[rbp-128]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN162@NodeDefToN

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN159@NodeDefToN
$LN162@NodeDefToN:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	movdqa	XMMWORD PTR Entry$6[rbp-144], xmm0

; 2051 :             _Myend   = nullptr;

	xor	ebx, ebx
	mov	QWORD PTR Entry$6[rbp-128], rbx

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	jmp	SHORT $LN144@NodeDefToN
$LN668@NodeDefToN:
	xor	ebx, ebx
$LN144@NodeDefToN:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR Entry$6[rbp-176]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 803  :         return static_cast<size_t>(_Which);

	movsx	rax, BYTE PTR Entry$6[rbp-192]

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN661@NodeDefToN[rcx+rax*4+4]
	add	rax, rcx
	jmp	rax
$LN202@NodeDefToN:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR Entry$6[rbp-224]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN220@NodeDefToN:
	lea	rcx, QWORD PTR Entry$6[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR Param$8[rbp-184]
	test	rcx, rcx
	je	SHORT $LN243@NodeDefToN

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR Param$8[rbp-168]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN261@NodeDefToN

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN258@NodeDefToN
$LN261@NodeDefToN:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	mov	QWORD PTR Param$8[rbp-184], rbx
	xorps	xmm0, xmm0

; 2050 :             _Mylast  = nullptr;

	movdqa	XMMWORD PTR Param$8[rbp-176], xmm0
$LN243@NodeDefToN:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR Param$8[rbp-216]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR Param$8[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 670  : 		for (AINBNodeDefMgr::NodeDef::ImmediateParam Param : Def->ImmediateParameters[Type])

	add	rsi, 96					; 00000060H
	cmp	rsi, r15
	jne	$LL10@NodeDefToN
$LN2@NodeDefToN:

; 647  : 
; 648  : 	for (int Type = 0; Type < AINBFile::ValueTypeCount; Type++)

	inc	r12d
	add	r14, 24
	cmp	r12d, 6
	jb	$LN671@NodeDefToN

; 677  : 			NewNode.ImmediateParameters[Type].push_back(Entry);
; 678  : 		}
; 679  : 	}
; 680  : 
; 681  : 	return NewNode;

	lea	rdx, QWORD PTR NewNode$[rbp-256]
	mov	rcx, QWORD PTR __$ReturnUdt$GSCopy$1$[rsp]
	call	??0Node@AINBFile@@QEAA@$$QEAU01@@Z
	npad	1
	lea	rcx, QWORD PTR NewNode$[rbp-256]
	call	??1Node@AINBFile@@QEAA@XZ
	mov	rax, QWORD PTR __$ReturnUdt$GSCopy$1$[rsp]
$LN1@NodeDefToN:

; 682  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+1280]
	add	rsp, 1200				; 000004b0H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN476@NodeDefToN:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN371@NodeDefToN:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN334@NodeDefToN:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

$LN439@NodeDefToN:
$LN159@NodeDefToN:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN258@NodeDefToN:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN215@NodeDefToN:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

$LN670@NodeDefToN:
	npad	1
$LN663@NodeDefToN:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINBNodeDefMgr.cpp

; 682  : }

	DD	$LN444@NodeDefToN
	DD	$LN444@NodeDefToN
	DD	$LN444@NodeDefToN
	DD	$LN444@NodeDefToN
	DD	$LN426@NodeDefToN
	DD	$LN444@NodeDefToN
$LN662@NodeDefToN:
	DD	$LN339@NodeDefToN
	DD	$LN339@NodeDefToN
	DD	$LN339@NodeDefToN
	DD	$LN339@NodeDefToN
	DD	$LN321@NodeDefToN
	DD	$LN339@NodeDefToN
$LN661@NodeDefToN:
	DD	$LN220@NodeDefToN
	DD	$LN220@NodeDefToN
	DD	$LN220@NodeDefToN
	DD	$LN220@NodeDefToN
	DD	$LN202@NodeDefToN
	DD	$LN220@NodeDefToN
?NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z ENDP ; AINBNodeDefMgr::NodeDefToNode
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
__$ReturnUdt$GSCopy$ = 32
$T1 = 32
$T2 = 32
__$ReturnUdt$GSCopy$1$ = 48
$T3 = 48
$T4 = 64
$T5 = 96
Entry$6 = 128
Entry$7 = 128
Param$8 = 368
Param$9 = 368
NewNode$ = 512
__$ArrayPad$ = 1184
__$ReturnUdt$ = 1264
Def$ = 1272
?dtor$0@?0??NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z@4HA PROC ; `AINBNodeDefMgr::NodeDefToNode'::`1'::dtor$0
	mov	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z@4HA ENDP ; `AINBNodeDefMgr::NodeDefToNode'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
__$ReturnUdt$GSCopy$ = 32
$T1 = 32
$T2 = 32
__$ReturnUdt$GSCopy$1$ = 48
$T3 = 48
$T4 = 64
$T5 = 96
Entry$6 = 128
Entry$7 = 128
Param$8 = 368
Param$9 = 368
NewNode$ = 512
__$ArrayPad$ = 1184
__$ReturnUdt$ = 1264
Def$ = 1272
?dtor$3@?0??NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z@4HA PROC ; `AINBNodeDefMgr::NodeDefToNode'::`1'::dtor$3
	lea	rcx, QWORD PTR NewNode$[rdx]
	jmp	??1Node@AINBFile@@QEAA@XZ
?dtor$3@?0??NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z@4HA ENDP ; `AINBNodeDefMgr::NodeDefToNode'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
__$ReturnUdt$GSCopy$ = 32
$T1 = 32
$T2 = 32
__$ReturnUdt$GSCopy$1$ = 48
$T3 = 48
$T4 = 64
$T5 = 96
Entry$6 = 128
Entry$7 = 128
Param$8 = 368
Param$9 = 368
NewNode$ = 512
__$ArrayPad$ = 1184
__$ReturnUdt$ = 1264
Def$ = 1272
?dtor$66@?0??NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z@4HA PROC ; `AINBNodeDefMgr::NodeDefToNode'::`1'::dtor$66
	lea	rcx, QWORD PTR Param$9[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$66@?0??NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z@4HA ENDP ; `AINBNodeDefMgr::NodeDefToNode'::`1'::dtor$66
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
__$ReturnUdt$GSCopy$ = 32
$T1 = 32
$T2 = 32
__$ReturnUdt$GSCopy$1$ = 48
$T3 = 48
$T4 = 64
$T5 = 96
Entry$6 = 128
Entry$7 = 128
Param$8 = 368
Param$9 = 368
NewNode$ = 512
__$ArrayPad$ = 1184
__$ReturnUdt$ = 1264
Def$ = 1272
?dtor$67@?0??NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z@4HA PROC ; `AINBNodeDefMgr::NodeDefToNode'::`1'::dtor$67
	lea	rcx, QWORD PTR Param$9[rdx]
	add	rcx, 32					; 00000020H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$67@?0??NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z@4HA ENDP ; `AINBNodeDefMgr::NodeDefToNode'::`1'::dtor$67
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
__$ReturnUdt$GSCopy$ = 32
$T1 = 32
$T2 = 32
__$ReturnUdt$GSCopy$1$ = 48
$T3 = 48
$T4 = 64
$T5 = 96
Entry$6 = 128
Entry$7 = 128
Param$8 = 368
Param$9 = 368
NewNode$ = 512
__$ArrayPad$ = 1184
__$ReturnUdt$ = 1264
Def$ = 1272
?dtor$68@?0??NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z@4HA PROC ; `AINBNodeDefMgr::NodeDefToNode'::`1'::dtor$68
	lea	rcx, QWORD PTR Param$9[rdx]
	add	rcx, 64					; 00000040H
	jmp	??1?$vector@W4FlagsStruct@AINBFile@@V?$allocator@W4FlagsStruct@AINBFile@@@std@@@std@@QEAA@XZ ; std::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >::~vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >
?dtor$68@?0??NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z@4HA ENDP ; `AINBNodeDefMgr::NodeDefToNode'::`1'::dtor$68
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
__$ReturnUdt$GSCopy$ = 32
$T1 = 32
$T2 = 32
__$ReturnUdt$GSCopy$1$ = 48
$T3 = 48
$T4 = 64
$T5 = 96
Entry$6 = 128
Entry$7 = 128
Param$8 = 368
Param$9 = 368
NewNode$ = 512
__$ArrayPad$ = 1184
__$ReturnUdt$ = 1264
Def$ = 1272
?dtor$4@?0??NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z@4HA PROC ; `AINBNodeDefMgr::NodeDefToNode'::`1'::dtor$4
	lea	rcx, QWORD PTR Param$9[rdx]
	jmp	??1InputParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ
?dtor$4@?0??NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z@4HA ENDP ; `AINBNodeDefMgr::NodeDefToNode'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
__$ReturnUdt$GSCopy$ = 32
$T1 = 32
$T2 = 32
__$ReturnUdt$GSCopy$1$ = 48
$T3 = 48
$T4 = 64
$T5 = 96
Entry$6 = 128
Entry$7 = 128
Param$8 = 368
Param$9 = 368
NewNode$ = 512
__$ArrayPad$ = 1184
__$ReturnUdt$ = 1264
Def$ = 1272
?dtor$5@?0??NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z@4HA PROC ; `AINBNodeDefMgr::NodeDefToNode'::`1'::dtor$5
	lea	rcx, QWORD PTR Entry$7[rdx]
	jmp	??1InputEntry@AINBFile@@QEAA@XZ
?dtor$5@?0??NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z@4HA ENDP ; `AINBNodeDefMgr::NodeDefToNode'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
__$ReturnUdt$GSCopy$ = 32
$T1 = 32
$T2 = 32
__$ReturnUdt$GSCopy$1$ = 48
$T3 = 48
$T4 = 64
$T5 = 96
Entry$6 = 128
Entry$7 = 128
Param$8 = 368
Param$9 = 368
NewNode$ = 512
__$ArrayPad$ = 1184
__$ReturnUdt$ = 1264
Def$ = 1272
?dtor$23@?0??NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z@4HA PROC ; `AINBNodeDefMgr::NodeDefToNode'::`1'::dtor$23
	lea	rcx, QWORD PTR Param$8[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$23@?0??NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z@4HA ENDP ; `AINBNodeDefMgr::NodeDefToNode'::`1'::dtor$23
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
__$ReturnUdt$GSCopy$ = 32
$T1 = 32
$T2 = 32
__$ReturnUdt$GSCopy$1$ = 48
$T3 = 48
$T4 = 64
$T5 = 96
Entry$6 = 128
Entry$7 = 128
Param$8 = 368
Param$9 = 368
NewNode$ = 512
__$ArrayPad$ = 1184
__$ReturnUdt$ = 1264
Def$ = 1272
?dtor$24@?0??NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z@4HA PROC ; `AINBNodeDefMgr::NodeDefToNode'::`1'::dtor$24
	lea	rcx, QWORD PTR Param$8[rdx]
	add	rcx, 40					; 00000028H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$24@?0??NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z@4HA ENDP ; `AINBNodeDefMgr::NodeDefToNode'::`1'::dtor$24
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
__$ReturnUdt$GSCopy$ = 32
$T1 = 32
$T2 = 32
__$ReturnUdt$GSCopy$1$ = 48
$T3 = 48
$T4 = 64
$T5 = 96
Entry$6 = 128
Entry$7 = 128
Param$8 = 368
Param$9 = 368
NewNode$ = 512
__$ArrayPad$ = 1184
__$ReturnUdt$ = 1264
Def$ = 1272
?dtor$6@?0??NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z@4HA PROC ; `AINBNodeDefMgr::NodeDefToNode'::`1'::dtor$6
	lea	rcx, QWORD PTR Param$8[rdx]
	jmp	??1ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ
?dtor$6@?0??NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z@4HA ENDP ; `AINBNodeDefMgr::NodeDefToNode'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
__$ReturnUdt$GSCopy$ = 32
$T1 = 32
$T2 = 32
__$ReturnUdt$GSCopy$1$ = 48
$T3 = 48
$T4 = 64
$T5 = 96
Entry$6 = 128
Entry$7 = 128
Param$8 = 368
Param$9 = 368
NewNode$ = 512
__$ArrayPad$ = 1184
__$ReturnUdt$ = 1264
Def$ = 1272
?dtor$7@?0??NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z@4HA PROC ; `AINBNodeDefMgr::NodeDefToNode'::`1'::dtor$7
	lea	rcx, QWORD PTR Entry$6[rdx]
	jmp	??1ImmediateParameter@AINBFile@@QEAA@XZ
?dtor$7@?0??NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z@4HA ENDP ; `AINBNodeDefMgr::NodeDefToNode'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
__$ReturnUdt$GSCopy$ = 32
$T1 = 32
$T2 = 32
__$ReturnUdt$GSCopy$1$ = 48
$T3 = 48
$T4 = 64
$T5 = 96
Entry$6 = 128
Entry$7 = 128
Param$8 = 368
Param$9 = 368
NewNode$ = 512
__$ArrayPad$ = 1184
__$ReturnUdt$ = 1264
Def$ = 1272
?dtor$26@?0??NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z@4HA PROC ; `AINBNodeDefMgr::NodeDefToNode'::`1'::dtor$26
	mov	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$26@?0??NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z@4HA ENDP ; `AINBNodeDefMgr::NodeDefToNode'::`1'::dtor$26
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
__$ReturnUdt$GSCopy$ = 32
$T1 = 32
$T2 = 32
__$ReturnUdt$GSCopy$1$ = 48
$T3 = 48
$T4 = 64
$T5 = 96
Entry$6 = 128
Entry$7 = 128
Param$8 = 368
Param$9 = 368
NewNode$ = 512
__$ArrayPad$ = 1184
__$ReturnUdt$ = 1264
Def$ = 1272
?dtor$27@?0??NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z@4HA PROC ; `AINBNodeDefMgr::NodeDefToNode'::`1'::dtor$27
	mov	rcx, QWORD PTR $T2[rdx]
	add	rcx, 32					; 00000020H
	jmp	??1?$variant@I_NMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VVector3F@@@std@@QEAA@XZ
?dtor$27@?0??NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z@4HA ENDP ; `AINBNodeDefMgr::NodeDefToNode'::`1'::dtor$27
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
__$ReturnUdt$GSCopy$ = 32
$T1 = 32
$T2 = 32
__$ReturnUdt$GSCopy$1$ = 48
$T3 = 48
$T4 = 64
$T5 = 96
Entry$6 = 128
Entry$7 = 128
Param$8 = 368
Param$9 = 368
NewNode$ = 512
__$ArrayPad$ = 1184
__$ReturnUdt$ = 1264
Def$ = 1272
?dtor$28@?0??NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z@4HA PROC ; `AINBNodeDefMgr::NodeDefToNode'::`1'::dtor$28
	mov	rcx, QWORD PTR $T2[rdx]
	add	rcx, 80					; 00000050H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$28@?0??NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z@4HA ENDP ; `AINBNodeDefMgr::NodeDefToNode'::`1'::dtor$28
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
__$ReturnUdt$GSCopy$ = 32
$T1 = 32
$T2 = 32
__$ReturnUdt$GSCopy$1$ = 48
$T3 = 48
$T4 = 64
$T5 = 96
Entry$6 = 128
Entry$7 = 128
Param$8 = 368
Param$9 = 368
NewNode$ = 512
__$ArrayPad$ = 1184
__$ReturnUdt$ = 1264
Def$ = 1272
?dtor$29@?0??NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z@4HA PROC ; `AINBNodeDefMgr::NodeDefToNode'::`1'::dtor$29
	mov	rcx, QWORD PTR $T2[rdx]
	add	rcx, 112				; 00000070H
	jmp	??1?$vector@W4FlagsStruct@AINBFile@@V?$allocator@W4FlagsStruct@AINBFile@@@std@@@std@@QEAA@XZ ; std::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >::~vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >
?dtor$29@?0??NodeDefToNode@AINBNodeDefMgr@@YA?AUNode@AINBFile@@PEAUNodeDef@1@@Z@4HA ENDP ; `AINBNodeDefMgr::NodeDefToNode'::`1'::dtor$29
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > >::operator==, COMDAT

; 162  :         _Compat(_Right);
; 163  :         return _Ptr == _Right._Ptr;

	mov	rax, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rax
	sete	al

; 164  :     }

	ret	0
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??A?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAAEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAAEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z PROC ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::operator[], COMDAT

; 1883 :         auto& _My_data = _Mypair._Myval2;
; 1884 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1885 :         _STL_VERIFY(
; 1886 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1887 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1888 : 
; 1889 :         return _My_data._Myfirst[_Pos];

	lea	rax, QWORD PTR [rdx+rdx*2]
	shl	rax, 5
	add	rax, QWORD PTR [rcx]

; 1890 :     }

	ret	0
??A?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAAEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z ENDP ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?size@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ PROC ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::size, COMDAT

; 1868 :         auto& _My_data = _Mypair._Myval2;
; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	mov	rcx, -6148914691236517205		; aaaaaaaaaaaaaaabH
	sar	rax, 5
	imul	rax, rcx

; 1870 :     }

	ret	0
?size@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Unchecked_end@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@XZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_end@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@XZ PROC ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Unchecked_end, COMDAT

; 1855 :         return _Mypair._Myval2._Mylast;

	mov	rax, QWORD PTR [rcx+8]

; 1856 :     }

	ret	0
?_Unchecked_end@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@XZ ENDP ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Unchecked_begin@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@XZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_begin@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@XZ PROC ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Unchecked_begin, COMDAT

; 1847 :         return _Mypair._Myval2._Myfirst;

	mov	rax, QWORD PTR [rcx]

; 1848 :     }

	ret	0
?_Unchecked_begin@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@XZ ENDP ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?resize@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
?resize@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z PROC ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::resize, COMDAT

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

$LN30:
	mov	QWORD PTR [rsp+24], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rdi, QWORD PTR [rcx+8]

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	mov	r14, rcx

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r8, QWORD PTR [rcx]
	mov	r9, -6148914691236517205		; aaaaaaaaaaaaaaabH
	mov	rcx, rdi
	sub	rcx, r8
	sar	rcx, 5
	imul	rcx, r9

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdx, rcx
	jae	SHORT $LN4@resize
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rsi

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rsi, QWORD PTR [rdx+rdx*2]
	shl	rsi, 5
	add	rsi, r8

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rbx, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rsi, rdi
	je	SHORT $LN10@resize
	npad	1
$LL11@resize:
	mov	rcx, rbx
	call	??1ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ
	add	rbx, 96					; 00000060H
	cmp	rbx, rdi
	jne	SHORT $LL11@resize
$LN10@resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1563 :             _Mylast = _Newlast;

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [r14+8], rsi
	mov	rsi, QWORD PTR [rsp+56]

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN4@resize:

; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN5@resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [r14+16]
	sub	rax, r8
	sar	rax, 5
	imul	rax, r9

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN6@resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, r14

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Resize_reallocate<std::_Value_init_tag>
$LN6@resize:

; 1571 :                 return;
; 1572 :             }
; 1573 : 
; 1574 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1575 :             const pointer _Oldlast = _Mylast;
; 1576 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1577 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1578 :             } else {
; 1579 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, rcx
	mov	rcx, rdi
	call	??$_Uninitialized_value_construct_n@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@_KAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >
	mov	QWORD PTR [r14+8], rax
$LN5@resize:

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
?resize@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z ENDP ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?resize@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
?resize@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@QEAAX_K@Z PROC ; std::vector<AINBFile::OutputEntry,std::allocator<AINBFile::OutputEntry> >::resize, COMDAT

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

$LN39:
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rdi, QWORD PTR [rcx+8]

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	mov	rsi, rcx

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rcx, QWORD PTR [rcx]
	mov	r8, rdi
	sub	r8, rcx
	mov	r9, -8198552921648689607		; 8e38e38e38e38e39H
	sar	r8, 3
	imul	r8, r9

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdx, r8
	jae	SHORT $LN4@resize
	mov	QWORD PTR [rsp+48], rbx

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rax, QWORD PTR [rdx+rdx*8]
	mov	QWORD PTR [rsp+56], rbp
	lea	rbp, QWORD PTR [rcx+rax*8]

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rbx, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbp, rdi
	je	SHORT $LN10@resize
	npad	5
$LL11@resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx+40]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 72					; 00000048H
	cmp	rbx, rdi
	jne	SHORT $LL11@resize
$LN10@resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1563 :             _Mylast = _Newlast;

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [rsi+8], rbp
	mov	rbp, QWORD PTR [rsp+56]

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN4@resize:

; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN5@resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [rsi+16]
	sub	rax, rcx
	sar	rax, 3
	imul	rax, r9

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN6@resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, rsi

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<AINBFile::OutputEntry,std::allocator<AINBFile::OutputEntry> >::_Resize_reallocate<std::_Value_init_tag>
$LN6@resize:

; 1571 :                 return;
; 1572 :             }
; 1573 : 
; 1574 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1575 :             const pointer _Oldlast = _Mylast;
; 1576 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1577 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1578 :             } else {
; 1579 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, r8
	mov	rcx, rdi
	call	??$_Uninitialized_value_construct_n@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@YAPEAUOutputEntry@AINBFile@@PEAU12@_KAEAV?$allocator@UOutputEntry@AINBFile@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<AINBFile::OutputEntry> >
	mov	QWORD PTR [rsi+8], rax
$LN5@resize:

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?resize@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@QEAAX_K@Z ENDP ; std::vector<AINBFile::OutputEntry,std::allocator<AINBFile::OutputEntry> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??A?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAAEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAAEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z PROC ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::operator[], COMDAT

; 1883 :         auto& _My_data = _Mypair._Myval2;
; 1884 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1885 :         _STL_VERIFY(
; 1886 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1887 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1888 : 
; 1889 :         return _My_data._Myfirst[_Pos];

	lea	rax, QWORD PTR [rdx+rdx*8]
	shl	rax, 4
	add	rax, QWORD PTR [rcx]

; 1890 :     }

	ret	0
??A?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAAEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z ENDP ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?size@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ PROC ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::size, COMDAT

; 1868 :         auto& _My_data = _Mypair._Myval2;
; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	mov	rcx, -8198552921648689607		; 8e38e38e38e38e39H
	sar	rax, 4
	imul	rax, rcx

; 1870 :     }

	ret	0
?size@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Unchecked_end@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAUInputParam@NodeDef@AINBNodeDefMgr@@XZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_end@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAUInputParam@NodeDef@AINBNodeDefMgr@@XZ PROC ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Unchecked_end, COMDAT

; 1855 :         return _Mypair._Myval2._Mylast;

	mov	rax, QWORD PTR [rcx+8]

; 1856 :     }

	ret	0
?_Unchecked_end@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAUInputParam@NodeDef@AINBNodeDefMgr@@XZ ENDP ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Unchecked_begin@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAUInputParam@NodeDef@AINBNodeDefMgr@@XZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_begin@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAUInputParam@NodeDef@AINBNodeDefMgr@@XZ PROC ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Unchecked_begin, COMDAT

; 1847 :         return _Mypair._Myval2._Myfirst;

	mov	rax, QWORD PTR [rcx]

; 1848 :     }

	ret	0
?_Unchecked_begin@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAUInputParam@NodeDef@AINBNodeDefMgr@@XZ ENDP ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?resize@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
?resize@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z PROC ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::resize, COMDAT

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

$LN30:
	mov	QWORD PTR [rsp+24], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rdi, QWORD PTR [rcx+8]

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	mov	r14, rcx

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rcx, QWORD PTR [rcx]
	mov	r8, rdi
	sub	r8, rcx
	mov	r9, -8198552921648689607		; 8e38e38e38e38e39H
	sar	r8, 4
	imul	r8, r9

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdx, r8
	jae	SHORT $LN4@resize
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rsi

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rsi, QWORD PTR [rdx+rdx*8]
	shl	rsi, 4
	add	rsi, rcx

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rbx, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rsi, rdi
	je	SHORT $LN10@resize
	npad	1
$LL11@resize:
	mov	rcx, rbx
	call	??1InputParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ
	add	rbx, 144				; 00000090H
	cmp	rbx, rdi
	jne	SHORT $LL11@resize
$LN10@resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1563 :             _Mylast = _Newlast;

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [r14+8], rsi
	mov	rsi, QWORD PTR [rsp+56]

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN4@resize:

; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN5@resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [r14+16]
	sub	rax, rcx
	sar	rax, 4
	imul	rax, r9

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN6@resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, r14

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Resize_reallocate<std::_Value_init_tag>
$LN6@resize:

; 1571 :                 return;
; 1572 :             }
; 1573 : 
; 1574 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1575 :             const pointer _Oldlast = _Mylast;
; 1576 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1577 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1578 :             } else {
; 1579 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, r8
	mov	rcx, rdi
	call	??$_Uninitialized_value_construct_n@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@_KAEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >
	mov	QWORD PTR [r14+8], rax
$LN5@resize:

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
?resize@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z ENDP ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??A?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAAEAUNodeDef@AINBNodeDefMgr@@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Pos$ = 16
??A?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAAEAUNodeDef@AINBNodeDefMgr@@_K@Z PROC ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::operator[], COMDAT

; 1883 :         auto& _My_data = _Mypair._Myval2;
; 1884 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1885 :         _STL_VERIFY(
; 1886 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1887 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1888 : 
; 1889 :         return _My_data._Myfirst[_Pos];

	imul	rax, rdx, 248				; 000000f8H
	add	rax, QWORD PTR ?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A

; 1890 :     }

	ret	0
??A?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAAEAUNodeDef@AINBNodeDefMgr@@_K@Z ENDP ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?size@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?size@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ PROC ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::size, COMDAT

; 1868 :         auto& _My_data = _Mypair._Myval2;
; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR ?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A+8
	mov	rcx, -1190112520884487201		; ef7bdef7bdef7bdfH
	sub	rax, QWORD PTR ?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A
	sar	rax, 3
	imul	rax, rcx

; 1870 :     }

	ret	0
?size@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Unchecked_end@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAUNodeDef@AINBNodeDefMgr@@XZ
_TEXT	SEGMENT
this$dead$ = 8
?_Unchecked_end@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAUNodeDef@AINBNodeDefMgr@@XZ PROC ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::_Unchecked_end, COMDAT

; 1855 :         return _Mypair._Myval2._Mylast;

	mov	rax, QWORD PTR ?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A+8

; 1856 :     }

	ret	0
?_Unchecked_end@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAUNodeDef@AINBNodeDefMgr@@XZ ENDP ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Unchecked_begin@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAUNodeDef@AINBNodeDefMgr@@XZ
_TEXT	SEGMENT
this$dead$ = 8
?_Unchecked_begin@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAUNodeDef@AINBNodeDefMgr@@XZ PROC ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::_Unchecked_begin, COMDAT

; 1847 :         return _Mypair._Myval2._Myfirst;

	mov	rax, QWORD PTR ?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A

; 1848 :     }

	ret	0
?_Unchecked_begin@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAUNodeDef@AINBNodeDefMgr@@XZ ENDP ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?resize@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Newsize$ = 56
?resize@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z PROC ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::resize, COMDAT

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

$LN30:
	push	rdi
	sub	rsp, 32					; 00000020H

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rdi, QWORD PTR ?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A+8
	mov	r9, -1190112520884487201		; ef7bdef7bdef7bdfH
	mov	r8, QWORD PTR ?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A
	mov	rcx, rdi
	sub	rcx, r8
	sar	rcx, 3
	imul	rcx, r9

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdx, rcx
	jae	SHORT $LN4@resize
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rsi

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	imul	rsi, rdx, 248				; 000000f8H
	add	rsi, r8

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rbx, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rsi, rdi
	je	SHORT $LN10@resize
	npad	3
$LL11@resize:
	mov	rcx, rbx
	call	??1NodeDef@AINBNodeDefMgr@@QEAA@XZ
	add	rbx, 248				; 000000f8H
	cmp	rbx, rdi
	jne	SHORT $LL11@resize
$LN10@resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1563 :             _Mylast = _Newlast;

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR ?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A+8, rsi
	mov	rsi, QWORD PTR [rsp+56]

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN4@resize:

; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN5@resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR ?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A+16
	sub	rax, r8
	sar	rax, 3
	imul	rax, r9

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN6@resize

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	add	rsp, 32					; 00000020H
	pop	rdi

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::_Resize_reallocate<std::_Value_init_tag>
$LN6@resize:

; 1571 :                 return;
; 1572 :             }
; 1573 : 
; 1574 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1575 :             const pointer _Oldlast = _Mylast;
; 1576 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1577 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1578 :             } else {
; 1579 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, rcx
	mov	rcx, rdi
	call	??$_Uninitialized_value_construct_n@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUNodeDef@AINBNodeDefMgr@@PEAU12@_KAEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<AINBNodeDefMgr::NodeDef> >
	mov	QWORD PTR ?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A+8, rax
$LN5@resize:

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?resize@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z ENDP ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??1?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ PROC ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::~vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >, COMDAT

; 766  :     _CONSTEXPR20 ~vector() noexcept {

$LN50:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR [rcx]

; 766  :     _CONSTEXPR20 ~vector() noexcept {

	mov	rdi, rcx

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	test	rbx, rbx
	je	SHORT $LN4@vector
	mov	QWORD PTR [rsp+56], rsi

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rsi, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rsi
	je	SHORT $LN8@vector
$LL9@vector:
	mov	rcx, rbx
	call	??1NodeDef@AINBNodeDefMgr@@QEAA@XZ
	add	rbx, 248				; 000000f8H
	cmp	rbx, rsi
	jne	SHORT $LL9@vector
$LN8@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rdi]
	mov	rdx, -1190112520884487201		; ef7bdef7bdef7bdfH
	mov	rax, QWORD PTR [rdi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rsi, QWORD PTR [rsp+56]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rax, rcx
	sar	rax, 3
	imul	rax, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	imul	rdx, rax, 248				; 000000f8H

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN34@vector

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN31@vector

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN34@vector:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rdi], rax

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rdi+8], rax

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rdi+16], rax
$LN4@vector:

; 772  :     }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN31@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN47@vector:
??1?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ ENDP ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::~vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ?reset@?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?reset@?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAAXXZ PROC ; std::shared_ptr<std::filesystem::_Recursive_dir_enum_impl>::reset, COMDAT

; 1733 :     void reset() noexcept { // release resource and convert to empty shared_ptr object

$LN32:
	push	rbx
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	mov	rbx, QWORD PTR [rcx+8]

; 101  :     _Right   = _STD move(_Tmp);

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	test	rbx, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 1402 :         if (_Rep) {

	je	SHORT $LN24@reset
	mov	QWORD PTR [rsp+48], rdi

; 1177 :         if (_MT_DECR(_Uses) == 0) {

	mov	edi, -1
	mov	eax, edi
	lock xadd DWORD PTR [rbx+8], eax
	cmp	eax, 1
	jne	SHORT $LN29@reset

; 1178 :             _Destroy();

	mov	rax, QWORD PTR [rbx]
	mov	rcx, rbx
	call	QWORD PTR [rax]

; 1184 :         if (_MT_DECR(_Weaks) == 0) {

	lock xadd DWORD PTR [rbx+12], edi
	cmp	edi, 1
	jne	SHORT $LN29@reset

; 1185 :             _Delete_this();

	mov	rax, QWORD PTR [rbx]
	mov	rcx, rbx
	call	QWORD PTR [rax+8]
$LN29@reset:
	mov	rdi, QWORD PTR [rsp+48]
$LN24@reset:

; 1734 :         shared_ptr().swap(*this);
; 1735 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?reset@?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAAXXZ ENDP ; std::shared_ptr<std::filesystem::_Recursive_dir_enum_impl>::reset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??1?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAA@XZ PROC ; std::shared_ptr<std::filesystem::_Recursive_dir_enum_impl>::~shared_ptr<std::filesystem::_Recursive_dir_enum_impl>, COMDAT

; 1686 :     ~shared_ptr() noexcept { // release resource

$LN18:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1402 :         if (_Rep) {

	mov	rbx, QWORD PTR [rcx+8]
	test	rbx, rbx
	je	SHORT $LN10@shared_ptr
	mov	QWORD PTR [rsp+48], rdi

; 1177 :         if (_MT_DECR(_Uses) == 0) {

	mov	edi, -1
	mov	eax, edi
	lock xadd DWORD PTR [rbx+8], eax
	cmp	eax, 1
	jne	SHORT $LN15@shared_ptr

; 1178 :             _Destroy();

	mov	rax, QWORD PTR [rbx]
	mov	rcx, rbx
	call	QWORD PTR [rax]

; 1184 :         if (_MT_DECR(_Weaks) == 0) {

	lock xadd DWORD PTR [rbx+12], edi
	cmp	edi, 1
	jne	SHORT $LN15@shared_ptr

; 1185 :             _Delete_this();

	mov	rax, QWORD PTR [rbx]
	mov	rcx, rbx
	call	QWORD PTR [rax+8]
$LN15@shared_ptr:
	mov	rdi, QWORD PTR [rsp+48]
$LN10@shared_ptr:

; 1687 :         this->_Decref();
; 1688 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAA@XZ ENDP ; std::shared_ptr<std::filesystem::_Recursive_dir_enum_impl>::~shared_ptr<std::filesystem::_Recursive_dir_enum_impl>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??0?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAA@$$QEAV01@@Z PROC ; std::shared_ptr<std::filesystem::_Recursive_dir_enum_impl>::shared_ptr<std::filesystem::_Recursive_dir_enum_impl>, COMDAT

; 1470 :     element_type* _Ptr{nullptr};

	xor	r8d, r8d
	mov	QWORD PTR [rcx], r8

; 1471 :     _Ref_count_base* _Rep{nullptr};

	mov	QWORD PTR [rcx+8], r8

; 1345 :         _Ptr = _Right._Ptr;

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 1346 :         _Rep = _Right._Rep;

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rcx+8], rax

; 1642 :         this->_Move_construct_from(_STD move(_Right));
; 1643 :     }

	mov	rax, rcx

; 1348 :         _Right._Ptr = nullptr;

	mov	QWORD PTR [rdx], r8

; 1349 :         _Right._Rep = nullptr;

	mov	QWORD PTR [rdx+8], r8

; 1642 :         this->_Move_construct_from(_STD move(_Right));
; 1643 :     }

	ret	0
??0?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAA@$$QEAV01@@Z ENDP ; std::shared_ptr<std::filesystem::_Recursive_dir_enum_impl>::shared_ptr<std::filesystem::_Recursive_dir_enum_impl>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??0?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Other$ = 16
??0?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAA@AEBV01@@Z PROC ; std::shared_ptr<std::filesystem::_Recursive_dir_enum_impl>::shared_ptr<std::filesystem::_Recursive_dir_enum_impl>, COMDAT

; 1470 :     element_type* _Ptr{nullptr};

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 1471 :     _Ref_count_base* _Rep{nullptr};

	mov	QWORD PTR [rcx+8], rax

; 1396 :         if (_Rep) {

	mov	rax, QWORD PTR [rdx+8]
	test	rax, rax
	je	SHORT $LN11@shared_ptr

; 1169 :         _MT_INCR(_Uses);

	lock inc DWORD PTR [rax+8]
$LN11@shared_ptr:

; 1357 :         _Ptr = _Other._Ptr;

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 1358 :         _Rep = _Other._Rep;

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rcx+8], rax

; 1632 :         this->_Copy_construct_from(_Other);
; 1633 :     }

	mov	rax, rcx
	ret	0
??0?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAA@AEBV01@@Z ENDP ; std::shared_ptr<std::filesystem::_Recursive_dir_enum_impl>::shared_ptr<std::filesystem::_Recursive_dir_enum_impl>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?back@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEAAAEAU_Find_file_handle@filesystem@2@XZ
_TEXT	SEGMENT
this$ = 8
?back@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEAAAEAU_Find_file_handle@filesystem@2@XZ PROC ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::back, COMDAT

; 1939 :         auto& _My_data = _Mypair._Myval2;
; 1940 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1941 :         _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "back() called on empty vector");
; 1942 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1943 : 
; 1944 :         return _My_data._Mylast[-1];

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, 8

; 1945 :     }

	ret	0
?back@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEAAAEAU_Find_file_handle@filesystem@2@XZ ENDP ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?empty@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?empty@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEBA_NXZ PROC ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::empty, COMDAT

; 1863 :         auto& _My_data = _Mypair._Myval2;
; 1864 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rax, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rcx], rax
	sete	al

; 1865 :     }

	ret	0
?empty@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEBA_NXZ ENDP ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?pop_back@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?pop_back@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEAAXXZ PROC ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::pop_back, COMDAT

; 1702 :     _CONSTEXPR20 void pop_back() noexcept /* strengthened */ {

$LN14:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1703 :         auto& _My_data   = _Mypair._Myval2;
; 1704 :         pointer& _Mylast = _My_data._Mylast;
; 1705 : 
; 1706 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1707 :         _STL_VERIFY(_My_data._Myfirst != _Mylast, "vector empty before pop");
; 1708 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1709 : 
; 1710 :         _Orphan_range(_Mylast - 1, _Mylast);
; 1711 :         _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));

	mov	rcx, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 605  :             __std_fs_directory_iterator_close(_Handle);

	mov	rcx, QWORD PTR [rcx-8]
	call	__std_fs_directory_iterator_close
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1713 :         --_Mylast;

	add	QWORD PTR [rbx+8], -8

; 1714 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?pop_back@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEAAXXZ ENDP ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?push_back@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEAAX$$QEAU_Find_file_handle@filesystem@2@@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
?push_back@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEAAX$$QEAU_Find_file_handle@filesystem@2@@Z PROC ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::push_back, COMDAT

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	r9, QWORD PTR [rcx+8]
	cmp	r9, QWORD PTR [rcx+16]
	je	SHORT $LN4@push_back

; 806  :         ++_Mylast;

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rdx], -1
	mov	QWORD PTR [r9], rax
	add	QWORD PTR [rcx+8], 8

; 877  :         // insert by moving into element at end, provide strong guarantee
; 878  :         _Emplace_one_at_back(_STD move(_Val));
; 879  :     }

	ret	0
$LN4@push_back:

; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	r8, rdx
	mov	rdx, r9
	jmp	??$_Emplace_reallocate@U_Find_file_handle@filesystem@std@@@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAPEAU_Find_file_handle@filesystem@1@QEAU231@$$QEAU231@@Z ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::_Emplace_reallocate<std::filesystem::_Find_file_handle>
?push_back@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEAAX$$QEAU_Find_file_handle@filesystem@2@@Z ENDP ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??1?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEAA@XZ PROC ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::~vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >, COMDAT

; 766  :     _CONSTEXPR20 ~vector() noexcept {

$LN52:
	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	sub	rsp, 32					; 00000020H

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR [rcx]

; 766  :     _CONSTEXPR20 ~vector() noexcept {

	mov	rsi, rcx

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	test	rbx, rbx
	je	SHORT $LN4@vector
	mov	QWORD PTR [rsp+56], rdi

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdi, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN8@vector
$LL9@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 605  :             __std_fs_directory_iterator_close(_Handle);

	mov	rcx, QWORD PTR [rbx]
	call	__std_fs_directory_iterator_close
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 8
	cmp	rbx, rdi
	jne	SHORT $LL9@vector
$LN8@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rsi]
	mov	rdx, QWORD PTR [rsi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdi, QWORD PTR [rsp+56]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN36@vector

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN33@vector

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN36@vector:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rsi], rax

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rsi+8], rax

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rsi+16], rax
$LN4@vector:

; 772  :     }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
$LN33@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN49@vector:
??1?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEAA@XZ ENDP ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::~vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEAA@XZ PROC ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 611  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 612  :     }

	mov	rax, rcx
	ret	0
??0?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEAA@XZ ENDP ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??0?$reverse_iterator@PEB_W@std@@QEAA@PEB_W@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$reverse_iterator@PEB_W@std@@QEAA@PEB_W@Z PROC	; std::reverse_iterator<wchar_t const *>::reverse_iterator<wchar_t const *>, COMDAT

; 1493 :         is_nothrow_move_constructible_v<_BidIt>) // strengthened
; 1494 :         : current(_STD move(_Right)) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0?$reverse_iterator@PEB_W@std@@QEAA@PEB_W@Z ENDP	; std::reverse_iterator<wchar_t const *>::reverse_iterator<wchar_t const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?end@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?end@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@XZ PROC ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::end, COMDAT

; 43   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rdx], rax

; 1805 :         auto& _My_data = _Mypair._Myval2;
; 1806 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

	mov	rax, rdx

; 1807 :     }

	ret	0
?end@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@XZ ENDP ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
__param0$ = 16
__param1$dead$ = 24
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > >, COMDAT

; 43   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?begin@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?begin@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@XZ PROC ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::begin, COMDAT

; 43   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax

; 1795 :         auto& _My_data = _Mypair._Myval2;
; 1796 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

	mov	rax, rdx

; 1797 :     }

	ret	0
?begin@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@XZ ENDP ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??4?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??4?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::operator=, COMDAT

; 1482 :     _CONSTEXPR20 vector& operator=(const vector& _Right) {

$LN7:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	r8, rdx
	mov	rbx, rcx

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN5@operator

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [rdx]
	mov	r8, QWORD PTR [r8+8]
	sub	r8, rdx
	call	??$_Assign_counted_range@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_K@Z ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Assign_counted_range<enum AINBNodeDefMgr::NodeDef::CategoryEnum *>
$LN5@operator:

; 1499 : 
; 1500 :         return *this;
; 1501 :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??4?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?push_back@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX$$QEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
?push_back@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX$$QEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@Z PROC ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::push_back, COMDAT

; 876  :     _CONSTEXPR20 void push_back(_Ty&& _Val) {

	mov	r8, rdx

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rcx+8]
	cmp	rdx, QWORD PTR [rcx+16]
	je	SHORT $LN4@push_back

; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [rdx], al

; 798  :         } else {
; 799  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 800  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 801  :             _ASAN_VECTOR_RELEASE_GUARD;
; 802  :         }
; 803  : 
; 804  :         _Orphan_range(_Mylast, _Mylast);
; 805  :         _Ty& _Result = *_Mylast;
; 806  :         ++_Mylast;

	inc	QWORD PTR [rcx+8]

; 877  :         // insert by moving into element at end, provide strong guarantee
; 878  :         _Emplace_one_at_back(_STD move(_Val));
; 879  :     }

	ret	0
$LN4@push_back:

; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@QEAW4234@$$QEAW4234@@Z ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Emplace_reallocate<enum AINBNodeDefMgr::NodeDef::CategoryEnum>
?push_back@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX$$QEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@Z ENDP ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??1?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ PROC ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::~vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >, COMDAT

; 766  :     _CONSTEXPR20 ~vector() noexcept {

$LN33:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN4@vector

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN22@vector

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN19@vector

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN22@vector:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN4@vector:

; 772  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN19@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN30@vector:
??1?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ ENDP ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::~vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ PROC ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 611  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 612  :     }

	mov	rax, rcx
	ret	0
??0?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ ENDP ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??A?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAAEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAAEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@_K@Z PROC ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::operator[], COMDAT

; 1883 :         auto& _My_data = _Mypair._Myval2;
; 1884 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1885 :         _STL_VERIFY(
; 1886 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1887 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1888 : 
; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rcx]
	lea	rdx, QWORD PTR [rdx+rdx*2]
	lea	rax, QWORD PTR [rax+rdx*8]

; 1890 :     }

	ret	0
??A?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAAEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@_K@Z ENDP ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?resize@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$dead$ = 56
?resize@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAX_K@Z PROC ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::resize, COMDAT

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

$LN81:
	mov	QWORD PTR [rsp+32], rbx
	push	rsi
	sub	rsp, 32					; 00000020H

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rbx, QWORD PTR [rcx+8]

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	mov	rsi, rcx

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rdx, QWORD PTR [rcx]
	mov	r8, -6148914691236517205		; aaaaaaaaaaaaaaabH
	mov	rcx, rbx
	sub	rcx, rdx
	sar	rcx, 3
	imul	rcx, r8

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rcx, 6
	jbe	SHORT $LN4@resize
	mov	QWORD PTR [rsp+56], rbp

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rbp, QWORD PTR [rdx+144]
	mov	QWORD PTR [rsp+64], rdi

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rdi, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbp, rbx
	je	SHORT $LN10@resize
	npad	5
$LL11@resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	mov	rcx, rdi
	call	?_Tidy@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rdi, 24
	cmp	rdi, rbx
	jne	SHORT $LL11@resize
$LN10@resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1563 :             _Mylast = _Newlast;

	mov	rdi, QWORD PTR [rsp+64]
	mov	QWORD PTR [rsi+8], rbp
	mov	rbp, QWORD PTR [rsp+56]

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
$LN4@resize:

; 1567 :         if (_Newsize > _Oldsize) { // append

	jae	SHORT $LN5@resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [rsi+16]
	sub	rax, rdx
	sar	rax, 3
	imul	rax, r8

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rax, 6
	jae	SHORT $LN6@resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, rsi

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rsi

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Resize_reallocate<std::_Value_init_tag>
$LN6@resize:

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	mov	eax, 6
	sub	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2041 :     for (; 0 < _Count; --_Count) {

	je	SHORT $LN24@resize
	xor	ecx, ecx
	npad	1
$LL25@resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rbx], rcx
	mov	QWORD PTR [rbx+8], rcx
	mov	QWORD PTR [rbx+16], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rbx, 24

; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rax, 1
	jne	SHORT $LL25@resize
$LN24@resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	mov	QWORD PTR [rsi+8], rbx
$LN5@resize:

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
?resize@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAX_K@Z ENDP ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??4?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??4?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::operator=, COMDAT

; 1482 :     _CONSTEXPR20 vector& operator=(const vector& _Right) {

$LN7:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	r8, rdx
	mov	rbx, rcx

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN5@operator

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	r8, QWORD PTR [r8+8]
	mov	rax, -6148914691236517205		; aaaaaaaaaaaaaaabH
	mov	rdx, QWORD PTR [rdx]
	sub	r8, rdx
	sar	r8, 3
	imul	r8, rax
	call	??$_Assign_counted_range@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@_K@Z ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Assign_counted_range<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > *>
$LN5@operator:

; 1499 : 
; 1500 :         return *this;
; 1501 :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??4?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??1?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAA@XZ PROC ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::~vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >, COMDAT

; 767  :         _Tidy();

	jmp	?_Tidy@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXXZ ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Tidy
??1?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAA@XZ ENDP ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::~vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAA@XZ PROC ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 611  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 612  :     }

	mov	rax, rcx
	ret	0
??0?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAA@XZ ENDP ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??A?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAAEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAAEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@_K@Z PROC ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::operator[], COMDAT

; 1883 :         auto& _My_data = _Mypair._Myval2;
; 1884 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1885 :         _STL_VERIFY(
; 1886 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1887 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1888 : 
; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rcx]
	lea	rdx, QWORD PTR [rdx+rdx*2]
	lea	rax, QWORD PTR [rax+rdx*8]

; 1890 :     }

	ret	0
??A?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAAEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@_K@Z ENDP ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?resize@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$dead$ = 56
?resize@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAX_K@Z PROC ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::resize, COMDAT

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

$LN81:
	mov	QWORD PTR [rsp+32], rbx
	push	rsi
	sub	rsp, 32					; 00000020H

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rbx, QWORD PTR [rcx+8]

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	mov	rsi, rcx

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rdx, QWORD PTR [rcx]
	mov	r8, -6148914691236517205		; aaaaaaaaaaaaaaabH
	mov	rcx, rbx
	sub	rcx, rdx
	sar	rcx, 3
	imul	rcx, r8

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rcx, 6
	jbe	SHORT $LN4@resize
	mov	QWORD PTR [rsp+56], rbp

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rbp, QWORD PTR [rdx+144]
	mov	QWORD PTR [rsp+64], rdi

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rdi, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbp, rbx
	je	SHORT $LN10@resize
	npad	5
$LL11@resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	mov	rcx, rdi
	call	?_Tidy@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rdi, 24
	cmp	rdi, rbx
	jne	SHORT $LL11@resize
$LN10@resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1563 :             _Mylast = _Newlast;

	mov	rdi, QWORD PTR [rsp+64]
	mov	QWORD PTR [rsi+8], rbp
	mov	rbp, QWORD PTR [rsp+56]

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
$LN4@resize:

; 1567 :         if (_Newsize > _Oldsize) { // append

	jae	SHORT $LN5@resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [rsi+16]
	sub	rax, rdx
	sar	rax, 3
	imul	rax, r8

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rax, 6
	jae	SHORT $LN6@resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, rsi

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rsi

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Resize_reallocate<std::_Value_init_tag>
$LN6@resize:

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	mov	eax, 6
	sub	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2041 :     for (; 0 < _Count; --_Count) {

	je	SHORT $LN24@resize
	xor	ecx, ecx
	npad	1
$LL25@resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rbx], rcx
	mov	QWORD PTR [rbx+8], rcx
	mov	QWORD PTR [rbx+16], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rbx, 24

; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rax, 1
	jne	SHORT $LL25@resize
$LN24@resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	mov	QWORD PTR [rsi+8], rbx
$LN5@resize:

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
?resize@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAX_K@Z ENDP ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??4?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??4?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::operator=, COMDAT

; 1482 :     _CONSTEXPR20 vector& operator=(const vector& _Right) {

$LN7:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	r8, rdx
	mov	rbx, rcx

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN5@operator

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	r8, QWORD PTR [r8+8]
	mov	rax, -6148914691236517205		; aaaaaaaaaaaaaaabH
	mov	rdx, QWORD PTR [rdx]
	sub	r8, rdx
	sar	r8, 3
	imul	r8, rax
	call	??$_Assign_counted_range@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@_K@Z ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Assign_counted_range<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *>
$LN5@operator:

; 1499 : 
; 1500 :         return *this;
; 1501 :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??4?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??1?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAA@XZ PROC ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::~vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >, COMDAT

; 767  :         _Tidy();

	jmp	?_Tidy@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXXZ ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Tidy
??1?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAA@XZ ENDP ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::~vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAA@XZ PROC ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 611  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 612  :     }

	mov	rax, rcx
	ret	0
??0?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAA@XZ ENDP ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@IV?$allocator@I@std@@@std@@QEAA@_KAEBV?$allocator@I@1@@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
_Al$dead$ = 64
??0?$vector@IV?$allocator@I@std@@@std@@QEAA@_KAEBV?$allocator@I@1@@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >, COMDAT

; 619  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN51:
	mov	QWORD PTR [rsp+32], rbx
	push	rsi
	sub	rsp, 32					; 00000020H

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax

; 619  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	rbx, rdx

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx], rax

; 619  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	rsi, rcx

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 2065 :         if (_Count != 0) {

	test	rdx, rdx
	je	SHORT $LN38@vector

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 4611686018427387903		; 3fffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN49@vector
	mov	QWORD PTR [rsp+64], rdi

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	call	?allocate@?$allocator@I@std@@QEAAPEAI_K@Z ; std::allocator<unsigned int>::allocate

; 1990 :         _Myfirst           = _Newvec;
; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rbx, QWORD PTR [rbx*4]
	mov	QWORD PTR [rsi], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	r8, rbx
	xor	edx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdi, rax

; 1990 :         _Myfirst           = _Newvec;
; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [rbx+rax]
	mov	QWORD PTR [rsi+16], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	rcx, rax
	call	memset

; 2036 :             return _First + _Count;

	lea	rcx, QWORD PTR [rbx+rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2069 :                 _My_data._Mylast = _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);

	mov	rdi, QWORD PTR [rsp+64]
	mov	QWORD PTR [rsi+8], rcx
$LN38@vector:

; 620  :         _Construct_n(_Count);
; 621  :     }

	mov	rbx, QWORD PTR [rsp+72]
	mov	rax, rsi
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
$LN49@vector:

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@IV?$allocator@I@std@@@std@@CAXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlength
	int	3
$LN47@vector:
??0?$vector@IV?$allocator@I@std@@@std@@QEAA@_KAEBV?$allocator@I@1@@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size, COMDAT

; 1868 :         auto& _My_data = _Mypair._Myval2;
; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 5

; 1870 :     }

	ret	0
?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAX$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAX$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back, COMDAT

; 876  :     _CONSTEXPR20 void push_back(_Ty&& _Val) {

	mov	r8, rdx

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rcx+8]
	cmp	rdx, QWORD PTR [rcx+16]
	je	SHORT $LN4@push_back
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rdx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rdx+16], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rdx+24], rax

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [rdx], xmm0
	movups	xmm1, XMMWORD PTR [r8+16]
	movups	XMMWORD PTR [rdx+16], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [r8+16], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [r8+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [r8], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 806  :         ++_Mylast;

	add	QWORD PTR [rcx+8], 32			; 00000020H

; 877  :         // insert by moving into element at end, provide strong guarantee
; 878  :         _Emplace_one_at_back(_STD move(_Val));
; 879  :     }

	ret	0
$LN4@push_back:

; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@$$QEAV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAX$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?_Orphan_all@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Orphan_all@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Orphan_all, COMDAT

; 4849 :         _Mypair._Myval2._Orphan_all();
; 4850 :     }

	ret	0
?_Orphan_all@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\wchar.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\wchar.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?resize@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K_W@Z
_TEXT	SEGMENT
this$ = 64
_New_size$ = 72
_Ch$dead$ = 80
?resize@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::resize, COMDAT

; 4137 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _New_size, const _Elem _Ch = _Elem()) {

$LN59:
	push	rdi
	sub	rsp, 48					; 00000030H

; 4138 :         // determine new length, padding with _Ch elements as needed
; 4139 :         const size_type _Old_size = size();

	lea	rdi, QWORD PTR [rcx+16]
	mov	r8, rcx
	mov	rcx, QWORD PTR [rdi]
	mov	r10, rdx

; 4140 :         if (_New_size <= _Old_size) {

	cmp	rdx, rcx
	ja	SHORT $LN2@resize

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [r8+24], 8

; 2227 :         if (_Large_string_engaged()) {

	jb	SHORT $LN8@resize

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r8, QWORD PTR [r8]
$LN8@resize:

; 4815 :         _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _New_size], _Elem());

	xor	r9d, r9d
	mov	QWORD PTR [rdi], r10
	mov	WORD PTR [r8+rdx*2], r9w

; 4144 :         }
; 4145 :     }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN2@resize:

; 3298 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	r9, QWORD PTR [r8+24]

; 4141 :             _Eos(_New_size);
; 4142 :         } else {
; 4143 :             append(_New_size - _Old_size, _Ch);

	sub	rdx, rcx

; 3298 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	rax, r9
	sub	rax, rcx
	cmp	rdx, rax
	ja	SHORT $LN13@resize

; 3299 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 3300 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	QWORD PTR [rdi], r10

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	r9, 8

; 2227 :         if (_Large_string_engaged()) {

	jb	SHORT $LN16@resize

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r8, QWORD PTR [r8]
$LN16@resize:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\wchar.h

; 259  :         for (; 0 < _N; ++_Su, --_N)

	xor	r9d, r9d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3302 :             _Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);

	lea	rdi, QWORD PTR [r8+rcx*2]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\wchar.h

; 259  :         for (; 0 < _N; ++_Su, --_N)

	test	rdx, rdx
	je	SHORT $LN38@resize
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3302 :             _Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);

	movzx	eax, r9w
	mov	rcx, rdx
	rep stosw
$LN38@resize:

; 3303 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	WORD PTR [r8+r10*2], r9w

; 4144 :         }
; 4145 :     }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN13@resize:

; 3307 :         return _Reallocate_grow_by(

	mov	r9, rdx
	mov	rcx, r8
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@_K_W@Z@_K_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@0_W@Z@_K_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<`std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append'::`2'::<lambda_1>,unsigned __int64,wchar_t>

; 4144 :         }
; 4145 :     }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?resize@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size, COMDAT

; 4129 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());
; 4130 :         const size_type _Storage_max = // can always store small string
; 4131 :             (_STD max)(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 4132 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

	mov	rax, 9223372036854775806		; 7ffffffffffffffeH

; 4133 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 4134 :         );
; 4135 :     }

	ret	0
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size, COMDAT

; 4125 :         return _Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR [rcx+16]

; 4126 :     }

	ret	0
?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAPEB_WXZ
_TEXT	SEGMENT
this$ = 8
?data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAPEB_WXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::data, COMDAT

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 8

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN8@data

; 4111 :         return _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR [rcx]

; 4112 :     }

	ret	0
$LN8@data:

; 4111 :         return _Mypair._Myval2._Myptr();

	mov	rax, rcx

; 4112 :     }

	ret	0
?data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAPEB_WXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAPEB_WXZ
_TEXT	SEGMENT
this$ = 8
?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAPEB_WXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str, COMDAT

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 8

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN8@c_str

; 4107 :         return _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR [rcx]

; 4108 :     }

	ret	0
$LN8@c_str:

; 4107 :         return _Mypair._Myval2._Myptr();

	mov	rax, rcx

; 4108 :     }

	ret	0
?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAPEB_WXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z
_TEXT	SEGMENT
this$ = 64
_Ch$dead$ = 72
?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::push_back, COMDAT

; 4045 :     _CONSTEXPR20 void push_back(const _Elem _Ch) { // insert element at end

$LN86:
	push	rbx
	push	rbp
	push	rsi
	sub	rsp, 32					; 00000020H

; 4046 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rsi, QWORD PTR [rcx+16]
	mov	rbx, rcx

; 4047 :         if (_Old_size < _Mypair._Myval2._Myres) {

	mov	rbp, QWORD PTR [rcx+24]
	cmp	rsi, rbp
	jae	SHORT $LN2@push_back

; 4048 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 4049 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rsi+1]
	mov	QWORD PTR [rcx+16], rax

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	rbp, 8

; 2227 :         if (_Large_string_engaged()) {

	jb	SHORT $LN5@push_back

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rbx, QWORD PTR [rcx]
$LN5@push_back:

; 4050 :             _Elem* const _Ptr       = _Mypair._Myval2._Myptr();
; 4051 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	DWORD PTR [rbx+rsi*2], 92		; 0000005cH

; 4061 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());
; 4062 :             },
; 4063 :             _Ch);
; 4064 :     }

	add	rsp, 32					; 00000020H
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN2@push_back:
	mov	QWORD PTR [rsp+72], rdi

; 4766 :         if (max_size() - _Old_size < _Size_increase) {

	mov	rdi, 9223372036854775806		; 7ffffffffffffffeH
	mov	rax, rdi
	sub	rax, rsi
	cmp	rax, 1
	jb	$LN84@push_back
	mov	QWORD PTR [rsp+80], r14
	mov	QWORD PTR [rsp+88], r15

; 4768 :         }
; 4769 : 
; 4770 :         const size_type _New_size     = _Old_size + _Size_increase;

	lea	r15, QWORD PTR [rsi+1]

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rcx, r15
	or	rcx, 7
	cmp	rcx, rdi

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN16@push_back

; 4716 :             return _Max;
; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	rdx, rbp
	mov	rax, rdi
	shr	rdx, 1
	sub	rax, rdx
	cmp	rbp, rax
	ja	SHORT $LN16@push_back

; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	rax, QWORD PTR [rdx+rbp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	mov	rdi, rcx
	cmp	rcx, rax
	cmovb	rdi, rax
$LN16@push_back:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4774 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	rdx, QWORD PTR [rdi+1]
	call	?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z ; std::allocator<wchar_t>::allocate

; 4775 : 
; 4776 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 4777 :         _My_data._Orphan_all();
; 4778 :         _ASAN_STRING_REMOVE(*this);
; 4779 :         _My_data._Mysize      = _New_size;
; 4780 :         _My_data._Myres       = _New_capacity;

	add	rsi, rsi
	mov	QWORD PTR [rbx+16], r15
	mov	r15, QWORD PTR [rsp+88]
	mov	r14, rax
	mov	QWORD PTR [rbx+24], rdi

; 4781 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4782 :         if (_BUF_SIZE <= _Old_capacity) {

	mov	r8, rsi
	mov	rcx, rax
	cmp	rbp, 8
	jb	SHORT $LN11@push_back

; 4783 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	rdi, QWORD PTR [rbx]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rdi
	call	memcpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rbp*2+2]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4060 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);

	mov	DWORD PTR [rsi+r14], 92			; 0000005cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN46@push_back

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rdi-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rdi, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rdi-8]
	cmp	rax, 31
	ja	SHORT $LN43@push_back

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rdi, rcx
$LN46@push_back:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4787 :         } else {

	jmp	SHORT $LN82@push_back
$LN43@push_back:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN11@push_back:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rbx
	call	memcpy

; 4060 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);

	mov	DWORD PTR [rsi+r14], 92			; 0000005cH
$LN82@push_back:
	mov	rdi, QWORD PTR [rsp+72]

; 4789 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR [rbx], r14
	mov	r14, QWORD PTR [rsp+80]

; 4061 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());
; 4062 :             },
; 4063 :             _Ch);
; 4064 :     }

	add	rsp, 32					; 00000020H
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN84@push_back:

; 4767 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN81@push_back:
?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??R<lambda_1>@?1??push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z@QEBA@QEA_WQEB_W_K0@Z
_TEXT	SEGMENT
this$dead$ = 48
_New_ptr$ = 56
_Old_ptr$ = 64
_Old_size$ = 72
_Ch$ = 80
??R<lambda_1>@?1??push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z@QEBA@QEA_WQEB_W_K0@Z PROC ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::push_back'::`2'::<lambda_1>::operator(), COMDAT

; 4058 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem _Ch) {

$LN17:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rax, r8

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	lea	rbx, QWORD PTR [r9+r9]

; 4058 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem _Ch) {

	mov	rdi, rdx

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rbx
	mov	rdx, rax
	mov	rcx, rdi
	call	memcpy

; 4059 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 4060 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);

	movzx	eax, WORD PTR _Ch$[rsp]
	mov	WORD PTR [rbx+rdi], ax

; 4061 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

	xor	eax, eax
	mov	WORD PTR [rbx+rdi+2], ax

; 4062 :             },

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??R<lambda_1>@?1??push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z@QEBA@QEA_WQEB_W_K0@Z ENDP ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::push_back'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??B?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV?$basic_string_view@_WU?$char_traits@_W@std@@@1@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
??B?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV?$basic_string_view@_WU?$char_traits@_W@std@@@1@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator std::basic_string_view<wchar_t,std::char_traits<wchar_t> >, COMDAT

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 8

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rax, rcx

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN4@basic_stri

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rcx]
$LN4@basic_stri:

; 1209 :         : _Mydata(_Cts), _Mysize(_Count) {

	mov	QWORD PTR [rdx], rax
	mov	rax, QWORD PTR [rcx+16]
	mov	QWORD PTR [rdx+8], rax

; 4040 :         // return a string_view around *this's character-type sequence
; 4041 :         return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize};

	mov	rax, rdx

; 4042 :     }

	ret	0
??B?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV?$basic_string_view@_WU?$char_traits@_W@std@@@1@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator std::basic_string_view<wchar_t,std::char_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@_K@Z
_TEXT	SEGMENT
this$ = 48
_Off$ = 56
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@_K@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase, COMDAT

; 3626 :     _CONSTEXPR20 basic_string& erase(const size_type _Off = 0) { // erase elements [_Off, ...)

$LN18:
	sub	rsp, 40					; 00000028H

; 2260 :         if (_Mysize < _Off) {

	cmp	QWORD PTR [rcx+16], rdx
	jb	SHORT $LN16@erase

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 8

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	rax, rcx

; 2227 :         if (_Large_string_engaged()) {

	jb	SHORT $LN10@erase

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rcx]
$LN10@erase:

; 4815 :         _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _New_size], _Elem());

	xor	r8d, r8d
	mov	QWORD PTR [rcx+16], rdx
	mov	WORD PTR [rax+rdx*2], r8w

; 3627 :         _Mypair._Myval2._Check_offset(_Off);
; 3628 :         _Eos(_Off);
; 3629 :         return *this;

	mov	rax, rcx

; 3630 :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN16@erase:

; 2261 :             _Xran();

	call	?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Xran
	int	3
$LN14@erase:
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@_K@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z
_TEXT	SEGMENT
this$ = 64
_Ptr$ = 72
_Count$ = 80
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append, COMDAT

; 3268 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN43:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	rbx, rcx

; 3269 :         // append [_Ptr, _Ptr + _Count)
; 3270 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR [rcx+16]

; 3271 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	r9, QWORD PTR [rbx+24]
	mov	rax, r9
	sub	rax, rcx
	cmp	r8, rax
	ja	SHORT $LN2@append
	mov	QWORD PTR [rsp+64], rsi

; 3272 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 3273 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	rsi, QWORD PTR [rcx+r8]
	mov	QWORD PTR [rsp+72], rdi

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	rdi, rbx

; 3272 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 3273 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	QWORD PTR [rbx+16], rsi

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	r9, 8

; 2227 :         if (_Large_string_engaged()) {

	jb	SHORT $LN5@append

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdi, QWORD PTR [rbx]
$LN5@append:

; 3274 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3275 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

	lea	rcx, QWORD PTR [rdi+rcx*2]
	add	r8, r8

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	call	memmove

; 3276 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	xor	eax, eax
	mov	WORD PTR [rdi+rsi*2], ax

; 3277 :             return *this;

	mov	rax, rbx
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]

; 3281 :             _Count,
; 3282 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 3283 :                 const size_type _Count) {
; 3284 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3285 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 3286 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 3287 :             },
; 3288 :             _Ptr, _Count);
; 3289 :     }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
$LN2@append:

; 3278 :         }
; 3279 : 
; 3280 :         return _Reallocate_grow_by(

	mov	r9, rdx
	mov	QWORD PTR [rsp+32], r8
	mov	rdx, r8
	mov	rcx, rbx
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEB_W0@Z@PEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<`std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append'::`2'::<lambda_1>,wchar_t const *,unsigned __int64>

; 3281 :             _Count,
; 3282 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 3283 :                 const size_type _Count) {
; 3284 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3285 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 3286 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 3287 :             },
; 3288 :             _Ptr, _Count);
; 3289 :     }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??R<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV23@QEB_W_K@Z@QEBA@QEA_W0101@Z
_TEXT	SEGMENT
this$dead$ = 48
_New_ptr$ = 56
_Old_ptr$ = 64
_Old_size$ = 72
_Ptr$ = 80
_Count$ = 88
??R<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV23@QEB_W_K@Z@QEBA@QEA_W0101@Z PROC ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append'::`2'::<lambda_1>::operator(), COMDAT

; 3283 :                 const size_type _Count) {

$LN29:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rax, r8

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	lea	rbx, QWORD PTR [r9+r9]

; 3283 :                 const size_type _Count) {

	mov	rsi, rdx

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rbx
	mov	rdx, rax
	mov	rcx, rsi

; 3283 :                 const size_type _Count) {

	mov	rdi, r9

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy
	mov	rdx, QWORD PTR _Ptr$[rsp]

; 3284 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3285 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

	lea	rcx, QWORD PTR [rbx+rsi]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rbx, QWORD PTR _Count$[rsp]
	lea	r8, QWORD PTR [rbx+rbx]
	call	memcpy

; 3286 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	lea	rax, QWORD PTR [rdi+rbx]
	xor	ecx, ecx

; 3287 :             },

	mov	rbx, QWORD PTR [rsp+48]
	mov	WORD PTR [rsi+rax*2], cx
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??R<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV23@QEB_W_K@Z@QEBA@QEA_W0101@Z ENDP ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
this$ = 80
_Right$ = 88
??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=, COMDAT

; 3155 :     _CONSTEXPR20 basic_string& operator=(const basic_string& _Right) {

$LN111:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H
	mov	rsi, rdx
	mov	rdi, rcx

; 3156 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	$LN35@operator

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 8

; 3157 :             return *this;
; 3158 :         }
; 3159 : 
; 3160 :         auto& _Al             = _Getal();
; 3161 :         const auto& _Right_al = _Right._Getal();
; 3162 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 3163 :             if (_Al != _Right_al) {
; 3164 :                 auto&& _Alproxy       = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 3165 :                 auto&& _Right_alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Right_al);
; 3166 :                 _Container_proxy_ptr<_Alty> _New_proxy(_Right_alproxy, _Leave_proxy_unbound{}); // throws
; 3167 : 
; 3168 :                 if (_Right._Mypair._Myval2._Large_string_engaged()) {
; 3169 :                     const auto _New_size     = _Right._Mypair._Myval2._Mysize;
; 3170 :                     const auto _New_capacity = _Calculate_growth(_New_size, 0, _Right.max_size());
; 3171 :                     auto _Right_al_non_const = _Right_al;
; 3172 :                     const auto _New_ptr      = _Right_al_non_const.allocate(_New_capacity + 1); // throws
; 3173 : 
; 3174 :                     _Start_element_lifetimes(_Unfancy(_New_ptr), _New_size + 1);
; 3175 : 
; 3176 :                     _Traits::copy(_Unfancy(_New_ptr), _Unfancy(_Right._Mypair._Myval2._Bx._Ptr), _New_size + 1);
; 3177 :                     _Tidy_deallocate();
; 3178 :                     _Mypair._Myval2._Bx._Ptr = _New_ptr;
; 3179 :                     _Mypair._Myval2._Mysize  = _New_size;
; 3180 :                     _Mypair._Myval2._Myres   = _New_capacity;
; 3181 :                 } else {
; 3182 :                     _Copy_assign_val_from_small(_Right);
; 3183 :                 }
; 3184 : 
; 3185 :                 _Pocca(_Al, _Right_al);
; 3186 :                 _New_proxy._Bind(_Alproxy, _STD addressof(_Mypair._Myval2));
; 3187 :                 return *this;
; 3188 :             }
; 3189 :         }
; 3190 : 
; 3191 :         _Pocca(_Al, _Right_al);
; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r14, QWORD PTR [rdx+16]

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN5@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rsi, QWORD PTR [rdx]
$LN5@operator:

; 3376 :         if (_Count <= _Mypair._Myval2._Myres) {

	mov	rbp, QWORD PTR [rcx+24]
	cmp	r14, rbp
	ja	SHORT $LN10@operator

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	r15, rdi

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	rbp, 8

; 2227 :         if (_Large_string_engaged()) {

	jb	SHORT $LN13@operator

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r15, QWORD PTR [rcx]
$LN13@operator:

; 3379 :             _Mypair._Myval2._Mysize = _Count;

	mov	QWORD PTR [rcx+16], r14
	lea	rbx, QWORD PTR [r14+r14]

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rbx
	mov	rdx, rsi
	mov	rcx, r15
	call	memmove

; 3381 :             _Traits::assign(_Old_ptr[_Count], _Elem());

	xor	eax, eax
	mov	WORD PTR [rbx+r15], ax

; 3382 :             return *this;

	jmp	$LN35@operator
$LN10@operator:

; 4734 :         if (_New_size > max_size()) {

	mov	rbx, 9223372036854775806		; 7ffffffffffffffeH
	cmp	r14, rbx
	ja	$LN109@operator

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rcx, r14
	or	rcx, 7
	cmp	rcx, rbx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN39@operator

; 4716 :             return _Max;
; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	rdx, rbp
	mov	rax, rbx
	shr	rdx, 1
	sub	rax, rdx
	cmp	rbp, rax
	ja	SHORT $LN39@operator

; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	rax, QWORD PTR [rdx+rbp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	mov	rbx, rcx
	cmp	rcx, rax
	cmovb	rbx, rax
$LN39@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4741 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	rdx, QWORD PTR [rbx+1]
	call	?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z ; std::allocator<wchar_t>::allocate

; 4747 :         _Mypair._Myval2._Myres  = _New_capacity;

	mov	QWORD PTR [rdi+24], rbx

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rsi
	lea	rbx, QWORD PTR [r14+r14]

; 4746 :         _Mypair._Myval2._Mysize = _New_size;

	mov	QWORD PTR [rdi+16], r14

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rbx
	mov	rcx, rax

; 4741 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	r15, rax

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy

; 3389 :                 _Traits::assign(_New_ptr[_Count], _Elem());

	xor	eax, eax
	mov	WORD PTR [rbx+r15], ax

; 4749 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	rbp, 8
	jb	SHORT $LN34@operator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]
	lea	rdx, QWORD PTR [rbp*2+2]

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN69@operator

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN66@operator

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN69@operator:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN34@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3193 :         return *this;

	mov	QWORD PTR [rdi], r15
$LN35@operator:

; 3194 :     }

	mov	rbx, QWORD PTR [rsp+96]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN66@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN109@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4735 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN107@operator:
??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 3119 :         _Tidy_deallocate();

	jmp	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>, COMDAT
	ret	0
??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >, COMDAT
	ret	0
??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@$$QEAV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=, COMDAT

; 2960 :         _Choose_pocma_v<_Alty> != _Pocma_values::_No_propagate_allocators) {

$LN63:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx
	mov	rbx, rcx

; 2961 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN60@operator

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR [rcx+24]
	cmp	rdx, 8

; 4832 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN13@operator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rcx]
	lea	rdx, QWORD PTR [rdx*2+2]

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN25@operator

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN22@operator

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN25@operator:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN13@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 7
	xor	eax, eax
	mov	QWORD PTR [rbx+16], rax

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	WORD PTR [rbx], ax

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdi]
	movups	XMMWORD PTR [rbx], xmm0
	movups	xmm1, XMMWORD PTR [rdi+16]
	movups	XMMWORD PTR [rbx+16], xmm1

; 2962 :             return *this;
; 2963 :         }
; 2964 : 
; 2965 :         auto& _Al                 = _Getal();
; 2966 :         auto& _Right_al           = _Right._Getal();
; 2967 :         constexpr auto _Pocma_val = _Choose_pocma_v<_Alty>;
; 2968 :         if constexpr (_Pocma_val == _Pocma_values::_Propagate_allocators) {
; 2969 :             if (_Al != _Right_al) {
; 2970 :                 // intentionally slams into noexcept on OOM, TRANSITION, VSO-466800
; 2971 :                 _Mypair._Myval2._Orphan_all();
; 2972 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 2973 :             }
; 2974 :         } else if constexpr (_Pocma_val == _Pocma_values::_No_propagate_allocators) {
; 2975 :             if (_Al != _Right_al) {
; 2976 :                 assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 2977 :                 return *this;
; 2978 :             }
; 2979 :         }
; 2980 : 
; 2981 :         _Tidy_deallocate();
; 2982 :         _Pocma(_Al, _Right_al);
; 2983 :         _Take_contents(_Right);
; 2984 :         return *this;

	mov	QWORD PTR [rdi+16], rax
	mov	QWORD PTR [rdi+24], 7
	mov	WORD PTR [rdi], ax
$LN60@operator:

; 2985 :     }

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN22@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN59@operator:
??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@$$QEAV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], rax

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1

; 2760 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2761 :         _Take_contents(_Right);
; 2762 :     }

	mov	QWORD PTR [rdx+16], rax
	mov	QWORD PTR [rdx+24], 7
	mov	WORD PTR [rdx], ax
	mov	rax, rcx
	ret	0
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 64
_Right$ = 72
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 2491 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

$LN66:
	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], rax

; 2491 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

	mov	r14, rdx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], rax

; 2491 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

	mov	rbx, rcx

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 8

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rsi, QWORD PTR [rdx+16]

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN12@basic_stri

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r14, QWORD PTR [rdx]
$LN12@basic_stri:

; 2620 :         if (_Count > max_size()) {

	mov	rdi, 9223372036854775806		; 7ffffffffffffffeH
	cmp	rsi, rdi
	ja	SHORT $LN64@basic_stri

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR [rcx+24], 7
	cmp	rsi, 8
	jae	SHORT $LN18@basic_stri

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR [rcx+16], rsi

; 2493 :     }

	mov	rax, rbx

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR [rcx], xmm0

; 2493 :     }

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN18@basic_stri:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rax, rsi
	or	rax, 7
	cmp	rax, rdi

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN28@basic_stri
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	mov	ecx, 10
	mov	rdi, rax
	cmp	rax, rcx
	cmovb	rdi, rcx
$LN28@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	rdx, QWORD PTR [rdi+1]
	call	?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z ; std::allocator<wchar_t>::allocate

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	lea	r8, QWORD PTR [rsi*2+2]

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR [rbx], rax

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14

; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR [rbx+16], rsi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rcx, rax

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR [rbx+24], rdi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy

; 2493 :     }

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN64@basic_stri:

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN62@basic_stri:
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 4821 :         _My_data._Mysize = 0;

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 7

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	WORD PTR [rcx], ax

; 2481 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2482 :         _Tidy_init();
; 2483 :     }

	mov	rax, rcx
	ret	0
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$allocator@_W@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@_W@std@@QEAA@XZ PROC			; std::allocator<wchar_t>::allocator<wchar_t>, COMDAT

; 958  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@_W@std@@QEAA@XZ ENDP			; std::allocator<wchar_t>::allocator<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcap$ = 56
?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve, COMDAT

; 4176 :     constexpr void reserve(_CRT_GUARDOVERFLOW const size_type _Newcap) {

$LN6:
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx

; 4177 :         // determine new minimum length of allocated storage
; 4178 :         if (_Mypair._Myval2._Myres >= _Newcap) { // requested capacity is not larger than current capacity, ignore

	cmp	QWORD PTR [rcx+24], rdx
	jae	SHORT $LN1@reserve
	mov	QWORD PTR [rsp+48], rbx

; 4179 :             return; // nothing to do
; 4180 :         }
; 4181 : 
; 4182 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rbx, QWORD PTR [rcx+16]

; 4183 :         _Reallocate_grow_by(

	sub	rdx, rbx
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??reserve@01@QEAAX0@Z@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve'::`2'::<lambda_1> >

; 4184 :             _Newcap - _Old_size, [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size) {
; 4185 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);
; 4186 :             });
; 4187 : 
; 4188 :         _Mypair._Myval2._Mysize = _Old_size;

	mov	QWORD PTR [rdi+16], rbx
	mov	rbx, QWORD PTR [rsp+48]
$LN1@reserve:

; 4189 :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??R<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@QEBA@QEADQEBD0@Z
_TEXT	SEGMENT
this$dead$ = 8
_New_ptr$ = 16
_Old_ptr$ = 24
_Old_size$ = 32
??R<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@QEBA@QEADQEBD0@Z PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve'::`2'::<lambda_1>::operator(), COMDAT

; 4184 :             _Newcap - _Old_size, [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size) {

	mov	rax, r8
	mov	rcx, rdx

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rax

; 4185 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);

	lea	r8, QWORD PTR [r9+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	jmp	memcpy
??R<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@QEBA@QEADQEBD0@Z ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2529 :         : _Mypair(_Zero_then_variadic_args_t{}) {

$LN13:
	push	rbx
	sub	rsp, 32					; 00000020H

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], rax

; 2529 :         : _Mypair(_Zero_then_variadic_args_t{}) {

	mov	rbx, rcx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], rax

; 2530 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Count);

	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>

; 2531 :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?empty@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?empty@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QEBA_NXZ PROC ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::empty, COMDAT

; 1296 :         return _Mysize == 0;

	cmp	QWORD PTR [rcx+8], 0
	sete	al

; 1297 :     }

	ret	0
?empty@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QEBA_NXZ ENDP ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?size@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QEBA_KXZ PROC ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::size, COMDAT

; 1288 :         return _Mysize;

	mov	rax, QWORD PTR [rcx+8]

; 1289 :     }

	ret	0
?size@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QEBA_KXZ ENDP ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??0?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QEAA@QEB_W@Z
_TEXT	SEGMENT
this$ = 8
_Ntcts$ = 16
??0?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QEAA@QEB_W@Z PROC ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::basic_string_view<wchar_t,std::char_traits<wchar_t> >, COMDAT

; 1201 :         : _Mydata(_Ntcts), _Mysize(_Traits::length(_Ntcts)) {}

	mov	QWORD PTR [rcx], rdx

; 261  :             return __builtin_wcslen(_First);

	mov	rax, -1
	npad	6
$LL5@basic_stri:
	inc	rax
	cmp	WORD PTR [rdx+rax*2], 0
	jne	SHORT $LL5@basic_stri

; 1201 :         : _Mydata(_Ntcts), _Mysize(_Traits::length(_Ntcts)) {}

	mov	QWORD PTR [rcx+8], rax
	mov	rax, rcx
	ret	0
??0?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QEAA@QEB_W@Z ENDP ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::basic_string_view<wchar_t,std::char_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?empty@?$basic_string_view@DU?$char_traits@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?empty@?$basic_string_view@DU?$char_traits@D@std@@@std@@QEBA_NXZ PROC ; std::basic_string_view<char,std::char_traits<char> >::empty, COMDAT

; 1296 :         return _Mysize == 0;

	cmp	QWORD PTR [rcx+8], 0
	sete	al

; 1297 :     }

	ret	0
?empty@?$basic_string_view@DU?$char_traits@D@std@@@std@@QEBA_NXZ ENDP ; std::basic_string_view<char,std::char_traits<char> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?size@?$basic_string_view@DU?$char_traits@D@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$basic_string_view@DU?$char_traits@D@std@@@std@@QEBA_KXZ PROC ; std::basic_string_view<char,std::char_traits<char> >::size, COMDAT

; 1288 :         return _Mysize;

	mov	rax, QWORD PTR [rcx+8]

; 1289 :     }

	ret	0
?size@?$basic_string_view@DU?$char_traits@D@std@@@std@@QEBA_KXZ ENDP ; std::basic_string_view<char,std::char_traits<char> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEBAXAEBV12@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Right$dead$ = 16
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEBAXAEBV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > >::_Compat, COMDAT

; 195  :         // test for compatible iterator pair
; 196  : #if _ITERATOR_DEBUG_LEVEL == 0
; 197  :         (void) _Right;
; 198  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 / _ITERATOR_DEBUG_LEVEL != 0 vvv
; 199  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "vector iterators incompatible");
; 200  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 201  :     }

	ret	0
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEBAXAEBV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
_Parg$ = 16
_Pvector$dead$ = 24
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > >, COMDAT

; 43   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	QWORD PTR [rcx], rdx

; 44   :         this->_Adopt(_Pvector);
; 45   :     }

	mov	rax, rcx
	ret	0
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Tidy@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ PROC ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::_Tidy, COMDAT

; 2035 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

$LN47:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 2036 :         auto& _Al         = _Getal();
; 2037 :         auto& _My_data    = _Mypair._Myval2;
; 2038 :         pointer& _Myfirst = _My_data._Myfirst;
; 2039 :         pointer& _Mylast  = _My_data._Mylast;
; 2040 :         pointer& _Myend   = _My_data._Myend;
; 2041 : 
; 2042 :         _My_data._Orphan_all();
; 2043 : 
; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR [rcx]
	mov	rdi, rcx
	test	rbx, rbx
	je	SHORT $LN2@Tidy
	mov	QWORD PTR [rsp+56], rsi

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rsi, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rsi
	je	SHORT $LN6@Tidy
$LL7@Tidy:
	mov	rcx, rbx
	call	??1NodeDef@AINBNodeDefMgr@@QEAA@XZ
	add	rbx, 248				; 000000f8H
	cmp	rbx, rsi
	jne	SHORT $LL7@Tidy
$LN6@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rdi]
	mov	rdx, -1190112520884487201		; ef7bdef7bdef7bdfH
	mov	rax, QWORD PTR [rdi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rsi, QWORD PTR [rsp+56]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rax, rcx
	sar	rax, 3
	imul	rax, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	imul	rdx, rax, 248				; 000000f8H

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN32@Tidy

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN29@Tidy

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN32@Tidy:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rdi], rax

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rdi+8], rax

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rdi+16], rax
$LN2@Tidy:

; 2053 :     }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN29@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN44@Tidy:
?_Tidy@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ ENDP ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ?swap@?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAAXAEAV12@@Z
_TEXT	SEGMENT
this$ = 8
_Other$ = 16
?swap@?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAAXAEAV12@@Z PROC ; std::shared_ptr<std::filesystem::_Recursive_dir_enum_impl>::swap, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	mov	rax, QWORD PTR [rdx]
	mov	r8, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR [rdx+8]

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [rdx], r8

; 99   :     _Ty _Tmp = _STD move(_Left);

	mov	r8, QWORD PTR [rcx+8]

; 100  :     _Left    = _STD move(_Right);

	mov	QWORD PTR [rcx+8], rax

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [rdx+8], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 1731 :     }

	ret	0
?swap@?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAAXAEAV12@@Z ENDP ; std::shared_ptr<std::filesystem::_Recursive_dir_enum_impl>::swap
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ?_Decref@?$_Ptr_base@U_Recursive_dir_enum_impl@filesystem@std@@@std@@IEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Decref@?$_Ptr_base@U_Recursive_dir_enum_impl@filesystem@std@@@std@@IEAAXXZ PROC ; std::_Ptr_base<std::filesystem::_Recursive_dir_enum_impl>::_Decref, COMDAT

; 1401 :     void _Decref() noexcept { // decrement reference count

$LN16:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1402 :         if (_Rep) {

	mov	rbx, QWORD PTR [rcx+8]
	test	rbx, rbx
	je	SHORT $LN8@Decref
	mov	QWORD PTR [rsp+48], rdi

; 1177 :         if (_MT_DECR(_Uses) == 0) {

	mov	edi, -1
	mov	eax, edi
	lock xadd DWORD PTR [rbx+8], eax
	cmp	eax, 1
	jne	SHORT $LN13@Decref

; 1178 :             _Destroy();

	mov	rax, QWORD PTR [rbx]
	mov	rcx, rbx
	call	QWORD PTR [rax]

; 1184 :         if (_MT_DECR(_Weaks) == 0) {

	lock xadd DWORD PTR [rbx+12], edi
	cmp	edi, 1
	jne	SHORT $LN13@Decref

; 1185 :             _Delete_this();

	mov	rax, QWORD PTR [rbx]
	mov	rcx, rbx
	call	QWORD PTR [rax+8]
$LN13@Decref:
	mov	rdi, QWORD PTR [rsp+48]
$LN8@Decref:

; 1403 :             _Rep->_Decref();
; 1404 :         }
; 1405 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Decref@?$_Ptr_base@U_Recursive_dir_enum_impl@filesystem@std@@@std@@IEAAXXZ ENDP ; std::_Ptr_base<std::filesystem::_Recursive_dir_enum_impl>::_Decref
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ?get@?$_Ptr_base@U_Recursive_dir_enum_impl@filesystem@std@@@std@@IEBAPEAU_Recursive_dir_enum_impl@filesystem@2@XZ
_TEXT	SEGMENT
this$ = 8
?get@?$_Ptr_base@U_Recursive_dir_enum_impl@filesystem@std@@@std@@IEBAPEAU_Recursive_dir_enum_impl@filesystem@2@XZ PROC ; std::_Ptr_base<std::filesystem::_Recursive_dir_enum_impl>::get, COMDAT

; 1335 :         return _Ptr;

	mov	rax, QWORD PTR [rcx]

; 1336 :     }

	ret	0
?get@?$_Ptr_base@U_Recursive_dir_enum_impl@filesystem@std@@@std@@IEBAPEAU_Recursive_dir_enum_impl@filesystem@2@XZ ENDP ; std::_Ptr_base<std::filesystem::_Recursive_dir_enum_impl>::get
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Getal@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAAEAV?$allocator@U_Find_file_handle@filesystem@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAAEAV?$allocator@U_Find_file_handle@filesystem@std@@@2@XZ PROC ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::_Getal, COMDAT

; 2181 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2182 :     }

	ret	0
?_Getal@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAAEAV?$allocator@U_Find_file_handle@filesystem@std@@@2@XZ ENDP ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Orphan_range@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEBAXPEAU_Find_file_handle@filesystem@2@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEBAXPEAU_Find_file_handle@filesystem@2@0@Z PROC ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::_Orphan_range, COMDAT

; 2177 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

	ret	0
?_Orphan_range@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEBAXPEAU_Find_file_handle@filesystem@2@0@Z ENDP ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Tidy@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAXXZ PROC ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::_Tidy, COMDAT

; 2035 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

$LN49:
	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	sub	rsp, 32					; 00000020H

; 2036 :         auto& _Al         = _Getal();
; 2037 :         auto& _My_data    = _Mypair._Myval2;
; 2038 :         pointer& _Myfirst = _My_data._Myfirst;
; 2039 :         pointer& _Mylast  = _My_data._Mylast;
; 2040 :         pointer& _Myend   = _My_data._Myend;
; 2041 : 
; 2042 :         _My_data._Orphan_all();
; 2043 : 
; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR [rcx]
	mov	rsi, rcx
	test	rbx, rbx
	je	SHORT $LN2@Tidy
	mov	QWORD PTR [rsp+56], rdi

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdi, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN6@Tidy
$LL7@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 605  :             __std_fs_directory_iterator_close(_Handle);

	mov	rcx, QWORD PTR [rbx]
	call	__std_fs_directory_iterator_close
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 8
	cmp	rbx, rdi
	jne	SHORT $LL7@Tidy
$LN6@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rsi]
	mov	rdx, QWORD PTR [rsi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdi, QWORD PTR [rsp+56]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN34@Tidy

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN31@Tidy

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN34@Tidy:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rsi], rax

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rsi+8], rax

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rsi+16], rax
$LN2@Tidy:

; 2053 :     }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
$LN31@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN46@Tidy:
?_Tidy@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAXXZ ENDP ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Getal@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEBAAEBV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEBAAEBV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@2@XZ PROC ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Getal, COMDAT

; 2185 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2186 :     }

	ret	0
?_Getal@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEBAAEBV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@2@XZ ENDP ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Getal@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAAEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAAEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@2@XZ PROC ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Getal, COMDAT

; 2181 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2182 :     }

	ret	0
?_Getal@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAAEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@2@XZ ENDP ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Tidy@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ PROC ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Tidy, COMDAT

; 2035 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

$LN30:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 2036 :         auto& _Al         = _Getal();
; 2037 :         auto& _My_data    = _Mypair._Myval2;
; 2038 :         pointer& _Myfirst = _My_data._Myfirst;
; 2039 :         pointer& _Mylast  = _My_data._Mylast;
; 2040 :         pointer& _Myend   = _My_data._Myend;
; 2041 : 
; 2042 :         _My_data._Orphan_all();
; 2043 : 
; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN2@Tidy

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN20@Tidy

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN17@Tidy

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN20@Tidy:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN2@Tidy:

; 2053 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN17@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN27@Tidy:
?_Tidy@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ ENDP ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Getal@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@XZ PROC ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Getal, COMDAT

; 2185 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2186 :     }

	ret	0
?_Getal@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@XZ ENDP ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Getal@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@XZ PROC ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Getal, COMDAT

; 2181 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2182 :     }

	ret	0
?_Getal@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@XZ ENDP ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Tidy@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXXZ PROC ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Tidy, COMDAT

; 2035 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

$LN49:
	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	sub	rsp, 32					; 00000020H

; 2036 :         auto& _Al         = _Getal();
; 2037 :         auto& _My_data    = _Mypair._Myval2;
; 2038 :         pointer& _Myfirst = _My_data._Myfirst;
; 2039 :         pointer& _Mylast  = _My_data._Mylast;
; 2040 :         pointer& _Myend   = _My_data._Myend;
; 2041 : 
; 2042 :         _My_data._Orphan_all();
; 2043 : 
; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR [rcx]
	mov	rsi, rcx
	test	rbx, rbx
	je	SHORT $LN2@Tidy
	mov	QWORD PTR [rsp+56], rdi

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdi, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN6@Tidy
$LL7@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	mov	rcx, rbx
	call	?_Tidy@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 24
	cmp	rbx, rdi
	jne	SHORT $LL7@Tidy
$LN6@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rsi]
	mov	rdx, -6148914691236517205		; aaaaaaaaaaaaaaabH
	mov	rax, QWORD PTR [rsi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdi, QWORD PTR [rsp+56]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rax, rcx
	sar	rax, 3
	imul	rax, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*2]
	shl	rdx, 3

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN34@Tidy

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN31@Tidy

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN34@Tidy:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rsi], rax

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rsi+8], rax

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rsi+16], rax
$LN2@Tidy:

; 2053 :     }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
$LN31@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN46@Tidy:
?_Tidy@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXXZ ENDP ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Getal@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@XZ PROC ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Getal, COMDAT

; 2185 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2186 :     }

	ret	0
?_Getal@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@XZ ENDP ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Getal@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@XZ PROC ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Getal, COMDAT

; 2181 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2182 :     }

	ret	0
?_Getal@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@XZ ENDP ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Tidy@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXXZ PROC ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Tidy, COMDAT

; 2035 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

$LN49:
	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	sub	rsp, 32					; 00000020H

; 2036 :         auto& _Al         = _Getal();
; 2037 :         auto& _My_data    = _Mypair._Myval2;
; 2038 :         pointer& _Myfirst = _My_data._Myfirst;
; 2039 :         pointer& _Mylast  = _My_data._Mylast;
; 2040 :         pointer& _Myend   = _My_data._Myend;
; 2041 : 
; 2042 :         _My_data._Orphan_all();
; 2043 : 
; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR [rcx]
	mov	rsi, rcx
	test	rbx, rbx
	je	SHORT $LN2@Tidy
	mov	QWORD PTR [rsp+56], rdi

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdi, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN6@Tidy
$LL7@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	mov	rcx, rbx
	call	?_Tidy@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 24
	cmp	rbx, rdi
	jne	SHORT $LL7@Tidy
$LN6@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rsi]
	mov	rdx, -6148914691236517205		; aaaaaaaaaaaaaaabH
	mov	rax, QWORD PTR [rsi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdi, QWORD PTR [rsp+56]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rax, rcx
	sar	rax, 3
	imul	rax, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*2]
	shl	rdx, 3

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN34@Tidy

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN31@Tidy

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN34@Tidy:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rsi], rax

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rsi+8], rax

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rsi+16], rax
$LN2@Tidy:

; 2053 :     }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
$LN31@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN46@Tidy:
?_Tidy@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXXZ ENDP ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBAAEBV?$allocator@_W@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBAAEBV?$allocator@_W@2@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal, COMDAT

; 4862 :         return _Mypair._Get_first();

	mov	rax, rcx

; 4863 :     }

	ret	0
?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBAAEBV?$allocator@_W@2@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$allocator@_W@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$allocator@_W@2@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal, COMDAT

; 4858 :         return _Mypair._Get_first();

	mov	rax, rcx

; 4859 :     }

	ret	0
?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$allocator@_W@2@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate, COMDAT

; 4829 :     _CONSTEXPR20 void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

$LN32:
	push	rbx
	sub	rsp, 32					; 00000020H

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR [rcx+24]

; 4829 :     _CONSTEXPR20 void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

	mov	rbx, rcx

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	rdx, 8

; 4830 :         auto& _My_data = _Mypair._Myval2;
; 4831 :         _My_data._Orphan_all();
; 4832 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN10@Tidy_deall
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rcx]
	lea	rdx, QWORD PTR [rdx*2+2]

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN22@Tidy_deall

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN19@Tidy_deall

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN22@Tidy_deall:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN10@Tidy_deall:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	xor	eax, eax

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 7
	mov	QWORD PTR [rbx+16], rax

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	WORD PTR [rbx], ax

; 4845 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN19@Tidy_deall:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN29@Tidy_deall:
?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init, COMDAT

; 4819 :         // initialize basic_string data members
; 4820 :         auto& _My_data   = _Mypair._Myval2;
; 4821 :         _My_data._Mysize = 0;

	xor	eax, eax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 7
	mov	QWORD PTR [rcx+16], rax

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	WORD PTR [rcx], ax

; 4827 :     }

	ret	0
?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
_New_size$ = 16
?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAX_K@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos, COMDAT

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 8

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	rax, rcx

; 2227 :         if (_Large_string_engaged()) {

	jb	SHORT $LN4@Eos

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rcx]
$LN4@Eos:

; 4814 :         _ASAN_STRING_MODIFY(*this, _Mypair._Myval2._Mysize, _New_size);
; 4815 :         _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _New_size], _Elem());

	mov	QWORD PTR [rcx+16], rdx
	xor	ecx, ecx
	mov	WORD PTR [rax+rdx*2], cx

; 4816 :     }

	ret	0
?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAX_K@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z
_TEXT	SEGMENT
this$ = 80
_Ptr$ = 88
_Count$ = 96
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT

; 3374 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN100:
	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 3375 :         // assign [_Ptr, _Ptr + _Count)
; 3376 :         if (_Count <= _Mypair._Myval2._Myres) {

	mov	rsi, QWORD PTR [rcx+24]
	mov	r14, r8
	mov	r15, rdx
	mov	rdi, rcx
	cmp	r8, rsi
	ja	SHORT $LN2@assign

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	rbp, rcx

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	rsi, 8

; 2227 :         if (_Large_string_engaged()) {

	jb	SHORT $LN5@assign

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rbp, QWORD PTR [rcx]
$LN5@assign:

; 3377 :             _ASAN_STRING_MODIFY(*this, _Mypair._Myval2._Mysize, _Count);
; 3378 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3379 :             _Mypair._Myval2._Mysize = _Count;

	lea	rbx, QWORD PTR [r8+r8]
	mov	QWORD PTR [rcx+16], r14

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rbx
	mov	rcx, rbp
	call	memmove

; 3380 :             _Traits::move(_Old_ptr, _Ptr, _Count);
; 3381 :             _Traits::assign(_Old_ptr[_Count], _Elem());

	xor	eax, eax
	mov	WORD PTR [rbx+rbp], ax

; 3382 :             return *this;

	jmp	$LN96@assign
$LN2@assign:

; 4734 :         if (_New_size > max_size()) {

	mov	rbx, 9223372036854775806		; 7ffffffffffffffeH
	cmp	r14, rbx
	ja	$LN98@assign

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rcx, r14
	or	rcx, 7
	cmp	rcx, rbx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN31@assign

; 4716 :             return _Max;
; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	rdx, rsi
	mov	rax, rbx
	shr	rdx, 1
	sub	rax, rdx
	cmp	rsi, rax
	ja	SHORT $LN31@assign

; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	rax, QWORD PTR [rdx+rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	mov	rbx, rcx
	cmp	rcx, rax
	cmovb	rbx, rax
$LN31@assign:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4741 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	rdx, QWORD PTR [rbx+1]
	call	?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z ; std::allocator<wchar_t>::allocate

; 4747 :         _Mypair._Myval2._Myres  = _New_capacity;

	mov	QWORD PTR [rdi+24], rbx

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r15
	lea	rbx, QWORD PTR [r14+r14]

; 4746 :         _Mypair._Myval2._Mysize = _New_size;

	mov	QWORD PTR [rdi+16], r14

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rbx
	mov	rcx, rax

; 4741 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rbp, rax

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy

; 3389 :                 _Traits::assign(_New_ptr[_Count], _Elem());

	xor	eax, eax
	mov	WORD PTR [rbx+rbp], ax

; 4749 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	rsi, 8
	jb	SHORT $LN26@assign
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]
	lea	rdx, QWORD PTR [rsi*2+2]

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN61@assign

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN58@assign

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN61@assign:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN26@assign:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3385 :         return _Reallocate_for(

	mov	QWORD PTR [rdi], rbp
$LN96@assign:

; 3390 :             },
; 3391 :             _Ptr);
; 3392 :     }

	mov	rbx, QWORD PTR [rsp+104]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN58@assign:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN98@assign:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4735 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN95@assign:
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??R<lambda_1>@?1??assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV23@QEB_W_K@Z@QEBA@QEA_W10@Z
_TEXT	SEGMENT
this$dead$ = 48
_New_ptr$ = 56
_Count$ = 64
_Ptr$ = 72
??R<lambda_1>@?1??assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV23@QEB_W_K@Z@QEBA@QEA_W10@Z PROC ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign'::`2'::<lambda_1>::operator(), COMDAT

; 3387 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {

$LN17:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	lea	rbx, QWORD PTR [r8+r8]
	mov	r8, rbx
	mov	rcx, rdi
	mov	rdx, r9
	call	memcpy

; 3388 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 3389 :                 _Traits::assign(_New_ptr[_Count], _Elem());

	xor	eax, eax
	mov	WORD PTR [rbx+rdi], ax

; 3390 :             },

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??R<lambda_1>@?1??assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV23@QEB_W_K@Z@QEBA@QEA_W10@Z ENDP ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\wchar.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\wchar.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@_K_W@Z
_TEXT	SEGMENT
this$ = 64
_Count$ = 72
_Ch$dead$ = 80
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@_K_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append, COMDAT

; 3295 :     _CONSTEXPR20 basic_string& append(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) {

$LN46:
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	r8, rcx

; 3296 :         // append _Count * _Ch
; 3297 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR [rcx+16]

; 3298 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	rdi, QWORD PTR [r8+24]
	mov	rax, rdi
	sub	rax, rcx
	cmp	rdx, rax
	ja	SHORT $LN2@append

; 3299 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 3300 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	r10, QWORD PTR [rdx+rcx]

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	r9, r8

; 3299 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 3300 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	QWORD PTR [r8+16], r10

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	rdi, 8

; 2227 :         if (_Large_string_engaged()) {

	jb	SHORT $LN5@append

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r9, QWORD PTR [r8]
$LN5@append:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\wchar.h

; 259  :         for (; 0 < _N; ++_Su, --_N)

	xor	r11d, r11d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3302 :             _Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);

	lea	rdi, QWORD PTR [r9+rcx*2]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\wchar.h

; 259  :         for (; 0 < _N; ++_Su, --_N)

	test	rdx, rdx
	je	SHORT $LN27@append
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3302 :             _Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);

	movzx	eax, r11w
	mov	rcx, rdx
	rep stosw
$LN27@append:

; 3303 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	WORD PTR [r9+r10*2], r11w

; 3304 :             return *this;

	mov	rax, r8

; 3308 :             _Count,
; 3309 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Count,
; 3310 :                 const _Elem _Ch) {
; 3311 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3312 :                 _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
; 3313 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 3314 :             },
; 3315 :             _Count, _Ch);
; 3316 :     }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN2@append:

; 3305 :         }
; 3306 : 
; 3307 :         return _Reallocate_grow_by(

	mov	r9, rdx
	mov	rcx, r8
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@_K_W@Z@_K_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@0_W@Z@_K_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<`std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append'::`2'::<lambda_1>,unsigned __int64,wchar_t>

; 3308 :             _Count,
; 3309 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Count,
; 3310 :                 const _Elem _Ch) {
; 3311 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3312 :                 _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
; 3313 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 3314 :             },
; 3315 :             _Count, _Ch);
; 3316 :     }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@_K_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\wchar.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\wchar.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??R<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV23@_K_W@Z@QEBA@QEA_WQEB_W001@Z
_TEXT	SEGMENT
this$dead$ = 64
_New_ptr$ = 72
_Old_ptr$ = 80
_Old_size$ = 88
_Count$ = 96
_Ch$dead$ = 104
??R<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV23@_K_W@Z@QEBA@QEA_WQEB_W001@Z PROC ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append'::`2'::<lambda_1>::operator(), COMDAT

; 3310 :                 const _Elem _Ch) {

$LN50:
	mov	QWORD PTR [rsp+8], rbx
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H
	mov	rbx, QWORD PTR _Count$[rsp]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	lea	rdi, QWORD PTR [r9+r9]

; 3310 :                 const _Elem _Ch) {

	mov	rax, r8
	mov	rsi, rdx

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rdi
	mov	rdx, rax
	mov	rcx, rsi

; 3310 :                 const _Elem _Ch) {

	mov	r14, r9

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\wchar.h

; 259  :         for (; 0 < _N; ++_Su, --_N)

	xor	edx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3312 :                 _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);

	add	rdi, rsi
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\wchar.h

; 259  :         for (; 0 < _N; ++_Su, --_N)

	test	rbx, rbx
	je	SHORT $LN27@operator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3310 :                 const _Elem _Ch) {

	movzx	eax, dx
	mov	rcx, rbx
	rep stosw
$LN27@operator:

; 3313 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	lea	rax, QWORD PTR [rbx+r14]

; 3314 :             },

	mov	rbx, QWORD PTR [rsp+64]
	mov	WORD PTR [rsi+rax*2], dx
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
??R<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV23@_K_W@Z@QEBA@QEA_WQEB_W001@Z ENDP ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?_Take_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
?_Take_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Take_contents, COMDAT

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx]

; 3003 :         // assign by stealing _Right's buffer
; 3004 :         // pre: this != &_Right
; 3005 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 3006 :         // pre: *this owns no memory, iterators orphaned
; 3007 :         // (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 3008 :         auto& _My_data    = _Mypair._Myval2;
; 3009 :         auto& _Right_data = _Right._Mypair._Myval2;
; 3010 : 
; 3011 : #if !defined(_INSERT_STRING_ANNOTATION)
; 3012 :         if constexpr (_Can_memcpy_val) {
; 3013 : #if _HAS_CXX20
; 3014 :             if (!_STD is_constant_evaluated())
; 3015 : #endif // _HAS_CXX20
; 3016 :             {
; 3017 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3018 :                 if (_Right_data._Large_string_engaged()) {
; 3019 :                     // take ownership of _Right's iterators along with its buffer
; 3020 :                     _Swap_proxy_and_iterators(_Right);
; 3021 :                 } else {
; 3022 :                     _Right_data._Orphan_all();
; 3023 :                 }
; 3024 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3025 : 
; 3026 :                 _Memcpy_val_from(_Right);
; 3027 :                 _Right._Tidy_init();
; 3028 :                 return;
; 3029 :             }
; 3030 :         }
; 3031 : #endif // !defined(_INSERT_STRING_ANNOTATION)
; 3032 : 
; 3033 :         if (_Right_data._Large_string_engaged()) { // steal buffer
; 3034 :             _Construct_in_place(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);
; 3035 :             _Right_data._Bx._Ptr = nullptr;
; 3036 :             _Swap_proxy_and_iterators(_Right);
; 3037 :         } else { // copy small string buffer
; 3038 :             _My_data._Activate_SSO_buffer();
; 3039 :             _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);
; 3040 :             _Right_data._Orphan_all();
; 3041 :         }
; 3042 : 
; 3043 :         _My_data._Myres  = _Right_data._Myres;
; 3044 :         _My_data._Mysize = _Right_data._Mysize;
; 3045 : 
; 3046 :         _Right._Tidy_init();
; 3047 :     }

	xor	eax, eax

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1

; 3003 :         // assign by stealing _Right's buffer
; 3004 :         // pre: this != &_Right
; 3005 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 3006 :         // pre: *this owns no memory, iterators orphaned
; 3007 :         // (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 3008 :         auto& _My_data    = _Mypair._Myval2;
; 3009 :         auto& _Right_data = _Right._Mypair._Myval2;
; 3010 : 
; 3011 : #if !defined(_INSERT_STRING_ANNOTATION)
; 3012 :         if constexpr (_Can_memcpy_val) {
; 3013 : #if _HAS_CXX20
; 3014 :             if (!_STD is_constant_evaluated())
; 3015 : #endif // _HAS_CXX20
; 3016 :             {
; 3017 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3018 :                 if (_Right_data._Large_string_engaged()) {
; 3019 :                     // take ownership of _Right's iterators along with its buffer
; 3020 :                     _Swap_proxy_and_iterators(_Right);
; 3021 :                 } else {
; 3022 :                     _Right_data._Orphan_all();
; 3023 :                 }
; 3024 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3025 : 
; 3026 :                 _Memcpy_val_from(_Right);
; 3027 :                 _Right._Tidy_init();
; 3028 :                 return;
; 3029 :             }
; 3030 :         }
; 3031 : #endif // !defined(_INSERT_STRING_ANNOTATION)
; 3032 : 
; 3033 :         if (_Right_data._Large_string_engaged()) { // steal buffer
; 3034 :             _Construct_in_place(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);
; 3035 :             _Right_data._Bx._Ptr = nullptr;
; 3036 :             _Swap_proxy_and_iterators(_Right);
; 3037 :         } else { // copy small string buffer
; 3038 :             _My_data._Activate_SSO_buffer();
; 3039 :             _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);
; 3040 :             _Right_data._Orphan_all();
; 3041 :         }
; 3042 : 
; 3043 :         _My_data._Myres  = _Right_data._Myres;
; 3044 :         _My_data._Mysize = _Right_data._Mysize;
; 3045 : 
; 3046 :         _Right._Tidy_init();
; 3047 :     }

	mov	QWORD PTR [rdx+16], rax
	mov	QWORD PTR [rdx+24], 7
	mov	WORD PTR [rdx], ax
	ret	0
?_Take_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Take_contents
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty, COMDAT

; 2285 :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers

	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?_Check_offset@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Off$ = 56
?_Check_offset@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAX_K@Z PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Check_offset, COMDAT

; 2258 :     _CONSTEXPR20 void _Check_offset(const size_type _Off) const {

$LN7:
	sub	rsp, 40					; 00000028H

; 2259 :         // checks whether _Off is in the bounds of [0, size()]
; 2260 :         if (_Mysize < _Off) {

	cmp	QWORD PTR [rcx+16], rdx
	jb	SHORT $LN6@Check_offs

; 2262 :         }
; 2263 :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN6@Check_offs:

; 2261 :             _Xran();

	call	?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Xran
	int	3
$LN4@Check_offs:
?_Check_offset@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAX_K@Z ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAPEB_WXZ
_TEXT	SEGMENT
this$ = 8
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAPEB_WXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr, COMDAT

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 8

; 2235 :         const value_type* _Result = _Bx._Buf;
; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN6@Myptr

; 2237 :             _Result = _Unfancy(_Bx._Ptr);
; 2238 :         }
; 2239 : 
; 2240 :         return _Result;

	mov	rax, QWORD PTR [rcx]

; 2241 :     }

	ret	0
$LN6@Myptr:

; 2237 :             _Result = _Unfancy(_Bx._Ptr);
; 2238 :         }
; 2239 : 
; 2240 :         return _Result;

	mov	rax, rcx

; 2241 :     }

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAPEB_WXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@AEBV32@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Al$dead$ = 16
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@AEBV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<wchar_t> >::select_on_container_copy_construction, COMDAT

; 737  :         return _Al;

	mov	rax, rcx

; 738  :     }

	ret	0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@AEBV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<wchar_t> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA_KAEBV?$allocator@_W@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA_KAEBV?$allocator@_W@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<wchar_t> >::max_size, COMDAT

; 733  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 734  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA_KAEBV?$allocator@_W@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z
_TEXT	SEGMENT
this$ = 64
_New_size$ = 72
_Ch$dead$ = 80
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize, COMDAT

; 4137 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _New_size, const _Elem _Ch = _Elem()) {

$LN50:
	sub	rsp, 56					; 00000038H

; 4138 :         // determine new length, padding with _Ch elements as needed
; 4139 :         const size_type _Old_size = size();

	mov	r9, QWORD PTR [rcx+16]
	lea	r8, QWORD PTR [rcx+16]

; 4140 :         if (_New_size <= _Old_size) {

	cmp	rdx, r9
	ja	SHORT $LN2@resize

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 16

; 2227 :         if (_Large_string_engaged()) {

	jb	SHORT $LN8@resize

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rcx]
$LN8@resize:

; 4815 :         _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _New_size], _Elem());

	mov	QWORD PTR [r8], rdx
	mov	BYTE PTR [rcx+rdx], 0

; 4144 :         }
; 4145 :     }

	add	rsp, 56					; 00000038H
	ret	0
$LN2@resize:

; 3298 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	r10, QWORD PTR [rcx+24]
	mov	QWORD PTR [rsp+48], rdi
	mov	rax, r10

; 4141 :             _Eos(_New_size);
; 4142 :         } else {
; 4143 :             append(_New_size - _Old_size, _Ch);

	mov	rdi, rdx

; 3298 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	sub	rax, r9

; 4141 :             _Eos(_New_size);
; 4142 :         } else {
; 4143 :             append(_New_size - _Old_size, _Ch);

	sub	rdi, r9

; 3298 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	cmp	rdi, rax
	ja	SHORT $LN13@resize
	mov	QWORD PTR [rsp+80], rbx

; 3299 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 3300 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	QWORD PTR [r8], rdx

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	r10, 16

; 2227 :         if (_Large_string_engaged()) {

	jb	SHORT $LN16@resize

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rcx]
$LN16@resize:

; 3302 :             _Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);

	lea	rbx, QWORD PTR [rcx+r9]

; 437  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

	mov	r8, rdi
	mov	rcx, rbx
	xor	edx, edx
	call	memset

; 3303 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [rbx+rdi], 0
	mov	rbx, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+48]

; 4144 :         }
; 4145 :     }

	add	rsp, 56					; 00000038H
	ret	0
$LN13@resize:

; 3307 :         return _Reallocate_grow_by(

	mov	r9, rdi
	mov	rdx, rdi
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KD@Z@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@0D@Z@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,unsigned __int64,char>
	mov	rdi, QWORD PTR [rsp+48]

; 4144 :         }
; 4145 :     }

	add	rsp, 56					; 00000038H
	ret	0
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
_TEXT	SEGMENT
this$ = 80
_Count$ = 88
_Ch$dead$ = 96
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT

; 3295 :     _CONSTEXPR20 basic_string& append(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) {

$LN36:
	push	rbx
	push	rbp
	push	rdi
	sub	rsp, 48					; 00000030H

; 3296 :         // append _Count * _Ch
; 3297 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rbp, QWORD PTR [rcx+16]
	mov	rbx, rcx

; 3298 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	rcx, QWORD PTR [rcx+24]
	mov	rdi, rdx
	mov	rax, rcx
	sub	rax, rbp
	cmp	rdx, rax
	ja	SHORT $LN2@append
	mov	QWORD PTR [rsp+96], rsi

; 3299 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 3300 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	rax, QWORD PTR [rdx+rbp]
	mov	QWORD PTR [rbx+16], rax

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	rsi, rbx

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	rcx, 16

; 2227 :         if (_Large_string_engaged()) {

	jb	SHORT $LN5@append

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rsi, QWORD PTR [rbx]
$LN5@append:

; 3301 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3302 :             _Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);

	lea	rcx, QWORD PTR [rsi+rbp]

; 437  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

	mov	r8, rdi
	xor	edx, edx
	call	memset

; 3303 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	lea	rcx, QWORD PTR [rdi+rsi]

; 3304 :             return *this;

	mov	rax, rbx
	mov	rsi, QWORD PTR [rsp+96]
	mov	BYTE PTR [rcx+rbp], 0

; 3308 :             _Count,
; 3309 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Count,
; 3310 :                 const _Elem _Ch) {
; 3311 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3312 :                 _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
; 3313 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 3314 :             },
; 3315 :             _Count, _Ch);
; 3316 :     }

	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rbp
	pop	rbx
	ret	0
$LN2@append:

; 3305 :         }
; 3306 : 
; 3307 :         return _Reallocate_grow_by(

	mov	r9, rdi
	mov	rcx, rbx
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KD@Z@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@0D@Z@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,unsigned __int64,char>

; 3308 :             _Count,
; 3309 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Count,
; 3310 :                 const _Elem _Ch) {
; 3311 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3312 :                 _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
; 3313 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 3314 :             },
; 3315 :             _Count, _Ch);
; 3316 :     }

	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rbp
	pop	rbx
	ret	0
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??R<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@_KD@Z@QEBA@QEADQEBD00D@Z
_TEXT	SEGMENT
this$dead$ = 64
_New_ptr$ = 72
_Old_ptr$ = 80
_Old_size$ = 88
_Count$ = 96
_Ch$dead$ = 104
??R<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@_KD@Z@QEBA@QEADQEBD00D@Z PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>::operator(), COMDAT

; 3310 :                 const _Elem _Ch) {

$LN40:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, QWORD PTR _Count$[rsp]
	mov	rax, r8
	mov	rdi, rdx

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, r9
	mov	rdx, rax
	mov	rcx, rdi

; 3310 :                 const _Elem _Ch) {

	mov	rsi, r9

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy

; 3311 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3312 :                 _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);

	lea	rcx, QWORD PTR [rsi+rdi]

; 437  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

	mov	r8, rbx
	xor	edx, edx
	call	memset

; 3313 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	lea	rax, QWORD PTR [rbx+rsi]
	mov	BYTE PTR [rax+rdi], 0

; 3314 :             },

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
??R<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@_KD@Z@QEBA@QEADQEBD00D@Z ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?assign@?$_WChar_traits@_W@std@@SAXAEA_WAEB_W@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
?assign@?$_WChar_traits@_W@std@@SAXAEA_WAEB_W@Z PROC	; std::_WChar_traits<wchar_t>::assign, COMDAT

; 297  : #if _HAS_CXX20
; 298  :         if (_STD is_constant_evaluated()) {
; 299  :             return _Primary_char_traits::assign(_Left, _Right);
; 300  :         }
; 301  : #endif // _HAS_CXX20
; 302  :         _Left = _Right;
; 303  :     }

	movzx	eax, WORD PTR [rdx]
	mov	WORD PTR [rcx], ax
	ret	0
?assign@?$_WChar_traits@_W@std@@SAXAEA_WAEB_W@Z ENDP	; std::_WChar_traits<wchar_t>::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?length@?$_WChar_traits@_W@std@@SA_KPEB_W@Z
_TEXT	SEGMENT
_First$ = 8
?length@?$_WChar_traits@_W@std@@SA_KPEB_W@Z PROC	; std::_WChar_traits<wchar_t>::length, COMDAT

; 258  :         // find length of null-terminated sequence
; 259  : #if _HAS_CXX17
; 260  :         if constexpr (is_same_v<_Elem, wchar_t>) {
; 261  :             return __builtin_wcslen(_First);

	mov	rax, -1
	npad	9
$LL3@length:
	inc	rax
	cmp	WORD PTR [rcx+rax*2], 0
	jne	SHORT $LL3@length

; 262  :         } else {
; 263  :             return _Primary_char_traits::length(_First);
; 264  :         }
; 265  : #else // _HAS_CXX17
; 266  :         return _CSTD wcslen(reinterpret_cast<const wchar_t*>(_First));
; 267  : #endif // _HAS_CXX17
; 268  :     }

	ret	0
?length@?$_WChar_traits@_W@std@@SA_KPEB_W@Z ENDP	; std::_WChar_traits<wchar_t>::length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?compare@?$_WChar_traits@_W@std@@SAHQEB_W0_K@Z
_TEXT	SEGMENT
_First1$ = 8
_First2$ = 16
_Count$ = 24
?compare@?$_WChar_traits@_W@std@@SAHQEB_W0_K@Z PROC	; std::_WChar_traits<wchar_t>::compare, COMDAT

; 243  :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

	mov	r10, rcx

; 244  :         // compare [_First1, _First1 + _Count) with [_First2, ...)
; 245  : #if _HAS_CXX17
; 246  :         if constexpr (is_same_v<_Elem, wchar_t>) {
; 247  :             return __builtin_wmemcmp(_First1, _First2, _Count);

	test	r8, r8
	je	SHORT $LN11@compare
	sub	r10, rdx
	npad	5
$LL4@compare:
	movzx	r9d, WORD PTR [r10+rdx]
	cmp	r9w, WORD PTR [rdx]
	jne	SHORT $LN5@compare
	add	rdx, 2
	sub	r8, 1
	jne	SHORT $LL4@compare
$LN11@compare:

; 248  :         } else {
; 249  :             return _Primary_char_traits::compare(_First1, _First2, _Count);
; 250  :         }
; 251  : #else // _HAS_CXX17
; 252  :         return _CSTD wmemcmp(
; 253  :             reinterpret_cast<const wchar_t*>(_First1), reinterpret_cast<const wchar_t*>(_First2), _Count);
; 254  : #endif // _HAS_CXX17
; 255  :     }

	xor	eax, eax
	ret	0
$LN5@compare:

; 244  :         // compare [_First1, _First1 + _Count) with [_First2, ...)
; 245  : #if _HAS_CXX17
; 246  :         if constexpr (is_same_v<_Elem, wchar_t>) {
; 247  :             return __builtin_wmemcmp(_First1, _First2, _Count);

	mov	eax, 1
	mov	edx, -1
	cmovb	eax, edx

; 248  :         } else {
; 249  :             return _Primary_char_traits::compare(_First1, _First2, _Count);
; 250  :         }
; 251  : #else // _HAS_CXX17
; 252  :         return _CSTD wmemcmp(
; 253  :             reinterpret_cast<const wchar_t*>(_First1), reinterpret_cast<const wchar_t*>(_First2), _Count);
; 254  : #endif // _HAS_CXX17
; 255  :     }

	ret	0
?compare@?$_WChar_traits@_W@std@@SAHQEB_W0_K@Z ENDP	; std::_WChar_traits<wchar_t>::compare
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?move@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z
_TEXT	SEGMENT
_First1$ = 48
_First2$ = 56
_Count$ = 64
?move@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z PROC ; std::_Char_traits<wchar_t,unsigned short>::move, COMDAT

; 81   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

$LN33:
	push	rbx
	sub	rsp, 32					; 00000020H
	add	r8, r8
	mov	rbx, rcx

; 82   :         // copy [_First2, _First2 + _Count) to [_First1, ...), allowing overlap
; 83   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 84   :         __builtin_memmove(_First1, _First2, _Count * sizeof(_Elem));
; 85   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS / !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 86   : #if _HAS_CXX20
; 87   :         if (_STD is_constant_evaluated()) {
; 88   :             // dest: [_First1, _First1 + _Count)
; 89   :             // src: [_First2, _First2 + _Count)
; 90   :             // We need to handle overlapping ranges.
; 91   :             // If _First1 is in the src range, we need a backward loop.
; 92   :             // Otherwise, the forward loop works (even if the back of dest overlaps the front of src).
; 93   : 
; 94   :             // Usually, we would compare pointers with less-than, even though they could belong to different arrays.
; 95   :             // However, we're not allowed to do that during constant evaluation, so we need a linear scan for equality.
; 96   :             bool _Loop_forward = true;
; 97   : 
; 98   :             for (const _Elem* _Src = _First2; _Src != _First2 + _Count; ++_Src) {
; 99   :                 if (_First1 == _Src) {
; 100  :                     _Loop_forward = false;
; 101  :                     break;
; 102  :                 }
; 103  :             }
; 104  : 
; 105  :             if (_Loop_forward) {
; 106  :                 for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
; 107  :                     _First1[_Idx] = _First2[_Idx];
; 108  :                 }
; 109  :             } else {
; 110  :                 for (size_t _Idx = _Count; _Idx != 0; --_Idx) {
; 111  :                     _First1[_Idx - 1] = _First2[_Idx - 1];
; 112  :                 }
; 113  :             }
; 114  : 
; 115  :             return _First1;
; 116  :         }
; 117  : #endif // _HAS_CXX20
; 118  : 
; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	call	memmove

; 120  : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 121  : 
; 122  :         return _First1;

	mov	rax, rbx

; 123  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?move@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z ENDP ; std::_Char_traits<wchar_t,unsigned short>::move
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?copy@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z
_TEXT	SEGMENT
_First1$ = 48
_First2$ = 56
_Count$ = 64
?copy@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z PROC ; std::_Char_traits<wchar_t,unsigned short>::copy, COMDAT

; 50   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

$LN15:
	push	rbx
	sub	rsp, 32					; 00000020H

; 51   :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 52   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 53   :         __builtin_memcpy(_First1, _First2, _Count * sizeof(_Elem));
; 54   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS / !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 55   : #if _HAS_CXX20
; 56   :         if (_STD is_constant_evaluated()) {
; 57   :             // pre: [_First1, _First1 + _Count) and [_First2, _First2 + _Count) do not overlap
; 58   :             for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
; 59   :                 _First1[_Idx] = _First2[_Idx];
; 60   :             }
; 61   : 
; 62   :             return _First1;
; 63   :         }
; 64   : #endif // _HAS_CXX20
; 65   : 
; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	add	r8, r8
	mov	rbx, rcx
	call	memcpy

; 67   : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 68   : 
; 69   :         return _First1;

	mov	rax, rbx

; 70   :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?copy@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z ENDP ; std::_Char_traits<wchar_t,unsigned short>::copy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Getal@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAAEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAAEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@2@XZ PROC ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::_Getal, COMDAT

; 2181 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2182 :     }

	ret	0
?_Getal@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAAEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@2@XZ ENDP ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?deallocate@?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@QEAAXQEAUNodeDef@AINBNodeDefMgr@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@QEAAXQEAUNodeDef@AINBNodeDefMgr@@_K@Z PROC ; std::allocator<AINBNodeDefMgr::NodeDef>::deallocate, COMDAT

; 966  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN23:
	sub	rsp, 40					; 00000028H
	mov	rax, rdx

; 967  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 968  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	imul	rdx, r8, 248				; 000000f8H

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN17@deallocate

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN14@deallocate

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN17@deallocate:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rax

; 970  :     }

	add	rsp, 40					; 00000028H

; 265  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN14@deallocate:

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN20@deallocate:
?deallocate@?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@QEAAXQEAUNodeDef@AINBNodeDefMgr@@_K@Z ENDP ; std::allocator<AINBNodeDefMgr::NodeDef>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ?_Swap@?$_Ptr_base@U_Recursive_dir_enum_impl@filesystem@std@@@std@@IEAAXAEAV12@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
?_Swap@?$_Ptr_base@U_Recursive_dir_enum_impl@filesystem@std@@@std@@IEAAXAEAV12@@Z PROC ; std::_Ptr_base<std::filesystem::_Recursive_dir_enum_impl>::_Swap, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	mov	rax, QWORD PTR [rdx]
	mov	r8, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR [rdx+8]

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [rdx], r8

; 99   :     _Ty _Tmp = _STD move(_Left);

	mov	r8, QWORD PTR [rcx+8]

; 100  :     _Left    = _STD move(_Right);

	mov	QWORD PTR [rcx+8], rax

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [rdx+8], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 1410 :     }

	ret	0
?_Swap@?$_Ptr_base@U_Recursive_dir_enum_impl@filesystem@std@@@std@@IEAAXAEAV12@@Z ENDP ; std::_Ptr_base<std::filesystem::_Recursive_dir_enum_impl>::_Swap
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Find_file_handle@filesystem@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U_Find_file_handle@filesystem@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Find_file_handle@filesystem@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U_Find_file_handle@filesystem@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::filesystem::_Find_file_handle>,std::_Vector_val<std::_Simple_types<std::filesystem::_Find_file_handle> >,1>::_Get_first, COMDAT

; 1523 :         return *this;

	mov	rax, rcx

; 1524 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Find_file_handle@filesystem@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U_Find_file_handle@filesystem@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::filesystem::_Find_file_handle>,std::_Vector_val<std::_Simple_types<std::filesystem::_Find_file_handle> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?deallocate@?$allocator@U_Find_file_handle@filesystem@std@@@std@@QEAAXQEAU_Find_file_handle@filesystem@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@U_Find_file_handle@filesystem@std@@@std@@QEAAXQEAU_Find_file_handle@filesystem@2@_K@Z PROC ; std::allocator<std::filesystem::_Find_file_handle>::deallocate, COMDAT

; 966  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN23:
	sub	rsp, 40					; 00000028H
	mov	rax, rdx

; 967  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 968  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [r8*8]

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN17@deallocate

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN14@deallocate

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN17@deallocate:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rax

; 970  :     }

	add	rsp, 40					; 00000028H

; 265  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN14@deallocate:

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN20@deallocate:
?deallocate@?$allocator@U_Find_file_handle@filesystem@std@@@std@@QEAAXQEAU_Find_file_handle@filesystem@2@_K@Z ENDP ; std::allocator<std::filesystem::_Find_file_handle>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEBAAEBV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEBAAEBV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum>,std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >,1>::_Get_first, COMDAT

; 1527 :         return *this;

	mov	rax, rcx

; 1528 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEBAAEBV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum>,std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAAAEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAAAEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum>,std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >,1>::_Get_first, COMDAT

; 1523 :         return *this;

	mov	rax, rcx

; 1524 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAAAEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum>,std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?deallocate@?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@QEAAXQEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@QEAAXQEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_K@Z PROC ; std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum>::deallocate, COMDAT

; 966  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN23:
	sub	rsp, 40					; 00000028H
	mov	rax, rdx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	r8, 4096				; 00001000H
	jb	SHORT $LN17@deallocate

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rdx-8]
	add	r8, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN14@deallocate

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN17@deallocate:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rdx, r8
	mov	rcx, rax

; 967  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 968  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);
; 970  :     }

	add	rsp, 40					; 00000028H

; 265  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN14@deallocate:

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN20@deallocate:
?deallocate@?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@QEAAXQEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_K@Z ENDP ; std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >,std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >,1>::_Get_first, COMDAT

; 1527 :         return *this;

	mov	rax, rcx

; 1528 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >,std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >,std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >,1>::_Get_first, COMDAT

; 1523 :         return *this;

	mov	rax, rcx

; 1524 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >,std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?deallocate@?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAAXQEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAAXQEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K@Z PROC ; std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >::deallocate, COMDAT

; 966  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN23:
	sub	rsp, 40					; 00000028H
	mov	rax, rdx

; 967  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 968  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [r8+r8*2]
	shl	rdx, 3

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN17@deallocate

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN14@deallocate

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN17@deallocate:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rax

; 970  :     }

	add	rsp, 40					; 00000028H

; 265  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN14@deallocate:

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN20@deallocate:
?deallocate@?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAAXQEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K@Z ENDP ; std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >,std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >,1>::_Get_first, COMDAT

; 1527 :         return *this;

	mov	rax, rcx

; 1528 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >,std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >,std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >,1>::_Get_first, COMDAT

; 1523 :         return *this;

	mov	rax, rcx

; 1524 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >,std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?deallocate@?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAAXQEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAAXQEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K@Z PROC ; std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >::deallocate, COMDAT

; 966  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN23:
	sub	rsp, 40					; 00000028H
	mov	rax, rdx

; 967  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 968  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [r8+r8*2]
	shl	rdx, 3

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN17@deallocate

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN14@deallocate

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN17@deallocate:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rax

; 970  :     }

	add	rsp, 40					; 00000028H

; 265  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN14@deallocate:

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN20@deallocate:
?deallocate@?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAAXQEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K@Z ENDP ; std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEBAAEBV?$allocator@_W@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEBAAEBV?$allocator@_W@2@XZ PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first, COMDAT

; 1527 :         return *this;

	mov	rax, rcx

; 1528 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEBAAEBV?$allocator@_W@2@XZ ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$allocator@_W@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$allocator@_W@2@XZ PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first, COMDAT

; 1523 :         return *this;

	mov	rax, rcx

; 1524 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$allocator@_W@2@XZ ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?_Swap_proxy_and_iterators@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Right$dead$ = 16
?_Swap_proxy_and_iterators@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Swap_proxy_and_iterators, COMDAT

; 4854 :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 4855 :     }

	ret	0
?_Swap_proxy_and_iterators@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?_Memcpy_val_from@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEBV12@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
?_Memcpy_val_from@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEBV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Memcpy_val_from, COMDAT

; 2994 :         _STL_INTERNAL_CHECK(_Can_memcpy_val);
; 2995 :         const auto _My_data_mem =
; 2996 :             reinterpret_cast<unsigned char*>(_STD addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
; 2997 :         const auto _Right_data_mem =
; 2998 :             reinterpret_cast<const unsigned char*>(_STD addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1

; 3000 :     }

	ret	0
?_Memcpy_val_from@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEBV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Memcpy_val_from
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Xran, COMDAT

; 2272 :     [[noreturn]] static void _Xran() {

$LN4:
	sub	rsp, 40					; 00000028H

; 2273 :         _Xout_of_range("invalid string position");

	lea	rcx, OFFSET FLAT:??_C@_0BI@CFPLBAOH@invalid?5string?5position@
	call	QWORD PTR __imp_?_Xout_of_range@std@@YAXPEBD@Z
	int	3
$LN3@Xran:
?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAXXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Activate_SSO_buffer, COMDAT

; 2248 :         // start the lifetime of the array elements
; 2249 : #if _HAS_CXX20
; 2250 :         if (_STD is_constant_evaluated()) {
; 2251 :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 2252 :                 _Bx._Buf[_Idx] = value_type();
; 2253 :             }
; 2254 :         }
; 2255 : #endif // _HAS_CXX20
; 2256 :     }

	ret	0
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAXXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Activate_SSO_buffer
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z PROC	; std::allocator<wchar_t>::deallocate, COMDAT

; 966  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN23:
	sub	rsp, 40					; 00000028H
	mov	rax, rdx

; 967  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 968  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [r8+r8]

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN17@deallocate

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN14@deallocate

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN17@deallocate:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rax

; 970  :     }

	add	rsp, 40					; 00000028H

; 265  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN14@deallocate:

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN20@deallocate:
?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z ENDP	; std::allocator<wchar_t>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
_New_size$ = 16
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 16

; 2227 :         if (_Large_string_engaged()) {

	jb	SHORT $LN8@Eos

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rcx]

; 4814 :         _ASAN_STRING_MODIFY(*this, _Mypair._Myval2._Mysize, _New_size);
; 4815 :         _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _New_size], _Elem());

	mov	QWORD PTR [rcx+16], rdx
	mov	BYTE PTR [rax+rdx], 0

; 4816 :     }

	ret	0
$LN8@Eos:

; 4814 :         _ASAN_STRING_MODIFY(*this, _Mypair._Myval2._Mysize, _New_size);
; 4815 :         _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _New_size], _Elem());

	mov	QWORD PTR [rcx+16], rdx
	mov	BYTE PTR [rcx+rdx], 0

; 4816 :     }

	ret	0
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\wchar.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?assign@?$_WChar_traits@_W@std@@SAPEA_WQEA_W_K_W@Z
_TEXT	SEGMENT
_First$ = 16
_Count$ = 24
_Ch$dead$ = 32
?assign@?$_WChar_traits@_W@std@@SAPEA_WQEA_W_K_W@Z PROC	; std::_WChar_traits<wchar_t>::assign, COMDAT

; 285  :         _Out_writes_all_(_Count) _Elem* const _First, size_t _Count, const _Elem _Ch) noexcept /* strengthened */ {

$LN37:
	sub	rsp, 8
	mov	r8, rcx
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\wchar.h

; 259  :         for (; 0 < _N; ++_Su, --_N)

	test	rdx, rdx
	je	SHORT $LN33@assign
	mov	QWORD PTR [rsp], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 285  :         _Out_writes_all_(_Count) _Elem* const _First, size_t _Count, const _Elem _Ch) noexcept /* strengthened */ {

	xor	eax, eax
	mov	rdi, rcx
	movzx	eax, ax
	mov	rcx, rdx
	rep stosw

; 286  :         // assign _Count * _Ch to [_First, ...)
; 287  : #if _HAS_CXX20
; 288  :         if (_STD is_constant_evaluated()) {
; 289  :             return _Primary_char_traits::assign(_First, _Count, _Ch);
; 290  :         }
; 291  : #endif // _HAS_CXX20
; 292  : 
; 293  :         return reinterpret_cast<_Elem*>(_CSTD wmemset(reinterpret_cast<wchar_t*>(_First), _Ch, _Count));

	mov	rdi, QWORD PTR [rsp]
$LN33@assign:

; 294  :     }

	mov	rax, r8
	add	rsp, 8
	ret	0
?assign@?$_WChar_traits@_W@std@@SAPEA_WQEA_W_K_W@Z ENDP	; std::_WChar_traits<wchar_t>::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?assign@?$_Char_traits@_WG@std@@SAXAEA_WAEB_W@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
?assign@?$_Char_traits@_WG@std@@SAXAEA_WAEB_W@Z PROC	; std::_Char_traits<wchar_t,unsigned short>::assign, COMDAT

; 183  : #if _HAS_CXX20
; 184  :         if (_STD is_constant_evaluated()) {
; 185  :             _STD construct_at(_STD addressof(_Left), _Right);
; 186  :         } else
; 187  : #endif // _HAS_CXX20
; 188  :         {
; 189  :             _Left = _Right;
; 190  :         }
; 191  :     }

	movzx	eax, WORD PTR [rdx]
	mov	WORD PTR [rcx], ax
	ret	0
?assign@?$_Char_traits@_WG@std@@SAXAEA_WAEB_W@Z ENDP	; std::_Char_traits<wchar_t,unsigned short>::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UNodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UNodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef> >,1>::_Get_first, COMDAT

; 1523 :         return *this;

	mov	rax, rcx

; 1524 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UNodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?assign@?$_Char_traits@_WG@std@@SAPEA_WQEA_W_K_W@Z
_TEXT	SEGMENT
_First$ = 16
_Count$ = 24
_Ch$dead$ = 32
?assign@?$_Char_traits@_WG@std@@SAPEA_WQEA_W_K_W@Z PROC	; std::_Char_traits<wchar_t,unsigned short>::assign, COMDAT

; 164  :         _Out_writes_all_(_Count) _Elem* const _First, size_t _Count, const _Elem _Ch) noexcept /* strengthened */ {

$LN25:
	sub	rsp, 8
	mov	r8, rcx

; 165  :         // assign _Count * _Ch to [_First, ...)
; 166  : #if _HAS_CXX20
; 167  :         if (_STD is_constant_evaluated()) {
; 168  :             for (_Elem* _Next = _First; _Count > 0; --_Count, ++_Next) {
; 169  :                 _STD construct_at(_Next, _Ch);
; 170  :             }
; 171  :         } else
; 172  : #endif // _HAS_CXX20
; 173  :         {
; 174  :             for (_Elem* _Next = _First; _Count > 0; --_Count, ++_Next) {

	test	rdx, rdx
	je	SHORT $LN21@assign
	mov	QWORD PTR [rsp], rdi
	xor	eax, eax
	mov	rdi, rcx
	movzx	eax, ax
	mov	rcx, rdx
	rep stosw

; 175  :                 *_Next = _Ch;
; 176  :             }
; 177  :         }
; 178  : 
; 179  :         return _First;

	mov	rdi, QWORD PTR [rsp]
$LN21@assign:

; 180  :     }

	mov	rax, r8
	add	rsp, 8
	ret	0
?assign@?$_Char_traits@_WG@std@@SAPEA_WQEA_W_K_W@Z ENDP	; std::_Char_traits<wchar_t,unsigned short>::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$_Bit_cast@_KT_Addr_storage@error_category@std@@$0A@@std@@YA_KAEBT_Addr_storage@error_category@0@@Z
_TEXT	SEGMENT
_Val$ = 8
??$_Bit_cast@_KT_Addr_storage@error_category@std@@$0A@@std@@YA_KAEBT_Addr_storage@error_category@0@@Z PROC ; std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>, COMDAT

; 2536 :     return __builtin_bit_cast(_To, _Val);

	mov	rax, QWORD PTR [rcx]

; 2537 : }

	ret	0
??$_Bit_cast@_KT_Addr_storage@error_category@std@@$0A@@std@@YA_KAEBT_Addr_storage@error_category@0@@Z ENDP ; std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
;	COMDAT ??$_Immortalize_memcpy_image@V_Generic_error_category@std@@@std@@YAAEBV_Generic_error_category@0@XZ
_TEXT	SEGMENT
??$_Immortalize_memcpy_image@V_Generic_error_category@std@@@std@@YAAEBV_Generic_error_category@0@XZ PROC ; std::_Immortalize_memcpy_image<std::_Generic_error_category>, COMDAT

; 643  :     static constexpr _Ty _Static;
; 644  :     return _Static;

	lea	rax, OFFSET FLAT:?_Static@?1???$_Immortalize_memcpy_image@V_Generic_error_category@std@@@std@@YAAEBV_Generic_error_category@1@XZ@4V21@B ; `std::_Immortalize_memcpy_image<std::_Generic_error_category>'::`2'::_Static

; 645  : }

	ret	0
??$_Immortalize_memcpy_image@V_Generic_error_category@std@@@std@@YAAEBV_Generic_error_category@0@XZ ENDP ; std::_Immortalize_memcpy_image<std::_Generic_error_category>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\system_error
;	COMDAT ??$_Immortalize_memcpy_image@V_System_error_category@std@@@std@@YAAEBV_System_error_category@0@XZ
_TEXT	SEGMENT
??$_Immortalize_memcpy_image@V_System_error_category@std@@@std@@YAAEBV_System_error_category@0@XZ PROC ; std::_Immortalize_memcpy_image<std::_System_error_category>, COMDAT

; 643  :     static constexpr _Ty _Static;
; 644  :     return _Static;

	lea	rax, OFFSET FLAT:?_Static@?1???$_Immortalize_memcpy_image@V_System_error_category@std@@@std@@YAAEBV_System_error_category@1@XZ@4V21@B ; `std::_Immortalize_memcpy_image<std::_System_error_category>'::`2'::_Static

; 645  : }

	ret	0
??$_Immortalize_memcpy_image@V_System_error_category@std@@@std@@YAAEBV_System_error_category@0@XZ ENDP ; std::_Immortalize_memcpy_image<std::_System_error_category>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Adl_verify_range@PEB_WPEB_W@std@@YAXAEBQEB_W0@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
??$_Adl_verify_range@PEB_WPEB_W@std@@YAXAEBQEB_W0@Z PROC ; std::_Adl_verify_range<wchar_t const *,wchar_t const *>, COMDAT

; 1133 :     // check that [_First, _Last) forms an iterator range
; 1134 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1135 :         _Verify_range(_First, _Last);
; 1136 :     }
; 1137 : }

	ret	0
??$_Adl_verify_range@PEB_WPEB_W@std@@YAXAEBQEB_W0@Z ENDP ; std::_Adl_verify_range<wchar_t const *,wchar_t const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$_Bitmask_includes_any@W4__std_fs_stats_flags@@@std@@YA_NW4__std_fs_stats_flags@@0@Z
_TEXT	SEGMENT
_Left$ = 8
_Elements$ = 16
??$_Bitmask_includes_any@W4__std_fs_stats_flags@@@std@@YA_NW4__std_fs_stats_flags@@0@Z PROC ; std::_Bitmask_includes_any<enum __std_fs_stats_flags>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 127  : _BITMASK_OPS(_EMPTY_ARGUMENT, __std_fs_stats_flags)

	test	ecx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2324 :     return (_Left & _Elements) != _Bitmask{};

	setne	al

; 2325 : }

	ret	0
??$_Bitmask_includes_any@W4__std_fs_stats_flags@@@std@@YA_NW4__std_fs_stats_flags@@0@Z ENDP ; std::_Bitmask_includes_any<enum __std_fs_stats_flags>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z PROC			; std::_Unfancy<wchar_t>, COMDAT

; 37   :     return _Ptr;

	mov	rax, rcx

; 38   : }

	ret	0
??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z ENDP			; std::_Unfancy<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ??$_Unaligned_load@I@filesystem@std@@YAIPEBX@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unaligned_load@I@filesystem@std@@YAIPEBX@Z PROC	; std::filesystem::_Unaligned_load<unsigned int>, COMDAT

; 351  :         static_assert(is_trivial_v<_Ty>, "Unaligned loads require trivial types");
; 352  :         _Ty _Tmp;
; 353  :         _CSTD memcpy(&_Tmp, _Ptr, sizeof(_Tmp));
; 354  :         return _Tmp;

	mov	eax, DWORD PTR [rcx]

; 355  :     }

	ret	0
??$_Unaligned_load@I@filesystem@std@@YAIPEBX@Z ENDP	; std::filesystem::_Unaligned_load<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$find_if@PEB_WU_Is_slash_oper@std@@@std@@YAPEB_WPEB_WQEB_WU_Is_slash_oper@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Pred$dead$ = 24
??$find_if@PEB_WU_Is_slash_oper@std@@@std@@YAPEB_WPEB_WQEB_WU_Is_slash_oper@0@@Z PROC ; std::find_if<wchar_t const *,std::_Is_slash_oper>, COMDAT

; 6315 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, rdx
	je	SHORT $LN17@find_if
$LL4@find_if:

; 6316 :         if (_Pred(*_UFirst)) {

	movzx	eax, WORD PTR [rcx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 384  :         return _Ch == L'\\' || _Ch == L'/';

	cmp	ax, 92					; 0000005cH
	je	SHORT $LN17@find_if
	cmp	ax, 47					; 0000002fH
	je	SHORT $LN17@find_if
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 6315 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	rcx, 2
	cmp	rcx, rdx
	jne	SHORT $LL4@find_if
$LN17@find_if:

; 6317 :             break;
; 6318 :         }
; 6319 :     }
; 6320 : 
; 6321 :     _Seek_wrapped(_First, _UFirst);
; 6322 :     return _First;
; 6323 : }

	mov	rax, rcx
	ret	0
??$find_if@PEB_WU_Is_slash_oper@std@@@std@@YAPEB_WPEB_WQEB_WU_Is_slash_oper@0@@Z ENDP ; std::find_if<wchar_t const *,std::_Is_slash_oper>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEAPEB_W@std@@YA?A_TAEAPEB_W@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEAPEB_W@std@@YA?A_TAEAPEB_W@Z PROC	; std::_Get_unwrapped<wchar_t const * &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEAPEB_W@std@@YA?A_TAEAPEB_W@Z ENDP	; std::_Get_unwrapped<wchar_t const * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEB_W@std@@YA?A_TAEBQEB_W@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEB_W@std@@YA?A_TAEBQEB_W@Z PROC	; std::_Get_unwrapped<wchar_t const * const &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEBQEB_W@std@@YA?A_TAEBQEB_W@Z ENDP	; std::_Get_unwrapped<wchar_t const * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$find_if_not@PEB_WU_Is_slash_oper@std@@@std@@YAPEB_WPEB_WQEB_WU_Is_slash_oper@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Pred$dead$ = 24
??$find_if_not@PEB_WU_Is_slash_oper@std@@@std@@YAPEB_WPEB_WQEB_WU_Is_slash_oper@0@@Z PROC ; std::find_if_not<wchar_t const *,std::_Is_slash_oper>, COMDAT

; 365  : _NODISCARD _CONSTEXPR20 _InIt find_if_not(_InIt _First, const _InIt _Last, _Pr _Pred) {

	npad	2
$LN22@find_if_no:

; 371  :         if (!_Pred(*_UFirst)) {

	cmp	rcx, rdx
	je	SHORT $LN19@find_if_no
	movzx	eax, WORD PTR [rcx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 384  :         return _Ch == L'\\' || _Ch == L'/';

	cmp	ax, 92					; 0000005cH
	je	SHORT $LN16@find_if_no
	cmp	ax, 47					; 0000002fH
	jne	SHORT $LN19@find_if_no
$LN16@find_if_no:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 370  :     for (; _UFirst != _ULast; ++_UFirst) {

	add	rcx, 2
	jmp	SHORT $LN22@find_if_no
$LN19@find_if_no:

; 372  :             break;
; 373  :         }
; 374  :     }
; 375  : 
; 376  :     _Seek_wrapped(_First, _UFirst);
; 377  :     return _First;
; 378  : }

	mov	rax, rcx
	ret	0
??$find_if_not@PEB_WU_Is_slash_oper@std@@@std@@YAPEB_WPEB_WQEB_WU_Is_slash_oper@0@@Z ENDP ; std::find_if_not<wchar_t const *,std::_Is_slash_oper>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??$_Traits_compare@U?$char_traits@_W@std@@@std@@YAHQEB_W_K01@Z
_TEXT	SEGMENT
_Left$ = 8
_Left_size$ = 16
_Right$ = 24
_Right_size$ = 32
??$_Traits_compare@U?$char_traits@_W@std@@@std@@YAHQEB_W_K01@Z PROC ; std::_Traits_compare<std::char_traits<wchar_t> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 70   :     return _Right < _Left ? _Right : _Left;

	cmp	r9, rdx
	mov	rax, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 553  :     _In_reads_(_Right_size) const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept {

	mov	r10, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 70   :     return _Right < _Left ? _Right : _Left;

	cmovb	rax, r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 247  :             return __builtin_wmemcmp(_First1, _First2, _Count);

	test	rax, rax
	je	SHORT $LN2@Traits_com
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 70   :     return _Right < _Left ? _Right : _Left;

	sub	r10, r8
$LL11@Traits_com:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 247  :             return __builtin_wmemcmp(_First1, _First2, _Count);

	movzx	ecx, WORD PTR [r10+r8]
	cmp	cx, WORD PTR [r8]
	jne	SHORT $LN12@Traits_com
	add	r8, 2
	sub	rax, 1
	jne	SHORT $LL11@Traits_com
$LN2@Traits_com:

; 554  :     // compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) using _Traits
; 555  :     const int _Ans = _Traits::compare(_Left, _Right, (_STD min)(_Left_size, _Right_size));
; 556  : 
; 557  :     if (_Ans != 0) {
; 558  :         return _Ans;
; 559  :     }
; 560  : 
; 561  :     if (_Left_size < _Right_size) {

	cmp	rdx, r9
	jae	SHORT $LN3@Traits_com

; 562  :         return -1;

	mov	eax, -1

; 566  :         return 1;
; 567  :     }
; 568  : 
; 569  :     return 0;
; 570  : }

	ret	0
$LN12@Traits_com:

; 247  :             return __builtin_wmemcmp(_First1, _First2, _Count);

	mov	eax, 1
	mov	r8d, -1
	cmovb	eax, r8d

; 566  :         return 1;
; 567  :     }
; 568  : 
; 569  :     return 0;
; 570  : }

	ret	0
$LN3@Traits_com:

; 563  :     }
; 564  : 
; 565  :     if (_Left_size > _Right_size) {

	xor	eax, eax
	cmp	rdx, r9
	seta	al

; 566  :         return 1;
; 567  :     }
; 568  : 
; 569  :     return 0;
; 570  : }

	ret	0
??$_Traits_compare@U?$char_traits@_W@std@@@std@@YAHQEB_W_K01@Z ENDP ; std::_Traits_compare<std::char_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$exchange@W4__std_fs_dir_handle@@W41@@std@@YA?AW4__std_fs_dir_handle@@AEAW41@$$QEAW41@@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@W4__std_fs_dir_handle@@W41@@std@@YA?AW4__std_fs_dir_handle@@AEAW41@$$QEAW41@@Z PROC ; std::exchange<enum __std_fs_dir_handle,enum __std_fs_dir_handle>, COMDAT

; 753  :     // assign _New_val to _Val, return previous _Val
; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 756  :     return _Old_val;
; 757  : }

	ret	0
??$exchange@W4__std_fs_dir_handle@@W41@@std@@YA?AW4__std_fs_dir_handle@@AEAW41@$$QEAW41@@Z ENDP ; std::exchange<enum __std_fs_dir_handle,enum __std_fs_dir_handle>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$exchange@W4__std_fs_dir_handle@@AEAW41@@std@@YA?AW4__std_fs_dir_handle@@AEAW41@0@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@W4__std_fs_dir_handle@@AEAW41@@std@@YA?AW4__std_fs_dir_handle@@AEAW41@0@Z PROC ; std::exchange<enum __std_fs_dir_handle,enum __std_fs_dir_handle &>, COMDAT

; 753  :     // assign _New_val to _Val, return previous _Val
; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 756  :     return _Old_val;
; 757  : }

	ret	0
??$exchange@W4__std_fs_dir_handle@@AEAW41@@std@@YA?AW4__std_fs_dir_handle@@AEAW41@0@Z ENDP ; std::exchange<enum __std_fs_dir_handle,enum __std_fs_dir_handle &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$find_if@V?$reverse_iterator@PEB_W@std@@U_Is_slash_oper@2@@std@@YA?AV?$reverse_iterator@PEB_W@0@V10@V10@U_Is_slash_oper@0@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_First$ = 16
_Last$ = 24
_Pred$dead$ = 32
??$find_if@V?$reverse_iterator@PEB_W@std@@U_Is_slash_oper@2@@std@@YA?AV?$reverse_iterator@PEB_W@0@V10@V10@U_Is_slash_oper@0@@Z PROC ; std::find_if<std::reverse_iterator<wchar_t const *>,std::_Is_slash_oper>, COMDAT

; 6311 : _NODISCARD _CONSTEXPR20 _InIt find_if(_InIt _First, const _InIt _Last, _Pr _Pred) { // find first satisfying _Pred

	mov	rax, rcx

; 1681 :     return _Left._Get_current() != _Right._Get_current();

	cmp	rdx, r8

; 6312 :     _Adl_verify_range(_First, _Last);
; 6313 :     auto _UFirst      = _Get_unwrapped(_First);
; 6314 :     const auto _ULast = _Get_unwrapped(_Last);
; 6315 :     for (; _UFirst != _ULast; ++_UFirst) {

	je	SHORT $LN27@find_if
	npad	8
$LL12@find_if:

; 6316 :         if (_Pred(*_UFirst)) {

	movzx	r9d, WORD PTR [rdx-2]
	lea	rcx, QWORD PTR [rdx-2]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 384  :         return _Ch == L'\\' || _Ch == L'/';

	cmp	r9w, 92					; 0000005cH
	je	SHORT $LN28@find_if
	cmp	r9w, 47					; 0000002fH
	je	SHORT $LN28@find_if
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 1544 :         --current;

	mov	rdx, rcx

; 1681 :     return _Left._Get_current() != _Right._Get_current();

	cmp	rcx, r8

; 6312 :     _Adl_verify_range(_First, _Last);
; 6313 :     auto _UFirst      = _Get_unwrapped(_First);
; 6314 :     const auto _ULast = _Get_unwrapped(_Last);
; 6315 :     for (; _UFirst != _ULast; ++_UFirst) {

	jne	SHORT $LL12@find_if

; 6317 :             break;
; 6318 :         }
; 6319 :     }
; 6320 : 
; 6321 :     _Seek_wrapped(_First, _UFirst);
; 6322 :     return _First;

	mov	QWORD PTR [rax], rcx

; 6323 : }

	ret	0
$LN28@find_if:
	mov	QWORD PTR [rax], rdx
	ret	0
$LN27@find_if:

; 6317 :             break;
; 6318 :         }
; 6319 :     }
; 6320 : 
; 6321 :     _Seek_wrapped(_First, _UFirst);
; 6322 :     return _First;

	mov	QWORD PTR [rcx], rdx

; 6323 : }

	ret	0
??$find_if@V?$reverse_iterator@PEB_W@std@@U_Is_slash_oper@2@@std@@YA?AV?$reverse_iterator@PEB_W@0@V10@V10@U_Is_slash_oper@0@@Z ENDP ; std::find_if<std::reverse_iterator<wchar_t const *>,std::_Is_slash_oper>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEAV?$reverse_iterator@PEB_W@std@@@std@@YA?A_TAEAV?$reverse_iterator@PEB_W@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEAV?$reverse_iterator@PEB_W@std@@@std@@YA?A_TAEAV?$reverse_iterator@PEB_W@0@@Z PROC ; std::_Get_unwrapped<std::reverse_iterator<wchar_t const *> &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;
; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);

	mov	rax, rcx

; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEAV?$reverse_iterator@PEB_W@std@@@std@@YA?A_TAEAV?$reverse_iterator@PEB_W@0@@Z ENDP ; std::_Get_unwrapped<std::reverse_iterator<wchar_t const *> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBV?$reverse_iterator@PEB_W@std@@@std@@YA?A_TAEBV?$reverse_iterator@PEB_W@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBV?$reverse_iterator@PEB_W@std@@@std@@YA?A_TAEBV?$reverse_iterator@PEB_W@0@@Z PROC ; std::_Get_unwrapped<std::reverse_iterator<wchar_t const *> const &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;
; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);

	mov	rax, rcx

; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEBV?$reverse_iterator@PEB_W@std@@@std@@YA?A_TAEBV?$reverse_iterator@PEB_W@0@@Z ENDP ; std::_Get_unwrapped<std::reverse_iterator<wchar_t const *> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$?9PEB_WPEB_W@std@@YA_NAEBV?$reverse_iterator@PEB_W@0@0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$?9PEB_WPEB_W@std@@YA_NAEBV?$reverse_iterator@PEB_W@0@0@Z PROC ; std::operator!=<wchar_t const *,wchar_t const *>, COMDAT

; 1681 :     return _Left._Get_current() != _Right._Get_current();

	mov	rax, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rax
	setne	al

; 1682 : }

	ret	0
??$?9PEB_WPEB_W@std@@YA_NAEBV?$reverse_iterator@PEB_W@0@0@Z ENDP ; std::operator!=<wchar_t const *,wchar_t const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ?_Get_current@?$reverse_iterator@PEB_W@std@@QEBAAEBQEB_WXZ
_TEXT	SEGMENT
this$ = 8
?_Get_current@?$reverse_iterator@PEB_W@std@@QEBAAEBQEB_WXZ PROC ; std::reverse_iterator<wchar_t const *>::_Get_current, COMDAT

; 1647 :         return current;

	mov	rax, rcx

; 1648 :     }

	ret	0
?_Get_current@?$reverse_iterator@PEB_W@std@@QEBAAEBQEB_WXZ ENDP ; std::reverse_iterator<wchar_t const *>::_Get_current
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??D?$reverse_iterator@PEB_W@std@@QEBAAEB_WXZ
_TEXT	SEGMENT
this$ = 8
??D?$reverse_iterator@PEB_W@std@@QEBAAEB_WXZ PROC	; std::reverse_iterator<wchar_t const *>::operator*, COMDAT

; 1523 :         _BidIt _Tmp = current;
; 1524 :         return *--_Tmp;

	mov	rax, QWORD PTR [rcx]
	sub	rax, 2

; 1525 :     }

	ret	0
??D?$reverse_iterator@PEB_W@std@@QEBAAEB_WXZ ENDP	; std::reverse_iterator<wchar_t const *>::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$find_if_not@V?$reverse_iterator@PEB_W@std@@U_Is_slash_oper@2@@std@@YA?AV?$reverse_iterator@PEB_W@0@V10@V10@U_Is_slash_oper@0@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_First$ = 16
_Last$ = 24
_Pred$dead$ = 32
??$find_if_not@V?$reverse_iterator@PEB_W@std@@U_Is_slash_oper@2@@std@@YA?AV?$reverse_iterator@PEB_W@0@V10@V10@U_Is_slash_oper@0@@Z PROC ; std::find_if_not<std::reverse_iterator<wchar_t const *>,std::_Is_slash_oper>, COMDAT

; 365  : _NODISCARD _CONSTEXPR20 _InIt find_if_not(_InIt _First, const _InIt _Last, _Pr _Pred) {

	mov	r9, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 1681 :     return _Left._Get_current() != _Right._Get_current();

	cmp	rdx, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 370  :     for (; _UFirst != _ULast; ++_UFirst) {

	je	SHORT $LN29@find_if_no
	npad	8
$LL12@find_if_no:

; 371  :         if (!_Pred(*_UFirst)) {

	movzx	ecx, WORD PTR [rdx-2]
	lea	rax, QWORD PTR [rdx-2]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 384  :         return _Ch == L'\\' || _Ch == L'/';

	cmp	cx, 92					; 0000005cH
	je	SHORT $LN26@find_if_no
	cmp	cx, 47					; 0000002fH
	jne	SHORT $LN28@find_if_no
$LN26@find_if_no:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 1544 :         --current;

	mov	rdx, rax

; 1681 :     return _Left._Get_current() != _Right._Get_current();

	cmp	rax, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 370  :     for (; _UFirst != _ULast; ++_UFirst) {

	jne	SHORT $LL12@find_if_no

; 372  :             break;
; 373  :         }
; 374  :     }
; 375  : 
; 376  :     _Seek_wrapped(_First, _UFirst);
; 377  :     return _First;

	mov	QWORD PTR [r9], rax

; 378  : }

	mov	rax, r9
	ret	0
$LN28@find_if_no:

; 372  :             break;
; 373  :         }
; 374  :     }
; 375  : 
; 376  :     _Seek_wrapped(_First, _UFirst);
; 377  :     return _First;

	mov	QWORD PTR [r9], rdx

; 378  : }

	mov	rax, r9
	ret	0
$LN29@find_if_no:

; 372  :             break;
; 373  :         }
; 374  :     }
; 375  : 
; 376  :     _Seek_wrapped(_First, _UFirst);
; 377  :     return _First;

	mov	QWORD PTR [rcx], rdx

; 378  : }

	mov	rax, r9
	ret	0
??$find_if_not@V?$reverse_iterator@PEB_W@std@@U_Is_slash_oper@2@@std@@YA?AV?$reverse_iterator@PEB_W@0@V10@V10@U_Is_slash_oper@0@@Z ENDP ; std::find_if_not<std::reverse_iterator<wchar_t const *>,std::_Is_slash_oper>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$?GPEB_WPEB_W@std@@YA_JAEBV?$reverse_iterator@PEB_W@0@0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$?GPEB_WPEB_W@std@@YA_JAEBV?$reverse_iterator@PEB_W@0@0@Z PROC ; std::operator-<wchar_t const *,wchar_t const *>, COMDAT

; 1758 :     return _Right._Get_current() - _Left._Get_current();

	mov	rax, QWORD PTR [rdx]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 1

; 1759 : }

	ret	0
??$?GPEB_WPEB_W@std@@YA_JAEBV?$reverse_iterator@PEB_W@0@0@Z ENDP ; std::operator-<wchar_t const *,wchar_t const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ??$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV?$allocator@D@2@@Z
_TEXT	SEGMENT
$T1 = 48
__$ReturnUdt$GSCopy$ = 56
this$ = 96
__$ReturnUdt$ = 104
_Al$dead$ = 112
??$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV?$allocator@D@2@@Z PROC ; std::filesystem::path::string<char,std::char_traits<char>,std::allocator<char>,0>, COMDAT

; 928  :         _NODISCARD basic_string<_EcharT, _Traits, _Alloc> string(const _Alloc& _Al = _Alloc()) const {

$LN61:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 64					; 00000040H
	mov	rbx, rdx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rdx
	xor	edi, edi
	mov	DWORD PTR $T1[rsp], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rsi, rcx

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rcx+24], 8
	jb	SHORT $LN8@string

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rsi, QWORD PTR [rcx]
$LN8@string:

; 4041 :         return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize};

	mov	rbp, QWORD PTR [rcx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 152  :             return _Convert_wide_to_narrow<_Traits>(__std_fs_code_page(), _Input, _Al);

	call	__std_fs_code_page
	mov	r14d, eax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rbx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], rdi

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono

; 80   :     return _Output;

	mov	DWORD PTR $T1[rsp], 4
	test	rbp, rbp

; 54   :     }
; 55   : 
; 56   :     return _Result._Len;
; 57   : }
; 58   : 
; 59   : template <class _Traits, class _Alloc>
; 60   : _NODISCARD basic_string<typename _Traits::char_type, _Traits, _Alloc> _Convert_wide_to_narrow(
; 61   :     const __std_code_page _Code_page, const wstring_view _Input, const _Alloc& _Al) {
; 62   :     basic_string<typename _Traits::char_type, _Traits, _Alloc> _Output(_Al);
; 63   : 
; 64   :     if (!_Input.empty()) {

	je	SHORT $LN51@string

; 65   :         if (_Input.size() > static_cast<size_t>(INT_MAX)) {

	cmp	rbp, 2147483647				; 7fffffffH
	ja	SHORT $LN57@string

; 67   :         }
; 68   : 
; 69   :         const int _Len = _Check_convert_result(

	mov	DWORD PTR [rsp+32], edi
	xor	r9d, r9d
	mov	r8d, ebp
	mov	rdx, rsi
	mov	ecx, eax
	call	__std_fs_convert_wide_to_narrow
	mov	rdi, rax
	shr	rax, 32					; 00000020H
	test	eax, eax

; 52   :     if (_Result._Err != __std_win_error::_Success) {

	jne	SHORT $LN58@string

; 72   :         _Output.resize(static_cast<size_t>(_Len));

	movsxd	rdx, edi
	mov	rcx, rbx
	call	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	r9, rbx

; 2227 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rbx+24], 16
	jb	SHORT $LN46@string

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r9, QWORD PTR [rbx]
$LN46@string:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono

; 76   :         (void) _Check_convert_result(__std_fs_convert_wide_to_narrow(

	mov	DWORD PTR [rsp+32], edi
	mov	r8d, ebp
	mov	rdx, rsi
	mov	ecx, r14d
	call	__std_fs_convert_wide_to_narrow
	mov	rcx, rax
	shr	rax, 32					; 00000020H
	test	eax, eax

; 52   :     if (_Result._Err != __std_win_error::_Success) {

	jne	SHORT $LN59@string
$LN51@string:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 930  :             return _Convert_wide_to<_Traits>(_Text, _Al);

	mov	rax, rbx

; 931  :         }

	mov	rbx, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+112]
	add	rsp, 64					; 00000040H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN59@string:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono

; 53   :         _Throw_system_error_from_std_win_error(_Result._Err);

	shr	rcx, 32					; 00000020H
	call	?_Throw_system_error_from_std_win_error@std@@YAXW4__std_win_error@@@Z ; std::_Throw_system_error_from_std_win_error
	int	3
$LN57@string:

; 66   :             _Throw_system_error(errc::invalid_argument);

	call	?_Throw_system_error@std@@YAXW4errc@1@@Z ; std::_Throw_system_error
	int	3
$LN58@string:

; 53   :         _Throw_system_error_from_std_win_error(_Result._Err);

	shr	rdi, 32					; 00000020H
	mov	ecx, edi
	call	?_Throw_system_error_from_std_win_error@std@@YAXW4__std_win_error@@@Z ; std::_Throw_system_error_from_std_win_error
	int	3
$LN55@string:
??$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV?$allocator@D@2@@Z ENDP ; std::filesystem::path::string<char,std::char_traits<char>,std::allocator<char>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
__$ReturnUdt$GSCopy$ = 56
this$ = 96
__$ReturnUdt$ = 104
_Al$dead$ = 112
?dtor$2@?0???$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV?$allocator@D@2@@Z@4HA PROC ; `std::filesystem::path::string<char,std::char_traits<char>,std::allocator<char>,0>'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN23@dtor$2
	and	DWORD PTR $T1[rbp], -5
	mov	rcx, QWORD PTR __$ReturnUdt$GSCopy$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN23@dtor$2:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0???$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV?$allocator@D@2@@Z@4HA ENDP ; `std::filesystem::path::string<char,std::char_traits<char>,std::allocator<char>,0>'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ??$?0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@2@W4format@012@@Z
_TEXT	SEGMENT
this$GSCopy$ = 32
this$ = 80
_Source$ = 88
__formal$dead$ = 96
??$?0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@2@W4format@012@@Z PROC ; std::filesystem::path::path<std::basic_string_view<wchar_t,std::char_traits<wchar_t> >,0>, COMDAT

; 649  :         path(const _Src& _Source, format = auto_format) : _Text(_Convert_Source_to_wide(_Source)) {

$LN75:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 1209 :         : _Mydata(_Cts), _Mysize(_Count) {

	mov	rbx, QWORD PTR [rdx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 649  :         path(const _Src& _Source, format = auto_format) : _Text(_Convert_Source_to_wide(_Source)) {

	xor	r15d, r15d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 1209 :         : _Mydata(_Cts), _Mysize(_Count) {

	mov	r14, QWORD PTR [rdx]
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	rbp, 9223372036854775806		; 7ffffffffffffffeH
	mov	QWORD PTR [rcx+16], r15
	mov	QWORD PTR [rcx+24], r15
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 649  :         path(const _Src& _Source, format = auto_format) : _Text(_Convert_Source_to_wide(_Source)) {

	mov	rsi, rcx
	mov	QWORD PTR this$GSCopy$[rsp], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	cmp	rbx, rbp

; 2620 :         if (_Count > max_size()) {

	ja	$LN73@path

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR [rcx+24], 7
	cmp	rbx, 8
	jae	SHORT $LN30@path

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR [rcx+16], rbx

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14
	add	rbx, rbx
	mov	r8, rbx
	call	memcpy

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	WORD PTR [rbx+rsi], r15w

; 2638 :             } else { // _Strat == _Construct_strategy::_From_string
; 2639 : #ifdef _INSERT_STRING_ANNOTATION
; 2640 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 2641 : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 2642 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 2643 : #endif // !_INSERT_STRING_ANNOTATION
; 2644 :             }
; 2645 : 
; 2646 :             _Proxy._Release();
; 2647 :             return;

	jmp	SHORT $LN28@path
$LN30@path:

; 4727 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	rax, rbx
	mov	QWORD PTR [rsp+88], rdi
	or	rax, 7

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	cmp	rax, rbp

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN40@path
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	mov	ecx, 10
	mov	rbp, rax
	cmp	rax, rcx
	cmovb	rbp, rcx
$LN40@path:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	rdx, QWORD PTR [rbp+1]
	call	?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z ; std::allocator<wchar_t>::allocate

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR [rsi+16], rbx

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14
	add	rbx, rbx

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR [rsi], rax

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rbx

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR [rsi+24], rbp

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rcx, rax

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdi, rax

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy

; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	mov	WORD PTR [rbx+rdi], r15w
	mov	rdi, QWORD PTR [rsp+88]
$LN28@path:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 651  :         }

	mov	rbx, QWORD PTR [rsp+96]
	mov	rax, rsi
	mov	rbp, QWORD PTR [rsp+104]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	rsi
	ret	0
$LN73@path:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN71@path:
??$?0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@2@W4format@012@@Z ENDP ; std::filesystem::path::path<std::basic_string_view<wchar_t,std::char_traits<wchar_t> >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEAPEB_W@std@@YAAEAPEB_WAEAPEB_W@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEB_W@std@@YAAEAPEB_WAEAPEB_W@Z PROC	; std::forward<wchar_t const * &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEAPEB_W@std@@YAAEAPEB_WAEAPEB_W@Z ENDP	; std::forward<wchar_t const * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ??$?_0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@path@filesystem@std@@QEAAAEAV012@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@2@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 80
_Source$ = 88
??$?_0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@path@filesystem@std@@QEAAAEAV012@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@2@@Z PROC ; std::filesystem::path::operator/=<std::basic_string_view<wchar_t,std::char_traits<wchar_t> >,0>, COMDAT

; 773  :         path& operator/=(const _Src& _Source) {

$LN12:
	push	rbx
	sub	rsp, 64					; 00000040H
	mov	rbx, rcx

; 774  :             return operator/=(path{_Source});

	lea	rcx, QWORD PTR $T1[rsp]
	call	??$?0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@2@W4format@012@@Z ; std::filesystem::path::path<std::basic_string_view<wchar_t,std::char_traits<wchar_t> >,0>
	npad	1
	mov	rdx, rax
	mov	rcx, rbx
	call	??_0path@filesystem@std@@QEAAAEAV012@AEBV012@@Z ; std::filesystem::path::operator/=
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T1[rsp]
	call	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 774  :             return operator/=(path{_Source});

	mov	rax, rbx

; 775  :         }

	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
??$?_0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@path@filesystem@std@@QEAAAEAV012@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@2@@Z ENDP ; std::filesystem::path::operator/=<std::basic_string_view<wchar_t,std::char_traits<wchar_t> >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 80
_Source$ = 88
?dtor$0@?0???$?_0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@path@filesystem@std@@QEAAAEAV012@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@2@@Z@4HA PROC ; `std::filesystem::path::operator/=<std::basic_string_view<wchar_t,std::char_traits<wchar_t> >,0>'::`1'::dtor$0
	lea	rcx, QWORD PTR $T1[rdx]
	jmp	??1path@filesystem@std@@QEAA@XZ		; std::filesystem::path::~path
?dtor$0@?0???$?_0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@path@filesystem@std@@QEAAAEAV012@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@2@@Z@4HA ENDP ; `std::filesystem::path::operator/=<std::basic_string_view<wchar_t,std::char_traits<wchar_t> >,0>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ??$_Convert_wide_to_narrow_replace_chars@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
$T1 = 48
__$ReturnUdt$ = 96
_Code_page$ = 104
_Input$ = 112
_Al$dead$ = 120
??$_Convert_wide_to_narrow_replace_chars@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z PROC ; std::filesystem::_Convert_wide_to_narrow_replace_chars<std::char_traits<char>,std::allocator<char> >, COMDAT

; 65   :         const __std_code_page _Code_page, const wstring_view _Input, const _Alloc& _Al) {

$LN42:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 64					; 00000040H
	mov	r14d, edx
	mov	rbx, rcx
	xor	eax, eax
	mov	DWORD PTR $T1[rsp], eax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 84   :         return _Output;

	mov	DWORD PTR $T1[rsp], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 1296 :         return _Mysize == 0;

	mov	rsi, QWORD PTR [r8+8]
	test	rsi, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 68   :         if (!_Input.empty()) {

	je	SHORT $LN34@Convert_wi

; 69   :             if (_Input.size() > static_cast<size_t>(INT_MAX)) {

	cmp	rsi, 2147483647				; 7fffffffH
	ja	SHORT $LN38@Convert_wi

; 71   :             }
; 72   : 
; 73   :             const int _Len = _Check_convert_result(__std_fs_convert_wide_to_narrow_replace_chars(

	mov	rbp, QWORD PTR [r8]
	mov	DWORD PTR [rsp+32], eax
	xor	r9d, r9d
	mov	r8d, esi
	mov	rdx, rbp
	mov	ecx, r14d
	call	__std_fs_convert_wide_to_narrow_replace_chars
	mov	rdi, rax
	shr	rax, 32					; 00000020H
	test	eax, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono

; 52   :     if (_Result._Err != __std_win_error::_Success) {

	jne	SHORT $LN39@Convert_wi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 76   :             _Output.resize(static_cast<size_t>(_Len));

	movsxd	rdx, edi
	mov	rcx, rbx
	call	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	r9, rbx

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rbx+24], 16

; 2227 :         if (_Large_string_engaged()) {

	jb	SHORT $LN29@Convert_wi

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r9, QWORD PTR [rbx]
$LN29@Convert_wi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 80   :             (void) _Check_convert_result(__std_fs_convert_wide_to_narrow_replace_chars(

	mov	DWORD PTR [rsp+32], edi
	mov	r8d, esi
	mov	rdx, rbp
	mov	ecx, r14d
	call	__std_fs_convert_wide_to_narrow_replace_chars
	mov	rcx, rax
	shr	rax, 32					; 00000020H
	test	eax, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono

; 52   :     if (_Result._Err != __std_win_error::_Success) {

	jne	SHORT $LN40@Convert_wi
$LN34@Convert_wi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 84   :         return _Output;

	mov	rax, rbx

; 85   :     }

	mov	rbx, QWORD PTR [rsp+104]
	mov	rbp, QWORD PTR [rsp+112]
	add	rsp, 64					; 00000040H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN40@Convert_wi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono

; 53   :         _Throw_system_error_from_std_win_error(_Result._Err);

	shr	rcx, 32					; 00000020H
	call	?_Throw_system_error_from_std_win_error@std@@YAXW4__std_win_error@@@Z ; std::_Throw_system_error_from_std_win_error
	int	3
$LN38@Convert_wi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 70   :                 _Throw_system_error(errc::invalid_argument);

	call	?_Throw_system_error@std@@YAXW4errc@1@@Z ; std::_Throw_system_error
	int	3
$LN39@Convert_wi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono

; 53   :         _Throw_system_error_from_std_win_error(_Result._Err);

	shr	rdi, 32					; 00000020H
	mov	ecx, edi
	call	?_Throw_system_error_from_std_win_error@std@@YAXW4__std_win_error@@@Z ; std::_Throw_system_error_from_std_win_error
	int	3
$LN36@Convert_wi:
??$_Convert_wide_to_narrow_replace_chars@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z ENDP ; std::filesystem::_Convert_wide_to_narrow_replace_chars<std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
__$ReturnUdt$ = 96
_Code_page$ = 104
_Input$ = 112
_Al$dead$ = 120
?dtor$0@?0???$_Convert_wide_to_narrow_replace_chars@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z@4HA PROC ; `std::filesystem::_Convert_wide_to_narrow_replace_chars<std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN6@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN6@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$_Convert_wide_to_narrow_replace_chars@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z@4HA ENDP ; `std::filesystem::_Convert_wide_to_narrow_replace_chars<std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??$?YV?$basic_string_view@DU?$char_traits@D@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV?$basic_string_view@DU?$char_traits@D@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??$?YV?$basic_string_view@DU?$char_traits@D@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV?$basic_string_view@DU?$char_traits@D@std@@@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=<std::basic_string_view<char,std::char_traits<char> >,0>, COMDAT

; 3255 :         return append(_As_view.data(), _Convert_size<size_type>(_As_view.size()));

	mov	r8, QWORD PTR [rdx+8]
	mov	rdx, QWORD PTR [rdx]
	jmp	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
??$?YV?$basic_string_view@DU?$char_traits@D@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV?$basic_string_view@DU?$char_traits@D@std@@@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=<std::basic_string_view<char,std::char_traits<char> >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$_Bitmask_includes_any@W4__std_fs_file_attr@@@std@@YA_NW4__std_fs_file_attr@@0@Z
_TEXT	SEGMENT
_Left$ = 8
_Elements$ = 16
??$_Bitmask_includes_any@W4__std_fs_file_attr@@@std@@YA_NW4__std_fs_file_attr@@0@Z PROC ; std::_Bitmask_includes_any<enum __std_fs_file_attr>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 82   : _BITMASK_OPS(_EMPTY_ARGUMENT, __std_fs_file_attr)

	test	ecx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2324 :     return (_Left & _Elements) != _Bitmask{};

	setne	al

; 2325 : }

	ret	0
??$_Bitmask_includes_any@W4__std_fs_file_attr@@@std@@YA_NW4__std_fs_file_attr@@0@Z ENDP ; std::_Bitmask_includes_any<enum __std_fs_file_attr>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$_Bitmask_includes_all@W4__std_fs_stats_flags@@@std@@YA_NW4__std_fs_stats_flags@@0@Z
_TEXT	SEGMENT
_Left$ = 8
_Elements$ = 16
??$_Bitmask_includes_all@W4__std_fs_stats_flags@@@std@@YA_NW4__std_fs_stats_flags@@0@Z PROC ; std::_Bitmask_includes_all<enum __std_fs_stats_flags>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xfilesystem_abi.h

; 127  : _BITMASK_OPS(_EMPTY_ARGUMENT, __std_fs_stats_flags)

	and	ecx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2329 :     return (_Left & _Elements) == _Elements;

	cmp	ecx, edx
	sete	al

; 2330 : }

	ret	0
??$_Bitmask_includes_all@W4__std_fs_stats_flags@@@std@@YA_NW4__std_fs_stats_flags@@0@Z ENDP ; std::_Bitmask_includes_all<enum __std_fs_stats_flags>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$_Bitmask_includes_any@W4directory_options@filesystem@std@@@std@@YA_NW4directory_options@filesystem@0@0@Z
_TEXT	SEGMENT
_Left$ = 8
_Elements$ = 16
??$_Bitmask_includes_any@W4directory_options@filesystem@std@@@std@@YA_NW4directory_options@filesystem@0@0@Z PROC ; std::_Bitmask_includes_any<enum std::filesystem::directory_options>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2487 :     _BITMASK_OPS(_EXPORT_STD, directory_options)

	test	ecx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2324 :     return (_Left & _Elements) != _Bitmask{};

	setne	al

; 2325 : }

	ret	0
??$_Bitmask_includes_any@W4directory_options@filesystem@std@@@std@@YA_NW4directory_options@filesystem@0@0@Z ENDP ; std::_Bitmask_includes_any<enum std::filesystem::directory_options>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAU_Find_file_handle@filesystem@std@@@std@@YA$$QEAU_Find_file_handle@filesystem@0@AEAU120@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAU_Find_file_handle@filesystem@std@@@std@@YA$$QEAU_Find_file_handle@filesystem@0@AEAU120@@Z PROC ; std::move<std::filesystem::_Find_file_handle &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAU_Find_file_handle@filesystem@std@@@std@@YA$$QEAU_Find_file_handle@filesystem@0@AEAU120@@Z ENDP ; std::move<std::filesystem::_Find_file_handle &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAVpath@filesystem@std@@@std@@YA$$QEAVpath@filesystem@0@AEAV120@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAVpath@filesystem@std@@@std@@YA$$QEAVpath@filesystem@0@AEAV120@@Z PROC ; std::move<std::filesystem::path &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAVpath@filesystem@std@@@std@@YA$$QEAVpath@filesystem@0@AEAV120@@Z ENDP ; std::move<std::filesystem::path &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??$?DU_Recursive_dir_enum_impl@filesystem@std@@$0A@@?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEBAAEAU_Recursive_dir_enum_impl@filesystem@1@XZ
_TEXT	SEGMENT
this$ = 8
??$?DU_Recursive_dir_enum_impl@filesystem@std@@$0A@@?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEBAAEAU_Recursive_dir_enum_impl@filesystem@1@XZ PROC ; std::shared_ptr<std::filesystem::_Recursive_dir_enum_impl>::operator*<std::filesystem::_Recursive_dir_enum_impl,0>, COMDAT

; 1765 :         return *get();

	mov	rax, QWORD PTR [rcx]

; 1766 :     }

	ret	0
??$?DU_Recursive_dir_enum_impl@filesystem@std@@$0A@@?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEBAAEAU_Recursive_dir_enum_impl@filesystem@1@XZ ENDP ; std::shared_ptr<std::filesystem::_Recursive_dir_enum_impl>::operator*<std::filesystem::_Recursive_dir_enum_impl,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAU_Creator@_Dir_enum_impl@filesystem@std@@@std@@YA$$QEAU_Creator@_Dir_enum_impl@filesystem@0@AEAU1230@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAU_Creator@_Dir_enum_impl@filesystem@std@@@std@@YA$$QEAU_Creator@_Dir_enum_impl@filesystem@0@AEAU1230@@Z PROC ; std::move<std::filesystem::_Dir_enum_impl::_Creator &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAU_Creator@_Dir_enum_impl@filesystem@std@@@std@@YA$$QEAU_Creator@_Dir_enum_impl@filesystem@0@AEAU1230@@Z ENDP ; std::move<std::filesystem::_Dir_enum_impl::_Creator &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ??$_Initialize_dir_enum@U_Recursive_dir_enum_impl@filesystem@std@@@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@2@AEBVpath@12@W4directory_options@12@@Z
_TEXT	SEGMENT
$T4 = 32
$T3 = 32
_Create_data$ = 48
__$ArrayPad$ = 688
_Impl$ = 752
_Path$ = 760
_Options$dead$ = 768
??$_Initialize_dir_enum@U_Recursive_dir_enum_impl@filesystem@std@@@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@2@AEBVpath@12@W4directory_options@12@@Z PROC ; std::filesystem::_Dir_enum_impl::_Initialize_dir_enum<std::filesystem::_Recursive_dir_enum_impl>, COMDAT

; 2579 :             shared_ptr<_Dir_enum_kind>& _Impl, const path& _Path, const directory_options _Options = {}) {

$LN115:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-448]
	sub	rsp, 704				; 000002c0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	r14, rcx
	xor	r15d, r15d

; 2553 :             _Creator(const path& _Path_arg, const directory_options _Options) : _Path(_Path_arg) {

	lea	rcx, QWORD PTR _Create_data$[rsp]
	call	??0path@filesystem@std@@QEAA@AEBV012@@Z	; std::filesystem::path::path
	npad	1

; 587  :         __std_fs_dir_handle _Handle = __std_fs_dir_handle::_Invalid;

	mov	rsi, -1
	mov	QWORD PTR _Create_data$[rsp+32], rsi

; 2554 :                 const auto _Error = _Open_dir(_Path, _Options, _Dir, _Find_data);

	lea	r9, QWORD PTR _Create_data$[rsp+40]
	lea	r8, QWORD PTR _Create_data$[rsp+32]
	xor	edx, edx
	lea	rcx, QWORD PTR _Create_data$[rsp]
	call	?_Open_dir@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAVpath@23@W4directory_options@23@AEAU_Find_file_handle@23@AEAU__std_fs_find_data@@@Z ; std::filesystem::_Dir_enum_impl::_Open_dir
	mov	edx, eax

; 2555 :                 if (_Error == __std_win_error::_Success) {

	mov	DWORD PTR _Create_data$[rbp+380], r15d
	test	eax, eax
	jne	SHORT $LN7@Initialize

; 2556 :                     _Status = {true, __std_win_error::_Success};

	mov	cl, 1
	jmp	SHORT $LN112@Initialize
$LN7@Initialize:

; 2557 :                 } else if (_Error == __std_win_error::_No_more_files) {

	xor	cl, cl
	cmp	edx, 18
	je	SHORT $LN112@Initialize

; 2558 :                     _Status = {false, __std_win_error::_Success};
; 2559 :                 } else {
; 2560 :                     _Status = {false, _Error};

	mov	DWORD PTR _Create_data$[rbp+380], edx
$LN112@Initialize:

; 2561 :                 }
; 2562 :             }

	movzx	eax, WORD PTR $T3[rsp+1]
	mov	WORD PTR _Create_data$[rbp+377], ax
	movzx	eax, BYTE PTR $T3[rsp+3]
	mov	BYTE PTR _Create_data$[rbp+376], cl
	mov	BYTE PTR _Create_data$[rbp+379], al

; 2580 :             _Creator _Create_data(_Path, _Options);
; 2581 :             if (_Create_data._Status._Should_create_impl) {

	test	cl, cl
	je	$LN111@Initialize
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 2779 :     const auto _Rx = new _Ref_count_obj2<_Ty>(_STD forward<_Types>(_Args)...);

	mov	ecx, 120				; 00000078H
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax
	mov	QWORD PTR $T4[rsp], rax
	xorps	xmm0, xmm0

; 2096 :     explicit _Ref_count_obj2(_Types&&... _Args) : _Ref_count_base() {

	movups	XMMWORD PTR [rax], xmm0

; 1137 :     _Atomic_counter_t _Uses  = 1;

	mov	DWORD PTR [rax+8], 1

; 1138 :     _Atomic_counter_t _Weaks = 1;

	mov	DWORD PTR [rax+12], 1

; 2096 :     explicit _Ref_count_obj2(_Types&&... _Args) : _Ref_count_base() {

	lea	rax, OFFSET FLAT:??_7?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@6B@
	mov	QWORD PTR [rdi], rax

; 2097 : #if _HAS_CXX20
; 2098 :         if constexpr (sizeof...(_Types) == 1 && (is_same_v<_For_overwrite_tag, remove_cvref_t<_Types>> && ...)) {
; 2099 :             _STD _Default_construct_in_place(_Storage._Value);
; 2100 :             ((void) _Args, ...);
; 2101 :         } else
; 2102 : #endif // _HAS_CXX20
; 2103 :         {
; 2104 :             _STD _Construct_in_place(_Storage._Value, _STD forward<_Types>(_Args)...);

	lea	rbx, QWORD PTR [rdi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2829 :             : _Dir_enum_impl(_STD move(_Create_data)), _Options(_Options_arg) {}

	lea	rdx, QWORD PTR _Create_data$[rsp]
	mov	rcx, rbx
	call	??0_Dir_enum_impl@filesystem@std@@QEAA@$$QEAU_Creator@012@W4directory_options@12@@Z ; std::filesystem::_Dir_enum_impl::_Dir_enum_impl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rbx+72], r15
	mov	QWORD PTR [rbx+80], r15
	mov	QWORD PTR [rbx+88], r15
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2829 :             : _Dir_enum_impl(_STD move(_Create_data)), _Options(_Options_arg) {}

	mov	DWORD PTR [rbx+96], r15d

; 2586 : 
; 2587 :         directory_entry _Entry;
; 2588 :         _Find_file_handle _Dir;
; 2589 :     };
; 2590 : 
; 2591 :     _EXPORT_STD class directory_iterator;
; 2592 :     _EXPORT_STD class recursive_directory_iterator;
; 2593 : 
; 2594 :     struct _Directory_entry_proxy {
; 2595 :         _NODISCARD directory_entry operator*() && noexcept {
; 2596 :             return _STD move(_Entry);
; 2597 :         }
; 2598 : 
; 2599 :     private:
; 2600 :         friend directory_iterator;
; 2601 :         friend recursive_directory_iterator;
; 2602 : 
; 2603 :         explicit _Directory_entry_proxy(const directory_entry& _Entry_arg) : _Entry(_Entry_arg) {}
; 2604 : 
; 2605 :         directory_entry _Entry;
; 2606 :     };
; 2607 : 
; 2608 :     _EXPORT_STD class directory_iterator {
; 2609 :     public:
; 2610 :         using iterator_category = input_iterator_tag;
; 2611 :         using value_type        = directory_entry;
; 2612 :         using difference_type   = ptrdiff_t;
; 2613 :         using pointer           = const directory_entry*;
; 2614 :         using reference         = const directory_entry&;
; 2615 : 
; 2616 :         // [fs.dir.itr.members], member functions
; 2617 :         directory_iterator() noexcept = default;
; 2618 :         explicit directory_iterator(const path& _Path) {
; 2619 :             const auto _Error = _Dir_enum_impl::_Initialize_dir_enum(_Impl, _Path);
; 2620 :             if (_Error != __std_win_error::_Success) {
; 2621 :                 _Throw_fs_error("directory_iterator::directory_iterator", _Error, _Path);
; 2622 :             }
; 2623 :         }
; 2624 : 
; 2625 :         directory_iterator(const path& _Path, const directory_options _Options) {
; 2626 :             const auto _Error = _Dir_enum_impl::_Initialize_dir_enum(_Impl, _Path, _Options);
; 2627 :             if (_Error != __std_win_error::_Success) {
; 2628 :                 _Throw_fs_error("directory_iterator::directory_iterator", _Error, _Path);
; 2629 :             }
; 2630 :         }
; 2631 : 
; 2632 :         directory_iterator(const path& _Path, error_code& _Ec) {
; 2633 :             _Ec = _Make_ec(_Dir_enum_impl::_Initialize_dir_enum(_Impl, _Path));
; 2634 :         }
; 2635 : 
; 2636 :         directory_iterator(const path& _Path, const directory_options _Options, error_code& _Ec) {
; 2637 :             _Ec = _Make_ec(_Dir_enum_impl::_Initialize_dir_enum(_Impl, _Path, _Options));
; 2638 :         }
; 2639 : 
; 2640 :         directory_iterator(const directory_iterator&) noexcept = default; // strengthened
; 2641 :         directory_iterator(directory_iterator&&) noexcept      = default;
; 2642 :         ~directory_iterator() noexcept                         = default;
; 2643 : 
; 2644 :         directory_iterator& operator=(const directory_iterator&) noexcept = default; // strengthened
; 2645 :         directory_iterator& operator=(directory_iterator&&) noexcept      = default;
; 2646 : 
; 2647 :         _NODISCARD const directory_entry& operator*() const noexcept /* strengthened */ {
; 2648 :             return _Impl->_Entry;
; 2649 :         }
; 2650 : 
; 2651 :         _NODISCARD const directory_entry* operator->() const noexcept /* strengthened */ {
; 2652 :             return &**this;
; 2653 :         }
; 2654 : 
; 2655 :         directory_iterator& operator++() {
; 2656 :             const auto _Error = _Dir_enum_impl::_Advance_and_reset_if_no_more_files(_Impl);
; 2657 :             if (_Error != __std_win_error::_Success) {
; 2658 :                 _Throw_fs_error("directory_iterator::operator++", _Error);
; 2659 :             }
; 2660 : 
; 2661 :             return *this;
; 2662 :         }
; 2663 : 
; 2664 :         directory_iterator& increment(error_code& _Ec) {
; 2665 :             _Ec = _Make_ec(_Dir_enum_impl::_Advance_and_reset_if_no_more_files(_Impl));
; 2666 :             return *this;
; 2667 :         }
; 2668 : 
; 2669 :         // other members as required by [input.iterators]:
; 2670 :         _NODISCARD bool operator==(const directory_iterator& _Rhs) const noexcept /* strengthened */ {
; 2671 :             return _Impl == _Rhs._Impl;
; 2672 :         }
; 2673 : 
; 2674 : #if !_HAS_CXX20
; 2675 :         _NODISCARD bool operator!=(const directory_iterator& _Rhs) const noexcept /* strengthened */ {
; 2676 :             return _Impl != _Rhs._Impl;
; 2677 :         }
; 2678 : #endif // !_HAS_CXX20
; 2679 : 
; 2680 : #ifdef __cpp_lib_concepts
; 2681 :         _NODISCARD bool operator==(default_sentinel_t) const noexcept {
; 2682 :             return !_Impl;
; 2683 :         }
; 2684 : #endif // __cpp_lib_concepts
; 2685 : 
; 2686 :         _Directory_entry_proxy operator++(int) {
; 2687 :             _Directory_entry_proxy _Proxy(**this);
; 2688 :             ++*this;
; 2689 :             return _Proxy;
; 2690 :         }
; 2691 : 
; 2692 :         _NODISCARD bool _At_end() const noexcept {
; 2693 :             return !_Impl;
; 2694 :         }
; 2695 : 
; 2696 :     private:
; 2697 :         shared_ptr<_Dir_enum_impl> _Impl;
; 2698 :     };
; 2699 : 
; 2700 :     _EXPORT_STD _NODISCARD inline directory_iterator begin(directory_iterator _Iter) noexcept {
; 2701 :         return _Iter;
; 2702 :     }
; 2703 : 
; 2704 :     _EXPORT_STD _NODISCARD inline directory_iterator end(directory_iterator) noexcept {
; 2705 :         return {};
; 2706 :     }
; 2707 : 
; 2708 :     struct _Should_recurse_result {
; 2709 :         bool _Should_recurse;
; 2710 :         __std_win_error _Error;
; 2711 :     };
; 2712 : 
; 2713 :     struct _Recursive_dir_enum_impl : _Dir_enum_impl {
; 2714 :         vector<_Find_file_handle> _Stack;
; 2715 :         directory_options _Options = {};
; 2716 :         bool _Recursion_pending    = true;

	mov	BYTE PTR [rbx+100], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [r14], rbx

; 100  :     _Left    = _STD move(_Right);

	mov	rbx, QWORD PTR [r14+8]

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [r14+8], rdi
	test	rbx, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 1402 :         if (_Rep) {

	je	SHORT $LN111@Initialize

; 1177 :         if (_MT_DECR(_Uses) == 0) {

	mov	eax, esi
	lock xadd DWORD PTR [rbx+8], eax
	cmp	eax, 1
	jne	SHORT $LN111@Initialize

; 1178 :             _Destroy();

	mov	rax, QWORD PTR [rbx]
	mov	rcx, rbx
	call	QWORD PTR [rax]

; 1184 :         if (_MT_DECR(_Weaks) == 0) {

	lock xadd DWORD PTR [rbx+12], esi
	cmp	esi, 1
	jne	SHORT $LN111@Initialize

; 1185 :             _Delete_this();

	mov	rax, QWORD PTR [rbx]
	mov	rcx, rbx
	call	QWORD PTR [rax+8]
$LN111@Initialize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2584 :             return _Create_data._Status._Error;

	mov	ebx, DWORD PTR _Create_data$[rbp+380]

; 605  :             __std_fs_directory_iterator_close(_Handle);

	mov	rcx, QWORD PTR _Create_data$[rsp+32]
	call	__std_fs_directory_iterator_close
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR _Create_data$[rsp]
	call	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2584 :             return _Create_data._Status._Error;

	mov	eax, ebx

; 2585 :         }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+768]
	add	rsp, 704				; 000002c0H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
??$_Initialize_dir_enum@U_Recursive_dir_enum_impl@filesystem@std@@@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@2@AEBVpath@12@W4directory_options@12@@Z ENDP ; std::filesystem::_Dir_enum_impl::_Initialize_dir_enum<std::filesystem::_Recursive_dir_enum_impl>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 32
$T3 = 32
_Create_data$ = 48
__$ArrayPad$ = 688
_Impl$ = 752
_Path$ = 760
_Options$dead$ = 768
?dtor$2@?0???$_Initialize_dir_enum@U_Recursive_dir_enum_impl@filesystem@std@@@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@2@AEBVpath@12@W4directory_options@12@@Z@4HA PROC ; `std::filesystem::_Dir_enum_impl::_Initialize_dir_enum<std::filesystem::_Recursive_dir_enum_impl>'::`1'::dtor$2
	lea	rcx, QWORD PTR _Create_data$[rdx]
	jmp	??1path@filesystem@std@@QEAA@XZ		; std::filesystem::path::~path
?dtor$2@?0???$_Initialize_dir_enum@U_Recursive_dir_enum_impl@filesystem@std@@@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@2@AEBVpath@12@W4directory_options@12@@Z@4HA ENDP ; `std::filesystem::_Dir_enum_impl::_Initialize_dir_enum<std::filesystem::_Recursive_dir_enum_impl>'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 32
$T3 = 32
_Create_data$ = 48
__$ArrayPad$ = 688
_Impl$ = 752
_Path$ = 760
_Options$dead$ = 768
?dtor$3@?0???$_Initialize_dir_enum@U_Recursive_dir_enum_impl@filesystem@std@@@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@2@AEBVpath@12@W4directory_options@12@@Z@4HA PROC ; `std::filesystem::_Dir_enum_impl::_Initialize_dir_enum<std::filesystem::_Recursive_dir_enum_impl>'::`1'::dtor$3
	lea	rcx, QWORD PTR _Create_data$[rdx]
	add	rcx, 32					; 00000020H
	jmp	??1_Find_file_handle@filesystem@std@@QEAA@XZ ; std::filesystem::_Find_file_handle::~_Find_file_handle
?dtor$3@?0???$_Initialize_dir_enum@U_Recursive_dir_enum_impl@filesystem@std@@@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@2@AEBVpath@12@W4directory_options@12@@Z@4HA ENDP ; `std::filesystem::_Dir_enum_impl::_Initialize_dir_enum<std::filesystem::_Recursive_dir_enum_impl>'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 32
$T3 = 32
_Create_data$ = 48
__$ArrayPad$ = 688
_Impl$ = 752
_Path$ = 760
_Options$dead$ = 768
?dtor$0@?0???$_Initialize_dir_enum@U_Recursive_dir_enum_impl@filesystem@std@@@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@2@AEBVpath@12@W4directory_options@12@@Z@4HA PROC ; `std::filesystem::_Dir_enum_impl::_Initialize_dir_enum<std::filesystem::_Recursive_dir_enum_impl>'::`1'::dtor$0
	lea	rcx, QWORD PTR _Create_data$[rdx]
	jmp	??1_Creator@_Dir_enum_impl@filesystem@std@@QEAA@XZ
?dtor$0@?0???$_Initialize_dir_enum@U_Recursive_dir_enum_impl@filesystem@std@@@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@2@AEBVpath@12@W4directory_options@12@@Z@4HA ENDP ; `std::filesystem::_Dir_enum_impl::_Initialize_dir_enum<std::filesystem::_Recursive_dir_enum_impl>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 32
$T3 = 32
_Create_data$ = 48
__$ArrayPad$ = 688
_Impl$ = 752
_Path$ = 760
_Options$dead$ = 768
?dtor$4@?0???$_Initialize_dir_enum@U_Recursive_dir_enum_impl@filesystem@std@@@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@2@AEBVpath@12@W4directory_options@12@@Z@4HA PROC ; `std::filesystem::_Dir_enum_impl::_Initialize_dir_enum<std::filesystem::_Recursive_dir_enum_impl>'::`1'::dtor$4
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 120				; 00000078H
	mov	rcx, QWORD PTR $T4[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$4@?0???$_Initialize_dir_enum@U_Recursive_dir_enum_impl@filesystem@std@@@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@2@AEBVpath@12@W4directory_options@12@@Z@4HA ENDP ; `std::filesystem::_Dir_enum_impl::_Initialize_dir_enum<std::filesystem::_Recursive_dir_enum_impl>'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??$?CU_Recursive_dir_enum_impl@filesystem@std@@$0A@@?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEBAPEAU_Recursive_dir_enum_impl@filesystem@1@XZ
_TEXT	SEGMENT
this$ = 8
??$?CU_Recursive_dir_enum_impl@filesystem@std@@$0A@@?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEBAPEAU_Recursive_dir_enum_impl@filesystem@1@XZ PROC ; std::shared_ptr<std::filesystem::_Recursive_dir_enum_impl>::operator-><std::filesystem::_Recursive_dir_enum_impl,0>, COMDAT

; 1770 :         return get();

	mov	rax, QWORD PTR [rcx]

; 1771 :     }

	ret	0
??$?CU_Recursive_dir_enum_impl@filesystem@std@@$0A@@?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEBAPEAU_Recursive_dir_enum_impl@filesystem@1@XZ ENDP ; std::shared_ptr<std::filesystem::_Recursive_dir_enum_impl>::operator-><std::filesystem::_Recursive_dir_enum_impl,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??$?8U_Recursive_dir_enum_impl@filesystem@std@@U012@@std@@YA_NAEBV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@0@0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$?8U_Recursive_dir_enum_impl@filesystem@std@@U012@@std@@YA_NAEBV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@0@0@Z PROC ; std::operator==<std::filesystem::_Recursive_dir_enum_impl,std::filesystem::_Recursive_dir_enum_impl>, COMDAT

; 1880 :     return _Left.get() == _Right.get();

	mov	rax, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rax
	sete	al

; 1881 : }

	ret	0
??$?8U_Recursive_dir_enum_impl@filesystem@std@@U012@@std@@YA_NAEBV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@0@0@Z ENDP ; std::operator==<std::filesystem::_Recursive_dir_enum_impl,std::filesystem::_Recursive_dir_enum_impl>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@V10@V10@AEBW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_First$ = 16
_Last$ = 24
_Val$dead$ = 32
??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@V10@V10@AEBW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@Z PROC ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > >,enum AINBNodeDefMgr::NodeDef::CategoryEnum>, COMDAT

; 5836 :     for (; _First != _Last; ++_First) {

	cmp	rdx, r8
	je	SHORT $LN15@find

; 5837 :         if (*_First == _Val) {

	movzx	eax, BYTE PTR ?AINBCategory@PopupAddAINBNode@@3W4CategoryEnum@NodeDef@AINBNodeDefMgr@@A ; PopupAddAINBNode::AINBCategory
	npad	4
$LL6@find:
	cmp	BYTE PTR [rdx], al
	je	SHORT $LN15@find

; 5836 :     for (; _First != _Last; ++_First) {

	inc	rdx
	cmp	rdx, r8
	jne	SHORT $LL6@find
$LN15@find:

; 5847 :     _Adl_verify_range(_First, _Last);
; 5848 :     if constexpr (_Is_vb_iterator<_InIt> && is_same_v<_Ty, bool>) {
; 5849 :         return _Find_vbool(_First, _Last, _Val);
; 5850 :     } else {
; 5851 :         _Seek_wrapped(_First, _STD _Find_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val));
; 5852 :         return _First;
; 5853 :     }
; 5854 : }

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@V10@V10@AEBW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@Z ENDP ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > >,enum AINBNodeDefMgr::NodeDef::CategoryEnum>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > > &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;
; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();

	mov	rax, QWORD PTR [rcx]

; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YA?A_TAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YA?A_TAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > > const &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;
; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();

	mov	rax, QWORD PTR [rcx]

; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YA?A_TAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@W4format@012@@Z
_TEXT	SEGMENT
this$GSCopy$ = 48
$T2 = 48
__$ReturnUdt$ = 56
this$ = 96
_Source$ = 104
__formal$dead$ = 112
??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@W4format@012@@Z PROC ; std::filesystem::path::path<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,0>, COMDAT

; 649  :         path(const _Src& _Source, format = auto_format) : _Text(_Convert_Source_to_wide(_Source)) {

$LN67:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 64					; 00000040H
	mov	rsi, rdx
	mov	rbx, rcx
	mov	QWORD PTR this$GSCopy$[rsp], rcx
	xor	edi, edi
	mov	DWORD PTR $T2[rsp], edi
	mov	QWORD PTR __$ReturnUdt$[rsp], rcx

; 243  :         return basic_string_view<_EcharT>(_Source.data(), _Source.size()); // erase mismatching _Traits

	mov	rbp, QWORD PTR [rdx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rdx+24], 16
	jb	SHORT $LN13@path

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rsi, QWORD PTR [rdx]
$LN13@path:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 199  :             return _Convert_narrow_to_wide(__std_fs_code_page(), _Input);

	call	__std_fs_code_page
	mov	r14d, eax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rbx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], rdi

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 7

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	WORD PTR [rbx], di
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 58   :         return _Output;

	mov	DWORD PTR $T2[rsp], 4

; 44   :         if (!_Input.empty()) {

	test	rbp, rbp
	je	SHORT $LN56@path

; 45   :             if (_Input.size() > static_cast<size_t>(INT_MAX)) {

	cmp	rbp, 2147483647				; 7fffffffH
	ja	SHORT $LN63@path

; 47   :             }
; 48   : 
; 49   :             const int _Len = _Check_convert_result(__std_fs_convert_narrow_to_wide(

	mov	DWORD PTR [rsp+32], edi
	xor	r9d, r9d
	mov	r8d, ebp
	mov	rdx, rsi
	mov	ecx, eax
	call	__std_fs_convert_narrow_to_wide
	mov	rdi, rax
	shr	rax, 32					; 00000020H
	test	eax, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono

; 52   :     if (_Result._Err != __std_win_error::_Success) {

	jne	SHORT $LN64@path
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 52   :             _Output.resize(static_cast<size_t>(_Len));

	movsxd	rdx, edi
	mov	rcx, rbx
	call	?resize@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::resize
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	r9, rbx

; 2227 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rbx+24], 8
	jb	SHORT $LN51@path

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r9, QWORD PTR [rbx]
$LN51@path:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 54   :             (void) _Check_convert_result(__std_fs_convert_narrow_to_wide(

	mov	DWORD PTR [rsp+32], edi
	mov	r8d, ebp
	mov	rdx, rsi
	mov	ecx, r14d
	call	__std_fs_convert_narrow_to_wide
	mov	rcx, rax
	shr	rax, 32					; 00000020H
	test	eax, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono

; 52   :     if (_Result._Err != __std_win_error::_Success) {

	jne	SHORT $LN65@path
$LN56@path:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 651  :         }

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+104]
	mov	rbp, QWORD PTR [rsp+112]
	add	rsp, 64					; 00000040H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN65@path:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono

; 53   :         _Throw_system_error_from_std_win_error(_Result._Err);

	shr	rcx, 32					; 00000020H
	call	?_Throw_system_error_from_std_win_error@std@@YAXW4__std_win_error@@@Z ; std::_Throw_system_error_from_std_win_error
	int	3
$LN63@path:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 46   :                 _Throw_system_error(errc::invalid_argument);

	call	?_Throw_system_error@std@@YAXW4errc@1@@Z ; std::_Throw_system_error
	int	3
$LN64@path:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono

; 53   :         _Throw_system_error_from_std_win_error(_Result._Err);

	shr	rdi, 32					; 00000020H
	mov	ecx, edi
	call	?_Throw_system_error_from_std_win_error@std@@YAXW4__std_win_error@@@Z ; std::_Throw_system_error_from_std_win_error
	int	3
$LN61@path:
??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@W4format@012@@Z ENDP ; std::filesystem::path::path<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$GSCopy$ = 48
$T2 = 48
__$ReturnUdt$ = 56
this$ = 96
_Source$ = 104
__formal$dead$ = 112
?dtor$3@?0???$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@W4format@012@@Z@4HA PROC ; `std::filesystem::path::path<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,0>'::`1'::dtor$3
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T2[rbp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN28@dtor$3
	and	DWORD PTR $T2[rbp], -5
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
$LN28@dtor$3:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$3@?0???$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@W4format@012@@Z@4HA ENDP ; `std::filesystem::path::path<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,0>'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
_Val$dead$ = 64
??$_Resize@U_Value_init_tag@std@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Resize<std::_Value_init_tag>, COMDAT

; 1551 :     _CONSTEXPR20 void _Resize(const size_type _Newsize, const _Ty2& _Val) {

$LN28:
	mov	QWORD PTR [rsp+24], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 1552 :         // trim or append elements, provide strong guarantee
; 1553 :         auto& _Al           = _Getal();
; 1554 :         auto& _My_data      = _Mypair._Myval2;
; 1555 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1556 :         pointer& _Mylast    = _My_data._Mylast;
; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rdi, QWORD PTR [rcx+8]
	mov	r14, rcx
	mov	r8, QWORD PTR [rcx]
	mov	r9, -6148914691236517205		; aaaaaaaaaaaaaaabH
	mov	rcx, rdi
	sub	rcx, r8
	sar	rcx, 5
	imul	rcx, r9

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdx, rcx
	jae	SHORT $LN2@Resize
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rsi

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rsi, QWORD PTR [rdx+rdx*2]
	shl	rsi, 5
	add	rsi, r8

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rbx, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rsi, rdi
	je	SHORT $LN8@Resize
	npad	1
$LL9@Resize:
	mov	rcx, rbx
	call	??1ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ
	add	rbx, 96					; 00000060H
	cmp	rbx, rdi
	jne	SHORT $LL9@Resize
$LN8@Resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1563 :             _Mylast = _Newlast;

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [r14+8], rsi
	mov	rsi, QWORD PTR [rsp+56]

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN2@Resize:

; 1564 :             return;
; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN3@Resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [r14+16]
	sub	rax, r8
	sar	rax, 5
	imul	rax, r9

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN4@Resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, r14

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Resize_reallocate<std::_Value_init_tag>
$LN4@Resize:

; 1571 :                 return;
; 1572 :             }
; 1573 : 
; 1574 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1575 :             const pointer _Oldlast = _Mylast;
; 1576 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1577 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1578 :             } else {
; 1579 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, rcx
	mov	rcx, rdi
	call	??$_Uninitialized_value_construct_n@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@_KAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >
	mov	QWORD PTR [r14+8], rax
$LN3@Resize:

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
??$_Resize@U_Value_init_tag@std@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@@Z PROC ; std::move<AINBNodeDefMgr::NodeDef::ImmediateParam &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@@Z ENDP ; std::move<AINBNodeDefMgr::NodeDef::ImmediateParam &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
_Val$dead$ = 64
??$_Resize@U_Value_init_tag@std@@@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<AINBFile::OutputEntry,std::allocator<AINBFile::OutputEntry> >::_Resize<std::_Value_init_tag>, COMDAT

; 1551 :     _CONSTEXPR20 void _Resize(const size_type _Newsize, const _Ty2& _Val) {

$LN37:
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1552 :         // trim or append elements, provide strong guarantee
; 1553 :         auto& _Al           = _Getal();
; 1554 :         auto& _My_data      = _Mypair._Myval2;
; 1555 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1556 :         pointer& _Mylast    = _My_data._Mylast;
; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rdi, QWORD PTR [rcx+8]
	mov	rsi, rcx
	mov	r8, QWORD PTR [rcx]
	mov	r9, -8198552921648689607		; 8e38e38e38e38e39H
	mov	rcx, rdi
	sub	rcx, r8
	sar	rcx, 3
	imul	rcx, r9

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdx, rcx
	jae	SHORT $LN2@Resize
	mov	QWORD PTR [rsp+48], rbx

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rax, QWORD PTR [rdx+rdx*8]
	mov	QWORD PTR [rsp+56], rbp
	lea	rbp, QWORD PTR [r8+rax*8]

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rbx, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbp, rdi
	je	SHORT $LN8@Resize
	npad	5
$LL9@Resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx+40]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 72					; 00000048H
	cmp	rbx, rdi
	jne	SHORT $LL9@Resize
$LN8@Resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1563 :             _Mylast = _Newlast;

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [rsi+8], rbp
	mov	rbp, QWORD PTR [rsp+56]

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@Resize:

; 1564 :             return;
; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN3@Resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [rsi+16]
	sub	rax, r8
	sar	rax, 3
	imul	rax, r9

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN4@Resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, rsi

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<AINBFile::OutputEntry,std::allocator<AINBFile::OutputEntry> >::_Resize_reallocate<std::_Value_init_tag>
$LN4@Resize:

; 1571 :                 return;
; 1572 :             }
; 1573 : 
; 1574 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1575 :             const pointer _Oldlast = _Mylast;
; 1576 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1577 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1578 :             } else {
; 1579 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, rcx
	mov	rcx, rdi
	call	??$_Uninitialized_value_construct_n@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@YAPEAUOutputEntry@AINBFile@@PEAU12@_KAEAV?$allocator@UOutputEntry@AINBFile@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<AINBFile::OutputEntry> >
	mov	QWORD PTR [rsi+8], rax
$LN3@Resize:

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Resize@U_Value_init_tag@std@@@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<AINBFile::OutputEntry,std::allocator<AINBFile::OutputEntry> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
_Val$dead$ = 64
??$_Resize@U_Value_init_tag@std@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Resize<std::_Value_init_tag>, COMDAT

; 1551 :     _CONSTEXPR20 void _Resize(const size_type _Newsize, const _Ty2& _Val) {

$LN28:
	mov	QWORD PTR [rsp+24], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 1552 :         // trim or append elements, provide strong guarantee
; 1553 :         auto& _Al           = _Getal();
; 1554 :         auto& _My_data      = _Mypair._Myval2;
; 1555 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1556 :         pointer& _Mylast    = _My_data._Mylast;
; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rdi, QWORD PTR [rcx+8]
	mov	r14, rcx
	mov	r8, QWORD PTR [rcx]
	mov	r9, -8198552921648689607		; 8e38e38e38e38e39H
	mov	rcx, rdi
	sub	rcx, r8
	sar	rcx, 4
	imul	rcx, r9

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdx, rcx
	jae	SHORT $LN2@Resize
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rsi

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rsi, QWORD PTR [rdx+rdx*8]
	shl	rsi, 4
	add	rsi, r8

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rbx, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rsi, rdi
	je	SHORT $LN8@Resize
	npad	1
$LL9@Resize:
	mov	rcx, rbx
	call	??1InputParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ
	add	rbx, 144				; 00000090H
	cmp	rbx, rdi
	jne	SHORT $LL9@Resize
$LN8@Resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1563 :             _Mylast = _Newlast;

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [r14+8], rsi
	mov	rsi, QWORD PTR [rsp+56]

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN2@Resize:

; 1564 :             return;
; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN3@Resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [r14+16]
	sub	rax, r8
	sar	rax, 4
	imul	rax, r9

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN4@Resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, r14

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Resize_reallocate<std::_Value_init_tag>
$LN4@Resize:

; 1571 :                 return;
; 1572 :             }
; 1573 : 
; 1574 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1575 :             const pointer _Oldlast = _Mylast;
; 1576 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1577 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1578 :             } else {
; 1579 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, rcx
	mov	rcx, rdi
	call	??$_Uninitialized_value_construct_n@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@_KAEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >
	mov	QWORD PTR [r14+8], rax
$LN3@Resize:

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
??$_Resize@U_Value_init_tag@std@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$dead$ = 48
_Newsize$ = 56
_Val$dead$ = 64
??$_Resize@U_Value_init_tag@std@@@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::_Resize<std::_Value_init_tag>, COMDAT

; 1551 :     _CONSTEXPR20 void _Resize(const size_type _Newsize, const _Ty2& _Val) {

$LN28:
	push	rdi
	sub	rsp, 32					; 00000020H

; 1552 :         // trim or append elements, provide strong guarantee
; 1553 :         auto& _Al           = _Getal();
; 1554 :         auto& _My_data      = _Mypair._Myval2;
; 1555 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1556 :         pointer& _Mylast    = _My_data._Mylast;
; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rdi, QWORD PTR ?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A+8
	mov	r9, -1190112520884487201		; ef7bdef7bdef7bdfH
	mov	r8, QWORD PTR ?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A
	mov	rcx, rdi
	sub	rcx, r8
	sar	rcx, 3
	imul	rcx, r9

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdx, rcx
	jae	SHORT $LN2@Resize
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rsi

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	imul	rsi, rdx, 248				; 000000f8H
	add	rsi, r8

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rbx, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rsi, rdi
	je	SHORT $LN8@Resize
	npad	3
$LL9@Resize:
	mov	rcx, rbx
	call	??1NodeDef@AINBNodeDefMgr@@QEAA@XZ
	add	rbx, 248				; 000000f8H
	cmp	rbx, rdi
	jne	SHORT $LL9@Resize
$LN8@Resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1563 :             _Mylast = _Newlast;

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR ?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A+8, rsi
	mov	rsi, QWORD PTR [rsp+56]

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@Resize:

; 1564 :             return;
; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN3@Resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR ?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A+16
	sub	rax, r8
	sar	rax, 3
	imul	rax, r9

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN4@Resize

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	add	rsp, 32					; 00000020H
	pop	rdi

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::_Resize_reallocate<std::_Value_init_tag>
$LN4@Resize:

; 1571 :                 return;
; 1572 :             }
; 1573 : 
; 1574 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1575 :             const pointer _Oldlast = _Mylast;
; 1576 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1577 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1578 :             } else {
; 1579 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, rcx
	mov	rcx, rdi
	call	??$_Uninitialized_value_construct_n@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUNodeDef@AINBNodeDefMgr@@PEAU12@_KAEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<AINBNodeDefMgr::NodeDef> >
	mov	QWORD PTR ?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A+8, rax
$LN3@Resize:

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Resize@U_Value_init_tag@std@@@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@@std@@YA$$QEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@@std@@YA$$QEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@0@AEAV10@@Z PROC ; std::move<std::shared_ptr<std::filesystem::_Recursive_dir_enum_impl> &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@@std@@YA$$QEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@0@AEAV10@@Z ENDP ; std::move<std::shared_ptr<std::filesystem::_Recursive_dir_enum_impl> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??$_Move_construct_from@U_Recursive_dir_enum_impl@filesystem@std@@@?$_Ptr_base@U_Recursive_dir_enum_impl@filesystem@std@@@std@@IEAAX$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??$_Move_construct_from@U_Recursive_dir_enum_impl@filesystem@std@@@?$_Ptr_base@U_Recursive_dir_enum_impl@filesystem@std@@@std@@IEAAX$$QEAV01@@Z PROC ; std::_Ptr_base<std::filesystem::_Recursive_dir_enum_impl>::_Move_construct_from<std::filesystem::_Recursive_dir_enum_impl>, COMDAT

; 1344 :         // implement shared_ptr's (converting) move ctor and weak_ptr's move ctor
; 1345 :         _Ptr = _Right._Ptr;

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 1346 :         _Rep = _Right._Rep;

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rcx+8], rax

; 1347 : 
; 1348 :         _Right._Ptr = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rdx], rax

; 1349 :         _Right._Rep = nullptr;

	mov	QWORD PTR [rdx+8], rax

; 1350 :     }

	ret	0
??$_Move_construct_from@U_Recursive_dir_enum_impl@filesystem@std@@@?$_Ptr_base@U_Recursive_dir_enum_impl@filesystem@std@@@std@@IEAAX$$QEAV01@@Z ENDP ; std::_Ptr_base<std::filesystem::_Recursive_dir_enum_impl>::_Move_construct_from<std::filesystem::_Recursive_dir_enum_impl>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??$_Copy_construct_from@U_Recursive_dir_enum_impl@filesystem@std@@@?$_Ptr_base@U_Recursive_dir_enum_impl@filesystem@std@@@std@@IEAAXAEBV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Other$ = 16
??$_Copy_construct_from@U_Recursive_dir_enum_impl@filesystem@std@@@?$_Ptr_base@U_Recursive_dir_enum_impl@filesystem@std@@@std@@IEAAXAEBV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@1@@Z PROC ; std::_Ptr_base<std::filesystem::_Recursive_dir_enum_impl>::_Copy_construct_from<std::filesystem::_Recursive_dir_enum_impl>, COMDAT

; 1396 :         if (_Rep) {

	mov	rax, QWORD PTR [rdx+8]
	test	rax, rax
	je	SHORT $LN7@Copy_const

; 1169 :         _MT_INCR(_Uses);

	lock inc DWORD PTR [rax+8]
$LN7@Copy_const:

; 1354 :         // implement shared_ptr's (converting) copy ctor
; 1355 :         _Other._Incref();
; 1356 : 
; 1357 :         _Ptr = _Other._Ptr;

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 1358 :         _Rep = _Other._Rep;

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rcx+8], rax

; 1359 :     }

	ret	0
??$_Copy_construct_from@U_Recursive_dir_enum_impl@filesystem@std@@@?$_Ptr_base@U_Recursive_dir_enum_impl@filesystem@std@@@std@@IEAAXAEBV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@1@@Z ENDP ; std::_Ptr_base<std::filesystem::_Recursive_dir_enum_impl>::_Copy_construct_from<std::filesystem::_Recursive_dir_enum_impl>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Unfancy@U_Find_file_handle@filesystem@std@@@std@@YAPEAU_Find_file_handle@filesystem@0@PEAU120@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@U_Find_file_handle@filesystem@std@@@std@@YAPEAU_Find_file_handle@filesystem@0@PEAU120@@Z PROC ; std::_Unfancy<std::filesystem::_Find_file_handle>, COMDAT

; 37   :     return _Ptr;

	mov	rax, rcx

; 38   : }

	ret	0
??$_Unfancy@U_Find_file_handle@filesystem@std@@@std@@YAPEAU_Find_file_handle@filesystem@0@PEAU120@@Z ENDP ; std::_Unfancy<std::filesystem::_Find_file_handle>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$destroy@U_Find_file_handle@filesystem@std@@@?$_Default_allocator_traits@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@@std@@SAXAEAV?$allocator@U_Find_file_handle@filesystem@std@@@1@QEAU_Find_file_handle@filesystem@1@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$destroy@U_Find_file_handle@filesystem@std@@@?$_Default_allocator_traits@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@@std@@SAXAEAV?$allocator@U_Find_file_handle@filesystem@std@@@1@QEAU_Find_file_handle@filesystem@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::filesystem::_Find_file_handle> >::destroy<std::filesystem::_Find_file_handle>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 605  :             __std_fs_directory_iterator_close(_Handle);

	mov	rcx, QWORD PTR [rdx]
	jmp	__std_fs_directory_iterator_close
??$destroy@U_Find_file_handle@filesystem@std@@@?$_Default_allocator_traits@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@@std@@SAXAEAV?$allocator@U_Find_file_handle@filesystem@std@@@1@QEAU_Find_file_handle@filesystem@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::filesystem::_Find_file_handle> >::destroy<std::filesystem::_Find_file_handle>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Emplace_one_at_back@U_Find_file_handle@filesystem@std@@@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAAEAU_Find_file_handle@filesystem@1@$$QEAU231@@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$_Emplace_one_at_back@U_Find_file_handle@filesystem@std@@@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAAEAU_Find_file_handle@filesystem@1@$$QEAU231@@Z PROC ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::_Emplace_one_at_back<std::filesystem::_Find_file_handle>, COMDAT

; 776  :     _CONSTEXPR20 _Ty& _Emplace_one_at_back(_Valty&&... _Val) {

	mov	r9, rcx

; 777  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 778  :         auto& _My_data   = _Mypair._Myval2;
; 779  :         pointer& _Mylast = _My_data._Mylast;
; 780  : 
; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rcx, QWORD PTR [rcx+8]
	cmp	rcx, QWORD PTR [r9+16]
	je	SHORT $LN2@Emplace_on

; 805  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rdx], -1
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR [r9+8]

; 806  :         ++_Mylast;

	lea	rcx, QWORD PTR [rax+8]
	mov	QWORD PTR [r9+8], rcx

; 786  :     }

	ret	0
$LN2@Emplace_on:

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	r8, rdx
	mov	rdx, rcx
	mov	rcx, r9
	jmp	??$_Emplace_reallocate@U_Find_file_handle@filesystem@std@@@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAPEAU_Find_file_handle@filesystem@1@QEAU231@$$QEAU231@@Z ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::_Emplace_reallocate<std::filesystem::_Find_file_handle>
??$_Emplace_one_at_back@U_Find_file_handle@filesystem@std@@@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAAEAU_Find_file_handle@filesystem@1@$$QEAU231@@Z ENDP ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::_Emplace_one_at_back<std::filesystem::_Find_file_handle>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Find_file_handle@filesystem@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Find_file_handle@filesystem@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::filesystem::_Find_file_handle>,std::_Vector_val<std::_Simple_types<std::filesystem::_Find_file_handle> >,1>::_Compressed_pair<std::allocator<std::filesystem::_Find_file_handle>,std::_Vector_val<std::_Simple_types<std::filesystem::_Find_file_handle> >,1><>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Find_file_handle@filesystem@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::filesystem::_Find_file_handle>,std::_Vector_val<std::_Simple_types<std::filesystem::_Find_file_handle> >,1>::_Compressed_pair<std::allocator<std::filesystem::_Find_file_handle>,std::_Vector_val<std::_Simple_types<std::filesystem::_Find_file_handle> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAPEB_W@std@@YA$$QEAPEB_WAEAPEB_W@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAPEB_W@std@@YA$$QEAPEB_WAEAPEB_W@Z PROC	; std::move<wchar_t const * &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAPEB_W@std@@YA$$QEAPEB_WAEAPEB_W@Z ENDP	; std::move<wchar_t const * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@$$CBV?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YAPEBV?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YAPEBV?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@0@AEBV10@@Z PROC ; std::addressof<std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > const >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@$$CBV?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YAPEBV?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Pocca@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAXAEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Left$dead$ = 8
_Right$dead$ = 16
??$_Pocca@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAXAEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@0@AEBV10@@Z PROC ; std::_Pocca<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >, COMDAT

; 1060 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 1061 :         _Left = _Right;
; 1062 :     }
; 1063 : }

	ret	0
??$_Pocca@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAXAEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@0@AEBV10@@Z ENDP ; std::_Pocca<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Assign_counted_range@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_K@Z
_TEXT	SEGMENT
this$ = 80
_First$ = 88
_Newsize$ = 96
??$_Assign_counted_range@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_K@Z PROC ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Assign_counted_range<enum AINBNodeDefMgr::NodeDef::CategoryEnum *>, COMDAT

; 1381 :     _CONSTEXPR20 void _Assign_counted_range(_Iter _First, const size_type _Newsize) {

$LN120:
	push	rbx
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 40					; 00000028H
	mov	rsi, rcx
	mov	r14, rdx

; 1382 :         // assign elements from counted range _First + [0, _Newsize)
; 1383 :         auto& _Al         = _Getal();
; 1384 :         auto& _My_data    = _Mypair._Myval2;
; 1385 :         pointer& _Myfirst = _My_data._Myfirst;
; 1386 :         pointer& _Mylast  = _My_data._Mylast;
; 1387 :         pointer& _Myend   = _My_data._Myend;
; 1388 : 
; 1389 :         constexpr bool _Nothrow_construct = conjunction_v<is_nothrow_constructible<_Ty, _Iter_ref_t<_Iter>>,
; 1390 :             _Uses_default_construct<_Alloc, _Ty*, _Iter_ref_t<_Iter>>>;
; 1391 : 
; 1392 :         _My_data._Orphan_all();
; 1393 :         const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

	mov	rcx, QWORD PTR [rcx]
	mov	rdi, r8
	mov	rdx, QWORD PTR [rsi+16]
	sub	rdx, rcx

; 1394 :         if (_Newsize > _Oldcapacity) {

	cmp	r8, rdx
	jbe	$LN5@Assign_cou

; 1658 :         if (_Newsize > max_size()) {

	mov	rbx, 9223372036854775807		; 7fffffffffffffffH
	cmp	r8, rbx
	ja	$LN118@Assign_cou

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	r8, rdx
	mov	rax, rbx
	shr	r8, 1
	sub	rax, r8
	cmp	rdx, rax
	ja	SHORT $LN17@Assign_cou

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rbx, QWORD PTR [r8+rdx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rbx, rdi
	cmovb	rbx, rdi
$LN17@Assign_cou:

; 1664 :         if (_Myfirst) { // destroy and deallocate old array

	test	rcx, rcx
	je	SHORT $LN13@Assign_cou
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN37@Assign_cou

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN34@Assign_cou

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN37@Assign_cou:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1669 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rsi], rax

; 1670 :             _Mylast  = nullptr;

	mov	QWORD PTR [rsi+8], rax

; 1671 :             _Myend   = nullptr;

	mov	QWORD PTR [rsi+16], rax
$LN13@Assign_cou:

; 1672 :         }
; 1673 : 
; 1674 :         _Buy_raw(_Newcapacity);

	mov	rdx, rbx
	mov	rcx, rsi
	call	?_Buy_raw@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Buy_raw

; 1397 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	rbx, QWORD PTR [rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rdi
	mov	rcx, rbx
	mov	rdx, r14
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1881 :             _Dest += _Count;

	lea	rax, QWORD PTR [rdi+rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1397 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	QWORD PTR [rsi+8], rax

; 1440 :         }
; 1441 :     }

	add	rsp, 40					; 00000028H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN34@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN5@Assign_cou:
	mov	QWORD PTR [rsp+32], rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1407 :         if (_Newsize > _Oldsize) {

	mov	rdx, r14
	mov	rbp, QWORD PTR [rsi+8]
	sub	rbp, rcx
	cmp	rdi, rbp
	jbe	SHORT $LN6@Assign_cou
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbp
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1416 :                     _Copied = true;

	mov	rbx, QWORD PTR [rsi+8]
	lea	rdx, QWORD PTR [r14+rbp]

; 1428 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);

	sub	rdi, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, rbx
	mov	r8, rdi
	call	memmove
	mov	rbp, QWORD PTR [rsp+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1881 :             _Dest += _Count;

	lea	rax, QWORD PTR [rdi+rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1428 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);

	mov	QWORD PTR [rsi+8], rax

; 1440 :         }
; 1441 :     }

	add	rsp, 40					; 00000028H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN6@Assign_cou:

; 1429 :             } else {
; 1430 :                 _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1431 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);
; 1432 :                 _ASAN_VECTOR_RELEASE_GUARD;
; 1433 :             }
; 1434 :         } else {
; 1435 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rbx, QWORD PTR [rcx+r8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	call	memmove
	mov	rbp, QWORD PTR [rsp+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1439 :             _Mylast = _Newlast;

	mov	QWORD PTR [rsi+8], rbx

; 1440 :         }
; 1441 :     }

	add	rsp, 40					; 00000028H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN118@Assign_cou:

; 1659 :             _Xlength();

	call	?_Xlength@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Xlength
	int	3
$LN116@Assign_cou:
??$_Assign_counted_range@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_K@Z ENDP ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Assign_counted_range<enum AINBNodeDefMgr::NodeDef::CategoryEnum *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@AEAW4123@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@AEAW4123@@Z PROC ; std::move<enum AINBNodeDefMgr::NodeDef::CategoryEnum &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@AEAW4123@@Z ENDP ; std::move<enum AINBNodeDefMgr::NodeDef::CategoryEnum &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Emplace_one_at_back@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAAEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@$$QEAW4234@@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$_Emplace_one_at_back@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAAEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@$$QEAW4234@@Z PROC ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Emplace_one_at_back<enum AINBNodeDefMgr::NodeDef::CategoryEnum>, COMDAT

; 776  :     _CONSTEXPR20 _Ty& _Emplace_one_at_back(_Valty&&... _Val) {

	mov	r8, rdx

; 777  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 778  :         auto& _My_data   = _Mypair._Myval2;
; 779  :         pointer& _Mylast = _My_data._Mylast;
; 780  : 
; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rcx+8]
	cmp	rdx, QWORD PTR [rcx+16]
	je	SHORT $LN2@Emplace_on

; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [rdx], al

; 798  :         } else {
; 799  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 800  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 801  :             _ASAN_VECTOR_RELEASE_GUARD;
; 802  :         }
; 803  : 
; 804  :         _Orphan_range(_Mylast, _Mylast);
; 805  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR [rcx+8]

; 806  :         ++_Mylast;

	lea	rdx, QWORD PTR [rax+1]
	mov	QWORD PTR [rcx+8], rdx

; 786  :     }

	ret	0
$LN2@Emplace_on:

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@QEAW4234@$$QEAW4234@@Z ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Emplace_reallocate<enum AINBNodeDefMgr::NodeDef::CategoryEnum>
??$_Emplace_one_at_back@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAAEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@$$QEAW4234@@Z ENDP ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Emplace_one_at_back<enum AINBNodeDefMgr::NodeDef::CategoryEnum>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum>,std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >,1>::_Compressed_pair<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum>,std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >,1><>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum>,std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >,1>::_Compressed_pair<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum>,std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$dead$ = 56
_Val$dead$ = 64
??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Resize<std::_Value_init_tag>, COMDAT

; 1551 :     _CONSTEXPR20 void _Resize(const size_type _Newsize, const _Ty2& _Val) {

$LN79:
	mov	QWORD PTR [rsp+32], rbx
	push	rsi
	sub	rsp, 32					; 00000020H

; 1552 :         // trim or append elements, provide strong guarantee
; 1553 :         auto& _Al           = _Getal();
; 1554 :         auto& _My_data      = _Mypair._Myval2;
; 1555 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1556 :         pointer& _Mylast    = _My_data._Mylast;
; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rbx, QWORD PTR [rcx+8]
	mov	rsi, rcx
	mov	rdx, QWORD PTR [rcx]
	mov	r8, -6148914691236517205		; aaaaaaaaaaaaaaabH
	mov	rcx, rbx
	sub	rcx, rdx
	sar	rcx, 3
	imul	rcx, r8

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rcx, 6
	jbe	SHORT $LN2@Resize
	mov	QWORD PTR [rsp+56], rbp

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rbp, QWORD PTR [rdx+144]
	mov	QWORD PTR [rsp+64], rdi

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rdi, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbp, rbx
	je	SHORT $LN8@Resize
	npad	5
$LL9@Resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	mov	rcx, rdi
	call	?_Tidy@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rdi, 24
	cmp	rdi, rbx
	jne	SHORT $LL9@Resize
$LN8@Resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1563 :             _Mylast = _Newlast;

	mov	rdi, QWORD PTR [rsp+64]
	mov	QWORD PTR [rsi+8], rbp
	mov	rbp, QWORD PTR [rsp+56]

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
$LN2@Resize:

; 1564 :             return;
; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jae	SHORT $LN3@Resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [rsi+16]
	sub	rax, rdx
	sar	rax, 3
	imul	rax, r8

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rax, 6
	jae	SHORT $LN4@Resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, rsi

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rsi

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Resize_reallocate<std::_Value_init_tag>
$LN4@Resize:

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	mov	eax, 6
	sub	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2041 :     for (; 0 < _Count; --_Count) {

	je	SHORT $LN22@Resize
	xor	ecx, ecx
	npad	1
$LL23@Resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rbx], rcx
	mov	QWORD PTR [rbx+8], rcx
	mov	QWORD PTR [rbx+16], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rbx, 24

; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rax, 1
	jne	SHORT $LL23@Resize
$LN22@Resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	mov	QWORD PTR [rsi+8], rbx
$LN3@Resize:

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@$$CBV?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@@std@@YAPEBV?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@@std@@YAPEBV?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@0@AEBV10@@Z PROC ; std::addressof<std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > > const >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@$$CBV?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@@std@@YAPEBV?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@0@AEBV10@@Z ENDP ; std::addressof<std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Pocca@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YAXAEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Left$dead$ = 8
_Right$dead$ = 16
??$_Pocca@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YAXAEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@AEBV10@@Z PROC ; std::_Pocca<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >, COMDAT

; 1060 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 1061 :         _Left = _Right;
; 1062 :     }
; 1063 : }

	ret	0
??$_Pocca@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YAXAEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@AEBV10@@Z ENDP ; std::_Pocca<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Assign_counted_range@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@_K@Z
_TEXT	SEGMENT
this$ = 96
_First$ = 104
_Newsize$ = 112
??$_Assign_counted_range@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@_K@Z PROC ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Assign_counted_range<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > *>, COMDAT

; 1381 :     _CONSTEXPR20 void _Assign_counted_range(_Iter _First, const size_type _Newsize) {

$LN117:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 1382 :         // assign elements from counted range _First + [0, _Newsize)
; 1383 :         auto& _Al         = _Getal();
; 1384 :         auto& _My_data    = _Mypair._Myval2;
; 1385 :         pointer& _Myfirst = _My_data._Myfirst;
; 1386 :         pointer& _Mylast  = _My_data._Mylast;
; 1387 :         pointer& _Myend   = _My_data._Myend;
; 1388 : 
; 1389 :         constexpr bool _Nothrow_construct = conjunction_v<is_nothrow_constructible<_Ty, _Iter_ref_t<_Iter>>,
; 1390 :             _Uses_default_construct<_Alloc, _Ty*, _Iter_ref_t<_Iter>>>;
; 1391 : 
; 1392 :         _My_data._Orphan_all();
; 1393 :         const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

	mov	rbx, QWORD PTR [rcx]
	mov	r14, rcx
	mov	rcx, QWORD PTR [rcx+16]
	mov	r12, -6148914691236517205		; aaaaaaaaaaaaaaabH
	sub	rcx, rbx
	mov	rsi, r8
	sar	rcx, 3
	mov	rdi, rdx
	imul	rcx, r12

; 1394 :         if (_Newsize > _Oldcapacity) {

	cmp	r8, rcx
	jbe	$LN5@Assign_cou

; 1658 :         if (_Newsize > max_size()) {

	mov	r15, 768614336404564650			; 0aaaaaaaaaaaaaaaH
	cmp	r8, r15
	ja	$LN115@Assign_cou

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	mov	rax, r15
	shr	rdx, 1
	sub	rax, rdx
	cmp	rcx, rax
	ja	SHORT $LN16@Assign_cou

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	r15, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	r15, r8
	cmovb	r15, r8
$LN16@Assign_cou:

; 1664 :         if (_Myfirst) { // destroy and deallocate old array

	test	rbx, rbx
	je	SHORT $LN12@Assign_cou

; 1665 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rbp, QWORD PTR [r14+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rbp
	je	SHORT $LN22@Assign_cou
	npad	6
$LL23@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	mov	rcx, rbx
	call	?_Tidy@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 24
	cmp	rbx, rbp
	jne	SHORT $LL23@Assign_cou
$LN22@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1667 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [r14]
	mov	rax, QWORD PTR [r14+16]
	sub	rax, rcx
	sar	rax, 3
	imul	rax, r12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*2]
	shl	rdx, 3

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN50@Assign_cou

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN47@Assign_cou

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN50@Assign_cou:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1669 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [r14], rax

; 1670 :             _Mylast  = nullptr;

	mov	QWORD PTR [r14+8], rax

; 1671 :             _Myend   = nullptr;

	mov	QWORD PTR [r14+16], rax
$LN12@Assign_cou:

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdx, r15
	call	?allocate@?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K@Z ; std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >::allocate

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [r14], rax

; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	r8, QWORD PTR [r15+r15*2]
	mov	QWORD PTR [r14+8], rax

; 1395 :             _Clear_and_reserve_geometric(_Newsize);
; 1396 :             if constexpr (_Nothrow_construct) {
; 1397 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1398 :                 _ASAN_VECTOR_CREATE;
; 1399 :             } else {
; 1400 :                 _ASAN_VECTOR_CREATE_GUARD;
; 1401 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	rdx, rsi
	mov	rcx, rdi

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	r9, QWORD PTR [rax+r8*8]

; 1395 :             _Clear_and_reserve_geometric(_Newsize);
; 1396 :             if constexpr (_Nothrow_construct) {
; 1397 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1398 :                 _ASAN_VECTOR_CREATE;
; 1399 :             } else {
; 1400 :                 _ASAN_VECTOR_CREATE_GUARD;
; 1401 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	r8, rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	mov	QWORD PTR [r14+16], r9

; 1395 :             _Clear_and_reserve_geometric(_Newsize);
; 1396 :             if constexpr (_Nothrow_construct) {
; 1397 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1398 :                 _ASAN_VECTOR_CREATE;
; 1399 :             } else {
; 1400 :                 _ASAN_VECTOR_CREATE_GUARD;
; 1401 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	r9, r14
	call	??$_Uninitialized_copy_n@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z ; std::_Uninitialized_copy_n<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > *,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >
	mov	QWORD PTR [r14+8], rax

; 1440 :         }
; 1441 :     }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN47@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN5@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1406 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r8, QWORD PTR [r14+8]
	mov	r15, r8
	sub	r15, rbx
	sar	r15, 3
	imul	r15, r12

; 1407 :         if (_Newsize > _Oldsize) {

	cmp	rsi, r15
	jbe	SHORT $LN6@Assign_cou

; 1408 :             bool _Copied = false;
; 1409 :             if constexpr (_Iter_copy_cat<_Iter, pointer>::_Bitcopy_assignable) {
; 1410 : #if _HAS_CXX20
; 1411 :                 if (!_STD is_constant_evaluated())
; 1412 : #endif // _HAS_CXX20
; 1413 :                 {
; 1414 :                     _Copy_memmove_n(_First, static_cast<size_t>(_Oldsize), _Myfirst);
; 1415 :                     _First += _Oldsize;
; 1416 :                     _Copied = true;
; 1417 :                 }
; 1418 :             }
; 1419 : 
; 1420 :             if (!_Copied) {
; 1421 :                 for (auto _Mid = _Myfirst; _Mid != _Mylast; ++_Mid, (void) ++_First) {

	cmp	rbx, r8
	je	SHORT $LN3@Assign_cou
	mov	rbp, -8198552921648689607		; 8e38e38e38e38e39H
	npad	6
$LL4@Assign_cou:

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rbx, rdi
	je	SHORT $LN2@Assign_cou

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [rdi]
	mov	rcx, rbx
	mov	r8, QWORD PTR [rdi+8]
	sub	r8, rdx
	sar	r8, 4
	imul	r8, rbp
	call	??$_Assign_counted_range@PEAUInputParam@NodeDef@AINBNodeDefMgr@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Assign_counted_range<AINBNodeDefMgr::NodeDef::InputParam *>
$LN2@Assign_cou:

; 1408 :             bool _Copied = false;
; 1409 :             if constexpr (_Iter_copy_cat<_Iter, pointer>::_Bitcopy_assignable) {
; 1410 : #if _HAS_CXX20
; 1411 :                 if (!_STD is_constant_evaluated())
; 1412 : #endif // _HAS_CXX20
; 1413 :                 {
; 1414 :                     _Copy_memmove_n(_First, static_cast<size_t>(_Oldsize), _Myfirst);
; 1415 :                     _First += _Oldsize;
; 1416 :                     _Copied = true;
; 1417 :                 }
; 1418 :             }
; 1419 : 
; 1420 :             if (!_Copied) {
; 1421 :                 for (auto _Mid = _Myfirst; _Mid != _Mylast; ++_Mid, (void) ++_First) {

	mov	r8, QWORD PTR [r14+8]
	add	rbx, 24
	add	rdi, 24
	cmp	rbx, r8
	jne	SHORT $LL4@Assign_cou
$LN3@Assign_cou:

; 1422 :                     *_Mid = *_First;
; 1423 :                 }
; 1424 :             }
; 1425 : 
; 1426 :             if constexpr (_Nothrow_construct) {
; 1427 :                 _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1428 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);
; 1429 :             } else {
; 1430 :                 _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1431 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);

	sub	rsi, r15
	mov	r9, r14
	mov	rdx, rsi
	mov	rcx, rdi
	call	??$_Uninitialized_copy_n@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z ; std::_Uninitialized_copy_n<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > *,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >
	mov	QWORD PTR [r14+8], rax

; 1440 :         }
; 1441 :     }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN6@Assign_cou:

; 1432 :                 _ASAN_VECTOR_RELEASE_GUARD;
; 1433 :             }
; 1434 :         } else {
; 1435 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rax, QWORD PTR [rsi+rsi*2]
	lea	r15, QWORD PTR [rbx+rax*8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4572 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	test	rsi, rsi
	je	SHORT $LN62@Assign_cou
	mov	rbp, -8198552921648689607		; 8e38e38e38e38e39H
	npad	5
$LL63@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rbx, rdi
	je	SHORT $LN61@Assign_cou

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [rdi]
	mov	rcx, rbx
	mov	r8, QWORD PTR [rdi+8]
	sub	r8, rdx
	sar	r8, 4
	imul	r8, rbp
	call	??$_Assign_counted_range@PEAUInputParam@NodeDef@AINBNodeDefMgr@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Assign_counted_range<AINBNodeDefMgr::NodeDef::InputParam *>
$LN61@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4572 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	add	rbx, 24
	add	rdi, 24
	sub	rsi, 1
	jne	SHORT $LL63@Assign_cou
$LN62@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1437 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rdi, QWORD PTR [r14+8]
	mov	rbx, r15
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	r15, rdi
	je	SHORT $LN70@Assign_cou
	npad	7
$LL71@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	mov	rcx, rbx
	call	?_Tidy@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 24
	cmp	rbx, rdi
	jne	SHORT $LL71@Assign_cou
$LN70@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1439 :             _Mylast = _Newlast;

	mov	QWORD PTR [r14+8], r15

; 1440 :         }
; 1441 :     }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN115@Assign_cou:

; 1659 :             _Xlength();

	call	?_Xlength@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@CAXXZ ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Xlength
	int	3
$LN113@Assign_cou:
??$_Assign_counted_range@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@_K@Z ENDP ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Assign_counted_range<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >,std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >,1>::_Compressed_pair<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >,std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >,1><>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >,std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >,1>::_Compressed_pair<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >,std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$dead$ = 56
_Val$dead$ = 64
??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Resize<std::_Value_init_tag>, COMDAT

; 1551 :     _CONSTEXPR20 void _Resize(const size_type _Newsize, const _Ty2& _Val) {

$LN79:
	mov	QWORD PTR [rsp+32], rbx
	push	rsi
	sub	rsp, 32					; 00000020H

; 1552 :         // trim or append elements, provide strong guarantee
; 1553 :         auto& _Al           = _Getal();
; 1554 :         auto& _My_data      = _Mypair._Myval2;
; 1555 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1556 :         pointer& _Mylast    = _My_data._Mylast;
; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rbx, QWORD PTR [rcx+8]
	mov	rsi, rcx
	mov	rdx, QWORD PTR [rcx]
	mov	r8, -6148914691236517205		; aaaaaaaaaaaaaaabH
	mov	rcx, rbx
	sub	rcx, rdx
	sar	rcx, 3
	imul	rcx, r8

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rcx, 6
	jbe	SHORT $LN2@Resize
	mov	QWORD PTR [rsp+56], rbp

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rbp, QWORD PTR [rdx+144]
	mov	QWORD PTR [rsp+64], rdi

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rdi, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbp, rbx
	je	SHORT $LN8@Resize
	npad	5
$LL9@Resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	mov	rcx, rdi
	call	?_Tidy@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rdi, 24
	cmp	rdi, rbx
	jne	SHORT $LL9@Resize
$LN8@Resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1563 :             _Mylast = _Newlast;

	mov	rdi, QWORD PTR [rsp+64]
	mov	QWORD PTR [rsi+8], rbp
	mov	rbp, QWORD PTR [rsp+56]

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
$LN2@Resize:

; 1564 :             return;
; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jae	SHORT $LN3@Resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [rsi+16]
	sub	rax, rdx
	sar	rax, 3
	imul	rax, r8

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rax, 6
	jae	SHORT $LN4@Resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, rsi

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rsi

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Resize_reallocate<std::_Value_init_tag>
$LN4@Resize:

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	mov	eax, 6
	sub	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2041 :     for (; 0 < _Count; --_Count) {

	je	SHORT $LN22@Resize
	xor	ecx, ecx
	npad	1
$LL23@Resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rbx], rcx
	mov	QWORD PTR [rbx+8], rcx
	mov	QWORD PTR [rbx+16], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rbx, 24

; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rax, 1
	jne	SHORT $LL23@Resize
$LN22@Resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	mov	QWORD PTR [rsi+8], rbx
$LN3@Resize:

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@$$CBV?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@@std@@YAPEBV?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@@std@@YAPEBV?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@0@AEBV10@@Z PROC ; std::addressof<std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > > const >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@$$CBV?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@@std@@YAPEBV?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@0@AEBV10@@Z ENDP ; std::addressof<std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Pocca@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YAXAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Left$dead$ = 8
_Right$dead$ = 16
??$_Pocca@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YAXAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@AEBV10@@Z PROC ; std::_Pocca<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >, COMDAT

; 1060 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 1061 :         _Left = _Right;
; 1062 :     }
; 1063 : }

	ret	0
??$_Pocca@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YAXAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@AEBV10@@Z ENDP ; std::_Pocca<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Assign_counted_range@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@_K@Z
_TEXT	SEGMENT
this$ = 96
_First$ = 104
_Newsize$ = 112
??$_Assign_counted_range@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@_K@Z PROC ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Assign_counted_range<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *>, COMDAT

; 1381 :     _CONSTEXPR20 void _Assign_counted_range(_Iter _First, const size_type _Newsize) {

$LN116:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r14
	sub	rsp, 40					; 00000028H

; 1382 :         // assign elements from counted range _First + [0, _Newsize)
; 1383 :         auto& _Al         = _Getal();
; 1384 :         auto& _My_data    = _Mypair._Myval2;
; 1385 :         pointer& _Myfirst = _My_data._Myfirst;
; 1386 :         pointer& _Mylast  = _My_data._Mylast;
; 1387 :         pointer& _Myend   = _My_data._Myend;
; 1388 : 
; 1389 :         constexpr bool _Nothrow_construct = conjunction_v<is_nothrow_constructible<_Ty, _Iter_ref_t<_Iter>>,
; 1390 :             _Uses_default_construct<_Alloc, _Ty*, _Iter_ref_t<_Iter>>>;
; 1391 : 
; 1392 :         _My_data._Orphan_all();
; 1393 :         const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

	mov	rbx, QWORD PTR [rcx]
	mov	r14, rcx
	mov	rcx, QWORD PTR [rcx+16]
	mov	r12, -6148914691236517205		; aaaaaaaaaaaaaaabH
	sub	rcx, rbx
	mov	rsi, r8
	sar	rcx, 3
	mov	rdi, rdx
	imul	rcx, r12

; 1394 :         if (_Newsize > _Oldcapacity) {

	cmp	r8, rcx
	jbe	$LN5@Assign_cou
	mov	QWORD PTR [rsp+32], r15

; 1658 :         if (_Newsize > max_size()) {

	mov	r15, 768614336404564650			; 0aaaaaaaaaaaaaaaH
	cmp	r8, r15
	ja	$LN114@Assign_cou

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	mov	rax, r15
	shr	rdx, 1
	sub	rax, rdx
	cmp	rcx, rax
	ja	SHORT $LN16@Assign_cou

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	r15, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	r15, r8
	cmovb	r15, r8
$LN16@Assign_cou:

; 1664 :         if (_Myfirst) { // destroy and deallocate old array

	test	rbx, rbx
	je	SHORT $LN12@Assign_cou

; 1665 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rbp, QWORD PTR [r14+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rbp
	je	SHORT $LN22@Assign_cou
	npad	3
$LL23@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	mov	rcx, rbx
	call	?_Tidy@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 24
	cmp	rbx, rbp
	jne	SHORT $LL23@Assign_cou
$LN22@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1667 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [r14]
	mov	rax, QWORD PTR [r14+16]
	sub	rax, rcx
	sar	rax, 3
	imul	rax, r12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*2]
	shl	rdx, 3

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN50@Assign_cou

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN47@Assign_cou

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN50@Assign_cou:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1669 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [r14], rax

; 1670 :             _Mylast  = nullptr;

	mov	QWORD PTR [r14+8], rax

; 1671 :             _Myend   = nullptr;

	mov	QWORD PTR [r14+16], rax
$LN12@Assign_cou:

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdx, r15
	call	?allocate@?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K@Z ; std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >::allocate

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [r14], rax

; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	r8, QWORD PTR [r15+r15*2]
	mov	QWORD PTR [r14+8], rax

; 1395 :             _Clear_and_reserve_geometric(_Newsize);
; 1396 :             if constexpr (_Nothrow_construct) {
; 1397 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1398 :                 _ASAN_VECTOR_CREATE;
; 1399 :             } else {
; 1400 :                 _ASAN_VECTOR_CREATE_GUARD;
; 1401 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	rdx, rsi
	mov	rcx, rdi

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	r9, QWORD PTR [rax+r8*8]

; 1395 :             _Clear_and_reserve_geometric(_Newsize);
; 1396 :             if constexpr (_Nothrow_construct) {
; 1397 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1398 :                 _ASAN_VECTOR_CREATE;
; 1399 :             } else {
; 1400 :                 _ASAN_VECTOR_CREATE_GUARD;
; 1401 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	r8, rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	mov	QWORD PTR [r14+16], r9

; 1395 :             _Clear_and_reserve_geometric(_Newsize);
; 1396 :             if constexpr (_Nothrow_construct) {
; 1397 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1398 :                 _ASAN_VECTOR_CREATE;
; 1399 :             } else {
; 1400 :                 _ASAN_VECTOR_CREATE_GUARD;
; 1401 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	r9, r14
	call	??$_Uninitialized_copy_n@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z ; std::_Uninitialized_copy_n<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >
	mov	r15, QWORD PTR [rsp+32]
	mov	QWORD PTR [r14+8], rax

; 1440 :         }
; 1441 :     }

	add	rsp, 40					; 00000028H
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN47@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN5@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1406 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r8, QWORD PTR [r14+8]
	mov	rbp, r8
	sub	rbp, rbx
	sar	rbp, 3
	imul	rbp, r12

; 1407 :         if (_Newsize > _Oldsize) {

	cmp	rsi, rbp
	jbe	SHORT $LN6@Assign_cou

; 1408 :             bool _Copied = false;
; 1409 :             if constexpr (_Iter_copy_cat<_Iter, pointer>::_Bitcopy_assignable) {
; 1410 : #if _HAS_CXX20
; 1411 :                 if (!_STD is_constant_evaluated())
; 1412 : #endif // _HAS_CXX20
; 1413 :                 {
; 1414 :                     _Copy_memmove_n(_First, static_cast<size_t>(_Oldsize), _Myfirst);
; 1415 :                     _First += _Oldsize;
; 1416 :                     _Copied = true;
; 1417 :                 }
; 1418 :             }
; 1419 : 
; 1420 :             if (!_Copied) {
; 1421 :                 for (auto _Mid = _Myfirst; _Mid != _Mylast; ++_Mid, (void) ++_First) {

	cmp	rbx, r8
	je	SHORT $LN3@Assign_cou
$LL4@Assign_cou:

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rbx, rdi
	je	SHORT $LN2@Assign_cou

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [rdi]
	mov	rcx, rbx
	mov	r8, QWORD PTR [rdi+8]
	sub	r8, rdx
	sar	r8, 5
	imul	r8, r12
	call	??$_Assign_counted_range@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Assign_counted_range<AINBNodeDefMgr::NodeDef::ImmediateParam *>
$LN2@Assign_cou:

; 1408 :             bool _Copied = false;
; 1409 :             if constexpr (_Iter_copy_cat<_Iter, pointer>::_Bitcopy_assignable) {
; 1410 : #if _HAS_CXX20
; 1411 :                 if (!_STD is_constant_evaluated())
; 1412 : #endif // _HAS_CXX20
; 1413 :                 {
; 1414 :                     _Copy_memmove_n(_First, static_cast<size_t>(_Oldsize), _Myfirst);
; 1415 :                     _First += _Oldsize;
; 1416 :                     _Copied = true;
; 1417 :                 }
; 1418 :             }
; 1419 : 
; 1420 :             if (!_Copied) {
; 1421 :                 for (auto _Mid = _Myfirst; _Mid != _Mylast; ++_Mid, (void) ++_First) {

	mov	r8, QWORD PTR [r14+8]
	add	rbx, 24
	add	rdi, 24
	cmp	rbx, r8
	jne	SHORT $LL4@Assign_cou
$LN3@Assign_cou:

; 1422 :                     *_Mid = *_First;
; 1423 :                 }
; 1424 :             }
; 1425 : 
; 1426 :             if constexpr (_Nothrow_construct) {
; 1427 :                 _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1428 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);
; 1429 :             } else {
; 1430 :                 _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1431 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);

	sub	rsi, rbp
	mov	r9, r14
	mov	rdx, rsi
	mov	rcx, rdi
	call	??$_Uninitialized_copy_n@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z ; std::_Uninitialized_copy_n<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >
	mov	QWORD PTR [r14+8], rax

; 1440 :         }
; 1441 :     }

	add	rsp, 40					; 00000028H
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN6@Assign_cou:

; 1432 :                 _ASAN_VECTOR_RELEASE_GUARD;
; 1433 :             }
; 1434 :         } else {
; 1435 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rax, QWORD PTR [rsi+rsi*2]
	lea	rbp, QWORD PTR [rbx+rax*8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4572 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	test	rsi, rsi
	je	SHORT $LN62@Assign_cou
$LL63@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rbx, rdi
	je	SHORT $LN61@Assign_cou

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [rdi]
	mov	rcx, rbx
	mov	r8, QWORD PTR [rdi+8]
	sub	r8, rdx
	sar	r8, 5
	imul	r8, r12
	call	??$_Assign_counted_range@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Assign_counted_range<AINBNodeDefMgr::NodeDef::ImmediateParam *>
$LN61@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4572 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	add	rbx, 24
	add	rdi, 24
	sub	rsi, 1
	jne	SHORT $LL63@Assign_cou
$LN62@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1437 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rdi, QWORD PTR [r14+8]
	mov	rbx, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbp, rdi
	je	SHORT $LN70@Assign_cou
	npad	5
$LL71@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	mov	rcx, rbx
	call	?_Tidy@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 24
	cmp	rbx, rdi
	jne	SHORT $LL71@Assign_cou
$LN70@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1439 :             _Mylast = _Newlast;

	mov	QWORD PTR [r14+8], rbp

; 1440 :         }
; 1441 :     }

	add	rsp, 40					; 00000028H
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN114@Assign_cou:

; 1659 :             _Xlength();

	call	?_Xlength@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@CAXXZ ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Xlength
	int	3
$LN112@Assign_cou:
??$_Assign_counted_range@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@_K@Z ENDP ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Assign_counted_range<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >,std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >,1>::_Compressed_pair<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >,std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >,1><>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >,std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >,1>::_Compressed_pair<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >,std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@I@std@@$$V@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@I@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0AEBV?$allocator@I@std@@$$V@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@I@1@@Z PROC ; std::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1><std::allocator<unsigned int> const &>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0AEBV?$allocator@I@std@@$$V@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@I@1@@Z ENDP ; std::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1><std::allocator<unsigned int> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Construct_n@$$V@?$vector@IV?$allocator@I@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
??$_Construct_n@$$V@?$vector@IV?$allocator@I@std@@@std@@AEAAX_K@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Construct_n<>, COMDAT

; 2056 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

$LN45:

; 2057 :         // Dispatches between the three sized constructions.
; 2058 :         // 1-arg -> value-construction, e.g. vector(5)
; 2059 :         // 2-arg -> fill, e.g. vector(5, "meow")
; 2060 :         // 3-arg -> sized range construction, e.g. vector{"Hello", "Fluffy", "World"}
; 2061 :         auto& _Al       = _Getal();
; 2062 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2063 :         auto& _My_data  = _Mypair._Myval2;
; 2064 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2065 :         if (_Count != 0) {

	test	rdx, rdx
	je	SHORT $LN41@Construct_
	mov	QWORD PTR [rsp+32], rbx
	push	rsi
	sub	rsp, 32					; 00000020H

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 4611686018427387903		; 3fffffffffffffffH

; 2056 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

	mov	rbx, rdx
	mov	rsi, rcx

; 2006 :         if (_Newcapacity > max_size()) {

	cmp	rdx, rax
	ja	SHORT $LN43@Construct_
	mov	QWORD PTR [rsp+64], rdi

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	call	?allocate@?$allocator@I@std@@QEAAPEAI_K@Z ; std::allocator<unsigned int>::allocate

; 1990 :         _Myfirst           = _Newvec;
; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rbx, QWORD PTR [rbx*4]
	mov	QWORD PTR [rsi], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	r8, rbx
	xor	edx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdi, rax

; 1990 :         _Myfirst           = _Newvec;
; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [rbx+rax]
	mov	QWORD PTR [rsi+16], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	rcx, rax
	call	memset

; 2036 :             return _First + _Count;

	lea	rax, QWORD PTR [rbx+rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2069 :                 _My_data._Mylast = _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);

	mov	rdi, QWORD PTR [rsp+64]

; 2070 :             } else if constexpr (sizeof...(_Val) == 1) {
; 2071 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Valty..., const _Ty&>);
; 2072 :                 _My_data._Mylast = _Uninitialized_fill_n(_My_data._Myfirst, _Count, _Val..., _Al);
; 2073 :             } else if constexpr (sizeof...(_Val) == 2) {
; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);
; 2075 :             } else {
; 2076 :                 static_assert(_Always_false<_Ty>, "Should be unreachable");
; 2077 :             }
; 2078 :             _ASAN_VECTOR_CREATE;
; 2079 :             _Guard._Target = nullptr;
; 2080 :         }
; 2081 : 
; 2082 :         _Proxy._Release();
; 2083 :     }

	mov	rbx, QWORD PTR [rsp+72]
	mov	QWORD PTR [rsi+8], rax
	add	rsp, 32					; 00000020H
	pop	rsi
$LN41@Construct_:
	ret	0
$LN43@Construct_:

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@IV?$allocator@I@std@@@std@@CAXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlength
	int	3
$LN40@Construct_:
??$_Construct_n@$$V@?$vector@IV?$allocator@I@std@@@std@@AEAAX_K@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Construct_n<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Emplace_one_at_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV21@@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$_Emplace_one_at_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV21@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_one_at_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 776  :     _CONSTEXPR20 _Ty& _Emplace_one_at_back(_Valty&&... _Val) {

	mov	r8, rdx
	mov	r9, rcx

; 777  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 778  :         auto& _My_data   = _Mypair._Myval2;
; 779  :         pointer& _Mylast = _My_data._Mylast;
; 780  : 
; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rcx+8]
	cmp	rdx, QWORD PTR [rcx+16]
	je	SHORT $LN2@Emplace_on
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rdx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rdx+16], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rdx+24], rax

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [rdx], xmm0
	movups	xmm1, XMMWORD PTR [r8+16]
	movups	XMMWORD PTR [rdx+16], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [r8+16], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [r8+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [r8], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 805  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR [rcx+8]

; 806  :         ++_Mylast;

	lea	rcx, QWORD PTR [rax+32]
	mov	QWORD PTR [r9+8], rcx

; 786  :     }

	ret	0
$LN2@Emplace_on:

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@$$QEAV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
??$_Emplace_one_at_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV21@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_one_at_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEAV10@@Z PROC ; std::addressof<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEAV10@@Z ENDP ; std::addressof<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z@_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAX_W@Z@_W@Z
_TEXT	SEGMENT
this$ = 80
_Size_increase$dead$ = 88
_Fn$dead$ = 96
<_Args_0>$ = 104
??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z@_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAX_W@Z@_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<`std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::push_back'::`2'::<lambda_1>,wchar_t>, COMDAT

; 4761 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

$LN74:
	push	rbx
	push	rdi
	push	r14
	push	r15
	sub	rsp, 40					; 00000028H

; 4762 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4763 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4764 :         auto& _My_data            = _Mypair._Myval2;
; 4765 :         const size_type _Old_size = _My_data._Mysize;

	mov	r14, QWORD PTR [rcx+16]

; 4766 :         if (max_size() - _Old_size < _Size_increase) {

	mov	rbx, 9223372036854775806		; 7ffffffffffffffeH
	mov	rax, rbx
	movzx	r15d, r9w
	sub	rax, r14
	mov	rdi, rcx
	cmp	rax, 1
	jb	$LN72@Reallocate

; 4768 :         }
; 4769 : 
; 4770 :         const size_type _New_size     = _Old_size + _Size_increase;
; 4771 :         const size_type _Old_capacity = _My_data._Myres;

	mov	QWORD PTR [rsp+88], rbp
	mov	rbp, QWORD PTR [rcx+24]
	mov	QWORD PTR [rsp+96], rsi
	mov	QWORD PTR [rsp+32], r12
	lea	r12, QWORD PTR [r14+1]

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rdx, r12
	or	rdx, 7
	cmp	rdx, rbx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN8@Reallocate

; 4716 :             return _Max;
; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	rcx, rbp
	mov	rax, rbx
	shr	rcx, 1
	sub	rax, rcx
	cmp	rbp, rax
	ja	SHORT $LN8@Reallocate

; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	rax, QWORD PTR [rcx+rbp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	mov	rbx, rdx
	cmp	rdx, rax
	cmovb	rbx, rax
$LN8@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4774 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	rdx, QWORD PTR [rbx+1]
	call	?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z ; std::allocator<wchar_t>::allocate

; 4775 : 
; 4776 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 4777 :         _My_data._Orphan_all();
; 4778 :         _ASAN_STRING_REMOVE(*this);
; 4779 :         _My_data._Mysize      = _New_size;
; 4780 :         _My_data._Myres       = _New_capacity;

	add	r14, r14
	mov	QWORD PTR [rdi+16], r12
	mov	r12, QWORD PTR [rsp+32]
	mov	rsi, rax
	mov	QWORD PTR [rdi+24], rbx

; 4781 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4782 :         if (_BUF_SIZE <= _Old_capacity) {

	mov	r8, r14
	mov	rcx, rax
	cmp	rbp, 8
	jb	SHORT $LN3@Reallocate

; 4783 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	rbx, QWORD PTR [rdi]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rbx
	call	memcpy

; 4061 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

	xor	eax, eax
	mov	WORD PTR [r14+rsi], r15w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rbp*2+2]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4061 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

	mov	WORD PTR [r14+rsi+2], ax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN38@Reallocate

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rbx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rbx, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rbx-8]
	cmp	rax, 31
	ja	SHORT $LN35@Reallocate

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rbx, rcx
$LN38@Reallocate:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4787 :         } else {

	jmp	SHORT $LN4@Reallocate
$LN35@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN3@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rdi
	call	memcpy

; 4061 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

	xor	eax, eax
	mov	WORD PTR [r14+rsi], r15w
	mov	WORD PTR [r14+rsi+2], ax
$LN4@Reallocate:

; 4788 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);
; 4789 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);
; 4790 :         }
; 4791 : 
; 4792 :         _ASAN_STRING_CREATE(*this);
; 4793 :         return *this;

	mov	QWORD PTR [rdi], rsi
	mov	rax, rdi
	mov	rbp, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]

; 4794 :     }

	add	rsp, 40					; 00000028H
	pop	r15
	pop	r14
	pop	rdi
	pop	rbx
	ret	0
$LN72@Reallocate:

; 4767 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN70@Reallocate:
??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_W@Z@_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAX_W@Z@_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<`std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::push_back'::`2'::<lambda_1>,wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@$$CBV?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@_W@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@_W@std@@@0@AEBV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > const >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@$$CBV?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@_W@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@_W@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@_W@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@_W@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEB_W0@Z@PEB_W_K@Z
_TEXT	SEGMENT
<_Args_0>$GSCopy$1$ = 32
this$ = 112
_Size_increase$ = 120
_Fn$dead$ = 128
<_Args_0>$ = 136
<_Args_1>$ = 144
??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEB_W0@Z@PEB_W_K@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<`std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append'::`2'::<lambda_1>,wchar_t const *,unsigned __int64>, COMDAT

; 4761 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

$LN100:
	mov	r11, rsp
	push	rbx
	push	rdi
	push	r13
	push	r14
	sub	rsp, 72					; 00000048H

; 4762 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4763 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4764 :         auto& _My_data            = _Mypair._Myval2;
; 4765 :         const size_type _Old_size = _My_data._Mysize;

	mov	r14, QWORD PTR [rcx+16]

; 4766 :         if (max_size() - _Old_size < _Size_increase) {

	mov	rbx, 9223372036854775806		; 7ffffffffffffffeH
	mov	r13, QWORD PTR <_Args_1>$[rsp]
	mov	rax, rbx
	sub	rax, r14
	mov	QWORD PTR <_Args_0>$GSCopy$1$[rsp], r9
	mov	rdi, rcx
	cmp	rax, rdx
	jb	$LN98@Reallocate

; 4768 :         }
; 4769 : 
; 4770 :         const size_type _New_size     = _Old_size + _Size_increase;
; 4771 :         const size_type _Old_capacity = _My_data._Myres;

	mov	QWORD PTR [r11+24], rbp
	mov	rbp, QWORD PTR [rcx+24]
	mov	QWORD PTR [r11-40], rsi
	mov	QWORD PTR [r11-48], r12
	mov	QWORD PTR [r11-56], r15
	lea	r15, QWORD PTR [rdx+r14]

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rdx, r15
	or	rdx, 7
	cmp	rdx, rbx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN8@Reallocate

; 4716 :             return _Max;
; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	rcx, rbp
	mov	rax, rbx
	shr	rcx, 1
	sub	rax, rcx
	cmp	rbp, rax
	ja	SHORT $LN8@Reallocate

; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	rax, QWORD PTR [rcx+rbp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	mov	rbx, rdx
	cmp	rdx, rax
	cmovb	rbx, rax
$LN8@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4774 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	rdx, QWORD PTR [rbx+1]
	call	?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z ; std::allocator<wchar_t>::allocate

; 4775 : 
; 4776 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 4777 :         _My_data._Orphan_all();
; 4778 :         _ASAN_STRING_REMOVE(*this);
; 4779 :         _My_data._Mysize      = _New_size;

	mov	QWORD PTR [rdi+16], r15
	mov	rsi, rax

; 4780 :         _My_data._Myres       = _New_capacity;

	mov	QWORD PTR [rdi+24], rbx
	lea	r8, QWORD PTR [r14+r14]
	lea	r15, QWORD PTR [r13*2]

; 4781 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4782 :         if (_BUF_SIZE <= _Old_capacity) {

	mov	rcx, rsi
	lea	r12, QWORD PTR [rax+r8]
	lea	rax, QWORD PTR [r14+r13]
	lea	r14, QWORD PTR [rsi+rax*2]
	cmp	rbp, 8
	jb	SHORT $LN3@Reallocate

; 4783 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	rbx, QWORD PTR [rdi]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rbx
	call	memcpy
	mov	rdx, QWORD PTR <_Args_0>$GSCopy$1$[rsp]
	mov	r8, r15
	mov	rcx, r12
	call	memcpy

; 3286 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	xor	eax, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rbp*2+2]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3286 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	WORD PTR [r14], ax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN44@Reallocate

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rbx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rbx, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rbx-8]
	cmp	rax, 31
	ja	SHORT $LN41@Reallocate

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rbx, rcx
$LN44@Reallocate:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4787 :         } else {

	jmp	SHORT $LN4@Reallocate
$LN41@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN3@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rdi
	call	memcpy
	mov	rdx, QWORD PTR <_Args_0>$GSCopy$1$[rsp]
	mov	r8, r15
	mov	rcx, r12
	call	memcpy

; 3286 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	xor	eax, eax
	mov	WORD PTR [r14], ax
$LN4@Reallocate:

; 4788 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);
; 4789 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);
; 4790 :         }
; 4791 : 
; 4792 :         _ASAN_STRING_CREATE(*this);
; 4793 :         return *this;

	mov	QWORD PTR [rdi], rsi
	mov	rax, rdi
	mov	r12, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+128]
	mov	r15, QWORD PTR [rsp+48]

; 4794 :     }

	add	rsp, 72					; 00000048H
	pop	r14
	pop	r13
	pop	rdi
	pop	rbx
	ret	0
$LN98@Reallocate:

; 4767 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN96@Reallocate:
??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEB_W0@Z@PEB_W_K@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<`std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append'::`2'::<lambda_1>,wchar_t const *,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@@Z PROC ; std::addressof<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@@Z ENDP ; std::addressof<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Pocca@V?$allocator@_W@std@@@std@@YAXAEAV?$allocator@_W@0@AEBV10@@Z
_TEXT	SEGMENT
_Left$dead$ = 8
_Right$dead$ = 16
??$_Pocca@V?$allocator@_W@std@@@std@@YAXAEAV?$allocator@_W@0@AEBV10@@Z PROC ; std::_Pocca<std::allocator<wchar_t> >, COMDAT

; 1060 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 1061 :         _Left = _Right;
; 1062 :     }
; 1063 : }

	ret	0
??$_Pocca@V?$allocator@_W@std@@@std@@YAXAEAV?$allocator@_W@0@AEBV10@@Z ENDP ; std::_Pocca<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Pocma@V?$allocator@_W@std@@@std@@YAXAEAV?$allocator@_W@0@0@Z
_TEXT	SEGMENT
_Left$dead$ = 8
_Right$dead$ = 16
??$_Pocma@V?$allocator@_W@std@@@std@@YAXAEAV?$allocator@_W@0@0@Z PROC ; std::_Pocma<std::allocator<wchar_t> >, COMDAT

; 1067 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_move_assignment::value) {
; 1068 :         _Left = _STD move(_Right);
; 1069 :     }
; 1070 : }

	ret	0
??$_Pocma@V?$allocator@_W@std@@@std@@YAXAEAV?$allocator@_W@0@0@Z ENDP ; std::_Pocma<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z PROC ; std::move<std::allocator<wchar_t> &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAV?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z ENDP ; std::move<std::allocator<wchar_t> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@_W@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@_W@1@@Z PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@_W@1@@Z ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z
_TEXT	SEGMENT
this$ = 80
_Arg$ = 88
_Count$ = 96
??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<1,wchar_t const *>, COMDAT

; 2610 :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN44:
	push	rbx
	push	rbp
	push	rsi
	push	r14
	sub	rsp, 40					; 00000028H

; 2611 :         auto& _My_data = _Mypair._Myval2;
; 2612 :         _STL_INTERNAL_CHECK(!_My_data._Large_string_engaged());
; 2613 : 
; 2614 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2615 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 2616 :         } else {
; 2617 :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 2618 :         }
; 2619 : 
; 2620 :         if (_Count > max_size()) {

	mov	rsi, 9223372036854775806		; 7ffffffffffffffeH
	mov	rbx, r8
	mov	rbp, rdx
	mov	r14, rcx
	cmp	r8, rsi
	ja	$LN42@Construct

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR [rcx+24], 7
	cmp	rbx, 8
	jae	SHORT $LN3@Construct

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR [rcx+16], rbx

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	add	rbx, rbx
	mov	r8, rbx
	call	memcpy

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;
; 2631 : 
; 2632 :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2633 :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 2634 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2635 :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2636 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);
; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	xor	eax, eax
	mov	WORD PTR [rbx+r14], ax

; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 2667 :         }
; 2668 : 
; 2669 :         _ASAN_STRING_CREATE(*this);
; 2670 :         _Proxy._Release();
; 2671 :     }

	add	rsp, 40					; 00000028H
	pop	r14
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN3@Construct:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rax, rbx
	mov	QWORD PTR [rsp+32], rdi
	or	rax, 7
	cmp	rax, rsi

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN13@Construct
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	mov	ecx, 10
	mov	rsi, rax
	cmp	rax, rcx
	cmovb	rsi, rcx
$LN13@Construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	rdx, QWORD PTR [rsi+1]
	call	?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z ; std::allocator<wchar_t>::allocate

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR [r14+16], rbx

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rbp
	add	rbx, rbx

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR [r14], rax

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rbx

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR [r14+24], rsi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rcx, rax

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdi, rax

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	xor	eax, eax
	mov	WORD PTR [rbx+rdi], ax
	mov	rdi, QWORD PTR [rsp+32]

; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 2667 :         }
; 2668 : 
; 2669 :         _ASAN_STRING_CREATE(*this);
; 2670 :         _Proxy._Release();
; 2671 :     }

	add	rsp, 40					; 00000028H
	pop	r14
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN42@Construct:

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN40@Construct:
??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<1,wchar_t const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??$_Construct@$01PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z
_TEXT	SEGMENT
this$ = 64
_Arg$ = 72
_Count$ = 80
??$_Construct@$01PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<2,wchar_t const *>, COMDAT

; 2610 :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN49:
	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 2611 :         auto& _My_data = _Mypair._Myval2;
; 2612 :         _STL_INTERNAL_CHECK(!_My_data._Large_string_engaged());
; 2613 : 
; 2614 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2615 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 2616 :         } else {
; 2617 :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 2618 :         }
; 2619 : 
; 2620 :         if (_Count > max_size()) {

	mov	rdi, 9223372036854775806		; 7ffffffffffffffeH
	mov	rsi, r8
	mov	rbp, rdx
	mov	rbx, rcx
	cmp	r8, rdi
	ja	SHORT $LN47@Construct

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR [rcx+24], 7
	cmp	r8, 8
	jae	SHORT $LN3@Construct

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR [rcx+16], r8

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 2667 :         }
; 2668 : 
; 2669 :         _ASAN_STRING_CREATE(*this);
; 2670 :         _Proxy._Release();
; 2671 :     }

	mov	rbx, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN3@Construct:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rax, rsi
	or	rax, 7
	cmp	rax, rdi

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN13@Construct
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	mov	ecx, 10
	mov	rdi, rax
	cmp	rax, rcx
	cmovb	rdi, rcx
$LN13@Construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	rdx, QWORD PTR [rdi+1]
	call	?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z ; std::allocator<wchar_t>::allocate

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	lea	r8, QWORD PTR [rsi*2+2]

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR [rbx], rax

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rbp

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR [rbx+16], rsi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rcx, rax

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR [rbx+24], rdi

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 2667 :         }
; 2668 : 
; 2669 :         _ASAN_STRING_CREATE(*this);
; 2670 :         _Proxy._Release();
; 2671 :     }

	mov	rbx, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbp

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	jmp	memcpy
$LN47@Construct:

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN45@Construct:
??$_Construct@$01PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<2,wchar_t const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??reserve@01@QEAAX0@Z@@Z
_TEXT	SEGMENT
this$ = 80
_Size_increase$ = 88
_Fn$dead$ = 96
??$_Reallocate_grow_by@V<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??reserve@01@QEAAX0@Z@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve'::`2'::<lambda_1> >, COMDAT

; 4761 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

$LN104:
	push	rbx
	push	rsi
	push	r14
	sub	rsp, 48					; 00000030H

; 4762 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4763 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4764 :         auto& _My_data            = _Mypair._Myval2;
; 4765 :         const size_type _Old_size = _My_data._Mysize;

	mov	r14, QWORD PTR [rcx+16]

; 4766 :         if (max_size() - _Old_size < _Size_increase) {

	mov	rbx, 9223372036854775807		; 7fffffffffffffffH
	mov	rax, rbx
	mov	rsi, rcx
	sub	rax, r14
	cmp	rax, rdx
	jb	$LN101@Reallocate

; 4768 :         }
; 4769 : 
; 4770 :         const size_type _New_size     = _Old_size + _Size_increase;
; 4771 :         const size_type _Old_capacity = _My_data._Myres;

	mov	QWORD PTR [rsp+96], rbp
	mov	rbp, QWORD PTR [rcx+24]
	mov	QWORD PTR [rsp+32], r15
	lea	r15, QWORD PTR [rdx+r14]

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rdx, r15
	or	rdx, 15
	cmp	rdx, rbx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN8@Reallocate

; 4716 :             return _Max;
; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	rcx, rbp
	mov	rax, rbx
	shr	rcx, 1
	sub	rax, rcx
	cmp	rbp, rax
	ja	SHORT $LN8@Reallocate

; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	rax, QWORD PTR [rcx+rbp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	mov	rbx, rdx
	cmp	rdx, rax
	cmovb	rbx, rax
$LN8@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4774 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rcx, rbx
	mov	QWORD PTR [rsp+40], rdi
	add	rcx, 1
	mov	rax, -1
	cmovb	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN18@Reallocate

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	$LN102@Reallocate

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN60@Reallocate

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN16@Reallocate
$LN18@Reallocate:

; 240  :         }
; 241  :     }
; 242  : #endif // defined(_M_IX86) || defined(_M_X64)
; 243  : 
; 244  :     if (_Bytes != 0) {

	test	rcx, rcx
	je	SHORT $LN19@Reallocate

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax

; 245  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN16@Reallocate
$LN19@Reallocate:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

	xor	edi, edi
$LN16@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4779 :         _My_data._Mysize      = _New_size;

	mov	QWORD PTR [rsi+16], r15

; 4780 :         _My_data._Myres       = _New_capacity;
; 4781 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

	lea	r8, QWORD PTR [r14+1]
	mov	QWORD PTR [rsi+24], rbx

; 4782 :         if (_BUF_SIZE <= _Old_capacity) {

	mov	rcx, rdi
	cmp	rbp, 16
	jb	SHORT $LN3@Reallocate

; 4783 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	rbx, QWORD PTR [rsi]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rbx
	call	memcpy

; 4784 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
; 4785 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

	lea	rdx, QWORD PTR [rbp+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN63@Reallocate

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rbx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rbx, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rbx-8]
	cmp	rax, 31
	ja	SHORT $LN60@Reallocate

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rbx, rcx
$LN63@Reallocate:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4787 :         } else {

	jmp	SHORT $LN4@Reallocate
$LN60@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN3@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rsi
	call	memcpy
$LN4@Reallocate:

; 4788 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);
; 4789 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);
; 4790 :         }
; 4791 : 
; 4792 :         _ASAN_STRING_CREATE(*this);
; 4793 :         return *this;

	mov	QWORD PTR [rsi], rdi
	mov	rax, rsi
	mov	rdi, QWORD PTR [rsp+40]
	mov	rbp, QWORD PTR [rsp+96]
	mov	r15, QWORD PTR [rsp+32]

; 4794 :     }

	add	rsp, 48					; 00000030H
	pop	r14
	pop	rsi
	pop	rbx
	ret	0
$LN102@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN101@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4767 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN99@Reallocate:
??$_Reallocate_grow_by@V<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??reserve@01@QEAAX0@Z@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve'::`2'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@YAXPEAUNodeDef@AINBNodeDefMgr@@QEAU12@AEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Al$dead$ = 64
??$_Destroy_range@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@YAXPEAUNodeDef@AINBNodeDefMgr@@QEAU12@AEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@0@@Z PROC ; std::_Destroy_range<std::allocator<AINBNodeDefMgr::NodeDef> >, COMDAT

; 1082 : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

$LN21:

; 1083 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1084 :     using _Ty = typename _Alloc::value_type;
; 1085 :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rcx, rdx
	je	SHORT $LN18@Destroy_ra
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1082 : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

	mov	rdi, rdx
	mov	rbx, rcx
$LL4@Destroy_ra:

; 1083 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1084 :     using _Ty = typename _Alloc::value_type;
; 1085 :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 1086 :         for (; _First != _Last; ++_First) {

	mov	rcx, rbx
	call	??1NodeDef@AINBNodeDefMgr@@QEAA@XZ
	add	rbx, 248				; 000000f8H
	cmp	rbx, rdi
	jne	SHORT $LL4@Destroy_ra

; 1087 :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 1088 :         }
; 1089 :     }
; 1090 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
$LN18@Destroy_ra:
	ret	0
??$_Destroy_range@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@YAXPEAUNodeDef@AINBNodeDefMgr@@QEAU12@AEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<AINBNodeDefMgr::NodeDef> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@@std@@YAXPEAU_Find_file_handle@filesystem@0@QEAU120@AEAV?$allocator@U_Find_file_handle@filesystem@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Al$dead$ = 64
??$_Destroy_range@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@@std@@YAXPEAU_Find_file_handle@filesystem@0@QEAU120@AEAV?$allocator@U_Find_file_handle@filesystem@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::filesystem::_Find_file_handle> >, COMDAT

; 1082 : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

$LN23:

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rcx, rdx
	je	SHORT $LN20@Destroy_ra
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1082 : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

	mov	rdi, rdx
	mov	rbx, rcx
$LL4@Destroy_ra:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 605  :             __std_fs_directory_iterator_close(_Handle);

	mov	rcx, QWORD PTR [rbx]
	call	__std_fs_directory_iterator_close
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 8
	cmp	rbx, rdi
	jne	SHORT $LL4@Destroy_ra

; 1087 :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 1088 :         }
; 1089 :     }
; 1090 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
$LN20@Destroy_ra:
	ret	0
??$_Destroy_range@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@@std@@YAXPEAU_Find_file_handle@filesystem@0@QEAU120@AEAV?$allocator@U_Find_file_handle@filesystem@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::filesystem::_Find_file_handle> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAXPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@QEAW4123@AEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
??$_Destroy_range@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAXPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@QEAW4123@AEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@0@@Z PROC ; std::_Destroy_range<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >, COMDAT

; 1083 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1084 :     using _Ty = typename _Alloc::value_type;
; 1085 :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 1086 :         for (; _First != _Last; ++_First) {
; 1087 :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 1088 :         }
; 1089 :     }
; 1090 : }

	ret	0
??$_Destroy_range@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAXPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@QEAW4123@AEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YAXPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Al$dead$ = 64
??$_Destroy_range@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YAXPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >, COMDAT

; 1082 : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

$LN23:

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rcx, rdx
	je	SHORT $LN20@Destroy_ra
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1082 : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

	mov	rdi, rdx
	mov	rbx, rcx
$LL4@Destroy_ra:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	mov	rcx, rbx
	call	?_Tidy@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 24
	cmp	rbx, rdi
	jne	SHORT $LL4@Destroy_ra

; 1087 :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 1088 :         }
; 1089 :     }
; 1090 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
$LN20@Destroy_ra:
	ret	0
??$_Destroy_range@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YAXPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YAXPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Al$dead$ = 64
??$_Destroy_range@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YAXPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >, COMDAT

; 1082 : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

$LN23:

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rcx, rdx
	je	SHORT $LN20@Destroy_ra
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1082 : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

	mov	rdi, rdx
	mov	rbx, rcx
$LL4@Destroy_ra:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	mov	rcx, rbx
	call	?_Tidy@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 24
	cmp	rbx, rdi
	jne	SHORT $LL4@Destroy_ra

; 1087 :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 1088 :         }
; 1089 :     }
; 1090 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
$LN20@Destroy_ra:
	ret	0
??$_Destroy_range@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YAXPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEA_W@std@@YAXAEAPEA_W@Z
_TEXT	SEGMENT
_Obj$dead$ = 8
??$_Destroy_in_place@PEA_W@std@@YAXAEAPEA_W@Z PROC	; std::_Destroy_in_place<wchar_t *>, COMDAT

; 305  :     if constexpr (is_array_v<_Ty>) {
; 306  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 307  :     } else {
; 308  :         _Obj.~_Ty();
; 309  :     }
; 310  : }

	ret	0
??$_Destroy_in_place@PEA_W@std@@YAXAEAPEA_W@Z ENDP	; std::_Destroy_in_place<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEB_W0@Z@PEB_W@Z
_TEXT	SEGMENT
this$ = 80
_New_size$ = 88
_Fn$dead$ = 96
<_Args_0>$ = 104
??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEB_W0@Z@PEB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_for<`std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign'::`2'::<lambda_1>,wchar_t const *>, COMDAT

; 4731 :     _CONSTEXPR20 basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

$LN60:
	push	rbx
	push	rdi
	push	r14
	push	r15
	sub	rsp, 40					; 00000028H

; 4732 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 4733 :         // _Fn(_New_ptr, _New_size, _Args...)
; 4734 :         if (_New_size > max_size()) {

	mov	rbx, 9223372036854775806		; 7ffffffffffffffeH
	mov	r15, r9
	mov	r14, rdx
	mov	rdi, rcx
	cmp	rdx, rbx
	ja	$LN58@Reallocate

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	or	rdx, 7
	mov	QWORD PTR [rsp+96], rbp
	mov	QWORD PTR [rsp+32], rsi

; 4736 :         }
; 4737 : 
; 4738 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

	mov	rsi, QWORD PTR [rcx+24]

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	cmp	rdx, rbx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN8@Reallocate

; 4716 :             return _Max;
; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	rcx, rsi
	mov	rax, rbx
	shr	rcx, 1
	sub	rax, rcx
	cmp	rsi, rax
	ja	SHORT $LN8@Reallocate

; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	rax, QWORD PTR [rcx+rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	mov	rbx, rdx
	cmp	rdx, rax
	cmovb	rbx, rax
$LN8@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4741 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	rdx, QWORD PTR [rbx+1]
	call	?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z ; std::allocator<wchar_t>::allocate

; 4747 :         _Mypair._Myval2._Myres  = _New_capacity;

	mov	QWORD PTR [rdi+24], rbx

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r15
	lea	rbx, QWORD PTR [r14+r14]

; 4742 : 
; 4743 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 4744 :         _Mypair._Myval2._Orphan_all();
; 4745 :         _ASAN_STRING_REMOVE(*this);
; 4746 :         _Mypair._Myval2._Mysize = _New_size;

	mov	QWORD PTR [rdi+16], r14

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rbx
	mov	rcx, rax

; 4741 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rbp, rax

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy

; 3389 :                 _Traits::assign(_New_ptr[_Count], _Elem());

	xor	eax, eax
	mov	WORD PTR [rbx+rbp], ax

; 4748 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);
; 4749 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	rsi, 8
	jb	SHORT $LN3@Reallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]
	lea	rdx, QWORD PTR [rsi*2+2]

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN38@Reallocate

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN35@Reallocate

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN38@Reallocate:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN3@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4757 :         return *this;

	mov	QWORD PTR [rdi], rbp
	mov	rax, rdi
	mov	rbp, QWORD PTR [rsp+96]
	mov	rsi, QWORD PTR [rsp+32]

; 4758 :     }

	add	rsp, 40					; 00000028H
	pop	r15
	pop	r14
	pop	rdi
	pop	rbx
	ret	0
$LN35@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN58@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4735 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN56@Reallocate:
??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEB_W0@Z@PEB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_for<`std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign'::`2'::<lambda_1>,wchar_t const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\wchar.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\wchar.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\wchar.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\wchar.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@_K_W@Z@_K_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@0_W@Z@_K_W@Z
_TEXT	SEGMENT
this$ = 96
_Size_increase$ = 104
_Fn$dead$ = 112
<_Args_0>$ = 120
<_Args_1>$dead$ = 128
??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@_K_W@Z@_K_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@0_W@Z@_K_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<`std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append'::`2'::<lambda_1>,unsigned __int64,wchar_t>, COMDAT

; 4761 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

$LN141:
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 56					; 00000038H

; 4762 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4763 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4764 :         auto& _My_data            = _Mypair._Myval2;
; 4765 :         const size_type _Old_size = _My_data._Mysize;

	mov	r12, QWORD PTR [rcx+16]

; 4766 :         if (max_size() - _Old_size < _Size_increase) {

	mov	rdi, 9223372036854775806		; 7ffffffffffffffeH
	mov	rax, rdi
	mov	r15, r9
	sub	rax, r12
	mov	r14, rcx
	cmp	rax, rdx
	jb	$LN139@Reallocate

; 4768 :         }
; 4769 : 
; 4770 :         const size_type _New_size     = _Old_size + _Size_increase;

	mov	QWORD PTR [rsp+48], rbx
	lea	rbx, QWORD PTR [rdx+r12]
	mov	QWORD PTR [rsp+40], rbp

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rdx, rbx

; 4771 :         const size_type _Old_capacity = _My_data._Myres;

	mov	rbp, QWORD PTR [rcx+24]

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	or	rdx, 7
	mov	QWORD PTR [rsp+32], rsi
	cmp	rdx, rdi

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN8@Reallocate

; 4716 :             return _Max;
; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	rcx, rbp
	mov	rax, rdi
	shr	rcx, 1
	sub	rax, rcx
	cmp	rbp, rax
	ja	SHORT $LN8@Reallocate

; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	rax, QWORD PTR [rcx+rbp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	mov	rdi, rdx
	cmp	rdx, rax
	cmovb	rdi, rax
$LN8@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4774 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	rdx, QWORD PTR [rdi+1]
	call	?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z ; std::allocator<wchar_t>::allocate

; 4775 : 
; 4776 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 4777 :         _My_data._Orphan_all();
; 4778 :         _ASAN_STRING_REMOVE(*this);
; 4779 :         _My_data._Mysize      = _New_size;
; 4780 :         _My_data._Myres       = _New_capacity;

	mov	QWORD PTR [r14+24], rdi
	lea	rdi, QWORD PTR [r12+r12]
	mov	QWORD PTR [r14+16], rbx

; 4781 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4782 :         if (_BUF_SIZE <= _Old_capacity) {

	mov	r8, rdi
	mov	rsi, rax
	mov	rcx, rax
	cmp	rbp, 8
	jb	SHORT $LN3@Reallocate

; 4783 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	rbx, QWORD PTR [r14]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rbx
	call	memcpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\wchar.h

; 259  :         for (; 0 < _N; ++_Su, --_N)

	xor	edx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3312 :                 _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);

	add	rdi, rsi
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\wchar.h

; 259  :         for (; 0 < _N; ++_Su, --_N)

	test	r15, r15
	je	SHORT $LN40@Reallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4783 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	movzx	eax, dx
	mov	rcx, r15
	rep stosw
$LN40@Reallocate:

; 3313 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	lea	rax, QWORD PTR [r15+r12]
	mov	WORD PTR [rsi+rax*2], dx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rbp*2+2]

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN58@Reallocate

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rbx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rbx, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rbx-8]
	cmp	rax, 31
	ja	SHORT $LN55@Reallocate

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rbx, rcx
$LN58@Reallocate:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4787 :         } else {

	jmp	SHORT $LN4@Reallocate
$LN55@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN3@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14
	call	memcpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\wchar.h

; 259  :         for (; 0 < _N; ++_Su, --_N)

	xor	edx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3312 :                 _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);

	add	rdi, rsi
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\wchar.h

; 259  :         for (; 0 < _N; ++_Su, --_N)

	test	r15, r15
	je	SHORT $LN88@Reallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movzx	eax, dx
	mov	rcx, r15
	rep stosw
$LN88@Reallocate:

; 3313 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	lea	rcx, QWORD PTR [r15+r12]
	mov	WORD PTR [rsi+rcx*2], dx
$LN4@Reallocate:

; 4788 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);
; 4789 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);
; 4790 :         }
; 4791 : 
; 4792 :         _ASAN_STRING_CREATE(*this);
; 4793 :         return *this;

	mov	QWORD PTR [r14], rsi
	mov	rax, r14
	mov	rbp, QWORD PTR [rsp+40]
	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+32]

; 4794 :     }

	add	rsp, 56					; 00000038H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	ret	0
$LN139@Reallocate:

; 4767 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN137@Reallocate:
??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@_K_W@Z@_K_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@0_W@Z@_K_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<`std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append'::`2'::<lambda_1>,unsigned __int64,wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Construct_in_place@PEA_WAEAPEA_W@std@@YAXAEAPEA_W0@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@PEA_WAEAPEA_W@std@@YAXAEAPEA_W0@Z PROC ; std::_Construct_in_place<wchar_t *,wchar_t * &>, COMDAT

; 248  : #if _HAS_CXX20
; 249  :     if (_STD is_constant_evaluated()) {
; 250  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 251  :     } else
; 252  : #endif // _HAS_CXX20
; 253  :     {
; 254  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 255  :     }
; 256  : }

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	ret	0
??$_Construct_in_place@PEA_WAEAPEA_W@std@@YAXAEAPEA_W0@Z ENDP ; std::_Construct_in_place<wchar_t *,wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KD@Z@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@0D@Z@_KD@Z
_TEXT	SEGMENT
this$ = 96
_Size_increase$ = 104
_Fn$dead$ = 112
<_Args_0>$ = 120
<_Args_1>$dead$ = 128
??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KD@Z@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@0D@Z@_KD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,unsigned __int64,char>, COMDAT

; 4761 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

$LN151:
	push	rbx
	push	rsi
	push	r12
	push	r15
	sub	rsp, 56					; 00000038H

; 4762 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4763 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4764 :         auto& _My_data            = _Mypair._Myval2;
; 4765 :         const size_type _Old_size = _My_data._Mysize;

	mov	r15, QWORD PTR [rcx+16]

; 4766 :         if (max_size() - _Old_size < _Size_increase) {

	mov	rbx, 9223372036854775807		; 7fffffffffffffffH
	mov	rax, rbx
	mov	r12, r9
	sub	rax, r15
	mov	rsi, rcx
	cmp	rax, rdx
	jb	$LN148@Reallocate

; 4768 :         }
; 4769 : 
; 4770 :         const size_type _New_size     = _Old_size + _Size_increase;

	mov	QWORD PTR [rsp+112], rbp
	lea	rbp, QWORD PTR [rdx+r15]

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rdx, rbp
	mov	QWORD PTR [rsp+40], r13

; 4771 :         const size_type _Old_capacity = _My_data._Myres;

	mov	r13, QWORD PTR [rcx+24]

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	or	rdx, 15
	cmp	rdx, rbx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN8@Reallocate

; 4716 :             return _Max;
; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	rcx, r13
	mov	rax, rbx
	shr	rcx, 1
	sub	rax, rcx
	cmp	r13, rax
	ja	SHORT $LN8@Reallocate

; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	rax, QWORD PTR [rcx+r13]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	mov	rbx, rdx
	cmp	rdx, rax
	cmovb	rbx, rax
$LN8@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4774 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rcx, rbx
	mov	QWORD PTR [rsp+48], rdi
	add	rcx, 1
	mov	QWORD PTR [rsp+32], r14
	mov	rax, -1
	cmovb	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN18@Reallocate

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	$LN149@Reallocate

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN75@Reallocate

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN16@Reallocate
$LN18@Reallocate:

; 240  :         }
; 241  :     }
; 242  : #endif // defined(_M_IX86) || defined(_M_X64)
; 243  : 
; 244  :     if (_Bytes != 0) {

	test	rcx, rcx
	je	SHORT $LN19@Reallocate

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax

; 245  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN16@Reallocate
$LN19@Reallocate:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

	xor	edi, edi
$LN16@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4779 :         _My_data._Mysize      = _New_size;

	mov	QWORD PTR [rsi+16], rbp

; 4780 :         _My_data._Myres       = _New_capacity;

	lea	rbp, QWORD PTR [rdi+r15]
	mov	QWORD PTR [rsi+24], rbx
	lea	r14, QWORD PTR [rdi+r12]

; 4781 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4782 :         if (_BUF_SIZE <= _Old_capacity) {

	mov	r8, r15
	mov	rcx, rdi
	cmp	r13, 16
	jb	SHORT $LN3@Reallocate

; 4783 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	rbx, QWORD PTR [rsi]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rbx
	call	memcpy

; 437  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

	mov	r8, r12
	xor	edx, edx
	mov	rcx, rbp
	call	memset

; 4784 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
; 4785 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

	lea	rdx, QWORD PTR [r13+1]

; 3313 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [r14+r15], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN78@Reallocate

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rbx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rbx, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rbx-8]
	cmp	rax, 31
	ja	SHORT $LN75@Reallocate

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rbx, rcx
$LN78@Reallocate:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4787 :         } else {

	jmp	SHORT $LN4@Reallocate
$LN75@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN3@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rsi
	call	memcpy

; 437  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

	mov	r8, r12
	xor	edx, edx
	mov	rcx, rbp
	call	memset

; 3313 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [r14+r15], 0
$LN4@Reallocate:

; 4788 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);
; 4789 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);
; 4790 :         }
; 4791 : 
; 4792 :         _ASAN_STRING_CREATE(*this);
; 4793 :         return *this;

	mov	QWORD PTR [rsi], rdi
	mov	rax, rsi
	mov	rdi, QWORD PTR [rsp+48]
	mov	r14, QWORD PTR [rsp+32]
	mov	rbp, QWORD PTR [rsp+112]
	mov	r13, QWORD PTR [rsp+40]

; 4794 :     }

	add	rsp, 56					; 00000038H
	pop	r15
	pop	r12
	pop	rsi
	pop	rbx
	ret	0
$LN149@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN148@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4767 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN146@Reallocate:
??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KD@Z@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@0D@Z@_KD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,unsigned __int64,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$swap@PEAU_Recursive_dir_enum_impl@filesystem@std@@$0A@@std@@YAXAEAPEAU_Recursive_dir_enum_impl@filesystem@0@0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$swap@PEAU_Recursive_dir_enum_impl@filesystem@std@@$0A@@std@@YAXAEAPEAU_Recursive_dir_enum_impl@filesystem@0@0@Z PROC ; std::swap<std::filesystem::_Recursive_dir_enum_impl *,0>, COMDAT

; 99   :     _Ty _Tmp = _STD move(_Left);
; 100  :     _Left    = _STD move(_Right);

	mov	rax, QWORD PTR [rdx]
	mov	r8, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rax

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [rdx], r8

; 102  : }

	ret	0
??$swap@PEAU_Recursive_dir_enum_impl@filesystem@std@@$0A@@std@@YAXAEAPEAU_Recursive_dir_enum_impl@filesystem@0@0@Z ENDP ; std::swap<std::filesystem::_Recursive_dir_enum_impl *,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$swap@PEAV_Ref_count_base@std@@$0A@@std@@YAXAEAPEAV_Ref_count_base@0@0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$swap@PEAV_Ref_count_base@std@@$0A@@std@@YAXAEAPEAV_Ref_count_base@0@0@Z PROC ; std::swap<std::_Ref_count_base *,0>, COMDAT

; 99   :     _Ty _Tmp = _STD move(_Left);
; 100  :     _Left    = _STD move(_Right);

	mov	rax, QWORD PTR [rdx]
	mov	r8, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rax

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [rdx], r8

; 102  : }

	ret	0
??$swap@PEAV_Ref_count_base@std@@$0A@@std@@YAXAEAPEAV_Ref_count_base@0@0@Z ENDP ; std::swap<std::_Ref_count_base *,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Construct_in_place@PEA_WAEBQEA_W@std@@YAXAEAPEA_WAEBQEA_W@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@PEA_WAEBQEA_W@std@@YAXAEAPEA_WAEBQEA_W@Z PROC ; std::_Construct_in_place<wchar_t *,wchar_t * const &>, COMDAT

; 248  : #if _HAS_CXX20
; 249  :     if (_STD is_constant_evaluated()) {
; 250  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 251  :     } else
; 252  : #endif // _HAS_CXX20
; 253  :     {
; 254  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 255  :     }
; 256  : }

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	ret	0
??$_Construct_in_place@PEA_WAEBQEA_W@std@@YAXAEAPEA_WAEBQEA_W@Z ENDP ; std::_Construct_in_place<wchar_t *,wchar_t * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@_W@std@@YAPEA_WAEA_W@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@_W@std@@YAPEA_WAEA_W@Z PROC		; std::addressof<wchar_t>, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@_W@std@@YAPEA_WAEA_W@Z ENDP		; std::addressof<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@_WAEB_W$0A@@std@@YAPEA_WQEA_WAEB_W@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@_WAEB_W$0A@@std@@YAPEA_WQEA_WAEB_W@Z PROC ; std::construct_at<wchar_t,wchar_t const &,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movzx	eax, WORD PTR [rdx]
	mov	WORD PTR [rcx], ax
	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@_WAEB_W$0A@@std@@YAPEA_WQEA_WAEB_W@Z ENDP ; std::construct_at<wchar_t,wchar_t const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??1_Creator@_Dir_enum_impl@filesystem@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1_Creator@_Dir_enum_impl@filesystem@std@@QEAA@XZ PROC	; std::filesystem::_Dir_enum_impl::_Creator::~_Creator, COMDAT
$LN13:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 605  :             __std_fs_directory_iterator_close(_Handle);

	mov	rcx, QWORD PTR [rcx+32]
	call	__std_fs_directory_iterator_close
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
??1_Creator@_Dir_enum_impl@filesystem@std@@QEAA@XZ ENDP	; std::filesystem::_Dir_enum_impl::_Creator::~_Creator
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEBAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@XZ
_TEXT	SEGMENT
this$ = 8
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEBAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > >::_Unwrapped, COMDAT

; 342  :         return _Unfancy(this->_Ptr);

	mov	rax, QWORD PTR [rcx]

; 343  :     }

	ret	0
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEBAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > >::_Unwrapped
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Getal@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@2@XZ PROC ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Getal, COMDAT

; 2181 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2182 :     }

	ret	0
?_Getal@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@2@XZ ENDP ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Orphan_range@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEBAXPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEBAXPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@0@Z PROC ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Orphan_range, COMDAT

; 2177 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

	ret	0
?_Orphan_range@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEBAXPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@0@Z ENDP ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??4?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??4?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::operator=, COMDAT

; 1482 :     _CONSTEXPR20 vector& operator=(const vector& _Right) {

$LN7:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	r8, rdx
	mov	rbx, rcx

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN5@operator

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	r8, QWORD PTR [r8+8]
	mov	rax, -6148914691236517205		; aaaaaaaaaaaaaaabH
	mov	rdx, QWORD PTR [rdx]
	sub	r8, rdx
	sar	r8, 5
	imul	r8, rax
	call	??$_Assign_counted_range@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Assign_counted_range<AINBNodeDefMgr::NodeDef::ImmediateParam *>
$LN5@operator:

; 1499 : 
; 1500 :         return *this;
; 1501 :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??4?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Getal@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAAEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAAEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@2@XZ PROC ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Getal, COMDAT

; 2181 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2182 :     }

	ret	0
?_Getal@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAAEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@2@XZ ENDP ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Orphan_range@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEBAXPEAUInputParam@NodeDef@AINBNodeDefMgr@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEBAXPEAUInputParam@NodeDef@AINBNodeDefMgr@@0@Z PROC ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Orphan_range, COMDAT

; 2177 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

	ret	0
?_Orphan_range@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEBAXPEAUInputParam@NodeDef@AINBNodeDefMgr@@0@Z ENDP ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??4?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??4?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::operator=, COMDAT

; 1482 :     _CONSTEXPR20 vector& operator=(const vector& _Right) {

$LN7:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	r8, rdx
	mov	rbx, rcx

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN5@operator

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	r8, QWORD PTR [r8+8]
	mov	rax, -8198552921648689607		; 8e38e38e38e38e39H
	mov	rdx, QWORD PTR [rdx]
	sub	r8, rdx
	sar	r8, 4
	imul	r8, rax
	call	??$_Assign_counted_range@PEAUInputParam@NodeDef@AINBNodeDefMgr@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Assign_counted_range<AINBNodeDefMgr::NodeDef::InputParam *>
$LN5@operator:

; 1499 : 
; 1500 :         return *this;
; 1501 :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??4?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Orphan_range@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEBAXPEAUNodeDef@AINBNodeDefMgr@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEBAXPEAUNodeDef@AINBNodeDefMgr@@0@Z PROC ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::_Orphan_range, COMDAT

; 2177 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

	ret	0
?_Orphan_range@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEBAXPEAUNodeDef@AINBNodeDefMgr@@0@Z ENDP ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??4?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??4?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAAAEAV01@$$QEAV01@@Z PROC ; std::shared_ptr<std::filesystem::_Recursive_dir_enum_impl>::operator=, COMDAT

; 1701 :     shared_ptr& operator=(shared_ptr&& _Right) noexcept { // take resource from _Right

$LN37:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1345 :         _Ptr = _Right._Ptr;

	mov	rax, QWORD PTR [rdx]

; 1701 :     shared_ptr& operator=(shared_ptr&& _Right) noexcept { // take resource from _Right

	mov	rdi, rcx

; 1346 :         _Rep = _Right._Rep;

	mov	r8, QWORD PTR [rdx+8]

; 1347 : 
; 1348 :         _Right._Ptr = nullptr;

	xor	ecx, ecx
	mov	QWORD PTR [rdx], rcx

; 1349 :         _Right._Rep = nullptr;

	mov	QWORD PTR [rdx+8], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	mov	rbx, QWORD PTR [rdi+8]

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [rdi], rax
	mov	QWORD PTR [rdi+8], r8
	test	rbx, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 1402 :         if (_Rep) {

	je	SHORT $LN30@operator
	mov	QWORD PTR [rsp+48], rsi

; 1177 :         if (_MT_DECR(_Uses) == 0) {

	mov	esi, -1
	mov	eax, esi
	lock xadd DWORD PTR [rbx+8], eax
	cmp	eax, 1
	jne	SHORT $LN29@operator

; 1178 :             _Destroy();

	mov	rax, QWORD PTR [rbx]
	mov	rcx, rbx
	call	QWORD PTR [rax]

; 1184 :         if (_MT_DECR(_Weaks) == 0) {

	lock xadd DWORD PTR [rbx+12], esi
	cmp	esi, 1
	jne	SHORT $LN29@operator

; 1185 :             _Delete_this();

	mov	rax, QWORD PTR [rbx]
	mov	rcx, rbx
	call	QWORD PTR [rax+8]
$LN29@operator:
	mov	rsi, QWORD PTR [rsp+48]

; 1702 :         shared_ptr(_STD move(_Right)).swap(*this);
; 1703 :         return *this;

	mov	rax, rdi

; 1704 :     }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN30@operator:
	mov	rbx, QWORD PTR [rsp+56]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??4?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAAAEAV01@$$QEAV01@@Z ENDP ; std::shared_ptr<std::filesystem::_Recursive_dir_enum_impl>::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ?_Incref@?$_Ptr_base@U_Recursive_dir_enum_impl@filesystem@std@@@std@@IEBAXXZ
_TEXT	SEGMENT
this$ = 8
?_Incref@?$_Ptr_base@U_Recursive_dir_enum_impl@filesystem@std@@@std@@IEBAXXZ PROC ; std::_Ptr_base<std::filesystem::_Recursive_dir_enum_impl>::_Incref, COMDAT

; 1396 :         if (_Rep) {

	mov	rax, QWORD PTR [rcx+8]
	test	rax, rax
	je	SHORT $LN5@Incref

; 1169 :         _MT_INCR(_Uses);

	lock inc DWORD PTR [rax+8]
$LN5@Incref:

; 1397 :             _Rep->_Incref();
; 1398 :         }
; 1399 :     }

	ret	0
?_Incref@?$_Ptr_base@U_Recursive_dir_enum_impl@filesystem@std@@@std@@IEBAXXZ ENDP ; std::_Ptr_base<std::filesystem::_Recursive_dir_enum_impl>::_Incref
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@U_Find_file_handle@filesystem@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@U_Find_file_handle@filesystem@std@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<std::filesystem::_Find_file_handle> >::_Vector_val<std::_Simple_types<std::filesystem::_Find_file_handle> >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@U_Find_file_handle@filesystem@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::filesystem::_Find_file_handle> >::_Vector_val<std::_Simple_types<std::filesystem::_Find_file_handle> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$allocator@U_Find_file_handle@filesystem@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@U_Find_file_handle@filesystem@std@@@std@@QEAA@XZ PROC ; std::allocator<std::filesystem::_Find_file_handle>::allocator<std::filesystem::_Find_file_handle>, COMDAT

; 958  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@U_Find_file_handle@filesystem@std@@@std@@QEAA@XZ ENDP ; std::allocator<std::filesystem::_Find_file_handle>::allocator<std::filesystem::_Find_file_handle>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??E?$reverse_iterator@PEB_W@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$reverse_iterator@PEB_W@std@@QEAAAEAV01@XZ PROC	; std::reverse_iterator<wchar_t const *>::operator++, COMDAT

; 1544 :         --current;

	add	QWORD PTR [rcx], -2

; 1545 :         return *this;

	mov	rax, rcx

; 1546 :     }

	ret	0
??E?$reverse_iterator@PEB_W@std@@QEAAAEAV01@XZ ENDP	; std::reverse_iterator<wchar_t const *>::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Clear_and_reserve_geometric@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
?_Clear_and_reserve_geometric@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z PROC ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Clear_and_reserve_geometric, COMDAT

; 1646 :     _CONSTEXPR20 void _Clear_and_reserve_geometric(const size_type _Newsize) {

$LN40:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1647 :         auto& _Al         = _Getal();
; 1648 :         auto& _My_data    = _Mypair._Myval2;
; 1649 :         pointer& _Myfirst = _My_data._Myfirst;
; 1650 :         pointer& _Mylast  = _My_data._Mylast;
; 1651 :         pointer& _Myend   = _My_data._Myend;
; 1652 : 
; 1653 : #if _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1654 :         _STL_INTERNAL_CHECK(_Newsize != 0);
; 1655 :         _Check_all_orphaned();
; 1656 : #endif // _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1657 : 
; 1658 :         if (_Newsize > max_size()) {

	mov	rdi, 9223372036854775807		; 7fffffffffffffffH
	mov	r8, rdx
	mov	rbx, rcx
	cmp	rdx, rdi
	ja	SHORT $LN38@Clear_and_

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx]

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, rdi

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	r9, rdx
	shr	r9, 1
	sub	rax, r9
	cmp	rdx, rax
	ja	SHORT $LN7@Clear_and_

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rdi, QWORD PTR [r9+rdx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rdi, r8
	cmovb	rdi, r8
$LN7@Clear_and_:

; 1660 :         }
; 1661 : 
; 1662 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1663 : 
; 1664 :         if (_Myfirst) { // destroy and deallocate old array

	test	rcx, rcx
	je	SHORT $LN3@Clear_and_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN27@Clear_and_

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN24@Clear_and_

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN27@Clear_and_:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1669 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1670 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 1671 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN3@Clear_and_:

; 1672 :         }
; 1673 : 
; 1674 :         _Buy_raw(_Newcapacity);

	mov	rdx, rdi
	mov	rcx, rbx

; 1675 :     }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1672 :         }
; 1673 : 
; 1674 :         _Buy_raw(_Newcapacity);

	jmp	?_Buy_raw@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Buy_raw
$LN24@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN38@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1659 :             _Xlength();

	call	?_Xlength@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Xlength
	int	3
$LN36@Clear_and_:
?_Clear_and_reserve_geometric@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z ENDP ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Clear_and_reserve_geometric
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@QEAA@XZ PROC ; std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum>::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum>, COMDAT

; 958  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@QEAA@XZ ENDP ; std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum>::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Orphan_range@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEBAXPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEBAXPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@0@Z PROC ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Orphan_range, COMDAT

; 2177 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

	ret	0
?_Orphan_range@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEBAXPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@0@Z ENDP ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Clear_and_reserve_geometric@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 64
_Newsize$ = 72
?_Clear_and_reserve_geometric@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z PROC ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Clear_and_reserve_geometric, COMDAT

; 1646 :     _CONSTEXPR20 void _Clear_and_reserve_geometric(const size_type _Newsize) {

$LN63:
	push	rdi
	push	r14
	sub	rsp, 40					; 00000028H

; 1647 :         auto& _Al         = _Getal();
; 1648 :         auto& _My_data    = _Mypair._Myval2;
; 1649 :         pointer& _Myfirst = _My_data._Myfirst;
; 1650 :         pointer& _Mylast  = _My_data._Mylast;
; 1651 :         pointer& _Myend   = _My_data._Myend;
; 1652 : 
; 1653 : #if _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1654 :         _STL_INTERNAL_CHECK(_Newsize != 0);
; 1655 :         _Check_all_orphaned();
; 1656 : #endif // _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1657 : 
; 1658 :         if (_Newsize > max_size()) {

	mov	r14, 768614336404564650			; 0aaaaaaaaaaaaaaaH
	mov	rdi, rcx
	cmp	rdx, r14
	ja	$LN61@Clear_and_
	mov	QWORD PTR [rsp+80], rbx

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, r14

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rbx, QWORD PTR [rcx]
	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, rbx
	mov	QWORD PTR [rsp+88], rbp
	sar	rcx, 3
	mov	rbp, -6148914691236517205		; aaaaaaaaaaaaaaabH
	imul	rcx, rbp

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	r8, rcx
	shr	r8, 1
	sub	rax, r8
	cmp	rcx, rax
	ja	SHORT $LN7@Clear_and_

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	r14, QWORD PTR [r8+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	r14, rdx
	cmovb	r14, rdx
$LN7@Clear_and_:

; 1660 :         }
; 1661 : 
; 1662 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1663 : 
; 1664 :         if (_Myfirst) { // destroy and deallocate old array

	test	rbx, rbx
	je	SHORT $LN3@Clear_and_
	mov	QWORD PTR [rsp+32], rsi

; 1665 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rsi, QWORD PTR [rdi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rsi
	je	SHORT $LN13@Clear_and_
$LL14@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	mov	rcx, rbx
	call	?_Tidy@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 24
	cmp	rbx, rsi
	jne	SHORT $LL14@Clear_and_
$LN13@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1667 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rdi]
	mov	rax, QWORD PTR [rdi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rsi, QWORD PTR [rsp+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1667 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rax, rcx
	sar	rax, 3
	imul	rax, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*2]
	shl	rdx, 3

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN41@Clear_and_

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN38@Clear_and_

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN41@Clear_and_:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1669 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rdi], rax

; 1670 :             _Mylast  = nullptr;

	mov	QWORD PTR [rdi+8], rax

; 1671 :             _Myend   = nullptr;

	mov	QWORD PTR [rdi+16], rax
$LN3@Clear_and_:

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdx, r14
	call	?allocate@?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K@Z ; std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >::allocate
	mov	rbx, QWORD PTR [rsp+80]

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [r14+r14*2]
	mov	rbp, QWORD PTR [rsp+88]

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rdi], rax

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [rdi+8], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rax, QWORD PTR [rax+rcx*8]
	mov	QWORD PTR [rdi+16], rax

; 1672 :         }
; 1673 : 
; 1674 :         _Buy_raw(_Newcapacity);
; 1675 :     }

	add	rsp, 40					; 00000028H
	pop	r14
	pop	rdi
	ret	0
$LN38@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN61@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1659 :             _Xlength();

	call	?_Xlength@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@CAXXZ ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Xlength
	int	3
$LN59@Clear_and_:
?_Clear_and_reserve_geometric@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z ENDP ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Clear_and_reserve_geometric
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@XZ PROC ; std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >, COMDAT

; 958  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Orphan_range@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEBAXPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEBAXPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@0@Z PROC ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Orphan_range, COMDAT

; 2177 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

	ret	0
?_Orphan_range@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEBAXPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@0@Z ENDP ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Clear_and_reserve_geometric@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 64
_Newsize$ = 72
?_Clear_and_reserve_geometric@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z PROC ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Clear_and_reserve_geometric, COMDAT

; 1646 :     _CONSTEXPR20 void _Clear_and_reserve_geometric(const size_type _Newsize) {

$LN63:
	push	rdi
	push	r14
	sub	rsp, 40					; 00000028H

; 1647 :         auto& _Al         = _Getal();
; 1648 :         auto& _My_data    = _Mypair._Myval2;
; 1649 :         pointer& _Myfirst = _My_data._Myfirst;
; 1650 :         pointer& _Mylast  = _My_data._Mylast;
; 1651 :         pointer& _Myend   = _My_data._Myend;
; 1652 : 
; 1653 : #if _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1654 :         _STL_INTERNAL_CHECK(_Newsize != 0);
; 1655 :         _Check_all_orphaned();
; 1656 : #endif // _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1657 : 
; 1658 :         if (_Newsize > max_size()) {

	mov	r14, 768614336404564650			; 0aaaaaaaaaaaaaaaH
	mov	rdi, rcx
	cmp	rdx, r14
	ja	$LN61@Clear_and_
	mov	QWORD PTR [rsp+80], rbx

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, r14

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rbx, QWORD PTR [rcx]
	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, rbx
	mov	QWORD PTR [rsp+88], rbp
	sar	rcx, 3
	mov	rbp, -6148914691236517205		; aaaaaaaaaaaaaaabH
	imul	rcx, rbp

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	r8, rcx
	shr	r8, 1
	sub	rax, r8
	cmp	rcx, rax
	ja	SHORT $LN7@Clear_and_

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	r14, QWORD PTR [r8+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	r14, rdx
	cmovb	r14, rdx
$LN7@Clear_and_:

; 1660 :         }
; 1661 : 
; 1662 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1663 : 
; 1664 :         if (_Myfirst) { // destroy and deallocate old array

	test	rbx, rbx
	je	SHORT $LN3@Clear_and_
	mov	QWORD PTR [rsp+32], rsi

; 1665 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rsi, QWORD PTR [rdi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rsi
	je	SHORT $LN13@Clear_and_
$LL14@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	mov	rcx, rbx
	call	?_Tidy@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 24
	cmp	rbx, rsi
	jne	SHORT $LL14@Clear_and_
$LN13@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1667 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rdi]
	mov	rax, QWORD PTR [rdi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rsi, QWORD PTR [rsp+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1667 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rax, rcx
	sar	rax, 3
	imul	rax, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*2]
	shl	rdx, 3

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN41@Clear_and_

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN38@Clear_and_

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN41@Clear_and_:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1669 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rdi], rax

; 1670 :             _Mylast  = nullptr;

	mov	QWORD PTR [rdi+8], rax

; 1671 :             _Myend   = nullptr;

	mov	QWORD PTR [rdi+16], rax
$LN3@Clear_and_:

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdx, r14
	call	?allocate@?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K@Z ; std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >::allocate
	mov	rbx, QWORD PTR [rsp+80]

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [r14+r14*2]
	mov	rbp, QWORD PTR [rsp+88]

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rdi], rax

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [rdi+8], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rax, QWORD PTR [rax+rcx*8]
	mov	QWORD PTR [rdi+16], rax

; 1672 :         }
; 1673 : 
; 1674 :         _Buy_raw(_Newcapacity);
; 1675 :     }

	add	rsp, 40					; 00000028H
	pop	r14
	pop	rdi
	ret	0
$LN38@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN61@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1659 :             _Xlength();

	call	?_Xlength@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@CAXXZ ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Xlength
	int	3
$LN59@Clear_and_:
?_Clear_and_reserve_geometric@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z ENDP ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Clear_and_reserve_geometric
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@XZ PROC ; std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >, COMDAT

; 958  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Requested$ = 16
?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBA_K_K@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth, COMDAT

; 4727 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	rax, QWORD PTR [rcx+24]

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	or	rdx, 7
	mov	r9, 9223372036854775806			; 7ffffffffffffffeH
	cmp	rdx, r9

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN4@Calculate_
$LN9@Calculate_:

; 4728 :     }

	mov	rax, r9
	ret	0
$LN4@Calculate_:

; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	r8, rax
	mov	rcx, r9
	shr	r8, 1
	sub	rcx, r8
	cmp	rax, rcx
	ja	SHORT $LN9@Calculate_

; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	rcx, QWORD PTR [r8+rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	cmp	rdx, rcx
	cmovb	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4727 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	rax, rdx

; 4728 :     }

	ret	0
?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBA_K_K@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?_Start_element_lifetimes@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAXQEA_W_K@Z
_TEXT	SEGMENT
_Ptr$dead$ = 8
_Size$dead$ = 16
?_Start_element_lifetimes@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAXQEA_W_K@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Start_element_lifetimes, COMDAT

; 2593 :         // Start element lifetimes to avoid UB. This is a more general mechanism than _String_val::_Activate_SSO_buffer,
; 2594 :         // but likely more impactful to throughput.
; 2595 : #if _HAS_CXX20
; 2596 :         if (_STD is_constant_evaluated()) {
; 2597 :             for (size_type _Idx = 0; _Idx < _Size; ++_Idx) {
; 2598 :                 _STD construct_at(_Ptr + _Idx);
; 2599 :             }
; 2600 :         }
; 2601 : #else // ^^^ C++20-or-later / pre-C++20 vvv
; 2602 :         (void) _Ptr;
; 2603 :         (void) _Size;
; 2604 : #endif // _HAS_CXX20
; 2605 :     }

	ret	0
?_Start_element_lifetimes@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAXQEA_W_K@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Start_element_lifetimes
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >, COMDAT

; 2285 :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 2286 : 
; 2287 :         value_type _Buf[_BUF_SIZE];
; 2288 :         pointer _Ptr;
; 2289 :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 2290 :     };
; 2291 :     _Bxty _Bx;
; 2292 : 
; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2285 :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 2286 : 
; 2287 :         value_type _Buf[_BUF_SIZE];
; 2288 :         pointer _Ptr;
; 2289 :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 2290 :     };
; 2291 :     _Bxty _Bx;
; 2292 : 
; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], rax
	mov	rax, rcx
	ret	0
??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z PROC	; std::allocator<wchar_t>::allocate, COMDAT

; 972  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN32:
	sub	rsp, 40					; 00000028H

; 70   :         if (_Count > _Max_possible) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN28@allocate

; 71   :             _Throw_bad_array_new_length(); // multiply overflow
; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	lea	rcx, QWORD PTR [rdx+rdx]

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN9@allocate

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN28@allocate

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN18@allocate

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN18@allocate:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@allocate:

; 244  :     if (_Bytes != 0) {

	test	rcx, rcx
	je	SHORT $LN10@allocate

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H

; 87   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN10@allocate:

; 248  :     return nullptr;

	xor	eax, eax

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN28@allocate:

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN30@allocate:
?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z ENDP	; std::allocator<wchar_t>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::ImmediateParam> >,1>::_Get_first, COMDAT

; 1523 :         return *this;

	mov	rax, rcx

; 1524 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::ImmediateParam> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Getal@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEBAAEBV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEBAAEBV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@2@XZ PROC ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Getal, COMDAT

; 2185 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2186 :     }

	ret	0
?_Getal@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEBAAEBV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@2@XZ ENDP ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::InputParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::InputParam> >,1>::_Get_first, COMDAT

; 1523 :         return *this;

	mov	rax, rcx

; 1524 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::InputParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::InputParam> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Getal@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEBAAEBV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEBAAEBV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@2@XZ PROC ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Getal, COMDAT

; 2185 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2186 :     }

	ret	0
?_Getal@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEBAAEBV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@2@XZ ENDP ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Xlength@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ PROC ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Xlength, COMDAT

; 2137 :     [[noreturn]] static void _Xlength() {

$LN4:
	sub	rsp, 40					; 00000028H

; 2138 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlength:
?_Xlength@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ ENDP ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Buy_raw@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$ = 56
?_Buy_raw@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z PROC ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Buy_raw, COMDAT

; 1979 :     _CONSTEXPR20 void _Buy_raw(const size_type _Newcapacity) {

$LN35:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN7@Buy_raw

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rdx
	jbe	SHORT $LN34@Buy_raw

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN16@Buy_raw

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN5@Buy_raw
$LN16@Buy_raw:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN7@Buy_raw:

; 244  :     if (_Bytes != 0) {

	test	rbx, rbx
	je	SHORT $LN8@Buy_raw

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new

; 245  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN5@Buy_raw
$LN8@Buy_raw:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

	xor	eax, eax
$LN5@Buy_raw:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rdi], rax

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [rdi+8], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	add	rax, rbx

; 1993 :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [rdi+16], rax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN34@Buy_raw:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN32@Buy_raw:
?_Buy_raw@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z ENDP ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Calculate_growth@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$ = 16
?_Calculate_growth@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEBA_K_K@Z PROC ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Calculate_growth, COMDAT

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	r8, QWORD PTR [rcx+16]

; 1962 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1963 :         const size_type _Oldcapacity = capacity();
; 1964 :         const auto _Max              = max_size();
; 1965 : 
; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sub	r8, QWORD PTR [rcx]

; 1962 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1963 :         const size_type _Oldcapacity = capacity();
; 1964 :         const auto _Max              = max_size();
; 1965 : 
; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rcx, rax
	mov	r9, r8
	shr	r9, 1
	sub	rcx, r9
	cmp	r8, rcx
	ja	SHORT $LN1@Calculate_

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [r9+r8]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rax, rdx
	cmovb	rax, rdx
$LN1@Calculate_:

; 1973 :             return _Newsize; // geometric growth would be insufficient
; 1974 :         }
; 1975 : 
; 1976 :         return _Geometric; // geometric growth is sufficient
; 1977 :     }

	ret	0
?_Calculate_growth@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEBA_K_K@Z ENDP ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?max_size@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ PROC ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::max_size, COMDAT

; 1873 :         return (_STD min)(

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 1874 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1875 :     }

	ret	0
?max_size@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Xlength@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@CAXXZ PROC ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Xlength, COMDAT

; 2137 :     [[noreturn]] static void _Xlength() {

$LN4:
	sub	rsp, 40					; 00000028H

; 2138 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlength:
?_Xlength@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@CAXXZ ENDP ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Buy_raw@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$ = 56
?_Buy_raw@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z PROC ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Buy_raw, COMDAT

; 1979 :     _CONSTEXPR20 void _Buy_raw(const size_type _Newcapacity) {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx

; 1980 :         // allocate array with _Newcapacity elements
; 1981 :         auto& _My_data    = _Mypair._Myval2;
; 1982 :         pointer& _Myfirst = _My_data._Myfirst;
; 1983 :         pointer& _Mylast  = _My_data._Mylast;
; 1984 :         pointer& _Myend   = _My_data._Myend;
; 1985 : 
; 1986 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 1987 :         _STL_INTERNAL_CHECK(0 < _Newcapacity && _Newcapacity <= max_size());
; 1988 : 
; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	call	?allocate@?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K@Z ; std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >::allocate

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rdi], rax

; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rdx, QWORD PTR [rbx+rbx*2]

; 1993 :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [rdi+8], rax
	lea	rax, QWORD PTR [rax+rdx*8]
	mov	QWORD PTR [rdi+16], rax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_Buy_raw@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z ENDP ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Calculate_growth@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$ = 16
?_Calculate_growth@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEBA_K_K@Z PROC ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Calculate_growth, COMDAT

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	r8, QWORD PTR [rcx+16]
	mov	rax, -6148914691236517205		; aaaaaaaaaaaaaaabH
	sub	r8, QWORD PTR [rcx]
	sar	r8, 3
	imul	r8, rax

; 1962 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1963 :         const size_type _Oldcapacity = capacity();
; 1964 :         const auto _Max              = max_size();
; 1965 : 
; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, 768614336404564650			; 0aaaaaaaaaaaaaaaH
	mov	r9, r8
	mov	rcx, rax
	shr	r9, 1
	sub	rcx, r9
	cmp	r8, rcx
	ja	SHORT $LN1@Calculate_

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [r9+r8]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rax, rdx
	cmovb	rax, rdx
$LN1@Calculate_:

; 1973 :             return _Newsize; // geometric growth would be insufficient
; 1974 :         }
; 1975 : 
; 1976 :         return _Geometric; // geometric growth is sufficient
; 1977 :     }

	ret	0
?_Calculate_growth@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEBA_K_K@Z ENDP ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?max_size@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::max_size, COMDAT

; 1873 :         return (_STD min)(

	mov	rax, 768614336404564650			; 0aaaaaaaaaaaaaaaH

; 1874 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1875 :     }

	ret	0
?max_size@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Xlength@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@CAXXZ PROC ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Xlength, COMDAT

; 2137 :     [[noreturn]] static void _Xlength() {

$LN4:
	sub	rsp, 40					; 00000028H

; 2138 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlength:
?_Xlength@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@CAXXZ ENDP ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Buy_raw@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$ = 56
?_Buy_raw@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z PROC ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Buy_raw, COMDAT

; 1979 :     _CONSTEXPR20 void _Buy_raw(const size_type _Newcapacity) {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx

; 1980 :         // allocate array with _Newcapacity elements
; 1981 :         auto& _My_data    = _Mypair._Myval2;
; 1982 :         pointer& _Myfirst = _My_data._Myfirst;
; 1983 :         pointer& _Mylast  = _My_data._Mylast;
; 1984 :         pointer& _Myend   = _My_data._Myend;
; 1985 : 
; 1986 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 1987 :         _STL_INTERNAL_CHECK(0 < _Newcapacity && _Newcapacity <= max_size());
; 1988 : 
; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	call	?allocate@?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K@Z ; std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >::allocate

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rdi], rax

; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rdx, QWORD PTR [rbx+rbx*2]

; 1993 :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [rdi+8], rax
	lea	rax, QWORD PTR [rax+rdx*8]
	mov	QWORD PTR [rdi+16], rax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_Buy_raw@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_K@Z ENDP ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Calculate_growth@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$ = 16
?_Calculate_growth@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEBA_K_K@Z PROC ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Calculate_growth, COMDAT

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	r8, QWORD PTR [rcx+16]
	mov	rax, -6148914691236517205		; aaaaaaaaaaaaaaabH
	sub	r8, QWORD PTR [rcx]
	sar	r8, 3
	imul	r8, rax

; 1962 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1963 :         const size_type _Oldcapacity = capacity();
; 1964 :         const auto _Max              = max_size();
; 1965 : 
; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, 768614336404564650			; 0aaaaaaaaaaaaaaaH
	mov	r9, r8
	mov	rcx, rax
	shr	r9, 1
	sub	rcx, r9
	cmp	r8, rcx
	ja	SHORT $LN1@Calculate_

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [r9+r8]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rax, rdx
	cmovb	rax, rdx
$LN1@Calculate_:

; 1973 :             return _Newsize; // geometric growth would be insufficient
; 1974 :         }
; 1975 : 
; 1976 :         return _Geometric; // geometric growth is sufficient
; 1977 :     }

	ret	0
?_Calculate_growth@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEBA_K_K@Z ENDP ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?max_size@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::max_size, COMDAT

; 1873 :         return (_STD min)(

	mov	rax, 768614336404564650			; 0aaaaaaaaaaaaaaaH

; 1874 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1875 :     }

	ret	0
?max_size@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CA_K_K00@Z
_TEXT	SEGMENT
_Requested$ = 8
_Old$ = 16
_Max$ = 24
?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CA_K_K00@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth, COMDAT

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	or	rcx, 7
	cmp	rcx, r8

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN7@Calculate_

; 4716 :             return _Max;
; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	r9, rdx
	mov	rax, r8
	shr	r9, 1
	sub	rax, r9
	cmp	rdx, rax
	ja	SHORT $LN7@Calculate_

; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	rax, QWORD PTR [r9+rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	cmp	rcx, rax
	cmovb	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	mov	rax, rcx

; 4724 :     }

	ret	0
$LN7@Calculate_:

; 4720 :             return _Max;

	mov	rax, r8

; 4724 :     }

	ret	0
?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CA_K_K00@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty, COMDAT

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	xorps	xmm0, xmm0
	mov	rax, rcx
	movups	XMMWORD PTR [rcx], xmm0
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::ImmediateParam> >,1>::_Get_first, COMDAT

; 1527 :         return *this;

	mov	rax, rcx

; 1528 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::ImmediateParam> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::InputParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::InputParam> >,1>::_Get_first, COMDAT

; 1527 :         return *this;

	mov	rax, rcx

; 1528 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::InputParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::InputParam> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?capacity@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ PROC ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::capacity, COMDAT

; 1878 :         auto& _My_data = _Mypair._Myval2;
; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]

; 1880 :     }

	ret	0
?capacity@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@SA_KAEBV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@SA_KAEBV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::max_size, COMDAT

; 733  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, -1

; 734  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@SA_KAEBV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?allocate@?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@QEAAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@QEAAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_K@Z PROC ; std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum>::allocate, COMDAT

; 972  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN28:
	sub	rsp, 40					; 00000028H

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN5@allocate

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rdx
	jbe	SHORT $LN27@allocate

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN14@allocate

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN14@allocate:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN5@allocate:

; 244  :     if (_Bytes != 0) {

	test	rdx, rdx
	je	SHORT $LN6@allocate

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rdx

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H

; 87   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN6@allocate:

; 248  :     return nullptr;

	xor	eax, eax

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN27@allocate:

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN25@allocate:
?allocate@?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@QEAAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_K@Z ENDP ; std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?capacity@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::capacity, COMDAT

; 1878 :         auto& _My_data = _Mypair._Myval2;
; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	mov	rcx, -6148914691236517205		; aaaaaaaaaaaaaaabH
	sar	rax, 3
	imul	rax, rcx

; 1880 :     }

	ret	0
?capacity@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::max_size, COMDAT

; 733  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 768614336404564650			; 0aaaaaaaaaaaaaaaH

; 734  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?allocate@?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K@Z PROC ; std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >::allocate, COMDAT

; 972  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN32:
	sub	rsp, 40					; 00000028H

; 70   :         if (_Count > _Max_possible) {

	mov	rax, 768614336404564650			; 0aaaaaaaaaaaaaaaH
	cmp	rdx, rax
	ja	SHORT $LN28@allocate

; 71   :             _Throw_bad_array_new_length(); // multiply overflow
; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	lea	rax, QWORD PTR [rdx+rdx*2]
	lea	rcx, QWORD PTR [rax*8]

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN9@allocate

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN28@allocate

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN18@allocate

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN18@allocate:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@allocate:

; 244  :     if (_Bytes != 0) {

	test	rcx, rcx
	je	SHORT $LN10@allocate

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H

; 87   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN10@allocate:

; 248  :     return nullptr;

	xor	eax, eax

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN28@allocate:

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN30@allocate:
?allocate@?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K@Z ENDP ; std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?capacity@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::capacity, COMDAT

; 1878 :         auto& _My_data = _Mypair._Myval2;
; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	mov	rcx, -6148914691236517205		; aaaaaaaaaaaaaaabH
	sar	rax, 3
	imul	rax, rcx

; 1880 :     }

	ret	0
?capacity@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::max_size, COMDAT

; 733  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 768614336404564650			; 0aaaaaaaaaaaaaaaH

; 734  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?allocate@?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K@Z PROC ; std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >::allocate, COMDAT

; 972  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN32:
	sub	rsp, 40					; 00000028H

; 70   :         if (_Count > _Max_possible) {

	mov	rax, 768614336404564650			; 0aaaaaaaaaaaaaaaH
	cmp	rdx, rax
	ja	SHORT $LN28@allocate

; 71   :             _Throw_bad_array_new_length(); // multiply overflow
; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	lea	rax, QWORD PTR [rdx+rdx*2]
	lea	rcx, QWORD PTR [rax*8]

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN9@allocate

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN28@allocate

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN18@allocate

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN18@allocate:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@allocate:

; 244  :     if (_Bytes != 0) {

	test	rcx, rcx
	je	SHORT $LN10@allocate

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H

; 87   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN10@allocate:

; 248  :     return nullptr;

	xor	eax, eax

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN28@allocate:

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN30@allocate:
?allocate@?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K@Z ENDP ; std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEB_W@std@@YAAEB_WAEB_W@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEB_W@std@@YAAEB_WAEB_W@Z PROC		; std::forward<wchar_t const &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEB_W@std@@YAAEB_WAEB_W@Z ENDP		; std::forward<wchar_t const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Seek_wrapped@PEB_WAEAPEB_W@std@@YAXAEAPEB_W0@Z
_TEXT	SEGMENT
_It$ = 8
_UIt$ = 16
??$_Seek_wrapped@PEB_WAEAPEB_W@std@@YAXAEAPEB_W0@Z PROC	; std::_Seek_wrapped<wchar_t const *,wchar_t const * &>, COMDAT

; 1256 :     if constexpr (_Wrapped_seekable_v<_Iter, _UIter>) {
; 1257 :         _It._Seek_to(_STD forward<_UIter>(_UIt));
; 1258 :     } else {
; 1259 :         _It = _STD forward<_UIter>(_UIt);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 1260 :     }
; 1261 : }

	ret	0
??$_Seek_wrapped@PEB_WAEAPEB_W@std@@YAXAEAPEB_W0@Z ENDP	; std::_Seek_wrapped<wchar_t const *,wchar_t const * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$reverse_iterator@PEB_W@std@@V12@@std@@YAXAEBV?$reverse_iterator@PEB_W@0@0@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
??$_Adl_verify_range@V?$reverse_iterator@PEB_W@std@@V12@@std@@YAXAEBV?$reverse_iterator@PEB_W@0@0@Z PROC ; std::_Adl_verify_range<std::reverse_iterator<wchar_t const *>,std::reverse_iterator<wchar_t const *> >, COMDAT

; 1133 :     // check that [_First, _Last) forms an iterator range
; 1134 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1135 :         _Verify_range(_First, _Last);
; 1136 :     }
; 1137 : }

	ret	0
??$_Adl_verify_range@V?$reverse_iterator@PEB_W@std@@V12@@std@@YAXAEBV?$reverse_iterator@PEB_W@0@0@Z ENDP ; std::_Adl_verify_range<std::reverse_iterator<wchar_t const *>,std::reverse_iterator<wchar_t const *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Seek_wrapped@V?$reverse_iterator@PEB_W@std@@AEAV12@@std@@YAXAEAV?$reverse_iterator@PEB_W@0@0@Z
_TEXT	SEGMENT
_It$ = 8
_UIt$ = 16
??$_Seek_wrapped@V?$reverse_iterator@PEB_W@std@@AEAV12@@std@@YAXAEAV?$reverse_iterator@PEB_W@0@0@Z PROC ; std::_Seek_wrapped<std::reverse_iterator<wchar_t const *>,std::reverse_iterator<wchar_t const *> &>, COMDAT

; 1256 :     if constexpr (_Wrapped_seekable_v<_Iter, _UIter>) {
; 1257 :         _It._Seek_to(_STD forward<_UIter>(_UIt));
; 1258 :     } else {
; 1259 :         _It = _STD forward<_UIter>(_UIt);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 1260 :     }
; 1261 : }

	ret	0
??$_Seek_wrapped@V?$reverse_iterator@PEB_W@std@@AEAV12@@std@@YAXAEAV?$reverse_iterator@PEB_W@0@0@Z ENDP ; std::_Seek_wrapped<std::reverse_iterator<wchar_t const *>,std::reverse_iterator<wchar_t const *> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ??$_Convert_wide_to@U?$char_traits@D@std@@V?$allocator@D@2@D@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
$T1 = 48
__$ReturnUdt$GSCopy$ = 56
__$ReturnUdt$ = 96
_Input$ = 104
_Al$dead$ = 112
??$_Convert_wide_to@U?$char_traits@D@std@@V?$allocator@D@2@D@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z PROC ; std::filesystem::_Convert_wide_to<std::char_traits<char>,std::allocator<char>,char>, COMDAT

; 150  :     _NODISCARD basic_string<_EcharT, _Traits, _Alloc> _Convert_wide_to(const wstring_view _Input, const _Alloc& _Al) {

$LN47:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 64					; 00000040H
	mov	rbx, rdx
	mov	rdi, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
	xor	ebp, ebp
	mov	DWORD PTR $T1[rsp], ebp

; 152  :             return _Convert_wide_to_narrow<_Traits>(__std_fs_code_page(), _Input, _Al);

	call	__std_fs_code_page
	mov	r14d, eax
	movaps	xmm1, XMMWORD PTR [rbx]
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rdi], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], rbp

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdi+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], bpl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono

; 80   :     return _Output;

	mov	DWORD PTR $T1[rsp], 2

; 54   :     }
; 55   : 
; 56   :     return _Result._Len;
; 57   : }
; 58   : 
; 59   : template <class _Traits, class _Alloc>
; 60   : _NODISCARD basic_string<typename _Traits::char_type, _Traits, _Alloc> _Convert_wide_to_narrow(
; 61   :     const __std_code_page _Code_page, const wstring_view _Input, const _Alloc& _Al) {
; 62   :     basic_string<typename _Traits::char_type, _Traits, _Alloc> _Output(_Al);
; 63   : 
; 64   :     if (!_Input.empty()) {

	movdqa	xmm0, xmm1
	psrldq	xmm0, 8
	movq	rsi, xmm0
	test	rsi, rsi
	je	SHORT $LN38@Convert_wi

; 65   :         if (_Input.size() > static_cast<size_t>(INT_MAX)) {

	cmp	rsi, 2147483647				; 7fffffffH
	ja	SHORT $LN43@Convert_wi

; 67   :         }
; 68   : 
; 69   :         const int _Len = _Check_convert_result(

	mov	DWORD PTR [rsp+32], ebp
	xor	r9d, r9d
	mov	r8d, esi
	movq	rbp, xmm1
	mov	rdx, rbp
	mov	ecx, eax
	call	__std_fs_convert_wide_to_narrow
	mov	rbx, rax
	shr	rax, 32					; 00000020H
	test	eax, eax

; 52   :     if (_Result._Err != __std_win_error::_Success) {

	jne	SHORT $LN44@Convert_wi

; 72   :         _Output.resize(static_cast<size_t>(_Len));

	movsxd	rdx, ebx
	mov	rcx, rdi
	call	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	r9, rdi

; 2227 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rdi+24], 16
	jb	SHORT $LN33@Convert_wi

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r9, QWORD PTR [rdi]
$LN33@Convert_wi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono

; 76   :         (void) _Check_convert_result(__std_fs_convert_wide_to_narrow(

	mov	DWORD PTR [rsp+32], ebx
	mov	r8d, esi
	mov	rdx, rbp
	mov	ecx, r14d
	call	__std_fs_convert_wide_to_narrow
	mov	rcx, rax
	shr	rax, 32					; 00000020H
	test	eax, eax

; 52   :     if (_Result._Err != __std_win_error::_Success) {

	jne	SHORT $LN45@Convert_wi
$LN38@Convert_wi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 152  :             return _Convert_wide_to_narrow<_Traits>(__std_fs_code_page(), _Input, _Al);

	mov	rax, rdi

; 164  :     }

	mov	rbx, QWORD PTR [rsp+112]
	mov	rbp, QWORD PTR [rsp+120]
	add	rsp, 64					; 00000040H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN45@Convert_wi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono

; 53   :         _Throw_system_error_from_std_win_error(_Result._Err);

	shr	rcx, 32					; 00000020H
	call	?_Throw_system_error_from_std_win_error@std@@YAXW4__std_win_error@@@Z ; std::_Throw_system_error_from_std_win_error
	int	3
$LN43@Convert_wi:

; 66   :             _Throw_system_error(errc::invalid_argument);

	call	?_Throw_system_error@std@@YAXW4errc@1@@Z ; std::_Throw_system_error
	int	3
$LN44@Convert_wi:

; 53   :         _Throw_system_error_from_std_win_error(_Result._Err);

	shr	rbx, 32					; 00000020H
	mov	ecx, ebx
	call	?_Throw_system_error_from_std_win_error@std@@YAXW4__std_win_error@@@Z ; std::_Throw_system_error_from_std_win_error
	int	3
$LN41@Convert_wi:
??$_Convert_wide_to@U?$char_traits@D@std@@V?$allocator@D@2@D@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z ENDP ; std::filesystem::_Convert_wide_to<std::char_traits<char>,std::allocator<char>,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
__$ReturnUdt$GSCopy$ = 56
__$ReturnUdt$ = 96
_Input$ = 104
_Al$dead$ = 112
?dtor$1@?0???$_Convert_wide_to@U?$char_traits@D@std@@V?$allocator@D@2@D@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z@4HA PROC ; `std::filesystem::_Convert_wide_to<std::char_traits<char>,std::allocator<char>,char>'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN10@dtor$1
	and	DWORD PTR $T1[rbp], -3
	mov	rcx, QWORD PTR __$ReturnUdt$GSCopy$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN10@dtor$1:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???$_Convert_wide_to@U?$char_traits@D@std@@V?$allocator@D@2@D@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z@4HA ENDP ; `std::filesystem::_Convert_wide_to<std::char_traits<char>,std::allocator<char>,char>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ??$_Convert_Source_to_wide@V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@1@U_Normal_conversion@01@@Z
_TEXT	SEGMENT
__$ReturnUdt$GSCopy$ = 40
__$ReturnUdt$ = 80
_Source$ = 88
_Tag$dead$ = 96
??$_Convert_Source_to_wide@V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@1@U_Normal_conversion@01@@Z PROC ; std::filesystem::_Convert_Source_to_wide<std::basic_string_view<wchar_t,std::char_traits<wchar_t> >,std::filesystem::_Normal_conversion>, COMDAT

; 282  :     _NODISCARD wstring _Convert_Source_to_wide(const _Src& _Source, _Conversion _Tag = {}) {

$LN71:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 1209 :         : _Mydata(_Cts), _Mysize(_Count) {

	mov	rbx, QWORD PTR [rdx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 282  :     _NODISCARD wstring _Convert_Source_to_wide(const _Src& _Source, _Conversion _Tag = {}) {

	xor	r15d, r15d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 1209 :         : _Mydata(_Cts), _Mysize(_Count) {

	mov	r14, QWORD PTR [rdx]
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	rbp, 9223372036854775806		; 7ffffffffffffffeH
	mov	QWORD PTR [rcx+16], r15
	mov	QWORD PTR [rcx+24], r15
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 282  :     _NODISCARD wstring _Convert_Source_to_wide(const _Src& _Source, _Conversion _Tag = {}) {

	mov	rsi, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	cmp	rbx, rbp

; 2620 :         if (_Count > max_size()) {

	ja	$LN69@Convert_So

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR [rcx+24], 7
	cmp	rbx, 8
	jae	SHORT $LN27@Convert_So

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR [rcx+16], rbx

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14
	add	rbx, rbx
	mov	r8, rbx
	call	memcpy

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	WORD PTR [rbx+rsi], r15w

; 2638 :             } else { // _Strat == _Construct_strategy::_From_string
; 2639 : #ifdef _INSERT_STRING_ANNOTATION
; 2640 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 2641 : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 2642 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 2643 : #endif // !_INSERT_STRING_ANNOTATION
; 2644 :             }
; 2645 : 
; 2646 :             _Proxy._Release();
; 2647 :             return;

	jmp	SHORT $LN25@Convert_So
$LN27@Convert_So:

; 4727 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	rax, rbx
	mov	QWORD PTR [rsp+88], rdi
	or	rax, 7

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	cmp	rax, rbp

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN37@Convert_So
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	mov	ecx, 10
	mov	rbp, rax
	cmp	rax, rcx
	cmovb	rbp, rcx
$LN37@Convert_So:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	rdx, QWORD PTR [rbp+1]
	call	?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z ; std::allocator<wchar_t>::allocate

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR [rsi+16], rbx

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14
	add	rbx, rbx

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR [rsi], rax

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rbx

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR [rsi+24], rbp

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rcx, rax

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdi, rax

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy

; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	mov	WORD PTR [rbx+rdi], r15w
	mov	rdi, QWORD PTR [rsp+88]
$LN25@Convert_So:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 284  :     }

	mov	rbx, QWORD PTR [rsp+96]
	mov	rax, rsi
	mov	rbp, QWORD PTR [rsp+104]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	rsi
	ret	0
$LN69@Convert_So:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN67@Convert_So:
??$_Convert_Source_to_wide@V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@1@U_Normal_conversion@01@@Z ENDP ; std::filesystem::_Convert_Source_to_wide<std::basic_string_view<wchar_t,std::char_traits<wchar_t> >,std::filesystem::_Normal_conversion>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ??$_Stringoid_from_Source@_WU?$char_traits@_W@std@@@filesystem@std@@YA?A_PAEBV?$basic_string_view@_WU?$char_traits@_W@std@@@1@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Source$ = 16
??$_Stringoid_from_Source@_WU?$char_traits@_W@std@@@filesystem@std@@YA?A_PAEBV?$basic_string_view@_WU?$char_traits@_W@std@@@1@@Z PROC ; std::filesystem::_Stringoid_from_Source<wchar_t,std::char_traits<wchar_t> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 1209 :         : _Mydata(_Cts), _Mysize(_Count) {

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rcx+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 238  :         return basic_string_view<_EcharT>(_Source.data(), _Source.size()); // erase mismatching _Traits

	mov	rax, rcx

; 239  :     }

	ret	0
??$_Stringoid_from_Source@_WU?$char_traits@_W@std@@@filesystem@std@@YA?A_PAEBV?$basic_string_view@_WU?$char_traits@_W@std@@@1@@Z ENDP ; std::filesystem::_Stringoid_from_Source<wchar_t,std::char_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> const &>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??$append@V?$basic_string_view@DU?$char_traits@D@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV?$basic_string_view@DU?$char_traits@D@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??$append@V?$basic_string_view@DU?$char_traits@D@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV?$basic_string_view@DU?$char_traits@D@std@@@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append<std::basic_string_view<char,std::char_traits<char> >,0>, COMDAT

; 3254 :         const basic_string_view<_Elem, _Traits> _As_view = _Right;
; 3255 :         return append(_As_view.data(), _Convert_size<size_type>(_As_view.size()));

	mov	r8, QWORD PTR [rdx+8]
	mov	rdx, QWORD PTR [rdx]
	jmp	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
??$append@V?$basic_string_view@DU?$char_traits@D@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV?$basic_string_view@DU?$char_traits@D@std@@@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append<std::basic_string_view<char,std::char_traits<char> >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??$make_shared@U_Recursive_dir_enum_impl@filesystem@std@@U_Creator@_Dir_enum_impl@23@AEBW4directory_options@23@@std@@YA?AV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@0@$$QEAU_Creator@_Dir_enum_impl@filesystem@0@AEBW4directory_options@40@@Z
_TEXT	SEGMENT
$T1 = 80
__$ReturnUdt$ = 80
<_Args_0>$ = 88
<_Args_1>$ = 96
??$make_shared@U_Recursive_dir_enum_impl@filesystem@std@@U_Creator@_Dir_enum_impl@23@AEBW4directory_options@23@@std@@YA?AV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@0@$$QEAU_Creator@_Dir_enum_impl@filesystem@0@AEBW4directory_options@40@@Z PROC ; std::make_shared<std::filesystem::_Recursive_dir_enum_impl,std::filesystem::_Dir_enum_impl::_Creator,enum std::filesystem::directory_options const &>, COMDAT

; 2778 :     make_shared(_Types&&... _Args) { // make a shared_ptr to non-array object

$LN48:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H
	mov	rbx, r8
	mov	rsi, rdx
	mov	r15, rcx
	xor	ebp, ebp

; 2779 :     const auto _Rx = new _Ref_count_obj2<_Ty>(_STD forward<_Types>(_Args)...);

	lea	ecx, QWORD PTR [rbp+120]
	call	??2@YAPEAX_K@Z				; operator new
	mov	r14, rax
	mov	QWORD PTR $T1[rsp], rax
	xorps	xmm0, xmm0

; 2096 :     explicit _Ref_count_obj2(_Types&&... _Args) : _Ref_count_base() {

	movups	XMMWORD PTR [rax], xmm0

; 1137 :     _Atomic_counter_t _Uses  = 1;

	mov	DWORD PTR [rax+8], 1

; 1138 :     _Atomic_counter_t _Weaks = 1;

	mov	DWORD PTR [rax+12], 1

; 2096 :     explicit _Ref_count_obj2(_Types&&... _Args) : _Ref_count_base() {

	lea	rax, OFFSET FLAT:??_7?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@6B@
	mov	QWORD PTR [r14], rax

; 2097 : #if _HAS_CXX20
; 2098 :         if constexpr (sizeof...(_Types) == 1 && (is_same_v<_For_overwrite_tag, remove_cvref_t<_Types>> && ...)) {
; 2099 :             _STD _Default_construct_in_place(_Storage._Value);
; 2100 :             ((void) _Args, ...);
; 2101 :         } else
; 2102 : #endif // _HAS_CXX20
; 2103 :         {
; 2104 :             _STD _Construct_in_place(_Storage._Value, _STD forward<_Types>(_Args)...);

	lea	rdi, QWORD PTR [r14+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 254  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	ebx, DWORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2829 :             : _Dir_enum_impl(_STD move(_Create_data)), _Options(_Options_arg) {}

	mov	rdx, rsi
	mov	rcx, rdi
	call	??0_Dir_enum_impl@filesystem@std@@QEAA@$$QEAU_Creator@012@W4directory_options@12@@Z ; std::filesystem::_Dir_enum_impl::_Dir_enum_impl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rdi+72], rbp
	mov	QWORD PTR [rdi+80], rbp
	mov	QWORD PTR [rdi+88], rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2829 :             : _Dir_enum_impl(_STD move(_Create_data)), _Options(_Options_arg) {}

	mov	DWORD PTR [rdi+96], ebx

; 2716 :         bool _Recursion_pending    = true;

	mov	BYTE PTR [rdi+100], 1
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [r15], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 1855 :         this->_Ptr = _Px;

	mov	QWORD PTR [r15], rdi

; 1856 :         this->_Rep = _Rx;

	mov	QWORD PTR [r15+8], r14

; 2780 :     shared_ptr<_Ty> _Ret;
; 2781 :     _Ret._Set_ptr_rep_and_enable_shared(_STD addressof(_Rx->_Storage._Value), _Rx);
; 2782 :     return _Ret;

	mov	rax, r15

; 2783 : }

	mov	rbx, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+96]
	mov	rsi, QWORD PTR [rsp+104]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
??$make_shared@U_Recursive_dir_enum_impl@filesystem@std@@U_Creator@_Dir_enum_impl@23@AEBW4directory_options@23@@std@@YA?AV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@0@$$QEAU_Creator@_Dir_enum_impl@filesystem@0@AEBW4directory_options@40@@Z ENDP ; std::make_shared<std::filesystem::_Recursive_dir_enum_impl,std::filesystem::_Dir_enum_impl::_Creator,enum std::filesystem::directory_options const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 80
__$ReturnUdt$ = 80
<_Args_0>$ = 88
<_Args_1>$ = 96
?dtor$0@?0???$make_shared@U_Recursive_dir_enum_impl@filesystem@std@@U_Creator@_Dir_enum_impl@23@AEBW4directory_options@23@@std@@YA?AV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@0@$$QEAU_Creator@_Dir_enum_impl@filesystem@0@AEBW4directory_options@40@@Z@4HA PROC ; `std::make_shared<std::filesystem::_Recursive_dir_enum_impl,std::filesystem::_Dir_enum_impl::_Creator,enum std::filesystem::directory_options const &>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 120				; 00000078H
	mov	rcx, QWORD PTR $T1[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$make_shared@U_Recursive_dir_enum_impl@filesystem@std@@U_Creator@_Dir_enum_impl@23@AEBW4directory_options@23@@std@@YA?AV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@0@$$QEAU_Creator@_Dir_enum_impl@filesystem@0@AEBW4directory_options@40@@Z@4HA ENDP ; `std::make_shared<std::filesystem::_Recursive_dir_enum_impl,std::filesystem::_Dir_enum_impl::_Creator,enum std::filesystem::directory_options const &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > > >, COMDAT

; 1133 :     // check that [_First, _Last) forms an iterator range
; 1134 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1135 :         _Verify_range(_First, _Last);
; 1136 :     }
; 1137 : }

	ret	0
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Find_unchecked@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@W4123@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@QEAW4123@AEBW4123@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Val$dead$ = 24
??$_Find_unchecked@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@W4123@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@QEAW4123@AEBW4123@@Z PROC ; std::_Find_unchecked<enum AINBNodeDefMgr::NodeDef::CategoryEnum *,enum AINBNodeDefMgr::NodeDef::CategoryEnum>, COMDAT

; 5802 :     // find first matching _Val; choose optimization
; 5803 :     // activate optimization for contiguous iterators to most scalar types (possibly const-qualified)
; 5804 :     if constexpr (_Vector_alg_in_find_is_safe<_InIt, _Ty>) {
; 5805 : #if _HAS_CXX20
; 5806 :         if (!_STD is_constant_evaluated())
; 5807 : #endif // _HAS_CXX20
; 5808 :         {
; 5809 :             if (!_STD _Could_compare_equal_to_value_type<_InIt>(_Val)) {
; 5810 :                 return _Last;
; 5811 :             }
; 5812 : #if _USE_STD_VECTOR_ALGORITHMS
; 5813 :             const auto _First_ptr = _To_address(_First);
; 5814 :             const auto _Result    = __std_find_trivial(_First_ptr, _To_address(_Last), _Val);
; 5815 :             if constexpr (is_pointer_v<_InIt>) {
; 5816 :                 return _Result;
; 5817 :             } else {
; 5818 :                 return _First + (_Result - _First_ptr);
; 5819 :             }
; 5820 : #else // ^^^ _USE_STD_VECTOR_ALGORITHMS / not _USE_STD_VECTOR_ALGORITHMS vvv
; 5821 :             if constexpr (sizeof(_Iter_value_t<_InIt>) == 1) {
; 5822 :                 const auto _First_ptr = _To_address(_First);
; 5823 :                 const auto _Result    = static_cast<remove_reference_t<_Iter_ref_t<_InIt>>*>(
; 5824 :                     _CSTD memchr(_First_ptr, static_cast<unsigned char>(_Val), static_cast<size_t>(_Last - _First)));
; 5825 :                 if constexpr (is_pointer_v<_InIt>) {
; 5826 :                     return _Result ? _Result : _Last;
; 5827 :                 } else {
; 5828 :                     return _Result ? _First + (_Result - _First_ptr) : _Last;
; 5829 :                 }
; 5830 :             }
; 5831 :             // TRANSITION, DevCom-1614562: not trying wmemchr
; 5832 : #endif // ^^^ not _USE_STD_VECTOR_ALGORITHMS ^^^
; 5833 :         }
; 5834 :     }
; 5835 : 
; 5836 :     for (; _First != _Last; ++_First) {

	cmp	rcx, rdx
	je	SHORT $LN13@Find_unche

; 5837 :         if (*_First == _Val) {

	movzx	eax, BYTE PTR ?AINBCategory@PopupAddAINBNode@@3W4CategoryEnum@NodeDef@AINBNodeDefMgr@@A ; PopupAddAINBNode::AINBCategory
	npad	4
$LL4@Find_unche:
	cmp	BYTE PTR [rcx], al
	je	SHORT $LN13@Find_unche

; 5802 :     // find first matching _Val; choose optimization
; 5803 :     // activate optimization for contiguous iterators to most scalar types (possibly const-qualified)
; 5804 :     if constexpr (_Vector_alg_in_find_is_safe<_InIt, _Ty>) {
; 5805 : #if _HAS_CXX20
; 5806 :         if (!_STD is_constant_evaluated())
; 5807 : #endif // _HAS_CXX20
; 5808 :         {
; 5809 :             if (!_STD _Could_compare_equal_to_value_type<_InIt>(_Val)) {
; 5810 :                 return _Last;
; 5811 :             }
; 5812 : #if _USE_STD_VECTOR_ALGORITHMS
; 5813 :             const auto _First_ptr = _To_address(_First);
; 5814 :             const auto _Result    = __std_find_trivial(_First_ptr, _To_address(_Last), _Val);
; 5815 :             if constexpr (is_pointer_v<_InIt>) {
; 5816 :                 return _Result;
; 5817 :             } else {
; 5818 :                 return _First + (_Result - _First_ptr);
; 5819 :             }
; 5820 : #else // ^^^ _USE_STD_VECTOR_ALGORITHMS / not _USE_STD_VECTOR_ALGORITHMS vvv
; 5821 :             if constexpr (sizeof(_Iter_value_t<_InIt>) == 1) {
; 5822 :                 const auto _First_ptr = _To_address(_First);
; 5823 :                 const auto _Result    = static_cast<remove_reference_t<_Iter_ref_t<_InIt>>*>(
; 5824 :                     _CSTD memchr(_First_ptr, static_cast<unsigned char>(_Val), static_cast<size_t>(_Last - _First)));
; 5825 :                 if constexpr (is_pointer_v<_InIt>) {
; 5826 :                     return _Result ? _Result : _Last;
; 5827 :                 } else {
; 5828 :                     return _Result ? _First + (_Result - _First_ptr) : _Last;
; 5829 :                 }
; 5830 :             }
; 5831 :             // TRANSITION, DevCom-1614562: not trying wmemchr
; 5832 : #endif // ^^^ not _USE_STD_VECTOR_ALGORITHMS ^^^
; 5833 :         }
; 5834 :     }
; 5835 : 
; 5836 :     for (; _First != _Last; ++_First) {

	inc	rcx
	cmp	rcx, rdx
	jne	SHORT $LL4@Find_unche
$LN13@Find_unche:

; 5838 :             break;
; 5839 :         }
; 5840 :     }
; 5841 : 
; 5842 :     return _First;
; 5843 : }

	mov	rax, rcx
	ret	0
??$_Find_unchecked@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@W4123@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@QEAW4123@AEBW4123@@Z ENDP ; std::_Find_unchecked<enum AINBNodeDefMgr::NodeDef::CategoryEnum *,enum AINBNodeDefMgr::NodeDef::CategoryEnum>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YAXAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@$$QEAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@Z
_TEXT	SEGMENT
_It$ = 8
_UIt$ = 16
??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YAXAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@$$QEAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@Z PROC ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > >,enum AINBNodeDefMgr::NodeDef::CategoryEnum *>, COMDAT

; 1256 :     if constexpr (_Wrapped_seekable_v<_Iter, _UIter>) {
; 1257 :         _It._Seek_to(_STD forward<_UIter>(_UIt));

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 1258 :     } else {
; 1259 :         _It = _STD forward<_UIter>(_UIt);
; 1260 :     }
; 1261 : }

	ret	0
??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YAXAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@$$QEAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@Z ENDP ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > >,enum AINBNodeDefMgr::NodeDef::CategoryEnum *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ??$_Convert_Source_to_wide@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@U_Normal_conversion@01@@Z
_TEXT	SEGMENT
$T2 = 48
__$ReturnUdt$GSCopy$ = 56
__$ReturnUdt$ = 96
_Source$ = 104
_Tag$dead$ = 112
??$_Convert_Source_to_wide@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@U_Normal_conversion@01@@Z PROC ; std::filesystem::_Convert_Source_to_wide<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::filesystem::_Normal_conversion>, COMDAT

; 282  :     _NODISCARD wstring _Convert_Source_to_wide(const _Src& _Source, _Conversion _Tag = {}) {

$LN63:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 64					; 00000040H
	mov	rsi, rdx
	mov	rbx, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
	xor	edi, edi
	mov	DWORD PTR $T2[rsp], edi

; 243  :         return basic_string_view<_EcharT>(_Source.data(), _Source.size()); // erase mismatching _Traits

	mov	rbp, QWORD PTR [rdx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rdx+24], 16
	jb	SHORT $LN10@Convert_So

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rsi, QWORD PTR [rdx]
$LN10@Convert_So:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 199  :             return _Convert_narrow_to_wide(__std_fs_code_page(), _Input);

	call	__std_fs_code_page
	mov	r14d, eax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rbx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], rdi

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 7

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	WORD PTR [rbx], di
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 58   :         return _Output;

	mov	DWORD PTR $T2[rsp], 4

; 44   :         if (!_Input.empty()) {

	test	rbp, rbp
	je	SHORT $LN53@Convert_So

; 45   :             if (_Input.size() > static_cast<size_t>(INT_MAX)) {

	cmp	rbp, 2147483647				; 7fffffffH
	ja	SHORT $LN59@Convert_So

; 47   :             }
; 48   : 
; 49   :             const int _Len = _Check_convert_result(__std_fs_convert_narrow_to_wide(

	mov	DWORD PTR [rsp+32], edi
	xor	r9d, r9d
	mov	r8d, ebp
	mov	rdx, rsi
	mov	ecx, eax
	call	__std_fs_convert_narrow_to_wide
	mov	rdi, rax
	shr	rax, 32					; 00000020H
	test	eax, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono

; 52   :     if (_Result._Err != __std_win_error::_Success) {

	jne	SHORT $LN60@Convert_So
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 52   :             _Output.resize(static_cast<size_t>(_Len));

	movsxd	rdx, edi
	mov	rcx, rbx
	call	?resize@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::resize
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	r9, rbx

; 2227 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rbx+24], 8
	jb	SHORT $LN48@Convert_So

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r9, QWORD PTR [rbx]
$LN48@Convert_So:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 54   :             (void) _Check_convert_result(__std_fs_convert_narrow_to_wide(

	mov	DWORD PTR [rsp+32], edi
	mov	r8d, ebp
	mov	rdx, rsi
	mov	ecx, r14d
	call	__std_fs_convert_narrow_to_wide
	mov	rcx, rax
	shr	rax, 32					; 00000020H
	test	eax, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono

; 52   :     if (_Result._Err != __std_win_error::_Success) {

	jne	SHORT $LN61@Convert_So
$LN53@Convert_So:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 283  :         return _Convert_stringoid_to_wide(_Stringoid_from_Source(_Source), _Tag);

	mov	rax, rbx

; 284  :     }

	mov	rbx, QWORD PTR [rsp+104]
	mov	rbp, QWORD PTR [rsp+112]
	add	rsp, 64					; 00000040H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN61@Convert_So:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono

; 53   :         _Throw_system_error_from_std_win_error(_Result._Err);

	shr	rcx, 32					; 00000020H
	call	?_Throw_system_error_from_std_win_error@std@@YAXW4__std_win_error@@@Z ; std::_Throw_system_error_from_std_win_error
	int	3
$LN59@Convert_So:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 46   :                 _Throw_system_error(errc::invalid_argument);

	call	?_Throw_system_error@std@@YAXW4errc@1@@Z ; std::_Throw_system_error
	int	3
$LN60@Convert_So:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono

; 53   :         _Throw_system_error_from_std_win_error(_Result._Err);

	shr	rdi, 32					; 00000020H
	mov	ecx, edi
	call	?_Throw_system_error_from_std_win_error@std@@YAXW4__std_win_error@@@Z ; std::_Throw_system_error_from_std_win_error
	int	3
$LN57@Convert_So:
??$_Convert_Source_to_wide@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@U_Normal_conversion@01@@Z ENDP ; std::filesystem::_Convert_Source_to_wide<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::filesystem::_Normal_conversion>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 48
__$ReturnUdt$GSCopy$ = 56
__$ReturnUdt$ = 96
_Source$ = 104
_Tag$dead$ = 112
?dtor$2@?0???$_Convert_Source_to_wide@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@U_Normal_conversion@01@@Z@4HA PROC ; `std::filesystem::_Convert_Source_to_wide<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::filesystem::_Normal_conversion>'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T2[rbp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN25@dtor$2
	and	DWORD PTR $T2[rbp], -5
	mov	rcx, QWORD PTR __$ReturnUdt$GSCopy$[rbp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
$LN25@dtor$2:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0???$_Convert_Source_to_wide@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@U_Normal_conversion@01@@Z@4HA ENDP ; `std::filesystem::_Convert_Source_to_wide<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::filesystem::_Normal_conversion>'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ??$_Stringoid_from_Source@DU?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?A_PAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Source$ = 16
??$_Stringoid_from_Source@DU?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?A_PAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::filesystem::_Stringoid_from_Source<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 16
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 243  :         return basic_string_view<_EcharT>(_Source.data(), _Source.size()); // erase mismatching _Traits

	mov	rax, QWORD PTR [rdx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN6@Stringoid_

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN6@Stringoid_:

; 1209 :         : _Mydata(_Cts), _Mysize(_Count) {

	mov	QWORD PTR [rcx+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 243  :         return basic_string_view<_EcharT>(_Source.data(), _Source.size()); // erase mismatching _Traits

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 1209 :         : _Mydata(_Cts), _Mysize(_Count) {

	mov	QWORD PTR [rcx], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 244  :     }

	ret	0
??$_Stringoid_from_Source@DU?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?A_PAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::filesystem::_Stringoid_from_Source<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAXPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Al$dead$ = 64
??$_Destroy_range@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAXPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z PROC ; std::_Destroy_range<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >, COMDAT

; 1082 : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

$LN21:

; 1083 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1084 :     using _Ty = typename _Alloc::value_type;
; 1085 :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rcx, rdx
	je	SHORT $LN18@Destroy_ra
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1082 : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

	mov	rdi, rdx
	mov	rbx, rcx
$LL4@Destroy_ra:

; 1083 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1084 :     using _Ty = typename _Alloc::value_type;
; 1085 :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 1086 :         for (; _First != _Last; ++_First) {

	mov	rcx, rbx
	call	??1ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ
	add	rbx, 96					; 00000060H
	cmp	rbx, rdi
	jne	SHORT $LL4@Destroy_ra

; 1087 :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 1088 :         }
; 1089 :     }
; 1090 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
$LN18@Destroy_ra:
	ret	0
??$_Destroy_range@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAXPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
_Val$dead$ = 64
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT

; 1511 :     _CONSTEXPR20 void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

$LN21:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1512 :         if (_Newsize > max_size()) {

	mov	rbx, 192153584101141162			; 02aaaaaaaaaaaaaaH
	mov	rdi, rdx
	mov	rsi, rcx
	cmp	rdx, rbx
	ja	$LN19@Resize_rea

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rdx, -6148914691236517205		; aaaaaaaaaaaaaaabH
	mov	QWORD PTR [rsp+48], rbp
	mov	QWORD PTR [rsp+56], r14

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, rbx

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r14, QWORD PTR [rcx+8]
	sub	r14, QWORD PTR [rcx]

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, QWORD PTR [rsi]
	sar	rcx, 5
	imul	rcx, rdx

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	sar	r14, 5
	imul	r14, rdx

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	shr	rdx, 1
	sub	rax, rdx
	cmp	rcx, rax
	ja	SHORT $LN11@Resize_rea

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rbx, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rbx, rdi
	cmovb	rbx, rdi
$LN11@Resize_rea:

; 1522 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1523 : 
; 1524 :         const pointer _Newvec         = _Al.allocate(_Newcapacity);

	mov	rdx, rbx
	call	?allocate@?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z ; std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>::allocate

; 1525 :         const pointer _Appended_first = _Newvec + _Oldsize;

	lea	rcx, QWORD PTR [r14+r14*2]

; 1526 :         pointer _Appended_last        = _Appended_first;
; 1527 : 
; 1528 :         _TRY_BEGIN
; 1529 :         if constexpr (is_same_v<_Ty2, _Ty>) {
; 1530 :             _Appended_last = _Uninitialized_fill_n(_Appended_first, _Newsize - _Oldsize, _Val, _Al);
; 1531 :         } else {
; 1532 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1533 :             _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);

	mov	rdx, rdi
	shl	rcx, 5
	sub	rdx, r14
	add	rcx, rax
	mov	rbp, rax
	call	??$_Uninitialized_value_construct_n@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@_KAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >

; 1534 :         }
; 1535 : 
; 1536 :         if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 1537 :             _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	rdx, QWORD PTR [rsi+8]
	mov	r8, rbp
	mov	rcx, QWORD PTR [rsi]
	call	??$_Uninitialized_move@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@0PEAU123@AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z ; std::_Uninitialized_move<AINBNodeDefMgr::NodeDef::ImmediateParam *,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >
	mov	r14, QWORD PTR [rsp+56]

; 1538 :         } else {
; 1539 :             _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 1540 :         }
; 1541 :         _CATCH_ALL
; 1542 :         _Destroy_range(_Appended_first, _Appended_last, _Al);
; 1543 :         _Al.deallocate(_Newvec, _Newcapacity);
; 1544 :         _RERAISE;
; 1545 :         _CATCH_END
; 1546 : 
; 1547 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, rbx
	mov	r8, rdi
	mov	rdx, rbp
	mov	rcx, rsi
	mov	rbp, QWORD PTR [rsp+48]

; 1548 :     }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1538 :         } else {
; 1539 :             _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 1540 :         }
; 1541 :         _CATCH_ALL
; 1542 :         _Destroy_range(_Appended_first, _Appended_last, _Al);
; 1543 :         _Al.deallocate(_Newvec, _Newcapacity);
; 1544 :         _RERAISE;
; 1545 :         _CATCH_END
; 1546 : 
; 1547 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	jmp	?_Change_array@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K1@Z ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Change_array
$LN19@Resize_rea:

; 1513 :             _Xlength();

	call	?_Xlength@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Xlength
	int	3
$LN17@Resize_rea:
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@_KAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Count$ = 16
_Al$dead$ = 24
??$_Uninitialized_value_construct_n@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@_KAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >, COMDAT

; 2041 :     for (; 0 < _Count; --_Count) {

	test	rdx, rdx
	je	SHORT $LN75@Uninitiali
	lea	rax, QWORD PTR [rcx+64]
	xor	r8d, r8d
	npad	4
$LL4@Uninitiali:
	xorps	xmm0, xmm0

; 1803 :         ++_Last;

	lea	rax, QWORD PTR [rax+96]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	XMMWORD PTR [rcx+16], xmm0
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	XMMWORD PTR [rcx+48], xmm0
	movups	XMMWORD PTR [rcx+64], xmm0
	movups	XMMWORD PTR [rcx+80], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rax-144], r8

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rax-136], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], r8b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rcx, 96					; 00000060H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rax-120], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rax-104], r8

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rax-96], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rax-120], r8b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rax-88], r8
	mov	QWORD PTR [rax-80], r8
	mov	QWORD PTR [rax-72], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rdx, 1
	jne	SHORT $LL4@Uninitiali
$LN75@Uninitiali:

; 2042 :         _Backout._Emplace_back();
; 2043 :     }
; 2044 : 
; 2045 :     return _Backout._Release();
; 2046 : }

	mov	rax, rcx
	ret	0
??$_Uninitialized_value_construct_n@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@_KAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@@Z PROC ; std::forward<AINBNodeDefMgr::NodeDef::ImmediateParam>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@@Z ENDP ; std::forward<AINBNodeDefMgr::NodeDef::ImmediateParam>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
_Val$dead$ = 64
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<AINBFile::OutputEntry,std::allocator<AINBFile::OutputEntry> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT

; 1511 :     _CONSTEXPR20 void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

$LN21:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1512 :         if (_Newsize > max_size()) {

	mov	rbx, 256204778801521550			; 038e38e38e38e38eH
	mov	rdi, rdx
	mov	rsi, rcx
	cmp	rdx, rbx
	ja	$LN19@Resize_rea

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	QWORD PTR [rsp+48], r14
	mov	rdx, -8198552921648689607		; 8e38e38e38e38e39H
	mov	r14, QWORD PTR [rcx+8]

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, rbx

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	sub	r14, QWORD PTR [rcx]

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, QWORD PTR [rsi]
	sar	rcx, 3
	imul	rcx, rdx

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	sar	r14, 3
	imul	r14, rdx

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	mov	QWORD PTR [rsp+56], r15
	shr	rdx, 1
	sub	rax, rdx
	cmp	rcx, rax
	ja	SHORT $LN11@Resize_rea

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rbx, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rbx, rdi
	cmovb	rbx, rdi
$LN11@Resize_rea:

; 1522 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1523 : 
; 1524 :         const pointer _Newvec         = _Al.allocate(_Newcapacity);

	mov	rdx, rbx
	call	?allocate@?$allocator@UOutputEntry@AINBFile@@@std@@QEAAPEAUOutputEntry@AINBFile@@_K@Z ; std::allocator<AINBFile::OutputEntry>::allocate

; 1525 :         const pointer _Appended_first = _Newvec + _Oldsize;
; 1526 :         pointer _Appended_last        = _Appended_first;
; 1527 : 
; 1528 :         _TRY_BEGIN
; 1529 :         if constexpr (is_same_v<_Ty2, _Ty>) {
; 1530 :             _Appended_last = _Uninitialized_fill_n(_Appended_first, _Newsize - _Oldsize, _Val, _Al);
; 1531 :         } else {
; 1532 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1533 :             _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);

	mov	rdx, rdi
	lea	rcx, QWORD PTR [r14+r14*8]
	sub	rdx, r14
	mov	r15, rax
	lea	rcx, QWORD PTR [rax+rcx*8]
	call	??$_Uninitialized_value_construct_n@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@YAPEAUOutputEntry@AINBFile@@PEAU12@_KAEAV?$allocator@UOutputEntry@AINBFile@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<AINBFile::OutputEntry> >

; 1534 :         }
; 1535 : 
; 1536 :         if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 1537 :             _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	rdx, QWORD PTR [rsi+8]
	mov	r8, r15
	mov	rcx, QWORD PTR [rsi]
	call	??$_Uninitialized_move@PEAUOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@YAPEAUOutputEntry@AINBFile@@QEAU12@0PEAU12@AEAV?$allocator@UOutputEntry@AINBFile@@@0@@Z ; std::_Uninitialized_move<AINBFile::OutputEntry *,std::allocator<AINBFile::OutputEntry> >
	mov	r14, QWORD PTR [rsp+48]

; 1538 :         } else {
; 1539 :             _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 1540 :         }
; 1541 :         _CATCH_ALL
; 1542 :         _Destroy_range(_Appended_first, _Appended_last, _Al);
; 1543 :         _Al.deallocate(_Newvec, _Newcapacity);
; 1544 :         _RERAISE;
; 1545 :         _CATCH_END
; 1546 : 
; 1547 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, rbx
	mov	r8, rdi
	mov	rdx, r15
	mov	rcx, rsi
	mov	r15, QWORD PTR [rsp+56]

; 1548 :     }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1538 :         } else {
; 1539 :             _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 1540 :         }
; 1541 :         _CATCH_ALL
; 1542 :         _Destroy_range(_Appended_first, _Appended_last, _Al);
; 1543 :         _Al.deallocate(_Newvec, _Newcapacity);
; 1544 :         _RERAISE;
; 1545 :         _CATCH_END
; 1546 : 
; 1547 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	jmp	?_Change_array@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@AEAAXQEAUOutputEntry@AINBFile@@_K1@Z ; std::vector<AINBFile::OutputEntry,std::allocator<AINBFile::OutputEntry> >::_Change_array
$LN19@Resize_rea:

; 1513 :             _Xlength();

	call	?_Xlength@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@CAXXZ ; std::vector<AINBFile::OutputEntry,std::allocator<AINBFile::OutputEntry> >::_Xlength
	int	3
$LN17@Resize_rea:
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UOutputEntry@AINBFile@@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<AINBFile::OutputEntry,std::allocator<AINBFile::OutputEntry> >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@YAPEAUOutputEntry@AINBFile@@PEAU12@_KAEAV?$allocator@UOutputEntry@AINBFile@@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Count$ = 16
_Al$dead$ = 24
??$_Uninitialized_value_construct_n@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@YAPEAUOutputEntry@AINBFile@@PEAU12@_KAEAV?$allocator@UOutputEntry@AINBFile@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<AINBFile::OutputEntry> >, COMDAT

; 2041 :     for (; 0 < _Count; --_Count) {

	test	rdx, rdx
	je	SHORT $LN78@Uninitiali
	lea	rax, QWORD PTR [rcx+64]
	xor	r8d, r8d
	npad	4
$LL4@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR [rcx+16], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	lea	rax, QWORD PTR [rax+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR [rcx+24], r8
	xorps	xmm0, xmm0
	mov	QWORD PTR [rcx+32], r8
	mov	QWORD PTR [rcx+40], r8
	mov	QWORD PTR [rcx+48], r8
	mov	QWORD PTR [rcx+56], r8
	mov	QWORD PTR [rcx+64], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rax-120], r8

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rax-112], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], r8b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rcx, 72					; 00000048H
	mov	BYTE PTR [rax-104], r8b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rax-96], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rax-80], r8

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rax-72], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rax-96], r8b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rdx, 1
	jne	SHORT $LL4@Uninitiali
$LN78@Uninitiali:

; 2042 :         _Backout._Emplace_back();
; 2043 :     }
; 2044 : 
; 2045 :     return _Backout._Release();
; 2046 : }

	mov	rax, rcx
	ret	0
??$_Uninitialized_value_construct_n@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@YAPEAUOutputEntry@AINBFile@@PEAU12@_KAEAV?$allocator@UOutputEntry@AINBFile@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<AINBFile::OutputEntry> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAXPEAUInputParam@NodeDef@AINBNodeDefMgr@@QEAU123@AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Al$dead$ = 64
??$_Destroy_range@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAXPEAUInputParam@NodeDef@AINBNodeDefMgr@@QEAU123@AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z PROC ; std::_Destroy_range<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >, COMDAT

; 1082 : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

$LN21:

; 1083 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1084 :     using _Ty = typename _Alloc::value_type;
; 1085 :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rcx, rdx
	je	SHORT $LN18@Destroy_ra
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1082 : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

	mov	rdi, rdx
	mov	rbx, rcx
$LL4@Destroy_ra:

; 1083 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1084 :     using _Ty = typename _Alloc::value_type;
; 1085 :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 1086 :         for (; _First != _Last; ++_First) {

	mov	rcx, rbx
	call	??1InputParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ
	add	rbx, 144				; 00000090H
	cmp	rbx, rdi
	jne	SHORT $LL4@Destroy_ra

; 1087 :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 1088 :         }
; 1089 :     }
; 1090 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
$LN18@Destroy_ra:
	ret	0
??$_Destroy_range@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAXPEAUInputParam@NodeDef@AINBNodeDefMgr@@QEAU123@AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
_Val$dead$ = 64
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT

; 1511 :     _CONSTEXPR20 void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

$LN21:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1512 :         if (_Newsize > max_size()) {

	mov	rbx, 128102389400760775			; 01c71c71c71c71c7H
	mov	rdi, rdx
	mov	rsi, rcx
	cmp	rdx, rbx
	ja	$LN19@Resize_rea

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rdx, -8198552921648689607		; 8e38e38e38e38e39H
	mov	QWORD PTR [rsp+48], rbp
	mov	QWORD PTR [rsp+56], r14

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, rbx

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r14, QWORD PTR [rcx+8]
	sub	r14, QWORD PTR [rcx]

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, QWORD PTR [rsi]
	sar	rcx, 4
	imul	rcx, rdx

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	sar	r14, 4
	imul	r14, rdx

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	shr	rdx, 1
	sub	rax, rdx
	cmp	rcx, rax
	ja	SHORT $LN11@Resize_rea

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rbx, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rbx, rdi
	cmovb	rbx, rdi
$LN11@Resize_rea:

; 1522 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1523 : 
; 1524 :         const pointer _Newvec         = _Al.allocate(_Newcapacity);

	mov	rdx, rbx
	call	?allocate@?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAPEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z ; std::allocator<AINBNodeDefMgr::NodeDef::InputParam>::allocate

; 1525 :         const pointer _Appended_first = _Newvec + _Oldsize;

	lea	rcx, QWORD PTR [r14+r14*8]

; 1526 :         pointer _Appended_last        = _Appended_first;
; 1527 : 
; 1528 :         _TRY_BEGIN
; 1529 :         if constexpr (is_same_v<_Ty2, _Ty>) {
; 1530 :             _Appended_last = _Uninitialized_fill_n(_Appended_first, _Newsize - _Oldsize, _Val, _Al);
; 1531 :         } else {
; 1532 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1533 :             _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);

	mov	rdx, rdi
	shl	rcx, 4
	sub	rdx, r14
	add	rcx, rax
	mov	rbp, rax
	call	??$_Uninitialized_value_construct_n@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@_KAEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >

; 1534 :         }
; 1535 : 
; 1536 :         if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 1537 :             _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	rdx, QWORD PTR [rsi+8]
	mov	r8, rbp
	mov	rcx, QWORD PTR [rsi]
	call	??$_Uninitialized_move@PEAUInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@QEAU123@0PEAU123@AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z ; std::_Uninitialized_move<AINBNodeDefMgr::NodeDef::InputParam *,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >
	mov	r14, QWORD PTR [rsp+56]

; 1538 :         } else {
; 1539 :             _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 1540 :         }
; 1541 :         _CATCH_ALL
; 1542 :         _Destroy_range(_Appended_first, _Appended_last, _Al);
; 1543 :         _Al.deallocate(_Newvec, _Newcapacity);
; 1544 :         _RERAISE;
; 1545 :         _CATCH_END
; 1546 : 
; 1547 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, rbx
	mov	r8, rdi
	mov	rdx, rbp
	mov	rcx, rsi
	mov	rbp, QWORD PTR [rsp+48]

; 1548 :     }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1538 :         } else {
; 1539 :             _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 1540 :         }
; 1541 :         _CATCH_ALL
; 1542 :         _Destroy_range(_Appended_first, _Appended_last, _Al);
; 1543 :         _Al.deallocate(_Newvec, _Newcapacity);
; 1544 :         _RERAISE;
; 1545 :         _CATCH_END
; 1546 : 
; 1547 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	jmp	?_Change_array@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUInputParam@NodeDef@AINBNodeDefMgr@@_K1@Z ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Change_array
$LN19@Resize_rea:

; 1513 :             _Xlength();

	call	?_Xlength@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Xlength
	int	3
$LN17@Resize_rea:
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@_KAEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Count$ = 16
_Al$dead$ = 24
??$_Uninitialized_value_construct_n@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@_KAEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >, COMDAT

; 2026 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

	mov	rax, rcx

; 2041 :     for (; 0 < _Count; --_Count) {

	test	rdx, rdx
	je	$LN98@Uninitiali
	add	rcx, 56					; 00000038H
	xor	r8d, r8d
	npad	13
$LL4@Uninitiali:
	xorps	xmm0, xmm0

; 1803 :         ++_Last;

	lea	rcx, QWORD PTR [rcx+144]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	XMMWORD PTR [rax+16], xmm0
	movups	XMMWORD PTR [rax+32], xmm0
	movups	XMMWORD PTR [rax+48], xmm0
	movups	XMMWORD PTR [rax+64], xmm0
	movups	XMMWORD PTR [rax+80], xmm0
	movups	XMMWORD PTR [rax+96], xmm0
	movups	XMMWORD PTR [rax+112], xmm0
	movups	XMMWORD PTR [rax+128], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rax], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx-184], r8

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx-176], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rax], r8b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rax, 144				; 00000090H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx-168], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx-152], r8

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx-144], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx-168], r8b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx-136], r8
	mov	QWORD PTR [rcx-128], r8
	mov	QWORD PTR [rcx-120], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	mov	DWORD PTR [rcx-112], r8d

; 795  :           _Which{static_cast<_Index_t>(_Idx)} { // initialize alternative _Idx from _Args...

	mov	BYTE PTR [rcx-80], r8b
	mov	BYTE PTR [rcx-68], r8b
	mov	DWORD PTR [rcx-64], 65535		; 0000ffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rdx, 1
	jne	$LL4@Uninitiali
$LN98@Uninitiali:

; 2042 :         _Backout._Emplace_back();
; 2043 :     }
; 2044 : 
; 2045 :     return _Backout._Release();
; 2046 : }

	ret	0
??$_Uninitialized_value_construct_n@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@_KAEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$dead$ = 64
_Newsize$ = 72
_Val$dead$ = 80
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT

; 1511 :     _CONSTEXPR20 void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

$LN101:
	push	rbp
	push	rsi
	sub	rsp, 40					; 00000028H

; 1512 :         if (_Newsize > max_size()) {

	mov	rsi, 74382032555280450			; 0108421084210842H
	mov	rbp, rdx
	cmp	rdx, rsi
	ja	$LN99@Resize_rea

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR ?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A+16

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rdx, -1190112520884487201		; ef7bdef7bdef7bdfH

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sub	rcx, QWORD PTR ?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, rsi
	mov	QWORD PTR [rsp+64], rbx

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	rcx, 3
	imul	rcx, rdx
	mov	QWORD PTR [rsp+80], rdi
	mov	QWORD PTR [rsp+88], r14

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r14, QWORD PTR ?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A+8
	sub	r14, QWORD PTR ?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A
	sar	r14, 3
	imul	r14, rdx

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	mov	QWORD PTR [rsp+32], r15
	shr	rdx, 1
	sub	rax, rdx
	cmp	rcx, rax
	ja	SHORT $LN11@Resize_rea

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rsi, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rsi, rbp
	cmovb	rsi, rbp
$LN11@Resize_rea:

; 1522 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1523 : 
; 1524 :         const pointer _Newvec         = _Al.allocate(_Newcapacity);

	mov	rdx, rsi
	call	?allocate@?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@QEAAPEAUNodeDef@AINBNodeDefMgr@@_K@Z ; std::allocator<AINBNodeDefMgr::NodeDef>::allocate

; 1525 :         const pointer _Appended_first = _Newvec + _Oldsize;

	imul	rbx, r14, 248				; 000000f8H

; 1526 :         pointer _Appended_last        = _Appended_first;
; 1527 : 
; 1528 :         _TRY_BEGIN
; 1529 :         if constexpr (is_same_v<_Ty2, _Ty>) {
; 1530 :             _Appended_last = _Uninitialized_fill_n(_Appended_first, _Newsize - _Oldsize, _Val, _Al);
; 1531 :         } else {
; 1532 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1533 :             _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);

	mov	rdi, rbp
	mov	r15, rax
	add	rbx, rax
	sub	rdi, r14
	mov	r14, QWORD PTR [rsp+88]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2041 :     for (; 0 < _Count; --_Count) {

	je	SHORT $LN17@Resize_rea
	npad	11
$LL18@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	edx, edx
	mov	r8d, 248				; 000000f8H
	mov	rcx, rbx
	call	memset
	mov	rcx, rbx
	call	??0NodeDef@AINBNodeDefMgr@@QEAA@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rbx, 248				; 000000f8H

; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rdi, 1
	jne	SHORT $LL18@Resize_rea
$LN17@Resize_rea:

; 1932 :     const auto _ULast = _Get_unwrapped(_Last);

	mov	rdi, QWORD PTR ?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A+8

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	rbx, r15

; 1927 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	mov	r11, QWORD PTR ?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A

; 1933 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1934 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1935 : #if _HAS_CXX20
; 1936 :         if (!_STD is_constant_evaluated())
; 1937 : #endif // _HAS_CXX20
; 1938 :         {
; 1939 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1940 :             return _Dest + (_ULast - _UFirst);
; 1941 :         }
; 1942 :     }
; 1943 : 
; 1944 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	r11, rdi
	je	SHORT $LN48@Resize_rea
	npad	5
$LL49@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rdx, r11
	mov	rcx, rbx
	call	??0NodeDef@AINBNodeDefMgr@@QEAA@$$QEAU01@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rbx, 248				; 000000f8H

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	r11, 248				; 000000f8H
	cmp	r11, rdi
	jne	SHORT $LL49@Resize_rea
$LN48@Resize_rea:
	mov	rdi, QWORD PTR [rsp+80]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1537 :             _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	rbx, QWORD PTR [rsp+64]

; 1538 :         } else {
; 1539 :             _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 1540 :         }
; 1541 :         _CATCH_ALL
; 1542 :         _Destroy_range(_Appended_first, _Appended_last, _Al);
; 1543 :         _Al.deallocate(_Newvec, _Newcapacity);
; 1544 :         _RERAISE;
; 1545 :         _CATCH_END
; 1546 : 
; 1547 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, rsi
	mov	r8, rbp
	mov	rdx, r15
	mov	r15, QWORD PTR [rsp+32]

; 1548 :     }

	add	rsp, 40					; 00000028H
	pop	rsi
	pop	rbp

; 1538 :         } else {
; 1539 :             _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 1540 :         }
; 1541 :         _CATCH_ALL
; 1542 :         _Destroy_range(_Appended_first, _Appended_last, _Al);
; 1543 :         _Al.deallocate(_Newvec, _Newcapacity);
; 1544 :         _RERAISE;
; 1545 :         _CATCH_END
; 1546 : 
; 1547 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	jmp	?_Change_array@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUNodeDef@AINBNodeDefMgr@@_K1@Z ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::_Change_array
$LN99@Resize_rea:

; 1513 :             _Xlength();

	call	?_Xlength@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::_Xlength
	int	3
$LN97@Resize_rea:
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUNodeDef@AINBNodeDefMgr@@PEAU12@_KAEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Al$dead$ = 64
??$_Uninitialized_value_construct_n@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUNodeDef@AINBNodeDefMgr@@PEAU12@_KAEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<AINBNodeDefMgr::NodeDef> >, COMDAT

; 2026 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

$LN45:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx
	mov	rbx, rcx

; 2027 :     // value-initialize _Count objects to raw _First, using _Al
; 2028 :     using _Ptrty = typename _Alloc::value_type*;
; 2029 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2030 : #if _HAS_CXX20
; 2031 :         if (!_STD is_constant_evaluated())
; 2032 : #endif // _HAS_CXX20
; 2033 :         {
; 2034 :             auto _PFirst = _Unfancy(_First);
; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2036 :             return _First + _Count;
; 2037 :         }
; 2038 :     }
; 2039 : 
; 2040 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2041 :     for (; 0 < _Count; --_Count) {

	test	rdx, rdx
	je	SHORT $LN40@Uninitiali
	npad	11
$LL4@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	edx, edx
	mov	r8d, 248				; 000000f8H
	mov	rcx, rbx
	call	memset
	mov	rcx, rbx
	call	??0NodeDef@AINBNodeDefMgr@@QEAA@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rbx, 248				; 000000f8H

; 2027 :     // value-initialize _Count objects to raw _First, using _Al
; 2028 :     using _Ptrty = typename _Alloc::value_type*;
; 2029 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2030 : #if _HAS_CXX20
; 2031 :         if (!_STD is_constant_evaluated())
; 2032 : #endif // _HAS_CXX20
; 2033 :         {
; 2034 :             auto _PFirst = _Unfancy(_First);
; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2036 :             return _First + _Count;
; 2037 :         }
; 2038 :     }
; 2039 : 
; 2040 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rdi, 1
	jne	SHORT $LL4@Uninitiali
$LN40@Uninitiali:

; 2042 :         _Backout._Emplace_back();
; 2043 :     }
; 2044 : 
; 2045 :     return _Backout._Release();
; 2046 : }

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_value_construct_n@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUNodeDef@AINBNodeDefMgr@@PEAU12@_KAEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<AINBNodeDefMgr::NodeDef> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$destroy_at@U_Find_file_handle@filesystem@std@@@std@@YAXQEAU_Find_file_handle@filesystem@0@@Z
_TEXT	SEGMENT
_Location$ = 8
??$destroy_at@U_Find_file_handle@filesystem@std@@@std@@YAXQEAU_Find_file_handle@filesystem@0@@Z PROC ; std::destroy_at<std::filesystem::_Find_file_handle>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 605  :             __std_fs_directory_iterator_close(_Handle);

	mov	rcx, QWORD PTR [rcx]
	jmp	__std_fs_directory_iterator_close
??$destroy_at@U_Find_file_handle@filesystem@std@@@std@@YAXQEAU_Find_file_handle@filesystem@0@@Z ENDP ; std::destroy_at<std::filesystem::_Find_file_handle>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@U_Find_file_handle@filesystem@std@@@std@@YA$$QEAU_Find_file_handle@filesystem@0@AEAU120@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@U_Find_file_handle@filesystem@std@@@std@@YA$$QEAU_Find_file_handle@filesystem@0@AEAU120@@Z PROC ; std::forward<std::filesystem::_Find_file_handle>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@U_Find_file_handle@filesystem@std@@@std@@YA$$QEAU_Find_file_handle@filesystem@0@AEAU120@@Z ENDP ; std::forward<std::filesystem::_Find_file_handle>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@U_Find_file_handle@filesystem@std@@@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAAEAU_Find_file_handle@filesystem@1@$$QEAU231@@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$_Emplace_back_with_unused_capacity@U_Find_file_handle@filesystem@std@@@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAAEAU_Find_file_handle@filesystem@1@$$QEAU231@@Z PROC ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::_Emplace_back_with_unused_capacity<std::filesystem::_Find_file_handle>, COMDAT

; 790  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 791  :         auto& _My_data   = _Mypair._Myval2;
; 792  :         pointer& _Mylast = _My_data._Mylast;
; 793  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 794  :         if constexpr (conjunction_v<is_nothrow_constructible<_Ty, _Valty...>,
; 795  :                           _Uses_default_construct<_Alloc, _Ty*, _Valty...>>) {
; 796  :             _ASAN_VECTOR_MODIFY(1);
; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);
; 798  :         } else {
; 799  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 800  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 801  :             _ASAN_VECTOR_RELEASE_GUARD;
; 802  :         }
; 803  : 
; 804  :         _Orphan_range(_Mylast, _Mylast);
; 805  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR [rdx]
	mov	r8, QWORD PTR [rcx+8]
	mov	QWORD PTR [rdx], -1
	mov	QWORD PTR [r8], rax
	mov	rax, QWORD PTR [rcx+8]

; 806  :         ++_Mylast;

	lea	rdx, QWORD PTR [rax+8]
	mov	QWORD PTR [rcx+8], rdx

; 807  : 
; 808  :         return _Result;
; 809  :     }

	ret	0
??$_Emplace_back_with_unused_capacity@U_Find_file_handle@filesystem@std@@@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAAEAU_Find_file_handle@filesystem@1@$$QEAU231@@Z ENDP ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::_Emplace_back_with_unused_capacity<std::filesystem::_Find_file_handle>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Emplace_reallocate@U_Find_file_handle@filesystem@std@@@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAPEAU_Find_file_handle@filesystem@1@QEAU231@$$QEAU231@@Z
_TEXT	SEGMENT
this$ = 96
_Whereptr$ = 104
<_Val_0>$ = 112
??$_Emplace_reallocate@U_Find_file_handle@filesystem@std@@@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAPEAU_Find_file_handle@filesystem@1@QEAU231@$$QEAU231@@Z PROC ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::_Emplace_reallocate<std::filesystem::_Find_file_handle>, COMDAT

; 812  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN255:
	push	rbx
	push	rbp
	push	rsi
	push	r15
	sub	rsp, 56					; 00000038H

; 813  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 814  :         _Alty& _Al        = _Getal();
; 815  :         auto& _My_data    = _Mypair._Myval2;
; 816  :         pointer& _Myfirst = _My_data._Myfirst;
; 817  :         pointer& _Mylast  = _My_data._Mylast;
; 818  : 
; 819  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 820  : 
; 821  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);
; 822  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	mov	rbx, rdx
	mov	rdx, QWORD PTR [rcx]
	mov	rbp, rbx
	sub	rbp, rdx
	sub	rax, rdx
	mov	r15, r8
	sar	rbp, 3
	sar	rax, 3

; 823  : 
; 824  :         if (_Oldsize == max_size()) {

	mov	r8, 2305843009213693951			; 1fffffffffffffffH
	mov	rsi, rcx
	cmp	rax, r8
	je	$LN253@Emplace_re

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, rdx
	mov	QWORD PTR [rsp+48], rdi
	sar	rcx, 3
	mov	QWORD PTR [rsp+40], r12

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx

; 826  :         }
; 827  : 
; 828  :         const size_type _Newsize     = _Oldsize + 1;

	lea	r12, QWORD PTR [rax+1]

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	shr	rdx, 1
	mov	rax, r8
	mov	QWORD PTR [rsp+32], r14
	sub	rax, rdx
	cmp	rcx, rax
	ja	$LN230@Emplace_re

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [rdx+rcx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 70   :         if (_Count > _Max_possible) {

	mov	r14, r12
	cmp	rax, r12
	cmovae	r14, rax
	cmp	r14, r8
	ja	$LN230@Emplace_re

; 71   :             _Throw_bad_array_new_length(); // multiply overflow
; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	lea	r14, QWORD PTR [r14*8]

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	r14, 4096				; 00001000H
	jb	SHORT $LN25@Emplace_re

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [r14+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, r14
	jbe	$LN230@Emplace_re

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN194@Emplace_re

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN23@Emplace_re
$LN25@Emplace_re:

; 240  :         }
; 241  :     }
; 242  : #endif // defined(_M_IX86) || defined(_M_X64)
; 243  : 
; 244  :     if (_Bytes != 0) {

	test	r14, r14
	je	SHORT $LN26@Emplace_re

; 87   :         return ::operator new(_Bytes);

	mov	rcx, r14
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax

; 245  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN23@Emplace_re
$LN26@Emplace_re:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

	xor	edi, edi
$LN23@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [r15]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 839  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	rdx, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r15], -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 591  :             : _Handle(_STD exchange(_Rhs._Handle, __std_fs_dir_handle::_Invalid)) {}

	lea	r15, QWORD PTR [rdi+rbp*8]
	mov	QWORD PTR [r15], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 839  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	r8, QWORD PTR [rsi+8]
	mov	rcx, QWORD PTR [rsi]
	cmp	rbx, r8
	jne	SHORT $LN4@Emplace_re
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, r8
	je	SHORT $LN129@Emplace_re
	npad	5
$LL56@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rcx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	lea	rdx, QWORD PTR [rdx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rcx], -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	rcx, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 591  :             : _Handle(_STD exchange(_Rhs._Handle, __std_fs_dir_handle::_Invalid)) {}

	mov	QWORD PTR [rdx-8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, r8
	jne	SHORT $LL56@Emplace_re
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 845  :         } else { // provide basic guarantee

	jmp	SHORT $LN129@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, rbx
	je	SHORT $LN92@Emplace_re
$LL93@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rcx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	lea	rdx, QWORD PTR [rdx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rcx], -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	rcx, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 591  :             : _Handle(_STD exchange(_Rhs._Handle, __std_fs_dir_handle::_Invalid)) {}

	mov	QWORD PTR [rdx-8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, rbx
	jne	SHORT $LL93@Emplace_re
$LN92@Emplace_re:

; 1932 :     const auto _ULast = _Get_unwrapped(_Last);

	mov	rcx, QWORD PTR [rsi+8]

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rbx, rcx
	je	SHORT $LN129@Emplace_re

; 1804 :     }
; 1805 : 
; 1806 :     constexpr pointer _Release() { // suppress any exception handling backout and return _Last
; 1807 :         _First = _Last;
; 1808 :         return _Last;
; 1809 :     }
; 1810 : 
; 1811 : private:
; 1812 :     pointer _First;
; 1813 :     pointer _Last;
; 1814 :     _Alloc& _Al;
; 1815 : };
; 1816 : 
; 1817 : template <class _InIt, class _Se, class _Alloc>
; 1818 : _CONSTEXPR20 _Alloc_ptr_t<_Alloc> _Uninitialized_copy(
; 1819 :     _InIt _First, _Se _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {
; 1820 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1821 :     // note: only called internally from elsewhere in the STL
; 1822 :     using _Ptrval = typename _Alloc::value_type*;
; 1823 : 
; 1824 : #ifdef __cpp_lib_concepts
; 1825 :     auto _UFirst = _RANGES _Unwrap_iter<_Se>(_STD move(_First));
; 1826 :     auto _ULast  = _RANGES _Unwrap_sent<_InIt>(_STD move(_Last));
; 1827 : #else // ^^^ __cpp_lib_concepts / !__cpp_lib_concepts vvv
; 1828 :     // In pre-concepts world, _Uninitialized_copy should only ever be called with an iterator
; 1829 :     // and sentinel of the same type, so `_Get_unwrapped` is fine to call.
; 1830 :     auto _UFirst = _Get_unwrapped(_STD move(_First));
; 1831 :     auto _ULast  = _Get_unwrapped(_STD move(_Last));
; 1832 : #endif // ^^^ !__cpp_lib_concepts ^^^
; 1833 : 
; 1834 :     constexpr bool _Can_memmove = _Sent_copy_cat<decltype(_UFirst), decltype(_ULast), _Ptrval>::_Bitcopy_constructible
; 1835 :                                && _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>::value;
; 1836 : 
; 1837 :     if constexpr (_Can_memmove) {
; 1838 : #if _HAS_CXX20
; 1839 :         if (!_STD is_constant_evaluated())
; 1840 : #endif // _HAS_CXX20
; 1841 :         {
; 1842 :             if constexpr (is_same_v<decltype(_UFirst), decltype(_ULast)>) {
; 1843 :                 _Copy_memmove(_To_address(_UFirst), _To_address(_ULast), _Unfancy(_Dest));
; 1844 :                 _Dest += _ULast - _UFirst;
; 1845 :             } else {
; 1846 :                 const auto _Count = static_cast<size_t>(_ULast - _UFirst);
; 1847 :                 _Copy_memmove_n(_To_address(_UFirst), _Count, _Unfancy(_Dest));
; 1848 :                 _Dest += _Count;
; 1849 :             }
; 1850 :             return _Dest;
; 1851 :         }
; 1852 :     }
; 1853 : 
; 1854 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1855 :     for (; _UFirst != _ULast; ++_UFirst) {
; 1856 :         _Backout._Emplace_back(*_UFirst);
; 1857 :     }
; 1858 : 
; 1859 :     return _Backout._Release();
; 1860 : }
; 1861 : 
; 1862 : template <class _InIt, class _Alloc>
; 1863 : _CONSTEXPR20 _Alloc_ptr_t<_Alloc> _Uninitialized_copy_n(
; 1864 :     _InIt _First, size_t _Count, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {
; 1865 :     // copy _First + [0, _Count) to raw _Dest, using _Al
; 1866 :     // note: only called internally from elsewhere in the STL
; 1867 :     using _Ptrval = typename _Alloc::value_type*;
; 1868 : 
; 1869 :     auto _UFirst = _Get_unwrapped(_STD move(_First));
; 1870 : 
; 1871 :     constexpr bool _Can_memmove =
; 1872 :         conjunction_v<bool_constant<_Iter_copy_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1873 :             _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>;
; 1874 : 
; 1875 :     if constexpr (_Can_memmove) {
; 1876 : #if _HAS_CXX20
; 1877 :         if (!_STD is_constant_evaluated())
; 1878 : #endif // _HAS_CXX20
; 1879 :         {
; 1880 :             _Copy_memmove_n(_UFirst, _Count, _Unfancy(_Dest));
; 1881 :             _Dest += _Count;
; 1882 :             return _Dest;
; 1883 :         }
; 1884 :     }
; 1885 : 
; 1886 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1887 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {
; 1888 :         _Backout._Emplace_back(*_UFirst);
; 1889 :     }
; 1890 : 
; 1891 :     return _Backout._Release();
; 1892 : }
; 1893 : 
; 1894 : template <class _InIt, class _NoThrowFwdIt>
; 1895 : _CONSTEXPR20 _NoThrowFwdIt _Uninitialized_copy_unchecked(_InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {
; 1896 :     // copy [_First, _Last) to raw [_Dest, ...)
; 1897 :     if constexpr (_Iter_copy_cat<_InIt, _NoThrowFwdIt>::_Bitcopy_constructible) {
; 1898 : #if _HAS_CXX20
; 1899 :         if (!_STD is_constant_evaluated())
; 1900 : #endif // _HAS_CXX20
; 1901 :         {
; 1902 :             return _Copy_memmove(_First, _Last, _Dest);
; 1903 :         }
; 1904 :     }
; 1905 : 
; 1906 :     _Uninitialized_backout<_NoThrowFwdIt> _Backout{_Dest};
; 1907 :     for (; _First != _Last; ++_First) {
; 1908 :         _Backout._Emplace_back(*_First);
; 1909 :     }
; 1910 : 
; 1911 :     return _Backout._Release();
; 1912 : }
; 1913 : 
; 1914 : _EXPORT_STD template <class _InIt, class _NoThrowFwdIt>
; 1915 : _NoThrowFwdIt uninitialized_copy(const _InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {
; 1916 :     // copy [_First, _Last) to raw [_Dest, ...)
; 1917 :     _Adl_verify_range(_First, _Last);
; 1918 :     auto _UFirst      = _Get_unwrapped(_First);
; 1919 :     const auto _ULast = _Get_unwrapped(_Last);
; 1920 :     auto _UDest       = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
; 1921 :     _Seek_wrapped(_Dest, _Uninitialized_copy_unchecked(_UFirst, _ULast, _UDest));
; 1922 :     return _Dest;
; 1923 : }
; 1924 : 
; 1925 : template <class _InIt, class _Alloc>
; 1926 : _CONSTEXPR20 _Alloc_ptr_t<_Alloc> _Uninitialized_move(
; 1927 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	mov	rdx, r15
	sub	rdx, rbx
	npad	4
$LL130@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rbx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rbx], -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 591  :             : _Handle(_STD exchange(_Rhs._Handle, __std_fs_dir_handle::_Invalid)) {}

	mov	QWORD PTR [rdx+rbx+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	rbx, 8
	cmp	rbx, rcx
	jne	SHORT $LL130@Emplace_re
$LN129@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2023 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR [rsi]
	test	rbx, rbx
	je	SHORT $LN185@Emplace_re

; 2024 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rbp, QWORD PTR [rsi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rbp
	je	SHORT $LN169@Emplace_re
	npad	7
$LL170@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 605  :             __std_fs_directory_iterator_close(_Handle);

	mov	rcx, QWORD PTR [rbx]
	call	__std_fs_directory_iterator_close
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 8
	cmp	rbx, rbp
	jne	SHORT $LL170@Emplace_re
$LN169@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rsi]
	mov	rdx, QWORD PTR [rsi+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN197@Emplace_re

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN194@Emplace_re

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN197@Emplace_re:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN185@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2030 :         _Mylast  = _Newvec + _Newsize;

	lea	rcx, QWORD PTR [rdi+r12*8]
	mov	QWORD PTR [rsi], rdi
	mov	r12, QWORD PTR [rsp+40]

; 846  :             _Uninitialized_move(_Myfirst, _Whereptr, _Newvec, _Al);
; 847  :             _Constructed_first = _Newvec;
; 848  :             _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);
; 849  :         }
; 850  :         _CATCH_ALL
; 851  :         _Destroy_range(_Constructed_first, _Constructed_last, _Al);
; 852  :         _Al.deallocate(_Newvec, _Newcapacity);
; 853  :         _RERAISE;
; 854  :         _CATCH_END
; 855  : 
; 856  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 857  :         return _Newvec + _Whereoff;

	mov	rax, r15

; 2030 :         _Mylast  = _Newvec + _Newsize;

	mov	QWORD PTR [rsi+8], rcx

; 2031 :         _Myend   = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [r14+rdi]
	mov	rdi, QWORD PTR [rsp+48]
	mov	r14, QWORD PTR [rsp+32]
	mov	QWORD PTR [rsi+16], rcx

; 858  :     }

	add	rsp, 56					; 00000038H
	pop	r15
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN194@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN253@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 825  :             _Xlength();

	call	?_Xlength@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@CAXXZ ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::_Xlength
	int	3
$LN230@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN251@Emplace_re:
??$_Emplace_reallocate@U_Find_file_handle@filesystem@std@@@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAPEAU_Find_file_handle@filesystem@1@QEAU231@$$QEAU231@@Z ENDP ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::_Emplace_reallocate<std::filesystem::_Find_file_handle>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@AEAPEAW4123@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@AEAPEAW4123@@Z PROC ; std::move<enum AINBNodeDefMgr::NodeDef::CategoryEnum * &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@AEAPEAW4123@@Z ENDP ; std::move<enum AINBNodeDefMgr::NodeDef::CategoryEnum * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YA?A_T$$QEAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YA?A_T$$QEAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@Z PROC ; std::_Get_unwrapped<enum AINBNodeDefMgr::NodeDef::CategoryEnum *>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YA?A_T$$QEAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@Z ENDP ; std::_Get_unwrapped<enum AINBNodeDefMgr::NodeDef::CategoryEnum *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_copy_n@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@_K0AEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Dest$ = 64
_Al$dead$ = 72
??$_Uninitialized_copy_n@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@_K0AEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@0@@Z PROC ; std::_Uninitialized_copy_n<enum AINBNodeDefMgr::NodeDef::CategoryEnum *,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >, COMDAT

; 1864 :     _InIt _First, size_t _Count, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN25:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, r8
	mov	rbx, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rdx
	mov	rdx, rcx
	mov	rcx, rdi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1881 :             _Dest += _Count;

	lea	rax, QWORD PTR [rdi+rbx]

; 1882 :             return _Dest;
; 1883 :         }
; 1884 :     }
; 1885 : 
; 1886 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1887 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {
; 1888 :         _Backout._Emplace_back(*_UFirst);
; 1889 :     }
; 1890 : 
; 1891 :     return _Backout._Release();
; 1892 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_copy_n@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@_K0AEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@0@@Z ENDP ; std::_Uninitialized_copy_n<enum AINBNodeDefMgr::NodeDef::CategoryEnum *,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Copy_memmove_n@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@_K0@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Dest$ = 64
??$_Copy_memmove_n@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@_K0@Z PROC ; std::_Copy_memmove_n<enum AINBNodeDefMgr::NodeDef::CategoryEnum *,enum AINBNodeDefMgr::NodeDef::CategoryEnum *>, COMDAT

; 4543 : _OutCtgIt _Copy_memmove_n(_CtgIt _First, const size_t _Count, _OutCtgIt _Dest) {

$LN6:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, r8
	mov	rbx, rdx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rdx
	mov	rdx, rcx
	mov	rcx, rdi
	call	memmove

; 4535 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4536 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rdi+rbx]

; 4544 :     const auto _Result = _Copy_memmove(_First, _First + _Count, _Dest);
; 4545 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4546 :         return _Result;
; 4547 :     } else { // _Result is unused so the compiler can optimize it away
; 4548 :         return _Dest + static_cast<_Iter_diff_t<_OutCtgIt>>(_Count);
; 4549 :     }
; 4550 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_memmove_n@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@_K0@Z ENDP ; std::_Copy_memmove_n<enum AINBNodeDefMgr::NodeDef::CategoryEnum *,enum AINBNodeDefMgr::NodeDef::CategoryEnum *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Copy_n_unchecked4@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_KPEAW4123@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@_K0@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Dest$ = 64
??$_Copy_n_unchecked4@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_KPEAW4123@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@_K0@Z PROC ; std::_Copy_n_unchecked4<enum AINBNodeDefMgr::NodeDef::CategoryEnum *,unsigned __int64,enum AINBNodeDefMgr::NodeDef::CategoryEnum *>, COMDAT

; 4556 : _CONSTEXPR20 _OutIt _Copy_n_unchecked4(_InIt _First, _SizeTy _Count, _OutIt _Dest) {

$LN16:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, r8
	mov	rbx, rdx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rdx
	mov	rdx, rcx
	mov	rcx, rdi
	call	memmove

; 4535 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4536 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rbx+rdi]

; 4557 :     // copy _First + [0, _Count) to _Dest + [0, _Count), returning _Dest + _Count
; 4558 :     // note: has callers outside the copy family
; 4559 : #ifdef __cpp_lib_concepts
; 4560 :     _STL_INTERNAL_STATIC_ASSERT(_Integer_like<_SizeTy>);
; 4561 : #endif // __cpp_lib_concepts
; 4562 : 
; 4563 :     if constexpr (_Iter_copy_cat<_InIt, _OutIt>::_Bitcopy_assignable) {
; 4564 : #if _HAS_CXX20
; 4565 :         if (!_STD is_constant_evaluated())
; 4566 : #endif // _HAS_CXX20
; 4567 :         {
; 4568 :             return _Copy_memmove_n(_First, static_cast<size_t>(_Count), _Dest);
; 4569 :         }
; 4570 :     }
; 4571 : 
; 4572 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {
; 4573 :         *_Dest = *_First;
; 4574 :     }
; 4575 : 
; 4576 :     return _Dest;
; 4577 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_n_unchecked4@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_KPEAW4123@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@_K0@Z ENDP ; std::_Copy_n_unchecked4<enum AINBNodeDefMgr::NodeDef::CategoryEnum *,unsigned __int64,enum AINBNodeDefMgr::NodeDef::CategoryEnum *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@AEAW4123@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@AEAW4123@@Z PROC ; std::forward<enum AINBNodeDefMgr::NodeDef::CategoryEnum>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@AEAW4123@@Z ENDP ; std::forward<enum AINBNodeDefMgr::NodeDef::CategoryEnum>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAAEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@$$QEAW4234@@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$_Emplace_back_with_unused_capacity@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAAEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@$$QEAW4234@@Z PROC ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Emplace_back_with_unused_capacity<enum AINBNodeDefMgr::NodeDef::CategoryEnum>, COMDAT

; 790  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 791  :         auto& _My_data   = _Mypair._Myval2;
; 792  :         pointer& _Mylast = _My_data._Mylast;
; 793  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 794  :         if constexpr (conjunction_v<is_nothrow_constructible<_Ty, _Valty...>,
; 795  :                           _Uses_default_construct<_Alloc, _Ty*, _Valty...>>) {
; 796  :             _ASAN_VECTOR_MODIFY(1);
; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	movzx	eax, BYTE PTR [rdx]
	mov	r8, QWORD PTR [rcx+8]
	mov	BYTE PTR [r8], al

; 798  :         } else {
; 799  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 800  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 801  :             _ASAN_VECTOR_RELEASE_GUARD;
; 802  :         }
; 803  : 
; 804  :         _Orphan_range(_Mylast, _Mylast);
; 805  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR [rcx+8]

; 806  :         ++_Mylast;

	lea	rdx, QWORD PTR [rax+1]
	mov	QWORD PTR [rcx+8], rdx

; 807  : 
; 808  :         return _Result;
; 809  :     }

	ret	0
??$_Emplace_back_with_unused_capacity@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAAEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@$$QEAW4234@@Z ENDP ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Emplace_back_with_unused_capacity<enum AINBNodeDefMgr::NodeDef::CategoryEnum>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Emplace_reallocate@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@QEAW4234@$$QEAW4234@@Z
_TEXT	SEGMENT
this$ = 80
_Whereptr$ = 88
<_Val_0>$ = 96
??$_Emplace_reallocate@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@QEAW4234@$$QEAW4234@@Z PROC ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Emplace_reallocate<enum AINBNodeDefMgr::NodeDef::CategoryEnum>, COMDAT

; 812  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN118:
	push	rbx
	push	rbp
	push	rsi
	push	r12
	push	r14
	sub	rsp, 32					; 00000020H

; 813  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 814  :         _Alty& _Al        = _Getal();
; 815  :         auto& _My_data    = _Mypair._Myval2;
; 816  :         pointer& _Myfirst = _My_data._Myfirst;
; 817  :         pointer& _Mylast  = _My_data._Mylast;
; 818  : 
; 819  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 820  : 
; 821  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);
; 822  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	mov	rbp, rdx
	mov	rdx, QWORD PTR [rcx]
	mov	r14, rbp
	sub	r14, rdx
	sub	rax, rdx

; 823  : 
; 824  :         if (_Oldsize == max_size()) {

	mov	rbx, 9223372036854775807		; 7fffffffffffffffH
	mov	r12, r8
	mov	rsi, rcx
	cmp	rax, rbx
	je	$LN115@Emplace_re

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, rdx
	mov	QWORD PTR [rsp+96], rdi

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	mov	QWORD PTR [rsp+104], r15

; 826  :         }
; 827  : 
; 828  :         const size_type _Newsize     = _Oldsize + 1;

	lea	r15, QWORD PTR [rax+1]

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	shr	rdx, 1
	mov	rax, rbx
	sub	rax, rdx
	cmp	rcx, rax
	jbe	SHORT $LN12@Emplace_re

; 1967 :             return _Max; // geometric growth would overflow

	mov	rcx, -9223372036854775770		; 8000000000000026H
$LN31@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN30@Emplace_re

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN19@Emplace_re
$LN12@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [rdx+rcx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	mov	rbx, r15
	cmp	rax, r15
	cmovae	rbx, rax
	cmp	rbx, 4096				; 00001000H
	jb	SHORT $LN21@Emplace_re

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rbx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rbx
	jbe	$LN116@Emplace_re
	jmp	SHORT $LN31@Emplace_re
$LN30@Emplace_re:

; 142  :     }
; 143  : 
; 144  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN21@Emplace_re:

; 244  :     if (_Bytes != 0) {

	test	rbx, rbx
	je	SHORT $LN22@Emplace_re

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax

; 245  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN19@Emplace_re
$LN22@Emplace_re:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

	xor	edi, edi
$LN19@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 836  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	movzx	eax, BYTE PTR [r12]
	add	r14, rdi

; 837  :         _Constructed_first = _Newvec + _Whereoff;
; 838  : 
; 839  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	rcx, rdi
	mov	BYTE PTR [r14], al
	mov	r8, QWORD PTR [rsi+8]
	mov	rdx, QWORD PTR [rsi]
	cmp	rbp, r8
	jne	SHORT $LN4@Emplace_re
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 845  :         } else { // provide basic guarantee

	jmp	SHORT $LN113@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	r8, rbp
	sub	r8, rdx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1932 :     const auto _ULast = _Get_unwrapped(_Last);

	mov	r8, QWORD PTR [rsi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 848  :             _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

	lea	rcx, QWORD PTR [r14+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rbp

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rbp
$LN113@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 848  :             _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

	call	memmove

; 849  :         }
; 850  :         _CATCH_ALL
; 851  :         _Destroy_range(_Constructed_first, _Constructed_last, _Al);
; 852  :         _Al.deallocate(_Newvec, _Newcapacity);
; 853  :         _RERAISE;
; 854  :         _CATCH_END
; 855  : 
; 856  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, rbx
	mov	r8, r15
	mov	rdx, rdi
	mov	rcx, rsi
	call	?_Change_array@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_K1@Z ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Change_array
	mov	rdi, QWORD PTR [rsp+96]

; 857  :         return _Newvec + _Whereoff;

	mov	rax, r14
	mov	r15, QWORD PTR [rsp+104]

; 858  :     }

	add	rsp, 32					; 00000020H
	pop	r14
	pop	r12
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN115@Emplace_re:

; 825  :             _Xlength();

	call	?_Xlength@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Xlength
	int	3
$LN116@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN112@Emplace_re:
??$_Emplace_reallocate@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@QEAW4234@$$QEAW4234@@Z ENDP ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Emplace_reallocate<enum AINBNodeDefMgr::NodeDef::CategoryEnum>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@YA$$QEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@YA$$QEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@0@AEAV10@@Z PROC ; std::forward<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@YA$$QEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@0@AEAV10@@Z ENDP ; std::forward<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_To_address@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YA?A_PAEBQEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@Z
_TEXT	SEGMENT
_Val$ = 8
??$_To_address@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YA?A_PAEBQEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@Z PROC ; std::_To_address<enum AINBNodeDefMgr::NodeDef::CategoryEnum *>, COMDAT

; 4395 :     _STL_INTERNAL_STATIC_ASSERT(contiguous_iterator<_Iter>);
; 4396 :     return _STD to_address(_Val);

	mov	rax, QWORD PTR [rcx]

; 4397 : }

	ret	0
??$_To_address@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YA?A_PAEBQEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@Z ENDP ; std::_To_address<enum AINBNodeDefMgr::NodeDef::CategoryEnum *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 64
_Newsize$dead$ = 72
_Val$dead$ = 80
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Resize_reallocate<std::_Value_init_tag>, COMDAT

; 1511 :     _CONSTEXPR20 void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

$LN169:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 1512 :         if (_Newsize > max_size()) {
; 1513 :             _Xlength();
; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rsi, QWORD PTR [rcx+8]
	mov	rdi, rcx
	sub	rsi, QWORD PTR [rcx]
	mov	rbp, -6148914691236517205		; aaaaaaaaaaaaaaabH

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	r14, 768614336404564650			; 0aaaaaaaaaaaaaaaH

; 1512 :         if (_Newsize > max_size()) {
; 1513 :             _Xlength();
; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	sar	rsi, 3

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, r14

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sub	rcx, QWORD PTR [rdi]

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ebx, 6

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	rcx, 3
	imul	rcx, rbp

; 1512 :         if (_Newsize > max_size()) {
; 1513 :             _Xlength();
; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	imul	rsi, rbp

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	shr	rdx, 1
	sub	rax, rdx
	cmp	rcx, rax
	ja	SHORT $LN11@Resize_rea

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	r14, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	r14, rbx
	cmovb	r14, rbx
$LN11@Resize_rea:

; 1522 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1523 : 
; 1524 :         const pointer _Newvec         = _Al.allocate(_Newcapacity);

	mov	rdx, r14
	call	?allocate@?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K@Z ; std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >::allocate

; 1525 :         const pointer _Appended_first = _Newvec + _Oldsize;
; 1526 :         pointer _Appended_last        = _Appended_first;
; 1527 : 
; 1528 :         _TRY_BEGIN
; 1529 :         if constexpr (is_same_v<_Ty2, _Ty>) {
; 1530 :             _Appended_last = _Uninitialized_fill_n(_Appended_first, _Newsize - _Oldsize, _Val, _Al);
; 1531 :         } else {
; 1532 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1533 :             _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);

	xor	r10d, r10d
	lea	rcx, QWORD PTR [rsi+rsi*2]
	mov	r15, rax
	lea	rdx, QWORD PTR [rax+rcx*8]
	sub	rbx, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2041 :     for (; 0 < _Count; --_Count) {

	je	SHORT $LN17@Resize_rea
	npad	7
$LL18@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rdx], r10
	mov	QWORD PTR [rdx+8], r10
	mov	QWORD PTR [rdx+16], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	lea	rdx, QWORD PTR [rdx+24]

; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rbx, 1
	jne	SHORT $LL18@Resize_rea
$LN17@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1537 :             _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	rbx, QWORD PTR [rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1932 :     const auto _ULast = _Get_unwrapped(_Last);

	mov	r9, QWORD PTR [rdi+8]

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rbx, r9
	je	SHORT $LN56@Resize_rea

; 1804 :     }
; 1805 : 
; 1806 :     constexpr pointer _Release() { // suppress any exception handling backout and return _Last
; 1807 :         _First = _Last;
; 1808 :         return _Last;
; 1809 :     }
; 1810 : 
; 1811 : private:
; 1812 :     pointer _First;
; 1813 :     pointer _Last;
; 1814 :     _Alloc& _Al;
; 1815 : };
; 1816 : 
; 1817 : template <class _InIt, class _Se, class _Alloc>
; 1818 : _CONSTEXPR20 _Alloc_ptr_t<_Alloc> _Uninitialized_copy(
; 1819 :     _InIt _First, _Se _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {
; 1820 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1821 :     // note: only called internally from elsewhere in the STL
; 1822 :     using _Ptrval = typename _Alloc::value_type*;
; 1823 : 
; 1824 : #ifdef __cpp_lib_concepts
; 1825 :     auto _UFirst = _RANGES _Unwrap_iter<_Se>(_STD move(_First));
; 1826 :     auto _ULast  = _RANGES _Unwrap_sent<_InIt>(_STD move(_Last));
; 1827 : #else // ^^^ __cpp_lib_concepts / !__cpp_lib_concepts vvv
; 1828 :     // In pre-concepts world, _Uninitialized_copy should only ever be called with an iterator
; 1829 :     // and sentinel of the same type, so `_Get_unwrapped` is fine to call.
; 1830 :     auto _UFirst = _Get_unwrapped(_STD move(_First));
; 1831 :     auto _ULast  = _Get_unwrapped(_STD move(_Last));
; 1832 : #endif // ^^^ !__cpp_lib_concepts ^^^
; 1833 : 
; 1834 :     constexpr bool _Can_memmove = _Sent_copy_cat<decltype(_UFirst), decltype(_ULast), _Ptrval>::_Bitcopy_constructible
; 1835 :                                && _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>::value;
; 1836 : 
; 1837 :     if constexpr (_Can_memmove) {
; 1838 : #if _HAS_CXX20
; 1839 :         if (!_STD is_constant_evaluated())
; 1840 : #endif // _HAS_CXX20
; 1841 :         {
; 1842 :             if constexpr (is_same_v<decltype(_UFirst), decltype(_ULast)>) {
; 1843 :                 _Copy_memmove(_To_address(_UFirst), _To_address(_ULast), _Unfancy(_Dest));
; 1844 :                 _Dest += _ULast - _UFirst;
; 1845 :             } else {
; 1846 :                 const auto _Count = static_cast<size_t>(_ULast - _UFirst);
; 1847 :                 _Copy_memmove_n(_To_address(_UFirst), _Count, _Unfancy(_Dest));
; 1848 :                 _Dest += _Count;
; 1849 :             }
; 1850 :             return _Dest;
; 1851 :         }
; 1852 :     }
; 1853 : 
; 1854 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1855 :     for (; _UFirst != _ULast; ++_UFirst) {
; 1856 :         _Backout._Emplace_back(*_UFirst);
; 1857 :     }
; 1858 : 
; 1859 :     return _Backout._Release();
; 1860 : }
; 1861 : 
; 1862 : template <class _InIt, class _Alloc>
; 1863 : _CONSTEXPR20 _Alloc_ptr_t<_Alloc> _Uninitialized_copy_n(
; 1864 :     _InIt _First, size_t _Count, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {
; 1865 :     // copy _First + [0, _Count) to raw _Dest, using _Al
; 1866 :     // note: only called internally from elsewhere in the STL
; 1867 :     using _Ptrval = typename _Alloc::value_type*;
; 1868 : 
; 1869 :     auto _UFirst = _Get_unwrapped(_STD move(_First));
; 1870 : 
; 1871 :     constexpr bool _Can_memmove =
; 1872 :         conjunction_v<bool_constant<_Iter_copy_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1873 :             _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>;
; 1874 : 
; 1875 :     if constexpr (_Can_memmove) {
; 1876 : #if _HAS_CXX20
; 1877 :         if (!_STD is_constant_evaluated())
; 1878 : #endif // _HAS_CXX20
; 1879 :         {
; 1880 :             _Copy_memmove_n(_UFirst, _Count, _Unfancy(_Dest));
; 1881 :             _Dest += _Count;
; 1882 :             return _Dest;
; 1883 :         }
; 1884 :     }
; 1885 : 
; 1886 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1887 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {
; 1888 :         _Backout._Emplace_back(*_UFirst);
; 1889 :     }
; 1890 : 
; 1891 :     return _Backout._Release();
; 1892 : }
; 1893 : 
; 1894 : template <class _InIt, class _NoThrowFwdIt>
; 1895 : _CONSTEXPR20 _NoThrowFwdIt _Uninitialized_copy_unchecked(_InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {
; 1896 :     // copy [_First, _Last) to raw [_Dest, ...)
; 1897 :     if constexpr (_Iter_copy_cat<_InIt, _NoThrowFwdIt>::_Bitcopy_constructible) {
; 1898 : #if _HAS_CXX20
; 1899 :         if (!_STD is_constant_evaluated())
; 1900 : #endif // _HAS_CXX20
; 1901 :         {
; 1902 :             return _Copy_memmove(_First, _Last, _Dest);
; 1903 :         }
; 1904 :     }
; 1905 : 
; 1906 :     _Uninitialized_backout<_NoThrowFwdIt> _Backout{_Dest};
; 1907 :     for (; _First != _Last; ++_First) {
; 1908 :         _Backout._Emplace_back(*_First);
; 1909 :     }
; 1910 : 
; 1911 :     return _Backout._Release();
; 1912 : }
; 1913 : 
; 1914 : _EXPORT_STD template <class _InIt, class _NoThrowFwdIt>
; 1915 : _NoThrowFwdIt uninitialized_copy(const _InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {
; 1916 :     // copy [_First, _Last) to raw [_Dest, ...)
; 1917 :     _Adl_verify_range(_First, _Last);
; 1918 :     auto _UFirst      = _Get_unwrapped(_First);
; 1919 :     const auto _ULast = _Get_unwrapped(_Last);
; 1920 :     auto _UDest       = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
; 1921 :     _Seek_wrapped(_Dest, _Uninitialized_copy_unchecked(_UFirst, _ULast, _UDest));
; 1922 :     return _Dest;
; 1923 : }
; 1924 : 
; 1925 : template <class _InIt, class _Alloc>
; 1926 : _CONSTEXPR20 _Alloc_ptr_t<_Alloc> _Uninitialized_move(
; 1927 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	lea	r8, QWORD PTR [rax+16]
	npad	11
$LL57@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [rbx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	lea	r8, QWORD PTR [r8+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [rbx+8]
	mov	rax, QWORD PTR [rbx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rbx+16], r10
	mov	QWORD PTR [rbx+8], r10
	mov	QWORD PTR [rbx], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	rbx, 24
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r8-40], rax
	mov	QWORD PTR [r8-32], rcx
	mov	QWORD PTR [r8-24], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rbx, r9
	jne	SHORT $LL57@Resize_rea
	mov	rbx, QWORD PTR [rdi]
$LN56@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2023 :         if (_Myfirst) { // destroy and deallocate old array

	test	rbx, rbx
	je	SHORT $LN120@Resize_rea

; 2024 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rsi, QWORD PTR [rdi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rsi
	je	SHORT $LN104@Resize_rea
$LL105@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	mov	rcx, rbx
	call	?_Tidy@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 24
	cmp	rbx, rsi
	jne	SHORT $LL105@Resize_rea
$LN104@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rdi]
	mov	rax, QWORD PTR [rdi+16]
	sub	rax, rcx
	sar	rax, 3
	imul	rax, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*2]
	shl	rdx, 3

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN132@Resize_rea

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN129@Resize_rea

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN132@Resize_rea:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN120@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1548 :     }

	mov	rbx, QWORD PTR [rsp+72]

; 2030 :         _Mylast  = _Newvec + _Newsize;

	lea	rax, QWORD PTR [r15+144]

; 1548 :     }

	mov	rbp, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]

; 2029 :         _Myfirst = _Newvec;

	mov	QWORD PTR [rdi], r15

; 2030 :         _Mylast  = _Newvec + _Newsize;

	mov	QWORD PTR [rdi+8], rax

; 2031 :         _Myend   = _Newvec + _Newcapacity;

	lea	rax, QWORD PTR [r14+r14*2]
	lea	rcx, QWORD PTR [r15+rax*8]
	mov	QWORD PTR [rdi+16], rcx

; 1548 :     }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
$LN129@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN166@Resize_rea:
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_KAEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Count$ = 16
_Al$dead$ = 24
??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_KAEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >, COMDAT

; 2027 :     // value-initialize _Count objects to raw _First, using _Al
; 2028 :     using _Ptrty = typename _Alloc::value_type*;
; 2029 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2030 : #if _HAS_CXX20
; 2031 :         if (!_STD is_constant_evaluated())
; 2032 : #endif // _HAS_CXX20
; 2033 :         {
; 2034 :             auto _PFirst = _Unfancy(_First);
; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2036 :             return _First + _Count;
; 2037 :         }
; 2038 :     }
; 2039 : 
; 2040 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2041 :     for (; 0 < _Count; --_Count) {

	test	rdx, rdx
	je	SHORT $LN48@Uninitiali
	xor	eax, eax
	npad	9
$LL4@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rcx, 24

; 2027 :     // value-initialize _Count objects to raw _First, using _Al
; 2028 :     using _Ptrty = typename _Alloc::value_type*;
; 2029 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2030 : #if _HAS_CXX20
; 2031 :         if (!_STD is_constant_evaluated())
; 2032 : #endif // _HAS_CXX20
; 2033 :         {
; 2034 :             auto _PFirst = _Unfancy(_First);
; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2036 :             return _First + _Count;
; 2037 :         }
; 2038 :     }
; 2039 : 
; 2040 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rdx, 1
	jne	SHORT $LL4@Uninitiali
$LN48@Uninitiali:

; 2042 :         _Backout._Emplace_back();
; 2043 :     }
; 2044 : 
; 2045 :     return _Backout._Release();
; 2046 : }

	mov	rax, rcx
	ret	0
??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_KAEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA$$QEAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAPEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA$$QEAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAPEAV10@@Z PROC ; std::move<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > * &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA$$QEAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAPEAV10@@Z ENDP ; std::move<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA?A_T$$QEAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA?A_T$$QEAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > *>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA?A_T$$QEAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_copy_n@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_Guard$1 = 32
_Backout$2 = 40
_Backout$ = 64
__$ArrayPad$ = 88
_First$ = 144
_Count$ = 152
_Dest$ = 160
_Al$ = 168
??$_Uninitialized_copy_n@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z PROC ; std::_Uninitialized_copy_n<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > *,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >, COMDAT

; 1864 :     _InIt _First, size_t _Count, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN112:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rsi, r8
	mov	r15, rdx
	mov	r14, rcx
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _Backout$[rsp], xmm0

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR _Backout$[rsp], r8
	mov	QWORD PTR _Backout$[rsp+8], r8
	mov	QWORD PTR _Backout$[rsp+16], r9

; 1865 :     // copy _First + [0, _Count) to raw _Dest, using _Al
; 1866 :     // note: only called internally from elsewhere in the STL
; 1867 :     using _Ptrval = typename _Alloc::value_type*;
; 1868 : 
; 1869 :     auto _UFirst = _Get_unwrapped(_STD move(_First));
; 1870 : 
; 1871 :     constexpr bool _Can_memmove =
; 1872 :         conjunction_v<bool_constant<_Iter_copy_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1873 :             _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>;
; 1874 : 
; 1875 :     if constexpr (_Can_memmove) {
; 1876 : #if _HAS_CXX20
; 1877 :         if (!_STD is_constant_evaluated())
; 1878 : #endif // _HAS_CXX20
; 1879 :         {
; 1880 :             _Copy_memmove_n(_UFirst, _Count, _Unfancy(_Dest));
; 1881 :             _Dest += _Count;
; 1882 :             return _Dest;
; 1883 :         }
; 1884 :     }
; 1885 : 
; 1886 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1887 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {

	test	rdx, rdx
	je	$LN108@Uninitiali
	xor	r12d, r12d
	mov	rax, -8198552921648689607		; 8e38e38e38e38e39H
	mov	r13, 128102389400760775			; 01c71c71c71c71c7H
	npad	5
$LL4@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rsi], r12
	mov	QWORD PTR [rsi+8], r12
	mov	QWORD PTR [rsi+16], r12

; 685  :         const auto _Count       = static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst);

	mov	rbx, QWORD PTR [r14+8]
	sub	rbx, QWORD PTR [r14]
	sar	rbx, 4
	imul	rbx, rax

; 2065 :         if (_Count != 0) {

	test	rbx, rbx
	je	$LN66@Uninitiali

; 2006 :         if (_Newcapacity > max_size()) {

	cmp	rbx, r13
	ja	$LN95@Uninitiali

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdx, rbx
	call	?allocate@?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAPEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z ; std::allocator<AINBNodeDefMgr::NodeDef::InputParam>::allocate
	mov	rdi, rax

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rsi], rax

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [rsi+8], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rax, QWORD PTR [rbx+rbx*8]
	shl	rax, 4
	add	rax, rdi
	mov	QWORD PTR [rsi+16], rax

; 2067 :             _Tidy_guard<vector> _Guard{this};

	mov	QWORD PTR _Guard$1[rsp], rsi

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rbp, QWORD PTR [r14+8]
	mov	rbx, QWORD PTR [r14]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _Backout$2[rsp], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR _Backout$2[rsp], rdi
	mov	QWORD PTR _Backout$2[rsp+8], rdi
	mov	QWORD PTR _Backout$2[rsp+16], rsi

; 1855 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rbx, rbp
	je	SHORT $LN35@Uninitiali
$LL36@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rdx, rbx
	mov	rcx, rdi
	call	??0InputParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rdi, 144				; 00000090H
	mov	QWORD PTR _Backout$2[rsp+8], rdi

; 1855 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	rbx, 144				; 00000090H
	cmp	rbx, rbp
	jne	SHORT $LL36@Uninitiali
$LN35@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	QWORD PTR [rsi+8], rdi

; 2075 :             } else {
; 2076 :                 static_assert(_Always_false<_Ty>, "Should be unreachable");
; 2077 :             }
; 2078 :             _ASAN_VECTOR_CREATE;
; 2079 :             _Guard._Target = nullptr;
; 2080 :         }

	mov	rax, -8198552921648689607		; 8e38e38e38e38e39H
$LN66@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rsi, 24
	mov	QWORD PTR _Backout$[rsp+8], rsi

; 1865 :     // copy _First + [0, _Count) to raw _Dest, using _Al
; 1866 :     // note: only called internally from elsewhere in the STL
; 1867 :     using _Ptrval = typename _Alloc::value_type*;
; 1868 : 
; 1869 :     auto _UFirst = _Get_unwrapped(_STD move(_First));
; 1870 : 
; 1871 :     constexpr bool _Can_memmove =
; 1872 :         conjunction_v<bool_constant<_Iter_copy_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1873 :             _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>;
; 1874 : 
; 1875 :     if constexpr (_Can_memmove) {
; 1876 : #if _HAS_CXX20
; 1877 :         if (!_STD is_constant_evaluated())
; 1878 : #endif // _HAS_CXX20
; 1879 :         {
; 1880 :             _Copy_memmove_n(_UFirst, _Count, _Unfancy(_Dest));
; 1881 :             _Dest += _Count;
; 1882 :             return _Dest;
; 1883 :         }
; 1884 :     }
; 1885 : 
; 1886 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1887 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {

	add	r14, 24
	sub	r15, 1
	jne	$LL4@Uninitiali
$LN108@Uninitiali:

; 1888 :         _Backout._Emplace_back(*_UFirst);
; 1889 :     }
; 1890 : 
; 1891 :     return _Backout._Release();

	mov	rax, rsi

; 1892 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+96]
	mov	rbx, QWORD PTR [r11+56]
	mov	rbp, QWORD PTR [r11+64]
	mov	rsi, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
$LN95@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Xlength
	npad	1
$LN109@Uninitiali:
??$_Uninitialized_copy_n@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy_n<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > *,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Guard$1 = 32
_Backout$2 = 40
_Backout$ = 64
__$ArrayPad$ = 88
_First$ = 144
_Count$ = 152
_Dest$ = 160
_Al$ = 168
?dtor$0@?0???$_Uninitialized_copy_n@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z@4HA PROC ; `std::_Uninitialized_copy_n<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > *,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Backout$[rdx]
	jmp	??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::~_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >
?dtor$0@?0???$_Uninitialized_copy_n@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z@4HA ENDP ; `std::_Uninitialized_copy_n<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > *,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Guard$1 = 32
_Backout$2 = 40
_Backout$ = 64
__$ArrayPad$ = 88
_First$ = 144
_Count$ = 152
_Dest$ = 160
_Al$ = 168
?dtor$1@?0???$_Uninitialized_copy_n@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z@4HA PROC ; `std::_Uninitialized_copy_n<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > *,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >'::`1'::dtor$1
	lea	rcx, QWORD PTR _Guard$1[rdx]
	jmp	??1?$_Tidy_guard@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >::~_Tidy_guard<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >
?dtor$1@?0???$_Uninitialized_copy_n@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z@4HA ENDP ; `std::_Uninitialized_copy_n<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > *,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Guard$1 = 32
_Backout$2 = 40
_Backout$ = 64
__$ArrayPad$ = 88
_First$ = 144
_Count$ = 152
_Dest$ = 160
_Al$ = 168
?dtor$2@?0???$_Uninitialized_copy_n@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z@4HA PROC ; `std::_Uninitialized_copy_n<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > *,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >'::`1'::dtor$2
	lea	rcx, QWORD PTR _Backout$2[rdx]
	jmp	??1?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::~_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >
?dtor$2@?0???$_Uninitialized_copy_n@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z@4HA ENDP ; `std::_Uninitialized_copy_n<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > *,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Copy_n_unchecked4@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@_KPEAV12@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Dest$ = 64
??$_Copy_n_unchecked4@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@_KPEAV12@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0@Z PROC ; std::_Copy_n_unchecked4<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > *,unsigned __int64,std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > *>, COMDAT

; 4556 : _CONSTEXPR20 _OutIt _Copy_n_unchecked4(_InIt _First, _SizeTy _Count, _OutIt _Dest) {

$LN18:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, r8
	mov	rsi, rdx
	mov	rdi, rcx

; 4572 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	test	rdx, rdx
	je	SHORT $LN13@Copy_n_unc
	mov	QWORD PTR [rsp+48], rbp
	mov	rbp, -8198552921648689607		; 8e38e38e38e38e39H
	npad	4
$LL4@Copy_n_unc:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rbx, rdi
	je	SHORT $LN2@Copy_n_unc

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [rdi]
	mov	rcx, rbx
	mov	r8, QWORD PTR [rdi+8]
	sub	r8, rdx
	sar	r8, 4
	imul	r8, rbp
	call	??$_Assign_counted_range@PEAUInputParam@NodeDef@AINBNodeDefMgr@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Assign_counted_range<AINBNodeDefMgr::NodeDef::InputParam *>
$LN2@Copy_n_unc:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4572 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	add	rbx, 24
	add	rdi, 24
	sub	rsi, 1
	jne	SHORT $LL4@Copy_n_unc
	mov	rbp, QWORD PTR [rsp+48]
$LN13@Copy_n_unc:

; 4573 :         *_Dest = *_First;
; 4574 :     }
; 4575 : 
; 4576 :     return _Dest;
; 4577 : }

	mov	rsi, QWORD PTR [rsp+64]
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_n_unchecked4@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@_KPEAV12@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0@Z ENDP ; std::_Copy_n_unchecked4<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > *,unsigned __int64,std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@AEAV10@@Z PROC ; std::forward<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::forward<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 64
_Newsize$dead$ = 72
_Val$dead$ = 80
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Resize_reallocate<std::_Value_init_tag>, COMDAT

; 1511 :     _CONSTEXPR20 void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

$LN169:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 1512 :         if (_Newsize > max_size()) {
; 1513 :             _Xlength();
; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rsi, QWORD PTR [rcx+8]
	mov	rdi, rcx
	sub	rsi, QWORD PTR [rcx]
	mov	rbp, -6148914691236517205		; aaaaaaaaaaaaaaabH

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	r14, 768614336404564650			; 0aaaaaaaaaaaaaaaH

; 1512 :         if (_Newsize > max_size()) {
; 1513 :             _Xlength();
; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	sar	rsi, 3

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, r14

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sub	rcx, QWORD PTR [rdi]

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ebx, 6

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	rcx, 3
	imul	rcx, rbp

; 1512 :         if (_Newsize > max_size()) {
; 1513 :             _Xlength();
; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	imul	rsi, rbp

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	shr	rdx, 1
	sub	rax, rdx
	cmp	rcx, rax
	ja	SHORT $LN11@Resize_rea

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	r14, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	r14, rbx
	cmovb	r14, rbx
$LN11@Resize_rea:

; 1522 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1523 : 
; 1524 :         const pointer _Newvec         = _Al.allocate(_Newcapacity);

	mov	rdx, r14
	call	?allocate@?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K@Z ; std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >::allocate

; 1525 :         const pointer _Appended_first = _Newvec + _Oldsize;
; 1526 :         pointer _Appended_last        = _Appended_first;
; 1527 : 
; 1528 :         _TRY_BEGIN
; 1529 :         if constexpr (is_same_v<_Ty2, _Ty>) {
; 1530 :             _Appended_last = _Uninitialized_fill_n(_Appended_first, _Newsize - _Oldsize, _Val, _Al);
; 1531 :         } else {
; 1532 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1533 :             _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);

	xor	r10d, r10d
	lea	rcx, QWORD PTR [rsi+rsi*2]
	mov	r15, rax
	lea	rdx, QWORD PTR [rax+rcx*8]
	sub	rbx, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2041 :     for (; 0 < _Count; --_Count) {

	je	SHORT $LN17@Resize_rea
	npad	7
$LL18@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rdx], r10
	mov	QWORD PTR [rdx+8], r10
	mov	QWORD PTR [rdx+16], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	lea	rdx, QWORD PTR [rdx+24]

; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rbx, 1
	jne	SHORT $LL18@Resize_rea
$LN17@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1537 :             _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	rbx, QWORD PTR [rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1932 :     const auto _ULast = _Get_unwrapped(_Last);

	mov	r9, QWORD PTR [rdi+8]

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rbx, r9
	je	SHORT $LN56@Resize_rea

; 1804 :     }
; 1805 : 
; 1806 :     constexpr pointer _Release() { // suppress any exception handling backout and return _Last
; 1807 :         _First = _Last;
; 1808 :         return _Last;
; 1809 :     }
; 1810 : 
; 1811 : private:
; 1812 :     pointer _First;
; 1813 :     pointer _Last;
; 1814 :     _Alloc& _Al;
; 1815 : };
; 1816 : 
; 1817 : template <class _InIt, class _Se, class _Alloc>
; 1818 : _CONSTEXPR20 _Alloc_ptr_t<_Alloc> _Uninitialized_copy(
; 1819 :     _InIt _First, _Se _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {
; 1820 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1821 :     // note: only called internally from elsewhere in the STL
; 1822 :     using _Ptrval = typename _Alloc::value_type*;
; 1823 : 
; 1824 : #ifdef __cpp_lib_concepts
; 1825 :     auto _UFirst = _RANGES _Unwrap_iter<_Se>(_STD move(_First));
; 1826 :     auto _ULast  = _RANGES _Unwrap_sent<_InIt>(_STD move(_Last));
; 1827 : #else // ^^^ __cpp_lib_concepts / !__cpp_lib_concepts vvv
; 1828 :     // In pre-concepts world, _Uninitialized_copy should only ever be called with an iterator
; 1829 :     // and sentinel of the same type, so `_Get_unwrapped` is fine to call.
; 1830 :     auto _UFirst = _Get_unwrapped(_STD move(_First));
; 1831 :     auto _ULast  = _Get_unwrapped(_STD move(_Last));
; 1832 : #endif // ^^^ !__cpp_lib_concepts ^^^
; 1833 : 
; 1834 :     constexpr bool _Can_memmove = _Sent_copy_cat<decltype(_UFirst), decltype(_ULast), _Ptrval>::_Bitcopy_constructible
; 1835 :                                && _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>::value;
; 1836 : 
; 1837 :     if constexpr (_Can_memmove) {
; 1838 : #if _HAS_CXX20
; 1839 :         if (!_STD is_constant_evaluated())
; 1840 : #endif // _HAS_CXX20
; 1841 :         {
; 1842 :             if constexpr (is_same_v<decltype(_UFirst), decltype(_ULast)>) {
; 1843 :                 _Copy_memmove(_To_address(_UFirst), _To_address(_ULast), _Unfancy(_Dest));
; 1844 :                 _Dest += _ULast - _UFirst;
; 1845 :             } else {
; 1846 :                 const auto _Count = static_cast<size_t>(_ULast - _UFirst);
; 1847 :                 _Copy_memmove_n(_To_address(_UFirst), _Count, _Unfancy(_Dest));
; 1848 :                 _Dest += _Count;
; 1849 :             }
; 1850 :             return _Dest;
; 1851 :         }
; 1852 :     }
; 1853 : 
; 1854 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1855 :     for (; _UFirst != _ULast; ++_UFirst) {
; 1856 :         _Backout._Emplace_back(*_UFirst);
; 1857 :     }
; 1858 : 
; 1859 :     return _Backout._Release();
; 1860 : }
; 1861 : 
; 1862 : template <class _InIt, class _Alloc>
; 1863 : _CONSTEXPR20 _Alloc_ptr_t<_Alloc> _Uninitialized_copy_n(
; 1864 :     _InIt _First, size_t _Count, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {
; 1865 :     // copy _First + [0, _Count) to raw _Dest, using _Al
; 1866 :     // note: only called internally from elsewhere in the STL
; 1867 :     using _Ptrval = typename _Alloc::value_type*;
; 1868 : 
; 1869 :     auto _UFirst = _Get_unwrapped(_STD move(_First));
; 1870 : 
; 1871 :     constexpr bool _Can_memmove =
; 1872 :         conjunction_v<bool_constant<_Iter_copy_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1873 :             _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>;
; 1874 : 
; 1875 :     if constexpr (_Can_memmove) {
; 1876 : #if _HAS_CXX20
; 1877 :         if (!_STD is_constant_evaluated())
; 1878 : #endif // _HAS_CXX20
; 1879 :         {
; 1880 :             _Copy_memmove_n(_UFirst, _Count, _Unfancy(_Dest));
; 1881 :             _Dest += _Count;
; 1882 :             return _Dest;
; 1883 :         }
; 1884 :     }
; 1885 : 
; 1886 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1887 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {
; 1888 :         _Backout._Emplace_back(*_UFirst);
; 1889 :     }
; 1890 : 
; 1891 :     return _Backout._Release();
; 1892 : }
; 1893 : 
; 1894 : template <class _InIt, class _NoThrowFwdIt>
; 1895 : _CONSTEXPR20 _NoThrowFwdIt _Uninitialized_copy_unchecked(_InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {
; 1896 :     // copy [_First, _Last) to raw [_Dest, ...)
; 1897 :     if constexpr (_Iter_copy_cat<_InIt, _NoThrowFwdIt>::_Bitcopy_constructible) {
; 1898 : #if _HAS_CXX20
; 1899 :         if (!_STD is_constant_evaluated())
; 1900 : #endif // _HAS_CXX20
; 1901 :         {
; 1902 :             return _Copy_memmove(_First, _Last, _Dest);
; 1903 :         }
; 1904 :     }
; 1905 : 
; 1906 :     _Uninitialized_backout<_NoThrowFwdIt> _Backout{_Dest};
; 1907 :     for (; _First != _Last; ++_First) {
; 1908 :         _Backout._Emplace_back(*_First);
; 1909 :     }
; 1910 : 
; 1911 :     return _Backout._Release();
; 1912 : }
; 1913 : 
; 1914 : _EXPORT_STD template <class _InIt, class _NoThrowFwdIt>
; 1915 : _NoThrowFwdIt uninitialized_copy(const _InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {
; 1916 :     // copy [_First, _Last) to raw [_Dest, ...)
; 1917 :     _Adl_verify_range(_First, _Last);
; 1918 :     auto _UFirst      = _Get_unwrapped(_First);
; 1919 :     const auto _ULast = _Get_unwrapped(_Last);
; 1920 :     auto _UDest       = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
; 1921 :     _Seek_wrapped(_Dest, _Uninitialized_copy_unchecked(_UFirst, _ULast, _UDest));
; 1922 :     return _Dest;
; 1923 : }
; 1924 : 
; 1925 : template <class _InIt, class _Alloc>
; 1926 : _CONSTEXPR20 _Alloc_ptr_t<_Alloc> _Uninitialized_move(
; 1927 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	lea	r8, QWORD PTR [rax+16]
	npad	11
$LL57@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [rbx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	lea	r8, QWORD PTR [r8+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [rbx+8]
	mov	rax, QWORD PTR [rbx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rbx+16], r10
	mov	QWORD PTR [rbx+8], r10
	mov	QWORD PTR [rbx], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	rbx, 24
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r8-40], rax
	mov	QWORD PTR [r8-32], rcx
	mov	QWORD PTR [r8-24], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rbx, r9
	jne	SHORT $LL57@Resize_rea
	mov	rbx, QWORD PTR [rdi]
$LN56@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2023 :         if (_Myfirst) { // destroy and deallocate old array

	test	rbx, rbx
	je	SHORT $LN120@Resize_rea

; 2024 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rsi, QWORD PTR [rdi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rsi
	je	SHORT $LN104@Resize_rea
$LL105@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	mov	rcx, rbx
	call	?_Tidy@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 24
	cmp	rbx, rsi
	jne	SHORT $LL105@Resize_rea
$LN104@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rdi]
	mov	rax, QWORD PTR [rdi+16]
	sub	rax, rcx
	sar	rax, 3
	imul	rax, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*2]
	shl	rdx, 3

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN132@Resize_rea

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN129@Resize_rea

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN132@Resize_rea:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN120@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1548 :     }

	mov	rbx, QWORD PTR [rsp+72]

; 2030 :         _Mylast  = _Newvec + _Newsize;

	lea	rax, QWORD PTR [r15+144]

; 1548 :     }

	mov	rbp, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]

; 2029 :         _Myfirst = _Newvec;

	mov	QWORD PTR [rdi], r15

; 2030 :         _Mylast  = _Newvec + _Newsize;

	mov	QWORD PTR [rdi+8], rax

; 2031 :         _Myend   = _Newvec + _Newcapacity;

	lea	rax, QWORD PTR [r14+r14*2]
	lea	rcx, QWORD PTR [r15+rax*8]
	mov	QWORD PTR [rdi+16], rcx

; 1548 :     }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
$LN129@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN166@Resize_rea:
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_KAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Count$ = 16
_Al$dead$ = 24
??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_KAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >, COMDAT

; 2027 :     // value-initialize _Count objects to raw _First, using _Al
; 2028 :     using _Ptrty = typename _Alloc::value_type*;
; 2029 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2030 : #if _HAS_CXX20
; 2031 :         if (!_STD is_constant_evaluated())
; 2032 : #endif // _HAS_CXX20
; 2033 :         {
; 2034 :             auto _PFirst = _Unfancy(_First);
; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2036 :             return _First + _Count;
; 2037 :         }
; 2038 :     }
; 2039 : 
; 2040 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2041 :     for (; 0 < _Count; --_Count) {

	test	rdx, rdx
	je	SHORT $LN48@Uninitiali
	xor	eax, eax
	npad	9
$LL4@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rcx, 24

; 2027 :     // value-initialize _Count objects to raw _First, using _Al
; 2028 :     using _Ptrty = typename _Alloc::value_type*;
; 2029 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2030 : #if _HAS_CXX20
; 2031 :         if (!_STD is_constant_evaluated())
; 2032 : #endif // _HAS_CXX20
; 2033 :         {
; 2034 :             auto _PFirst = _Unfancy(_First);
; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2036 :             return _First + _Count;
; 2037 :         }
; 2038 :     }
; 2039 : 
; 2040 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rdx, 1
	jne	SHORT $LL4@Uninitiali
$LN48@Uninitiali:

; 2042 :         _Backout._Emplace_back();
; 2043 :     }
; 2044 : 
; 2045 :     return _Backout._Release();
; 2046 : }

	mov	rax, rcx
	ret	0
??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_KAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA$$QEAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAPEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA$$QEAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAPEAV10@@Z PROC ; std::move<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > * &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA$$QEAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAPEAV10@@Z ENDP ; std::move<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA?A_T$$QEAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA?A_T$$QEAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA?A_T$$QEAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_copy_n@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_Guard$1 = 32
$T2 = 40
_Backout$3 = 48
_Backout$ = 72
__$ArrayPad$ = 96
_First$ = 160
_Count$ = 168
_Dest$ = 176
_Al$ = 184
??$_Uninitialized_copy_n@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z PROC ; std::_Uninitialized_copy_n<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >, COMDAT

; 1864 :     _InIt _First, size_t _Count, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN117:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 112				; 00000070H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rsi, r8
	mov	r15, rdx
	mov	r14, rcx
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _Backout$[rsp], xmm0

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR _Backout$[rsp], r8
	mov	QWORD PTR _Backout$[rsp+8], r8
	mov	QWORD PTR _Backout$[rsp+16], r9

; 1865 :     // copy _First + [0, _Count) to raw _Dest, using _Al
; 1866 :     // note: only called internally from elsewhere in the STL
; 1867 :     using _Ptrval = typename _Alloc::value_type*;
; 1868 : 
; 1869 :     auto _UFirst = _Get_unwrapped(_STD move(_First));
; 1870 : 
; 1871 :     constexpr bool _Can_memmove =
; 1872 :         conjunction_v<bool_constant<_Iter_copy_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1873 :             _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>;
; 1874 : 
; 1875 :     if constexpr (_Can_memmove) {
; 1876 : #if _HAS_CXX20
; 1877 :         if (!_STD is_constant_evaluated())
; 1878 : #endif // _HAS_CXX20
; 1879 :         {
; 1880 :             _Copy_memmove_n(_UFirst, _Count, _Unfancy(_Dest));
; 1881 :             _Dest += _Count;
; 1882 :             return _Dest;
; 1883 :         }
; 1884 :     }
; 1885 : 
; 1886 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1887 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {

	test	rdx, rdx
	je	$LN113@Uninitiali
	xor	r12d, r12d
	mov	rax, -6148914691236517205		; aaaaaaaaaaaaaaabH
	mov	r13, 192153584101141162			; 02aaaaaaaaaaaaaaH
	npad	5
$LL4@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rsi], r12
	mov	QWORD PTR [rsi+8], r12
	mov	QWORD PTR [rsi+16], r12

; 685  :         const auto _Count       = static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst);

	mov	rbx, QWORD PTR [r14+8]
	sub	rbx, QWORD PTR [r14]
	sar	rbx, 5
	imul	rbx, rax

; 2065 :         if (_Count != 0) {

	test	rbx, rbx
	je	$LN71@Uninitiali

; 2006 :         if (_Newcapacity > max_size()) {

	cmp	rbx, r13
	ja	$LN100@Uninitiali

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdx, rbx
	call	?allocate@?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z ; std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>::allocate
	mov	rdi, rax

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rsi], rax

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [rsi+8], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rax, QWORD PTR [rbx+rbx*2]
	shl	rax, 5
	add	rax, rdi
	mov	QWORD PTR [rsi+16], rax

; 2067 :             _Tidy_guard<vector> _Guard{this};

	mov	QWORD PTR _Guard$1[rsp], rsi

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rbp, QWORD PTR [r14+8]
	mov	rbx, QWORD PTR [r14]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _Backout$3[rsp], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR _Backout$3[rsp], rdi
	mov	QWORD PTR _Backout$3[rsp+8], rdi
	mov	QWORD PTR _Backout$3[rsp+16], rsi

; 1855 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rbx, rbp
	je	SHORT $LN35@Uninitiali
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1983 :         pointer& _Mylast  = _My_data._Mylast;

	add	rbx, 40					; 00000028H
	npad	7
$LL36@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T2[rsp], rdi
	lea	rdx, QWORD PTR [rbx-40]
	mov	rcx, rdi
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, DWORD PTR [rbx-8]
	mov	DWORD PTR [rdi+32], eax
	lea	rcx, QWORD PTR [rdi+40]
	mov	rdx, rbx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rdi+72]
	lea	rdx, QWORD PTR [rbx+32]
	call	??0?$vector@W4FlagsStruct@AINBFile@@V?$allocator@W4FlagsStruct@AINBFile@@@std@@@std@@QEAA@AEBV01@@Z ; std::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rdi, 96					; 00000060H
	mov	QWORD PTR _Backout$3[rsp+8], rdi

; 1855 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	rbx, 96					; 00000060H
	lea	rax, QWORD PTR [rbx-40]
	cmp	rax, rbp
	jne	SHORT $LL36@Uninitiali
$LN35@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	QWORD PTR [rsi+8], rdi

; 2075 :             } else {
; 2076 :                 static_assert(_Always_false<_Ty>, "Should be unreachable");
; 2077 :             }
; 2078 :             _ASAN_VECTOR_CREATE;
; 2079 :             _Guard._Target = nullptr;
; 2080 :         }

	mov	rax, -6148914691236517205		; aaaaaaaaaaaaaaabH
$LN71@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rsi, 24
	mov	QWORD PTR _Backout$[rsp+8], rsi

; 1865 :     // copy _First + [0, _Count) to raw _Dest, using _Al
; 1866 :     // note: only called internally from elsewhere in the STL
; 1867 :     using _Ptrval = typename _Alloc::value_type*;
; 1868 : 
; 1869 :     auto _UFirst = _Get_unwrapped(_STD move(_First));
; 1870 : 
; 1871 :     constexpr bool _Can_memmove =
; 1872 :         conjunction_v<bool_constant<_Iter_copy_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1873 :             _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>;
; 1874 : 
; 1875 :     if constexpr (_Can_memmove) {
; 1876 : #if _HAS_CXX20
; 1877 :         if (!_STD is_constant_evaluated())
; 1878 : #endif // _HAS_CXX20
; 1879 :         {
; 1880 :             _Copy_memmove_n(_UFirst, _Count, _Unfancy(_Dest));
; 1881 :             _Dest += _Count;
; 1882 :             return _Dest;
; 1883 :         }
; 1884 :     }
; 1885 : 
; 1886 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1887 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {

	add	r14, 24
	sub	r15, 1
	jne	$LL4@Uninitiali
$LN113@Uninitiali:

; 1888 :         _Backout._Emplace_back(*_UFirst);
; 1889 :     }
; 1890 : 
; 1891 :     return _Backout._Release();

	mov	rax, rsi

; 1892 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+112]
	mov	rbx, QWORD PTR [r11+56]
	mov	rbp, QWORD PTR [r11+64]
	mov	rsi, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
$LN100@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Xlength
	npad	1
$LN114@Uninitiali:
??$_Uninitialized_copy_n@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy_n<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Guard$1 = 32
$T2 = 40
_Backout$3 = 48
_Backout$ = 72
__$ArrayPad$ = 96
_First$ = 160
_Count$ = 168
_Dest$ = 176
_Al$ = 184
?dtor$0@?0???$_Uninitialized_copy_n@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z@4HA PROC ; `std::_Uninitialized_copy_n<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Backout$[rdx]
	jmp	??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::~_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >
?dtor$0@?0???$_Uninitialized_copy_n@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z@4HA ENDP ; `std::_Uninitialized_copy_n<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Guard$1 = 32
$T2 = 40
_Backout$3 = 48
_Backout$ = 72
__$ArrayPad$ = 96
_First$ = 160
_Count$ = 168
_Dest$ = 176
_Al$ = 184
?dtor$1@?0???$_Uninitialized_copy_n@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z@4HA PROC ; `std::_Uninitialized_copy_n<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >'::`1'::dtor$1
	lea	rcx, QWORD PTR _Guard$1[rdx]
	jmp	??1?$_Tidy_guard@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >::~_Tidy_guard<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >
?dtor$1@?0???$_Uninitialized_copy_n@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z@4HA ENDP ; `std::_Uninitialized_copy_n<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Guard$1 = 32
$T2 = 40
_Backout$3 = 48
_Backout$ = 72
__$ArrayPad$ = 96
_First$ = 160
_Count$ = 168
_Dest$ = 176
_Al$ = 184
?dtor$2@?0???$_Uninitialized_copy_n@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z@4HA PROC ; `std::_Uninitialized_copy_n<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >'::`1'::dtor$2
	lea	rcx, QWORD PTR _Backout$3[rdx]
	jmp	??1?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::~_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >
?dtor$2@?0???$_Uninitialized_copy_n@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z@4HA ENDP ; `std::_Uninitialized_copy_n<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Guard$1 = 32
$T2 = 40
_Backout$3 = 48
_Backout$ = 72
__$ArrayPad$ = 96
_First$ = 160
_Count$ = 168
_Dest$ = 176
_Al$ = 184
?dtor$3@?0???$_Uninitialized_copy_n@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z@4HA PROC ; `std::_Uninitialized_copy_n<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >'::`1'::dtor$3
	mov	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0???$_Uninitialized_copy_n@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z@4HA ENDP ; `std::_Uninitialized_copy_n<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Guard$1 = 32
$T2 = 40
_Backout$3 = 48
_Backout$ = 72
__$ArrayPad$ = 96
_First$ = 160
_Count$ = 168
_Dest$ = 176
_Al$ = 184
?dtor$4@?0???$_Uninitialized_copy_n@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z@4HA PROC ; `std::_Uninitialized_copy_n<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >'::`1'::dtor$4
	mov	rcx, QWORD PTR $T2[rdx]
	add	rcx, 40					; 00000028H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0???$_Uninitialized_copy_n@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z@4HA ENDP ; `std::_Uninitialized_copy_n<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Copy_n_unchecked4@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@_KPEAV12@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Dest$ = 64
??$_Copy_n_unchecked4@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@_KPEAV12@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0@Z PROC ; std::_Copy_n_unchecked4<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *,unsigned __int64,std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *>, COMDAT

; 4556 : _CONSTEXPR20 _OutIt _Copy_n_unchecked4(_InIt _First, _SizeTy _Count, _OutIt _Dest) {

$LN18:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, r8
	mov	rsi, rdx
	mov	rdi, rcx

; 4572 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	test	rdx, rdx
	je	SHORT $LN13@Copy_n_unc
	mov	QWORD PTR [rsp+48], rbp
	mov	rbp, -6148914691236517205		; aaaaaaaaaaaaaaabH
	npad	4
$LL4@Copy_n_unc:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rbx, rdi
	je	SHORT $LN2@Copy_n_unc

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [rdi]
	mov	rcx, rbx
	mov	r8, QWORD PTR [rdi+8]
	sub	r8, rdx
	sar	r8, 5
	imul	r8, rbp
	call	??$_Assign_counted_range@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Assign_counted_range<AINBNodeDefMgr::NodeDef::ImmediateParam *>
$LN2@Copy_n_unc:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4572 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	add	rbx, 24
	add	rdi, 24
	sub	rsi, 1
	jne	SHORT $LL4@Copy_n_unc
	mov	rbp, QWORD PTR [rsp+48]
$LN13@Copy_n_unc:

; 4573 :         *_Dest = *_First;
; 4574 :     }
; 4575 : 
; 4576 :     return _Dest;
; 4577 : }

	mov	rsi, QWORD PTR [rsp+64]
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_n_unchecked4@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@_KPEAV12@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@_K0@Z ENDP ; std::_Copy_n_unchecked4<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *,unsigned __int64,std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@AEAV10@@Z PROC ; std::forward<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::forward<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEBV?$allocator@I@std@@@std@@YAAEBV?$allocator@I@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$allocator@I@std@@@std@@YAAEBV?$allocator@I@0@AEBV10@@Z PROC ; std::forward<std::allocator<unsigned int> const &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEBV?$allocator@I@std@@@std@@YAAEBV?$allocator@I@0@AEBV10@@Z ENDP ; std::forward<std::allocator<unsigned int> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV21@@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$_Emplace_back_with_unused_capacity@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV21@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back_with_unused_capacity<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 790  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 791  :         auto& _My_data   = _Mypair._Myval2;
; 792  :         pointer& _Mylast = _My_data._Mylast;
; 793  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 794  :         if constexpr (conjunction_v<is_nothrow_constructible<_Ty, _Valty...>,
; 795  :                           _Uses_default_construct<_Alloc, _Ty*, _Valty...>>) {
; 796  :             _ASAN_VECTOR_MODIFY(1);
; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	rax, QWORD PTR [rcx+8]
	mov	r8, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	ecx, ecx
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rax], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rax+16], rcx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rax+24], rcx

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rax], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rax+16], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdx+16], rcx

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;
; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdx], cl
	mov	QWORD PTR [rdx+24], 15
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 805  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR [r8+8]

; 806  :         ++_Mylast;

	lea	rcx, QWORD PTR [rax+32]
	mov	QWORD PTR [r8+8], rcx

; 807  : 
; 808  :         return _Result;
; 809  :     }

	ret	0
??$_Emplace_back_with_unused_capacity@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV21@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back_with_unused_capacity<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@$$QEAV21@@Z
_TEXT	SEGMENT
this$ = 64
_Whereptr$ = 72
<_Val_0>$ = 80
??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@$$QEAV21@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 812  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN65:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 813  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 814  :         _Alty& _Al        = _Getal();
; 815  :         auto& _My_data    = _Mypair._Myval2;
; 816  :         pointer& _Myfirst = _My_data._Myfirst;
; 817  :         pointer& _Mylast  = _My_data._Mylast;
; 818  : 
; 819  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 820  : 
; 821  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);
; 822  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	mov	r14, rdx
	mov	rdx, QWORD PTR [rcx]
	mov	rsi, r14
	sub	rax, rdx
	sub	rsi, rdx
	sar	rax, 5

; 823  : 
; 824  :         if (_Oldsize == max_size()) {

	mov	rbx, 576460752303423487			; 07ffffffffffffffH
	mov	r15, r8
	mov	rdi, rcx
	cmp	rax, rbx
	je	$LN63@Emplace_re

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, rdx
	mov	QWORD PTR [rsp+64], rbp
	sar	rcx, 5

; 826  :         }
; 827  : 
; 828  :         const size_type _Newsize     = _Oldsize + 1;

	lea	rbp, QWORD PTR [rax+1]

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	mov	rax, rbx
	shr	rdx, 1
	sub	rax, rdx
	cmp	rcx, rax
	ja	SHORT $LN13@Emplace_re

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rbx, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rbx, rbp
	cmovb	rbx, rbp
$LN13@Emplace_re:

; 829  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 830  : 
; 831  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	rdx, rbx
	call	?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate

; 832  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;
; 833  :         pointer _Constructed_first      = _Constructed_last;
; 834  : 
; 835  :         _TRY_BEGIN
; 836  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	and	rsi, -32				; ffffffffffffffe0H
	mov	r11, rax
	add	rsi, rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 839  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	r8, r11
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rsi], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rsi+16], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rsi+24], rax

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r15]
	movups	XMMWORD PTR [rsi], xmm0
	movups	xmm1, XMMWORD PTR [r15+16]
	movups	XMMWORD PTR [rsi+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 839  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	QWORD PTR [r15+16], rax
	mov	QWORD PTR [r15+24], 15
	mov	BYTE PTR [r15], al
	mov	rdx, QWORD PTR [rdi+8]
	mov	rcx, QWORD PTR [rdi]
	cmp	r14, rdx
	je	SHORT $LN61@Emplace_re

; 840  :             if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 841  :                 _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);
; 842  :             } else {
; 843  :                 _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 844  :             }
; 845  :         } else { // provide basic guarantee
; 846  :             _Uninitialized_move(_Myfirst, _Whereptr, _Newvec, _Al);

	mov	rdx, r14
	call	??$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 847  :             _Constructed_first = _Newvec;
; 848  :             _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

	mov	rdx, QWORD PTR [rdi+8]
	lea	r8, QWORD PTR [rsi+32]
	mov	rcx, r14
$LN61@Emplace_re:
	call	??$_Uninitialized_move@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 849  :         }
; 850  :         _CATCH_ALL
; 851  :         _Destroy_range(_Constructed_first, _Constructed_last, _Al);
; 852  :         _Al.deallocate(_Newvec, _Newcapacity);
; 853  :         _RERAISE;
; 854  :         _CATCH_END
; 855  : 
; 856  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, rbx
	mov	r8, rbp
	mov	rdx, r11
	mov	rcx, rdi
	call	?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_K1@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Change_array

; 857  :         return _Newvec + _Whereoff;

	mov	rbp, QWORD PTR [rsp+64]
	mov	rax, rsi

; 858  :     }

	mov	rsi, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
$LN63@Emplace_re:

; 825  :             _Xlength();

	call	?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlength
	int	3
$LN60@Emplace_re:
??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@$$QEAV21@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@V?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z PROC ; std::forward<std::allocator<wchar_t> >, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@V?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z ENDP ; std::forward<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Unfancy@UNodeDef@AINBNodeDefMgr@@@std@@YAPEAUNodeDef@AINBNodeDefMgr@@PEAU12@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@UNodeDef@AINBNodeDefMgr@@@std@@YAPEAUNodeDef@AINBNodeDefMgr@@PEAU12@@Z PROC ; std::_Unfancy<AINBNodeDefMgr::NodeDef>, COMDAT

; 37   :     return _Ptr;

	mov	rax, rcx

; 38   : }

	ret	0
??$_Unfancy@UNodeDef@AINBNodeDefMgr@@@std@@YAPEAUNodeDef@AINBNodeDefMgr@@PEAU12@@Z ENDP ; std::_Unfancy<AINBNodeDefMgr::NodeDef>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$destroy@UNodeDef@AINBNodeDefMgr@@@?$_Default_allocator_traits@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@1@QEAUNodeDef@AINBNodeDefMgr@@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$destroy@UNodeDef@AINBNodeDefMgr@@@?$_Default_allocator_traits@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@1@QEAUNodeDef@AINBNodeDefMgr@@@Z PROC ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef> >::destroy<AINBNodeDefMgr::NodeDef>, COMDAT

; 724  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

	mov	rcx, rdx
	jmp	??1NodeDef@AINBNodeDefMgr@@QEAA@XZ
??$destroy@UNodeDef@AINBNodeDefMgr@@@?$_Default_allocator_traits@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@1@QEAUNodeDef@AINBNodeDefMgr@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef> >::destroy<AINBNodeDefMgr::NodeDef>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Unfancy@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@@Z PROC ; std::_Unfancy<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >, COMDAT

; 37   :     return _Ptr;

	mov	rax, rcx

; 38   : }

	ret	0
??$_Unfancy@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@@Z ENDP ; std::_Unfancy<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$destroy@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$destroy@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::destroy<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	mov	rcx, rdx
	jmp	?_Tidy@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Tidy
??$destroy@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::destroy<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Unfancy@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@@Z PROC ; std::_Unfancy<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >, COMDAT

; 37   :     return _Ptr;

	mov	rax, rcx

; 38   : }

	ret	0
??$_Unfancy@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@PEAV10@@Z ENDP ; std::_Unfancy<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$destroy@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$destroy@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::destroy<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	mov	rcx, rdx
	jmp	?_Tidy@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Tidy
??$destroy@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::destroy<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@PEA_W@std@@YAPEAPEA_WAEAPEA_W@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEA_W@std@@YAPEAPEA_WAEAPEA_W@Z PROC	; std::addressof<wchar_t *>, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@PEA_W@std@@YAPEAPEA_WAEAPEA_W@Z ENDP	; std::addressof<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEAPEA_W@std@@YAAEAPEA_WAEAPEA_W@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEA_W@std@@YAAEAPEA_WAEAPEA_W@Z PROC	; std::forward<wchar_t * &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEAPEA_W@std@@YAAEAPEA_WAEAPEA_W@Z ENDP	; std::forward<wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@PEA_WAEAPEA_W$0A@@std@@YAPEAPEA_WQEAPEA_WAEAPEA_W@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@PEA_WAEAPEA_W$0A@@std@@YAPEAPEA_WQEAPEA_WAEAPEA_W@Z PROC ; std::construct_at<wchar_t *,wchar_t * &,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@PEA_WAEAPEA_W$0A@@std@@YAPEAPEA_WQEAPEA_WAEAPEA_W@Z ENDP ; std::construct_at<wchar_t *,wchar_t * &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAPEAU_Recursive_dir_enum_impl@filesystem@std@@@std@@YA$$QEAPEAU_Recursive_dir_enum_impl@filesystem@0@AEAPEAU120@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAPEAU_Recursive_dir_enum_impl@filesystem@std@@@std@@YA$$QEAPEAU_Recursive_dir_enum_impl@filesystem@0@AEAPEAU120@@Z PROC ; std::move<std::filesystem::_Recursive_dir_enum_impl * &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAPEAU_Recursive_dir_enum_impl@filesystem@std@@@std@@YA$$QEAPEAU_Recursive_dir_enum_impl@filesystem@0@AEAPEAU120@@Z ENDP ; std::move<std::filesystem::_Recursive_dir_enum_impl * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAPEAV_Ref_count_base@std@@@std@@YA$$QEAPEAV_Ref_count_base@0@AEAPEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAPEAV_Ref_count_base@std@@@std@@YA$$QEAPEAV_Ref_count_base@0@AEAPEAV10@@Z PROC ; std::move<std::_Ref_count_base * &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAPEAV_Ref_count_base@std@@@std@@YA$$QEAPEAV_Ref_count_base@0@AEAPEAV10@@Z ENDP ; std::move<std::_Ref_count_base * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEBQEA_W@std@@YAAEBQEA_WAEBQEA_W@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEA_W@std@@YAAEBQEA_WAEBQEA_W@Z PROC	; std::forward<wchar_t * const &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEBQEA_W@std@@YAAEBQEA_WAEBQEA_W@Z ENDP	; std::forward<wchar_t * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@PEA_WAEBQEA_W$0A@@std@@YAPEAPEA_WQEAPEA_WAEBQEA_W@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@PEA_WAEBQEA_W$0A@@std@@YAPEAPEA_WQEAPEA_WAEBQEA_W@Z PROC ; std::construct_at<wchar_t *,wchar_t * const &,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@PEA_WAEBQEA_W$0A@@std@@YAPEAPEA_WQEAPEA_WAEBQEA_W@Z ENDP ; std::construct_at<wchar_t *,wchar_t * const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Unfancy@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@@Z PROC ; std::_Unfancy<enum AINBNodeDefMgr::NodeDef::CategoryEnum>, COMDAT

; 37   :     return _Ptr;

	mov	rax, rcx

; 38   : }

	ret	0
??$_Unfancy@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@@Z ENDP ; std::_Unfancy<enum AINBNodeDefMgr::NodeDef::CategoryEnum>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@$$CBV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YAPEBV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YAPEBV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEBV10@@Z PROC ; std::addressof<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > const >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@$$CBV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YAPEBV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Pocca@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAXAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Left$dead$ = 8
_Right$dead$ = 16
??$_Pocca@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAXAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@AEBV10@@Z PROC ; std::_Pocca<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >, COMDAT

; 1060 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 1061 :         _Left = _Right;
; 1062 :     }
; 1063 : }

	ret	0
??$_Pocca@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAXAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@AEBV10@@Z ENDP ; std::_Pocca<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Assign_counted_range@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z
_TEXT	SEGMENT
this$ = 96
_First$ = 104
_Newsize$ = 112
??$_Assign_counted_range@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z PROC ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Assign_counted_range<AINBNodeDefMgr::NodeDef::ImmediateParam *>, COMDAT

; 1381 :     _CONSTEXPR20 void _Assign_counted_range(_Iter _First, const size_type _Newsize) {

$LN131:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 40					; 00000028H

; 1382 :         // assign elements from counted range _First + [0, _Newsize)
; 1383 :         auto& _Al         = _Getal();
; 1384 :         auto& _My_data    = _Mypair._Myval2;
; 1385 :         pointer& _Myfirst = _My_data._Myfirst;
; 1386 :         pointer& _Mylast  = _My_data._Mylast;
; 1387 :         pointer& _Myend   = _My_data._Myend;
; 1388 : 
; 1389 :         constexpr bool _Nothrow_construct = conjunction_v<is_nothrow_constructible<_Ty, _Iter_ref_t<_Iter>>,
; 1390 :             _Uses_default_construct<_Alloc, _Ty*, _Iter_ref_t<_Iter>>>;
; 1391 : 
; 1392 :         _My_data._Orphan_all();
; 1393 :         const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

	mov	rbx, QWORD PTR [rcx]
	mov	r15, rcx
	mov	rcx, QWORD PTR [rcx+16]
	mov	rbp, -6148914691236517205		; aaaaaaaaaaaaaaabH
	sub	rcx, rbx
	mov	r14, r8
	sar	rcx, 5
	mov	rdi, rdx
	imul	rcx, rbp

; 1394 :         if (_Newsize > _Oldcapacity) {

	cmp	r8, rcx
	jbe	$LN5@Assign_cou
	mov	QWORD PTR [rsp+32], r12

; 1658 :         if (_Newsize > max_size()) {

	mov	r12, 192153584101141162			; 02aaaaaaaaaaaaaaH
	cmp	r8, r12
	ja	$LN129@Assign_cou

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	mov	rax, r12
	shr	rdx, 1
	sub	rax, rdx
	cmp	rcx, rax
	ja	SHORT $LN16@Assign_cou

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	r12, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	r12, r8
	cmovb	r12, r8
$LN16@Assign_cou:

; 1664 :         if (_Myfirst) { // destroy and deallocate old array

	test	rbx, rbx
	je	SHORT $LN12@Assign_cou

; 1665 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rsi, QWORD PTR [r15+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rsi
	je	SHORT $LN22@Assign_cou
	npad	3
$LL23@Assign_cou:
	mov	rcx, rbx
	call	??1ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ
	add	rbx, 96					; 00000060H
	cmp	rbx, rsi
	jne	SHORT $LL23@Assign_cou
$LN22@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1667 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [r15]
	mov	rax, QWORD PTR [r15+16]
	sub	rax, rcx
	sar	rax, 5
	imul	rax, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*2]
	shl	rdx, 5

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN48@Assign_cou

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN45@Assign_cou

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN48@Assign_cou:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1669 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [r15], rax

; 1670 :             _Mylast  = nullptr;

	mov	QWORD PTR [r15+8], rax

; 1671 :             _Myend   = nullptr;

	mov	QWORD PTR [r15+16], rax
$LN12@Assign_cou:

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdx, r12
	call	?allocate@?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z ; std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>::allocate

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [r15], rax

; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	r8, QWORD PTR [r12+r12*2]
	shl	r8, 5

; 1395 :             _Clear_and_reserve_geometric(_Newsize);
; 1396 :             if constexpr (_Nothrow_construct) {
; 1397 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1398 :                 _ASAN_VECTOR_CREATE;
; 1399 :             } else {
; 1400 :                 _ASAN_VECTOR_CREATE_GUARD;
; 1401 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	r9, r15

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	add	r8, rax
	mov	QWORD PTR [r15+8], rax
	mov	QWORD PTR [r15+16], r8

; 1395 :             _Clear_and_reserve_geometric(_Newsize);
; 1396 :             if constexpr (_Nothrow_construct) {
; 1397 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1398 :                 _ASAN_VECTOR_CREATE;
; 1399 :             } else {
; 1400 :                 _ASAN_VECTOR_CREATE_GUARD;
; 1401 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	rdx, r14
	mov	r8, rax
	mov	rcx, rdi
	call	??$_Uninitialized_copy_n@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z ; std::_Uninitialized_copy_n<AINBNodeDefMgr::NodeDef::ImmediateParam *,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >
	mov	r12, QWORD PTR [rsp+32]
	mov	QWORD PTR [r15+8], rax

; 1440 :         }
; 1441 :     }

	add	rsp, 40					; 00000028H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN45@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN5@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1406 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r8, QWORD PTR [r15+8]
	mov	rsi, r8
	sub	rsi, rbx
	sar	rsi, 5
	imul	rsi, rbp

; 1407 :         if (_Newsize > _Oldsize) {

	cmp	r14, rsi
	jbe	SHORT $LN6@Assign_cou

; 1408 :             bool _Copied = false;
; 1409 :             if constexpr (_Iter_copy_cat<_Iter, pointer>::_Bitcopy_assignable) {
; 1410 : #if _HAS_CXX20
; 1411 :                 if (!_STD is_constant_evaluated())
; 1412 : #endif // _HAS_CXX20
; 1413 :                 {
; 1414 :                     _Copy_memmove_n(_First, static_cast<size_t>(_Oldsize), _Myfirst);
; 1415 :                     _First += _Oldsize;
; 1416 :                     _Copied = true;
; 1417 :                 }
; 1418 :             }
; 1419 : 
; 1420 :             if (!_Copied) {
; 1421 :                 for (auto _Mid = _Myfirst; _Mid != _Mylast; ++_Mid, (void) ++_First) {

	cmp	rbx, r8
	je	SHORT $LN3@Assign_cou
	npad	10
$LL4@Assign_cou:

; 1422 :                     *_Mid = *_First;

	mov	rdx, rdi
	mov	rcx, rbx
	call	??4ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAAAEAU012@AEBU012@@Z
	mov	r8, QWORD PTR [r15+8]
	add	rbx, 96					; 00000060H
	add	rdi, 96					; 00000060H
	cmp	rbx, r8
	jne	SHORT $LL4@Assign_cou
$LN3@Assign_cou:

; 1423 :                 }
; 1424 :             }
; 1425 : 
; 1426 :             if constexpr (_Nothrow_construct) {
; 1427 :                 _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1428 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);
; 1429 :             } else {
; 1430 :                 _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1431 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);

	sub	r14, rsi
	mov	r9, r15
	mov	rdx, r14
	mov	rcx, rdi
	call	??$_Uninitialized_copy_n@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z ; std::_Uninitialized_copy_n<AINBNodeDefMgr::NodeDef::ImmediateParam *,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >
	mov	QWORD PTR [r15+8], rax

; 1440 :         }
; 1441 :     }

	add	rsp, 40					; 00000028H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN6@Assign_cou:

; 1435 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rbp, QWORD PTR [r14+r14*2]
	shl	rbp, 5
	add	rbp, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4572 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	test	r14, r14
	je	SHORT $LN57@Assign_cou
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1435 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rsi, QWORD PTR [rbx+40]
	add	rdi, 64					; 00000040H
$LL58@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3156 :         if (this == _STD addressof(_Right)) {

	lea	rdx, QWORD PTR [rdi-64]
	cmp	rbx, rdx
	je	SHORT $LN62@Assign_cou

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdi-40], 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN66@Assign_cou

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN66@Assign_cou:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rdi-48]
	mov	rcx, rbx
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN62@Assign_cou:
	mov	eax, DWORD PTR [rdi-32]

; 3156 :         if (this == _STD addressof(_Right)) {

	lea	rdx, QWORD PTR [rdi-24]
	mov	DWORD PTR [rsi-8], eax
	cmp	rsi, rdx
	je	SHORT $LN70@Assign_cou

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdi], 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN74@Assign_cou

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN74@Assign_cou:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rdi-8]
	mov	rcx, rsi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN70@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1483 :         if (this == _STD addressof(_Right)) {

	lea	rdx, QWORD PTR [rdi+8]
	lea	rcx, QWORD PTR [rsi+32]
	cmp	rcx, rdx
	je	SHORT $LN56@Assign_cou

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [rdx]
	mov	r8, QWORD PTR [rdi+16]
	sub	r8, rdx
	call	??$_Assign_counted_range@PEAW4FlagsStruct@AINBFile@@@?$vector@W4FlagsStruct@AINBFile@@V?$allocator@W4FlagsStruct@AINBFile@@@std@@@std@@AEAAXPEAW4FlagsStruct@AINBFile@@_K@Z ; std::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >::_Assign_counted_range<enum AINBFile::FlagsStruct *>
$LN56@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4572 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	add	rbx, 96					; 00000060H
	add	rsi, 96					; 00000060H
	add	rdi, 96					; 00000060H
	sub	r14, 1
	jne	SHORT $LL58@Assign_cou
$LN57@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1437 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rdi, QWORD PTR [r15+8]
	mov	rbx, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbp, rdi
	je	SHORT $LN83@Assign_cou
$LL84@Assign_cou:
	mov	rcx, rbx
	call	??1ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ
	add	rbx, 96					; 00000060H
	cmp	rbx, rdi
	jne	SHORT $LL84@Assign_cou
$LN83@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1439 :             _Mylast = _Newlast;

	mov	QWORD PTR [r15+8], rbp

; 1440 :         }
; 1441 :     }

	add	rsp, 40					; 00000028H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN129@Assign_cou:

; 1659 :             _Xlength();

	call	?_Xlength@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Xlength
	int	3
$LN127@Assign_cou:
??$_Assign_counted_range@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z ENDP ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Assign_counted_range<AINBNodeDefMgr::NodeDef::ImmediateParam *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@$$CBV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YAPEBV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YAPEBV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEBV10@@Z PROC ; std::addressof<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > const >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@$$CBV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YAPEBV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Pocca@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAXAEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Left$dead$ = 8
_Right$dead$ = 16
??$_Pocca@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAXAEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@AEBV10@@Z PROC ; std::_Pocca<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >, COMDAT

; 1060 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 1061 :         _Left = _Right;
; 1062 :     }
; 1063 : }

	ret	0
??$_Pocca@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAXAEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@AEBV10@@Z ENDP ; std::_Pocca<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Assign_counted_range@PEAUInputParam@NodeDef@AINBNodeDefMgr@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 112
_First$ = 120
_Newsize$ = 128
??$_Assign_counted_range@PEAUInputParam@NodeDef@AINBNodeDefMgr@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z PROC ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Assign_counted_range<AINBNodeDefMgr::NodeDef::InputParam *>, COMDAT

; 1381 :     _CONSTEXPR20 void _Assign_counted_range(_Iter _First, const size_type _Newsize) {

$LN143:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 56					; 00000038H

; 1382 :         // assign elements from counted range _First + [0, _Newsize)
; 1383 :         auto& _Al         = _Getal();
; 1384 :         auto& _My_data    = _Mypair._Myval2;
; 1385 :         pointer& _Myfirst = _My_data._Myfirst;
; 1386 :         pointer& _Mylast  = _My_data._Mylast;
; 1387 :         pointer& _Myend   = _My_data._Myend;
; 1388 : 
; 1389 :         constexpr bool _Nothrow_construct = conjunction_v<is_nothrow_constructible<_Ty, _Iter_ref_t<_Iter>>,
; 1390 :             _Uses_default_construct<_Alloc, _Ty*, _Iter_ref_t<_Iter>>>;
; 1391 : 
; 1392 :         _My_data._Orphan_all();
; 1393 :         const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

	mov	rdi, QWORD PTR [rcx]
	mov	r14, rcx
	mov	rcx, QWORD PTR [rcx+16]
	mov	rbp, -8198552921648689607		; 8e38e38e38e38e39H
	sub	rcx, rdi
	mov	r15, r8
	sar	rcx, 4
	mov	rbx, rdx
	imul	rcx, rbp

; 1394 :         if (_Newsize > _Oldcapacity) {

	cmp	r8, rcx
	jbe	$LN5@Assign_cou
	mov	QWORD PTR [rsp+48], r12

; 1658 :         if (_Newsize > max_size()) {

	mov	r12, 128102389400760775			; 01c71c71c71c71c7H
	cmp	r8, r12
	ja	$LN141@Assign_cou

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	mov	rax, r12
	shr	rdx, 1
	sub	rax, rdx
	cmp	rcx, rax
	ja	SHORT $LN16@Assign_cou

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	r12, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	r12, r8
	cmovb	r12, r8
$LN16@Assign_cou:

; 1664 :         if (_Myfirst) { // destroy and deallocate old array

	test	rdi, rdi
	je	SHORT $LN12@Assign_cou

; 1665 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rsi, QWORD PTR [r14+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rdi, rsi
	je	SHORT $LN22@Assign_cou
	npad	3
$LL23@Assign_cou:
	mov	rcx, rdi
	call	??1InputParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ
	add	rdi, 144				; 00000090H
	cmp	rdi, rsi
	jne	SHORT $LL23@Assign_cou
$LN22@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1667 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [r14]
	mov	rax, QWORD PTR [r14+16]
	sub	rax, rcx
	sar	rax, 4
	imul	rax, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*8]
	shl	rdx, 4

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN48@Assign_cou

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN45@Assign_cou

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN48@Assign_cou:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1669 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [r14], rax

; 1670 :             _Mylast  = nullptr;

	mov	QWORD PTR [r14+8], rax

; 1671 :             _Myend   = nullptr;

	mov	QWORD PTR [r14+16], rax
$LN12@Assign_cou:

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdx, r12
	call	?allocate@?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAPEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z ; std::allocator<AINBNodeDefMgr::NodeDef::InputParam>::allocate

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [r14], rax

; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	r8, QWORD PTR [r12+r12*8]
	shl	r8, 4

; 1395 :             _Clear_and_reserve_geometric(_Newsize);
; 1396 :             if constexpr (_Nothrow_construct) {
; 1397 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1398 :                 _ASAN_VECTOR_CREATE;
; 1399 :             } else {
; 1400 :                 _ASAN_VECTOR_CREATE_GUARD;
; 1401 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	r9, r14

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	add	r8, rax
	mov	QWORD PTR [r14+8], rax
	mov	QWORD PTR [r14+16], r8

; 1395 :             _Clear_and_reserve_geometric(_Newsize);
; 1396 :             if constexpr (_Nothrow_construct) {
; 1397 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1398 :                 _ASAN_VECTOR_CREATE;
; 1399 :             } else {
; 1400 :                 _ASAN_VECTOR_CREATE_GUARD;
; 1401 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	rdx, r15
	mov	r8, rax
	mov	rcx, rbx
	call	??$_Uninitialized_copy_n@PEAUInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z ; std::_Uninitialized_copy_n<AINBNodeDefMgr::NodeDef::InputParam *,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >
	mov	r12, QWORD PTR [rsp+48]
	mov	QWORD PTR [r14+8], rax

; 1440 :         }
; 1441 :     }

	add	rsp, 56					; 00000038H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN45@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN5@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1406 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r8, QWORD PTR [r14+8]
	mov	rsi, r8
	sub	rsi, rdi
	sar	rsi, 4
	imul	rsi, rbp

; 1407 :         if (_Newsize > _Oldsize) {

	cmp	r15, rsi
	jbe	SHORT $LN6@Assign_cou

; 1408 :             bool _Copied = false;
; 1409 :             if constexpr (_Iter_copy_cat<_Iter, pointer>::_Bitcopy_assignable) {
; 1410 : #if _HAS_CXX20
; 1411 :                 if (!_STD is_constant_evaluated())
; 1412 : #endif // _HAS_CXX20
; 1413 :                 {
; 1414 :                     _Copy_memmove_n(_First, static_cast<size_t>(_Oldsize), _Myfirst);
; 1415 :                     _First += _Oldsize;
; 1416 :                     _Copied = true;
; 1417 :                 }
; 1418 :             }
; 1419 : 
; 1420 :             if (!_Copied) {
; 1421 :                 for (auto _Mid = _Myfirst; _Mid != _Mylast; ++_Mid, (void) ++_First) {

	cmp	rdi, r8
	je	SHORT $LN3@Assign_cou
	npad	7
$LL4@Assign_cou:

; 1422 :                     *_Mid = *_First;

	mov	rdx, rbx
	mov	rcx, rdi
	call	??4InputParam@NodeDef@AINBNodeDefMgr@@QEAAAEAU012@AEBU012@@Z
	mov	r8, QWORD PTR [r14+8]
	add	rdi, 144				; 00000090H
	add	rbx, 144				; 00000090H
	cmp	rdi, r8
	jne	SHORT $LL4@Assign_cou
$LN3@Assign_cou:

; 1423 :                 }
; 1424 :             }
; 1425 : 
; 1426 :             if constexpr (_Nothrow_construct) {
; 1427 :                 _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1428 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);
; 1429 :             } else {
; 1430 :                 _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1431 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);

	sub	r15, rsi
	mov	r9, r14
	mov	rdx, r15
	mov	rcx, rbx
	call	??$_Uninitialized_copy_n@PEAUInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z ; std::_Uninitialized_copy_n<AINBNodeDefMgr::NodeDef::InputParam *,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >
	mov	QWORD PTR [r14+8], rax

; 1440 :         }
; 1441 :     }

	add	rsp, 56					; 00000038H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN6@Assign_cou:

; 1435 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rbp, QWORD PTR [r15+r15*8]
	shl	rbp, 4
	add	rbp, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4572 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	test	r15, r15
	je	$LN57@Assign_cou
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1435 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rsi, QWORD PTR [rdi+64]
	add	rbx, 56					; 00000038H
$LL58@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3156 :         if (this == _STD addressof(_Right)) {

	lea	rdx, QWORD PTR [rbx-56]
	cmp	rdi, rdx
	je	SHORT $LN62@Assign_cou

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rbx-32], 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN66@Assign_cou

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN66@Assign_cou:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rbx-40]
	mov	rcx, rdi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN62@Assign_cou:

; 3156 :         if (this == _STD addressof(_Right)) {

	lea	rdx, QWORD PTR [rbx-24]
	lea	rcx, QWORD PTR [rsi-32]
	cmp	rcx, rdx
	je	SHORT $LN70@Assign_cou

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rbx], 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN74@Assign_cou

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN74@Assign_cou:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rbx-8]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN70@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1483 :         if (this == _STD addressof(_Right)) {

	lea	rdx, QWORD PTR [rbx+8]
	cmp	rsi, rdx
	je	SHORT $LN78@Assign_cou

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [rdx]
	mov	rcx, rsi
	mov	r8, QWORD PTR [rbx+16]
	sub	r8, rdx
	call	??$_Assign_counted_range@PEAW4FlagsStruct@AINBFile@@@?$vector@W4FlagsStruct@AINBFile@@V?$allocator@W4FlagsStruct@AINBFile@@@std@@@std@@AEAAXPEAW4FlagsStruct@AINBFile@@_K@Z ; std::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >::_Assign_counted_range<enum AINBFile::FlagsStruct *>
$LN78@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 803  :         return static_cast<size_t>(_Which);

	movsx	rcx, BYTE PTR [rbx+64]

; 865  :         _STD _Variant_raw_visit(_That.index(), _That._Storage(), _Variant_assign_visitor<_Types...>{*this});

	lea	rax, QWORD PTR [rsi+24]

; 691  :     ++_Idx; // bias index by +1 to map {variant_npos} U [0, _Size) to the contiguous range [0, _Size]

	inc	rcx

; 865  :         _STD _Variant_raw_visit(_That.index(), _That._Storage(), _Variant_assign_visitor<_Types...>{*this});

	mov	QWORD PTR $T1[rsp], rax

; 692  :     return _Variant_raw_visit1<_Strategy>::_Visit(_Idx, static_cast<_Fn&&>(_Func), static_cast<_Storage&&>(_Obj));

	lea	r8, QWORD PTR [rbx+32]
	lea	rdx, QWORD PTR $T1[rsp]
	call	??$_Visit@U?$_Variant_assign_visitor@I_NMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VVector3F@@@std@@AEBV?$_Variant_storage_@$0A@I_NMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VVector3F@@@2@@?$_Variant_raw_visit1@$01@std@@SAX_K$$QEAU?$_Variant_assign_visitor@I_NMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VVector3F@@@1@AEBV?$_Variant_storage_@$0A@I_NMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VVector3F@@@1@@Z ; std::_Variant_raw_visit1<2>::_Visit<std::_Variant_assign_visitor<unsigned int,bool,float,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Vector3F>,std::_Variant_storage_<0,unsigned int,bool,float,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Vector3F> const &>
	mov	eax, DWORD PTR [rbx+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4572 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	add	rdi, 144				; 00000090H
	mov	DWORD PTR [rsi+64], eax
	movzx	eax, BYTE PTR [rbx+76]
	mov	BYTE PTR [rsi+68], al
	mov	eax, DWORD PTR [rbx+80]
	add	rbx, 144				; 00000090H
	mov	DWORD PTR [rsi+72], eax
	add	rsi, 144				; 00000090H
	sub	r15, 1
	jne	$LL58@Assign_cou
$LN57@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1437 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rdi, QWORD PTR [r14+8]
	mov	rbx, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbp, rdi
	je	SHORT $LN95@Assign_cou
$LL96@Assign_cou:
	mov	rcx, rbx
	call	??1InputParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ
	add	rbx, 144				; 00000090H
	cmp	rbx, rdi
	jne	SHORT $LL96@Assign_cou
$LN95@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1439 :             _Mylast = _Newlast;

	mov	QWORD PTR [r14+8], rbp

; 1440 :         }
; 1441 :     }

	add	rsp, 56					; 00000038H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN141@Assign_cou:

; 1659 :             _Xlength();

	call	?_Xlength@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Xlength
	int	3
$LN139@Assign_cou:
??$_Assign_counted_range@PEAUInputParam@NodeDef@AINBNodeDefMgr@@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXPEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z ENDP ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Assign_counted_range<AINBNodeDefMgr::NodeDef::InputParam *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@_W$$V$0A@@std@@YAPEA_WQEA_W@Z
_TEXT	SEGMENT
_Location$ = 8
??$construct_at@_W$$V$0A@@std@@YAPEA_WQEA_W@Z PROC	; std::construct_at<wchar_t,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	mov	WORD PTR [rcx], ax
	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@_W$$V$0A@@std@@YAPEA_WQEA_W@Z ENDP	; std::construct_at<wchar_t,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAAX_K@Z PROC ; std::shared_ptr<std::filesystem::_Recursive_dir_enum_impl>::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rcx], xmm0
	ret	0
?__autoclassinit2@?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAAX_K@Z ENDP ; std::shared_ptr<std::filesystem::_Recursive_dir_enum_impl>::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z PROC ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z PROC ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z PROC ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ??_G_Find_file_handle@filesystem@std@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_G_Find_file_handle@filesystem@std@@QEAAPEAXI@Z PROC	; std::filesystem::_Find_file_handle::`scalar deleting destructor', COMDAT
$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 605  :             __std_fs_directory_iterator_close(_Handle);

	mov	rcx, QWORD PTR [rcx]
	call	__std_fs_directory_iterator_close
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_G_Find_file_handle@filesystem@std@@QEAAPEAXI@Z ENDP	; std::filesystem::_Find_file_handle::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z PROC ; std::_Uninitialized_backout_al<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX_K@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAX_K@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAX_K@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAX_K@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAX_K@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Release, COMDAT

; 1807 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1808 :         return _Last;
; 1809 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::~_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >, COMDAT

; 1796 :     _CONSTEXPR20 ~_Uninitialized_backout_al() {

$LN24:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1797 :         _Destroy_range(_First, _Last, _Al);

	mov	rdi, QWORD PTR [rcx+8]
	mov	rbx, QWORD PTR [rcx]

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN5@Uninitiali
$LL6@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	mov	rcx, rbx
	call	?_Tidy@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 24
	cmp	rbx, rdi
	jne	SHORT $LL6@Uninitiali
$LN5@Uninitiali:

; 1798 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::~_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAA@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAA@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >, COMDAT

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAA@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Release, COMDAT

; 1807 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1808 :         return _Last;
; 1809 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::~_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >, COMDAT

; 1796 :     _CONSTEXPR20 ~_Uninitialized_backout_al() {

$LN24:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1797 :         _Destroy_range(_First, _Last, _Al);

	mov	rdi, QWORD PTR [rcx+8]
	mov	rbx, QWORD PTR [rcx]

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN5@Uninitiali
$LL6@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	mov	rcx, rbx
	call	?_Tidy@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 24
	cmp	rbx, rdi
	jne	SHORT $LL6@Uninitiali
$LN5@Uninitiali:

; 1798 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::~_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAA@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAA@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >, COMDAT

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAA@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Release, COMDAT

; 1807 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1808 :         return _Last;
; 1809 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Uninitialized_backout_al@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::~_Uninitialized_backout_al<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >, COMDAT

; 1797 :         _Destroy_range(_First, _Last, _Al);
; 1798 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::~_Uninitialized_backout_al<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@AEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@AEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Uninitialized_backout_al<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >, COMDAT

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@AEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Uninitialized_backout_al<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAUNodeDef@AINBNodeDefMgr@@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAUNodeDef@AINBNodeDefMgr@@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef> >::_Release, COMDAT

; 1807 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1808 :         return _Last;
; 1809 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAUNodeDef@AINBNodeDefMgr@@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Uninitialized_backout_al@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef> >::~_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef> >, COMDAT

; 1796 :     _CONSTEXPR20 ~_Uninitialized_backout_al() {

$LN22:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1797 :         _Destroy_range(_First, _Last, _Al);

	mov	rdi, QWORD PTR [rcx+8]
	mov	rbx, QWORD PTR [rcx]

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN5@Uninitiali
$LL6@Uninitiali:
	mov	rcx, rbx
	call	??1NodeDef@AINBNodeDefMgr@@QEAA@XZ
	add	rbx, 248				; 000000f8H
	cmp	rbx, rdi
	jne	SHORT $LL6@Uninitiali
$LN5@Uninitiali:

; 1798 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef> >::~_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@PEAUNodeDef@AINBNodeDefMgr@@AEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@PEAUNodeDef@AINBNodeDefMgr@@AEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef> >::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef> >, COMDAT

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@PEAUNodeDef@AINBNodeDefMgr@@AEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef> >::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAUInputParam@NodeDef@AINBNodeDefMgr@@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAUInputParam@NodeDef@AINBNodeDefMgr@@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Release, COMDAT

; 1807 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1808 :         return _Last;
; 1809 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAUInputParam@NodeDef@AINBNodeDefMgr@@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::~_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >, COMDAT

; 1796 :     _CONSTEXPR20 ~_Uninitialized_backout_al() {

$LN22:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1797 :         _Destroy_range(_First, _Last, _Al);

	mov	rdi, QWORD PTR [rcx+8]
	mov	rbx, QWORD PTR [rcx]

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN5@Uninitiali
$LL6@Uninitiali:
	mov	rcx, rbx
	call	??1InputParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ
	add	rbx, 144				; 00000090H
	cmp	rbx, rdi
	jne	SHORT $LL6@Uninitiali
$LN5@Uninitiali:

; 1798 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::~_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@PEAUInputParam@NodeDef@AINBNodeDefMgr@@AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@PEAUInputParam@NodeDef@AINBNodeDefMgr@@AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >, COMDAT

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@PEAUInputParam@NodeDef@AINBNodeDefMgr@@AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Release, COMDAT

; 1807 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1808 :         return _Last;
; 1809 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::~_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >, COMDAT

; 1796 :     _CONSTEXPR20 ~_Uninitialized_backout_al() {

$LN22:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1797 :         _Destroy_range(_First, _Last, _Al);

	mov	rdi, QWORD PTR [rcx+8]
	mov	rbx, QWORD PTR [rcx]

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN5@Uninitiali
$LL6@Uninitiali:
	mov	rcx, rbx
	call	??1ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ
	add	rbx, 96					; 00000060H
	cmp	rbx, rdi
	jne	SHORT $LL6@Uninitiali
$LN5@Uninitiali:

; 1798 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::~_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >, COMDAT

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ?_Delete_this@?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@EEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Delete_this@?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@EEAAXXZ PROC ; std::_Ref_count_obj2<std::filesystem::_Recursive_dir_enum_impl>::_Delete_this, COMDAT

; 2126 :         delete this;

	test	rcx, rcx
	je	SHORT $LN3@Delete_thi
	mov	rax, QWORD PTR [rcx]
	mov	edx, 1
	rex_jmp	QWORD PTR [rax+16]
$LN3@Delete_thi:

; 2127 :     }

	ret	0
?_Delete_this@?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@EEAAXXZ ENDP ; std::_Ref_count_obj2<std::filesystem::_Recursive_dir_enum_impl>::_Delete_this
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ?_Destroy@?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@EEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Destroy@?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@EEAAXXZ PROC ; std::_Ref_count_obj2<std::filesystem::_Recursive_dir_enum_impl>::_Destroy, COMDAT

; 2121 :     void _Destroy() noexcept override { // destroy managed resource

$LN27:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 2122 :         _Destroy_in_place(_Storage._Value);

	add	rcx, 88					; 00000058H
	call	??1?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEAA@XZ ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::~vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 605  :             __std_fs_directory_iterator_close(_Handle);

	mov	rcx, QWORD PTR [rbx+80]
	call	__std_fs_directory_iterator_close

; 638  :         ~path()                          = default;

	lea	rcx, QWORD PTR [rbx+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 2123 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	jmp	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
?_Destroy@?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@EEAAXXZ ENDP ; std::_Ref_count_obj2<std::filesystem::_Recursive_dir_enum_impl>::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??1?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@UEAA@XZ PROC ; std::_Ref_count_obj2<std::filesystem::_Recursive_dir_enum_impl>::~_Ref_count_obj2<std::filesystem::_Recursive_dir_enum_impl>, COMDAT

; 2108 :     ~_Ref_count_obj2() noexcept override { // TRANSITION, should be non-virtual

	lea	rax, OFFSET FLAT:??_7?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@6B@
	mov	QWORD PTR [rcx], rax

; 2109 :         // nothing to do, _Storage._Value was already destroyed in _Destroy
; 2110 : 
; 2111 :         // N4950 [class.dtor]/7:
; 2112 :         // "A defaulted destructor for a class X is defined as deleted if:
; 2113 :         // X is a union-like class that has a variant member with a non-trivial destructor"
; 2114 :     }

	ret	0
??1?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@UEAA@XZ ENDP ; std::_Ref_count_obj2<std::filesystem::_Recursive_dir_enum_impl>::~_Ref_count_obj2<std::filesystem::_Recursive_dir_enum_impl>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAAXPEBW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@Z
_TEXT	SEGMENT
this$ = 8
_It$ = 16
?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAAXPEBW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > >::_Seek_to, COMDAT

; 218  :         _Ptr = _Refancy<_Tptr>(const_cast<value_type*>(_It));

	mov	QWORD PTR [rcx], rdx

; 219  :     }

	ret	0
?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAAXPEBW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> > >::_Seek_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Xlength@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ PROC ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Xlength, COMDAT

; 2137 :     [[noreturn]] static void _Xlength() {

$LN4:
	sub	rsp, 40					; 00000028H

; 2138 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlength:
?_Xlength@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ ENDP ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Change_array@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K1@Z
_TEXT	SEGMENT
this$ = 64
_Newvec$ = 72
_Newsize$ = 80
_Newcapacity$ = 88
?_Change_array@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K1@Z PROC ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Change_array, COMDAT

; 2013 :     _CONSTEXPR20 void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN47:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 2014 :         // orphan all iterators, discard old array, acquire new array
; 2015 :         auto& _Al         = _Getal();
; 2016 :         auto& _My_data    = _Mypair._Myval2;
; 2017 :         pointer& _Myfirst = _My_data._Myfirst;
; 2018 :         pointer& _Mylast  = _My_data._Mylast;
; 2019 :         pointer& _Myend   = _My_data._Myend;
; 2020 : 
; 2021 :         _My_data._Orphan_all();
; 2022 : 
; 2023 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR [rcx]
	mov	r14, r9
	mov	r15, r8
	mov	rbp, rdx
	mov	rsi, rcx
	test	rbx, rbx
	je	SHORT $LN20@Change_arr
	mov	QWORD PTR [rsp+72], rdi

; 2024 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdi, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN6@Change_arr
$LL7@Change_arr:
	mov	rcx, rbx
	call	??1ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ
	add	rbx, 96					; 00000060H
	cmp	rbx, rdi
	jne	SHORT $LL7@Change_arr
$LN6@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rsi]
	mov	rdx, -6148914691236517205		; aaaaaaaaaaaaaaabH
	mov	rax, QWORD PTR [rsi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdi, QWORD PTR [rsp+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rax, rcx
	sar	rax, 5
	imul	rax, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*2]
	shl	rdx, 5

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN32@Change_arr

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN29@Change_arr

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN32@Change_arr:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN20@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2033 :     }

	mov	rbx, QWORD PTR [rsp+80]
	lea	rax, QWORD PTR [r15+r15*2]
	shl	rax, 5
	add	rax, rbp
	mov	QWORD PTR [rsi], rbp
	mov	QWORD PTR [rsi+8], rax
	lea	rax, QWORD PTR [r14+r14*2]
	shl	rax, 5
	add	rax, rbp
	mov	rbp, QWORD PTR [rsp+88]
	mov	QWORD PTR [rsi+16], rax
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rsi
	ret	0
$LN29@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN44@Change_arr:
?_Change_array@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K1@Z ENDP ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Calculate_growth@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$ = 16
?_Calculate_growth@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEBA_K_K@Z PROC ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Calculate_growth, COMDAT

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	r8, QWORD PTR [rcx+16]
	mov	rax, -6148914691236517205		; aaaaaaaaaaaaaaabH
	sub	r8, QWORD PTR [rcx]
	sar	r8, 5
	imul	r8, rax

; 1962 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1963 :         const size_type _Oldcapacity = capacity();
; 1964 :         const auto _Max              = max_size();
; 1965 : 
; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, 192153584101141162			; 02aaaaaaaaaaaaaaH
	mov	r9, r8
	mov	rcx, rax
	shr	r9, 1
	sub	rcx, r9
	cmp	r8, rcx
	ja	SHORT $LN1@Calculate_

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [r9+r8]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rax, rdx
	cmovb	rax, rdx
$LN1@Calculate_:

; 1973 :             return _Newsize; // geometric growth would be insufficient
; 1974 :         }
; 1975 : 
; 1976 :         return _Geometric; // geometric growth is sufficient
; 1977 :     }

	ret	0
?_Calculate_growth@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEBA_K_K@Z ENDP ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?max_size@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ PROC ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::max_size, COMDAT

; 1873 :         return (_STD min)(

	mov	rax, 192153584101141162			; 02aaaaaaaaaaaaaaH

; 1874 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1875 :     }

	ret	0
?max_size@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Clear_and_reserve_geometric@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 64
_Newsize$ = 72
?_Clear_and_reserve_geometric@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z PROC ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Clear_and_reserve_geometric, COMDAT

; 1646 :     _CONSTEXPR20 void _Clear_and_reserve_geometric(const size_type _Newsize) {

$LN61:
	push	rdi
	push	r14
	sub	rsp, 40					; 00000028H

; 1647 :         auto& _Al         = _Getal();
; 1648 :         auto& _My_data    = _Mypair._Myval2;
; 1649 :         pointer& _Myfirst = _My_data._Myfirst;
; 1650 :         pointer& _Mylast  = _My_data._Mylast;
; 1651 :         pointer& _Myend   = _My_data._Myend;
; 1652 : 
; 1653 : #if _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1654 :         _STL_INTERNAL_CHECK(_Newsize != 0);
; 1655 :         _Check_all_orphaned();
; 1656 : #endif // _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1657 : 
; 1658 :         if (_Newsize > max_size()) {

	mov	r14, 192153584101141162			; 02aaaaaaaaaaaaaaH
	mov	rdi, rcx
	cmp	rdx, r14
	ja	$LN59@Clear_and_
	mov	QWORD PTR [rsp+80], rbx

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, r14

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rbx, QWORD PTR [rcx]
	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, rbx
	mov	QWORD PTR [rsp+88], rbp
	sar	rcx, 5
	mov	rbp, -6148914691236517205		; aaaaaaaaaaaaaaabH
	imul	rcx, rbp

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	r8, rcx
	shr	r8, 1
	sub	rax, r8
	cmp	rcx, rax
	ja	SHORT $LN7@Clear_and_

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	r14, QWORD PTR [r8+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	r14, rdx
	cmovb	r14, rdx
$LN7@Clear_and_:

; 1660 :         }
; 1661 : 
; 1662 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1663 : 
; 1664 :         if (_Myfirst) { // destroy and deallocate old array

	test	rbx, rbx
	je	SHORT $LN3@Clear_and_
	mov	QWORD PTR [rsp+32], rsi

; 1665 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rsi, QWORD PTR [rdi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rsi
	je	SHORT $LN13@Clear_and_
$LL14@Clear_and_:
	mov	rcx, rbx
	call	??1ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ
	add	rbx, 96					; 00000060H
	cmp	rbx, rsi
	jne	SHORT $LL14@Clear_and_
$LN13@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1667 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rdi]
	mov	rax, QWORD PTR [rdi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rsi, QWORD PTR [rsp+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1667 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rax, rcx
	sar	rax, 5
	imul	rax, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*2]
	shl	rdx, 5

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN39@Clear_and_

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN36@Clear_and_

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN39@Clear_and_:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1669 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rdi], rax

; 1670 :             _Mylast  = nullptr;

	mov	QWORD PTR [rdi+8], rax

; 1671 :             _Myend   = nullptr;

	mov	QWORD PTR [rdi+16], rax
$LN3@Clear_and_:

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdx, r14
	call	?allocate@?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z ; std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>::allocate
	mov	rbx, QWORD PTR [rsp+80]

; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [r14+r14*2]
	mov	rbp, QWORD PTR [rsp+88]

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rdi], rax

; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	shl	rcx, 5
	add	rcx, rax
	mov	QWORD PTR [rdi+8], rax
	mov	QWORD PTR [rdi+16], rcx

; 1672 :         }
; 1673 : 
; 1674 :         _Buy_raw(_Newcapacity);
; 1675 :     }

	add	rsp, 40					; 00000028H
	pop	r14
	pop	rdi
	ret	0
$LN36@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN59@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1659 :             _Xlength();

	call	?_Xlength@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Xlength
	int	3
$LN57@Clear_and_:
?_Clear_and_reserve_geometric@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z ENDP ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Clear_and_reserve_geometric
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?allocate@?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z PROC ; std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>::allocate, COMDAT

; 972  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN32:
	sub	rsp, 40					; 00000028H

; 70   :         if (_Count > _Max_possible) {

	mov	rax, 192153584101141162			; 02aaaaaaaaaaaaaaH
	cmp	rdx, rax
	ja	SHORT $LN28@allocate

; 71   :             _Throw_bad_array_new_length(); // multiply overflow
; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	lea	rcx, QWORD PTR [rdx+rdx*2]
	shl	rcx, 5

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN9@allocate

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN28@allocate

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN18@allocate

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN18@allocate:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@allocate:

; 244  :     if (_Bytes != 0) {

	test	rcx, rcx
	je	SHORT $LN10@allocate

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H

; 87   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN10@allocate:

; 248  :     return nullptr;

	xor	eax, eax

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN28@allocate:

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN30@allocate:
?allocate@?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z ENDP ; std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?deallocate@?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAXQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAXQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z PROC ; std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>::deallocate, COMDAT

; 966  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN23:
	sub	rsp, 40					; 00000028H
	mov	rax, rdx

; 967  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 968  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [r8+r8*2]
	shl	rdx, 5

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN17@deallocate

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN14@deallocate

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN17@deallocate:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rax

; 970  :     }

	add	rsp, 40					; 00000028H

; 265  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN14@deallocate:

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN20@deallocate:
?deallocate@?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAXQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z ENDP ; std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Xlength@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ PROC ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Xlength, COMDAT

; 2137 :     [[noreturn]] static void _Xlength() {

$LN4:
	sub	rsp, 40					; 00000028H

; 2138 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlength:
?_Xlength@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ ENDP ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Change_array@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUInputParam@NodeDef@AINBNodeDefMgr@@_K1@Z
_TEXT	SEGMENT
this$ = 64
_Newvec$ = 72
_Newsize$ = 80
_Newcapacity$ = 88
?_Change_array@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUInputParam@NodeDef@AINBNodeDefMgr@@_K1@Z PROC ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Change_array, COMDAT

; 2013 :     _CONSTEXPR20 void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN47:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 2014 :         // orphan all iterators, discard old array, acquire new array
; 2015 :         auto& _Al         = _Getal();
; 2016 :         auto& _My_data    = _Mypair._Myval2;
; 2017 :         pointer& _Myfirst = _My_data._Myfirst;
; 2018 :         pointer& _Mylast  = _My_data._Mylast;
; 2019 :         pointer& _Myend   = _My_data._Myend;
; 2020 : 
; 2021 :         _My_data._Orphan_all();
; 2022 : 
; 2023 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR [rcx]
	mov	r14, r9
	mov	r15, r8
	mov	rbp, rdx
	mov	rsi, rcx
	test	rbx, rbx
	je	SHORT $LN20@Change_arr
	mov	QWORD PTR [rsp+72], rdi

; 2024 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdi, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN6@Change_arr
$LL7@Change_arr:
	mov	rcx, rbx
	call	??1InputParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ
	add	rbx, 144				; 00000090H
	cmp	rbx, rdi
	jne	SHORT $LL7@Change_arr
$LN6@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rsi]
	mov	rdx, -8198552921648689607		; 8e38e38e38e38e39H
	mov	rax, QWORD PTR [rsi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdi, QWORD PTR [rsp+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rax, rcx
	sar	rax, 4
	imul	rax, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*8]
	shl	rdx, 4

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN32@Change_arr

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN29@Change_arr

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN32@Change_arr:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN20@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2033 :     }

	mov	rbx, QWORD PTR [rsp+80]
	lea	rax, QWORD PTR [r15+r15*8]
	shl	rax, 4
	add	rax, rbp
	mov	QWORD PTR [rsi], rbp
	mov	QWORD PTR [rsi+8], rax
	lea	rax, QWORD PTR [r14+r14*8]
	shl	rax, 4
	add	rax, rbp
	mov	rbp, QWORD PTR [rsp+88]
	mov	QWORD PTR [rsi+16], rax
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rsi
	ret	0
$LN29@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN44@Change_arr:
?_Change_array@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUInputParam@NodeDef@AINBNodeDefMgr@@_K1@Z ENDP ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Calculate_growth@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$ = 16
?_Calculate_growth@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEBA_K_K@Z PROC ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Calculate_growth, COMDAT

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	r8, QWORD PTR [rcx+16]
	mov	rax, -8198552921648689607		; 8e38e38e38e38e39H
	sub	r8, QWORD PTR [rcx]
	sar	r8, 4
	imul	r8, rax

; 1962 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1963 :         const size_type _Oldcapacity = capacity();
; 1964 :         const auto _Max              = max_size();
; 1965 : 
; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, 128102389400760775			; 01c71c71c71c71c7H
	mov	r9, r8
	mov	rcx, rax
	shr	r9, 1
	sub	rcx, r9
	cmp	r8, rcx
	ja	SHORT $LN1@Calculate_

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [r9+r8]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rax, rdx
	cmovb	rax, rdx
$LN1@Calculate_:

; 1973 :             return _Newsize; // geometric growth would be insufficient
; 1974 :         }
; 1975 : 
; 1976 :         return _Geometric; // geometric growth is sufficient
; 1977 :     }

	ret	0
?_Calculate_growth@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEBA_K_K@Z ENDP ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?max_size@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ PROC ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::max_size, COMDAT

; 1873 :         return (_STD min)(

	mov	rax, 128102389400760775			; 01c71c71c71c71c7H

; 1874 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1875 :     }

	ret	0
?max_size@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Clear_and_reserve_geometric@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 64
_Newsize$ = 72
?_Clear_and_reserve_geometric@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z PROC ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Clear_and_reserve_geometric, COMDAT

; 1646 :     _CONSTEXPR20 void _Clear_and_reserve_geometric(const size_type _Newsize) {

$LN61:
	push	rsi
	push	rdi
	sub	rsp, 40					; 00000028H

; 1647 :         auto& _Al         = _Getal();
; 1648 :         auto& _My_data    = _Mypair._Myval2;
; 1649 :         pointer& _Myfirst = _My_data._Myfirst;
; 1650 :         pointer& _Mylast  = _My_data._Mylast;
; 1651 :         pointer& _Myend   = _My_data._Myend;
; 1652 : 
; 1653 : #if _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1654 :         _STL_INTERNAL_CHECK(_Newsize != 0);
; 1655 :         _Check_all_orphaned();
; 1656 : #endif // _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1657 : 
; 1658 :         if (_Newsize > max_size()) {

	mov	rsi, 128102389400760775			; 01c71c71c71c71c7H
	mov	rdi, rcx
	cmp	rdx, rsi
	ja	$LN59@Clear_and_
	mov	QWORD PTR [rsp+80], rbx

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, rsi

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rbx, QWORD PTR [rcx]
	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, rbx
	mov	QWORD PTR [rsp+32], r14
	sar	rcx, 4
	mov	r14, -8198552921648689607		; 8e38e38e38e38e39H
	imul	rcx, r14

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	r8, rcx
	shr	r8, 1
	sub	rax, r8
	cmp	rcx, rax
	ja	SHORT $LN7@Clear_and_

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rsi, QWORD PTR [r8+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rsi, rdx
	cmovb	rsi, rdx
$LN7@Clear_and_:

; 1660 :         }
; 1661 : 
; 1662 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1663 : 
; 1664 :         if (_Myfirst) { // destroy and deallocate old array

	test	rbx, rbx
	je	SHORT $LN3@Clear_and_
	mov	QWORD PTR [rsp+88], rbp

; 1665 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rbp, QWORD PTR [rdi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rbp
	je	SHORT $LN13@Clear_and_
$LL14@Clear_and_:
	mov	rcx, rbx
	call	??1InputParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ
	add	rbx, 144				; 00000090H
	cmp	rbx, rbp
	jne	SHORT $LL14@Clear_and_
$LN13@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1667 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rdi]
	mov	rax, QWORD PTR [rdi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rbp, QWORD PTR [rsp+88]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1667 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rax, rcx
	sar	rax, 4
	imul	rax, r14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*8]
	shl	rdx, 4

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN39@Clear_and_

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN36@Clear_and_

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN39@Clear_and_:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1669 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rdi], rax

; 1670 :             _Mylast  = nullptr;

	mov	QWORD PTR [rdi+8], rax

; 1671 :             _Myend   = nullptr;

	mov	QWORD PTR [rdi+16], rax
$LN3@Clear_and_:

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdx, rsi
	call	?allocate@?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAPEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z ; std::allocator<AINBNodeDefMgr::NodeDef::InputParam>::allocate
	mov	rbx, QWORD PTR [rsp+80]

; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [rsi+rsi*8]
	mov	r14, QWORD PTR [rsp+32]

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rdi], rax

; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	shl	rcx, 4
	add	rcx, rax
	mov	QWORD PTR [rdi+8], rax
	mov	QWORD PTR [rdi+16], rcx

; 1672 :         }
; 1673 : 
; 1674 :         _Buy_raw(_Newcapacity);
; 1675 :     }

	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rsi
	ret	0
$LN36@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN59@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1659 :             _Xlength();

	call	?_Xlength@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Xlength
	int	3
$LN57@Clear_and_:
?_Clear_and_reserve_geometric@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z ENDP ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Clear_and_reserve_geometric
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?allocate@?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAPEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAPEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z PROC ; std::allocator<AINBNodeDefMgr::NodeDef::InputParam>::allocate, COMDAT

; 972  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN32:
	sub	rsp, 40					; 00000028H

; 70   :         if (_Count > _Max_possible) {

	mov	rax, 128102389400760775			; 01c71c71c71c71c7H
	cmp	rdx, rax
	ja	SHORT $LN28@allocate

; 71   :             _Throw_bad_array_new_length(); // multiply overflow
; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	lea	rcx, QWORD PTR [rdx+rdx*8]
	shl	rcx, 4

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN9@allocate

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN28@allocate

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN18@allocate

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN18@allocate:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@allocate:

; 244  :     if (_Bytes != 0) {

	test	rcx, rcx
	je	SHORT $LN10@allocate

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H

; 87   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN10@allocate:

; 248  :     return nullptr;

	xor	eax, eax

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN28@allocate:

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN30@allocate:
?allocate@?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAPEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z ENDP ; std::allocator<AINBNodeDefMgr::NodeDef::InputParam>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?deallocate@?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAXQEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAXQEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z PROC ; std::allocator<AINBNodeDefMgr::NodeDef::InputParam>::deallocate, COMDAT

; 966  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN23:
	sub	rsp, 40					; 00000028H
	mov	rax, rdx

; 967  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 968  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [r8+r8*8]
	shl	rdx, 4

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN17@deallocate

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN14@deallocate

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN17@deallocate:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rax

; 970  :     }

	add	rsp, 40					; 00000028H

; 265  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN14@deallocate:

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN20@deallocate:
?deallocate@?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAXQEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z ENDP ; std::allocator<AINBNodeDefMgr::NodeDef::InputParam>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Xlength@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ PROC ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::_Xlength, COMDAT

; 2137 :     [[noreturn]] static void _Xlength() {

$LN4:
	sub	rsp, 40					; 00000028H

; 2138 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlength:
?_Xlength@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ ENDP ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Change_array@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUNodeDef@AINBNodeDefMgr@@_K1@Z
_TEXT	SEGMENT
this$dead$ = 48
_Newvec$ = 56
_Newsize$ = 64
_Newcapacity$ = 72
?_Change_array@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUNodeDef@AINBNodeDefMgr@@_K1@Z PROC ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::_Change_array, COMDAT

; 2013 :     _CONSTEXPR20 void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN48:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	r14
	sub	rsp, 32					; 00000020H

; 2014 :         // orphan all iterators, discard old array, acquire new array
; 2015 :         auto& _Al         = _Getal();
; 2016 :         auto& _My_data    = _Mypair._Myval2;
; 2017 :         pointer& _Myfirst = _My_data._Myfirst;
; 2018 :         pointer& _Mylast  = _My_data._Mylast;
; 2019 :         pointer& _Myend   = _My_data._Myend;
; 2020 : 
; 2021 :         _My_data._Orphan_all();
; 2022 : 
; 2023 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR ?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A
	mov	rbp, r9
	mov	r14, r8
	mov	rsi, rdx
	test	rbx, rbx
	je	$LN20@Change_arr
	mov	QWORD PTR [rsp+48], rdi

; 2024 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdi, QWORD PTR ?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A+8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN6@Change_arr
	npad	1
$LL7@Change_arr:
	mov	rcx, rbx
	call	??1NodeDef@AINBNodeDefMgr@@QEAA@XZ
	add	rbx, 248				; 000000f8H
	cmp	rbx, rdi
	jne	SHORT $LL7@Change_arr
	mov	rbx, QWORD PTR ?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A
$LN6@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR ?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A+16
	mov	rcx, -1190112520884487201		; ef7bdef7bdef7bdfH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdi, QWORD PTR [rsp+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rax, rbx
	sar	rax, 3
	imul	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	imul	rdx, rax, 248				; 000000f8H

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN32@Change_arr

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rax, QWORD PTR [rbx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rbx, rax

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rbx, -8
	cmp	rbx, 31
	ja	SHORT $LN29@Change_arr

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rbx, rax
$LN32@Change_arr:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
$LN20@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2033 :     }

	mov	rbx, QWORD PTR [rsp+56]
	imul	rax, r14, 248				; 000000f8H
	mov	QWORD PTR ?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A, rsi
	add	rax, rsi
	mov	QWORD PTR ?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A+8, rax
	imul	rax, rbp, 248				; 000000f8H
	mov	rbp, QWORD PTR [rsp+64]
	add	rax, rsi
	mov	rsi, QWORD PTR [rsp+72]
	mov	QWORD PTR ?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A+16, rax
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN29@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN45@Change_arr:
?_Change_array@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAUNodeDef@AINBNodeDefMgr@@_K1@Z ENDP ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Calculate_growth@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Newsize$ = 16
?_Calculate_growth@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEBA_K_K@Z PROC ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::_Calculate_growth, COMDAT

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	r8, QWORD PTR ?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A+16
	mov	rax, -1190112520884487201		; ef7bdef7bdef7bdfH
	sub	r8, QWORD PTR ?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A
	sar	r8, 3
	imul	r8, rax

; 1962 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1963 :         const size_type _Oldcapacity = capacity();
; 1964 :         const auto _Max              = max_size();
; 1965 : 
; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, 74382032555280450			; 0108421084210842H
	mov	r9, r8
	mov	rcx, rax
	shr	r9, 1
	sub	rcx, r9
	cmp	r8, rcx
	ja	SHORT $LN1@Calculate_

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [r9+r8]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rax, rdx
	cmovb	rax, rdx
$LN1@Calculate_:

; 1973 :             return _Newsize; // geometric growth would be insufficient
; 1974 :         }
; 1975 : 
; 1976 :         return _Geometric; // geometric growth is sufficient
; 1977 :     }

	ret	0
?_Calculate_growth@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEBA_K_K@Z ENDP ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?max_size@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ PROC ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::max_size, COMDAT

; 1873 :         return (_STD min)(

	mov	rax, 74382032555280450			; 0108421084210842H

; 1874 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1875 :     }

	ret	0
?max_size@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?allocate@?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@QEAAPEAUNodeDef@AINBNodeDefMgr@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@QEAAPEAUNodeDef@AINBNodeDefMgr@@_K@Z PROC ; std::allocator<AINBNodeDefMgr::NodeDef>::allocate, COMDAT

; 972  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN32:
	sub	rsp, 40					; 00000028H

; 70   :         if (_Count > _Max_possible) {

	mov	rax, 74382032555280450			; 0108421084210842H
	cmp	rdx, rax
	ja	SHORT $LN28@allocate

; 71   :             _Throw_bad_array_new_length(); // multiply overflow
; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	imul	rcx, rdx, 248				; 000000f8H

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN9@allocate

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN28@allocate

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN18@allocate

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN18@allocate:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@allocate:

; 244  :     if (_Bytes != 0) {

	test	rcx, rcx
	je	SHORT $LN10@allocate

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H

; 87   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN10@allocate:

; 248  :     return nullptr;

	xor	eax, eax

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN28@allocate:

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN30@allocate:
?allocate@?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@QEAAPEAUNodeDef@AINBNodeDefMgr@@_K@Z ENDP ; std::allocator<AINBNodeDefMgr::NodeDef>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Xlength@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@CAXXZ PROC ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::_Xlength, COMDAT

; 2137 :     [[noreturn]] static void _Xlength() {

$LN4:
	sub	rsp, 40					; 00000028H

; 2138 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlength:
?_Xlength@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@CAXXZ ENDP ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Change_array@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAXQEAU_Find_file_handle@filesystem@2@_K1@Z
_TEXT	SEGMENT
this$ = 64
_Newvec$ = 72
_Newsize$ = 80
_Newcapacity$ = 88
?_Change_array@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAXQEAU_Find_file_handle@filesystem@2@_K1@Z PROC ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::_Change_array, COMDAT

; 2013 :     _CONSTEXPR20 void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN49:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 2014 :         // orphan all iterators, discard old array, acquire new array
; 2015 :         auto& _Al         = _Getal();
; 2016 :         auto& _My_data    = _Mypair._Myval2;
; 2017 :         pointer& _Myfirst = _My_data._Myfirst;
; 2018 :         pointer& _Mylast  = _My_data._Mylast;
; 2019 :         pointer& _Myend   = _My_data._Myend;
; 2020 : 
; 2021 :         _My_data._Orphan_all();
; 2022 : 
; 2023 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR [rcx]
	mov	rbp, r9
	mov	r15, r8
	mov	r14, rdx
	mov	rsi, rcx
	test	rbx, rbx
	je	SHORT $LN22@Change_arr
	mov	QWORD PTR [rsp+72], rdi

; 2024 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdi, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN6@Change_arr
$LL7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 605  :             __std_fs_directory_iterator_close(_Handle);

	mov	rcx, QWORD PTR [rbx]
	call	__std_fs_directory_iterator_close
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 8
	cmp	rbx, rdi
	jne	SHORT $LL7@Change_arr
$LN6@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rsi]
	mov	rdx, QWORD PTR [rsi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdi, QWORD PTR [rsp+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN34@Change_arr

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN31@Change_arr

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN34@Change_arr:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN22@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2033 :     }

	mov	rbx, QWORD PTR [rsp+80]
	lea	rax, QWORD PTR [r14+r15*8]
	mov	QWORD PTR [rsi], r14
	mov	QWORD PTR [rsi+8], rax
	lea	rax, QWORD PTR [r14+rbp*8]
	mov	rbp, QWORD PTR [rsp+88]
	mov	QWORD PTR [rsi+16], rax
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rsi
	ret	0
$LN31@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN46@Change_arr:
?_Change_array@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEAAXQEAU_Find_file_handle@filesystem@2@_K1@Z ENDP ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Calculate_growth@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$ = 16
?_Calculate_growth@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEBA_K_K@Z PROC ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::_Calculate_growth, COMDAT

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	r8, QWORD PTR [rcx+16]

; 1962 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1963 :         const size_type _Oldcapacity = capacity();
; 1964 :         const auto _Max              = max_size();
; 1965 : 
; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sub	r8, QWORD PTR [rcx]

; 1962 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1963 :         const size_type _Oldcapacity = capacity();
; 1964 :         const auto _Max              = max_size();
; 1965 : 
; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rcx, rax

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	r8, 3

; 1962 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1963 :         const size_type _Oldcapacity = capacity();
; 1964 :         const auto _Max              = max_size();
; 1965 : 
; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	r9, r8
	shr	r9, 1
	sub	rcx, r9
	cmp	r8, rcx
	ja	SHORT $LN1@Calculate_

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [r9+r8]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rax, rdx
	cmovb	rax, rdx
$LN1@Calculate_:

; 1973 :             return _Newsize; // geometric growth would be insufficient
; 1974 :         }
; 1975 : 
; 1976 :         return _Geometric; // geometric growth is sufficient
; 1977 :     }

	ret	0
?_Calculate_growth@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEBA_K_K@Z ENDP ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?max_size@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEBA_KXZ PROC ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::max_size, COMDAT

; 1873 :         return (_STD min)(

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 1874 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1875 :     }

	ret	0
?max_size@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEBA_KXZ ENDP ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Find_file_handle@filesystem@std@@@std@@QEAAPEAU_Find_file_handle@filesystem@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@U_Find_file_handle@filesystem@std@@@std@@QEAAPEAU_Find_file_handle@filesystem@2@_K@Z PROC ; std::allocator<std::filesystem::_Find_file_handle>::allocate, COMDAT

; 972  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN32:
	sub	rsp, 40					; 00000028H

; 70   :         if (_Count > _Max_possible) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN28@allocate

; 71   :             _Throw_bad_array_new_length(); // multiply overflow
; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	lea	rcx, QWORD PTR [rdx*8]

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN9@allocate

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN28@allocate

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN18@allocate

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN18@allocate:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@allocate:

; 244  :     if (_Bytes != 0) {

	test	rcx, rcx
	je	SHORT $LN10@allocate

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H

; 87   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN10@allocate:

; 248  :     return nullptr;

	xor	eax, eax

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN28@allocate:

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN30@allocate:
?allocate@?$allocator@U_Find_file_handle@filesystem@std@@@std@@QEAAPEAU_Find_file_handle@filesystem@2@_K@Z ENDP ; std::allocator<std::filesystem::_Find_file_handle>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Orphan_range@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEBAXPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEBAXPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@0@Z PROC ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Orphan_range, COMDAT

; 2177 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

	ret	0
?_Orphan_range@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEBAXPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@0@Z ENDP ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Change_array@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_K1@Z
_TEXT	SEGMENT
this$ = 48
_Newvec$ = 56
_Newsize$ = 64
_Newcapacity$ = 72
?_Change_array@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_K1@Z PROC ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Change_array, COMDAT

; 2013 :     _CONSTEXPR20 void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN30:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rsi, r9

; 2014 :         // orphan all iterators, discard old array, acquire new array
; 2015 :         auto& _Al         = _Getal();
; 2016 :         auto& _My_data    = _Mypair._Myval2;
; 2017 :         pointer& _Myfirst = _My_data._Myfirst;
; 2018 :         pointer& _Mylast  = _My_data._Mylast;
; 2019 :         pointer& _Myend   = _My_data._Myend;
; 2020 : 
; 2021 :         _My_data._Orphan_all();
; 2022 : 
; 2023 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	mov	rbp, r8
	mov	rdi, rdx
	test	rcx, rcx
	je	SHORT $LN8@Change_arr

; 2024 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2025 :             _ASAN_VECTOR_REMOVE;
; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN20@Change_arr

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN17@Change_arr

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN20@Change_arr:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN8@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2030 :         _Mylast  = _Newvec + _Newsize;

	lea	rax, QWORD PTR [rdi+rbp]
	mov	QWORD PTR [rbx], rdi

; 2033 :     }

	mov	rbp, QWORD PTR [rsp+64]
	mov	QWORD PTR [rbx+8], rax
	lea	rax, QWORD PTR [rdi+rsi]
	mov	rsi, QWORD PTR [rsp+72]
	mov	QWORD PTR [rbx+16], rax
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN17@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN27@Change_arr:
?_Change_array@?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXQEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@_K1@Z ENDP ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Change_array@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXQEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K1@Z
_TEXT	SEGMENT
this$ = 64
_Newvec$ = 72
_Newsize$dead$ = 80
_Newcapacity$ = 88
?_Change_array@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXQEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K1@Z PROC ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Change_array, COMDAT

; 2013 :     _CONSTEXPR20 void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN49:
	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 2014 :         // orphan all iterators, discard old array, acquire new array
; 2015 :         auto& _Al         = _Getal();
; 2016 :         auto& _My_data    = _Mypair._Myval2;
; 2017 :         pointer& _Myfirst = _My_data._Myfirst;
; 2018 :         pointer& _Mylast  = _My_data._Mylast;
; 2019 :         pointer& _Myend   = _My_data._Myend;
; 2020 : 
; 2021 :         _My_data._Orphan_all();
; 2022 : 
; 2023 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR [rcx]
	mov	r15, r9
	mov	r14, rdx
	mov	rsi, rcx
	test	rbx, rbx
	je	SHORT $LN22@Change_arr
	mov	QWORD PTR [rsp+72], rdi

; 2024 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdi, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN6@Change_arr
	npad	3
$LL7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	mov	rcx, rbx
	call	?_Tidy@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 24
	cmp	rbx, rdi
	jne	SHORT $LL7@Change_arr
$LN6@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rsi]
	mov	rdx, -6148914691236517205		; aaaaaaaaaaaaaaabH
	mov	rax, QWORD PTR [rsi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdi, QWORD PTR [rsp+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rax, rcx
	sar	rax, 3
	imul	rax, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*2]
	shl	rdx, 3

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN34@Change_arr

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN31@Change_arr

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN34@Change_arr:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN22@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2033 :     }

	mov	rbx, QWORD PTR [rsp+80]
	lea	rax, QWORD PTR [r14+144]
	mov	QWORD PTR [rsi], r14
	mov	QWORD PTR [rsi+8], rax
	lea	rax, QWORD PTR [r15+r15*2]
	lea	rcx, QWORD PTR [r14+rax*8]
	mov	QWORD PTR [rsi+16], rcx
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rsi
	ret	0
$LN31@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN46@Change_arr:
?_Change_array@?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXQEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K1@Z ENDP ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Change_array@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXQEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K1@Z
_TEXT	SEGMENT
this$ = 64
_Newvec$ = 72
_Newsize$dead$ = 80
_Newcapacity$ = 88
?_Change_array@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXQEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K1@Z PROC ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Change_array, COMDAT

; 2013 :     _CONSTEXPR20 void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN49:
	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 2014 :         // orphan all iterators, discard old array, acquire new array
; 2015 :         auto& _Al         = _Getal();
; 2016 :         auto& _My_data    = _Mypair._Myval2;
; 2017 :         pointer& _Myfirst = _My_data._Myfirst;
; 2018 :         pointer& _Mylast  = _My_data._Mylast;
; 2019 :         pointer& _Myend   = _My_data._Myend;
; 2020 : 
; 2021 :         _My_data._Orphan_all();
; 2022 : 
; 2023 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR [rcx]
	mov	r15, r9
	mov	r14, rdx
	mov	rsi, rcx
	test	rbx, rbx
	je	SHORT $LN22@Change_arr
	mov	QWORD PTR [rsp+72], rdi

; 2024 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdi, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN6@Change_arr
	npad	3
$LL7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	mov	rcx, rbx
	call	?_Tidy@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 24
	cmp	rbx, rdi
	jne	SHORT $LL7@Change_arr
$LN6@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rsi]
	mov	rdx, -6148914691236517205		; aaaaaaaaaaaaaaabH
	mov	rax, QWORD PTR [rsi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdi, QWORD PTR [rsp+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rax, rcx
	sar	rax, 3
	imul	rax, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*2]
	shl	rdx, 3

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN34@Change_arr

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN31@Change_arr

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN34@Change_arr:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN22@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2033 :     }

	mov	rbx, QWORD PTR [rsp+80]
	lea	rax, QWORD PTR [r14+144]
	mov	QWORD PTR [rsi], r14
	mov	QWORD PTR [rsi+8], rax
	lea	rax, QWORD PTR [r15+r15*2]
	lea	rcx, QWORD PTR [r14+rax*8]
	mov	QWORD PTR [rsi+16], rcx
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rsi
	ret	0
$LN31@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN46@Change_arr:
?_Change_array@?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@AEAAXQEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@_K1@Z ENDP ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_G?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@UEAAPEAXI@Z PROC ; std::_Ref_count_obj2<std::filesystem::_Recursive_dir_enum_impl>::`scalar deleting destructor', COMDAT
$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H
	lea	rax, OFFSET FLAT:??_7?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@6B@
	mov	rbx, rcx
	mov	QWORD PTR [rcx], rax
	test	dl, 1
	je	SHORT $LN4@scalar
	mov	edx, 120				; 00000078H
	call	??3@YAXPEAX_K@Z				; operator delete
$LN4@scalar:
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_G?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@UEAAPEAXI@Z ENDP ; std::_Ref_count_obj2<std::filesystem::_Recursive_dir_enum_impl>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Buy_raw@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$ = 56
?_Buy_raw@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z PROC ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Buy_raw, COMDAT

; 1979 :     _CONSTEXPR20 void _Buy_raw(const size_type _Newcapacity) {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx

; 1980 :         // allocate array with _Newcapacity elements
; 1981 :         auto& _My_data    = _Mypair._Myval2;
; 1982 :         pointer& _Myfirst = _My_data._Myfirst;
; 1983 :         pointer& _Mylast  = _My_data._Mylast;
; 1984 :         pointer& _Myend   = _My_data._Myend;
; 1985 : 
; 1986 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 1987 :         _STL_INTERNAL_CHECK(0 < _Newcapacity && _Newcapacity <= max_size());
; 1988 : 
; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	call	?allocate@?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z ; std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>::allocate

; 1990 :         _Myfirst           = _Newvec;
; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rdx, QWORD PTR [rbx+rbx*2]
	mov	QWORD PTR [rdi], rax

; 1993 :     }

	mov	rbx, QWORD PTR [rsp+48]
	shl	rdx, 5
	add	rdx, rax
	mov	QWORD PTR [rdi+8], rax
	mov	QWORD PTR [rdi+16], rdx
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_Buy_raw@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z ENDP ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?capacity@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ PROC ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::capacity, COMDAT

; 1878 :         auto& _My_data = _Mypair._Myval2;
; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	mov	rcx, -6148914691236517205		; aaaaaaaaaaaaaaabH
	sar	rax, 5
	imul	rax, rcx

; 1880 :     }

	ret	0
?capacity@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SA_KAEBV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SA_KAEBV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::max_size, COMDAT

; 733  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 192153584101141162			; 02aaaaaaaaaaaaaaH

; 734  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SA_KAEBV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Buy_raw@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$ = 56
?_Buy_raw@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z PROC ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Buy_raw, COMDAT

; 1979 :     _CONSTEXPR20 void _Buy_raw(const size_type _Newcapacity) {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx

; 1980 :         // allocate array with _Newcapacity elements
; 1981 :         auto& _My_data    = _Mypair._Myval2;
; 1982 :         pointer& _Myfirst = _My_data._Myfirst;
; 1983 :         pointer& _Mylast  = _My_data._Mylast;
; 1984 :         pointer& _Myend   = _My_data._Myend;
; 1985 : 
; 1986 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 1987 :         _STL_INTERNAL_CHECK(0 < _Newcapacity && _Newcapacity <= max_size());
; 1988 : 
; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	call	?allocate@?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAPEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z ; std::allocator<AINBNodeDefMgr::NodeDef::InputParam>::allocate

; 1990 :         _Myfirst           = _Newvec;
; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rdx, QWORD PTR [rbx+rbx*8]
	mov	QWORD PTR [rdi], rax

; 1993 :     }

	mov	rbx, QWORD PTR [rsp+48]
	shl	rdx, 4
	add	rdx, rax
	mov	QWORD PTR [rdi+8], rax
	mov	QWORD PTR [rdi+16], rdx
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_Buy_raw@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z ENDP ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?capacity@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ PROC ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::capacity, COMDAT

; 1878 :         auto& _My_data = _Mypair._Myval2;
; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	mov	rcx, -8198552921648689607		; 8e38e38e38e38e39H
	sar	rax, 4
	imul	rax, rcx

; 1880 :     }

	ret	0
?capacity@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SA_KAEBV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SA_KAEBV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::max_size, COMDAT

; 733  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 128102389400760775			; 01c71c71c71c71c7H

; 734  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SA_KAEBV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Getal@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEBAAEBV?$allocator@UNodeDef@AINBNodeDefMgr@@@2@XZ
_TEXT	SEGMENT
this$dead$ = 8
?_Getal@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEBAAEBV?$allocator@UNodeDef@AINBNodeDefMgr@@@2@XZ PROC ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::_Getal, COMDAT

; 2185 :         return _Mypair._Get_first();

	lea	rax, OFFSET FLAT:?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A ; AINBNodeDefMgr::NodeDefinitions

; 2186 :     }

	ret	0
?_Getal@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@AEBAAEBV?$allocator@UNodeDef@AINBNodeDefMgr@@@2@XZ ENDP ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?capacity@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?capacity@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ PROC ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::capacity, COMDAT

; 1878 :         auto& _My_data = _Mypair._Myval2;
; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rax, QWORD PTR ?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A+16
	mov	rcx, -1190112520884487201		; ef7bdef7bdef7bdfH
	sub	rax, QWORD PTR ?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A
	sar	rax, 3
	imul	rax, rcx

; 1880 :     }

	ret	0
?capacity@?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<AINBNodeDefMgr::NodeDef,std::allocator<AINBNodeDefMgr::NodeDef> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@SA_KAEBV?$allocator@UNodeDef@AINBNodeDefMgr@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@SA_KAEBV?$allocator@UNodeDef@AINBNodeDefMgr@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef> >::max_size, COMDAT

; 733  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 74382032555280450			; 0108421084210842H

; 734  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@SA_KAEBV?$allocator@UNodeDef@AINBNodeDefMgr@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Getal@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEBAAEBV?$allocator@U_Find_file_handle@filesystem@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEBAAEBV?$allocator@U_Find_file_handle@filesystem@std@@@2@XZ PROC ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::_Getal, COMDAT

; 2185 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2186 :     }

	ret	0
?_Getal@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@AEBAAEBV?$allocator@U_Find_file_handle@filesystem@std@@@2@XZ ENDP ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?capacity@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEBA_KXZ PROC ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::capacity, COMDAT

; 1878 :         auto& _My_data = _Mypair._Myval2;
; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 1880 :     }

	ret	0
?capacity@?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEBA_KXZ ENDP ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@@std@@SA_KAEBV?$allocator@U_Find_file_handle@filesystem@std@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@@std@@SA_KAEBV?$allocator@U_Find_file_handle@filesystem@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::filesystem::_Find_file_handle> >::max_size, COMDAT

; 733  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 734  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@@std@@SA_KAEBV?$allocator@U_Find_file_handle@filesystem@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::filesystem::_Find_file_handle> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UNodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UNodeDef@AINBNodeDefMgr@@@2@XZ
_TEXT	SEGMENT
this$dead$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UNodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UNodeDef@AINBNodeDefMgr@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef> >,1>::_Get_first, COMDAT

; 1527 :         return *this;

	lea	rax, OFFSET FLAT:?NodeDefinitions@AINBNodeDefMgr@@3V?$vector@UNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@A ; AINBNodeDefMgr::NodeDefinitions

; 1528 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UNodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UNodeDef@AINBNodeDefMgr@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Find_file_handle@filesystem@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U_Find_file_handle@filesystem@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Find_file_handle@filesystem@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U_Find_file_handle@filesystem@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::filesystem::_Find_file_handle>,std::_Vector_val<std::_Simple_types<std::filesystem::_Find_file_handle> >,1>::_Get_first, COMDAT

; 1527 :         return *this;

	mov	rax, rcx

; 1528 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Find_file_handle@filesystem@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U_Find_file_handle@filesystem@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::filesystem::_Find_file_handle>,std::_Vector_val<std::_Simple_types<std::filesystem::_Find_file_handle> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEAV?$reverse_iterator@PEB_W@std@@@std@@YAAEAV?$reverse_iterator@PEB_W@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAV?$reverse_iterator@PEB_W@std@@@std@@YAAEAV?$reverse_iterator@PEB_W@0@AEAV10@@Z PROC ; std::forward<std::reverse_iterator<wchar_t const *> &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEAV?$reverse_iterator@PEB_W@std@@@std@@YAAEAV?$reverse_iterator@PEB_W@0@AEAV10@@Z ENDP ; std::forward<std::reverse_iterator<wchar_t const *> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono
;	COMDAT ??$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@0@AEBV?$allocator@D@0@@Z
_TEXT	SEGMENT
$T1 = 48
__$ReturnUdt$ = 96
_Code_page$ = 104
_Input$ = 112
_Al$dead$ = 120
??$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@0@AEBV?$allocator@D@0@@Z PROC ; std::_Convert_wide_to_narrow<std::char_traits<char>,std::allocator<char> >, COMDAT

; 61   :     const __std_code_page _Code_page, const wstring_view _Input, const _Alloc& _Al) {

$LN42:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 64					; 00000040H
	mov	r14d, edx
	mov	rbx, rcx
	xor	eax, eax
	mov	DWORD PTR $T1[rsp], eax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono

; 80   :     return _Output;

	mov	DWORD PTR $T1[rsp], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 1296 :         return _Mysize == 0;

	mov	rsi, QWORD PTR [r8+8]
	test	rsi, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono

; 64   :     if (!_Input.empty()) {

	je	SHORT $LN34@Convert_wi

; 65   :         if (_Input.size() > static_cast<size_t>(INT_MAX)) {

	cmp	rsi, 2147483647				; 7fffffffH
	ja	SHORT $LN38@Convert_wi

; 67   :         }
; 68   : 
; 69   :         const int _Len = _Check_convert_result(

	mov	rbp, QWORD PTR [r8]
	mov	DWORD PTR [rsp+32], eax
	xor	r9d, r9d
	mov	r8d, esi
	mov	rdx, rbp
	mov	ecx, r14d
	call	__std_fs_convert_wide_to_narrow
	mov	rdi, rax
	shr	rax, 32					; 00000020H
	test	eax, eax

; 52   :     if (_Result._Err != __std_win_error::_Success) {

	jne	SHORT $LN39@Convert_wi

; 70   :             __std_fs_convert_wide_to_narrow(_Code_page, _Input.data(), static_cast<int>(_Input.size()), nullptr, 0));
; 71   : 
; 72   :         _Output.resize(static_cast<size_t>(_Len));

	movsxd	rdx, edi
	mov	rcx, rbx
	call	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	r9, rbx

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rbx+24], 16

; 2227 :         if (_Large_string_engaged()) {

	jb	SHORT $LN29@Convert_wi

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r9, QWORD PTR [rbx]
$LN29@Convert_wi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono

; 76   :         (void) _Check_convert_result(__std_fs_convert_wide_to_narrow(

	mov	DWORD PTR [rsp+32], edi
	mov	r8d, esi
	mov	rdx, rbp
	mov	ecx, r14d
	call	__std_fs_convert_wide_to_narrow
	mov	rcx, rax
	shr	rax, 32					; 00000020H
	test	eax, eax

; 52   :     if (_Result._Err != __std_win_error::_Success) {

	jne	SHORT $LN40@Convert_wi
$LN34@Convert_wi:

; 80   :     return _Output;

	mov	rax, rbx

; 81   : }

	mov	rbx, QWORD PTR [rsp+104]
	mov	rbp, QWORD PTR [rsp+112]
	add	rsp, 64					; 00000040H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN40@Convert_wi:

; 53   :         _Throw_system_error_from_std_win_error(_Result._Err);

	shr	rcx, 32					; 00000020H
	call	?_Throw_system_error_from_std_win_error@std@@YAXW4__std_win_error@@@Z ; std::_Throw_system_error_from_std_win_error
	int	3
$LN38@Convert_wi:

; 66   :             _Throw_system_error(errc::invalid_argument);

	call	?_Throw_system_error@std@@YAXW4errc@1@@Z ; std::_Throw_system_error
	int	3
$LN39@Convert_wi:

; 53   :         _Throw_system_error_from_std_win_error(_Result._Err);

	shr	rdi, 32					; 00000020H
	mov	ecx, edi
	call	?_Throw_system_error_from_std_win_error@std@@YAXW4__std_win_error@@@Z ; std::_Throw_system_error_from_std_win_error
	int	3
$LN36@Convert_wi:
??$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@0@AEBV?$allocator@D@0@@Z ENDP ; std::_Convert_wide_to_narrow<std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
__$ReturnUdt$ = 96
_Code_page$ = 104
_Input$ = 112
_Al$dead$ = 120
?dtor$0@?0???$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@0@AEBV?$allocator@D@0@@Z@4HA PROC ; `std::_Convert_wide_to_narrow<std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN6@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN6@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@0@AEBV?$allocator@D@0@@Z@4HA ENDP ; `std::_Convert_wide_to_narrow<std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ??$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@U_Normal_conversion@01@@Z
_TEXT	SEGMENT
__$ReturnUdt$GSCopy$ = 40
__$ReturnUdt$ = 96
_Input$ = 104
__formal$dead$ = 112
??$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@U_Normal_conversion@01@@Z PROC ; std::filesystem::_Convert_stringoid_to_wide<std::filesystem::_Normal_conversion>, COMDAT

; 206  :     _NODISCARD wstring _Convert_stringoid_to_wide(const wstring_view _Input, _Conversion) {

$LN62:
	push	rbx
	push	rbp
	push	rsi
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2886 :         const basic_string_view<_Elem, _Traits> _As_view = _Right;

	mov	rbx, QWORD PTR [rdx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 206  :     _NODISCARD wstring _Convert_stringoid_to_wide(const wstring_view _Input, _Conversion) {

	xor	r15d, r15d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2886 :         const basic_string_view<_Elem, _Traits> _As_view = _Right;

	mov	r14, QWORD PTR [rdx]
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2620 :         if (_Count > max_size()) {

	mov	rbp, 9223372036854775806		; 7ffffffffffffffeH

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], r15

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], r15
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 206  :     _NODISCARD wstring _Convert_stringoid_to_wide(const wstring_view _Input, _Conversion) {

	mov	rsi, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2620 :         if (_Count > max_size()) {

	cmp	rbx, rbp
	ja	$LN60@Convert_st

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR [rcx+24], 7
	cmp	rbx, 8
	jae	SHORT $LN19@Convert_st

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR [rcx+16], rbx

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14
	add	rbx, rbx
	mov	r8, rbx
	call	memcpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 209  :         return wstring{_Input};

	mov	rax, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	WORD PTR [rbx+rsi], r15w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 210  :     }

	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN19@Convert_st:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rax, rbx
	mov	QWORD PTR [rsp+112], rdi
	or	rax, 7
	cmp	rax, rbp

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN29@Convert_st
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	mov	ecx, 10
	mov	rbp, rax
	cmp	rax, rcx
	cmovb	rbp, rcx
$LN29@Convert_st:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	rdx, QWORD PTR [rbp+1]
	call	?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z ; std::allocator<wchar_t>::allocate

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR [rsi+16], rbx

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14
	add	rbx, rbx

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR [rsi], rax

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rbx

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR [rsi+24], rbp

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rcx, rax

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdi, rax

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy

; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	mov	WORD PTR [rbx+rdi], r15w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 209  :         return wstring{_Input};

	mov	rax, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	mov	rdi, QWORD PTR [rsp+112]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 210  :     }

	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN60@Convert_st:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN58@Convert_st:
??$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@U_Normal_conversion@01@@Z ENDP ; std::filesystem::_Convert_stringoid_to_wide<std::filesystem::_Normal_conversion>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEBV?$allocator@_W@std@@@std@@YAAEBV?$allocator@_W@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$allocator@_W@std@@@std@@YAAEBV?$allocator@_W@0@AEBV10@@Z PROC ; std::forward<std::allocator<wchar_t> const &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEBV?$allocator@_W@std@@@std@@YAAEBV?$allocator@_W@0@AEBV10@@Z ENDP ; std::forward<std::allocator<wchar_t> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@U_Creator@_Dir_enum_impl@filesystem@std@@@std@@YA$$QEAU_Creator@_Dir_enum_impl@filesystem@0@AEAU1230@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@U_Creator@_Dir_enum_impl@filesystem@std@@@std@@YA$$QEAU_Creator@_Dir_enum_impl@filesystem@0@AEAU1230@@Z PROC ; std::forward<std::filesystem::_Dir_enum_impl::_Creator>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@U_Creator@_Dir_enum_impl@filesystem@std@@@std@@YA$$QEAU_Creator@_Dir_enum_impl@filesystem@0@AEAU1230@@Z ENDP ; std::forward<std::filesystem::_Dir_enum_impl::_Creator>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEBW4directory_options@filesystem@std@@@std@@YAAEBW4directory_options@filesystem@0@AEBW4120@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBW4directory_options@filesystem@std@@@std@@YAAEBW4directory_options@filesystem@0@AEBW4120@@Z PROC ; std::forward<enum std::filesystem::directory_options const &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEBW4directory_options@filesystem@std@@@std@@YAAEBW4directory_options@filesystem@0@AEBW4120@@Z ENDP ; std::forward<enum std::filesystem::directory_options const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??$?0U_Creator@_Dir_enum_impl@filesystem@std@@AEBW4directory_options@23@@?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAA@$$QEAU_Creator@_Dir_enum_impl@filesystem@1@AEBW4directory_options@41@@Z
_TEXT	SEGMENT
this$ = 48
<_Args_0>$ = 56
<_Args_1>$ = 64
??$?0U_Creator@_Dir_enum_impl@filesystem@std@@AEBW4directory_options@23@@?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAA@$$QEAU_Creator@_Dir_enum_impl@filesystem@1@AEBW4directory_options@41@@Z PROC ; std::_Ref_count_obj2<std::filesystem::_Recursive_dir_enum_impl>::_Ref_count_obj2<std::filesystem::_Recursive_dir_enum_impl><std::filesystem::_Dir_enum_impl::_Creator,enum std::filesystem::directory_options const &>, COMDAT

; 2096 :     explicit _Ref_count_obj2(_Types&&... _Args) : _Ref_count_base() {

$LN33:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1137 :     _Atomic_counter_t _Uses  = 1;

	mov	DWORD PTR [rcx+8], 1

; 2096 :     explicit _Ref_count_obj2(_Types&&... _Args) : _Ref_count_base() {

	lea	rax, OFFSET FLAT:??_7?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@6B@
	mov	QWORD PTR [rcx], rax
	mov	rsi, rcx

; 1138 :     _Atomic_counter_t _Weaks = 1;

	mov	DWORD PTR [rcx+12], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2829 :             : _Dir_enum_impl(_STD move(_Create_data)), _Options(_Options_arg) {}

	add	rcx, 16
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 2104 :             _STD _Construct_in_place(_Storage._Value, _STD forward<_Types>(_Args)...);

	mov	ebx, DWORD PTR [r8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2829 :             : _Dir_enum_impl(_STD move(_Create_data)), _Options(_Options_arg) {}

	call	??0_Dir_enum_impl@filesystem@std@@QEAA@$$QEAU_Creator@012@W4directory_options@12@@Z ; std::filesystem::_Dir_enum_impl::_Dir_enum_impl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 2106 :     }

	xor	eax, eax
	mov	QWORD PTR [rsi+88], rax
	mov	QWORD PTR [rsi+96], rax
	mov	QWORD PTR [rsi+104], rax
	mov	rax, rsi
	mov	DWORD PTR [rsi+112], ebx
	mov	BYTE PTR [rsi+116], 1
	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$?0U_Creator@_Dir_enum_impl@filesystem@std@@AEBW4directory_options@23@@?$_Ref_count_obj2@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAA@$$QEAU_Creator@_Dir_enum_impl@filesystem@1@AEBW4directory_options@41@@Z ENDP ; std::_Ref_count_obj2<std::filesystem::_Recursive_dir_enum_impl>::_Ref_count_obj2<std::filesystem::_Recursive_dir_enum_impl><std::filesystem::_Dir_enum_impl::_Creator,enum std::filesystem::directory_options const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@U_Recursive_dir_enum_impl@filesystem@std@@@std@@YAPEAU_Recursive_dir_enum_impl@filesystem@0@AEAU120@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@U_Recursive_dir_enum_impl@filesystem@std@@@std@@YAPEAU_Recursive_dir_enum_impl@filesystem@0@AEAU120@@Z PROC ; std::addressof<std::filesystem::_Recursive_dir_enum_impl>, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@U_Recursive_dir_enum_impl@filesystem@std@@@std@@YAPEAU_Recursive_dir_enum_impl@filesystem@0@AEAU120@@Z ENDP ; std::addressof<std::filesystem::_Recursive_dir_enum_impl>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??$_Set_ptr_rep_and_enable_shared@U_Recursive_dir_enum_impl@filesystem@std@@@?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@AEAAXQEAU_Recursive_dir_enum_impl@filesystem@1@QEAV_Ref_count_base@1@@Z
_TEXT	SEGMENT
this$ = 8
_Px$ = 16
_Rx$ = 24
??$_Set_ptr_rep_and_enable_shared@U_Recursive_dir_enum_impl@filesystem@std@@@?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@AEAAXQEAU_Recursive_dir_enum_impl@filesystem@1@QEAV_Ref_count_base@1@@Z PROC ; std::shared_ptr<std::filesystem::_Recursive_dir_enum_impl>::_Set_ptr_rep_and_enable_shared<std::filesystem::_Recursive_dir_enum_impl>, COMDAT

; 1855 :         this->_Ptr = _Px;

	mov	QWORD PTR [rcx], rdx

; 1856 :         this->_Rep = _Rx;

	mov	QWORD PTR [rcx+8], r8

; 1857 :         if constexpr (conjunction_v<negation<is_array<_Ty>>, negation<is_volatile<_Ux>>, _Can_enable_shared<_Ux>>) {
; 1858 :             if (_Px && _Px->_Wptr.expired()) {
; 1859 :                 _Px->_Wptr = shared_ptr<remove_cv_t<_Ux>>(*this, const_cast<remove_cv_t<_Ux>*>(_Px));
; 1860 :             }
; 1861 :         }
; 1862 :     }

	ret	0
??$_Set_ptr_rep_and_enable_shared@U_Recursive_dir_enum_impl@filesystem@std@@@?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@AEAAXQEAU_Recursive_dir_enum_impl@filesystem@1@QEAV_Ref_count_base@1@@Z ENDP ; std::shared_ptr<std::filesystem::_Recursive_dir_enum_impl>::_Set_ptr_rep_and_enable_shared<std::filesystem::_Recursive_dir_enum_impl>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@AEAPEAW4123@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@AEAPEAW4123@@Z PROC ; std::forward<enum AINBNodeDefMgr::NodeDef::CategoryEnum *>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@AEAPEAW4123@@Z ENDP ; std::forward<enum AINBNodeDefMgr::NodeDef::CategoryEnum *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
;	COMDAT ??$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@DU?$char_traits@D@std@@@1@U_Normal_conversion@01@@Z
_TEXT	SEGMENT
$T1 = 48
__$ReturnUdt$GSCopy$ = 56
__$ReturnUdt$ = 96
_Input$ = 104
__formal$dead$ = 112
??$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@DU?$char_traits@D@std@@@1@U_Normal_conversion@01@@Z PROC ; std::filesystem::_Convert_stringoid_to_wide<std::filesystem::_Normal_conversion>, COMDAT

; 195  :     _NODISCARD wstring _Convert_stringoid_to_wide(const string_view _Input, _Conversion) {

$LN47:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 64					; 00000040H
	mov	rbx, rdx
	mov	rdi, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
	xor	ebp, ebp
	mov	DWORD PTR $T1[rsp], ebp

; 199  :             return _Convert_narrow_to_wide(__std_fs_code_page(), _Input);

	call	__std_fs_code_page
	mov	r14d, eax
	movaps	xmm1, XMMWORD PTR [rbx]
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rdi], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], rbp

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdi+24], 7

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	WORD PTR [rdi], bp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 58   :         return _Output;

	mov	DWORD PTR $T1[rsp], 2

; 44   :         if (!_Input.empty()) {

	movdqa	xmm0, xmm1
	psrldq	xmm0, 8
	movq	rsi, xmm0
	test	rsi, rsi
	je	SHORT $LN38@Convert_st

; 45   :             if (_Input.size() > static_cast<size_t>(INT_MAX)) {

	cmp	rsi, 2147483647				; 7fffffffH
	ja	SHORT $LN43@Convert_st

; 47   :             }
; 48   : 
; 49   :             const int _Len = _Check_convert_result(__std_fs_convert_narrow_to_wide(

	mov	DWORD PTR [rsp+32], ebp
	xor	r9d, r9d
	mov	r8d, esi
	movq	rbp, xmm1
	mov	rdx, rbp
	mov	ecx, eax
	call	__std_fs_convert_narrow_to_wide
	mov	rbx, rax
	shr	rax, 32					; 00000020H
	test	eax, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono

; 52   :     if (_Result._Err != __std_win_error::_Success) {

	jne	SHORT $LN44@Convert_st
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 52   :             _Output.resize(static_cast<size_t>(_Len));

	movsxd	rdx, ebx
	mov	rcx, rdi
	call	?resize@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::resize
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	r9, rdi

; 2227 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rdi+24], 8
	jb	SHORT $LN33@Convert_st

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r9, QWORD PTR [rdi]
$LN33@Convert_st:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 54   :             (void) _Check_convert_result(__std_fs_convert_narrow_to_wide(

	mov	DWORD PTR [rsp+32], ebx
	mov	r8d, esi
	mov	rdx, rbp
	mov	ecx, r14d
	call	__std_fs_convert_narrow_to_wide
	mov	rcx, rax
	shr	rax, 32					; 00000020H
	test	eax, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono

; 52   :     if (_Result._Err != __std_win_error::_Success) {

	jne	SHORT $LN45@Convert_st
$LN38@Convert_st:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 199  :             return _Convert_narrow_to_wide(__std_fs_code_page(), _Input);

	mov	rax, rdi

; 203  :     }

	mov	rbx, QWORD PTR [rsp+112]
	mov	rbp, QWORD PTR [rsp+120]
	add	rsp, 64					; 00000040H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN45@Convert_st:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono

; 53   :         _Throw_system_error_from_std_win_error(_Result._Err);

	shr	rcx, 32					; 00000020H
	call	?_Throw_system_error_from_std_win_error@std@@YAXW4__std_win_error@@@Z ; std::_Throw_system_error_from_std_win_error
	int	3
$LN43@Convert_st:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 46   :                 _Throw_system_error(errc::invalid_argument);

	call	?_Throw_system_error@std@@YAXW4errc@1@@Z ; std::_Throw_system_error
	int	3
$LN44@Convert_st:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono

; 53   :         _Throw_system_error_from_std_win_error(_Result._Err);

	shr	rbx, 32					; 00000020H
	mov	ecx, ebx
	call	?_Throw_system_error_from_std_win_error@std@@YAXW4__std_win_error@@@Z ; std::_Throw_system_error_from_std_win_error
	int	3
$LN41@Convert_st:
??$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@DU?$char_traits@D@std@@@1@U_Normal_conversion@01@@Z ENDP ; std::filesystem::_Convert_stringoid_to_wide<std::filesystem::_Normal_conversion>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
__$ReturnUdt$GSCopy$ = 56
__$ReturnUdt$ = 96
_Input$ = 104
__formal$dead$ = 112
?dtor$1@?0???$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@DU?$char_traits@D@std@@@1@U_Normal_conversion@01@@Z@4HA PROC ; `std::filesystem::_Convert_stringoid_to_wide<std::filesystem::_Normal_conversion>'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN10@dtor$1
	and	DWORD PTR $T1[rbp], -3
	mov	rcx, QWORD PTR __$ReturnUdt$GSCopy$[rbp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
$LN10@dtor$1:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@DU?$char_traits@D@std@@@1@U_Normal_conversion@01@@Z@4HA ENDP ; `std::filesystem::_Convert_stringoid_to_wide<std::filesystem::_Normal_conversion>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Unfancy@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@@Z PROC ; std::_Unfancy<AINBNodeDefMgr::NodeDef::ImmediateParam>, COMDAT

; 37   :     return _Ptr;

	mov	rax, rcx

; 38   : }

	ret	0
??$_Unfancy@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@@Z ENDP ; std::_Unfancy<AINBNodeDefMgr::NodeDef::ImmediateParam>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$destroy@UImmediateParam@NodeDef@AINBNodeDefMgr@@@?$_Default_allocator_traits@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@1@QEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$destroy@UImmediateParam@NodeDef@AINBNodeDefMgr@@@?$_Default_allocator_traits@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@1@QEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z PROC ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::destroy<AINBNodeDefMgr::NodeDef::ImmediateParam>, COMDAT

; 724  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

	mov	rcx, rdx
	jmp	??1ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ
??$destroy@UImmediateParam@NodeDef@AINBNodeDefMgr@@@?$_Default_allocator_traits@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@1@QEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::destroy<AINBNodeDefMgr::NodeDef::ImmediateParam>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@YA?A_TAEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@YA?A_TAEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z PROC ; std::_Get_unwrapped<AINBNodeDefMgr::NodeDef::ImmediateParam * const &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@YA?A_TAEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z ENDP ; std::_Get_unwrapped<AINBNodeDefMgr::NodeDef::ImmediateParam * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@0PEAU123@AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z
_TEXT	SEGMENT
_First$ = 16
_Last$ = 24
_Dest$ = 32
_Al$dead$ = 40
??$_Uninitialized_move@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@0PEAU123@AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z PROC ; std::_Uninitialized_move<AINBNodeDefMgr::NodeDef::ImmediateParam *,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >, COMDAT

; 1927 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN138:
	push	rbx
	mov	r11, r8
	mov	rbx, rdx

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, rdx
	je	$LN133@Uninitiali
	mov	r10, r11
	mov	QWORD PTR [rsp+24], rdi
	sub	r10, rcx
	lea	r8, QWORD PTR [rcx+88]
	xor	edi, edi
$LL4@Uninitiali:
	xorps	xmm0, xmm0

; 1803 :         ++_Last;

	lea	r8, QWORD PTR [r8+96]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [r11], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [r10+r8-168], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [r10+r8-160], rdi

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r8-184]
	movups	XMMWORD PTR [r11], xmm0
	movups	xmm1, XMMWORD PTR [r8-168]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [r11+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [r8-168], rdi

; 1803 :         ++_Last;

	add	r11, 96					; 00000060H

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [r8-160], 15
	mov	BYTE PTR [r8-184], dil
	mov	eax, DWORD PTR [r8-152]
	mov	DWORD PTR [r10+r8-152], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [r10+r8-144], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [r10+r8-128], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [r10+r8-120], rdi

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r8-144]
	movups	XMMWORD PTR [r10+r8-144], xmm0
	movups	xmm1, XMMWORD PTR [r8-128]
	movups	XMMWORD PTR [r10+r8-128], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 697  :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal()),

	mov	QWORD PTR [r8-128], rdi
	mov	QWORD PTR [r8-120], 15
	mov	BYTE PTR [r8-144], dil
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [r8-112]
	mov	r9, QWORD PTR [r8-96]
	mov	rdx, QWORD PTR [r8-104]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8-96], rdi
	mov	QWORD PTR [r8-104], rdi
	mov	QWORD PTR [r8-112], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r10+r8-112], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	lea	rcx, QWORD PTR [r8-88]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r10+r8-104], rdx
	mov	QWORD PTR [r10+r8-96], r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, rbx
	jne	$LL4@Uninitiali
	mov	rdi, QWORD PTR [rsp+24]
$LN133@Uninitiali:

; 1946 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1947 :     }
; 1948 : 
; 1949 :     return _Backout._Release();
; 1950 : }

	mov	rax, r11
	pop	rbx
	ret	0
??$_Uninitialized_move@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@0PEAU123@AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z ENDP ; std::_Uninitialized_move<AINBNodeDefMgr::NodeDef::ImmediateParam *,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAXXZ PROC ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Emplace_back<>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rcx+8]
	xor	edx, edx
	xorps	xmm0, xmm0
	xorps	xmm1, xmm1
	mov	QWORD PTR [rax+32], rdx
	movups	XMMWORD PTR [rax+56], xmm0
	movups	XMMWORD PTR [rax+80], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rax], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rax+16], rdx

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rax+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rax], dl

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rax+40], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rax+56], rdx

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rax+64], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rax+40], dl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rax+72], rdx
	mov	QWORD PTR [rax+80], rdx
	mov	QWORD PTR [rax+88], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rcx+8], 96			; 00000060H

; 1804 :     }

	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAXXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@UImmediateParam@NodeDef@AINBNodeDefMgr@@U123@@?$_Default_allocator_traits@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@1@QEAUImmediateParam@NodeDef@AINBNodeDefMgr@@$$QEAU345@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@UImmediateParam@NodeDef@AINBNodeDefMgr@@U123@@?$_Default_allocator_traits@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@1@QEAUImmediateParam@NodeDef@AINBNodeDefMgr@@$$QEAU345@@Z PROC ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::construct<AINBNodeDefMgr::NodeDef::ImmediateParam,AINBNodeDefMgr::NodeDef::ImmediateParam>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	r10d, r10d
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rdx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rdx+16], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 715  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

	mov	r9, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rdx+24], r10

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [rdx], xmm0
	movups	xmm1, XMMWORD PTR [r8+16]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rdx+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [r8+16], r10
	mov	QWORD PTR [r8+24], 15
	mov	BYTE PTR [r8], r10b
	mov	eax, DWORD PTR [r8+32]
	mov	DWORD PTR [rdx+32], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rdx+40], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rdx+56], r10

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rdx+64], r10

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r8+40]
	movups	XMMWORD PTR [rdx+40], xmm0
	movups	xmm1, XMMWORD PTR [r8+56]
	movups	XMMWORD PTR [rdx+56], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 697  :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal()),

	mov	QWORD PTR [r8+56], r10
	mov	QWORD PTR [r8+64], 15
	mov	BYTE PTR [r8+40], r10b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [r8+88]
	mov	rcx, QWORD PTR [r8+80]
	mov	rax, QWORD PTR [r8+72]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8+88], r10
	mov	QWORD PTR [r8+80], r10
	mov	QWORD PTR [r8+72], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r9+72], rax
	mov	QWORD PTR [r9+80], rcx
	mov	QWORD PTR [r9+88], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@UImmediateParam@NodeDef@AINBNodeDefMgr@@U123@@?$_Default_allocator_traits@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@1@QEAUImmediateParam@NodeDef@AINBNodeDefMgr@@$$QEAU345@@Z ENDP ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::construct<AINBNodeDefMgr::NodeDef::ImmediateParam,AINBNodeDefMgr::NodeDef::ImmediateParam>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@QEAAXXZ PROC ; std::_Uninitialized_backout_al<std::allocator<AINBFile::OutputEntry> >::_Emplace_back<>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rcx+8]
	xor	edx, edx
	xorps	xmm0, xmm0
	mov	DWORD PTR [rax+33], edx
	mov	WORD PTR [rax+37], dx
	mov	BYTE PTR [rax+39], dl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rax], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rax+16], rdx

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rax+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rax], dl
	mov	BYTE PTR [rax+32], dl

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rax+40], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rax+56], rdx

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rax+64], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rax+40], dl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rcx+8], 72			; 00000048H

; 1804 :     }

	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@QEAAXXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<AINBFile::OutputEntry> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Unfancy@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@@Z PROC ; std::_Unfancy<AINBNodeDefMgr::NodeDef::InputParam>, COMDAT

; 37   :     return _Ptr;

	mov	rax, rcx

; 38   : }

	ret	0
??$_Unfancy@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@@Z ENDP ; std::_Unfancy<AINBNodeDefMgr::NodeDef::InputParam>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$destroy@UInputParam@NodeDef@AINBNodeDefMgr@@@?$_Default_allocator_traits@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@1@QEAUInputParam@NodeDef@AINBNodeDefMgr@@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$destroy@UInputParam@NodeDef@AINBNodeDefMgr@@@?$_Default_allocator_traits@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@1@QEAUInputParam@NodeDef@AINBNodeDefMgr@@@Z PROC ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::destroy<AINBNodeDefMgr::NodeDef::InputParam>, COMDAT

; 724  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

	mov	rcx, rdx
	jmp	??1InputParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ
??$destroy@UInputParam@NodeDef@AINBNodeDefMgr@@@?$_Default_allocator_traits@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@1@QEAUInputParam@NodeDef@AINBNodeDefMgr@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::destroy<AINBNodeDefMgr::NodeDef::InputParam>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@@std@@YA?A_TAEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@@std@@YA?A_TAEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@@Z PROC ; std::_Get_unwrapped<AINBNodeDefMgr::NodeDef::InputParam * const &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@@std@@YA?A_TAEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@@Z ENDP ; std::_Get_unwrapped<AINBNodeDefMgr::NodeDef::InputParam * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAUInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@QEAU123@0PEAU123@AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$dead$ = 72
??$_Uninitialized_move@PEAUInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@QEAU123@0PEAU123@AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z PROC ; std::_Uninitialized_move<AINBNodeDefMgr::NodeDef::InputParam *,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >, COMDAT

; 1927 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN138:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	r11, r8
	mov	rbx, rdx

; 1928 :     // move [_First, _Last) to raw _Dest, using _Al
; 1929 :     // note: only called internally from elsewhere in the STL
; 1930 :     using _Ptrval     = typename _Alloc::value_type*;
; 1931 :     auto _UFirst      = _Get_unwrapped(_First);
; 1932 :     const auto _ULast = _Get_unwrapped(_Last);
; 1933 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1934 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1935 : #if _HAS_CXX20
; 1936 :         if (!_STD is_constant_evaluated())
; 1937 : #endif // _HAS_CXX20
; 1938 :         {
; 1939 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1940 :             return _Dest + (_ULast - _UFirst);
; 1941 :         }
; 1942 :     }
; 1943 : 
; 1944 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, rdx
	je	$LN133@Uninitiali
	mov	r10, r8
	mov	QWORD PTR [rsp+56], rdi
	sub	r10, rcx
	lea	r9, QWORD PTR [rcx+80]
	xor	edi, edi
	npad	10
$LL4@Uninitiali:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [r11], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [r10+r9-64], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [r10+r9-56], rdi

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r9-80]
	movups	XMMWORD PTR [r11], xmm0
	movups	xmm1, XMMWORD PTR [r9-64]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [r11+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [r9-64], rdi
	mov	QWORD PTR [r9-56], 15
	mov	BYTE PTR [r9-80], dil
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [r10+r9-48], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [r10+r9-32], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [r10+r9-24], rdi

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r9-48]
	movups	XMMWORD PTR [r10+r9-48], xmm0
	movups	xmm1, XMMWORD PTR [r9-32]
	movups	XMMWORD PTR [r10+r9-32], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 697  :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal()),

	mov	QWORD PTR [r9-32], rdi
	mov	QWORD PTR [r9-24], 15
	mov	BYTE PTR [r9-48], dil
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [r9]
	mov	rcx, QWORD PTR [r9-8]
	mov	rax, QWORD PTR [r9-16]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r9], rdi
	mov	QWORD PTR [r9-8], rdi
	mov	QWORD PTR [r9-16], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r10+r9-8], rcx
	lea	rcx, QWORD PTR [r10+8]
	mov	QWORD PTR [r10+r9], rdx
	add	rcx, r9
	lea	rdx, QWORD PTR [r9+8]
	mov	QWORD PTR [r10+r9-16], rax
	call	??0?$variant@I_NMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VVector3F@@@std@@QEAA@$$QEAV01@@Z
	mov	ecx, DWORD PTR [r9+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	r11, 144				; 00000090H
	mov	DWORD PTR [r10+r9+48], ecx
	movzx	ecx, BYTE PTR [r9+52]
	mov	BYTE PTR [r10+r9+52], cl
	mov	ecx, DWORD PTR [r9+56]
	mov	DWORD PTR [r10+r9+56], ecx
	add	r9, 144					; 00000090H

; 1928 :     // move [_First, _Last) to raw _Dest, using _Al
; 1929 :     // note: only called internally from elsewhere in the STL
; 1930 :     using _Ptrval     = typename _Alloc::value_type*;
; 1931 :     auto _UFirst      = _Get_unwrapped(_First);
; 1932 :     const auto _ULast = _Get_unwrapped(_Last);
; 1933 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1934 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1935 : #if _HAS_CXX20
; 1936 :         if (!_STD is_constant_evaluated())
; 1937 : #endif // _HAS_CXX20
; 1938 :         {
; 1939 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1940 :             return _Dest + (_ULast - _UFirst);
; 1941 :         }
; 1942 :     }
; 1943 : 
; 1944 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	lea	rcx, QWORD PTR [r9-80]
	cmp	rcx, rbx
	jne	$LL4@Uninitiali
	mov	rdi, QWORD PTR [rsp+56]
$LN133@Uninitiali:

; 1946 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1947 :     }
; 1948 : 
; 1949 :     return _Backout._Release();
; 1950 : }

	mov	rax, r11
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Uninitialized_move@PEAUInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@QEAU123@0PEAU123@AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z ENDP ; std::_Uninitialized_move<AINBNodeDefMgr::NodeDef::InputParam *,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAXXZ PROC ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Emplace_back<>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rcx+8]
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4821 :         _My_data._Mysize = 0;

	xor	edx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	XMMWORD PTR [rax], xmm0
	movups	XMMWORD PTR [rax+16], xmm0
	movups	XMMWORD PTR [rax+32], xmm0
	movups	XMMWORD PTR [rax+48], xmm0
	movups	XMMWORD PTR [rax+64], xmm0
	movups	XMMWORD PTR [rax+80], xmm0
	movups	XMMWORD PTR [rax+96], xmm0
	movups	XMMWORD PTR [rax+112], xmm0
	movups	XMMWORD PTR [rax+128], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rax+24], 15

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rax+48], rdx

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rax+56], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rax+32], dl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rax+64], rdx
	mov	QWORD PTR [rax+72], rdx
	mov	QWORD PTR [rax+80], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	mov	DWORD PTR [rax+88], edx

; 795  :           _Which{static_cast<_Index_t>(_Idx)} { // initialize alternative _Idx from _Args...

	mov	BYTE PTR [rax+120], dl
	mov	BYTE PTR [rax+132], dl
	mov	DWORD PTR [rax+136], 65535		; 0000ffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rcx+8], 144			; 00000090H

; 1804 :     }

	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAXXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAUNodeDef@AINBNodeDefMgr@@@std@@YA?A_TAEBQEAUNodeDef@AINBNodeDefMgr@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAUNodeDef@AINBNodeDefMgr@@@std@@YA?A_TAEBQEAUNodeDef@AINBNodeDefMgr@@@Z PROC ; std::_Get_unwrapped<AINBNodeDefMgr::NodeDef * const &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEBQEAUNodeDef@AINBNodeDefMgr@@@std@@YA?A_TAEBQEAUNodeDef@AINBNodeDefMgr@@@Z ENDP ; std::_Get_unwrapped<AINBNodeDefMgr::NodeDef * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAUNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUNodeDef@AINBNodeDefMgr@@QEAU12@0PEAU12@AEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$dead$ = 72
??$_Uninitialized_move@PEAUNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUNodeDef@AINBNodeDefMgr@@QEAU12@0PEAU12@AEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@0@@Z PROC ; std::_Uninitialized_move<AINBNodeDefMgr::NodeDef *,std::allocator<AINBNodeDefMgr::NodeDef> >, COMDAT

; 1927 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN45:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, r8
	mov	rdi, rdx
	mov	r11, rcx

; 1928 :     // move [_First, _Last) to raw _Dest, using _Al
; 1929 :     // note: only called internally from elsewhere in the STL
; 1930 :     using _Ptrval     = typename _Alloc::value_type*;
; 1931 :     auto _UFirst      = _Get_unwrapped(_First);
; 1932 :     const auto _ULast = _Get_unwrapped(_Last);
; 1933 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1934 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1935 : #if _HAS_CXX20
; 1936 :         if (!_STD is_constant_evaluated())
; 1937 : #endif // _HAS_CXX20
; 1938 :         {
; 1939 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1940 :             return _Dest + (_ULast - _UFirst);
; 1941 :         }
; 1942 :     }
; 1943 : 
; 1944 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, rdx
	je	SHORT $LN40@Uninitiali
	npad	8
$LL4@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rdx, r11
	mov	rcx, rbx
	call	??0NodeDef@AINBNodeDefMgr@@QEAA@$$QEAU01@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rbx, 248				; 000000f8H
	add	r11, 248				; 000000f8H

; 1928 :     // move [_First, _Last) to raw _Dest, using _Al
; 1929 :     // note: only called internally from elsewhere in the STL
; 1930 :     using _Ptrval     = typename _Alloc::value_type*;
; 1931 :     auto _UFirst      = _Get_unwrapped(_First);
; 1932 :     const auto _ULast = _Get_unwrapped(_Last);
; 1933 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1934 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1935 : #if _HAS_CXX20
; 1936 :         if (!_STD is_constant_evaluated())
; 1937 : #endif // _HAS_CXX20
; 1938 :         {
; 1939 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1940 :             return _Dest + (_ULast - _UFirst);
; 1941 :         }
; 1942 :     }
; 1943 : 
; 1944 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	r11, rdi
	jne	SHORT $LL4@Uninitiali
$LN40@Uninitiali:

; 1946 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1947 :     }
; 1948 : 
; 1949 :     return _Backout._Release();
; 1950 : }

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_move@PEAUNodeDef@AINBNodeDefMgr@@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUNodeDef@AINBNodeDefMgr@@QEAU12@0PEAU12@AEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@0@@Z ENDP ; std::_Uninitialized_move<AINBNodeDefMgr::NodeDef *,std::allocator<AINBNodeDefMgr::NodeDef> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAXXZ PROC ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef> >::_Emplace_back<>, COMDAT

; 1801 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

$LN9:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rbx, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1801 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	mov	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, rbx
	xor	edx, edx
	mov	r8d, 248				; 000000f8H
	call	memset
	mov	rcx, rbx
	call	??0NodeDef@AINBNodeDefMgr@@QEAA@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rdi+8], 248			; 000000f8H

; 1804 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAXXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Construct_in_place@U_Find_file_handle@filesystem@std@@U123@@std@@YAXAEAU_Find_file_handle@filesystem@0@$$QEAU120@@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@U_Find_file_handle@filesystem@std@@U123@@std@@YAXAEAU_Find_file_handle@filesystem@0@$$QEAU120@@Z PROC ; std::_Construct_in_place<std::filesystem::_Find_file_handle,std::filesystem::_Find_file_handle>, COMDAT

; 248  : #if _HAS_CXX20
; 249  :     if (_STD is_constant_evaluated()) {
; 250  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 251  :     } else
; 252  : #endif // _HAS_CXX20
; 253  :     {
; 254  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 255  :     }
; 256  : }

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rdx], -1
	mov	QWORD PTR [rcx], rax
	ret	0
??$_Construct_in_place@U_Find_file_handle@filesystem@std@@U123@@std@@YAXAEAU_Find_file_handle@filesystem@0@$$QEAU120@@Z ENDP ; std::_Construct_in_place<std::filesystem::_Find_file_handle,std::filesystem::_Find_file_handle>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@U_Find_file_handle@filesystem@std@@U123@@?$_Default_allocator_traits@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@@std@@SAXAEAV?$allocator@U_Find_file_handle@filesystem@std@@@1@QEAU_Find_file_handle@filesystem@1@$$QEAU341@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@U_Find_file_handle@filesystem@std@@U123@@?$_Default_allocator_traits@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@@std@@SAXAEAV?$allocator@U_Find_file_handle@filesystem@std@@@1@QEAU_Find_file_handle@filesystem@1@$$QEAU341@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::filesystem::_Find_file_handle> >::construct<std::filesystem::_Find_file_handle,std::filesystem::_Find_file_handle>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [r8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8], -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 591  :             : _Handle(_STD exchange(_Rhs._Handle, __std_fs_dir_handle::_Invalid)) {}

	mov	QWORD PTR [rdx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@U_Find_file_handle@filesystem@std@@U123@@?$_Default_allocator_traits@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@@std@@SAXAEAV?$allocator@U_Find_file_handle@filesystem@std@@@1@QEAU_Find_file_handle@filesystem@1@$$QEAU341@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::filesystem::_Find_file_handle> >::construct<std::filesystem::_Find_file_handle,std::filesystem::_Find_file_handle>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAU_Find_file_handle@filesystem@std@@@std@@YA?A_TAEBQEAU_Find_file_handle@filesystem@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAU_Find_file_handle@filesystem@std@@@std@@YA?A_TAEBQEAU_Find_file_handle@filesystem@0@@Z PROC ; std::_Get_unwrapped<std::filesystem::_Find_file_handle * const &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEBQEAU_Find_file_handle@filesystem@std@@@std@@YA?A_TAEBQEAU_Find_file_handle@filesystem@0@@Z ENDP ; std::_Get_unwrapped<std::filesystem::_Find_file_handle * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAU_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@YAPEAU_Find_file_handle@filesystem@0@QEAU120@0PEAU120@AEAV?$allocator@U_Find_file_handle@filesystem@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Dest$ = 24
_Al$dead$ = 32
??$_Uninitialized_move@PEAU_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@YAPEAU_Find_file_handle@filesystem@0@QEAU120@0PEAU120@AEAV?$allocator@U_Find_file_handle@filesystem@std@@@0@@Z PROC ; std::_Uninitialized_move<std::filesystem::_Find_file_handle *,std::allocator<std::filesystem::_Find_file_handle> >, COMDAT

; 1927 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	mov	rax, r8

; 1928 :     // move [_First, _Last) to raw _Dest, using _Al
; 1929 :     // note: only called internally from elsewhere in the STL
; 1930 :     using _Ptrval     = typename _Alloc::value_type*;
; 1931 :     auto _UFirst      = _Get_unwrapped(_First);
; 1932 :     const auto _ULast = _Get_unwrapped(_Last);
; 1933 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1934 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1935 : #if _HAS_CXX20
; 1936 :         if (!_STD is_constant_evaluated())
; 1937 : #endif // _HAS_CXX20
; 1938 :         {
; 1939 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1940 :             return _Dest + (_ULast - _UFirst);
; 1941 :         }
; 1942 :     }
; 1943 : 
; 1944 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, rdx
	je	SHORT $LN46@Uninitiali
	npad	8
$LL4@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rcx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rcx], -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rcx, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 591  :             : _Handle(_STD exchange(_Rhs._Handle, __std_fs_dir_handle::_Invalid)) {}

	mov	QWORD PTR [rax], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rax, 8

; 1928 :     // move [_First, _Last) to raw _Dest, using _Al
; 1929 :     // note: only called internally from elsewhere in the STL
; 1930 :     using _Ptrval     = typename _Alloc::value_type*;
; 1931 :     auto _UFirst      = _Get_unwrapped(_First);
; 1932 :     const auto _ULast = _Get_unwrapped(_Last);
; 1933 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1934 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1935 : #if _HAS_CXX20
; 1936 :         if (!_STD is_constant_evaluated())
; 1937 : #endif // _HAS_CXX20
; 1938 :         {
; 1939 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1940 :             return _Dest + (_ULast - _UFirst);
; 1941 :         }
; 1942 :     }
; 1943 : 
; 1944 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, rdx
	jne	SHORT $LL4@Uninitiali
$LN46@Uninitiali:

; 1946 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1947 :     }
; 1948 : 
; 1949 :     return _Backout._Release();
; 1950 : }

	ret	0
??$_Uninitialized_move@PEAU_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@YAPEAU_Find_file_handle@filesystem@0@QEAU120@0PEAU120@AEAV?$allocator@U_Find_file_handle@filesystem@std@@@0@@Z ENDP ; std::_Uninitialized_move<std::filesystem::_Find_file_handle *,std::allocator<std::filesystem::_Find_file_handle> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@AEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAXAEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@AEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAXAEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Emplace_back<enum AINBNodeDefMgr::NodeDef::CategoryEnum &>, COMDAT

; 1802 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	r8, QWORD PTR [rcx+8]
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [r8], al

; 1803 :         ++_Last;

	inc	QWORD PTR [rcx+8]

; 1804 :     }

	ret	0
??$_Emplace_back@AEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAXAEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Emplace_back<enum AINBNodeDefMgr::NodeDef::CategoryEnum &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Copy_memmove@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@00@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Copy_memmove@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@00@Z PROC ; std::_Copy_memmove<enum AINBNodeDefMgr::NodeDef::CategoryEnum *,enum AINBNodeDefMgr::NodeDef::CategoryEnum *>, COMDAT

; 4526 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

$LN4:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8

; 4527 :     auto _FirstPtr              = _To_address(_First);
; 4528 :     auto _LastPtr               = _To_address(_Last);
; 4529 :     auto _DestPtr               = _To_address(_Dest);
; 4530 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4531 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4532 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove

; 4535 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4536 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rdi+rbx]

; 4537 :     } else {
; 4538 :         return _Dest + (_LastPtr - _FirstPtr);
; 4539 :     }
; 4540 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_memmove@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@00@Z ENDP ; std::_Copy_memmove<enum AINBNodeDefMgr::NodeDef::CategoryEnum *,enum AINBNodeDefMgr::NodeDef::CategoryEnum *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Construct_in_place@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@W4123@@std@@YAXAEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@$$QEAW4123@@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@W4123@@std@@YAXAEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@$$QEAW4123@@Z PROC ; std::_Construct_in_place<enum AINBNodeDefMgr::NodeDef::CategoryEnum,enum AINBNodeDefMgr::NodeDef::CategoryEnum>, COMDAT

; 248  : #if _HAS_CXX20
; 249  :     if (_STD is_constant_evaluated()) {
; 250  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 251  :     } else
; 252  : #endif // _HAS_CXX20
; 253  :     {
; 254  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 255  :     }
; 256  : }

	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	ret	0
??$_Construct_in_place@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@W4123@@std@@YAXAEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@$$QEAW4123@@Z ENDP ; std::_Construct_in_place<enum AINBNodeDefMgr::NodeDef::CategoryEnum,enum AINBNodeDefMgr::NodeDef::CategoryEnum>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@W4123@@?$_Default_allocator_traits@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@1@QEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@$$QEAW4345@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@W4123@@?$_Default_allocator_traits@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@1@QEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@$$QEAW4345@@Z PROC ; std::_Default_allocator_traits<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::construct<enum AINBNodeDefMgr::NodeDef::CategoryEnum,enum AINBNodeDefMgr::NodeDef::CategoryEnum>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [rdx], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@W4123@@?$_Default_allocator_traits@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@1@QEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@$$QEAW4345@@Z ENDP ; std::_Default_allocator_traits<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::construct<enum AINBNodeDefMgr::NodeDef::CategoryEnum,enum AINBNodeDefMgr::NodeDef::CategoryEnum>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YA?A_TAEBQEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YA?A_TAEBQEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@Z PROC ; std::_Get_unwrapped<enum AINBNodeDefMgr::NodeDef::CategoryEnum * const &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEBQEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YA?A_TAEBQEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@Z ENDP ; std::_Get_unwrapped<enum AINBNodeDefMgr::NodeDef::CategoryEnum * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@QEAW4123@0PEAW4123@AEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
??$_Uninitialized_move@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@QEAW4123@0PEAW4123@AEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@0@@Z PROC ; std::_Uninitialized_move<enum AINBNodeDefMgr::NodeDef::CategoryEnum *,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >, COMDAT

; 1927 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN23:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, r8
	mov	rdi, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	r8, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1927 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rcx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	rcx, rsi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1940 :             return _Dest + (_ULast - _UFirst);

	sub	rsi, rbx
	lea	rax, QWORD PTR [rdi+rsi]

; 1941 :         }
; 1942 :     }
; 1943 : 
; 1944 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {
; 1946 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1947 :     }
; 1948 : 
; 1949 :     return _Backout._Release();
; 1950 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
??$_Uninitialized_move@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@QEAW4123@0PEAW4123@AEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@0@@Z ENDP ; std::_Uninitialized_move<enum AINBNodeDefMgr::NodeDef::CategoryEnum *,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$to_address@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@QEAW4123@@Z
_TEXT	SEGMENT
_Val$ = 8
??$to_address@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@QEAW4123@@Z PROC ; std::to_address<enum AINBNodeDefMgr::NodeDef::CategoryEnum>, COMDAT

; 328  :     static_assert(!is_function_v<_Ty>, "N4950 [pointer.conversion]/1: Mandates: T is not a function type.");
; 329  :     return _Val;

	mov	rax, rcx

; 330  : }

	ret	0
??$to_address@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@QEAW4123@@Z ENDP ; std::to_address<enum AINBNodeDefMgr::NodeDef::CategoryEnum>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA?A_TAEBQEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA?A_TAEBQEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > * const &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEBQEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA?A_TAEBQEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 16
_Last$ = 24
_Dest$ = 32
_Al$dead$ = 40
??$_Uninitialized_move@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z PROC ; std::_Uninitialized_move<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > *,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >, COMDAT

; 1927 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN59:
	sub	rsp, 8
	mov	rax, r8
	mov	r11, rdx

; 1928 :     // move [_First, _Last) to raw _Dest, using _Al
; 1929 :     // note: only called internally from elsewhere in the STL
; 1930 :     using _Ptrval     = typename _Alloc::value_type*;
; 1931 :     auto _UFirst      = _Get_unwrapped(_First);
; 1932 :     const auto _ULast = _Get_unwrapped(_Last);
; 1933 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1934 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1935 : #if _HAS_CXX20
; 1936 :         if (!_STD is_constant_evaluated())
; 1937 : #endif // _HAS_CXX20
; 1938 :         {
; 1939 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1940 :             return _Dest + (_ULast - _UFirst);
; 1941 :         }
; 1942 :     }
; 1943 : 
; 1944 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, rdx
	je	SHORT $LN54@Uninitiali
	mov	r10, rax
	mov	QWORD PTR [rsp], rbx
	sub	r10, rcx
	lea	r8, QWORD PTR [rcx+8]
	xor	ebx, ebx
	npad	1
$LL4@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [r8-8]
	mov	r9, QWORD PTR [r8+8]
	mov	rdx, QWORD PTR [r8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8+8], rbx
	mov	QWORD PTR [r8], rbx
	mov	QWORD PTR [r8-8], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rax], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rax, 24
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r8+r10], rdx
	mov	QWORD PTR [r10+r8+8], r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	lea	r8, QWORD PTR [r8+24]

; 1928 :     // move [_First, _Last) to raw _Dest, using _Al
; 1929 :     // note: only called internally from elsewhere in the STL
; 1930 :     using _Ptrval     = typename _Alloc::value_type*;
; 1931 :     auto _UFirst      = _Get_unwrapped(_First);
; 1932 :     const auto _ULast = _Get_unwrapped(_Last);
; 1933 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1934 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1935 : #if _HAS_CXX20
; 1936 :         if (!_STD is_constant_evaluated())
; 1937 : #endif // _HAS_CXX20
; 1938 :         {
; 1939 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1940 :             return _Dest + (_ULast - _UFirst);
; 1941 :         }
; 1942 :     }
; 1943 : 
; 1944 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	lea	rcx, QWORD PTR [r8-8]
	cmp	rcx, r11
	jne	SHORT $LL4@Uninitiali
	mov	rbx, QWORD PTR [rsp]
$LN54@Uninitiali:

; 1946 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1947 :     }
; 1948 : 
; 1949 :     return _Backout._Release();
; 1950 : }

	add	rsp, 8
	ret	0
??$_Uninitialized_move@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > *,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAXXZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Emplace_back<>, COMDAT

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	edx, edx
	mov	QWORD PTR [rax], rdx
	mov	QWORD PTR [rax+8], rdx
	mov	QWORD PTR [rax+16], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rcx+8], 24

; 1804 :     }

	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@AEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAXAEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z
_TEXT	SEGMENT
_Guard$1 = 32
_Backout$2 = 40
__$ArrayPad$ = 64
this$ = 128
<_Vals_0>$ = 136
??$_Emplace_back@AEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAXAEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Emplace_back<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > &>, COMDAT

; 1801 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

$LN74:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r15, rdx
	mov	rbp, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	r14, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [r14], rax
	mov	QWORD PTR [r14+8], rax
	mov	QWORD PTR [r14+16], rax

; 685  :         const auto _Count       = static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst);

	mov	rbx, QWORD PTR [rdx+8]
	sub	rbx, QWORD PTR [rdx]
	sar	rbx, 4
	mov	rax, -8198552921648689607		; 8e38e38e38e38e39H
	imul	rbx, rax

; 2065 :         if (_Count != 0) {

	test	rbx, rbx
	je	$LN56@Emplace_ba

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 128102389400760775			; 01c71c71c71c71c7H
	cmp	rbx, rax
	ja	$LN72@Emplace_ba

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdx, rbx
	call	?allocate@?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAPEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z ; std::allocator<AINBNodeDefMgr::NodeDef::InputParam>::allocate
	mov	rdi, rax

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [r14], rax

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [r14+8], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [rbx+rbx*8]
	shl	rcx, 4
	add	rcx, rax
	mov	QWORD PTR [r14+16], rcx

; 2067 :             _Tidy_guard<vector> _Guard{this};

	mov	QWORD PTR _Guard$1[rsp], r14

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rsi, QWORD PTR [r15+8]
	mov	rbx, QWORD PTR [r15]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _Backout$2[rsp], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR _Backout$2[rsp], rax
	mov	QWORD PTR _Backout$2[rsp+8], rax
	mov	QWORD PTR _Backout$2[rsp+16], r14

; 1855 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rbx, rsi
	je	SHORT $LN25@Emplace_ba
$LL26@Emplace_ba:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rdx, rbx
	mov	rcx, rdi
	call	??0InputParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rdi, 144				; 00000090H
	mov	QWORD PTR _Backout$2[rsp+8], rdi

; 1855 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	rbx, 144				; 00000090H
	cmp	rbx, rsi
	jne	SHORT $LL26@Emplace_ba
$LN25@Emplace_ba:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	QWORD PTR [r14+8], rdi
$LN56@Emplace_ba:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rbp+8], 24

; 1804 :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+144]
	add	rsp, 80					; 00000050H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN72@Emplace_ba:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Xlength
	int	3
$LN70@Emplace_ba:
??$_Emplace_back@AEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAXAEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Emplace_back<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Guard$1 = 32
_Backout$2 = 40
__$ArrayPad$ = 64
this$ = 128
<_Vals_0>$ = 136
?dtor$0@?0???$_Emplace_back@AEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAXAEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z@4HA PROC ; `std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Emplace_back<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > &>'::`1'::dtor$0
	lea	rcx, QWORD PTR _Guard$1[rdx]
	jmp	??1?$_Tidy_guard@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >::~_Tidy_guard<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >
?dtor$0@?0???$_Emplace_back@AEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAXAEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z@4HA ENDP ; `std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Emplace_back<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Guard$1 = 32
_Backout$2 = 40
__$ArrayPad$ = 64
this$ = 128
<_Vals_0>$ = 136
?dtor$1@?0???$_Emplace_back@AEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAXAEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z@4HA PROC ; `std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Emplace_back<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > &>'::`1'::dtor$1
	lea	rcx, QWORD PTR _Backout$2[rdx]
	jmp	??1?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::~_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >
?dtor$1@?0???$_Emplace_back@AEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAXAEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z@4HA ENDP ; `std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Emplace_back<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > &>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA?A_TAEBQEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA?A_TAEBQEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > * const &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEBQEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA?A_TAEBQEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 16
_Last$ = 24
_Dest$ = 32
_Al$dead$ = 40
??$_Uninitialized_move@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z PROC ; std::_Uninitialized_move<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >, COMDAT

; 1927 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN59:
	sub	rsp, 8
	mov	rax, r8
	mov	r11, rdx

; 1928 :     // move [_First, _Last) to raw _Dest, using _Al
; 1929 :     // note: only called internally from elsewhere in the STL
; 1930 :     using _Ptrval     = typename _Alloc::value_type*;
; 1931 :     auto _UFirst      = _Get_unwrapped(_First);
; 1932 :     const auto _ULast = _Get_unwrapped(_Last);
; 1933 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1934 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1935 : #if _HAS_CXX20
; 1936 :         if (!_STD is_constant_evaluated())
; 1937 : #endif // _HAS_CXX20
; 1938 :         {
; 1939 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1940 :             return _Dest + (_ULast - _UFirst);
; 1941 :         }
; 1942 :     }
; 1943 : 
; 1944 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, rdx
	je	SHORT $LN54@Uninitiali
	mov	r10, rax
	mov	QWORD PTR [rsp], rbx
	sub	r10, rcx
	lea	r8, QWORD PTR [rcx+8]
	xor	ebx, ebx
	npad	1
$LL4@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [r8-8]
	mov	r9, QWORD PTR [r8+8]
	mov	rdx, QWORD PTR [r8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8+8], rbx
	mov	QWORD PTR [r8], rbx
	mov	QWORD PTR [r8-8], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rax], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rax, 24
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r8+r10], rdx
	mov	QWORD PTR [r10+r8+8], r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	lea	r8, QWORD PTR [r8+24]

; 1928 :     // move [_First, _Last) to raw _Dest, using _Al
; 1929 :     // note: only called internally from elsewhere in the STL
; 1930 :     using _Ptrval     = typename _Alloc::value_type*;
; 1931 :     auto _UFirst      = _Get_unwrapped(_First);
; 1932 :     const auto _ULast = _Get_unwrapped(_Last);
; 1933 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1934 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1935 : #if _HAS_CXX20
; 1936 :         if (!_STD is_constant_evaluated())
; 1937 : #endif // _HAS_CXX20
; 1938 :         {
; 1939 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1940 :             return _Dest + (_ULast - _UFirst);
; 1941 :         }
; 1942 :     }
; 1943 : 
; 1944 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	lea	rcx, QWORD PTR [r8-8]
	cmp	rcx, r11
	jne	SHORT $LL4@Uninitiali
	mov	rbx, QWORD PTR [rsp]
$LN54@Uninitiali:

; 1946 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1947 :     }
; 1948 : 
; 1949 :     return _Backout._Release();
; 1950 : }

	add	rsp, 8
	ret	0
??$_Uninitialized_move@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAXXZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Emplace_back<>, COMDAT

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	edx, edx
	mov	QWORD PTR [rax], rdx
	mov	QWORD PTR [rax+8], rdx
	mov	QWORD PTR [rax+16], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rcx+8], 24

; 1804 :     }

	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@AEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAXAEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z
_TEXT	SEGMENT
_Guard$1 = 32
$T2 = 40
_Backout$3 = 48
__$ArrayPad$ = 72
this$ = 128
<_Vals_0>$ = 136
??$_Emplace_back@AEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAXAEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Emplace_back<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > &>, COMDAT

; 1801 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

$LN79:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r15, rdx
	mov	rbp, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	r14, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [r14], rax
	mov	QWORD PTR [r14+8], rax
	mov	QWORD PTR [r14+16], rax

; 685  :         const auto _Count       = static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst);

	mov	rbx, QWORD PTR [rdx+8]
	sub	rbx, QWORD PTR [rdx]
	sar	rbx, 5
	mov	rax, -6148914691236517205		; aaaaaaaaaaaaaaabH
	imul	rbx, rax

; 2065 :         if (_Count != 0) {

	test	rbx, rbx
	je	$LN61@Emplace_ba

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 192153584101141162			; 02aaaaaaaaaaaaaaH
	cmp	rbx, rax
	ja	$LN77@Emplace_ba

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdx, rbx
	call	?allocate@?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z ; std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>::allocate
	mov	rdi, rax

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [r14], rax

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [r14+8], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [rbx+rbx*2]
	shl	rcx, 5
	add	rcx, rax
	mov	QWORD PTR [r14+16], rcx

; 2067 :             _Tidy_guard<vector> _Guard{this};

	mov	QWORD PTR _Guard$1[rsp], r14

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rsi, QWORD PTR [r15+8]
	mov	rbx, QWORD PTR [r15]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _Backout$3[rsp], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR _Backout$3[rsp], rax
	mov	QWORD PTR _Backout$3[rsp+8], rax
	mov	QWORD PTR _Backout$3[rsp+16], r14

; 1855 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rbx, rsi
	je	SHORT $LN25@Emplace_ba
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1983 :         pointer& _Mylast  = _My_data._Mylast;

	add	rbx, 40					; 00000028H
	npad	8
$LL26@Emplace_ba:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T2[rsp], rdi
	lea	rdx, QWORD PTR [rbx-40]
	mov	rcx, rdi
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, DWORD PTR [rbx-8]
	mov	DWORD PTR [rdi+32], eax
	lea	rcx, QWORD PTR [rdi+40]
	mov	rdx, rbx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rdi+72]
	lea	rdx, QWORD PTR [rbx+32]
	call	??0?$vector@W4FlagsStruct@AINBFile@@V?$allocator@W4FlagsStruct@AINBFile@@@std@@@std@@QEAA@AEBV01@@Z ; std::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rdi, 96					; 00000060H
	mov	QWORD PTR _Backout$3[rsp+8], rdi

; 1855 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	rbx, 96					; 00000060H
	lea	rax, QWORD PTR [rbx-40]
	cmp	rax, rsi
	jne	SHORT $LL26@Emplace_ba
$LN25@Emplace_ba:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	QWORD PTR [r14+8], rdi
$LN61@Emplace_ba:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rbp+8], 24

; 1804 :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+144]
	add	rsp, 80					; 00000050H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN77@Emplace_ba:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Xlength
	int	3
$LN75@Emplace_ba:
??$_Emplace_back@AEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAXAEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Emplace_back<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Guard$1 = 32
$T2 = 40
_Backout$3 = 48
__$ArrayPad$ = 72
this$ = 128
<_Vals_0>$ = 136
?dtor$0@?0???$_Emplace_back@AEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAXAEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z@4HA PROC ; `std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Emplace_back<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > &>'::`1'::dtor$0
	lea	rcx, QWORD PTR _Guard$1[rdx]
	jmp	??1?$_Tidy_guard@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >::~_Tidy_guard<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >
?dtor$0@?0???$_Emplace_back@AEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAXAEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z@4HA ENDP ; `std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Emplace_back<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Guard$1 = 32
$T2 = 40
_Backout$3 = 48
__$ArrayPad$ = 72
this$ = 128
<_Vals_0>$ = 136
?dtor$1@?0???$_Emplace_back@AEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAXAEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z@4HA PROC ; `std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Emplace_back<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > &>'::`1'::dtor$1
	lea	rcx, QWORD PTR _Backout$3[rdx]
	jmp	??1?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::~_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >
?dtor$1@?0???$_Emplace_back@AEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAXAEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z@4HA ENDP ; `std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Emplace_back<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > &>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Guard$1 = 32
$T2 = 40
_Backout$3 = 48
__$ArrayPad$ = 72
this$ = 128
<_Vals_0>$ = 136
?dtor$2@?0???$_Emplace_back@AEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAXAEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z@4HA PROC ; `std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Emplace_back<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > &>'::`1'::dtor$2
	mov	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0???$_Emplace_back@AEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAXAEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z@4HA ENDP ; `std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Emplace_back<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > &>'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Guard$1 = 32
$T2 = 40
_Backout$3 = 48
__$ArrayPad$ = 72
this$ = 128
<_Vals_0>$ = 136
?dtor$3@?0???$_Emplace_back@AEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAXAEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z@4HA PROC ; `std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Emplace_back<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > &>'::`1'::dtor$3
	mov	rcx, QWORD PTR $T2[rdx]
	add	rcx, 40					; 00000028H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0???$_Emplace_back@AEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAXAEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z@4HA ENDP ; `std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Emplace_back<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > &>'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Construct_in_place@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@@Z PROC ; std::_Construct_in_place<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], rax

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdx+16], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdx], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 256  : }

	ret	0
??$_Construct_in_place@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@@Z ENDP ; std::_Construct_in_place<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$destroy_at@UNodeDef@AINBNodeDefMgr@@@std@@YAXQEAUNodeDef@AINBNodeDefMgr@@@Z
_TEXT	SEGMENT
_Location$ = 8
??$destroy_at@UNodeDef@AINBNodeDefMgr@@@std@@YAXQEAUNodeDef@AINBNodeDefMgr@@@Z PROC ; std::destroy_at<AINBNodeDefMgr::NodeDef>, COMDAT

; 314  : _CONSTEXPR20 void destroy_at(_Ty* const _Location) noexcept /* strengthened */ {

	jmp	??1NodeDef@AINBNodeDefMgr@@QEAA@XZ
??$destroy_at@UNodeDef@AINBNodeDefMgr@@@std@@YAXQEAUNodeDef@AINBNodeDefMgr@@@Z ENDP ; std::destroy_at<AINBNodeDefMgr::NodeDef>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$destroy_at@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YAXQEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@@Z
_TEXT	SEGMENT
_Location$ = 8
??$destroy_at@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YAXQEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@@Z PROC ; std::destroy_at<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	jmp	?_Tidy@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Tidy
??$destroy_at@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YAXQEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@@Z ENDP ; std::destroy_at<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$destroy_at@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YAXQEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@@Z
_TEXT	SEGMENT
_Location$ = 8
??$destroy_at@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YAXQEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@@Z PROC ; std::destroy_at<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	jmp	?_Tidy@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Tidy
??$destroy_at@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YAXQEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@@Z ENDP ; std::destroy_at<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEAPEAU123@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEAPEAU123@@Z PROC ; std::move<AINBNodeDefMgr::NodeDef::ImmediateParam * &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEAPEAU123@@Z ENDP ; std::move<AINBNodeDefMgr::NodeDef::ImmediateParam * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@YA?A_T$$QEAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@YA?A_T$$QEAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z PROC ; std::_Get_unwrapped<AINBNodeDefMgr::NodeDef::ImmediateParam *>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@YA?A_T$$QEAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z ENDP ; std::_Get_unwrapped<AINBNodeDefMgr::NodeDef::ImmediateParam *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_copy_n@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z
_TEXT	SEGMENT
$T1 = 32
_Backout$ = 40
__$ArrayPad$ = 64
_First$ = 96
_Count$ = 104
_Dest$ = 112
_Al$ = 120
??$_Uninitialized_copy_n@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z PROC ; std::_Uninitialized_copy_n<AINBNodeDefMgr::NodeDef::ImmediateParam *,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >, COMDAT

; 1864 :     _InIt _First, size_t _Count, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN49:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbx, r8
	mov	rsi, rdx
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _Backout$[rsp], xmm0

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR _Backout$[rsp], rbx
	mov	QWORD PTR _Backout$[rsp+8], rbx
	mov	QWORD PTR _Backout$[rsp+16], r9

; 1865 :     // copy _First + [0, _Count) to raw _Dest, using _Al
; 1866 :     // note: only called internally from elsewhere in the STL
; 1867 :     using _Ptrval = typename _Alloc::value_type*;
; 1868 : 
; 1869 :     auto _UFirst = _Get_unwrapped(_STD move(_First));
; 1870 : 
; 1871 :     constexpr bool _Can_memmove =
; 1872 :         conjunction_v<bool_constant<_Iter_copy_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1873 :             _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>;
; 1874 : 
; 1875 :     if constexpr (_Can_memmove) {
; 1876 : #if _HAS_CXX20
; 1877 :         if (!_STD is_constant_evaluated())
; 1878 : #endif // _HAS_CXX20
; 1879 :         {
; 1880 :             _Copy_memmove_n(_UFirst, _Count, _Unfancy(_Dest));
; 1881 :             _Dest += _Count;
; 1882 :             return _Dest;
; 1883 :         }
; 1884 :     }
; 1885 : 
; 1886 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1887 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {

	test	rdx, rdx
	je	SHORT $LN46@Uninitiali

; 1864 :     _InIt _First, size_t _Count, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	lea	rdi, QWORD PTR [rcx+40]
$LL4@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T1[rsp], rbx
	lea	rdx, QWORD PTR [rdi-40]
	mov	rcx, rbx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, DWORD PTR [rdi-8]
	mov	DWORD PTR [rbx+32], eax
	lea	rcx, QWORD PTR [rbx+40]
	mov	rdx, rdi
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rbx+72]
	lea	rdx, QWORD PTR [rdi+32]
	call	??0?$vector@W4FlagsStruct@AINBFile@@V?$allocator@W4FlagsStruct@AINBFile@@@std@@@std@@QEAA@AEBV01@@Z ; std::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rbx, 96					; 00000060H
	mov	QWORD PTR _Backout$[rsp+8], rbx

; 1865 :     // copy _First + [0, _Count) to raw _Dest, using _Al
; 1866 :     // note: only called internally from elsewhere in the STL
; 1867 :     using _Ptrval = typename _Alloc::value_type*;
; 1868 : 
; 1869 :     auto _UFirst = _Get_unwrapped(_STD move(_First));
; 1870 : 
; 1871 :     constexpr bool _Can_memmove =
; 1872 :         conjunction_v<bool_constant<_Iter_copy_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1873 :             _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>;
; 1874 : 
; 1875 :     if constexpr (_Can_memmove) {
; 1876 : #if _HAS_CXX20
; 1877 :         if (!_STD is_constant_evaluated())
; 1878 : #endif // _HAS_CXX20
; 1879 :         {
; 1880 :             _Copy_memmove_n(_UFirst, _Count, _Unfancy(_Dest));
; 1881 :             _Dest += _Count;
; 1882 :             return _Dest;
; 1883 :         }
; 1884 :     }
; 1885 : 
; 1886 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1887 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {

	add	rdi, 96					; 00000060H
	sub	rsi, 1
	jne	SHORT $LL4@Uninitiali
$LN46@Uninitiali:

; 1888 :         _Backout._Emplace_back(*_UFirst);
; 1889 :     }
; 1890 : 
; 1891 :     return _Backout._Release();
; 1892 : }

	mov	rax, rbx
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+104]
	mov	rsi, QWORD PTR [rsp+112]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
??$_Uninitialized_copy_n@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z ENDP ; std::_Uninitialized_copy_n<AINBNodeDefMgr::NodeDef::ImmediateParam *,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Backout$ = 40
__$ArrayPad$ = 64
_First$ = 96
_Count$ = 104
_Dest$ = 112
_Al$ = 120
?dtor$0@?0???$_Uninitialized_copy_n@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z@4HA PROC ; `std::_Uninitialized_copy_n<AINBNodeDefMgr::NodeDef::ImmediateParam *,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Backout$[rdx]
	jmp	??1?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::~_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >
?dtor$0@?0???$_Uninitialized_copy_n@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z@4HA ENDP ; `std::_Uninitialized_copy_n<AINBNodeDefMgr::NodeDef::ImmediateParam *,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Backout$ = 40
__$ArrayPad$ = 64
_First$ = 96
_Count$ = 104
_Dest$ = 112
_Al$ = 120
?dtor$1@?0???$_Uninitialized_copy_n@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z@4HA PROC ; `std::_Uninitialized_copy_n<AINBNodeDefMgr::NodeDef::ImmediateParam *,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >'::`1'::dtor$1
	mov	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0???$_Uninitialized_copy_n@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z@4HA ENDP ; `std::_Uninitialized_copy_n<AINBNodeDefMgr::NodeDef::ImmediateParam *,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Backout$ = 40
__$ArrayPad$ = 64
_First$ = 96
_Count$ = 104
_Dest$ = 112
_Al$ = 120
?dtor$2@?0???$_Uninitialized_copy_n@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z@4HA PROC ; `std::_Uninitialized_copy_n<AINBNodeDefMgr::NodeDef::ImmediateParam *,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >'::`1'::dtor$2
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 40					; 00000028H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0???$_Uninitialized_copy_n@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z@4HA ENDP ; `std::_Uninitialized_copy_n<AINBNodeDefMgr::NodeDef::ImmediateParam *,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Copy_n_unchecked4@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_KPEAU123@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Dest$ = 64
??$_Copy_n_unchecked4@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_KPEAU123@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0@Z PROC ; std::_Copy_n_unchecked4<AINBNodeDefMgr::NodeDef::ImmediateParam *,unsigned __int64,AINBNodeDefMgr::NodeDef::ImmediateParam *>, COMDAT

; 4556 : _CONSTEXPR20 _OutIt _Copy_n_unchecked4(_InIt _First, _SizeTy _Count, _OutIt _Dest) {

$LN41:
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	sub	rsp, 32					; 00000020H
	mov	rsi, r8
	mov	rbp, rdx

; 4572 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	test	rdx, rdx
	je	$LN31@Copy_n_unc
	mov	QWORD PTR [rsp+48], rbx
	lea	rbx, QWORD PTR [rcx+64]
	mov	QWORD PTR [rsp+56], rdi
	lea	rdi, QWORD PTR [r8+40]
	npad	5
$LL4@Copy_n_unc:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3156 :         if (this == _STD addressof(_Right)) {

	lea	rdx, QWORD PTR [rbx-64]
	cmp	rsi, rdx
	je	SHORT $LN8@Copy_n_unc

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rbx-40], 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN12@Copy_n_unc

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN12@Copy_n_unc:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rbx-48]
	mov	rcx, rsi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN8@Copy_n_unc:
	mov	eax, DWORD PTR [rbx-32]

; 3156 :         if (this == _STD addressof(_Right)) {

	lea	rdx, QWORD PTR [rbx-24]
	mov	DWORD PTR [rdi-8], eax
	cmp	rdi, rdx
	je	SHORT $LN16@Copy_n_unc

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rbx], 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN20@Copy_n_unc

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN20@Copy_n_unc:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rbx-8]
	mov	rcx, rdi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN16@Copy_n_unc:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1483 :         if (this == _STD addressof(_Right)) {

	lea	rdx, QWORD PTR [rbx+8]
	lea	rcx, QWORD PTR [rdi+32]
	cmp	rcx, rdx
	je	SHORT $LN2@Copy_n_unc

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [rdx]
	mov	r8, QWORD PTR [rbx+16]
	sub	r8, rdx
	call	??$_Assign_counted_range@PEAW4FlagsStruct@AINBFile@@@?$vector@W4FlagsStruct@AINBFile@@V?$allocator@W4FlagsStruct@AINBFile@@@std@@@std@@AEAAXPEAW4FlagsStruct@AINBFile@@_K@Z ; std::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >::_Assign_counted_range<enum AINBFile::FlagsStruct *>
$LN2@Copy_n_unc:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4572 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	add	rsi, 96					; 00000060H
	add	rdi, 96					; 00000060H
	add	rbx, 96					; 00000060H
	sub	rbp, 1
	jne	SHORT $LL4@Copy_n_unc
	mov	rdi, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]
$LN31@Copy_n_unc:

; 4573 :         *_Dest = *_First;
; 4574 :     }
; 4575 : 
; 4576 :     return _Dest;
; 4577 : }

	mov	rbp, QWORD PTR [rsp+64]
	mov	rax, rsi
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
??$_Copy_n_unchecked4@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_KPEAU123@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0@Z ENDP ; std::_Copy_n_unchecked4<AINBNodeDefMgr::NodeDef::ImmediateParam *,unsigned __int64,AINBNodeDefMgr::NodeDef::ImmediateParam *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAPEAUInputParam@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAPEAUInputParam@NodeDef@AINBNodeDefMgr@@AEAPEAU123@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAPEAUInputParam@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAPEAUInputParam@NodeDef@AINBNodeDefMgr@@AEAPEAU123@@Z PROC ; std::move<AINBNodeDefMgr::NodeDef::InputParam * &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAPEAUInputParam@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAPEAUInputParam@NodeDef@AINBNodeDefMgr@@AEAPEAU123@@Z ENDP ; std::move<AINBNodeDefMgr::NodeDef::InputParam * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@PEAUInputParam@NodeDef@AINBNodeDefMgr@@@std@@YA?A_T$$QEAPEAUInputParam@NodeDef@AINBNodeDefMgr@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@PEAUInputParam@NodeDef@AINBNodeDefMgr@@@std@@YA?A_T$$QEAPEAUInputParam@NodeDef@AINBNodeDefMgr@@@Z PROC ; std::_Get_unwrapped<AINBNodeDefMgr::NodeDef::InputParam *>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@PEAUInputParam@NodeDef@AINBNodeDefMgr@@@std@@YA?A_T$$QEAPEAUInputParam@NodeDef@AINBNodeDefMgr@@@Z ENDP ; std::_Get_unwrapped<AINBNodeDefMgr::NodeDef::InputParam *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_copy_n@PEAUInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z
_TEXT	SEGMENT
_Backout$ = 32
__$ArrayPad$ = 56
_First$ = 80
_Count$ = 88
_Dest$ = 96
_Al$ = 104
??$_Uninitialized_copy_n@PEAUInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z PROC ; std::_Uninitialized_copy_n<AINBNodeDefMgr::NodeDef::InputParam *,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >, COMDAT

; 1864 :     _InIt _First, size_t _Count, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN44:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbx, rcx
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _Backout$[rsp], xmm0

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR _Backout$[rsp], r8
	mov	QWORD PTR _Backout$[rsp+8], r8
	mov	QWORD PTR _Backout$[rsp+16], r9

; 1865 :     // copy _First + [0, _Count) to raw _Dest, using _Al
; 1866 :     // note: only called internally from elsewhere in the STL
; 1867 :     using _Ptrval = typename _Alloc::value_type*;
; 1868 : 
; 1869 :     auto _UFirst = _Get_unwrapped(_STD move(_First));
; 1870 : 
; 1871 :     constexpr bool _Can_memmove =
; 1872 :         conjunction_v<bool_constant<_Iter_copy_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1873 :             _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>;
; 1874 : 
; 1875 :     if constexpr (_Can_memmove) {
; 1876 : #if _HAS_CXX20
; 1877 :         if (!_STD is_constant_evaluated())
; 1878 : #endif // _HAS_CXX20
; 1879 :         {
; 1880 :             _Copy_memmove_n(_UFirst, _Count, _Unfancy(_Dest));
; 1881 :             _Dest += _Count;
; 1882 :             return _Dest;
; 1883 :         }
; 1884 :     }
; 1885 : 
; 1886 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1887 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {

	test	rdx, rdx
	je	SHORT $LN41@Uninitiali
$LL4@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rdx, rbx
	mov	rcx, rdi
	call	??0InputParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rdi, 144				; 00000090H
	mov	QWORD PTR _Backout$[rsp+8], rdi

; 1865 :     // copy _First + [0, _Count) to raw _Dest, using _Al
; 1866 :     // note: only called internally from elsewhere in the STL
; 1867 :     using _Ptrval = typename _Alloc::value_type*;
; 1868 : 
; 1869 :     auto _UFirst = _Get_unwrapped(_STD move(_First));
; 1870 : 
; 1871 :     constexpr bool _Can_memmove =
; 1872 :         conjunction_v<bool_constant<_Iter_copy_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1873 :             _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>;
; 1874 : 
; 1875 :     if constexpr (_Can_memmove) {
; 1876 : #if _HAS_CXX20
; 1877 :         if (!_STD is_constant_evaluated())
; 1878 : #endif // _HAS_CXX20
; 1879 :         {
; 1880 :             _Copy_memmove_n(_UFirst, _Count, _Unfancy(_Dest));
; 1881 :             _Dest += _Count;
; 1882 :             return _Dest;
; 1883 :         }
; 1884 :     }
; 1885 : 
; 1886 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1887 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {

	add	rbx, 144				; 00000090H
	sub	rsi, 1
	jne	SHORT $LL4@Uninitiali
$LN41@Uninitiali:

; 1888 :         _Backout._Emplace_back(*_UFirst);
; 1889 :     }
; 1890 : 
; 1891 :     return _Backout._Release();
; 1892 : }

	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
??$_Uninitialized_copy_n@PEAUInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z ENDP ; std::_Uninitialized_copy_n<AINBNodeDefMgr::NodeDef::InputParam *,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Backout$ = 32
__$ArrayPad$ = 56
_First$ = 80
_Count$ = 88
_Dest$ = 96
_Al$ = 104
?dtor$0@?0???$_Uninitialized_copy_n@PEAUInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z@4HA PROC ; `std::_Uninitialized_copy_n<AINBNodeDefMgr::NodeDef::InputParam *,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Backout$[rdx]
	jmp	??1?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::~_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >
?dtor$0@?0???$_Uninitialized_copy_n@PEAUInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z@4HA ENDP ; `std::_Uninitialized_copy_n<AINBNodeDefMgr::NodeDef::InputParam *,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Copy_n_unchecked4@PEAUInputParam@NodeDef@AINBNodeDefMgr@@_KPEAU123@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0@Z
_TEXT	SEGMENT
_First$ = 48
$T1 = 56
_Count$ = 56
_Dest$ = 64
??$_Copy_n_unchecked4@PEAUInputParam@NodeDef@AINBNodeDefMgr@@_KPEAU123@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0@Z PROC ; std::_Copy_n_unchecked4<AINBNodeDefMgr::NodeDef::InputParam *,unsigned __int64,AINBNodeDefMgr::NodeDef::InputParam *>, COMDAT

; 4556 : _CONSTEXPR20 _OutIt _Copy_n_unchecked4(_InIt _First, _SizeTy _Count, _OutIt _Dest) {

$LN53:
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	sub	rsp, 32					; 00000020H
	mov	rsi, r8
	mov	rbp, rdx

; 4572 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	test	rdx, rdx
	je	$LN43@Copy_n_unc
	mov	QWORD PTR [rsp+48], rbx
	lea	rbx, QWORD PTR [rcx+56]
	mov	QWORD PTR [rsp+64], rdi
	lea	rdi, QWORD PTR [r8+64]
	npad	5
$LL4@Copy_n_unc:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3156 :         if (this == _STD addressof(_Right)) {

	lea	rdx, QWORD PTR [rbx-56]
	cmp	rsi, rdx
	je	SHORT $LN8@Copy_n_unc

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rbx-32], 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN12@Copy_n_unc

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN12@Copy_n_unc:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rbx-40]
	mov	rcx, rsi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN8@Copy_n_unc:

; 3156 :         if (this == _STD addressof(_Right)) {

	lea	rdx, QWORD PTR [rbx-24]
	lea	rcx, QWORD PTR [rdi-32]
	cmp	rcx, rdx
	je	SHORT $LN16@Copy_n_unc

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rbx], 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN20@Copy_n_unc

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN20@Copy_n_unc:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rbx-8]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN16@Copy_n_unc:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1483 :         if (this == _STD addressof(_Right)) {

	lea	rdx, QWORD PTR [rbx+8]
	cmp	rdi, rdx
	je	SHORT $LN24@Copy_n_unc

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [rdx]
	mov	rcx, rdi
	mov	r8, QWORD PTR [rbx+16]
	sub	r8, rdx
	call	??$_Assign_counted_range@PEAW4FlagsStruct@AINBFile@@@?$vector@W4FlagsStruct@AINBFile@@V?$allocator@W4FlagsStruct@AINBFile@@@std@@@std@@AEAAXPEAW4FlagsStruct@AINBFile@@_K@Z ; std::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >::_Assign_counted_range<enum AINBFile::FlagsStruct *>
$LN24@Copy_n_unc:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 803  :         return static_cast<size_t>(_Which);

	movsx	rcx, BYTE PTR [rbx+64]

; 865  :         _STD _Variant_raw_visit(_That.index(), _That._Storage(), _Variant_assign_visitor<_Types...>{*this});

	lea	rax, QWORD PTR [rdi+24]

; 691  :     ++_Idx; // bias index by +1 to map {variant_npos} U [0, _Size) to the contiguous range [0, _Size]

	inc	rcx

; 865  :         _STD _Variant_raw_visit(_That.index(), _That._Storage(), _Variant_assign_visitor<_Types...>{*this});

	mov	QWORD PTR $T1[rsp], rax

; 692  :     return _Variant_raw_visit1<_Strategy>::_Visit(_Idx, static_cast<_Fn&&>(_Func), static_cast<_Storage&&>(_Obj));

	lea	r8, QWORD PTR [rbx+32]
	lea	rdx, QWORD PTR $T1[rsp]
	call	??$_Visit@U?$_Variant_assign_visitor@I_NMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VVector3F@@@std@@AEBV?$_Variant_storage_@$0A@I_NMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VVector3F@@@2@@?$_Variant_raw_visit1@$01@std@@SAX_K$$QEAU?$_Variant_assign_visitor@I_NMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VVector3F@@@1@AEBV?$_Variant_storage_@$0A@I_NMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VVector3F@@@1@@Z ; std::_Variant_raw_visit1<2>::_Visit<std::_Variant_assign_visitor<unsigned int,bool,float,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Vector3F>,std::_Variant_storage_<0,unsigned int,bool,float,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Vector3F> const &>
	mov	eax, DWORD PTR [rbx+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4572 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	add	rsi, 144				; 00000090H
	mov	DWORD PTR [rdi+64], eax
	movzx	eax, BYTE PTR [rbx+76]
	mov	BYTE PTR [rdi+68], al
	mov	eax, DWORD PTR [rbx+80]
	add	rbx, 144				; 00000090H
	mov	DWORD PTR [rdi+72], eax
	add	rdi, 144				; 00000090H
	sub	rbp, 1
	jne	$LL4@Copy_n_unc
	mov	rdi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+48]
$LN43@Copy_n_unc:

; 4573 :         *_Dest = *_First;
; 4574 :     }
; 4575 : 
; 4576 :     return _Dest;
; 4577 : }

	mov	rbp, QWORD PTR [rsp+72]
	mov	rax, rsi
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
??$_Copy_n_unchecked4@PEAUInputParam@NodeDef@AINBNodeDefMgr@@_KPEAU123@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@_K0@Z ENDP ; std::_Copy_n_unchecked4<AINBNodeDefMgr::NodeDef::InputParam *,unsigned __int64,AINBNodeDefMgr::NodeDef::InputParam *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Destroy_in_place@U_Recursive_dir_enum_impl@filesystem@std@@@std@@YAXAEAU_Recursive_dir_enum_impl@filesystem@0@@Z
_TEXT	SEGMENT
_Obj$ = 48
??$_Destroy_in_place@U_Recursive_dir_enum_impl@filesystem@std@@@std@@YAXAEAU_Recursive_dir_enum_impl@filesystem@0@@Z PROC ; std::_Destroy_in_place<std::filesystem::_Recursive_dir_enum_impl>, COMDAT

; 304  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

$LN25:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	add	rcx, 72					; 00000048H
	call	??1?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEAA@XZ ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::~vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 605  :             __std_fs_directory_iterator_close(_Handle);

	mov	rcx, QWORD PTR [rbx+64]
	call	__std_fs_directory_iterator_close

; 638  :         ~path()                          = default;

	lea	rcx, QWORD PTR [rbx+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 310  : }

	add	rsp, 32					; 00000020H
	pop	rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	jmp	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
??$_Destroy_in_place@U_Recursive_dir_enum_impl@filesystem@std@@@std@@YAXAEAU_Recursive_dir_enum_impl@filesystem@0@@Z ENDP ; std::_Destroy_in_place<std::filesystem::_Recursive_dir_enum_impl>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??1_Recursive_dir_enum_impl@filesystem@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1_Recursive_dir_enum_impl@filesystem@std@@QEAA@XZ PROC ; std::filesystem::_Recursive_dir_enum_impl::~_Recursive_dir_enum_impl, COMDAT
$LN19:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	add	rcx, 72					; 00000048H
	call	??1?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEAA@XZ ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::~vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 605  :             __std_fs_directory_iterator_close(_Handle);

	mov	rcx, QWORD PTR [rbx+64]
	call	__std_fs_directory_iterator_close

; 638  :         ~path()                          = default;

	lea	rcx, QWORD PTR [rbx+32]
	add	rsp, 32					; 00000020H
	pop	rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	jmp	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
??1_Recursive_dir_enum_impl@filesystem@std@@QEAA@XZ ENDP ; std::filesystem::_Recursive_dir_enum_impl::~_Recursive_dir_enum_impl
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Refancy@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@$0A@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Refancy@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@$0A@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@@Z PROC ; std::_Refancy<enum AINBNodeDefMgr::NodeDef::CategoryEnum *,0>, COMDAT

; 297  :     return _Ptr;

	mov	rax, rcx

; 298  : }

	ret	0
??$_Refancy@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@$0A@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4123@@Z ENDP ; std::_Refancy<enum AINBNodeDefMgr::NodeDef::CategoryEnum *,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0JA@@std@@YA_K_K@Z
_TEXT	SEGMENT
_Count$ = 48
??$_Get_size_of_n@$0JA@@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<144>, COMDAT

; 65   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN7:
	sub	rsp, 40					; 00000028H

; 66   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;
; 67   : 
; 68   :     if constexpr (_Overflow_is_possible) {
; 69   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 70   :         if (_Count > _Max_possible) {

	mov	rax, 128102389400760775			; 01c71c71c71c71c7H
	cmp	rcx, rax
	ja	SHORT $LN6@Get_size_o

; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	lea	rax, QWORD PTR [rcx+rcx*8]
	shl	rax, 4

; 76   : }

	add	rsp, 40					; 00000028H
	ret	0
$LN6@Get_size_o:

; 71   :             _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN4@Get_size_o:
??$_Get_size_of_n@$0JA@@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<144>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0PI@@std@@YA_K_K@Z
_TEXT	SEGMENT
_Count$ = 48
??$_Get_size_of_n@$0PI@@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<248>, COMDAT

; 65   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN7:
	sub	rsp, 40					; 00000028H

; 66   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;
; 67   : 
; 68   :     if constexpr (_Overflow_is_possible) {
; 69   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 70   :         if (_Count > _Max_possible) {

	mov	rax, 74382032555280450			; 0108421084210842H
	cmp	rcx, rax
	ja	SHORT $LN6@Get_size_o

; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	imul	rax, rcx, 248				; 000000f8H

; 76   : }

	add	rsp, 40					; 00000028H
	ret	0
$LN6@Get_size_o:

; 71   :             _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN4@Get_size_o:
??$_Get_size_of_n@$0PI@@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<248>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@$$QEAU012@@Z
_TEXT	SEGMENT
this$ = 8
__that$ = 16
??0ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@$$QEAU012@@Z PROC ; AINBNodeDefMgr::NodeDef::ImmediateParam::ImmediateParam, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	r10d, r10d
	mov	r8, rdx
	mov	r9, rcx
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], r10

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], r10

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rcx+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rdx+16], r10
	mov	QWORD PTR [rdx+24], 15
	mov	BYTE PTR [rdx], r10b
	mov	eax, DWORD PTR [rdx+32]
	mov	DWORD PTR [rcx+32], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx+40], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+56], r10

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+64], r10

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx+40]
	movups	XMMWORD PTR [rcx+40], xmm0
	movups	xmm1, XMMWORD PTR [rdx+56]
	movups	XMMWORD PTR [rcx+56], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 697  :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal()),

	mov	QWORD PTR [rdx+56], r10
	mov	QWORD PTR [rdx+64], 15
	mov	BYTE PTR [rdx+40], r10b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [r8+72]
	mov	rdx, QWORD PTR [rdx+88]
	mov	rcx, QWORD PTR [r8+80]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8+88], r10
	mov	QWORD PTR [r8+80], r10
	mov	QWORD PTR [r8+72], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r9+72], rax
	mov	rax, r9
	mov	QWORD PTR [r9+80], rcx
	mov	QWORD PTR [r9+88], rdx
	ret	0
??0ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@$$QEAU012@@Z ENDP ; AINBNodeDefMgr::NodeDef::ImmediateParam::ImmediateParam
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@@std@@QEAAX_K@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::filesystem::_Find_file_handle> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@@std@@QEAAX_K@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::filesystem::_Find_file_handle> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_GNodeDef@AINBNodeDefMgr@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_GNodeDef@AINBNodeDefMgr@@QEAAPEAXI@Z PROC		; AINBNodeDefMgr::NodeDef::`scalar deleting destructor', COMDAT
$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	call	??1NodeDef@AINBNodeDefMgr@@QEAA@XZ
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_GNodeDef@AINBNodeDefMgr@@QEAAPEAXI@Z ENDP		; AINBNodeDefMgr::NodeDef::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??_G?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_G?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAXI@Z PROC ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::`scalar deleting destructor', COMDAT
$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 767  :         _Tidy();

	call	?_Tidy@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Tidy
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_G?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAXI@Z ENDP ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??_G?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_G?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAXI@Z PROC ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::`scalar deleting destructor', COMDAT
$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 767  :         _Tidy();

	call	?_Tidy@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Tidy
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_G?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAPEAXI@Z ENDP ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??_G_Recursive_dir_enum_impl@filesystem@std@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_G_Recursive_dir_enum_impl@filesystem@std@@QEAAPEAXI@Z PROC ; std::filesystem::_Recursive_dir_enum_impl::`scalar deleting destructor', COMDAT
$LN23:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	add	rcx, 72					; 00000048H
	call	??1?$vector@U_Find_file_handle@filesystem@std@@V?$allocator@U_Find_file_handle@filesystem@std@@@3@@std@@QEAA@XZ ; std::vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >::~vector<std::filesystem::_Find_file_handle,std::allocator<std::filesystem::_Find_file_handle> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 605  :             __std_fs_directory_iterator_close(_Handle);

	mov	rcx, QWORD PTR [rbx+64]
	call	__std_fs_directory_iterator_close

; 638  :         ~path()                          = default;

	lea	rcx, QWORD PTR [rbx+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	call	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_G_Recursive_dir_enum_impl@filesystem@std@@QEAAPEAXI@Z ENDP ; std::filesystem::_Recursive_dir_enum_impl::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@@std@@QEAAPEAU_Find_file_handle@filesystem@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@@std@@QEAAPEAU_Find_file_handle@filesystem@2@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::filesystem::_Find_file_handle> >::_Release, COMDAT

; 1807 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1808 :         return _Last;
; 1809 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@@std@@QEAAPEAU_Find_file_handle@filesystem@2@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::filesystem::_Find_file_handle> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Uninitialized_backout_al@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::filesystem::_Find_file_handle> >::~_Uninitialized_backout_al<std::allocator<std::filesystem::_Find_file_handle> >, COMDAT

; 1796 :     _CONSTEXPR20 ~_Uninitialized_backout_al() {

$LN24:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1797 :         _Destroy_range(_First, _Last, _Al);

	mov	rdi, QWORD PTR [rcx+8]
	mov	rbx, QWORD PTR [rcx]

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN5@Uninitiali
$LL6@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 605  :             __std_fs_directory_iterator_close(_Handle);

	mov	rcx, QWORD PTR [rbx]
	call	__std_fs_directory_iterator_close
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 8
	cmp	rbx, rdi
	jne	SHORT $LL6@Uninitiali
$LN5@Uninitiali:

; 1798 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::filesystem::_Find_file_handle> >::~_Uninitialized_backout_al<std::allocator<std::filesystem::_Find_file_handle> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@@std@@QEAA@PEAU_Find_file_handle@filesystem@1@AEAV?$allocator@U_Find_file_handle@filesystem@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@@std@@QEAA@PEAU_Find_file_handle@filesystem@1@AEAV?$allocator@U_Find_file_handle@filesystem@std@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::filesystem::_Find_file_handle> >::_Uninitialized_backout_al<std::allocator<std::filesystem::_Find_file_handle> >, COMDAT

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@@std@@QEAA@PEAU_Find_file_handle@filesystem@1@AEAV?$allocator@U_Find_file_handle@filesystem@std@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::filesystem::_Find_file_handle> >::_Uninitialized_backout_al<std::allocator<std::filesystem::_Find_file_handle> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??1?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ PROC ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::~vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >, COMDAT

; 767  :         _Tidy();

	jmp	?_Tidy@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Tidy
??1?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ ENDP ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::~vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??1?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ PROC ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::~vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >, COMDAT

; 767  :         _Tidy();

	jmp	?_Tidy@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Tidy
??1?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ ENDP ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::~vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Tidy@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ PROC ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Tidy, COMDAT

; 2035 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

$LN47:
	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	sub	rsp, 32					; 00000020H

; 2036 :         auto& _Al         = _Getal();
; 2037 :         auto& _My_data    = _Mypair._Myval2;
; 2038 :         pointer& _Myfirst = _My_data._Myfirst;
; 2039 :         pointer& _Mylast  = _My_data._Mylast;
; 2040 :         pointer& _Myend   = _My_data._Myend;
; 2041 : 
; 2042 :         _My_data._Orphan_all();
; 2043 : 
; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR [rcx]
	mov	rsi, rcx
	test	rbx, rbx
	je	SHORT $LN2@Tidy
	mov	QWORD PTR [rsp+56], rdi

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdi, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN6@Tidy
$LL7@Tidy:
	mov	rcx, rbx
	call	??1ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ
	add	rbx, 96					; 00000060H
	cmp	rbx, rdi
	jne	SHORT $LL7@Tidy
$LN6@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rsi]
	mov	rdx, -6148914691236517205		; aaaaaaaaaaaaaaabH
	mov	rax, QWORD PTR [rsi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdi, QWORD PTR [rsp+56]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rax, rcx
	sar	rax, 5
	imul	rax, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*2]
	shl	rdx, 5

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN32@Tidy

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN29@Tidy

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN32@Tidy:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rsi], rax

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rsi+8], rax

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rsi+16], rax
$LN2@Tidy:

; 2053 :     }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
$LN29@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN44@Tidy:
?_Tidy@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ ENDP ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Tidy@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ PROC ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Tidy, COMDAT

; 2035 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

$LN47:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 2036 :         auto& _Al         = _Getal();
; 2037 :         auto& _My_data    = _Mypair._Myval2;
; 2038 :         pointer& _Myfirst = _My_data._Myfirst;
; 2039 :         pointer& _Mylast  = _My_data._Mylast;
; 2040 :         pointer& _Myend   = _My_data._Myend;
; 2041 : 
; 2042 :         _My_data._Orphan_all();
; 2043 : 
; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR [rcx]
	mov	rdi, rcx
	test	rbx, rbx
	je	SHORT $LN2@Tidy
	mov	QWORD PTR [rsp+56], rsi

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rsi, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rsi
	je	SHORT $LN6@Tidy
$LL7@Tidy:
	mov	rcx, rbx
	call	??1InputParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ
	add	rbx, 144				; 00000090H
	cmp	rbx, rsi
	jne	SHORT $LL7@Tidy
$LN6@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rdi]
	mov	rdx, -8198552921648689607		; 8e38e38e38e38e39H
	mov	rax, QWORD PTR [rdi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rsi, QWORD PTR [rsp+56]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rax, rcx
	sar	rax, 4
	imul	rax, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*8]
	shl	rdx, 4

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN32@Tidy

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN29@Tidy

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN32@Tidy:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rdi], rax

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rdi+8], rax

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rdi+16], rax
$LN2@Tidy:

; 2053 :     }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN29@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN44@Tidy:
?_Tidy@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ ENDP ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??$?0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@_W@1@@Z
_TEXT	SEGMENT
this$ = 80
_Right$ = 88
_Al$dead$ = 96
??$?0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@_W@1@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> ><std::basic_string_view<wchar_t,std::char_traits<wchar_t> >,0>, COMDAT

; 2885 :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN57:
	push	rbx
	push	rbp
	push	rsi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	r15d, r15d
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], r15

; 2620 :         if (_Count > max_size()) {

	mov	rbp, 9223372036854775806		; 7ffffffffffffffeH

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], r15

; 2885 :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	rsi, rcx

; 2886 :         const basic_string_view<_Elem, _Traits> _As_view = _Right;

	mov	rbx, QWORD PTR [rdx+8]
	mov	r14, QWORD PTR [rdx]

; 2620 :         if (_Count > max_size()) {

	cmp	rbx, rbp
	ja	$LN55@allocator

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR [rcx+24], 7
	cmp	rbx, 8
	jae	SHORT $LN15@allocator

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR [rcx+16], rbx

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14
	add	rbx, rbx
	mov	r8, rbx
	call	memcpy

; 2887 :         _Construct<_Construct_strategy::_From_ptr>(_As_view.data(), _Convert_size<size_type>(_As_view.size()));
; 2888 :     }

	mov	rax, rsi

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	WORD PTR [rbx+rsi], r15w

; 2887 :         _Construct<_Construct_strategy::_From_ptr>(_As_view.data(), _Convert_size<size_type>(_As_view.size()));
; 2888 :     }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN15@allocator:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rax, rbx
	mov	QWORD PTR [rsp+96], rdi
	or	rax, 7
	cmp	rax, rbp

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN25@allocator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	mov	ecx, 10
	mov	rbp, rax
	cmp	rax, rcx
	cmovb	rbp, rcx
$LN25@allocator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	rdx, QWORD PTR [rbp+1]
	call	?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z ; std::allocator<wchar_t>::allocate

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR [rsi+16], rbx

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14
	add	rbx, rbx

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR [rsi], rax

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rbx

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR [rsi+24], rbp

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rcx, rax

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdi, rax

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy

; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	mov	WORD PTR [rbx+rdi], r15w

; 2887 :         _Construct<_Construct_strategy::_From_ptr>(_As_view.data(), _Convert_size<size_type>(_As_view.size()));
; 2888 :     }

	mov	rax, rsi

; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	mov	rdi, QWORD PTR [rsp+96]

; 2887 :         _Construct<_Construct_strategy::_From_ptr>(_As_view.data(), _Convert_size<size_type>(_As_view.size()));
; 2888 :     }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN55@allocator:

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN53@allocator:
??$?0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@_W@1@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> ><std::basic_string_view<wchar_t,std::char_traits<wchar_t> >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Construct_in_place@U_Recursive_dir_enum_impl@filesystem@std@@U_Creator@_Dir_enum_impl@23@AEBW4directory_options@23@@std@@YAXAEAU_Recursive_dir_enum_impl@filesystem@0@$$QEAU_Creator@_Dir_enum_impl@20@AEBW4directory_options@20@@Z
_TEXT	SEGMENT
_Obj$ = 48
<_Args_0>$ = 56
<_Args_1>$ = 64
??$_Construct_in_place@U_Recursive_dir_enum_impl@filesystem@std@@U_Creator@_Dir_enum_impl@23@AEBW4directory_options@23@@std@@YAXAEAU_Recursive_dir_enum_impl@filesystem@0@$$QEAU_Creator@_Dir_enum_impl@20@AEBW4directory_options@20@@Z PROC ; std::_Construct_in_place<std::filesystem::_Recursive_dir_enum_impl,std::filesystem::_Dir_enum_impl::_Creator,enum std::filesystem::directory_options const &>, COMDAT

; 247  :     is_nothrow_constructible_v<_Ty, _Types...>) {

$LN29:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	ebx, DWORD PTR [r8]
	mov	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2829 :             : _Dir_enum_impl(_STD move(_Create_data)), _Options(_Options_arg) {}

	call	??0_Dir_enum_impl@filesystem@std@@QEAA@$$QEAU_Creator@012@W4directory_options@12@@Z ; std::filesystem::_Dir_enum_impl::_Dir_enum_impl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 256  : }

	xor	eax, eax
	mov	QWORD PTR [rdi+72], rax
	mov	QWORD PTR [rdi+80], rax
	mov	QWORD PTR [rdi+88], rax
	mov	DWORD PTR [rdi+96], ebx
	mov	BYTE PTR [rdi+100], 1
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Construct_in_place@U_Recursive_dir_enum_impl@filesystem@std@@U_Creator@_Dir_enum_impl@23@AEBW4directory_options@23@@std@@YAXAEAU_Recursive_dir_enum_impl@filesystem@0@$$QEAU_Creator@_Dir_enum_impl@20@AEBW4directory_options@20@@Z ENDP ; std::_Construct_in_place<std::filesystem::_Recursive_dir_enum_impl,std::filesystem::_Dir_enum_impl::_Creator,enum std::filesystem::directory_options const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$destroy_at@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@YAXQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z
_TEXT	SEGMENT
_Location$ = 8
??$destroy_at@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@YAXQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z PROC ; std::destroy_at<AINBNodeDefMgr::NodeDef::ImmediateParam>, COMDAT

; 314  : _CONSTEXPR20 void destroy_at(_Ty* const _Location) noexcept /* strengthened */ {

	jmp	??1ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ
??$destroy_at@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@YAXQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z ENDP ; std::destroy_at<AINBNodeDefMgr::NodeDef::ImmediateParam>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@UImmediateParam@NodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX$$QEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@UImmediateParam@NodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX$$QEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Emplace_back<AINBNodeDefMgr::NodeDef::ImmediateParam>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	r8, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	r11d, r11d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1801 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	mov	r9, rdx
	xorps	xmm0, xmm0
	mov	r10, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [r8], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [r8+16], r11

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [r8+24], r11

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [r8], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [r8+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rdx+16], r11
	mov	QWORD PTR [rdx+24], 15
	mov	BYTE PTR [rdx], r11b
	mov	eax, DWORD PTR [rdx+32]
	mov	DWORD PTR [r8+32], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [r8+40], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [r8+56], r11

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [r8+64], r11

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx+40]
	movups	XMMWORD PTR [r8+40], xmm0
	movups	xmm1, XMMWORD PTR [rdx+56]
	movups	XMMWORD PTR [r8+56], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 697  :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal()),

	mov	QWORD PTR [rdx+56], r11
	mov	QWORD PTR [rdx+64], 15
	mov	BYTE PTR [rdx+40], r11b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [rdx+88]
	mov	rcx, QWORD PTR [r9+80]
	mov	rax, QWORD PTR [r9+72]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r9+88], r11
	mov	QWORD PTR [r9+80], r11
	mov	QWORD PTR [r9+72], r11
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r8+72], rax
	mov	QWORD PTR [r8+80], rcx
	mov	QWORD PTR [r8+88], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [r10+8], 96			; 00000060H

; 1804 :     }

	ret	0
??$_Emplace_back@UImmediateParam@NodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX$$QEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Emplace_back<AINBNodeDefMgr::NodeDef::ImmediateParam>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@UImmediateParam@NodeDef@AINBNodeDefMgr@@$$V@?$_Default_allocator_traits@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@1@QEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$construct@UImmediateParam@NodeDef@AINBNodeDefMgr@@$$V@?$_Default_allocator_traits@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@1@QEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z PROC ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::construct<AINBNodeDefMgr::NodeDef::ImmediateParam>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	xorps	xmm0, xmm0
	mov	QWORD PTR [rdx+32], rax
	xorps	xmm1, xmm1
	movups	XMMWORD PTR [rdx+56], xmm0
	movups	XMMWORD PTR [rdx+80], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rdx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdx+16], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdx], al

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rdx+40], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdx+56], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdx+64], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdx+40], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rdx+72], rax
	mov	QWORD PTR [rdx+80], rax
	mov	QWORD PTR [rdx+88], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@UImmediateParam@NodeDef@AINBNodeDefMgr@@$$V@?$_Default_allocator_traits@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@1@QEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::construct<AINBNodeDefMgr::NodeDef::ImmediateParam>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@UImmediateParam@NodeDef@AINBNodeDefMgr@@U123@$0A@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@$$QEAU123@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@UImmediateParam@NodeDef@AINBNodeDefMgr@@U123@$0A@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@$$QEAU123@@Z PROC ; std::construct_at<AINBNodeDefMgr::NodeDef::ImmediateParam,AINBNodeDefMgr::NodeDef::ImmediateParam,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	r10d, r10d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

	mov	r8, rdx
	mov	r9, rcx
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], r10

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], r10

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rcx+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rdx+16], r10
	mov	QWORD PTR [rdx+24], 15
	mov	BYTE PTR [rdx], r10b
	mov	eax, DWORD PTR [rdx+32]
	mov	DWORD PTR [rcx+32], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx+40], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+56], r10

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+64], r10

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx+40]
	movups	XMMWORD PTR [rcx+40], xmm0
	movups	xmm1, XMMWORD PTR [rdx+56]
	movups	XMMWORD PTR [rcx+56], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 697  :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal()),

	mov	QWORD PTR [rdx+56], r10
	mov	QWORD PTR [rdx+64], 15
	mov	BYTE PTR [rdx+40], r10b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [r8+72]
	mov	rdx, QWORD PTR [rdx+88]
	mov	rcx, QWORD PTR [r8+80]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8+88], r10
	mov	QWORD PTR [r8+80], r10
	mov	QWORD PTR [r8+72], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r9+72], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r9+80], rcx
	mov	QWORD PTR [r9+88], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 242  : }

	ret	0
??$construct_at@UImmediateParam@NodeDef@AINBNodeDefMgr@@U123@$0A@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@$$QEAU123@@Z ENDP ; std::construct_at<AINBNodeDefMgr::NodeDef::ImmediateParam,AINBNodeDefMgr::NodeDef::ImmediateParam,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@UOutputEntry@AINBFile@@$$V@?$_Default_allocator_traits@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@SAXAEAV?$allocator@UOutputEntry@AINBFile@@@1@QEAUOutputEntry@AINBFile@@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$construct@UOutputEntry@AINBFile@@$$V@?$_Default_allocator_traits@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@SAXAEAV?$allocator@UOutputEntry@AINBFile@@@1@QEAUOutputEntry@AINBFile@@@Z PROC ; std::_Default_allocator_traits<std::allocator<AINBFile::OutputEntry> >::construct<AINBFile::OutputEntry>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	xorps	xmm0, xmm0
	mov	DWORD PTR [rdx+33], eax
	mov	WORD PTR [rdx+37], ax
	mov	BYTE PTR [rdx+39], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rdx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdx+16], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdx], al
	mov	BYTE PTR [rdx+32], al

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rdx+40], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdx+56], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdx+64], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdx+40], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@UOutputEntry@AINBFile@@$$V@?$_Default_allocator_traits@V?$allocator@UOutputEntry@AINBFile@@@std@@@std@@SAXAEAV?$allocator@UOutputEntry@AINBFile@@@1@QEAUOutputEntry@AINBFile@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<AINBFile::OutputEntry> >::construct<AINBFile::OutputEntry>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$destroy_at@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@YAXQEAUInputParam@NodeDef@AINBNodeDefMgr@@@Z
_TEXT	SEGMENT
_Location$ = 8
??$destroy_at@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@YAXQEAUInputParam@NodeDef@AINBNodeDefMgr@@@Z PROC ; std::destroy_at<AINBNodeDefMgr::NodeDef::InputParam>, COMDAT

; 314  : _CONSTEXPR20 void destroy_at(_Ty* const _Location) noexcept /* strengthened */ {

	jmp	??1InputParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ
??$destroy_at@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@YAXQEAUInputParam@NodeDef@AINBNodeDefMgr@@@Z ENDP ; std::destroy_at<AINBNodeDefMgr::NodeDef::InputParam>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAUInputParam@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAUInputParam@NodeDef@AINBNodeDefMgr@@AEAU123@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAUInputParam@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAUInputParam@NodeDef@AINBNodeDefMgr@@AEAU123@@Z PROC ; std::move<AINBNodeDefMgr::NodeDef::InputParam &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAUInputParam@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAUInputParam@NodeDef@AINBNodeDefMgr@@AEAU123@@Z ENDP ; std::move<AINBNodeDefMgr::NodeDef::InputParam &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@UInputParam@NodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX$$QEAUInputParam@NodeDef@AINBNodeDefMgr@@@Z
_TEXT	SEGMENT
this$ = 48
<_Vals_0>$ = 56
??$_Emplace_back@UInputParam@NodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX$$QEAUInputParam@NodeDef@AINBNodeDefMgr@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Emplace_back<AINBNodeDefMgr::NodeDef::InputParam>, COMDAT

; 1801 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

$LN96:
	sub	rsp, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	r9, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	r8d, r8d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1801 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	mov	r10, rdx
	xorps	xmm0, xmm0
	mov	r11, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [r9], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [r9+16], r8

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [r9+24], r8

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [r9], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [r9+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rdx+16], r8
	mov	QWORD PTR [rdx+24], 15
	mov	BYTE PTR [rdx], r8b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [r9+32], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [r9+48], r8

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [r9+56], r8

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx+32]
	movups	XMMWORD PTR [r9+32], xmm0
	movups	xmm1, XMMWORD PTR [rdx+48]
	movups	XMMWORD PTR [r9+48], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 697  :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal()),

	mov	QWORD PTR [rdx+48], r8
	mov	QWORD PTR [rdx+56], 15
	mov	BYTE PTR [rdx+32], r8b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [rdx+80]
	mov	rcx, QWORD PTR [r10+72]
	mov	rax, QWORD PTR [r10+64]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r10+80], r8
	mov	QWORD PTR [r10+72], r8
	mov	QWORD PTR [r10+64], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r9+72], rcx
	lea	rcx, QWORD PTR [r9+88]
	mov	QWORD PTR [r9+80], rdx
	lea	rdx, QWORD PTR [r10+88]
	mov	QWORD PTR [r9+64], rax
	call	??0?$variant@I_NMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VVector3F@@@std@@QEAA@$$QEAV01@@Z
	mov	ecx, DWORD PTR [r10+128]
	mov	DWORD PTR [r9+128], ecx
	movzx	eax, BYTE PTR [r10+132]
	mov	BYTE PTR [r9+132], al
	mov	eax, DWORD PTR [r10+136]
	mov	DWORD PTR [r9+136], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [r11+8], 144			; 00000090H

; 1804 :     }

	add	rsp, 40					; 00000028H
	ret	0
??$_Emplace_back@UInputParam@NodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX$$QEAUInputParam@NodeDef@AINBNodeDefMgr@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Emplace_back<AINBNodeDefMgr::NodeDef::InputParam>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@UInputParam@NodeDef@AINBNodeDefMgr@@$$V@?$_Default_allocator_traits@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@1@QEAUInputParam@NodeDef@AINBNodeDefMgr@@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$construct@UInputParam@NodeDef@AINBNodeDefMgr@@$$V@?$_Default_allocator_traits@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@1@QEAUInputParam@NodeDef@AINBNodeDefMgr@@@Z PROC ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::construct<AINBNodeDefMgr::NodeDef::InputParam>, COMDAT

; 715  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4821 :         _My_data._Mysize = 0;

	xor	eax, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	XMMWORD PTR [rdx], xmm0
	movups	XMMWORD PTR [rdx+16], xmm0
	movups	XMMWORD PTR [rdx+32], xmm0
	movups	XMMWORD PTR [rdx+48], xmm0
	movups	XMMWORD PTR [rdx+64], xmm0
	movups	XMMWORD PTR [rdx+80], xmm0
	movups	XMMWORD PTR [rdx+96], xmm0
	movups	XMMWORD PTR [rdx+112], xmm0
	movups	XMMWORD PTR [rdx+128], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdx+24], 15

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdx+48], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdx+56], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdx+32], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rdx+64], rax
	mov	QWORD PTR [rdx+72], rax
	mov	QWORD PTR [rdx+80], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	mov	DWORD PTR [rdx+88], eax

; 795  :           _Which{static_cast<_Index_t>(_Idx)} { // initialize alternative _Idx from _Args...

	mov	BYTE PTR [rdx+120], al
	mov	BYTE PTR [rdx+132], al
	mov	DWORD PTR [rdx+136], 65535		; 0000ffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@UInputParam@NodeDef@AINBNodeDefMgr@@$$V@?$_Default_allocator_traits@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@1@QEAUInputParam@NodeDef@AINBNodeDefMgr@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::construct<AINBNodeDefMgr::NodeDef::InputParam>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAUNodeDef@AINBNodeDefMgr@@@std@@YA$$QEAUNodeDef@AINBNodeDefMgr@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAUNodeDef@AINBNodeDefMgr@@@std@@YA$$QEAUNodeDef@AINBNodeDefMgr@@AEAU12@@Z PROC ; std::move<AINBNodeDefMgr::NodeDef &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAUNodeDef@AINBNodeDefMgr@@@std@@YA$$QEAUNodeDef@AINBNodeDefMgr@@AEAU12@@Z ENDP ; std::move<AINBNodeDefMgr::NodeDef &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@UNodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX$$QEAUNodeDef@AINBNodeDefMgr@@@Z
_TEXT	SEGMENT
this$ = 48
<_Vals_0>$ = 56
??$_Emplace_back@UNodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX$$QEAUNodeDef@AINBNodeDefMgr@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef> >::_Emplace_back<AINBNodeDefMgr::NodeDef>, COMDAT

; 1801 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

$LN9:
	sub	rsp, 40					; 00000028H
	mov	r11, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR [rcx+8]
	call	??0NodeDef@AINBNodeDefMgr@@QEAA@$$QEAU01@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [r11+8], 248			; 000000f8H

; 1804 :     }

	add	rsp, 40					; 00000028H
	ret	0
??$_Emplace_back@UNodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX$$QEAUNodeDef@AINBNodeDefMgr@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef> >::_Emplace_back<AINBNodeDefMgr::NodeDef>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@UNodeDef@AINBNodeDefMgr@@$$V@?$_Default_allocator_traits@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@1@QEAUNodeDef@AINBNodeDefMgr@@@Z
_TEXT	SEGMENT
__formal$dead$ = 48
_Ptr$ = 56
??$construct@UNodeDef@AINBNodeDefMgr@@$$V@?$_Default_allocator_traits@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@1@QEAUNodeDef@AINBNodeDefMgr@@@Z PROC ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef> >::construct<AINBNodeDefMgr::NodeDef>, COMDAT

; 715  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN7:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	r8d, 248				; 000000f8H
	mov	rcx, rbx
	xor	edx, edx
	call	memset
	mov	rcx, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	jmp	??0NodeDef@AINBNodeDefMgr@@QEAA@XZ
??$construct@UNodeDef@AINBNodeDefMgr@@$$V@?$_Default_allocator_traits@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@1@QEAUNodeDef@AINBNodeDefMgr@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef> >::construct<AINBNodeDefMgr::NodeDef>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@U_Find_file_handle@filesystem@std@@@std@@YAPEAU_Find_file_handle@filesystem@0@AEAU120@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@U_Find_file_handle@filesystem@std@@@std@@YAPEAU_Find_file_handle@filesystem@0@AEAU120@@Z PROC ; std::addressof<std::filesystem::_Find_file_handle>, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@U_Find_file_handle@filesystem@std@@@std@@YAPEAU_Find_file_handle@filesystem@0@AEAU120@@Z ENDP ; std::addressof<std::filesystem::_Find_file_handle>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@U_Find_file_handle@filesystem@std@@U123@$0A@@std@@YAPEAU_Find_file_handle@filesystem@0@QEAU120@$$QEAU120@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@U_Find_file_handle@filesystem@std@@U123@$0A@@std@@YAPEAU_Find_file_handle@filesystem@0@QEAU120@$$QEAU120@@Z PROC ; std::construct_at<std::filesystem::_Find_file_handle,std::filesystem::_Find_file_handle,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx], -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 591  :             : _Handle(_STD exchange(_Rhs._Handle, __std_fs_dir_handle::_Invalid)) {}

	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@U_Find_file_handle@filesystem@std@@U123@$0A@@std@@YAPEAU_Find_file_handle@filesystem@0@QEAU120@$$QEAU120@@Z ENDP ; std::construct_at<std::filesystem::_Find_file_handle,std::filesystem::_Find_file_handle,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@U_Find_file_handle@filesystem@std@@@?$_Uninitialized_backout_al@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@@std@@QEAAX$$QEAU_Find_file_handle@filesystem@1@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@U_Find_file_handle@filesystem@std@@@?$_Uninitialized_backout_al@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@@std@@QEAAX$$QEAU_Find_file_handle@filesystem@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::filesystem::_Find_file_handle> >::_Emplace_back<std::filesystem::_Find_file_handle>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	r8, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx], -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 591  :             : _Handle(_STD exchange(_Rhs._Handle, __std_fs_dir_handle::_Invalid)) {}

	mov	QWORD PTR [r8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rcx+8], 8

; 1804 :     }

	ret	0
??$_Emplace_back@U_Find_file_handle@filesystem@std@@@?$_Uninitialized_backout_al@V?$allocator@U_Find_file_handle@filesystem@std@@@std@@@std@@QEAAX$$QEAU_Find_file_handle@filesystem@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::filesystem::_Find_file_handle> >::_Emplace_back<std::filesystem::_Find_file_handle>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YAAEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@AEAW4123@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YAAEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@AEAW4123@@Z PROC ; std::forward<enum AINBNodeDefMgr::NodeDef::CategoryEnum &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YAAEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@AEAW4123@@Z ENDP ; std::forward<enum AINBNodeDefMgr::NodeDef::CategoryEnum &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@AEAW4123@@?$_Default_allocator_traits@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@1@QEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@AEAW4345@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@AEAW4123@@?$_Default_allocator_traits@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@1@QEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@AEAW4345@@Z PROC ; std::_Default_allocator_traits<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::construct<enum AINBNodeDefMgr::NodeDef::CategoryEnum,enum AINBNodeDefMgr::NodeDef::CategoryEnum &>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [rdx], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@AEAW4123@@?$_Default_allocator_traits@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@1@QEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@AEAW4345@@Z ENDP ; std::_Default_allocator_traits<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::construct<enum AINBNodeDefMgr::NodeDef::CategoryEnum,enum AINBNodeDefMgr::NodeDef::CategoryEnum &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@AEAW4123@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@AEAW4123@@Z PROC ; std::addressof<enum AINBNodeDefMgr::NodeDef::CategoryEnum>, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@AEAW4123@@Z ENDP ; std::addressof<enum AINBNodeDefMgr::NodeDef::CategoryEnum>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@W4123@$0A@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@QEAW4123@$$QEAW4123@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@W4123@$0A@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@QEAW4123@$$QEAW4123@@Z PROC ; std::construct_at<enum AINBNodeDefMgr::NodeDef::CategoryEnum,enum AINBNodeDefMgr::NodeDef::CategoryEnum,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@W4123@$0A@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@QEAW4123@$$QEAW4123@@Z ENDP ; std::construct_at<enum AINBNodeDefMgr::NodeDef::CategoryEnum,enum AINBNodeDefMgr::NodeDef::CategoryEnum,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX$$QEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX$$QEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Emplace_back<enum AINBNodeDefMgr::NodeDef::CategoryEnum>, COMDAT

; 1802 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	r8, QWORD PTR [rcx+8]
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [r8], al

; 1803 :         ++_Last;

	inc	QWORD PTR [rcx+8]

; 1804 :     }

	ret	0
??$_Emplace_back@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAX$$QEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Emplace_back<enum AINBNodeDefMgr::NodeDef::CategoryEnum>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA$$QEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA$$QEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAV10@@Z PROC ; std::move<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA$$QEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAV10@@Z ENDP ; std::move<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAX$$QEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAX$$QEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Emplace_back<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 697  :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal()),

	mov	r10, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r11d, r11d
	mov	r9, QWORD PTR [rdx+16]

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]
	mov	rax, QWORD PTR [rdx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], r11
	mov	QWORD PTR [rdx+8], r11
	mov	QWORD PTR [rdx], r11
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r10], rax
	mov	QWORD PTR [r10+8], r8
	mov	QWORD PTR [r10+16], r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rcx+8], 24

; 1804 :     }

	ret	0
??$_Emplace_back@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAX$$QEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Emplace_back<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@$$V@?$_Default_allocator_traits@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$construct@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@$$V@?$_Default_allocator_traits@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::construct<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	QWORD PTR [rdx+8], rax
	mov	QWORD PTR [rdx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@$$V@?$_Default_allocator_traits@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::construct<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YAAEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YAAEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAV10@@Z PROC ; std::forward<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YAAEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAV10@@Z ENDP ; std::forward<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@AEAV31@@Z
_TEXT	SEGMENT
_Guard$1 = 32
_Backout$2 = 40
__$ArrayPad$ = 64
__formal$dead$ = 112
_Ptr$ = 120
<_Args_0>$ = 128
??$construct@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@AEAV31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::construct<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > &>, COMDAT

; 715  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN71:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r15, r8
	mov	r14, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	QWORD PTR [rdx+8], rax
	mov	QWORD PTR [rdx+16], rax

; 685  :         const auto _Count       = static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst);

	mov	rbx, QWORD PTR [r8+8]
	sub	rbx, QWORD PTR [r8]
	sar	rbx, 4
	mov	rax, -8198552921648689607		; 8e38e38e38e38e39H
	imul	rbx, rax

; 2065 :         if (_Count != 0) {

	test	rbx, rbx
	je	$LN54@construct

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 128102389400760775			; 01c71c71c71c71c7H
	cmp	rbx, rax
	ja	$LN69@construct

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdx, rbx
	call	?allocate@?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAPEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z ; std::allocator<AINBNodeDefMgr::NodeDef::InputParam>::allocate
	mov	rdi, rax

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [r14], rax

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [r14+8], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [rbx+rbx*8]
	shl	rcx, 4
	add	rcx, rax
	mov	QWORD PTR [r14+16], rcx

; 2067 :             _Tidy_guard<vector> _Guard{this};

	mov	QWORD PTR _Guard$1[rsp], r14

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rsi, QWORD PTR [r15+8]
	mov	rbx, QWORD PTR [r15]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _Backout$2[rsp], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR _Backout$2[rsp], rax
	mov	QWORD PTR _Backout$2[rsp+8], rax
	mov	QWORD PTR _Backout$2[rsp+16], r14

; 1855 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rbx, rsi
	je	SHORT $LN23@construct
$LL24@construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rdx, rbx
	mov	rcx, rdi
	call	??0InputParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rdi, 144				; 00000090H
	mov	QWORD PTR _Backout$2[rsp+8], rdi

; 1855 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	rbx, 144				; 00000090H
	cmp	rbx, rsi
	jne	SHORT $LL24@construct
$LN23@construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	QWORD PTR [r14+8], rdi
$LN54@construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+112]
	mov	rsi, QWORD PTR [rsp+136]
	add	rsp, 80					; 00000050H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
$LN69@construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Xlength
	int	3
$LN67@construct:
??$construct@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@AEAV31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::construct<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Guard$1 = 32
_Backout$2 = 40
__$ArrayPad$ = 64
__formal$dead$ = 112
_Ptr$ = 120
<_Args_0>$ = 128
?dtor$0@?0???$construct@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@AEAV31@@Z@4HA PROC ; `std::_Default_allocator_traits<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::construct<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > &>'::`1'::dtor$0
	lea	rcx, QWORD PTR _Guard$1[rdx]
	jmp	??1?$_Tidy_guard@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >::~_Tidy_guard<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >
?dtor$0@?0???$construct@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@AEAV31@@Z@4HA ENDP ; `std::_Default_allocator_traits<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::construct<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Guard$1 = 32
_Backout$2 = 40
__$ArrayPad$ = 64
__formal$dead$ = 112
_Ptr$ = 120
<_Args_0>$ = 128
?dtor$1@?0???$construct@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@AEAV31@@Z@4HA PROC ; `std::_Default_allocator_traits<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::construct<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > &>'::`1'::dtor$1
	lea	rcx, QWORD PTR _Backout$2[rdx]
	jmp	??1?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::~_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >
?dtor$1@?0???$construct@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@AEAV31@@Z@4HA ENDP ; `std::_Default_allocator_traits<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::construct<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > &>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA$$QEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA$$QEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAV10@@Z PROC ; std::move<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA$$QEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAV10@@Z ENDP ; std::move<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAX$$QEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAX$$QEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Emplace_back<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 697  :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal()),

	mov	r10, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r11d, r11d
	mov	r9, QWORD PTR [rdx+16]

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]
	mov	rax, QWORD PTR [rdx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], r11
	mov	QWORD PTR [rdx+8], r11
	mov	QWORD PTR [rdx], r11
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r10], rax
	mov	QWORD PTR [r10+8], r8
	mov	QWORD PTR [r10+16], r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rcx+8], 24

; 1804 :     }

	ret	0
??$_Emplace_back@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAAX$$QEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Emplace_back<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@$$V@?$_Default_allocator_traits@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$construct@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@$$V@?$_Default_allocator_traits@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::construct<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	QWORD PTR [rdx+8], rax
	mov	QWORD PTR [rdx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@$$V@?$_Default_allocator_traits@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::construct<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YAAEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YAAEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAV10@@Z PROC ; std::forward<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YAAEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAV10@@Z ENDP ; std::forward<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@AEAV31@@Z
_TEXT	SEGMENT
_Guard$1 = 32
$T2 = 40
_Backout$3 = 48
__$ArrayPad$ = 72
__formal$dead$ = 112
_Ptr$ = 120
<_Args_0>$ = 128
??$construct@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@AEAV31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::construct<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > &>, COMDAT

; 715  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN76:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r14, r8
	mov	rsi, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	QWORD PTR [rdx+8], rax
	mov	QWORD PTR [rdx+16], rax

; 685  :         const auto _Count       = static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst);

	mov	rbx, QWORD PTR [r8+8]
	sub	rbx, QWORD PTR [r8]
	sar	rbx, 5
	mov	rax, -6148914691236517205		; aaaaaaaaaaaaaaabH
	imul	rbx, rax

; 2065 :         if (_Count != 0) {

	test	rbx, rbx
	je	$LN59@construct

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 192153584101141162			; 02aaaaaaaaaaaaaaH
	cmp	rbx, rax
	ja	$LN74@construct

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdx, rbx
	call	?allocate@?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z ; std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>::allocate
	mov	rdi, rax

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rsi], rax

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [rsi+8], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [rbx+rbx*2]
	shl	rcx, 5
	add	rcx, rax
	mov	QWORD PTR [rsi+16], rcx

; 2067 :             _Tidy_guard<vector> _Guard{this};

	mov	QWORD PTR _Guard$1[rsp], rsi

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rbp, QWORD PTR [r14+8]
	mov	rbx, QWORD PTR [r14]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _Backout$3[rsp], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR _Backout$3[rsp], rax
	mov	QWORD PTR _Backout$3[rsp+8], rax
	mov	QWORD PTR _Backout$3[rsp+16], rsi

; 1855 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rbx, rbp
	je	SHORT $LN23@construct
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1983 :         pointer& _Mylast  = _My_data._Mylast;

	add	rbx, 40					; 00000028H
	npad	10
$LL24@construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T2[rsp], rdi
	lea	rdx, QWORD PTR [rbx-40]
	mov	rcx, rdi
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, DWORD PTR [rbx-8]
	mov	DWORD PTR [rdi+32], eax
	lea	rcx, QWORD PTR [rdi+40]
	mov	rdx, rbx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rdi+72]
	lea	rdx, QWORD PTR [rbx+32]
	call	??0?$vector@W4FlagsStruct@AINBFile@@V?$allocator@W4FlagsStruct@AINBFile@@@std@@@std@@QEAA@AEBV01@@Z ; std::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rdi, 96					; 00000060H
	mov	QWORD PTR _Backout$3[rsp+8], rdi

; 1855 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	rbx, 96					; 00000060H
	lea	rax, QWORD PTR [rbx-40]
	cmp	rax, rbp
	jne	SHORT $LL24@construct
$LN23@construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	QWORD PTR [rsi+8], rdi
$LN59@construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+112]
	mov	rbp, QWORD PTR [rsp+136]
	add	rsp, 80					; 00000050H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN74@construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Xlength
	int	3
$LN72@construct:
??$construct@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@AEAV31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::construct<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Guard$1 = 32
$T2 = 40
_Backout$3 = 48
__$ArrayPad$ = 72
__formal$dead$ = 112
_Ptr$ = 120
<_Args_0>$ = 128
?dtor$0@?0???$construct@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@AEAV31@@Z@4HA PROC ; `std::_Default_allocator_traits<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::construct<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > &>'::`1'::dtor$0
	lea	rcx, QWORD PTR _Guard$1[rdx]
	jmp	??1?$_Tidy_guard@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >::~_Tidy_guard<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >
?dtor$0@?0???$construct@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@AEAV31@@Z@4HA ENDP ; `std::_Default_allocator_traits<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::construct<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Guard$1 = 32
$T2 = 40
_Backout$3 = 48
__$ArrayPad$ = 72
__formal$dead$ = 112
_Ptr$ = 120
<_Args_0>$ = 128
?dtor$1@?0???$construct@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@AEAV31@@Z@4HA PROC ; `std::_Default_allocator_traits<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::construct<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > &>'::`1'::dtor$1
	lea	rcx, QWORD PTR _Backout$3[rdx]
	jmp	??1?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::~_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >
?dtor$1@?0???$construct@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@AEAV31@@Z@4HA ENDP ; `std::_Default_allocator_traits<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::construct<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > &>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Guard$1 = 32
$T2 = 40
_Backout$3 = 48
__$ArrayPad$ = 72
__formal$dead$ = 112
_Ptr$ = 120
<_Args_0>$ = 128
?dtor$2@?0???$construct@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@AEAV31@@Z@4HA PROC ; `std::_Default_allocator_traits<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::construct<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > &>'::`1'::dtor$2
	mov	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0???$construct@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@AEAV31@@Z@4HA ENDP ; `std::_Default_allocator_traits<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::construct<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > &>'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Guard$1 = 32
$T2 = 40
_Backout$3 = 48
__$ArrayPad$ = 72
__formal$dead$ = 112
_Ptr$ = 120
<_Args_0>$ = 128
?dtor$3@?0???$construct@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@AEAV31@@Z@4HA PROC ; `std::_Default_allocator_traits<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::construct<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > &>'::`1'::dtor$3
	mov	rcx, QWORD PTR $T2[rdx]
	add	rcx, 40					; 00000028H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0???$construct@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@AEAV31@@Z@4HA ENDP ; `std::_Default_allocator_traits<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::construct<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > &>'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@AEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAXAEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z
_TEXT	SEGMENT
$T1 = 48
this$ = 48
<_Vals_0>$ = 56
??$_Emplace_back@AEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAXAEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Emplace_back<AINBNodeDefMgr::NodeDef::ImmediateParam &>, COMDAT

; 1801 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

$LN14:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx
	mov	rsi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rbx, QWORD PTR [rcx+8]
	mov	QWORD PTR $T1[rsp], rbx
	mov	rcx, rbx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, DWORD PTR [rdi+32]
	mov	DWORD PTR [rbx+32], eax
	lea	rcx, QWORD PTR [rbx+40]
	lea	rdx, QWORD PTR [rdi+40]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rbx+72]
	lea	rdx, QWORD PTR [rdi+72]
	call	??0?$vector@W4FlagsStruct@AINBFile@@V?$allocator@W4FlagsStruct@AINBFile@@@std@@@std@@QEAA@AEBV01@@Z ; std::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rsi+8], 96			; 00000060H

; 1804 :     }

	mov	rbx, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Emplace_back@AEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAXAEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Emplace_back<AINBNodeDefMgr::NodeDef::ImmediateParam &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
this$ = 48
<_Vals_0>$ = 56
?dtor$0@?0???$_Emplace_back@AEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAXAEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z@4HA PROC ; `std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Emplace_back<AINBNodeDefMgr::NodeDef::ImmediateParam &>'::`1'::dtor$0
	mov	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$_Emplace_back@AEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAXAEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z@4HA ENDP ; `std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Emplace_back<AINBNodeDefMgr::NodeDef::ImmediateParam &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
this$ = 48
<_Vals_0>$ = 56
?dtor$1@?0???$_Emplace_back@AEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAXAEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z@4HA PROC ; `std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Emplace_back<AINBNodeDefMgr::NodeDef::ImmediateParam &>'::`1'::dtor$1
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 40					; 00000028H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0???$_Emplace_back@AEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAXAEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z@4HA ENDP ; `std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Emplace_back<AINBNodeDefMgr::NodeDef::ImmediateParam &>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@AEAUInputParam@NodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAXAEAUInputParam@NodeDef@AINBNodeDefMgr@@@Z
_TEXT	SEGMENT
this$ = 48
<_Vals_0>$ = 56
??$_Emplace_back@AEAUInputParam@NodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAXAEAUInputParam@NodeDef@AINBNodeDefMgr@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Emplace_back<AINBNodeDefMgr::NodeDef::InputParam &>, COMDAT

; 1801 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR [rcx+8]
	call	??0InputParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rbx+8], 144			; 00000090H

; 1804 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Emplace_back@AEAUInputParam@NodeDef@AINBNodeDefMgr@@@?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAAXAEAUInputParam@NodeDef@AINBNodeDefMgr@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Emplace_back<AINBNodeDefMgr::NodeDef::InputParam &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_GImmediateParam@NodeDef@AINBNodeDefMgr@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_GImmediateParam@NodeDef@AINBNodeDefMgr@@QEAAPEAXI@Z PROC ; AINBNodeDefMgr::NodeDef::ImmediateParam::`scalar deleting destructor', COMDAT
$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	call	??1ImmediateParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_GImmediateParam@NodeDef@AINBNodeDefMgr@@QEAAPEAXI@Z ENDP ; AINBNodeDefMgr::NodeDef::ImmediateParam::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_GInputParam@NodeDef@AINBNodeDefMgr@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_GInputParam@NodeDef@AINBNodeDefMgr@@QEAAPEAXI@Z PROC	; AINBNodeDefMgr::NodeDef::InputParam::`scalar deleting destructor', COMDAT
$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	call	??1InputParam@NodeDef@AINBNodeDefMgr@@QEAA@XZ
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_GInputParam@NodeDef@AINBNodeDefMgr@@QEAAPEAXI@Z ENDP	; AINBNodeDefMgr::NodeDef::InputParam::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@U_Recursive_dir_enum_impl@filesystem@std@@U_Creator@_Dir_enum_impl@23@AEBW4directory_options@23@$0A@@std@@YAPEAU_Recursive_dir_enum_impl@filesystem@0@QEAU120@$$QEAU_Creator@_Dir_enum_impl@20@AEBW4directory_options@20@@Z
_TEXT	SEGMENT
_Location$ = 48
<_Args_0>$ = 56
<_Args_1>$ = 64
??$construct_at@U_Recursive_dir_enum_impl@filesystem@std@@U_Creator@_Dir_enum_impl@23@AEBW4directory_options@23@$0A@@std@@YAPEAU_Recursive_dir_enum_impl@filesystem@0@QEAU120@$$QEAU_Creator@_Dir_enum_impl@20@AEBW4directory_options@20@@Z PROC ; std::construct_at<std::filesystem::_Recursive_dir_enum_impl,std::filesystem::_Dir_enum_impl::_Creator,enum std::filesystem::directory_options const &,0>, COMDAT

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN15:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	ebx, DWORD PTR [r8]
	mov	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2829 :             : _Dir_enum_impl(_STD move(_Create_data)), _Options(_Options_arg) {}

	call	??0_Dir_enum_impl@filesystem@std@@QEAA@$$QEAU_Creator@012@W4directory_options@12@@Z ; std::filesystem::_Dir_enum_impl::_Dir_enum_impl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2829 :             : _Dir_enum_impl(_STD move(_Create_data)), _Options(_Options_arg) {}

	mov	DWORD PTR [rdi+96], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 242  : }

	mov	rbx, QWORD PTR [rsp+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rdi+72], rax
	mov	QWORD PTR [rdi+80], rax
	mov	QWORD PTR [rdi+88], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2716 :         bool _Recursion_pending    = true;

	mov	BYTE PTR [rdi+100], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 242  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$construct_at@U_Recursive_dir_enum_impl@filesystem@std@@U_Creator@_Dir_enum_impl@23@AEBW4directory_options@23@$0A@@std@@YAPEAU_Recursive_dir_enum_impl@filesystem@0@QEAU120@$$QEAU_Creator@_Dir_enum_impl@20@AEBW4directory_options@20@@Z ENDP ; std::construct_at<std::filesystem::_Recursive_dir_enum_impl,std::filesystem::_Dir_enum_impl::_Creator,enum std::filesystem::directory_options const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@UImmediateParam@NodeDef@AINBNodeDefMgr@@$$V$0A@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@@Z
_TEXT	SEGMENT
_Location$ = 8
??$construct_at@UImmediateParam@NodeDef@AINBNodeDefMgr@@$$V$0A@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@@Z PROC ; std::construct_at<AINBNodeDefMgr::NodeDef::ImmediateParam,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	xorps	xmm0, xmm0
	mov	QWORD PTR [rcx+32], rax
	xorps	xmm1, xmm1
	movups	XMMWORD PTR [rcx+56], xmm0
	movups	XMMWORD PTR [rcx+80], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], al

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx+40], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+56], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+64], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx+40], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+72], rax
	mov	QWORD PTR [rcx+80], rax
	mov	QWORD PTR [rcx+88], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@UImmediateParam@NodeDef@AINBNodeDefMgr@@$$V$0A@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@@Z ENDP ; std::construct_at<AINBNodeDefMgr::NodeDef::ImmediateParam,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@UOutputEntry@AINBFile@@$$V$0A@@std@@YAPEAUOutputEntry@AINBFile@@QEAU12@@Z
_TEXT	SEGMENT
_Location$ = 8
??$construct_at@UOutputEntry@AINBFile@@$$V$0A@@std@@YAPEAUOutputEntry@AINBFile@@QEAU12@@Z PROC ; std::construct_at<AINBFile::OutputEntry,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	xorps	xmm0, xmm0
	mov	DWORD PTR [rcx+33], eax
	mov	WORD PTR [rcx+37], ax
	mov	BYTE PTR [rcx+39], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], al
	mov	BYTE PTR [rcx+32], al

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx+40], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+56], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+64], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx+40], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@UOutputEntry@AINBFile@@$$V$0A@@std@@YAPEAUOutputEntry@AINBFile@@QEAU12@@Z ENDP ; std::construct_at<AINBFile::OutputEntry,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAUInputParam@NodeDef@AINBNodeDefMgr@@AEAU123@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAUInputParam@NodeDef@AINBNodeDefMgr@@AEAU123@@Z PROC ; std::forward<AINBNodeDefMgr::NodeDef::InputParam>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAUInputParam@NodeDef@AINBNodeDefMgr@@AEAU123@@Z ENDP ; std::forward<AINBNodeDefMgr::NodeDef::InputParam>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@UInputParam@NodeDef@AINBNodeDefMgr@@U123@@?$_Default_allocator_traits@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@1@QEAUInputParam@NodeDef@AINBNodeDefMgr@@$$QEAU345@@Z
_TEXT	SEGMENT
__formal$dead$ = 48
_Ptr$ = 56
<_Args_0>$ = 64
??$construct@UInputParam@NodeDef@AINBNodeDefMgr@@U123@@?$_Default_allocator_traits@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@1@QEAUInputParam@NodeDef@AINBNodeDefMgr@@$$QEAU345@@Z PROC ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::construct<AINBNodeDefMgr::NodeDef::InputParam,AINBNodeDefMgr::NodeDef::InputParam>, COMDAT

; 715  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN94:
	sub	rsp, 40					; 00000028H
	mov	r9, r8
	mov	r10, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	r8d, r8d
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rdx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rdx+16], r8

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rdx+24], r8

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r9]
	movups	XMMWORD PTR [rdx], xmm0
	movups	xmm1, XMMWORD PTR [r9+16]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rdx+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [r9+16], r8
	mov	QWORD PTR [r9+24], 15
	mov	BYTE PTR [r9], r8b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rdx+32], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rdx+48], r8

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rdx+56], r8

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r9+32]
	movups	XMMWORD PTR [rdx+32], xmm0
	movups	xmm1, XMMWORD PTR [r9+48]
	movups	XMMWORD PTR [rdx+48], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 697  :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal()),

	mov	QWORD PTR [r9+48], r8
	mov	QWORD PTR [r9+56], 15
	mov	BYTE PTR [r9+32], r8b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [r9+80]
	mov	rcx, QWORD PTR [r9+72]
	mov	rax, QWORD PTR [r9+64]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r9+80], r8
	mov	QWORD PTR [r9+72], r8
	mov	QWORD PTR [r9+64], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r10+72], rcx
	lea	rcx, QWORD PTR [r10+88]
	mov	QWORD PTR [r10+80], rdx
	lea	rdx, QWORD PTR [r9+88]
	mov	QWORD PTR [r10+64], rax
	call	??0?$variant@I_NMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VVector3F@@@std@@QEAA@$$QEAV01@@Z
	mov	ecx, DWORD PTR [r9+128]
	mov	DWORD PTR [r10+128], ecx
	movzx	eax, BYTE PTR [r9+132]
	mov	BYTE PTR [r10+132], al
	mov	eax, DWORD PTR [r9+136]
	mov	DWORD PTR [r10+136], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$construct@UInputParam@NodeDef@AINBNodeDefMgr@@U123@@?$_Default_allocator_traits@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@1@QEAUInputParam@NodeDef@AINBNodeDefMgr@@$$QEAU345@@Z ENDP ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::construct<AINBNodeDefMgr::NodeDef::InputParam,AINBNodeDefMgr::NodeDef::InputParam>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@UInputParam@NodeDef@AINBNodeDefMgr@@$$V$0A@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@QEAU123@@Z
_TEXT	SEGMENT
_Location$ = 8
??$construct_at@UInputParam@NodeDef@AINBNodeDefMgr@@$$V$0A@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@QEAU123@@Z PROC ; std::construct_at<AINBNodeDefMgr::NodeDef::InputParam,0>, COMDAT

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4821 :         _My_data._Mysize = 0;

	xor	eax, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	XMMWORD PTR [rcx], xmm0
	movups	XMMWORD PTR [rcx+16], xmm0
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	XMMWORD PTR [rcx+48], xmm0
	movups	XMMWORD PTR [rcx+64], xmm0
	movups	XMMWORD PTR [rcx+80], xmm0
	movups	XMMWORD PTR [rcx+96], xmm0
	movups	XMMWORD PTR [rcx+112], xmm0
	movups	XMMWORD PTR [rcx+128], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+48], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+56], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx+32], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+64], rax
	mov	QWORD PTR [rcx+72], rax
	mov	QWORD PTR [rcx+80], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	mov	DWORD PTR [rcx+88], eax

; 795  :           _Which{static_cast<_Index_t>(_Idx)} { // initialize alternative _Idx from _Args...

	mov	BYTE PTR [rcx+120], al
	mov	BYTE PTR [rcx+132], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rcx
	mov	DWORD PTR [rcx+136], 65535		; 0000ffffH

; 242  : }

	ret	0
??$construct_at@UInputParam@NodeDef@AINBNodeDefMgr@@$$V$0A@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@QEAU123@@Z ENDP ; std::construct_at<AINBNodeDefMgr::NodeDef::InputParam,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@UNodeDef@AINBNodeDefMgr@@@std@@YA$$QEAUNodeDef@AINBNodeDefMgr@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@UNodeDef@AINBNodeDefMgr@@@std@@YA$$QEAUNodeDef@AINBNodeDefMgr@@AEAU12@@Z PROC ; std::forward<AINBNodeDefMgr::NodeDef>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@UNodeDef@AINBNodeDefMgr@@@std@@YA$$QEAUNodeDef@AINBNodeDefMgr@@AEAU12@@Z ENDP ; std::forward<AINBNodeDefMgr::NodeDef>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@UNodeDef@AINBNodeDefMgr@@U12@@?$_Default_allocator_traits@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@1@QEAUNodeDef@AINBNodeDefMgr@@$$QEAU34@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@UNodeDef@AINBNodeDefMgr@@U12@@?$_Default_allocator_traits@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@1@QEAUNodeDef@AINBNodeDefMgr@@$$QEAU34@@Z PROC ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef> >::construct<AINBNodeDefMgr::NodeDef,AINBNodeDefMgr::NodeDef>, COMDAT

; 715  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

	mov	rcx, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rdx, r8
	jmp	??0NodeDef@AINBNodeDefMgr@@QEAA@$$QEAU01@@Z
??$construct@UNodeDef@AINBNodeDefMgr@@U12@@?$_Default_allocator_traits@V?$allocator@UNodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UNodeDef@AINBNodeDefMgr@@@1@QEAUNodeDef@AINBNodeDefMgr@@$$QEAU34@@Z ENDP ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef> >::construct<AINBNodeDefMgr::NodeDef,AINBNodeDefMgr::NodeDef>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@UNodeDef@AINBNodeDefMgr@@$$V$0A@@std@@YAPEAUNodeDef@AINBNodeDefMgr@@QEAU12@@Z
_TEXT	SEGMENT
_Location$ = 48
??$construct_at@UNodeDef@AINBNodeDefMgr@@$$V$0A@@std@@YAPEAUNodeDef@AINBNodeDefMgr@@QEAU12@@Z PROC ; std::construct_at<AINBNodeDefMgr::NodeDef,0>, COMDAT

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN5:
	push	rbx
	sub	rsp, 32					; 00000020H

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	edx, edx
	mov	r8d, 248				; 000000f8H
	mov	rbx, rcx
	call	memset
	mov	rcx, rbx

; 242  : }

	add	rsp, 32					; 00000020H
	pop	rbx

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	jmp	??0NodeDef@AINBNodeDefMgr@@QEAA@XZ
??$construct_at@UNodeDef@AINBNodeDefMgr@@$$V$0A@@std@@YAPEAUNodeDef@AINBNodeDefMgr@@QEAU12@@Z ENDP ; std::construct_at<AINBNodeDefMgr::NodeDef,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@AEAW4123@$0A@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@QEAW4123@AEAW4123@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@AEAW4123@$0A@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@QEAW4123@AEAW4123@@Z PROC ; std::construct_at<enum AINBNodeDefMgr::NodeDef::CategoryEnum,enum AINBNodeDefMgr::NodeDef::CategoryEnum &,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@AEAW4123@$0A@@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@QEAW4123@AEAW4123@@Z ENDP ; std::construct_at<enum AINBNodeDefMgr::NodeDef::CategoryEnum,enum AINBNodeDefMgr::NodeDef::CategoryEnum &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA$$QEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA$$QEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAV10@@Z PROC ; std::forward<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA$$QEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAV10@@Z ENDP ; std::forward<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@$$QEAV31@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@$$QEAV31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::construct<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r9, QWORD PTR [r8+16]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r10d, r10d

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [r8+8]
	mov	rax, QWORD PTR [r8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8+16], r10
	mov	QWORD PTR [r8+8], r10
	mov	QWORD PTR [r8], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rdx], rax
	mov	QWORD PTR [rdx+8], rcx
	mov	QWORD PTR [rdx+16], r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@$$QEAV31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::construct<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@$$V$0A@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@@Z
_TEXT	SEGMENT
_Location$ = 8
??$construct_at@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@$$V$0A@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@@Z PROC ; std::construct_at<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@$$V$0A@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@@Z ENDP ; std::construct_at<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@$0A@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV10@@Z
_TEXT	SEGMENT
_Guard$1 = 32
_Backout$2 = 40
__$ArrayPad$ = 64
_Location$ = 112
<_Args_0>$ = 120
??$construct_at@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@$0A@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV10@@Z PROC ; std::construct_at<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > &,0>, COMDAT

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN68:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r14, rdx
	mov	rsi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 685  :         const auto _Count       = static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst);

	mov	rbx, QWORD PTR [rdx+8]
	sub	rbx, QWORD PTR [rdx]
	sar	rbx, 4
	mov	rax, -8198552921648689607		; 8e38e38e38e38e39H
	imul	rbx, rax

; 2065 :         if (_Count != 0) {

	test	rbx, rbx
	je	$LN52@construct_

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 128102389400760775			; 01c71c71c71c71c7H
	cmp	rbx, rax
	ja	$LN66@construct_

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdx, rbx
	call	?allocate@?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAPEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z ; std::allocator<AINBNodeDefMgr::NodeDef::InputParam>::allocate
	mov	rdi, rax

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rsi], rax

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [rsi+8], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rax, QWORD PTR [rbx+rbx*8]
	shl	rax, 4
	add	rax, rdi
	mov	QWORD PTR [rsi+16], rax

; 2067 :             _Tidy_guard<vector> _Guard{this};

	mov	QWORD PTR _Guard$1[rsp], rsi

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rbp, QWORD PTR [r14+8]
	mov	rbx, QWORD PTR [r14]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _Backout$2[rsp], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR _Backout$2[rsp], rdi
	mov	QWORD PTR _Backout$2[rsp+8], rdi
	mov	QWORD PTR _Backout$2[rsp+16], rsi

; 1855 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rbx, rbp
	je	SHORT $LN21@construct_
$LL22@construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rdx, rbx
	mov	rcx, rdi
	call	??0InputParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rdi, 144				; 00000090H
	mov	QWORD PTR _Backout$2[rsp+8], rdi

; 1855 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	rbx, 144				; 00000090H
	cmp	rbx, rbp
	jne	SHORT $LL22@construct_
$LN21@construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	QWORD PTR [rsi+8], rdi
$LN52@construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rsi

; 242  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [r11+48]
	mov	rbp, QWORD PTR [r11+56]
	mov	rsp, r11
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN66@construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Xlength
	int	3
$LN64@construct_:
??$construct_at@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@$0A@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV10@@Z ENDP ; std::construct_at<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Guard$1 = 32
_Backout$2 = 40
__$ArrayPad$ = 64
_Location$ = 112
<_Args_0>$ = 120
?dtor$0@?0???$construct_at@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@$0A@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV10@@Z@4HA PROC ; `std::construct_at<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > &,0>'::`1'::dtor$0
	lea	rcx, QWORD PTR _Guard$1[rdx]
	jmp	??1?$_Tidy_guard@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >::~_Tidy_guard<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >
?dtor$0@?0???$construct_at@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@$0A@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV10@@Z@4HA ENDP ; `std::construct_at<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > &,0>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Guard$1 = 32
_Backout$2 = 40
__$ArrayPad$ = 64
_Location$ = 112
<_Args_0>$ = 120
?dtor$1@?0???$construct_at@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@$0A@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV10@@Z@4HA PROC ; `std::construct_at<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > &,0>'::`1'::dtor$1
	lea	rcx, QWORD PTR _Backout$2[rdx]
	jmp	??1?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::~_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >
?dtor$1@?0???$construct_at@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@$0A@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV10@@Z@4HA ENDP ; `std::construct_at<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > &,0>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA$$QEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA$$QEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAV10@@Z PROC ; std::forward<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA$$QEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAV10@@Z ENDP ; std::forward<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@$$QEAV31@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@$$QEAV31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::construct<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r9, QWORD PTR [r8+16]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r10d, r10d

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [r8+8]
	mov	rax, QWORD PTR [r8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8+16], r10
	mov	QWORD PTR [r8+8], r10
	mov	QWORD PTR [r8], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rdx], rax
	mov	QWORD PTR [rdx+8], rcx
	mov	QWORD PTR [rdx+16], r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@QEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@$$QEAV31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::construct<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@$$V$0A@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@@Z
_TEXT	SEGMENT
_Location$ = 8
??$construct_at@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@$$V$0A@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@@Z PROC ; std::construct_at<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@$$V$0A@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@@Z ENDP ; std::construct_at<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@$0A@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV10@@Z
_TEXT	SEGMENT
_Guard$1 = 32
$T2 = 40
_Backout$3 = 48
__$ArrayPad$ = 72
_Location$ = 112
<_Args_0>$ = 120
??$construct_at@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@$0A@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV10@@Z PROC ; std::construct_at<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > &,0>, COMDAT

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN73:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r14, rdx
	mov	rsi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 685  :         const auto _Count       = static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst);

	mov	rbx, QWORD PTR [rdx+8]
	sub	rbx, QWORD PTR [rdx]
	sar	rbx, 5
	mov	rax, -6148914691236517205		; aaaaaaaaaaaaaaabH
	imul	rbx, rax

; 2065 :         if (_Count != 0) {

	test	rbx, rbx
	je	$LN57@construct_

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 192153584101141162			; 02aaaaaaaaaaaaaaH
	cmp	rbx, rax
	ja	$LN71@construct_

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdx, rbx
	call	?allocate@?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z ; std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>::allocate
	mov	rdi, rax

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rsi], rax

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [rsi+8], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rax, QWORD PTR [rbx+rbx*2]
	shl	rax, 5
	add	rax, rdi
	mov	QWORD PTR [rsi+16], rax

; 2067 :             _Tidy_guard<vector> _Guard{this};

	mov	QWORD PTR _Guard$1[rsp], rsi

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rbp, QWORD PTR [r14+8]
	mov	rbx, QWORD PTR [r14]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _Backout$3[rsp], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR _Backout$3[rsp], rdi
	mov	QWORD PTR _Backout$3[rsp+8], rdi
	mov	QWORD PTR _Backout$3[rsp+16], rsi

; 1855 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rbx, rbp
	je	SHORT $LN21@construct_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1983 :         pointer& _Mylast  = _My_data._Mylast;

	add	rbx, 40					; 00000028H
	npad	10
$LL22@construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T2[rsp], rdi
	lea	rdx, QWORD PTR [rbx-40]
	mov	rcx, rdi
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, DWORD PTR [rbx-8]
	mov	DWORD PTR [rdi+32], eax
	lea	rcx, QWORD PTR [rdi+40]
	mov	rdx, rbx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rdi+72]
	lea	rdx, QWORD PTR [rbx+32]
	call	??0?$vector@W4FlagsStruct@AINBFile@@V?$allocator@W4FlagsStruct@AINBFile@@@std@@@std@@QEAA@AEBV01@@Z ; std::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rdi, 96					; 00000060H
	mov	QWORD PTR _Backout$3[rsp+8], rdi

; 1855 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	rbx, 96					; 00000060H
	lea	rcx, QWORD PTR [rbx-40]
	cmp	rcx, rbp
	jne	SHORT $LL22@construct_
$LN21@construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	QWORD PTR [rsi+8], rdi
$LN57@construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rsi

; 242  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [r11+48]
	mov	rbp, QWORD PTR [r11+56]
	mov	rsp, r11
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN71@construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Xlength
	int	3
$LN69@construct_:
??$construct_at@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@$0A@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV10@@Z ENDP ; std::construct_at<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Guard$1 = 32
$T2 = 40
_Backout$3 = 48
__$ArrayPad$ = 72
_Location$ = 112
<_Args_0>$ = 120
?dtor$0@?0???$construct_at@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@$0A@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV10@@Z@4HA PROC ; `std::construct_at<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > &,0>'::`1'::dtor$0
	lea	rcx, QWORD PTR _Guard$1[rdx]
	jmp	??1?$_Tidy_guard@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >::~_Tidy_guard<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >
?dtor$0@?0???$construct_at@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@$0A@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV10@@Z@4HA ENDP ; `std::construct_at<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > &,0>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Guard$1 = 32
$T2 = 40
_Backout$3 = 48
__$ArrayPad$ = 72
_Location$ = 112
<_Args_0>$ = 120
?dtor$1@?0???$construct_at@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@$0A@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV10@@Z@4HA PROC ; `std::construct_at<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > &,0>'::`1'::dtor$1
	lea	rcx, QWORD PTR _Backout$3[rdx]
	jmp	??1?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::~_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >
?dtor$1@?0???$construct_at@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@$0A@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV10@@Z@4HA ENDP ; `std::construct_at<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > &,0>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Guard$1 = 32
$T2 = 40
_Backout$3 = 48
__$ArrayPad$ = 72
_Location$ = 112
<_Args_0>$ = 120
?dtor$2@?0???$construct_at@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@$0A@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV10@@Z@4HA PROC ; `std::construct_at<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > &,0>'::`1'::dtor$2
	mov	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0???$construct_at@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@$0A@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV10@@Z@4HA ENDP ; `std::construct_at<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > &,0>'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Guard$1 = 32
$T2 = 40
_Backout$3 = 48
__$ArrayPad$ = 72
_Location$ = 112
<_Args_0>$ = 120
?dtor$3@?0???$construct_at@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@$0A@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV10@@Z@4HA PROC ; `std::construct_at<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > &,0>'::`1'::dtor$3
	mov	rcx, QWORD PTR $T2[rdx]
	add	rcx, 40					; 00000028H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0???$construct_at@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAV12@$0A@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@AEAV10@@Z@4HA ENDP ; `std::construct_at<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > &,0>'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@YAAEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@YAAEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@@Z PROC ; std::forward<AINBNodeDefMgr::NodeDef::ImmediateParam &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@YAAEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@@Z ENDP ; std::forward<AINBNodeDefMgr::NodeDef::ImmediateParam &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@UImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@@?$_Default_allocator_traits@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@1@QEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU345@@Z
_TEXT	SEGMENT
$T1 = 48
__formal$dead$ = 48
_Ptr$ = 56
<_Args_0>$ = 64
??$construct@UImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@@?$_Default_allocator_traits@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@1@QEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU345@@Z PROC ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::construct<AINBNodeDefMgr::NodeDef::ImmediateParam,AINBNodeDefMgr::NodeDef::ImmediateParam &>, COMDAT

; 715  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN12:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, r8
	mov	rbx, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T1[rsp], rdx
	mov	rdx, r8
	mov	rcx, rbx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, DWORD PTR [rdi+32]
	mov	DWORD PTR [rbx+32], eax
	lea	rcx, QWORD PTR [rbx+40]
	lea	rdx, QWORD PTR [rdi+40]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rbx+72]
	lea	rdx, QWORD PTR [rdi+72]
	call	??0?$vector@W4FlagsStruct@AINBFile@@V?$allocator@W4FlagsStruct@AINBFile@@@std@@@std@@QEAA@AEBV01@@Z ; std::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$construct@UImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@@?$_Default_allocator_traits@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@1@QEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU345@@Z ENDP ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::construct<AINBNodeDefMgr::NodeDef::ImmediateParam,AINBNodeDefMgr::NodeDef::ImmediateParam &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
__formal$dead$ = 48
_Ptr$ = 56
<_Args_0>$ = 64
?dtor$0@?0???$construct@UImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@@?$_Default_allocator_traits@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@1@QEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU345@@Z@4HA PROC ; `std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::construct<AINBNodeDefMgr::NodeDef::ImmediateParam,AINBNodeDefMgr::NodeDef::ImmediateParam &>'::`1'::dtor$0
	mov	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$construct@UImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@@?$_Default_allocator_traits@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@1@QEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU345@@Z@4HA ENDP ; `std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::construct<AINBNodeDefMgr::NodeDef::ImmediateParam,AINBNodeDefMgr::NodeDef::ImmediateParam &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
__formal$dead$ = 48
_Ptr$ = 56
<_Args_0>$ = 64
?dtor$1@?0???$construct@UImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@@?$_Default_allocator_traits@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@1@QEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU345@@Z@4HA PROC ; `std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::construct<AINBNodeDefMgr::NodeDef::ImmediateParam,AINBNodeDefMgr::NodeDef::ImmediateParam &>'::`1'::dtor$1
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 40					; 00000028H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0???$construct@UImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@@?$_Default_allocator_traits@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@1@QEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU345@@Z@4HA ENDP ; `std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::construct<AINBNodeDefMgr::NodeDef::ImmediateParam,AINBNodeDefMgr::NodeDef::ImmediateParam &>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEAUInputParam@NodeDef@AINBNodeDefMgr@@@std@@YAAEAUInputParam@NodeDef@AINBNodeDefMgr@@AEAU123@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAUInputParam@NodeDef@AINBNodeDefMgr@@@std@@YAAEAUInputParam@NodeDef@AINBNodeDefMgr@@AEAU123@@Z PROC ; std::forward<AINBNodeDefMgr::NodeDef::InputParam &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEAUInputParam@NodeDef@AINBNodeDefMgr@@@std@@YAAEAUInputParam@NodeDef@AINBNodeDefMgr@@AEAU123@@Z ENDP ; std::forward<AINBNodeDefMgr::NodeDef::InputParam &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@UInputParam@NodeDef@AINBNodeDefMgr@@AEAU123@@?$_Default_allocator_traits@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@1@QEAUInputParam@NodeDef@AINBNodeDefMgr@@AEAU345@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@UInputParam@NodeDef@AINBNodeDefMgr@@AEAU123@@?$_Default_allocator_traits@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@1@QEAUInputParam@NodeDef@AINBNodeDefMgr@@AEAU345@@Z PROC ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::construct<AINBNodeDefMgr::NodeDef::InputParam,AINBNodeDefMgr::NodeDef::InputParam &>, COMDAT

; 715  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

	mov	rcx, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rdx, r8
	jmp	??0InputParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z
??$construct@UInputParam@NodeDef@AINBNodeDefMgr@@AEAU123@@?$_Default_allocator_traits@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SAXAEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@1@QEAUInputParam@NodeDef@AINBNodeDefMgr@@AEAU345@@Z ENDP ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::construct<AINBNodeDefMgr::NodeDef::InputParam,AINBNodeDefMgr::NodeDef::InputParam &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
_Guard$1 = 32
$T2 = 40
_Backout$3 = 48
__$ArrayPad$ = 72
this$ = 112
_Right$ = 120
??0?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@AEBV01@@Z PROC ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >, COMDAT

; 683  :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

$LN70:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r14, rdx
	mov	rsi, rcx

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 684  :         const auto& _Right_data = _Right._Mypair._Myval2;
; 685  :         const auto _Count       = static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst);

	mov	rbx, QWORD PTR [rdx+8]
	sub	rbx, QWORD PTR [rdx]
	sar	rbx, 5
	mov	rax, -6148914691236517205		; aaaaaaaaaaaaaaabH
	imul	rbx, rax

; 2065 :         if (_Count != 0) {

	test	rbx, rbx
	je	$LN55@vector

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 192153584101141162			; 02aaaaaaaaaaaaaaH
	cmp	rbx, rax
	ja	$LN68@vector

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdx, rbx
	call	?allocate@?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z ; std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>::allocate
	mov	rdi, rax

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rsi], rax

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [rsi+8], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rax, QWORD PTR [rbx+rbx*2]
	shl	rax, 5
	add	rax, rdi
	mov	QWORD PTR [rsi+16], rax

; 2067 :             _Tidy_guard<vector> _Guard{this};

	mov	QWORD PTR _Guard$1[rsp], rsi

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rbp, QWORD PTR [r14+8]
	mov	rbx, QWORD PTR [r14]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _Backout$3[rsp], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR _Backout$3[rsp], rdi
	mov	QWORD PTR _Backout$3[rsp+8], rdi
	mov	QWORD PTR _Backout$3[rsp+16], rsi

; 1855 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rbx, rbp
	je	SHORT $LN19@vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1983 :         pointer& _Mylast  = _My_data._Mylast;

	add	rbx, 40					; 00000028H
	npad	10
$LL20@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T2[rsp], rdi
	lea	rdx, QWORD PTR [rbx-40]
	mov	rcx, rdi
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, DWORD PTR [rbx-8]
	mov	DWORD PTR [rdi+32], eax
	lea	rcx, QWORD PTR [rdi+40]
	mov	rdx, rbx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rdi+72]
	lea	rdx, QWORD PTR [rbx+32]
	call	??0?$vector@W4FlagsStruct@AINBFile@@V?$allocator@W4FlagsStruct@AINBFile@@@std@@@std@@QEAA@AEBV01@@Z ; std::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rdi, 96					; 00000060H
	mov	QWORD PTR _Backout$3[rsp+8], rdi

; 1855 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	rbx, 96					; 00000060H
	lea	rcx, QWORD PTR [rbx-40]
	cmp	rcx, rbp
	jne	SHORT $LL20@vector
$LN19@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	QWORD PTR [rsi+8], rdi
$LN55@vector:

; 686  :         _Construct_n(_Count, _Right_data._Myfirst, _Right_data._Mylast);
; 687  :     }

	mov	rax, rsi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [r11+48]
	mov	rbp, QWORD PTR [r11+56]
	mov	rsp, r11
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN68@vector:

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Xlength
	int	3
$LN66@vector:
??0?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@AEBV01@@Z ENDP ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Guard$1 = 32
$T2 = 40
_Backout$3 = 48
__$ArrayPad$ = 72
this$ = 112
_Right$ = 120
?dtor$0@?0???0?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@AEBV01@@Z@4HA PROC ; `std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Guard$1[rdx]
	jmp	??1?$_Tidy_guard@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >::~_Tidy_guard<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >
?dtor$0@?0???0?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@AEBV01@@Z@4HA ENDP ; `std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Guard$1 = 32
$T2 = 40
_Backout$3 = 48
__$ArrayPad$ = 72
this$ = 112
_Right$ = 120
?dtor$1@?0???0?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@AEBV01@@Z@4HA PROC ; `std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >'::`1'::dtor$1
	lea	rcx, QWORD PTR _Backout$3[rdx]
	jmp	??1?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::~_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >
?dtor$1@?0???0?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@AEBV01@@Z@4HA ENDP ; `std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Guard$1 = 32
$T2 = 40
_Backout$3 = 48
__$ArrayPad$ = 72
this$ = 112
_Right$ = 120
?dtor$2@?0???0?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@AEBV01@@Z@4HA PROC ; `std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >'::`1'::dtor$2
	mov	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0???0?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@AEBV01@@Z@4HA ENDP ; `std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Guard$1 = 32
$T2 = 40
_Backout$3 = 48
__$ArrayPad$ = 72
this$ = 112
_Right$ = 120
?dtor$3@?0???0?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@AEBV01@@Z@4HA PROC ; `std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >'::`1'::dtor$3
	mov	rcx, QWORD PTR $T2[rdx]
	add	rcx, 40					; 00000028H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0???0?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@AEBV01@@Z@4HA ENDP ; `std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ PROC ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 611  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 612  :     }

	mov	rax, rcx
	ret	0
??0?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ ENDP ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
_Guard$1 = 32
_Backout$2 = 40
__$ArrayPad$ = 64
this$ = 112
_Right$ = 120
??0?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@AEBV01@@Z PROC ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >, COMDAT

; 683  :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

$LN65:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r14, rdx
	mov	rsi, rcx

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 684  :         const auto& _Right_data = _Right._Mypair._Myval2;
; 685  :         const auto _Count       = static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst);

	mov	rbx, QWORD PTR [rdx+8]
	sub	rbx, QWORD PTR [rdx]
	sar	rbx, 4
	mov	rax, -8198552921648689607		; 8e38e38e38e38e39H
	imul	rbx, rax

; 2065 :         if (_Count != 0) {

	test	rbx, rbx
	je	$LN50@vector

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 128102389400760775			; 01c71c71c71c71c7H
	cmp	rbx, rax
	ja	$LN63@vector

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdx, rbx
	call	?allocate@?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAPEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z ; std::allocator<AINBNodeDefMgr::NodeDef::InputParam>::allocate
	mov	rdi, rax

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rsi], rax

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [rsi+8], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rax, QWORD PTR [rbx+rbx*8]
	shl	rax, 4
	add	rax, rdi
	mov	QWORD PTR [rsi+16], rax

; 2067 :             _Tidy_guard<vector> _Guard{this};

	mov	QWORD PTR _Guard$1[rsp], rsi

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rbp, QWORD PTR [r14+8]
	mov	rbx, QWORD PTR [r14]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _Backout$2[rsp], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR _Backout$2[rsp], rdi
	mov	QWORD PTR _Backout$2[rsp+8], rdi
	mov	QWORD PTR _Backout$2[rsp+16], rsi

; 1855 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rbx, rbp
	je	SHORT $LN19@vector
$LL20@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rdx, rbx
	mov	rcx, rdi
	call	??0InputParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rdi, 144				; 00000090H
	mov	QWORD PTR _Backout$2[rsp+8], rdi

; 1855 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	rbx, 144				; 00000090H
	cmp	rbx, rbp
	jne	SHORT $LL20@vector
$LN19@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	QWORD PTR [rsi+8], rdi
$LN50@vector:

; 686  :         _Construct_n(_Count, _Right_data._Myfirst, _Right_data._Mylast);
; 687  :     }

	mov	rax, rsi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [r11+48]
	mov	rbp, QWORD PTR [r11+56]
	mov	rsp, r11
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN63@vector:

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Xlength
	int	3
$LN61@vector:
??0?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@AEBV01@@Z ENDP ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Guard$1 = 32
_Backout$2 = 40
__$ArrayPad$ = 64
this$ = 112
_Right$ = 120
?dtor$0@?0???0?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@AEBV01@@Z@4HA PROC ; `std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Guard$1[rdx]
	jmp	??1?$_Tidy_guard@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >::~_Tidy_guard<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >
?dtor$0@?0???0?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@AEBV01@@Z@4HA ENDP ; `std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Guard$1 = 32
_Backout$2 = 40
__$ArrayPad$ = 64
this$ = 112
_Right$ = 120
?dtor$1@?0???0?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@AEBV01@@Z@4HA PROC ; `std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >'::`1'::dtor$1
	lea	rcx, QWORD PTR _Backout$2[rdx]
	jmp	??1?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::~_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >
?dtor$1@?0???0?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@AEBV01@@Z@4HA ENDP ; `std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ PROC ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 611  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 612  :     }

	mov	rax, rcx
	ret	0
??0?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ ENDP ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SA?AV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@2@AEBV32@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Al$dead$ = 16
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SA?AV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@2@AEBV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::select_on_container_copy_construction, COMDAT

; 737  :         return _Al;

	mov	rax, rcx

; 738  :     }

	ret	0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SA?AV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@2@AEBV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SA?AV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@2@AEBV32@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Al$dead$ = 16
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SA?AV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@2@AEBV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::select_on_container_copy_construction, COMDAT

; 737  :         return _Al;

	mov	rax, rcx

; 738  :     }

	ret	0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@SA?AV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@2@AEBV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@UInputParam@NodeDef@AINBNodeDefMgr@@U123@$0A@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@QEAU123@$$QEAU123@@Z
_TEXT	SEGMENT
_Location$ = 48
<_Args_0>$ = 56
??$construct_at@UInputParam@NodeDef@AINBNodeDefMgr@@U123@$0A@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@QEAU123@$$QEAU123@@Z PROC ; std::construct_at<AINBNodeDefMgr::NodeDef::InputParam,AINBNodeDefMgr::NodeDef::InputParam,0>, COMDAT

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN92:
	sub	rsp, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	r8d, r8d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

	mov	r9, rdx
	xorps	xmm0, xmm0
	mov	r10, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], r8

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], r8

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rcx+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rdx+16], r8
	mov	QWORD PTR [rdx+24], 15
	mov	BYTE PTR [rdx], r8b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx+32], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+48], r8

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+56], r8

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx+32]
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	xmm1, XMMWORD PTR [rdx+48]
	movups	XMMWORD PTR [rcx+48], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 697  :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal()),

	mov	QWORD PTR [rdx+48], r8
	mov	QWORD PTR [rdx+56], 15
	mov	BYTE PTR [rdx+32], r8b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [rdx+80]
	mov	rcx, QWORD PTR [r9+72]
	mov	rax, QWORD PTR [r9+64]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r9+80], r8
	mov	QWORD PTR [r9+72], r8
	mov	QWORD PTR [r9+64], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r10+72], rcx
	lea	rcx, QWORD PTR [r10+88]
	mov	QWORD PTR [r10+80], rdx
	lea	rdx, QWORD PTR [r9+88]
	mov	QWORD PTR [r10+64], rax
	call	??0?$variant@I_NMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VVector3F@@@std@@QEAA@$$QEAV01@@Z
	mov	ecx, DWORD PTR [r9+128]
	mov	DWORD PTR [r10+128], ecx
	movzx	eax, BYTE PTR [r9+132]
	mov	BYTE PTR [r10+132], al
	mov	eax, DWORD PTR [r9+136]
	mov	DWORD PTR [r10+136], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, r10

; 242  : }

	add	rsp, 40					; 00000028H
	ret	0
??$construct_at@UInputParam@NodeDef@AINBNodeDefMgr@@U123@$0A@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@QEAU123@$$QEAU123@@Z ENDP ; std::construct_at<AINBNodeDefMgr::NodeDef::InputParam,AINBNodeDefMgr::NodeDef::InputParam,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@UNodeDef@AINBNodeDefMgr@@U12@$0A@@std@@YAPEAUNodeDef@AINBNodeDefMgr@@QEAU12@$$QEAU12@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@UNodeDef@AINBNodeDefMgr@@U12@$0A@@std@@YAPEAUNodeDef@AINBNodeDefMgr@@QEAU12@$$QEAU12@@Z PROC ; std::construct_at<AINBNodeDefMgr::NodeDef,AINBNodeDefMgr::NodeDef,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	jmp	??0NodeDef@AINBNodeDefMgr@@QEAA@$$QEAU01@@Z
??$construct_at@UNodeDef@AINBNodeDefMgr@@U12@$0A@@std@@YAPEAUNodeDef@AINBNodeDefMgr@@QEAU12@$$QEAU12@@Z ENDP ; std::construct_at<AINBNodeDefMgr::NodeDef,AINBNodeDefMgr::NodeDef,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V12@$0A@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@$$QEAV10@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V12@$0A@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@$$QEAV10@@Z PROC ; std::construct_at<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r10d, r10d
	mov	r9, QWORD PTR [rdx+16]

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], r10
	mov	QWORD PTR [rdx+8], r10
	mov	QWORD PTR [rdx], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 242  : }

	ret	0
??$construct_at@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V12@$0A@@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@$$QEAV10@@Z ENDP ; std::construct_at<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V12@$0A@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@$$QEAV10@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V12@$0A@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@$$QEAV10@@Z PROC ; std::construct_at<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r10d, r10d
	mov	r9, QWORD PTR [rdx+16]

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], r10
	mov	QWORD PTR [rdx+8], r10
	mov	QWORD PTR [rdx], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 242  : }

	ret	0
??$construct_at@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V12@$0A@@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@QEAV10@$$QEAV10@@Z ENDP ; std::construct_at<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@UImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@$0A@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@AEAU123@@Z
_TEXT	SEGMENT
$T1 = 48
_Location$ = 48
<_Args_0>$ = 56
??$construct_at@UImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@$0A@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@AEAU123@@Z PROC ; std::construct_at<AINBNodeDefMgr::NodeDef::ImmediateParam,AINBNodeDefMgr::NodeDef::ImmediateParam &,0>, COMDAT

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN10:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T1[rsp], rcx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, DWORD PTR [rbx+32]
	mov	DWORD PTR [rdi+32], eax
	lea	rcx, QWORD PTR [rdi+40]
	lea	rdx, QWORD PTR [rbx+40]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rdi+72]
	lea	rdx, QWORD PTR [rbx+72]
	call	??0?$vector@W4FlagsStruct@AINBFile@@V?$allocator@W4FlagsStruct@AINBFile@@@std@@@std@@QEAA@AEBV01@@Z ; std::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >
	npad	1
	mov	rax, rdi

; 242  : }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$construct_at@UImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@$0A@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@AEAU123@@Z ENDP ; std::construct_at<AINBNodeDefMgr::NodeDef::ImmediateParam,AINBNodeDefMgr::NodeDef::ImmediateParam &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
_Location$ = 48
<_Args_0>$ = 56
?dtor$0@?0???$construct_at@UImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@$0A@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@AEAU123@@Z@4HA PROC ; `std::construct_at<AINBNodeDefMgr::NodeDef::ImmediateParam,AINBNodeDefMgr::NodeDef::ImmediateParam &,0>'::`1'::dtor$0
	mov	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$construct_at@UImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@$0A@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@AEAU123@@Z@4HA ENDP ; `std::construct_at<AINBNodeDefMgr::NodeDef::ImmediateParam,AINBNodeDefMgr::NodeDef::ImmediateParam &,0>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
_Location$ = 48
<_Args_0>$ = 56
?dtor$1@?0???$construct_at@UImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@$0A@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@AEAU123@@Z@4HA PROC ; `std::construct_at<AINBNodeDefMgr::NodeDef::ImmediateParam,AINBNodeDefMgr::NodeDef::ImmediateParam &,0>'::`1'::dtor$1
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 40					; 00000028H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0???$construct_at@UImmediateParam@NodeDef@AINBNodeDefMgr@@AEAU123@$0A@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@QEAU123@AEAU123@@Z@4HA ENDP ; `std::construct_at<AINBNodeDefMgr::NodeDef::ImmediateParam,AINBNodeDefMgr::NodeDef::ImmediateParam &,0>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@UInputParam@NodeDef@AINBNodeDefMgr@@AEAU123@$0A@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@QEAU123@AEAU123@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@UInputParam@NodeDef@AINBNodeDefMgr@@AEAU123@$0A@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@QEAU123@AEAU123@@Z PROC ; std::construct_at<AINBNodeDefMgr::NodeDef::InputParam,AINBNodeDefMgr::NodeDef::InputParam &,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	jmp	??0InputParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z
??$construct_at@UInputParam@NodeDef@AINBNodeDefMgr@@AEAU123@$0A@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@QEAU123@AEAU123@@Z ENDP ; std::construct_at<AINBNodeDefMgr::NodeDef::InputParam,AINBNodeDefMgr::NodeDef::InputParam &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@$$V@?$_Compressed_pair@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@$$V@?$_Compressed_pair@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::ImmediateParam> >,1>::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::ImmediateParam> >,1><std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@$$V@?$_Compressed_pair@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::ImmediateParam> >,1>::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::ImmediateParam> >,1><std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Construct_n@AEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEBQEAU123@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@1@Z
_TEXT	SEGMENT
_Guard$1 = 32
$T2 = 40
_Backout$3 = 48
__$ArrayPad$ = 72
this$ = 128
_Count$ = 136
<_Val_0>$ = 144
<_Val_1>$ = 152
??$_Construct_n@AEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEBQEAU123@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@1@Z PROC ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Construct_n<AINBNodeDefMgr::NodeDef::ImmediateParam * const &,AINBNodeDefMgr::NodeDef::ImmediateParam * const &>, COMDAT

; 2056 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

$LN64:

; 2057 :         // Dispatches between the three sized constructions.
; 2058 :         // 1-arg -> value-construction, e.g. vector(5)
; 2059 :         // 2-arg -> fill, e.g. vector(5, "meow")
; 2060 :         // 3-arg -> sized range construction, e.g. vector{"Hello", "Fluffy", "World"}
; 2061 :         auto& _Al       = _Getal();
; 2062 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2063 :         auto& _My_data  = _Mypair._Myval2;
; 2064 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2065 :         if (_Count != 0) {

	test	rdx, rdx
	je	$LN60@Construct_
	push	rbx
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 2056 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

	mov	rsi, r9
	mov	r15, r8
	mov	rbx, rdx
	mov	r14, rcx

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 192153584101141162			; 02aaaaaaaaaaaaaaH
	cmp	rdx, rax
	ja	$LN62@Construct_

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	call	?allocate@?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z ; std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>::allocate
	mov	rdi, rax

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [r14], rax

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [r14+8], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [rbx+rbx*2]
	shl	rcx, 5
	add	rcx, rax
	mov	QWORD PTR [r14+16], rcx

; 2066 :             _Buy_nonzero(_Count);
; 2067 :             _Tidy_guard<vector> _Guard{this};

	mov	QWORD PTR _Guard$1[rsp], r14

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rsi, QWORD PTR [rsi]
	mov	rbx, QWORD PTR [r15]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _Backout$3[rsp], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR _Backout$3[rsp], rax
	mov	QWORD PTR _Backout$3[rsp+8], rax
	mov	QWORD PTR _Backout$3[rsp+16], r14

; 1855 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rbx, rsi
	je	SHORT $LN13@Construct_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1983 :         pointer& _Mylast  = _My_data._Mylast;

	add	rbx, 40					; 00000028H
	npad	5
$LL14@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T2[rsp], rdi
	lea	rdx, QWORD PTR [rbx-40]
	mov	rcx, rdi
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, DWORD PTR [rbx-8]
	mov	DWORD PTR [rdi+32], eax
	lea	rcx, QWORD PTR [rdi+40]
	mov	rdx, rbx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rdi+72]
	lea	rdx, QWORD PTR [rbx+32]
	call	??0?$vector@W4FlagsStruct@AINBFile@@V?$allocator@W4FlagsStruct@AINBFile@@@std@@@std@@QEAA@AEBV01@@Z ; std::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rdi, 96					; 00000060H
	mov	QWORD PTR _Backout$3[rsp+8], rdi

; 1855 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	rbx, 96					; 00000060H
	lea	rax, QWORD PTR [rbx-40]
	cmp	rax, rsi
	jne	SHORT $LL14@Construct_
$LN13@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	QWORD PTR [r14+8], rdi

; 2075 :             } else {
; 2076 :                 static_assert(_Always_false<_Ty>, "Should be unreachable");
; 2077 :             }
; 2078 :             _ASAN_VECTOR_CREATE;
; 2079 :             _Guard._Target = nullptr;
; 2080 :         }
; 2081 : 
; 2082 :         _Proxy._Release();
; 2083 :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 80					; 00000050H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbx
$LN60@Construct_:
	ret	0
$LN62@Construct_:

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Xlength
	int	3
$LN59@Construct_:
??$_Construct_n@AEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEBQEAU123@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@1@Z ENDP ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Construct_n<AINBNodeDefMgr::NodeDef::ImmediateParam * const &,AINBNodeDefMgr::NodeDef::ImmediateParam * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Guard$1 = 32
$T2 = 40
_Backout$3 = 48
__$ArrayPad$ = 72
this$ = 128
_Count$ = 136
<_Val_0>$ = 144
<_Val_1>$ = 152
?dtor$0@?0???$_Construct_n@AEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEBQEAU123@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@1@Z@4HA PROC ; `std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Construct_n<AINBNodeDefMgr::NodeDef::ImmediateParam * const &,AINBNodeDefMgr::NodeDef::ImmediateParam * const &>'::`1'::dtor$0
	lea	rcx, QWORD PTR _Guard$1[rdx]
	jmp	??1?$_Tidy_guard@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >::~_Tidy_guard<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >
?dtor$0@?0???$_Construct_n@AEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEBQEAU123@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@1@Z@4HA ENDP ; `std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Construct_n<AINBNodeDefMgr::NodeDef::ImmediateParam * const &,AINBNodeDefMgr::NodeDef::ImmediateParam * const &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Guard$1 = 32
$T2 = 40
_Backout$3 = 48
__$ArrayPad$ = 72
this$ = 128
_Count$ = 136
<_Val_0>$ = 144
<_Val_1>$ = 152
?dtor$1@?0???$_Construct_n@AEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEBQEAU123@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@1@Z@4HA PROC ; `std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Construct_n<AINBNodeDefMgr::NodeDef::ImmediateParam * const &,AINBNodeDefMgr::NodeDef::ImmediateParam * const &>'::`1'::dtor$1
	lea	rcx, QWORD PTR _Backout$3[rdx]
	jmp	??1?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::~_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >
?dtor$1@?0???$_Construct_n@AEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEBQEAU123@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@1@Z@4HA ENDP ; `std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Construct_n<AINBNodeDefMgr::NodeDef::ImmediateParam * const &,AINBNodeDefMgr::NodeDef::ImmediateParam * const &>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Guard$1 = 32
$T2 = 40
_Backout$3 = 48
__$ArrayPad$ = 72
this$ = 128
_Count$ = 136
<_Val_0>$ = 144
<_Val_1>$ = 152
?dtor$2@?0???$_Construct_n@AEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEBQEAU123@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@1@Z@4HA PROC ; `std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Construct_n<AINBNodeDefMgr::NodeDef::ImmediateParam * const &,AINBNodeDefMgr::NodeDef::ImmediateParam * const &>'::`1'::dtor$2
	mov	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0???$_Construct_n@AEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEBQEAU123@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@1@Z@4HA ENDP ; `std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Construct_n<AINBNodeDefMgr::NodeDef::ImmediateParam * const &,AINBNodeDefMgr::NodeDef::ImmediateParam * const &>'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Guard$1 = 32
$T2 = 40
_Backout$3 = 48
__$ArrayPad$ = 72
this$ = 128
_Count$ = 136
<_Val_0>$ = 144
<_Val_1>$ = 152
?dtor$3@?0???$_Construct_n@AEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEBQEAU123@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@1@Z@4HA PROC ; `std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Construct_n<AINBNodeDefMgr::NodeDef::ImmediateParam * const &,AINBNodeDefMgr::NodeDef::ImmediateParam * const &>'::`1'::dtor$3
	mov	rcx, QWORD PTR $T2[rdx]
	add	rcx, 40					; 00000028H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0???$_Construct_n@AEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEBQEAU123@@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@1@Z@4HA ENDP ; `std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Construct_n<AINBNodeDefMgr::NodeDef::ImmediateParam * const &,AINBNodeDefMgr::NodeDef::ImmediateParam * const &>'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::ImmediateParam> >,1>::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::ImmediateParam> >,1><>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::ImmediateParam> >,1>::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::ImmediateParam> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@$$V@?$_Compressed_pair@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@$$V@?$_Compressed_pair@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::InputParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::InputParam> >,1>::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::InputParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::InputParam> >,1><std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@$$V@?$_Compressed_pair@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::InputParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::InputParam> >,1>::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::InputParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::InputParam> >,1><std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Construct_n@AEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@AEBQEAU123@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@1@Z
_TEXT	SEGMENT
_Guard$1 = 32
_Backout$2 = 40
__$ArrayPad$ = 64
this$ = 128
_Count$ = 136
<_Val_0>$ = 144
<_Val_1>$ = 152
??$_Construct_n@AEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@AEBQEAU123@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@1@Z PROC ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Construct_n<AINBNodeDefMgr::NodeDef::InputParam * const &,AINBNodeDefMgr::NodeDef::InputParam * const &>, COMDAT

; 2056 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

$LN59:

; 2057 :         // Dispatches between the three sized constructions.
; 2058 :         // 1-arg -> value-construction, e.g. vector(5)
; 2059 :         // 2-arg -> fill, e.g. vector(5, "meow")
; 2060 :         // 3-arg -> sized range construction, e.g. vector{"Hello", "Fluffy", "World"}
; 2061 :         auto& _Al       = _Getal();
; 2062 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2063 :         auto& _My_data  = _Mypair._Myval2;
; 2064 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2065 :         if (_Count != 0) {

	test	rdx, rdx
	je	$LN55@Construct_
	push	rbx
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 2056 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

	mov	rsi, r9
	mov	r15, r8
	mov	rbx, rdx
	mov	r14, rcx

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 128102389400760775			; 01c71c71c71c71c7H
	cmp	rdx, rax
	ja	$LN57@Construct_

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	call	?allocate@?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAPEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z ; std::allocator<AINBNodeDefMgr::NodeDef::InputParam>::allocate
	mov	rdi, rax

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [r14], rax

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [r14+8], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [rbx+rbx*8]
	shl	rcx, 4
	add	rcx, rax
	mov	QWORD PTR [r14+16], rcx

; 2066 :             _Buy_nonzero(_Count);
; 2067 :             _Tidy_guard<vector> _Guard{this};

	mov	QWORD PTR _Guard$1[rsp], r14

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rsi, QWORD PTR [rsi]
	mov	rbx, QWORD PTR [r15]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _Backout$2[rsp], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR _Backout$2[rsp], rax
	mov	QWORD PTR _Backout$2[rsp+8], rax
	mov	QWORD PTR _Backout$2[rsp+16], r14

; 1855 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rbx, rsi
	je	SHORT $LN13@Construct_
	npad	9
$LL14@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rdx, rbx
	mov	rcx, rdi
	call	??0InputParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rdi, 144				; 00000090H
	mov	QWORD PTR _Backout$2[rsp+8], rdi

; 1855 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	rbx, 144				; 00000090H
	cmp	rbx, rsi
	jne	SHORT $LL14@Construct_
$LN13@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	QWORD PTR [r14+8], rdi

; 2075 :             } else {
; 2076 :                 static_assert(_Always_false<_Ty>, "Should be unreachable");
; 2077 :             }
; 2078 :             _ASAN_VECTOR_CREATE;
; 2079 :             _Guard._Target = nullptr;
; 2080 :         }
; 2081 : 
; 2082 :         _Proxy._Release();
; 2083 :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 80					; 00000050H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbx
$LN55@Construct_:
	ret	0
$LN57@Construct_:

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Xlength
	int	3
$LN54@Construct_:
??$_Construct_n@AEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@AEBQEAU123@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@1@Z ENDP ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Construct_n<AINBNodeDefMgr::NodeDef::InputParam * const &,AINBNodeDefMgr::NodeDef::InputParam * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Guard$1 = 32
_Backout$2 = 40
__$ArrayPad$ = 64
this$ = 128
_Count$ = 136
<_Val_0>$ = 144
<_Val_1>$ = 152
?dtor$0@?0???$_Construct_n@AEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@AEBQEAU123@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@1@Z@4HA PROC ; `std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Construct_n<AINBNodeDefMgr::NodeDef::InputParam * const &,AINBNodeDefMgr::NodeDef::InputParam * const &>'::`1'::dtor$0
	lea	rcx, QWORD PTR _Guard$1[rdx]
	jmp	??1?$_Tidy_guard@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >::~_Tidy_guard<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >
?dtor$0@?0???$_Construct_n@AEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@AEBQEAU123@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@1@Z@4HA ENDP ; `std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Construct_n<AINBNodeDefMgr::NodeDef::InputParam * const &,AINBNodeDefMgr::NodeDef::InputParam * const &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Guard$1 = 32
_Backout$2 = 40
__$ArrayPad$ = 64
this$ = 128
_Count$ = 136
<_Val_0>$ = 144
<_Val_1>$ = 152
?dtor$1@?0???$_Construct_n@AEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@AEBQEAU123@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@1@Z@4HA PROC ; `std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Construct_n<AINBNodeDefMgr::NodeDef::InputParam * const &,AINBNodeDefMgr::NodeDef::InputParam * const &>'::`1'::dtor$1
	lea	rcx, QWORD PTR _Backout$2[rdx]
	jmp	??1?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::~_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >
?dtor$1@?0???$_Construct_n@AEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@AEBQEAU123@@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_KAEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@1@Z@4HA ENDP ; `std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Construct_n<AINBNodeDefMgr::NodeDef::InputParam * const &,AINBNodeDefMgr::NodeDef::InputParam * const &>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::InputParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::InputParam> >,1>::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::InputParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::InputParam> >,1><>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::InputParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::InputParam> >,1>::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::InputParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::InputParam> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0InputParam@NodeDef@AINBNodeDefMgr@@QEAA@$$QEAU012@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0InputParam@NodeDef@AINBNodeDefMgr@@QEAA@$$QEAU012@@Z PROC ; AINBNodeDefMgr::NodeDef::InputParam::InputParam, COMDAT
$LN89:
	sub	rsp, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	r8d, r8d
	mov	r9, rdx
	xorps	xmm0, xmm0
	mov	r10, rcx

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], r8

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], r8

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rcx+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rdx+16], r8
	mov	QWORD PTR [rdx+24], 15
	mov	BYTE PTR [rdx], r8b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx+32], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+48], r8

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+56], r8

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx+32]
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	xmm1, XMMWORD PTR [rdx+48]
	movups	XMMWORD PTR [rcx+48], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 697  :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal()),

	mov	QWORD PTR [rdx+48], r8
	mov	QWORD PTR [rdx+56], 15
	mov	BYTE PTR [rdx+32], r8b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [rdx+80]
	mov	rcx, QWORD PTR [r9+72]
	mov	rax, QWORD PTR [r9+64]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r9+80], r8
	mov	QWORD PTR [r9+72], r8
	mov	QWORD PTR [r9+64], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r10+72], rcx
	lea	rcx, QWORD PTR [r10+88]
	mov	QWORD PTR [r10+80], rdx
	lea	rdx, QWORD PTR [r9+88]
	mov	QWORD PTR [r10+64], rax
	call	??0?$variant@I_NMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VVector3F@@@std@@QEAA@$$QEAV01@@Z
	mov	ecx, DWORD PTR [r9+128]
	mov	DWORD PTR [r10+128], ecx
	movzx	eax, BYTE PTR [r9+132]
	mov	BYTE PTR [r10+132], al
	mov	eax, DWORD PTR [r9+136]
	mov	DWORD PTR [r10+136], eax
	mov	rax, r10
	add	rsp, 40					; 00000028H
	ret	0
??0InputParam@NodeDef@AINBNodeDefMgr@@QEAA@$$QEAU012@@Z ENDP ; AINBNodeDefMgr::NodeDef::InputParam::InputParam
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0NodeDef@AINBNodeDefMgr@@QEAA@$$QEAU01@@Z
_TEXT	SEGMENT
this$ = 8
__that$ = 16
??0NodeDef@AINBNodeDefMgr@@QEAA@$$QEAU01@@Z PROC	; AINBNodeDefMgr::NodeDef::NodeDef, COMDAT
	movzx	eax, BYTE PTR [rdx]
	mov	r8, rdx
	mov	BYTE PTR [rcx], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	r10d, r10d
	mov	r9, rcx
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx+8], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+24], r10

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+32], r10

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx+8]
	movups	XMMWORD PTR [rcx+8], xmm0
	movups	xmm1, XMMWORD PTR [rdx+24]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rcx+24], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rdx+24], r10
	mov	QWORD PTR [rdx+32], 15
	mov	BYTE PTR [rdx+8], r10b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx+40], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+56], r10

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+64], r10

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx+40]
	movups	XMMWORD PTR [rcx+40], xmm0
	movups	xmm1, XMMWORD PTR [rdx+56]
	movups	XMMWORD PTR [rcx+56], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 697  :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal()),

	mov	QWORD PTR [rdx+56], r10
	mov	QWORD PTR [rdx+64], 15
	mov	BYTE PTR [rdx+40], r10b
	mov	eax, DWORD PTR [rdx+72]
	mov	DWORD PTR [rcx+72], eax
	movzx	eax, WORD PTR [rdx+76]
	mov	WORD PTR [rcx+76], ax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [rdx+96]
	mov	rcx, QWORD PTR [r8+88]
	mov	rax, QWORD PTR [r8+80]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8+96], r10
	mov	QWORD PTR [r8+88], r10
	mov	QWORD PTR [r8+80], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r9+80], rax
	mov	QWORD PTR [r9+88], rcx
	mov	QWORD PTR [r9+96], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [r8+120]
	mov	rcx, QWORD PTR [r8+112]
	mov	rax, QWORD PTR [r8+104]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8+120], r10
	mov	QWORD PTR [r8+112], r10
	mov	QWORD PTR [r8+104], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r9+104], rax
	mov	QWORD PTR [r9+112], rcx
	mov	QWORD PTR [r9+120], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [r8+144]
	mov	rcx, QWORD PTR [r8+136]
	mov	rax, QWORD PTR [r8+128]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8+144], r10
	mov	QWORD PTR [r8+136], r10
	mov	QWORD PTR [r8+128], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r9+128], rax
	mov	QWORD PTR [r9+136], rcx
	mov	QWORD PTR [r9+144], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [r8+168]
	mov	rcx, QWORD PTR [r8+160]
	mov	rax, QWORD PTR [r8+152]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8+168], r10
	mov	QWORD PTR [r8+160], r10
	mov	QWORD PTR [r8+152], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r9+152], rax
	mov	QWORD PTR [r9+160], rcx
	mov	QWORD PTR [r9+168], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [r8+192]
	mov	rcx, QWORD PTR [r8+184]
	mov	rax, QWORD PTR [r8+176]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8+192], r10
	mov	QWORD PTR [r8+184], r10
	mov	QWORD PTR [r8+176], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r9+176], rax
	mov	QWORD PTR [r9+184], rcx
	mov	QWORD PTR [r9+192], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [r8+216]
	mov	rcx, QWORD PTR [r8+208]
	mov	rax, QWORD PTR [r8+200]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8+216], r10
	mov	QWORD PTR [r8+208], r10
	mov	QWORD PTR [r8+200], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r9+200], rax
	mov	QWORD PTR [r9+208], rcx
	mov	QWORD PTR [r9+216], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [r8+224]
	mov	rdx, QWORD PTR [r8+240]
	mov	rcx, QWORD PTR [r8+232]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8+240], r10
	mov	QWORD PTR [r8+232], r10
	mov	QWORD PTR [r8+224], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r9+224], rax
	mov	rax, r9
	mov	QWORD PTR [r9+232], rcx
	mov	QWORD PTR [r9+240], rdx
	ret	0
??0NodeDef@AINBNodeDefMgr@@QEAA@$$QEAU01@@Z ENDP	; AINBNodeDefMgr::NodeDef::NodeDef
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Tidy_guard@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Tidy_guard@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Tidy_guard<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >::~_Tidy_guard<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >, COMDAT

; 44   :         if (_Target) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	jne	?_Tidy@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Tidy

; 45   :             _Target->_Tidy();
; 46   :         }
; 47   :     }

	ret	0
??1?$_Tidy_guard@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Tidy_guard<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >::~_Tidy_guard<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Tidy_guard@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Tidy_guard@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Tidy_guard<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >::~_Tidy_guard<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >, COMDAT

; 44   :         if (_Target) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	jne	?_Tidy@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Tidy

; 45   :             _Target->_Tidy();
; 46   :         }
; 47   :     }

	ret	0
??1?$_Tidy_guard@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Tidy_guard<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >::~_Tidy_guard<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::ImmediateParam> >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::ImmediateParam> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Buy_nonzero@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$ = 56
?_Buy_nonzero@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z PROC ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Buy_nonzero, COMDAT

; 1995 :     _CONSTEXPR20 void _Buy_nonzero(const size_type _Newcapacity) {

$LN10:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1996 :         // allocate array with _Newcapacity elements
; 1997 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1998 :         auto& _My_data    = _Mypair._Myval2;
; 1999 :         pointer& _Myfirst = _My_data._Myfirst;
; 2000 :         pointer& _Mylast  = _My_data._Mylast;
; 2001 :         pointer& _Myend   = _My_data._Myend;
; 2002 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 2003 :         _STL_INTERNAL_CHECK(0 < _Newcapacity);
; 2004 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 2005 : 
; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 192153584101141162			; 02aaaaaaaaaaaaaaH
	mov	rbx, rdx
	mov	rdi, rcx
	cmp	rdx, rax
	ja	SHORT $LN9@Buy_nonzer

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	call	?allocate@?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@_K@Z ; std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>::allocate

; 1990 :         _Myfirst           = _Newvec;
; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [rbx+rbx*2]
	mov	QWORD PTR [rdi], rax

; 2008 :         }
; 2009 : 
; 2010 :         _Buy_raw(_Newcapacity);
; 2011 :     }

	mov	rbx, QWORD PTR [rsp+48]

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	shl	rcx, 5
	add	rcx, rax
	mov	QWORD PTR [rdi+8], rax
	mov	QWORD PTR [rdi+16], rcx

; 2008 :         }
; 2009 : 
; 2010 :         _Buy_raw(_Newcapacity);
; 2011 :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN9@Buy_nonzer:

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Xlength
	int	3
$LN7@Buy_nonzer:
?_Buy_nonzero@?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z ENDP ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Buy_nonzero
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@$$QEAV01@@Z PROC ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r10d, r10d
	mov	r9, QWORD PTR [rdx+16]

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], r10
	mov	QWORD PTR [rdx+8], r10
	mov	QWORD PTR [rdx], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rax

; 701  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 702  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 703  :     }

	mov	rax, rcx

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9

; 701  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 702  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 703  :     }

	ret	0
??0?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@$$QEAV01@@Z ENDP ; std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@QEAA@XZ PROC ; std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>, COMDAT

; 958  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@QEAA@XZ ENDP ; std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::InputParam> >::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::InputParam> >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::InputParam> >::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::InputParam> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Buy_nonzero@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$ = 56
?_Buy_nonzero@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z PROC ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Buy_nonzero, COMDAT

; 1995 :     _CONSTEXPR20 void _Buy_nonzero(const size_type _Newcapacity) {

$LN10:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1996 :         // allocate array with _Newcapacity elements
; 1997 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1998 :         auto& _My_data    = _Mypair._Myval2;
; 1999 :         pointer& _Myfirst = _My_data._Myfirst;
; 2000 :         pointer& _Mylast  = _My_data._Mylast;
; 2001 :         pointer& _Myend   = _My_data._Myend;
; 2002 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 2003 :         _STL_INTERNAL_CHECK(0 < _Newcapacity);
; 2004 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 2005 : 
; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 128102389400760775			; 01c71c71c71c71c7H
	mov	rbx, rdx
	mov	rdi, rcx
	cmp	rdx, rax
	ja	SHORT $LN9@Buy_nonzer

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	call	?allocate@?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@QEAAPEAUInputParam@NodeDef@AINBNodeDefMgr@@_K@Z ; std::allocator<AINBNodeDefMgr::NodeDef::InputParam>::allocate

; 1990 :         _Myfirst           = _Newvec;
; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [rbx+rbx*8]
	mov	QWORD PTR [rdi], rax

; 2008 :         }
; 2009 : 
; 2010 :         _Buy_raw(_Newcapacity);
; 2011 :     }

	mov	rbx, QWORD PTR [rsp+48]

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	shl	rcx, 4
	add	rcx, rax
	mov	QWORD PTR [rdi+8], rax
	mov	QWORD PTR [rdi+16], rcx

; 2008 :         }
; 2009 : 
; 2010 :         _Buy_raw(_Newcapacity);
; 2011 :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN9@Buy_nonzer:

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@CAXXZ ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Xlength
	int	3
$LN7@Buy_nonzer:
?_Buy_nonzero@?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@AEAAX_K@Z ENDP ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::_Buy_nonzero
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@$$QEAV01@@Z PROC ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r10d, r10d
	mov	r9, QWORD PTR [rdx+16]

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], r10
	mov	QWORD PTR [rdx+8], r10
	mov	QWORD PTR [rdx], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rax

; 701  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 702  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 703  :     }

	mov	rax, rcx

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9

; 701  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 702  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 703  :     }

	ret	0
??0?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@$$QEAV01@@Z ENDP ; std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@QEAA@XZ PROC ; std::allocator<AINBNodeDefMgr::NodeDef::InputParam>::allocator<AINBNodeDefMgr::NodeDef::InputParam>, COMDAT

; 958  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@QEAA@XZ ENDP ; std::allocator<AINBNodeDefMgr::NodeDef::InputParam>::allocator<AINBNodeDefMgr::NodeDef::InputParam>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@$$QEAV01@@Z PROC ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r10d, r10d
	mov	r9, QWORD PTR [rdx+16]

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], r10
	mov	QWORD PTR [rdx+8], r10
	mov	QWORD PTR [rdx], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rax

; 701  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 702  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 703  :     }

	mov	rax, rcx

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9

; 701  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 702  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 703  :     }

	ret	0
??0?$vector@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@$$QEAV01@@Z ENDP ; std::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::vector<enum AINBNodeDefMgr::NodeDef::CategoryEnum,std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAA@$$QEAV01@@Z PROC ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r10d, r10d
	mov	r9, QWORD PTR [rdx+16]

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], r10
	mov	QWORD PTR [rdx+8], r10
	mov	QWORD PTR [rdx], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rax

; 701  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 702  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 703  :     }

	mov	rax, rcx

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9

; 701  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 702  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 703  :     }

	ret	0
??0?$vector@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAA@$$QEAV01@@Z ENDP ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::vector<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAA@$$QEAV01@@Z PROC ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r10d, r10d
	mov	r9, QWORD PTR [rdx+16]

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], r10
	mov	QWORD PTR [rdx+8], r10
	mov	QWORD PTR [rdx], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rax

; 701  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 702  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 703  :     }

	mov	rax, rcx

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9

; 701  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 702  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 703  :     }

	ret	0
??0?$vector@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@2@@std@@QEAA@$$QEAV01@@Z ENDP ; std::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::vector<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >,std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YA$$QEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YA$$QEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@AEAV10@@Z PROC ; std::forward<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YA$$QEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@AEAV10@@Z ENDP ; std::forward<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@YAAEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEBQEAU123@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@YAAEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEBQEAU123@@Z PROC ; std::forward<AINBNodeDefMgr::NodeDef::ImmediateParam * const &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@YAAEBQEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEBQEAU123@@Z ENDP ; std::forward<AINBNodeDefMgr::NodeDef::ImmediateParam * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Unwrap_iter@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@@ranges@std@@YA?A_T$$QEAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Unwrap_iter@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@@ranges@std@@YA?A_T$$QEAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z PROC ; std::ranges::_Unwrap_iter<AINBNodeDefMgr::NodeDef::ImmediateParam *,AINBNodeDefMgr::NodeDef::ImmediateParam *>, COMDAT

; 2488 :         _STL_INTERNAL_STATIC_ASSERT(sentinel_for<remove_cvref_t<_Sent>, remove_cvref_t<_Iter>>);
; 2489 :         if constexpr (is_pointer_v<remove_cvref_t<_Iter>>) {
; 2490 :             return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 2491 :         } else if constexpr (_Unwrappable_sentinel_for<_Sent, _Iter>) {
; 2492 :             return static_cast<_Iter&&>(_It)._Unwrapped();
; 2493 :         } else {
; 2494 :             return static_cast<_Iter&&>(_It);
; 2495 :         }
; 2496 :     }

	ret	0
??$_Unwrap_iter@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@@ranges@std@@YA?A_T$$QEAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z ENDP ; std::ranges::_Unwrap_iter<AINBNodeDefMgr::NodeDef::ImmediateParam *,AINBNodeDefMgr::NodeDef::ImmediateParam *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Unwrap_sent@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@@ranges@std@@YA?A_T$$QEAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z
_TEXT	SEGMENT
_Se$ = 8
??$_Unwrap_sent@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@@ranges@std@@YA?A_T$$QEAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z PROC ; std::ranges::_Unwrap_sent<AINBNodeDefMgr::NodeDef::ImmediateParam *,AINBNodeDefMgr::NodeDef::ImmediateParam *>, COMDAT

; 2501 :         _STL_INTERNAL_STATIC_ASSERT(sentinel_for<remove_cvref_t<_Sent>, remove_cvref_t<_Iter>>);
; 2502 :         if constexpr (is_pointer_v<remove_cvref_t<_Sent>>) {
; 2503 :             return _Se + 0;

	mov	rax, QWORD PTR [rcx]

; 2504 :         } else if constexpr (_Unwrappable_sentinel_for<_Sent, _Iter>) {
; 2505 :             return static_cast<_Sent&&>(_Se)._Unwrapped();
; 2506 :         } else {
; 2507 :             return static_cast<_Sent&&>(_Se);
; 2508 :         }
; 2509 :     }

	ret	0
??$_Unwrap_sent@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@@ranges@std@@YA?A_T$$QEAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@Z ENDP ; std::ranges::_Unwrap_sent<AINBNodeDefMgr::NodeDef::ImmediateParam *,AINBNodeDefMgr::NodeDef::ImmediateParam *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@00AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z
_TEXT	SEGMENT
$T1 = 32
_Backout$ = 40
__$ArrayPad$ = 64
_First$ = 96
_Last$ = 104
_Dest$ = 112
_Al$ = 120
??$_Uninitialized_copy@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@00AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z PROC ; std::_Uninitialized_copy<AINBNodeDefMgr::NodeDef::ImmediateParam *,AINBNodeDefMgr::NodeDef::ImmediateParam *,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >, COMDAT

; 1819 :     _InIt _First, _Se _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN49:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbx, r8
	mov	rsi, rdx
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _Backout$[rsp], xmm0

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR _Backout$[rsp], rbx
	mov	QWORD PTR _Backout$[rsp+8], rbx
	mov	QWORD PTR _Backout$[rsp+16], r9

; 1820 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1821 :     // note: only called internally from elsewhere in the STL
; 1822 :     using _Ptrval = typename _Alloc::value_type*;
; 1823 : 
; 1824 : #ifdef __cpp_lib_concepts
; 1825 :     auto _UFirst = _RANGES _Unwrap_iter<_Se>(_STD move(_First));
; 1826 :     auto _ULast  = _RANGES _Unwrap_sent<_InIt>(_STD move(_Last));
; 1827 : #else // ^^^ __cpp_lib_concepts / !__cpp_lib_concepts vvv
; 1828 :     // In pre-concepts world, _Uninitialized_copy should only ever be called with an iterator
; 1829 :     // and sentinel of the same type, so `_Get_unwrapped` is fine to call.
; 1830 :     auto _UFirst = _Get_unwrapped(_STD move(_First));
; 1831 :     auto _ULast  = _Get_unwrapped(_STD move(_Last));
; 1832 : #endif // ^^^ !__cpp_lib_concepts ^^^
; 1833 : 
; 1834 :     constexpr bool _Can_memmove = _Sent_copy_cat<decltype(_UFirst), decltype(_ULast), _Ptrval>::_Bitcopy_constructible
; 1835 :                                && _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>::value;
; 1836 : 
; 1837 :     if constexpr (_Can_memmove) {
; 1838 : #if _HAS_CXX20
; 1839 :         if (!_STD is_constant_evaluated())
; 1840 : #endif // _HAS_CXX20
; 1841 :         {
; 1842 :             if constexpr (is_same_v<decltype(_UFirst), decltype(_ULast)>) {
; 1843 :                 _Copy_memmove(_To_address(_UFirst), _To_address(_ULast), _Unfancy(_Dest));
; 1844 :                 _Dest += _ULast - _UFirst;
; 1845 :             } else {
; 1846 :                 const auto _Count = static_cast<size_t>(_ULast - _UFirst);
; 1847 :                 _Copy_memmove_n(_To_address(_UFirst), _Count, _Unfancy(_Dest));
; 1848 :                 _Dest += _Count;
; 1849 :             }
; 1850 :             return _Dest;
; 1851 :         }
; 1852 :     }
; 1853 : 
; 1854 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1855 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, rdx
	je	SHORT $LN46@Uninitiali

; 1819 :     _InIt _First, _Se _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	lea	rdi, QWORD PTR [rcx+40]
$LL4@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T1[rsp], rbx
	lea	rdx, QWORD PTR [rdi-40]
	mov	rcx, rbx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, DWORD PTR [rdi-8]
	mov	DWORD PTR [rbx+32], eax
	lea	rcx, QWORD PTR [rbx+40]
	mov	rdx, rdi
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rbx+72]
	lea	rdx, QWORD PTR [rdi+32]
	call	??0?$vector@W4FlagsStruct@AINBFile@@V?$allocator@W4FlagsStruct@AINBFile@@@std@@@std@@QEAA@AEBV01@@Z ; std::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rbx, 96					; 00000060H
	mov	QWORD PTR _Backout$[rsp+8], rbx

; 1820 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1821 :     // note: only called internally from elsewhere in the STL
; 1822 :     using _Ptrval = typename _Alloc::value_type*;
; 1823 : 
; 1824 : #ifdef __cpp_lib_concepts
; 1825 :     auto _UFirst = _RANGES _Unwrap_iter<_Se>(_STD move(_First));
; 1826 :     auto _ULast  = _RANGES _Unwrap_sent<_InIt>(_STD move(_Last));
; 1827 : #else // ^^^ __cpp_lib_concepts / !__cpp_lib_concepts vvv
; 1828 :     // In pre-concepts world, _Uninitialized_copy should only ever be called with an iterator
; 1829 :     // and sentinel of the same type, so `_Get_unwrapped` is fine to call.
; 1830 :     auto _UFirst = _Get_unwrapped(_STD move(_First));
; 1831 :     auto _ULast  = _Get_unwrapped(_STD move(_Last));
; 1832 : #endif // ^^^ !__cpp_lib_concepts ^^^
; 1833 : 
; 1834 :     constexpr bool _Can_memmove = _Sent_copy_cat<decltype(_UFirst), decltype(_ULast), _Ptrval>::_Bitcopy_constructible
; 1835 :                                && _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>::value;
; 1836 : 
; 1837 :     if constexpr (_Can_memmove) {
; 1838 : #if _HAS_CXX20
; 1839 :         if (!_STD is_constant_evaluated())
; 1840 : #endif // _HAS_CXX20
; 1841 :         {
; 1842 :             if constexpr (is_same_v<decltype(_UFirst), decltype(_ULast)>) {
; 1843 :                 _Copy_memmove(_To_address(_UFirst), _To_address(_ULast), _Unfancy(_Dest));
; 1844 :                 _Dest += _ULast - _UFirst;
; 1845 :             } else {
; 1846 :                 const auto _Count = static_cast<size_t>(_ULast - _UFirst);
; 1847 :                 _Copy_memmove_n(_To_address(_UFirst), _Count, _Unfancy(_Dest));
; 1848 :                 _Dest += _Count;
; 1849 :             }
; 1850 :             return _Dest;
; 1851 :         }
; 1852 :     }
; 1853 : 
; 1854 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1855 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	rdi, 96					; 00000060H
	lea	rcx, QWORD PTR [rdi-40]
	cmp	rcx, rsi
	jne	SHORT $LL4@Uninitiali
$LN46@Uninitiali:

; 1856 :         _Backout._Emplace_back(*_UFirst);
; 1857 :     }
; 1858 : 
; 1859 :     return _Backout._Release();
; 1860 : }

	mov	rax, rbx
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+104]
	mov	rsi, QWORD PTR [rsp+112]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
??$_Uninitialized_copy@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@00AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z ENDP ; std::_Uninitialized_copy<AINBNodeDefMgr::NodeDef::ImmediateParam *,AINBNodeDefMgr::NodeDef::ImmediateParam *,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Backout$ = 40
__$ArrayPad$ = 64
_First$ = 96
_Last$ = 104
_Dest$ = 112
_Al$ = 120
?dtor$0@?0???$_Uninitialized_copy@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@00AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z@4HA PROC ; `std::_Uninitialized_copy<AINBNodeDefMgr::NodeDef::ImmediateParam *,AINBNodeDefMgr::NodeDef::ImmediateParam *,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Backout$[rdx]
	jmp	??1?$_Uninitialized_backout_al@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >::~_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >
?dtor$0@?0???$_Uninitialized_copy@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@00AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z@4HA ENDP ; `std::_Uninitialized_copy<AINBNodeDefMgr::NodeDef::ImmediateParam *,AINBNodeDefMgr::NodeDef::ImmediateParam *,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Backout$ = 40
__$ArrayPad$ = 64
_First$ = 96
_Last$ = 104
_Dest$ = 112
_Al$ = 120
?dtor$1@?0???$_Uninitialized_copy@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@00AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z@4HA PROC ; `std::_Uninitialized_copy<AINBNodeDefMgr::NodeDef::ImmediateParam *,AINBNodeDefMgr::NodeDef::ImmediateParam *,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >'::`1'::dtor$1
	mov	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0???$_Uninitialized_copy@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@00AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z@4HA ENDP ; `std::_Uninitialized_copy<AINBNodeDefMgr::NodeDef::ImmediateParam *,AINBNodeDefMgr::NodeDef::ImmediateParam *,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Backout$ = 40
__$ArrayPad$ = 64
_First$ = 96
_Last$ = 104
_Dest$ = 112
_Al$ = 120
?dtor$2@?0???$_Uninitialized_copy@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@00AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z@4HA PROC ; `std::_Uninitialized_copy<AINBNodeDefMgr::NodeDef::ImmediateParam *,AINBNodeDefMgr::NodeDef::ImmediateParam *,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >'::`1'::dtor$2
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 40					; 00000028H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0???$_Uninitialized_copy@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU123@00AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@@Z@4HA ENDP ; `std::_Uninitialized_copy<AINBNodeDefMgr::NodeDef::ImmediateParam *,AINBNodeDefMgr::NodeDef::ImmediateParam *,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YA$$QEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YA$$QEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@AEAV10@@Z PROC ; std::forward<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YA$$QEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@AEAV10@@Z ENDP ; std::forward<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@@std@@YAAEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@AEBQEAU123@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@@std@@YAAEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@AEBQEAU123@@Z PROC ; std::forward<AINBNodeDefMgr::NodeDef::InputParam * const &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@@std@@YAAEBQEAUInputParam@NodeDef@AINBNodeDefMgr@@AEBQEAU123@@Z ENDP ; std::forward<AINBNodeDefMgr::NodeDef::InputParam * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Unwrap_iter@PEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@@ranges@std@@YA?A_T$$QEAPEAUInputParam@NodeDef@AINBNodeDefMgr@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Unwrap_iter@PEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@@ranges@std@@YA?A_T$$QEAPEAUInputParam@NodeDef@AINBNodeDefMgr@@@Z PROC ; std::ranges::_Unwrap_iter<AINBNodeDefMgr::NodeDef::InputParam *,AINBNodeDefMgr::NodeDef::InputParam *>, COMDAT

; 2488 :         _STL_INTERNAL_STATIC_ASSERT(sentinel_for<remove_cvref_t<_Sent>, remove_cvref_t<_Iter>>);
; 2489 :         if constexpr (is_pointer_v<remove_cvref_t<_Iter>>) {
; 2490 :             return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 2491 :         } else if constexpr (_Unwrappable_sentinel_for<_Sent, _Iter>) {
; 2492 :             return static_cast<_Iter&&>(_It)._Unwrapped();
; 2493 :         } else {
; 2494 :             return static_cast<_Iter&&>(_It);
; 2495 :         }
; 2496 :     }

	ret	0
??$_Unwrap_iter@PEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@@ranges@std@@YA?A_T$$QEAPEAUInputParam@NodeDef@AINBNodeDefMgr@@@Z ENDP ; std::ranges::_Unwrap_iter<AINBNodeDefMgr::NodeDef::InputParam *,AINBNodeDefMgr::NodeDef::InputParam *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Unwrap_sent@PEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@@ranges@std@@YA?A_T$$QEAPEAUInputParam@NodeDef@AINBNodeDefMgr@@@Z
_TEXT	SEGMENT
_Se$ = 8
??$_Unwrap_sent@PEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@@ranges@std@@YA?A_T$$QEAPEAUInputParam@NodeDef@AINBNodeDefMgr@@@Z PROC ; std::ranges::_Unwrap_sent<AINBNodeDefMgr::NodeDef::InputParam *,AINBNodeDefMgr::NodeDef::InputParam *>, COMDAT

; 2501 :         _STL_INTERNAL_STATIC_ASSERT(sentinel_for<remove_cvref_t<_Sent>, remove_cvref_t<_Iter>>);
; 2502 :         if constexpr (is_pointer_v<remove_cvref_t<_Sent>>) {
; 2503 :             return _Se + 0;

	mov	rax, QWORD PTR [rcx]

; 2504 :         } else if constexpr (_Unwrappable_sentinel_for<_Sent, _Iter>) {
; 2505 :             return static_cast<_Sent&&>(_Se)._Unwrapped();
; 2506 :         } else {
; 2507 :             return static_cast<_Sent&&>(_Se);
; 2508 :         }
; 2509 :     }

	ret	0
??$_Unwrap_sent@PEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@@ranges@std@@YA?A_T$$QEAPEAUInputParam@NodeDef@AINBNodeDefMgr@@@Z ENDP ; std::ranges::_Unwrap_sent<AINBNodeDefMgr::NodeDef::InputParam *,AINBNodeDefMgr::NodeDef::InputParam *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@00AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z
_TEXT	SEGMENT
_Backout$ = 32
__$ArrayPad$ = 56
_First$ = 80
_Last$ = 88
_Dest$ = 96
_Al$ = 104
??$_Uninitialized_copy@PEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@00AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z PROC ; std::_Uninitialized_copy<AINBNodeDefMgr::NodeDef::InputParam *,AINBNodeDefMgr::NodeDef::InputParam *,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >, COMDAT

; 1819 :     _InIt _First, _Se _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN44:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbx, rcx
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _Backout$[rsp], xmm0

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR _Backout$[rsp], r8
	mov	QWORD PTR _Backout$[rsp+8], r8
	mov	QWORD PTR _Backout$[rsp+16], r9

; 1820 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1821 :     // note: only called internally from elsewhere in the STL
; 1822 :     using _Ptrval = typename _Alloc::value_type*;
; 1823 : 
; 1824 : #ifdef __cpp_lib_concepts
; 1825 :     auto _UFirst = _RANGES _Unwrap_iter<_Se>(_STD move(_First));
; 1826 :     auto _ULast  = _RANGES _Unwrap_sent<_InIt>(_STD move(_Last));
; 1827 : #else // ^^^ __cpp_lib_concepts / !__cpp_lib_concepts vvv
; 1828 :     // In pre-concepts world, _Uninitialized_copy should only ever be called with an iterator
; 1829 :     // and sentinel of the same type, so `_Get_unwrapped` is fine to call.
; 1830 :     auto _UFirst = _Get_unwrapped(_STD move(_First));
; 1831 :     auto _ULast  = _Get_unwrapped(_STD move(_Last));
; 1832 : #endif // ^^^ !__cpp_lib_concepts ^^^
; 1833 : 
; 1834 :     constexpr bool _Can_memmove = _Sent_copy_cat<decltype(_UFirst), decltype(_ULast), _Ptrval>::_Bitcopy_constructible
; 1835 :                                && _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>::value;
; 1836 : 
; 1837 :     if constexpr (_Can_memmove) {
; 1838 : #if _HAS_CXX20
; 1839 :         if (!_STD is_constant_evaluated())
; 1840 : #endif // _HAS_CXX20
; 1841 :         {
; 1842 :             if constexpr (is_same_v<decltype(_UFirst), decltype(_ULast)>) {
; 1843 :                 _Copy_memmove(_To_address(_UFirst), _To_address(_ULast), _Unfancy(_Dest));
; 1844 :                 _Dest += _ULast - _UFirst;
; 1845 :             } else {
; 1846 :                 const auto _Count = static_cast<size_t>(_ULast - _UFirst);
; 1847 :                 _Copy_memmove_n(_To_address(_UFirst), _Count, _Unfancy(_Dest));
; 1848 :                 _Dest += _Count;
; 1849 :             }
; 1850 :             return _Dest;
; 1851 :         }
; 1852 :     }
; 1853 : 
; 1854 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1855 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, rdx
	je	SHORT $LN41@Uninitiali
$LL4@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rdx, rbx
	mov	rcx, rdi
	call	??0InputParam@NodeDef@AINBNodeDefMgr@@QEAA@AEBU012@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rdi, 144				; 00000090H
	mov	QWORD PTR _Backout$[rsp+8], rdi

; 1820 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1821 :     // note: only called internally from elsewhere in the STL
; 1822 :     using _Ptrval = typename _Alloc::value_type*;
; 1823 : 
; 1824 : #ifdef __cpp_lib_concepts
; 1825 :     auto _UFirst = _RANGES _Unwrap_iter<_Se>(_STD move(_First));
; 1826 :     auto _ULast  = _RANGES _Unwrap_sent<_InIt>(_STD move(_Last));
; 1827 : #else // ^^^ __cpp_lib_concepts / !__cpp_lib_concepts vvv
; 1828 :     // In pre-concepts world, _Uninitialized_copy should only ever be called with an iterator
; 1829 :     // and sentinel of the same type, so `_Get_unwrapped` is fine to call.
; 1830 :     auto _UFirst = _Get_unwrapped(_STD move(_First));
; 1831 :     auto _ULast  = _Get_unwrapped(_STD move(_Last));
; 1832 : #endif // ^^^ !__cpp_lib_concepts ^^^
; 1833 : 
; 1834 :     constexpr bool _Can_memmove = _Sent_copy_cat<decltype(_UFirst), decltype(_ULast), _Ptrval>::_Bitcopy_constructible
; 1835 :                                && _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>::value;
; 1836 : 
; 1837 :     if constexpr (_Can_memmove) {
; 1838 : #if _HAS_CXX20
; 1839 :         if (!_STD is_constant_evaluated())
; 1840 : #endif // _HAS_CXX20
; 1841 :         {
; 1842 :             if constexpr (is_same_v<decltype(_UFirst), decltype(_ULast)>) {
; 1843 :                 _Copy_memmove(_To_address(_UFirst), _To_address(_ULast), _Unfancy(_Dest));
; 1844 :                 _Dest += _ULast - _UFirst;
; 1845 :             } else {
; 1846 :                 const auto _Count = static_cast<size_t>(_ULast - _UFirst);
; 1847 :                 _Copy_memmove_n(_To_address(_UFirst), _Count, _Unfancy(_Dest));
; 1848 :                 _Dest += _Count;
; 1849 :             }
; 1850 :             return _Dest;
; 1851 :         }
; 1852 :     }
; 1853 : 
; 1854 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1855 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	rbx, 144				; 00000090H
	cmp	rbx, rsi
	jne	SHORT $LL4@Uninitiali
$LN41@Uninitiali:

; 1856 :         _Backout._Emplace_back(*_UFirst);
; 1857 :     }
; 1858 : 
; 1859 :     return _Backout._Release();
; 1860 : }

	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
??$_Uninitialized_copy@PEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@00AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z ENDP ; std::_Uninitialized_copy<AINBNodeDefMgr::NodeDef::InputParam *,AINBNodeDefMgr::NodeDef::InputParam *,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Backout$ = 32
__$ArrayPad$ = 56
_First$ = 80
_Last$ = 88
_Dest$ = 96
_Al$ = 104
?dtor$0@?0???$_Uninitialized_copy@PEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@00AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z@4HA PROC ; `std::_Uninitialized_copy<AINBNodeDefMgr::NodeDef::InputParam *,AINBNodeDefMgr::NodeDef::InputParam *,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Backout$[rdx]
	jmp	??1?$_Uninitialized_backout_al@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >::~_Uninitialized_backout_al<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >
?dtor$0@?0???$_Uninitialized_copy@PEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU123@00AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@@Z@4HA ENDP ; `std::_Uninitialized_copy<AINBNodeDefMgr::NodeDef::InputParam *,AINBNodeDefMgr::NodeDef::InputParam *,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YA$$QEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YA$$QEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@AEAV10@@Z PROC ; std::move<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YA$$QEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@0@AEAV10@@Z ENDP ; std::move<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$exchange@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@$$T@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEAPEAU123@$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@$$T@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEAPEAU123@$$QEA$$T@Z PROC ; std::exchange<AINBNodeDefMgr::NodeDef::ImmediateParam *,std::nullptr_t>, COMDAT

; 753  :     // assign _New_val to _Val, return previous _Val
; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 756  :     return _Old_val;
; 757  : }

	ret	0
??$exchange@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@$$T@std@@YAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEAPEAU123@$$QEA$$T@Z ENDP ; std::exchange<AINBNodeDefMgr::NodeDef::ImmediateParam *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU234@PEAU234@@?$_Compressed_pair@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@1@$$QEAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@22@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
<_Val2_0>$ = 32
<_Val2_1>$ = 40
<_Val2_2>$ = 48
??$?0V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU234@PEAU234@@?$_Compressed_pair@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@1@$$QEAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@22@Z PROC ; std::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::ImmediateParam> >,1>::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::ImmediateParam> >,1><std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>,AINBNodeDefMgr::NodeDef::ImmediateParam *,AINBNodeDefMgr::NodeDef::ImmediateParam *,AINBNodeDefMgr::NodeDef::ImmediateParam *>, COMDAT

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR <_Val2_2>$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR <_Val2_1>$[rsp]
	mov	rdx, QWORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	0
??$?0V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@PEAU234@PEAU234@@?$_Compressed_pair@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@1@$$QEAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@22@Z ENDP ; std::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::ImmediateParam> >,1>::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::ImmediateParam> >,1><std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam>,AINBNodeDefMgr::NodeDef::ImmediateParam *,AINBNodeDefMgr::NodeDef::ImmediateParam *,AINBNodeDefMgr::NodeDef::ImmediateParam *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YA$$QEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YA$$QEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@AEAV10@@Z PROC ; std::move<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@YA$$QEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@0@AEAV10@@Z ENDP ; std::move<std::allocator<AINBNodeDefMgr::NodeDef::InputParam> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$exchange@PEAUInputParam@NodeDef@AINBNodeDefMgr@@$$T@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@AEAPEAU123@$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAUInputParam@NodeDef@AINBNodeDefMgr@@$$T@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@AEAPEAU123@$$QEA$$T@Z PROC ; std::exchange<AINBNodeDefMgr::NodeDef::InputParam *,std::nullptr_t>, COMDAT

; 753  :     // assign _New_val to _Val, return previous _Val
; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 756  :     return _Old_val;
; 757  : }

	ret	0
??$exchange@PEAUInputParam@NodeDef@AINBNodeDefMgr@@$$T@std@@YAPEAUInputParam@NodeDef@AINBNodeDefMgr@@AEAPEAU123@$$QEA$$T@Z ENDP ; std::exchange<AINBNodeDefMgr::NodeDef::InputParam *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@PEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU234@PEAU234@@?$_Compressed_pair@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@1@$$QEAPEAUInputParam@NodeDef@AINBNodeDefMgr@@22@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
<_Val2_0>$ = 32
<_Val2_1>$ = 40
<_Val2_2>$ = 48
??$?0V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@PEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU234@PEAU234@@?$_Compressed_pair@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@1@$$QEAPEAUInputParam@NodeDef@AINBNodeDefMgr@@22@Z PROC ; std::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::InputParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::InputParam> >,1>::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::InputParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::InputParam> >,1><std::allocator<AINBNodeDefMgr::NodeDef::InputParam>,AINBNodeDefMgr::NodeDef::InputParam *,AINBNodeDefMgr::NodeDef::InputParam *,AINBNodeDefMgr::NodeDef::InputParam *>, COMDAT

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR <_Val2_2>$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR <_Val2_1>$[rsp]
	mov	rdx, QWORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	0
??$?0V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@PEAUInputParam@NodeDef@AINBNodeDefMgr@@PEAU234@PEAU234@@?$_Compressed_pair@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@1@$$QEAPEAUInputParam@NodeDef@AINBNodeDefMgr@@22@Z ENDP ; std::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::InputParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::InputParam> >,1>::_Compressed_pair<std::allocator<AINBNodeDefMgr::NodeDef::InputParam>,std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::InputParam> >,1><std::allocator<AINBNodeDefMgr::NodeDef::InputParam>,AINBNodeDefMgr::NodeDef::InputParam *,AINBNodeDefMgr::NodeDef::InputParam *,AINBNodeDefMgr::NodeDef::InputParam *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@YA$$QEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@YA$$QEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@0@AEAV10@@Z PROC ; std::move<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@YA$$QEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@0@AEAV10@@Z ENDP ; std::move<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$exchange@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@$$T@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@AEAPEAW4123@$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@$$T@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@AEAPEAW4123@$$QEA$$T@Z PROC ; std::exchange<enum AINBNodeDefMgr::NodeDef::CategoryEnum *,std::nullptr_t>, COMDAT

; 753  :     // assign _New_val to _Val, return previous _Val
; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 756  :     return _Old_val;
; 757  : }

	ret	0
??$exchange@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@$$T@std@@YAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@AEAPEAW4123@$$QEA$$T@Z ENDP ; std::exchange<enum AINBNodeDefMgr::NodeDef::CategoryEnum *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4234@PEAW4234@@?$_Compressed_pair@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@1@$$QEAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@22@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
<_Val2_0>$ = 32
<_Val2_1>$ = 40
<_Val2_2>$ = 48
??$?0V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4234@PEAW4234@@?$_Compressed_pair@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@1@$$QEAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@22@Z PROC ; std::_Compressed_pair<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum>,std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >,1>::_Compressed_pair<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum>,std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >,1><std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum>,enum AINBNodeDefMgr::NodeDef::CategoryEnum *,enum AINBNodeDefMgr::NodeDef::CategoryEnum *,enum AINBNodeDefMgr::NodeDef::CategoryEnum *>, COMDAT

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR <_Val2_2>$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR <_Val2_1>$[rsp]
	mov	rdx, QWORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	0
??$?0V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@PEAW4234@PEAW4234@@?$_Compressed_pair@V?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@V?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@1@$$QEAPEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@22@Z ENDP ; std::_Compressed_pair<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum>,std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >,1>::_Compressed_pair<std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum>,std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >,1><std::allocator<enum AINBNodeDefMgr::NodeDef::CategoryEnum>,enum AINBNodeDefMgr::NodeDef::CategoryEnum *,enum AINBNodeDefMgr::NodeDef::CategoryEnum *,enum AINBNodeDefMgr::NodeDef::CategoryEnum *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@AEAV10@@Z PROC ; std::move<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::move<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$exchange@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@$$T@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAPEAV10@$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@$$T@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAPEAV10@$$QEA$$T@Z PROC ; std::exchange<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > *,std::nullptr_t>, COMDAT

; 753  :     // assign _New_val to _Val, return previous _Val
; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 756  :     return _Old_val;
; 757  : }

	ret	0
??$exchange@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@$$T@std@@YAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAPEAV10@$$QEA$$T@Z ENDP ; std::exchange<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@PEAV21@PEAV21@@?$_Compressed_pair@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@$$QEAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@22@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
<_Val2_0>$ = 32
<_Val2_1>$ = 40
<_Val2_2>$ = 48
??$?0V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@PEAV21@PEAV21@@?$_Compressed_pair@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@$$QEAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@22@Z PROC ; std::_Compressed_pair<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >,std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >,1>::_Compressed_pair<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >,std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >,1><std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >,std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > *,std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > *,std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > *>, COMDAT

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR <_Val2_2>$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR <_Val2_1>$[rsp]
	mov	rdx, QWORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	0
??$?0V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@PEAV21@PEAV21@@?$_Compressed_pair@V?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@$$QEAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@22@Z ENDP ; std::_Compressed_pair<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >,std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >,1>::_Compressed_pair<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >,std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >,1><std::allocator<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > >,std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > *,std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > *,std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@AEAV10@@Z PROC ; std::move<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::move<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$exchange@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@$$T@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAPEAV10@$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@$$T@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAPEAV10@$$QEA$$T@Z PROC ; std::exchange<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *,std::nullptr_t>, COMDAT

; 753  :     // assign _New_val to _Val, return previous _Val
; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 756  :     return _Old_val;
; 757  : }

	ret	0
??$exchange@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@$$T@std@@YAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAPEAV10@$$QEA$$T@Z ENDP ; std::exchange<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@PEAV21@PEAV21@@?$_Compressed_pair@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@$$QEAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@22@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
<_Val2_0>$ = 32
<_Val2_1>$ = 40
<_Val2_2>$ = 48
??$?0V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@PEAV21@PEAV21@@?$_Compressed_pair@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@$$QEAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@22@Z PROC ; std::_Compressed_pair<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >,std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >,1>::_Compressed_pair<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >,std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >,1><std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >,std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *,std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *,std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *>, COMDAT

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR <_Val2_2>$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR <_Val2_1>$[rsp]
	mov	rdx, QWORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	0
??$?0V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@PEAV21@PEAV21@@?$_Compressed_pair@V?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@1@$$QEAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@22@Z ENDP ; std::_Compressed_pair<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >,std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >,1>::_Compressed_pair<std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >,std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >,1><std::allocator<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > >,std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *,std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *,std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@00@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
_End$ = 32
??0?$_Vector_val@U?$_Simple_types@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@00@Z PROC ; std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::ImmediateParam> >, COMDAT

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9
	ret	0
??0?$_Vector_val@U?$_Simple_types@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@00@Z ENDP ; std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::ImmediateParam> >::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::ImmediateParam> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@PEAUInputParam@NodeDef@AINBNodeDefMgr@@00@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
_End$ = 32
??0?$_Vector_val@U?$_Simple_types@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@PEAUInputParam@NodeDef@AINBNodeDefMgr@@00@Z PROC ; std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::InputParam> >::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::InputParam> >, COMDAT

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9
	ret	0
??0?$_Vector_val@U?$_Simple_types@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@PEAUInputParam@NodeDef@AINBNodeDefMgr@@00@Z ENDP ; std::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::InputParam> >::_Vector_val<std::_Simple_types<AINBNodeDefMgr::NodeDef::InputParam> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@00@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
_End$ = 32
??0?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@00@Z PROC ; std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >, COMDAT

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9
	ret	0
??0?$_Vector_val@U?$_Simple_types@W4CategoryEnum@NodeDef@AINBNodeDefMgr@@@std@@@std@@QEAA@PEAW4CategoryEnum@NodeDef@AINBNodeDefMgr@@00@Z ENDP ; std::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >::_Vector_val<std::_Simple_types<enum AINBNodeDefMgr::NodeDef::CategoryEnum> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAA@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@00@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
_End$ = 32
??0?$_Vector_val@U?$_Simple_types@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAA@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@00@Z PROC ; std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >, COMDAT

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAA@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@1@00@Z ENDP ; std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAA@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@00@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
_End$ = 32
??0?$_Vector_val@U?$_Simple_types@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAA@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@00@Z PROC ; std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >, COMDAT

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@@std@@QEAA@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@1@00@Z ENDP ; std::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >::_Vector_val<std::_Simple_types<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEAPEAU123@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEAPEAU123@@Z PROC ; std::forward<AINBNodeDefMgr::NodeDef::ImmediateParam *>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@PEAUImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAPEAUImmediateParam@NodeDef@AINBNodeDefMgr@@AEAPEAU123@@Z ENDP ; std::forward<AINBNodeDefMgr::NodeDef::ImmediateParam *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@PEAUInputParam@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAPEAUInputParam@NodeDef@AINBNodeDefMgr@@AEAPEAU123@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAUInputParam@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAPEAUInputParam@NodeDef@AINBNodeDefMgr@@AEAPEAU123@@Z PROC ; std::forward<AINBNodeDefMgr::NodeDef::InputParam *>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@PEAUInputParam@NodeDef@AINBNodeDefMgr@@@std@@YA$$QEAPEAUInputParam@NodeDef@AINBNodeDefMgr@@AEAPEAU123@@Z ENDP ; std::forward<AINBNodeDefMgr::NodeDef::InputParam *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA$$QEAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAPEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA$$QEAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAPEAV10@@Z PROC ; std::forward<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > *>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@PEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA$$QEAPEAV?$vector@UInputParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UInputParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAPEAV10@@Z ENDP ; std::forward<std::vector<AINBNodeDefMgr::NodeDef::InputParam,std::allocator<AINBNodeDefMgr::NodeDef::InputParam> > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA$$QEAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAPEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA$$QEAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAPEAV10@@Z PROC ; std::forward<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@PEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@std@@@std@@YA$$QEAPEAV?$vector@UImmediateParam@NodeDef@AINBNodeDefMgr@@V?$allocator@UImmediateParam@NodeDef@AINBNodeDefMgr@@@std@@@0@AEAPEAV10@@Z ENDP ; std::forward<std::vector<AINBNodeDefMgr::NodeDef::ImmediateParam,std::allocator<AINBNodeDefMgr::NodeDef::ImmediateParam> > *>
_TEXT	ENDS
END
