; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32822.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_04LBBEMOBJ@typ1@				; `string'
PUBLIC	??_C@_04KIOEMAHO@ttcf@				; `string'
PUBLIC	??_C@_04LLEFIKCJ@OTTO@				; `string'
PUBLIC	??_C@_04EICJPCEA@cmap@				; `string'
PUBLIC	??_C@_04NEODDMOL@head@				; `string'
PUBLIC	??_C@_04DACNFKGE@loca@				; `string'
PUBLIC	??_C@_04FMPHLIKP@hhea@				; `string'
PUBLIC	??_C@_04LLIHEPK@glyf@				; `string'
PUBLIC	??_C@_04HHMMLDJI@kern@				; `string'
PUBLIC	??_C@_04ONMNCIMC@hmtx@				; `string'
PUBLIC	??_C@_04HJGCPIEK@CFF?5@				; `string'
PUBLIC	??_C@_04PCFDEHHD@GPOS@				; `string'
PUBLIC	??_C@_04KODIGLGG@maxp@				; `string'
PUBLIC	??_C@_0BG@CONABPA@ProggyClean?4ttf?0?5?$CFdpx@	; `string'
PUBLIC	??_C@_0L@EPCGLJHG@?$CFs?0?5?$CF?40fpx@		; `string'
;	COMDAT ?full_ranges@?1??GetGlyphRangesChineseSimplifiedCommon@ImFontAtlas@@QEAAPEBGXZ@4PAGA
_BSS	SEGMENT
?full_ranges@?1??GetGlyphRangesChineseSimplifiedCommon@ImFontAtlas@@QEAAPEBGXZ@4PAGA DW 01395H DUP (?) ; `ImFontAtlas::GetGlyphRangesChineseSimplifiedCommon'::`2'::full_ranges
_BSS	ENDS
;	COMDAT ?full_ranges@?1??GetGlyphRangesJapanese@ImFontAtlas@@QEAAPEBGXZ@4PAGA
_BSS	SEGMENT
?full_ranges@?1??GetGlyphRangesJapanese@ImFontAtlas@@QEAAPEBGXZ@4PAGA DW 01779H DUP (?) ; `ImFontAtlas::GetGlyphRangesJapanese'::`2'::full_ranges
_BSS	ENDS
;	COMDAT ?accumulative_offsets_from_0x4E00@?1??GetGlyphRangesChineseSimplifiedCommon@ImFontAtlas@@QEAAPEBGXZ@4QBFB
CONST	SEGMENT
?accumulative_offsets_from_0x4E00@?1??GetGlyphRangesChineseSimplifiedCommon@ImFontAtlas@@QEAAPEBGXZ@4QBFB DW 00H ; `ImFontAtlas::GetGlyphRangesChineseSimplifiedCommon'::`2'::accumulative_offsets_from_0x4E00
	DW	01H
	DW	02H
	DW	04H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	03H
	DW	02H
	DW	01H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	05H
	DW	02H
	DW	01H
	DW	02H
	DW	03H
	DW	03H
	DW	03H
	DW	02H
	DW	02H
	DW	04H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	05H
	DW	02H
	DW	03H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	01H
	DW	04H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	05H
	DW	0aH
	DW	01H
	DW	02H
	DW	013H
	DW	02H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	01H
	DW	05H
	DW	01H
	DW	06H
	DW	03H
	DW	02H
	DW	01H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	08H
	DW	05H
	DW	01H
	DW	01H
	DW	04H
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	02H
	DW	01H
	DW	05H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	0aH
	DW	01H
	DW	01H
	DW	05H
	DW	02H
	DW	04H
	DW	06H
	DW	01H
	DW	04H
	DW	02H
	DW	02H
	DW	02H
	DW	0cH
	DW	02H
	DW	01H
	DW	01H
	DW	06H
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	01H
	DW	01H
	DW	04H
	DW	06H
	DW	05H
	DW	01H
	DW	04H
	DW	02H
	DW	02H
	DW	04H
	DW	0aH
	DW	07H
	DW	01H
	DW	01H
	DW	04H
	DW	02H
	DW	04H
	DW	02H
	DW	01H
	DW	04H
	DW	03H
	DW	06H
	DW	0aH
	DW	0cH
	DW	05H
	DW	07H
	DW	02H
	DW	0eH
	DW	02H
	DW	09H
	DW	01H
	DW	01H
	DW	06H
	DW	07H
	DW	0aH
	DW	04H
	DW	07H
	DW	0dH
	DW	01H
	DW	05H
	DW	04H
	DW	08H
	DW	04H
	DW	01H
	DW	01H
	DW	02H
	DW	01cH
	DW	05H
	DW	06H
	DW	01H
	DW	01H
	DW	05H
	DW	02H
	DW	05H
	DW	014H
	DW	02H
	DW	02H
	DW	09H
	DW	08H
	DW	0bH
	DW	02H
	DW	09H
	DW	011H
	DW	01H
	DW	08H
	DW	06H
	DW	08H
	DW	01bH
	DW	04H
	DW	06H
	DW	09H
	DW	014H
	DW	0bH
	DW	01bH
	DW	06H
	DW	044H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	02H
	DW	07H
	DW	06H
	DW	0bH
	DW	03H
	DW	03H
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	01H
	DW	08H
	DW	03H
	DW	04H
	DW	01H
	DW	05H
	DW	07H
	DW	02H
	DW	01H
	DW	04H
	DW	04H
	DW	08H
	DW	04H
	DW	02H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	04H
	DW	05H
	DW	06H
	DW	03H
	DW	06H
	DW	02H
	DW	0cH
	DW	03H
	DW	01H
	DW	03H
	DW	09H
	DW	02H
	DW	04H
	DW	03H
	DW	04H
	DW	01H
	DW	05H
	DW	03H
	DW	03H
	DW	01H
	DW	03H
	DW	07H
	DW	01H
	DW	05H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	03H
	DW	04H
	DW	05H
	DW	02H
	DW	03H
	DW	02H
	DW	06H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	07H
	DW	01H
	DW	07H
	DW	03H
	DW	04H
	DW	05H
	DW	0fH
	DW	02H
	DW	02H
	DW	01H
	DW	05H
	DW	03H
	DW	016H
	DW	013H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	05H
	DW	01H
	DW	01H
	DW	01H
	DW	06H
	DW	01H
	DW	01H
	DW	0cH
	DW	08H
	DW	02H
	DW	09H
	DW	012H
	DW	016H
	DW	04H
	DW	01H
	DW	01H
	DW	05H
	DW	01H
	DW	010H
	DW	01H
	DW	02H
	DW	07H
	DW	0aH
	DW	0fH
	DW	01H
	DW	01H
	DW	06H
	DW	02H
	DW	04H
	DW	01H
	DW	02H
	DW	04H
	DW	01H
	DW	06H
	DW	01H
	DW	01H
	DW	03H
	DW	02H
	DW	04H
	DW	01H
	DW	06H
	DW	04H
	DW	05H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	0aH
	DW	03H
	DW	01H
	DW	03H
	DW	02H
	DW	01H
	DW	09H
	DW	03H
	DW	02H
	DW	05H
	DW	07H
	DW	02H
	DW	013H
	DW	04H
	DW	03H
	DW	06H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	03H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	05H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	07H
	DW	01H
	DW	04H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	04H
	DW	04H
	DW	03H
	DW	08H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	03H
	DW	05H
	DW	01H
	DW	03H
	DW	01H
	DW	03H
	DW	04H
	DW	06H
	DW	02H
	DW	02H
	DW	0eH
	DW	04H
	DW	06H
	DW	06H
	DW	0bH
	DW	09H
	DW	01H
	DW	0fH
	DW	03H
	DW	01H
	DW	01cH
	DW	05H
	DW	02H
	DW	05H
	DW	05H
	DW	03H
	DW	01H
	DW	03H
	DW	04H
	DW	05H
	DW	04H
	DW	06H
	DW	0eH
	DW	03H
	DW	02H
	DW	03H
	DW	05H
	DW	015H
	DW	02H
	DW	07H
	DW	014H
	DW	0aH
	DW	01H
	DW	02H
	DW	013H
	DW	02H
	DW	04H
	DW	01cH
	DW	01cH
	DW	02H
	DW	03H
	DW	02H
	DW	01H
	DW	0eH
	DW	04H
	DW	01H
	DW	01aH
	DW	01cH
	DW	02aH
	DW	0cH
	DW	028H
	DW	03H
	DW	034H
	DW	04fH
	DW	05H
	DW	0eH
	DW	011H
	DW	03H
	DW	02H
	DW	02H
	DW	0bH
	DW	03H
	DW	04H
	DW	06H
	DW	03H
	DW	01H
	DW	08H
	DW	02H
	DW	017H
	DW	04H
	DW	05H
	DW	08H
	DW	0aH
	DW	04H
	DW	02H
	DW	07H
	DW	03H
	DW	05H
	DW	01H
	DW	01H
	DW	06H
	DW	03H
	DW	01H
	DW	02H
	DW	02H
	DW	02H
	DW	05H
	DW	01cH
	DW	01H
	DW	01H
	DW	07H
	DW	07H
	DW	014H
	DW	05H
	DW	03H
	DW	01dH
	DW	03H
	DW	011H
	DW	01aH
	DW	01H
	DW	08H
	DW	04H
	DW	01bH
	DW	03H
	DW	06H
	DW	0bH
	DW	017H
	DW	05H
	DW	03H
	DW	04H
	DW	06H
	DW	0dH
	DW	018H
	DW	010H
	DW	06H
	DW	05H
	DW	0aH
	DW	019H
	DW	023H
	DW	07H
	DW	03H
	DW	02H
	DW	03H
	DW	03H
	DW	0eH
	DW	03H
	DW	06H
	DW	02H
	DW	06H
	DW	01H
	DW	04H
	DW	02H
	DW	03H
	DW	08H
	DW	02H
	DW	01H
	DW	01H
	DW	03H
	DW	03H
	DW	03H
	DW	04H
	DW	01H
	DW	01H
	DW	0dH
	DW	02H
	DW	02H
	DW	04H
	DW	05H
	DW	02H
	DW	01H
	DW	0eH
	DW	0eH
	DW	01H
	DW	02H
	DW	02H
	DW	01H
	DW	04H
	DW	05H
	DW	02H
	DW	03H
	DW	01H
	DW	0eH
	DW	03H
	DW	0cH
	DW	03H
	DW	011H
	DW	02H
	DW	010H
	DW	05H
	DW	01H
	DW	02H
	DW	01H
	DW	08H
	DW	09H
	DW	03H
	DW	013H
	DW	04H
	DW	02H
	DW	02H
	DW	04H
	DW	011H
	DW	019H
	DW	015H
	DW	014H
	DW	01cH
	DW	04bH
	DW	01H
	DW	0aH
	DW	01dH
	DW	067H
	DW	04H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	04H
	DW	02H
	DW	04H
	DW	01H
	DW	02H
	DW	03H
	DW	018H
	DW	02H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	03H
	DW	08H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	06H
	DW	01H
	DW	05H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	04H
	DW	01H
	DW	01H
	DW	05H
	DW	02H
	DW	01H
	DW	05H
	DW	06H
	DW	0dH
	DW	09H
	DW	010H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	02H
	DW	03H
	DW	02H
	DW	04H
	DW	05H
	DW	02H
	DW	05H
	DW	02H
	DW	02H
	DW	03H
	DW	07H
	DW	0dH
	DW	07H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	03H
	DW	03H
	DW	02H
	DW	01H
	DW	06H
	DW	04H
	DW	09H
	DW	02H
	DW	01H
	DW	0eH
	DW	02H
	DW	0eH
	DW	02H
	DW	01H
	DW	012H
	DW	03H
	DW	04H
	DW	0eH
	DW	04H
	DW	0bH
	DW	029H
	DW	0fH
	DW	017H
	DW	0fH
	DW	017H
	DW	0b0H
	DW	01H
	DW	03H
	DW	04H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	05H
	DW	03H
	DW	01H
	DW	02H
	DW	03H
	DW	07H
	DW	03H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	04H
	DW	04H
	DW	06H
	DW	02H
	DW	04H
	DW	01H
	DW	09H
	DW	07H
	DW	01H
	DW	0aH
	DW	05H
	DW	08H
	DW	010H
	DW	01dH
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	03H
	DW	01H
	DW	03H
	DW	05H
	DW	02H
	DW	04H
	DW	05H
	DW	04H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	03H
	DW	03H
	DW	07H
	DW	01H
	DW	06H
	DW	0aH
	DW	01H
	DW	011H
	DW	01H
	DW	02cH
	DW	04H
	DW	06H
	DW	02H
	DW	01H
	DW	01H
	DW	06H
	DW	05H
	DW	04H
	DW	02H
	DW	0aH
	DW	01H
	DW	06H
	DW	09H
	DW	02H
	DW	08H
	DW	01H
	DW	018H
	DW	01H
	DW	02H
	DW	0dH
	DW	07H
	DW	08H
	DW	08H
	DW	02H
	DW	01H
	DW	04H
	DW	01H
	DW	03H
	DW	01H
	DW	03H
	DW	03H
	DW	05H
	DW	02H
	DW	05H
	DW	0aH
	DW	09H
	DW	04H
	DW	09H
	DW	0cH
	DW	02H
	DW	01H
	DW	06H
	DW	01H
	DW	0aH
	DW	01H
	DW	01H
	DW	07H
	DW	07H
	DW	04H
	DW	0aH
	DW	08H
	DW	03H
	DW	01H
	DW	0dH
	DW	04H
	DW	03H
	DW	01H
	DW	06H
	DW	01H
	DW	03H
	DW	05H
	DW	02H
	DW	01H
	DW	02H
	DW	011H
	DW	010H
	DW	05H
	DW	02H
	DW	010H
	DW	06H
	DW	01H
	DW	04H
	DW	02H
	DW	01H
	DW	03H
	DW	03H
	DW	06H
	DW	08H
	DW	05H
	DW	0bH
	DW	0bH
	DW	01H
	DW	03H
	DW	03H
	DW	02H
	DW	04H
	DW	06H
	DW	0aH
	DW	09H
	DW	05H
	DW	07H
	DW	04H
	DW	07H
	DW	04H
	DW	07H
	DW	01H
	DW	01H
	DW	04H
	DW	02H
	DW	01H
	DW	03H
	DW	06H
	DW	08H
	DW	07H
	DW	01H
	DW	06H
	DW	0bH
	DW	05H
	DW	05H
	DW	03H
	DW	018H
	DW	09H
	DW	04H
	DW	02H
	DW	07H
	DW	0dH
	DW	05H
	DW	01H
	DW	08H
	DW	052H
	DW	010H
	DW	03dH
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	02H
	DW	02H
	DW	010H
	DW	0aH
	DW	03H
	DW	08H
	DW	01H
	DW	01H
	DW	06H
	DW	04H
	DW	02H
	DW	01H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	03H
	DW	08H
	DW	04H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	06H
	DW	03H
	DW	05H
	DW	01H
	DW	01H
	DW	04H
	DW	06H
	DW	09H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	07H
	DW	02H
	DW	01H
	DW	06H
	DW	01H
	DW	05H
	DW	04H
	DW	04H
	DW	03H
	DW	01H
	DW	08H
	DW	01H
	DW	03H
	DW	03H
	DW	01H
	DW	03H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	03H
	DW	01H
	DW	06H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	01H
	DW	03H
	DW	07H
	DW	01H
	DW	08H
	DW	02H
	DW	01H
	DW	02H
	DW	01H
	DW	05H
	DW	02H
	DW	05H
	DW	03H
	DW	05H
	DW	0aH
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	03H
	DW	02H
	DW	05H
	DW	0bH
	DW	03H
	DW	09H
	DW	03H
	DW	05H
	DW	01H
	DW	01H
	DW	05H
	DW	09H
	DW	01H
	DW	02H
	DW	01H
	DW	05H
	DW	07H
	DW	09H
	DW	09H
	DW	08H
	DW	01H
	DW	03H
	DW	03H
	DW	03H
	DW	06H
	DW	08H
	DW	02H
	DW	03H
	DW	02H
	DW	01H
	DW	01H
	DW	020H
	DW	06H
	DW	01H
	DW	02H
	DW	0fH
	DW	09H
	DW	03H
	DW	07H
	DW	0dH
	DW	01H
	DW	03H
	DW	0aH
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0dH
	DW	0aH
	DW	02H
	DW	01H
	DW	03H
	DW	0aH
	DW	04H
	DW	0fH
	DW	02H
	DW	0fH
	DW	0fH
	DW	0aH
	DW	01H
	DW	03H
	DW	09H
	DW	06H
	DW	09H
	DW	020H
	DW	019H
	DW	01aH
	DW	02fH
	DW	07H
	DW	03H
	DW	02H
	DW	03H
	DW	01H
	DW	06H
	DW	03H
	DW	04H
	DW	03H
	DW	02H
	DW	08H
	DW	05H
	DW	04H
	DW	01H
	DW	09H
	DW	04H
	DW	02H
	DW	02H
	DW	013H
	DW	0aH
	DW	06H
	DW	02H
	DW	03H
	DW	08H
	DW	01H
	DW	02H
	DW	02H
	DW	04H
	DW	02H
	DW	01H
	DW	09H
	DW	04H
	DW	04H
	DW	04H
	DW	06H
	DW	04H
	DW	08H
	DW	09H
	DW	02H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	05H
	DW	05H
	DW	01H
	DW	03H
	DW	08H
	DW	04H
	DW	06H
	DW	02H
	DW	01H
	DW	04H
	DW	0cH
	DW	01H
	DW	05H
	DW	03H
	DW	07H
	DW	0dH
	DW	02H
	DW	05H
	DW	08H
	DW	01H
	DW	06H
	DW	01H
	DW	02H
	DW	05H
	DW	0eH
	DW	06H
	DW	01H
	DW	05H
	DW	02H
	DW	04H
	DW	08H
	DW	0fH
	DW	05H
	DW	01H
	DW	017H
	DW	06H
	DW	03eH
	DW	02H
	DW	0aH
	DW	01H
	DW	01H
	DW	08H
	DW	01H
	DW	02H
	DW	02H
	DW	0aH
	DW	04H
	DW	02H
	DW	02H
	DW	09H
	DW	02H
	DW	01H
	DW	01H
	DW	03H
	DW	02H
	DW	03H
	DW	01H
	DW	05H
	DW	03H
	DW	03H
	DW	02H
	DW	01H
	DW	03H
	DW	08H
	DW	01H
	DW	01H
	DW	01H
	DW	0bH
	DW	03H
	DW	01H
	DW	01H
	DW	04H
	DW	03H
	DW	07H
	DW	01H
	DW	0eH
	DW	01H
	DW	02H
	DW	03H
	DW	0cH
	DW	05H
	DW	02H
	DW	05H
	DW	01H
	DW	06H
	DW	07H
	DW	05H
	DW	07H
	DW	0eH
	DW	0bH
	DW	01H
	DW	03H
	DW	01H
	DW	08H
	DW	09H
	DW	0cH
	DW	02H
	DW	01H
	DW	0bH
	DW	08H
	DW	04H
	DW	04H
	DW	02H
	DW	06H
	DW	0aH
	DW	09H
	DW	0dH
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	05H
	DW	01H
	DW	03H
	DW	02H
	DW	04H
	DW	04H
	DW	01H
	DW	012H
	DW	02H
	DW	03H
	DW	0eH
	DW	0bH
	DW	04H
	DW	01dH
	DW	04H
	DW	02H
	DW	07H
	DW	01H
	DW	03H
	DW	0dH
	DW	09H
	DW	02H
	DW	02H
	DW	05H
	DW	03H
	DW	05H
	DW	014H
	DW	07H
	DW	010H
	DW	08H
	DW	05H
	DW	048H
	DW	022H
	DW	06H
	DW	04H
	DW	016H
	DW	0cH
	DW	0cH
	DW	01cH
	DW	02dH
	DW	024H
	DW	09H
	DW	07H
	DW	027H
	DW	09H
	DW	0bfH
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	0bH
	DW	08H
	DW	04H
	DW	09H
	DW	02H
	DW	03H
	DW	016H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	011H
	DW	01H
	DW	07H
	DW	07H
	DW	01H
	DW	0bH
	DW	01fH
	DW	0aH
	DW	02H
	DW	04H
	DW	08H
	DW	02H
	DW	03H
	DW	02H
	DW	01H
	DW	04H
	DW	02H
	DW	010H
	DW	04H
	DW	020H
	DW	02H
	DW	03H
	DW	013H
	DW	0dH
	DW	04H
	DW	09H
	DW	01H
	DW	05H
	DW	02H
	DW	0eH
	DW	08H
	DW	01H
	DW	01H
	DW	03H
	DW	06H
	DW	013H
	DW	06H
	DW	05H
	DW	01H
	DW	010H
	DW	06H
	DW	02H
	DW	0aH
	DW	08H
	DW	05H
	DW	01H
	DW	02H
	DW	03H
	DW	01H
	DW	05H
	DW	05H
	DW	01H
	DW	0bH
	DW	06H
	DW	06H
	DW	01H
	DW	03H
	DW	03H
	DW	02H
	DW	06H
	DW	03H
	DW	08H
	DW	01H
	DW	01H
	DW	04H
	DW	0aH
	DW	07H
	DW	05H
	DW	07H
	DW	07H
	DW	05H
	DW	08H
	DW	09H
	DW	02H
	DW	01H
	DW	03H
	DW	04H
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	03H
	DW	03H
	DW	02H
	DW	06H
	DW	010H
	DW	01H
	DW	04H
	DW	06H
	DW	03H
	DW	01H
	DW	0aH
	DW	06H
	DW	01H
	DW	03H
	DW	0fH
	DW	02H
	DW	09H
	DW	02H
	DW	0aH
	DW	019H
	DW	0dH
	DW	09H
	DW	010H
	DW	06H
	DW	02H
	DW	02H
	DW	0aH
	DW	0bH
	DW	04H
	DW	03H
	DW	09H
	DW	01H
	DW	02H
	DW	06H
	DW	06H
	DW	05H
	DW	04H
	DW	01eH
	DW	028H
	DW	01H
	DW	0aH
	DW	07H
	DW	0cH
	DW	0eH
	DW	021H
	DW	06H
	DW	03H
	DW	06H
	DW	07H
	DW	03H
	DW	01H
	DW	03H
	DW	01H
	DW	0bH
	DW	0eH
	DW	04H
	DW	09H
	DW	05H
	DW	0cH
	DW	0bH
	DW	031H
	DW	012H
	DW	033H
	DW	01fH
	DW	08cH
	DW	01fH
	DW	02H
	DW	02H
	DW	01H
	DW	05H
	DW	01H
	DW	08H
	DW	01H
	DW	0aH
	DW	01H
	DW	04H
	DW	04H
	DW	03H
	DW	018H
	DW	01H
	DW	0aH
	DW	01H
	DW	03H
	DW	06H
	DW	06H
	DW	010H
	DW	03H
	DW	04H
	DW	05H
	DW	02H
	DW	01H
	DW	04H
	DW	02H
	DW	039H
	DW	0aH
	DW	06H
	DW	016H
	DW	02H
	DW	016H
	DW	03H
	DW	07H
	DW	016H
	DW	06H
	DW	0aH
	DW	0bH
	DW	024H
	DW	012H
	DW	010H
	DW	021H
	DW	024H
	DW	02H
	DW	05H
	DW	05H
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	0aH
	DW	01H
	DW	04H
	DW	0dH
	DW	02H
	DW	07H
	DW	05H
	DW	02H
	DW	09H
	DW	03H
	DW	04H
	DW	01H
	DW	07H
	DW	02bH
	DW	03H
	DW	07H
	DW	03H
	DW	09H
	DW	0eH
	DW	07H
	DW	09H
	DW	01H
	DW	0bH
	DW	01H
	DW	01H
	DW	03H
	DW	07H
	DW	04H
	DW	012H
	DW	0dH
	DW	01H
	DW	0eH
	DW	01H
	DW	03H
	DW	06H
	DW	0aH
	DW	049H
	DW	02H
	DW	02H
	DW	01eH
	DW	06H
	DW	01H
	DW	0bH
	DW	012H
	DW	013H
	DW	0dH
	DW	016H
	DW	03H
	DW	02eH
	DW	02aH
	DW	025H
	DW	059H
	DW	07H
	DW	03H
	DW	010H
	DW	022H
	DW	02H
	DW	02H
	DW	03H
	DW	09H
	DW	01H
	DW	07H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	04H
	DW	0aH
	DW	07H
	DW	03H
	DW	0aH
	DW	03H
	DW	09H
	DW	05H
	DW	01cH
	DW	09H
	DW	02H
	DW	06H
	DW	0dH
	DW	07H
	DW	03H
	DW	01H
	DW	03H
	DW	0aH
	DW	02H
	DW	07H
	DW	02H
	DW	0bH
	DW	03H
	DW	06H
	DW	015H
	DW	036H
	DW	055H
	DW	02H
	DW	01H
	DW	04H
	DW	02H
	DW	02H
	DW	01H
	DW	027H
	DW	03H
	DW	015H
	DW	02H
	DW	02H
	DW	05H
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	01H
	DW	01H
	DW	03H
	DW	04H
	DW	0fH
	DW	01H
	DW	03H
	DW	02H
	DW	04H
	DW	04H
	DW	02H
	DW	03H
	DW	08H
	DW	02H
	DW	014H
	DW	01H
	DW	08H
	DW	07H
	DW	0dH
	DW	04H
	DW	01H
	DW	01aH
	DW	06H
	DW	02H
	DW	09H
	DW	022H
	DW	04H
	DW	015H
	DW	034H
	DW	0aH
	DW	04H
	DW	04H
	DW	01H
	DW	05H
	DW	0cH
	DW	02H
	DW	0bH
	DW	01H
	DW	07H
	DW	02H
	DW	01eH
	DW	0cH
	DW	02cH
	DW	02H
	DW	01eH
	DW	01H
	DW	01H
	DW	03H
	DW	06H
	DW	010H
	DW	09H
	DW	011H
	DW	027H
	DW	052H
	DW	02H
	DW	02H
	DW	018H
	DW	07H
	DW	01H
	DW	07H
	DW	03H
	DW	010H
	DW	09H
	DW	0eH
	DW	02cH
	DW	02H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	03H
	DW	05H
	DW	02H
	DW	04H
	DW	01H
	DW	06H
	DW	07H
	DW	05H
	DW	03H
	DW	02H
	DW	06H
	DW	01H
	DW	0bH
	DW	05H
	DW	0bH
	DW	02H
	DW	01H
	DW	012H
	DW	013H
	DW	08H
	DW	01H
	DW	03H
	DW	018H
	DW	01dH
	DW	02H
	DW	01H
	DW	03H
	DW	05H
	DW	02H
	DW	02H
	DW	01H
	DW	0dH
	DW	06H
	DW	05H
	DW	01H
	DW	02eH
	DW	0bH
	DW	03H
	DW	05H
	DW	01H
	DW	01H
	DW	05H
	DW	08H
	DW	02H
	DW	0aH
	DW	06H
	DW	0cH
	DW	06H
	DW	03H
	DW	07H
	DW	0bH
	DW	02H
	DW	04H
	DW	010H
	DW	0dH
	DW	02H
	DW	05H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	05H
	DW	02H
	DW	01cH
	DW	05H
	DW	02H
	DW	017H
	DW	0aH
	DW	08H
	DW	04H
	DW	04H
	DW	016H
	DW	027H
	DW	05fH
	DW	026H
	DW	08H
	DW	0eH
	DW	09H
	DW	05H
	DW	01H
	DW	0dH
	DW	05H
	DW	04H
	DW	03H
	DW	0dH
	DW	0cH
	DW	0bH
	DW	01H
	DW	09H
	DW	01H
	DW	01bH
	DW	025H
	DW	02H
	DW	05H
	DW	04H
	DW	04H
	DW	03fH
	DW	0d3H
	DW	05fH
	DW	02H
	DW	02H
	DW	02H
	DW	01H
	DW	03H
	DW	05H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	02H
	DW	04H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	05H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	03H
	DW	01H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	04H
	DW	02H
	DW	01H
	DW	03H
	DW	06H
	DW	01H
	DW	01H
	DW	03H
	DW	07H
	DW	0fH
	DW	05H
	DW	03H
	DW	02H
	DW	05H
	DW	03H
	DW	09H
	DW	0bH
	DW	04H
	DW	02H
	DW	016H
	DW	01H
	DW	06H
	DW	03H
	DW	08H
	DW	07H
	DW	01H
	DW	04H
	DW	01cH
	DW	04H
	DW	010H
	DW	03H
	DW	03H
	DW	019H
	DW	04H
	DW	04H
	DW	01bH
	DW	01bH
	DW	01H
	DW	04H
	DW	01H
	DW	02H
	DW	02H
	DW	07H
	DW	01H
	DW	03H
	DW	05H
	DW	02H
	DW	01cH
	DW	08H
	DW	02H
	DW	0eH
	DW	01H
	DW	08H
	DW	06H
	DW	010H
	DW	019H
	DW	03H
	DW	03H
	DW	03H
	DW	0eH
	DW	03H
	DW	03H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	04H
	DW	06H
	DW	03H
	DW	08H
	DW	04H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	03H
	DW	06H
	DW	0aH
	DW	06H
	DW	02H
	DW	03H
	DW	012H
	DW	03H
	DW	02H
	DW	05H
	DW	05H
	DW	04H
	DW	03H
	DW	01H
	DW	05H
	DW	02H
	DW	05H
	DW	04H
	DW	017H
	DW	07H
	DW	06H
	DW	0cH
	DW	06H
	DW	04H
	DW	011H
	DW	0bH
	DW	09H
	DW	05H
	DW	01H
	DW	01H
	DW	0aH
	DW	05H
	DW	0cH
	DW	01H
	DW	01H
	DW	0bH
	DW	01aH
	DW	021H
	DW	07H
	DW	03H
	DW	06H
	DW	01H
	DW	011H
	DW	07H
	DW	01H
	DW	05H
	DW	0cH
	DW	01H
	DW	0bH
	DW	02H
	DW	04H
	DW	01H
	DW	08H
	DW	0eH
	DW	011H
	DW	017H
	DW	01H
	DW	02H
	DW	01H
	DW	07H
	DW	08H
	DW	010H
	DW	0bH
	DW	09H
	DW	06H
	DW	05H
	DW	02H
	DW	06H
	DW	04H
	DW	010H
	DW	02H
	DW	08H
	DW	0eH
	DW	01H
	DW	0bH
	DW	08H
	DW	09H
	DW	01H
	DW	01H
	DW	01H
	DW	09H
	DW	019H
	DW	04H
	DW	0bH
	DW	013H
	DW	07H
	DW	02H
	DW	0fH
	DW	02H
	DW	0cH
	DW	08H
	DW	034H
	DW	07H
	DW	05H
	DW	013H
	DW	02H
	DW	010H
	DW	04H
	DW	024H
	DW	08H
	DW	01H
	DW	010H
	DW	08H
	DW	018H
	DW	01aH
	DW	04H
	DW	06H
	DW	02H
	DW	09H
	DW	05H
	DW	04H
	DW	024H
	DW	03H
	DW	01cH
	DW	0cH
	DW	019H
	DW	0fH
	DW	025H
	DW	01bH
	DW	011H
	DW	0cH
	DW	03bH
	DW	026H
	DW	05H
	DW	020H
	DW	07fH
	DW	01H
	DW	02H
	DW	09H
	DW	011H
	DW	0eH
	DW	04H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	08H
	DW	0bH
	DW	032H
	DW	04H
	DW	0eH
	DW	02H
	DW	013H
	DW	010H
	DW	04H
	DW	011H
	DW	05H
	DW	04H
	DW	05H
	DW	01aH
	DW	0cH
	DW	02dH
	DW	02H
	DW	017H
	DW	02dH
	DW	068H
	DW	01eH
	DW	0cH
	DW	08H
	DW	03H
	DW	0aH
	DW	02H
	DW	02H
	DW	03H
	DW	03H
	DW	01H
	DW	04H
	DW	014H
	DW	07H
	DW	02H
	DW	09H
	DW	06H
	DW	0fH
	DW	02H
	DW	014H
	DW	01H
	DW	03H
	DW	010H
	DW	04H
	DW	0bH
	DW	0fH
	DW	06H
	DW	086H
	DW	02H
	DW	05H
	DW	03bH
	DW	01H
	DW	02H
	DW	02H
	DW	02H
	DW	01H
	DW	09H
	DW	011H
	DW	03H
	DW	01aH
	DW	089H
	DW	0aH
	DW	0d3H
	DW	03bH
	DW	01H
	DW	02H
	DW	04H
	DW	01H
	DW	04H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	06H
	DW	02H
	DW	03H
	DW	01H
	DW	01H
	DW	02H
	DW	03H
	DW	02H
	DW	03H
	DW	01H
	DW	03H
	DW	04H
	DW	04H
	DW	02H
	DW	03H
	DW	03H
	DW	01H
	DW	04H
	DW	03H
	DW	01H
	DW	07H
	DW	02H
	DW	02H
	DW	03H
	DW	01H
	DW	02H
	DW	01H
	DW	03H
	DW	03H
	DW	03H
	DW	02H
	DW	02H
	DW	03H
	DW	02H
	DW	01H
	DW	03H
	DW	0eH
	DW	06H
	DW	01H
	DW	03H
	DW	02H
	DW	09H
	DW	06H
	DW	0fH
	DW	01bH
	DW	09H
	DW	022H
	DW	091H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	02H
	DW	03H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	03H
	DW	05H
	DW	08H
	DW	03H
	DW	05H
	DW	02H
	DW	04H
	DW	01H
	DW	03H
	DW	02H
	DW	02H
	DW	02H
	DW	0cH
	DW	04H
	DW	01H
	DW	01H
	DW	01H
	DW	0aH
	DW	04H
	DW	05H
	DW	01H
	DW	014H
	DW	04H
	DW	010H
	DW	01H
	DW	0fH
	DW	09H
	DW	05H
	DW	0cH
	DW	02H
	DW	09H
	DW	02H
	DW	05H
	DW	04H
	DW	02H
	DW	01aH
	DW	013H
	DW	07H
	DW	01H
	DW	01aH
	DW	04H
	DW	01eH
	DW	0cH
	DW	0fH
	DW	02aH
	DW	01H
	DW	06H
	DW	08H
	DW	0acH
	DW	01H
	DW	01H
	DW	04H
	DW	02H
	DW	01H
	DW	01H
	DW	0bH
	DW	02H
	DW	02H
	DW	04H
	DW	02H
	DW	01H
	DW	02H
	DW	01H
	DW	0aH
	DW	08H
	DW	01H
	DW	02H
	DW	01H
	DW	04H
	DW	05H
	DW	01H
	DW	02H
	DW	05H
	DW	01H
	DW	08H
	DW	04H
	DW	01H
	DW	03H
	DW	04H
	DW	02H
	DW	01H
	DW	06H
	DW	02H
	DW	01H
	DW	03H
	DW	04H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	0cH
	DW	05H
	DW	07H
	DW	02H
	DW	04H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	03H
	DW	06H
	DW	01H
	DW	02H
	DW	02H
	DW	03H
	DW	03H
	DW	03H
	DW	02H
	DW	01H
	DW	02H
	DW	0cH
	DW	0eH
	DW	0bH
	DW	06H
	DW	06H
	DW	04H
	DW	0cH
	DW	02H
	DW	08H
	DW	01H
	DW	07H
	DW	0aH
	DW	01H
	DW	023H
	DW	07H
	DW	04H
	DW	0dH
	DW	0fH
	DW	04H
	DW	03H
	DW	017H
	DW	015H
	DW	01cH
	DW	034H
	DW	05H
	DW	01aH
	DW	05H
	DW	06H
	DW	01H
	DW	07H
	DW	0aH
	DW	02H
	DW	07H
	DW	035H
	DW	03H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	0a3H
	DW	0214H
	DW	01H
	DW	0aH
	DW	0bH
	DW	01H
	DW	03H
	DW	03H
	DW	04H
	DW	08H
	DW	02H
	DW	08H
	DW	06H
	DW	02H
	DW	02H
	DW	017H
	DW	016H
	DW	04H
	DW	02H
	DW	02H
	DW	04H
	DW	02H
	DW	01H
	DW	03H
	DW	01H
	DW	03H
	DW	03H
	DW	05H
	DW	09H
	DW	08H
	DW	02H
	DW	01H
	DW	02H
	DW	08H
	DW	01H
	DW	0aH
	DW	02H
	DW	0cH
	DW	015H
	DW	014H
	DW	0fH
	DW	069H
	DW	02H
	DW	03H
	DW	01H
	DW	01H
	DW	03H
	DW	02H
	DW	03H
	DW	01H
	DW	01H
	DW	02H
	DW	05H
	DW	01H
	DW	04H
	DW	0fH
	DW	0bH
	DW	013H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	05H
	DW	04H
	DW	05H
	DW	01H
	DW	01H
	DW	02H
	DW	05H
	DW	03H
	DW	05H
	DW	0cH
	DW	01H
	DW	02H
	DW	05H
	DW	01H
	DW	0bH
	DW	01H
	DW	01H
	DW	0fH
	DW	09H
	DW	01H
	DW	04H
	DW	05H
	DW	03H
	DW	01aH
	DW	08H
	DW	02H
	DW	01H
	DW	03H
	DW	01H
	DW	01H
	DW	0fH
	DW	013H
	DW	02H
	DW	0cH
	DW	01H
	DW	02H
	DW	05H
	DW	02H
	DW	07H
	DW	02H
	DW	013H
	DW	02H
	DW	014H
	DW	06H
	DW	01aH
	DW	07H
	DW	05H
	DW	02H
	DW	02H
	DW	07H
	DW	022H
	DW	015H
	DW	0dH
	DW	046H
	DW	02H
	DW	080H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	03H
	DW	02H
	DW	02H
	DW	02H
	DW	0fH
	DW	01H
	DW	04H
	DW	01H
	DW	03H
	DW	04H
	DW	02aH
	DW	0aH
	DW	06H
	DW	01H
	DW	031H
	DW	055H
	DW	08H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	04H
	DW	04H
	DW	02H
	DW	03H
	DW	06H
	DW	01H
	DW	05H
	DW	07H
	DW	04H
	DW	03H
	DW	0d3H
	DW	04H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	05H
	DW	01H
	DW	02H
	DW	04H
	DW	02H
	DW	02H
	DW	06H
	DW	05H
	DW	06H
	DW	0aH
	DW	03H
	DW	04H
	DW	030H
	DW	064H
	DW	06H
	DW	02H
	DW	010H
	DW	0128H
	DW	05H
	DW	01bH
	DW	0183H
	DW	02H
	DW	02H
	DW	03H
	DW	07H
	DW	010H
	DW	08H
	DW	05H
	DW	026H
	DW	0fH
	DW	027H
	DW	015H
	DW	09H
	DW	0aH
	DW	03H
	DW	07H
	DW	03bH
	DW	0dH
	DW	01bH
	DW	015H
	DW	02fH
	DW	05H
	DW	015H
	DW	06H
CONST	ENDS
;	COMDAT ?ranges@?1??GetGlyphRangesGreek@ImFontAtlas@@QEAAPEBGXZ@4QBGB
CONST	SEGMENT
?ranges@?1??GetGlyphRangesGreek@ImFontAtlas@@QEAAPEBGXZ@4QBGB DW 020H ; `ImFontAtlas::GetGlyphRangesGreek'::`2'::ranges
	DW	0ffH
	DW	0370H
	DW	03ffH
	DW	00H
CONST	ENDS
;	COMDAT ?base_ranges@?1??GetGlyphRangesChineseSimplifiedCommon@ImFontAtlas@@QEAAPEBGXZ@4PAGA
_DATA	SEGMENT
?base_ranges@?1??GetGlyphRangesChineseSimplifiedCommon@ImFontAtlas@@QEAAPEBGXZ@4PAGA DW 020H ; `ImFontAtlas::GetGlyphRangesChineseSimplifiedCommon'::`2'::base_ranges
	DW	0ffH
	DW	02000H
	DW	0206fH
	DW	03000H
	DW	030ffH
	DW	031f0H
	DW	031ffH
	DW	0ff00H
	DW	0ffefH
	DW	0fffdH
	DW	0fffdH
_DATA	ENDS
;	COMDAT ?ranges@?1??GetGlyphRangesKorean@ImFontAtlas@@QEAAPEBGXZ@4QBGB
CONST	SEGMENT
?ranges@?1??GetGlyphRangesKorean@ImFontAtlas@@QEAAPEBGXZ@4QBGB DW 020H ; `ImFontAtlas::GetGlyphRangesKorean'::`2'::ranges
	DW	0ffH
	DW	03131H
	DW	03163H
	DW	0ac00H
	DW	0d7a3H
	DW	0fffdH
	DW	0fffdH
	DW	00H
CONST	ENDS
;	COMDAT ?ranges@?1??GetGlyphRangesDefault@ImFontAtlas@@QEAAPEBGXZ@4QBGB
CONST	SEGMENT
?ranges@?1??GetGlyphRangesDefault@ImFontAtlas@@QEAAPEBGXZ@4QBGB DW 020H ; `ImFontAtlas::GetGlyphRangesDefault'::`2'::ranges
	DW	0ffH
	DW	00H
CONST	ENDS
;	COMDAT ?ranges@?1??GetGlyphRangesVietnamese@ImFontAtlas@@QEAAPEBGXZ@4QBGB
CONST	SEGMENT
?ranges@?1??GetGlyphRangesVietnamese@ImFontAtlas@@QEAAPEBGXZ@4QBGB DW 020H ; `ImFontAtlas::GetGlyphRangesVietnamese'::`2'::ranges
	DW	0ffH
	DW	0102H
	DW	0103H
	DW	0110H
	DW	0111H
	DW	0128H
	DW	0129H
	DW	0168H
	DW	0169H
	DW	01a0H
	DW	01a1H
	DW	01afH
	DW	01b0H
	DW	01ea0H
	DW	01ef9H
	DW	00H
CONST	ENDS
;	COMDAT ?ranges@?1??GetGlyphRangesThai@ImFontAtlas@@QEAAPEBGXZ@4QBGB
CONST	SEGMENT
?ranges@?1??GetGlyphRangesThai@ImFontAtlas@@QEAAPEBGXZ@4QBGB DW 020H ; `ImFontAtlas::GetGlyphRangesThai'::`2'::ranges
	DW	0ffH
	DW	02010H
	DW	0205eH
	DW	0e00H
	DW	0e7fH
	DW	00H
CONST	ENDS
;	COMDAT ?accumulative_offsets_from_0x4E00@?1??GetGlyphRangesJapanese@ImFontAtlas@@QEAAPEBGXZ@4QBFB
CONST	SEGMENT
?accumulative_offsets_from_0x4E00@?1??GetGlyphRangesJapanese@ImFontAtlas@@QEAAPEBGXZ@4QBFB DW 00H ; `ImFontAtlas::GetGlyphRangesJapanese'::`2'::accumulative_offsets_from_0x4E00
	DW	01H
	DW	02H
	DW	04H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	03H
	DW	03H
	DW	02H
	DW	02H
	DW	01H
	DW	05H
	DW	03H
	DW	05H
	DW	07H
	DW	05H
	DW	06H
	DW	01H
	DW	02H
	DW	01H
	DW	07H
	DW	02H
	DW	06H
	DW	03H
	DW	01H
	DW	08H
	DW	01H
	DW	01H
	DW	04H
	DW	01H
	DW	01H
	DW	012H
	DW	02H
	DW	0bH
	DW	02H
	DW	06H
	DW	02H
	DW	01H
	DW	02H
	DW	01H
	DW	05H
	DW	01H
	DW	02H
	DW	01H
	DW	03H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	03H
	DW	03H
	DW	01H
	DW	01H
	DW	02H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	0cH
	DW	07H
	DW	09H
	DW	01H
	DW	04H
	DW	05H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	0aH
	DW	01H
	DW	01H
	DW	09H
	DW	02H
	DW	02H
	DW	04H
	DW	05H
	DW	06H
	DW	09H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	09H
	DW	03H
	DW	012H
	DW	05H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	01H
	DW	06H
	DW	03H
	DW	07H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	04H
	DW	02H
	DW	01H
	DW	017H
	DW	02H
	DW	0aH
	DW	04H
	DW	03H
	DW	05H
	DW	02H
	DW	04H
	DW	0aH
	DW	02H
	DW	04H
	DW	0dH
	DW	01H
	DW	06H
	DW	01H
	DW	09H
	DW	03H
	DW	01H
	DW	01H
	DW	06H
	DW	06H
	DW	07H
	DW	06H
	DW	03H
	DW	01H
	DW	02H
	DW	0bH
	DW	03H
	DW	02H
	DW	02H
	DW	03H
	DW	02H
	DW	0fH
	DW	02H
	DW	02H
	DW	05H
	DW	04H
	DW	03H
	DW	06H
	DW	04H
	DW	01H
	DW	02H
	DW	05H
	DW	02H
	DW	0cH
	DW	010H
	DW	06H
	DW	0dH
	DW	09H
	DW	0dH
	DW	02H
	DW	01H
	DW	01H
	DW	07H
	DW	010H
	DW	04H
	DW	07H
	DW	01H
	DW	013H
	DW	01H
	DW	05H
	DW	01H
	DW	02H
	DW	02H
	DW	07H
	DW	07H
	DW	08H
	DW	02H
	DW	06H
	DW	05H
	DW	04H
	DW	09H
	DW	012H
	DW	07H
	DW	04H
	DW	05H
	DW	09H
	DW	0dH
	DW	0bH
	DW	08H
	DW	0fH
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	02H
	DW	01H
	DW	02H
	DW	02H
	DW	08H
	DW	02H
	DW	09H
	DW	03H
	DW	03H
	DW	01H
	DW	01H
	DW	04H
	DW	04H
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	09H
	DW	01H
	DW	04H
	DW	03H
	DW	05H
	DW	05H
	DW	02H
	DW	07H
	DW	05H
	DW	03H
	DW	04H
	DW	08H
	DW	02H
	DW	01H
	DW	0dH
	DW	02H
	DW	03H
	DW	03H
	DW	01H
	DW	0eH
	DW	01H
	DW	01H
	DW	04H
	DW	05H
	DW	01H
	DW	03H
	DW	06H
	DW	01H
	DW	05H
	DW	02H
	DW	01H
	DW	01H
	DW	03H
	DW	03H
	DW	03H
	DW	03H
	DW	01H
	DW	01H
	DW	02H
	DW	07H
	DW	06H
	DW	06H
	DW	07H
	DW	01H
	DW	04H
	DW	07H
	DW	06H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	0cH
	DW	03H
	DW	03H
	DW	09H
	DW	05H
	DW	02H
	DW	06H
	DW	01H
	DW	05H
	DW	06H
	DW	01H
	DW	02H
	DW	03H
	DW	012H
	DW	02H
	DW	04H
	DW	0eH
	DW	04H
	DW	01H
	DW	03H
	DW	06H
	DW	01H
	DW	01H
	DW	06H
	DW	03H
	DW	05H
	DW	05H
	DW	03H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	0cH
	DW	03H
	DW	01H
	DW	04H
	DW	02H
	DW	03H
	DW	02H
	DW	03H
	DW	0bH
	DW	01H
	DW	07H
	DW	04H
	DW	01H
	DW	02H
	DW	01H
	DW	03H
	DW	011H
	DW	01H
	DW	09H
	DW	01H
	DW	018H
	DW	01H
	DW	01H
	DW	04H
	DW	02H
	DW	02H
	DW	04H
	DW	01H
	DW	02H
	DW	07H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	02H
	DW	02H
	DW	04H
	DW	0fH
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	05H
	DW	02H
	DW	05H
	DW	014H
	DW	02H
	DW	05H
	DW	09H
	DW	01H
	DW	0aH
	DW	08H
	DW	07H
	DW	06H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	06H
	DW	02H
	DW	01H
	DW	02H
	DW	08H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	05H
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	01H
	DW	0cH
	DW	04H
	DW	01H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	0aH
	DW	03H
	DW	01H
	DW	07H
	DW	05H
	DW	0dH
	DW	01H
	DW	02H
	DW	03H
	DW	04H
	DW	06H
	DW	01H
	DW	01H
	DW	01eH
	DW	02H
	DW	09H
	DW	09H
	DW	01H
	DW	0fH
	DW	026H
	DW	0bH
	DW	03H
	DW	01H
	DW	08H
	DW	018H
	DW	07H
	DW	01H
	DW	09H
	DW	08H
	DW	0aH
	DW	02H
	DW	01H
	DW	09H
	DW	01fH
	DW	02H
	DW	0dH
	DW	06H
	DW	02H
	DW	09H
	DW	04H
	DW	031H
	DW	05H
	DW	02H
	DW	0fH
	DW	02H
	DW	01H
	DW	0aH
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	06H
	DW	0fH
	DW	01eH
	DW	023H
	DW	03H
	DW	0eH
	DW	012H
	DW	08H
	DW	01H
	DW	010H
	DW	0aH
	DW	01cH
	DW	0cH
	DW	013H
	DW	02dH
	DW	026H
	DW	01H
	DW	03H
	DW	02H
	DW	03H
	DW	0dH
	DW	02H
	DW	01H
	DW	07H
	DW	03H
	DW	06H
	DW	05H
	DW	03H
	DW	04H
	DW	03H
	DW	01H
	DW	05H
	DW	07H
	DW	08H
	DW	01H
	DW	05H
	DW	03H
	DW	012H
	DW	05H
	DW	03H
	DW	06H
	DW	01H
	DW	015H
	DW	04H
	DW	018H
	DW	09H
	DW	018H
	DW	028H
	DW	03H
	DW	0eH
	DW	03H
	DW	015H
	DW	03H
	DW	02H
	DW	01H
	DW	02H
	DW	04H
	DW	02H
	DW	03H
	DW	01H
	DW	0fH
	DW	0fH
	DW	06H
	DW	05H
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	05H
	DW	06H
	DW	01H
	DW	09H
	DW	07H
	DW	03H
	DW	03H
	DW	02H
	DW	01H
	DW	04H
	DW	03H
	DW	08H
	DW	015H
	DW	05H
	DW	010H
	DW	04H
	DW	05H
	DW	02H
	DW	0aH
	DW	0bH
	DW	0bH
	DW	03H
	DW	06H
	DW	03H
	DW	02H
	DW	09H
	DW	03H
	DW	06H
	DW	0dH
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	0bH
	DW	0cH
	DW	06H
	DW	06H
	DW	01H
	DW	04H
	DW	02H
	DW	06H
	DW	05H
	DW	02H
	DW	01H
	DW	01H
	DW	03H
	DW	03H
	DW	06H
	DW	0dH
	DW	03H
	DW	01H
	DW	01H
	DW	05H
	DW	01H
	DW	02H
	DW	03H
	DW	03H
	DW	0eH
	DW	02H
	DW	01H
	DW	02H
	DW	02H
	DW	02H
	DW	05H
	DW	01H
	DW	09H
	DW	05H
	DW	01H
	DW	01H
	DW	06H
	DW	0cH
	DW	03H
	DW	0cH
	DW	03H
	DW	04H
	DW	0dH
	DW	02H
	DW	0eH
	DW	02H
	DW	08H
	DW	01H
	DW	011H
	DW	05H
	DW	01H
	DW	010H
	DW	04H
	DW	02H
	DW	02H
	DW	015H
	DW	08H
	DW	09H
	DW	06H
	DW	017H
	DW	014H
	DW	0cH
	DW	019H
	DW	013H
	DW	09H
	DW	026H
	DW	08H
	DW	03H
	DW	015H
	DW	028H
	DW	019H
	DW	021H
	DW	0dH
	DW	04H
	DW	03H
	DW	01H
	DW	04H
	DW	01H
	DW	02H
	DW	04H
	DW	01H
	DW	02H
	DW	05H
	DW	01aH
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	03H
	DW	06H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	09H
	DW	02H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	06H
	DW	03H
	DW	02H
	DW	01H
	DW	01H
	DW	06H
	DW	06H
	DW	01H
	DW	08H
	DW	02H
	DW	02H
	DW	02H
	DW	01H
	DW	04H
	DW	01H
	DW	02H
	DW	03H
	DW	02H
	DW	07H
	DW	03H
	DW	02H
	DW	04H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	02H
	DW	05H
	DW	04H
	DW	0aH
	DW	09H
	DW	04H
	DW	09H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	05H
	DW	03H
	DW	02H
	DW	01H
	DW	06H
	DW	04H
	DW	09H
	DW	06H
	DW	01H
	DW	0aH
	DW	02H
	DW	01fH
	DW	011H
	DW	08H
	DW	03H
	DW	07H
	DW	05H
	DW	028H
	DW	01H
	DW	07H
	DW	07H
	DW	01H
	DW	06H
	DW	05H
	DW	02H
	DW	0aH
	DW	07H
	DW	08H
	DW	04H
	DW	0fH
	DW	027H
	DW	019H
	DW	06H
	DW	01cH
	DW	02fH
	DW	012H
	DW	0aH
	DW	07H
	DW	01H
	DW	03H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	03H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	04H
	DW	02H
	DW	01H
	DW	04H
	DW	01H
	DW	03H
	DW	06H
	DW	0aH
	DW	07H
	DW	08H
	DW	06H
	DW	02H
	DW	02H
	DW	01H
	DW	03H
	DW	03H
	DW	02H
	DW	05H
	DW	08H
	DW	07H
	DW	09H
	DW	0cH
	DW	02H
	DW	0fH
	DW	01H
	DW	01H
	DW	04H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	02H
	DW	01H
	DW	03H
	DW	03H
	DW	05H
	DW	06H
	DW	02H
	DW	03H
	DW	02H
	DW	0aH
	DW	01H
	DW	04H
	DW	02H
	DW	08H
	DW	01H
	DW	01H
	DW	01H
	DW	0bH
	DW	06H
	DW	01H
	DW	015H
	DW	04H
	DW	010H
	DW	03H
	DW	01H
	DW	03H
	DW	01H
	DW	04H
	DW	02H
	DW	03H
	DW	06H
	DW	05H
	DW	01H
	DW	03H
	DW	01H
	DW	01H
	DW	03H
	DW	03H
	DW	04H
	DW	06H
	DW	01H
	DW	01H
	DW	0aH
	DW	04H
	DW	02H
	DW	07H
	DW	0aH
	DW	04H
	DW	07H
	DW	04H
	DW	02H
	DW	09H
	DW	04H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	01H
	DW	08H
	DW	03H
	DW	04H
	DW	01H
	DW	03H
	DW	01H
	DW	06H
	DW	01H
	DW	04H
	DW	02H
	DW	01H
	DW	04H
	DW	07H
	DW	02H
	DW	01H
	DW	08H
	DW	01H
	DW	04H
	DW	05H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	04H
	DW	06H
	DW	02H
	DW	07H
	DW	01H
	DW	0aH
	DW	01H
	DW	01H
	DW	03H
	DW	04H
	DW	0bH
	DW	0aH
	DW	08H
	DW	015H
	DW	04H
	DW	06H
	DW	01H
	DW	03H
	DW	05H
	DW	02H
	DW	01H
	DW	02H
	DW	01cH
	DW	05H
	DW	05H
	DW	02H
	DW	03H
	DW	0dH
	DW	01H
	DW	02H
	DW	03H
	DW	01H
	DW	04H
	DW	02H
	DW	01H
	DW	05H
	DW	014H
	DW	03H
	DW	08H
	DW	0bH
	DW	01H
	DW	03H
	DW	03H
	DW	03H
	DW	01H
	DW	08H
	DW	0aH
	DW	09H
	DW	02H
	DW	0aH
	DW	09H
	DW	02H
	DW	03H
	DW	01H
	DW	01H
	DW	02H
	DW	04H
	DW	01H
	DW	08H
	DW	03H
	DW	06H
	DW	01H
	DW	07H
	DW	08H
	DW	06H
	DW	0bH
	DW	01H
	DW	04H
	DW	01dH
	DW	08H
	DW	04H
	DW	03H
	DW	01H
	DW	02H
	DW	07H
	DW	0dH
	DW	01H
	DW	04H
	DW	01H
	DW	06H
	DW	02H
	DW	06H
	DW	0cH
	DW	0cH
	DW	02H
	DW	014H
	DW	03H
	DW	02H
	DW	03H
	DW	06H
	DW	04H
	DW	08H
	DW	09H
	DW	02H
	DW	07H
	DW	022H
	DW	05H
	DW	01H
	DW	012H
	DW	06H
	DW	01H
	DW	01H
	DW	04H
	DW	04H
	DW	05H
	DW	07H
	DW	09H
	DW	01H
	DW	02H
	DW	02H
	DW	04H
	DW	03H
	DW	04H
	DW	01H
	DW	07H
	DW	02H
	DW	02H
	DW	02H
	DW	06H
	DW	02H
	DW	03H
	DW	019H
	DW	05H
	DW	03H
	DW	06H
	DW	01H
	DW	04H
	DW	06H
	DW	07H
	DW	04H
	DW	02H
	DW	01H
	DW	04H
	DW	02H
	DW	0dH
	DW	06H
	DW	04H
	DW	04H
	DW	03H
	DW	01H
	DW	05H
	DW	03H
	DW	04H
	DW	04H
	DW	03H
	DW	02H
	DW	01H
	DW	01H
	DW	04H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	0bH
	DW	01H
	DW	06H
	DW	03H
	DW	01H
	DW	07H
	DW	03H
	DW	06H
	DW	02H
	DW	08H
	DW	08H
	DW	06H
	DW	09H
	DW	03H
	DW	04H
	DW	0bH
	DW	03H
	DW	02H
	DW	0aH
	DW	0cH
	DW	02H
	DW	05H
	DW	0bH
	DW	01H
	DW	06H
	DW	04H
	DW	05H
	DW	03H
	DW	01H
	DW	08H
	DW	05H
	DW	04H
	DW	06H
	DW	06H
	DW	03H
	DW	05H
	DW	01H
	DW	01H
	DW	03H
	DW	02H
	DW	01H
	DW	02H
	DW	02H
	DW	06H
	DW	011H
	DW	0cH
	DW	01H
	DW	0aH
	DW	01H
	DW	06H
	DW	0cH
	DW	01H
	DW	06H
	DW	06H
	DW	013H
	DW	09H
	DW	06H
	DW	010H
	DW	01H
	DW	0dH
	DW	04H
	DW	04H
	DW	0fH
	DW	07H
	DW	011H
	DW	06H
	DW	0bH
	DW	09H
	DW	0fH
	DW	0cH
	DW	06H
	DW	07H
	DW	02H
	DW	01H
	DW	02H
	DW	02H
	DW	0fH
	DW	09H
	DW	03H
	DW	015H
	DW	04H
	DW	06H
	DW	031H
	DW	012H
	DW	07H
	DW	03H
	DW	02H
	DW	03H
	DW	01H
	DW	06H
	DW	08H
	DW	02H
	DW	02H
	DW	06H
	DW	02H
	DW	09H
	DW	01H
	DW	03H
	DW	06H
	DW	04H
	DW	04H
	DW	01H
	DW	02H
	DW	010H
	DW	02H
	DW	05H
	DW	02H
	DW	01H
	DW	06H
	DW	02H
	DW	03H
	DW	05H
	DW	03H
	DW	01H
	DW	02H
	DW	05H
	DW	01H
	DW	02H
	DW	01H
	DW	09H
	DW	03H
	DW	01H
	DW	08H
	DW	06H
	DW	04H
	DW	08H
	DW	0bH
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	0dH
	DW	08H
	DW	04H
	DW	01H
	DW	03H
	DW	02H
	DW	02H
	DW	01H
	DW	04H
	DW	01H
	DW	0bH
	DW	01H
	DW	05H
	DW	02H
	DW	01H
	DW	05H
	DW	02H
	DW	05H
	DW	08H
	DW	06H
	DW	01H
	DW	01H
	DW	07H
	DW	04H
	DW	03H
	DW	08H
	DW	03H
	DW	02H
	DW	07H
	DW	02H
	DW	01H
	DW	05H
	DW	01H
	DW	05H
	DW	02H
	DW	04H
	DW	07H
	DW	06H
	DW	02H
	DW	08H
	DW	05H
	DW	01H
	DW	0bH
	DW	04H
	DW	05H
	DW	03H
	DW	06H
	DW	012H
	DW	01H
	DW	02H
	DW	0dH
	DW	03H
	DW	03H
	DW	01H
	DW	015H
	DW	01H
	DW	01H
	DW	04H
	DW	01H
	DW	04H
	DW	01H
	DW	01H
	DW	01H
	DW	08H
	DW	01H
	DW	02H
	DW	02H
	DW	07H
	DW	01H
	DW	02H
	DW	04H
	DW	02H
	DW	02H
	DW	09H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	03H
	DW	06H
	DW	03H
	DW	0cH
	DW	05H
	DW	01H
	DW	01H
	DW	01H
	DW	05H
	DW	06H
	DW	03H
	DW	02H
	DW	04H
	DW	08H
	DW	02H
	DW	02H
	DW	04H
	DW	02H
	DW	07H
	DW	01H
	DW	08H
	DW	09H
	DW	05H
	DW	02H
	DW	03H
	DW	02H
	DW	01H
	DW	03H
	DW	02H
	DW	0dH
	DW	07H
	DW	0eH
	DW	06H
	DW	05H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	04H
	DW	02H
	DW	017H
	DW	02H
	DW	01H
	DW	01H
	DW	06H
	DW	03H
	DW	01H
	DW	04H
	DW	01H
	DW	0fH
	DW	03H
	DW	01H
	DW	07H
	DW	03H
	DW	09H
	DW	0eH
	DW	01H
	DW	03H
	DW	01H
	DW	04H
	DW	01H
	DW	01H
	DW	05H
	DW	08H
	DW	01H
	DW	03H
	DW	08H
	DW	03H
	DW	08H
	DW	0fH
	DW	0bH
	DW	04H
	DW	0eH
	DW	04H
	DW	04H
	DW	02H
	DW	05H
	DW	05H
	DW	01H
	DW	07H
	DW	01H
	DW	06H
	DW	0eH
	DW	07H
	DW	07H
	DW	08H
	DW	05H
	DW	0fH
	DW	04H
	DW	08H
	DW	06H
	DW	05H
	DW	06H
	DW	02H
	DW	01H
	DW	0dH
	DW	01H
	DW	014H
	DW	0fH
	DW	0bH
	DW	09H
	DW	02H
	DW	05H
	DW	06H
	DW	02H
	DW	0bH
	DW	02H
	DW	06H
	DW	02H
	DW	05H
	DW	01H
	DW	05H
	DW	08H
	DW	04H
	DW	0dH
	DW	013H
	DW	019H
	DW	04H
	DW	01H
	DW	01H
	DW	0bH
	DW	01H
	DW	022H
	DW	02H
	DW	05H
	DW	09H
	DW	0eH
	DW	06H
	DW	02H
	DW	02H
	DW	06H
	DW	01H
	DW	01H
	DW	0eH
	DW	01H
	DW	03H
	DW	0eH
	DW	0dH
	DW	01H
	DW	06H
	DW	0cH
	DW	015H
	DW	0eH
	DW	0eH
	DW	06H
	DW	020H
	DW	011H
	DW	08H
	DW	020H
	DW	09H
	DW	01cH
	DW	01H
	DW	02H
	DW	04H
	DW	0bH
	DW	08H
	DW	03H
	DW	01H
	DW	0eH
	DW	02H
	DW	05H
	DW	0fH
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	06H
	DW	04H
	DW	01H
	DW	03H
	DW	04H
	DW	0bH
	DW	03H
	DW	01H
	DW	01H
	DW	0bH
	DW	01eH
	DW	01H
	DW	05H
	DW	01H
	DW	04H
	DW	01H
	DW	05H
	DW	08H
	DW	01H
	DW	01H
	DW	03H
	DW	02H
	DW	04H
	DW	03H
	DW	011H
	DW	023H
	DW	02H
	DW	06H
	DW	0cH
	DW	011H
	DW	03H
	DW	01H
	DW	06H
	DW	02H
	DW	01H
	DW	01H
	DW	0cH
	DW	02H
	DW	07H
	DW	03H
	DW	03H
	DW	02H
	DW	01H
	DW	010H
	DW	02H
	DW	08H
	DW	03H
	DW	06H
	DW	05H
	DW	04H
	DW	07H
	DW	03H
	DW	03H
	DW	08H
	DW	01H
	DW	09H
	DW	08H
	DW	05H
	DW	01H
	DW	02H
	DW	01H
	DW	03H
	DW	02H
	DW	08H
	DW	01H
	DW	02H
	DW	09H
	DW	0cH
	DW	01H
	DW	01H
	DW	02H
	DW	03H
	DW	08H
	DW	03H
	DW	018H
	DW	0cH
	DW	04H
	DW	03H
	DW	07H
	DW	05H
	DW	08H
	DW	03H
	DW	03H
	DW	03H
	DW	03H
	DW	03H
	DW	03H
	DW	01H
	DW	017H
	DW	0aH
	DW	03H
	DW	01H
	DW	02H
	DW	02H
	DW	06H
	DW	03H
	DW	01H
	DW	010H
	DW	01H
	DW	010H
	DW	016H
	DW	03H
	DW	0aH
	DW	04H
	DW	0bH
	DW	06H
	DW	09H
	DW	07H
	DW	07H
	DW	03H
	DW	06H
	DW	02H
	DW	02H
	DW	02H
	DW	04H
	DW	0aH
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	08H
	DW	07H
	DW	01H
	DW	06H
	DW	04H
	DW	01H
	DW	03H
	DW	03H
	DW	03H
	DW	05H
	DW	0aH
	DW	0cH
	DW	0cH
	DW	02H
	DW	03H
	DW	0cH
	DW	08H
	DW	0fH
	DW	01H
	DW	01H
	DW	010H
	DW	06H
	DW	06H
	DW	01H
	DW	05H
	DW	09H
	DW	0bH
	DW	04H
	DW	0bH
	DW	04H
	DW	02H
	DW	06H
	DW	0cH
	DW	01H
	DW	011H
	DW	05H
	DW	0dH
	DW	01H
	DW	04H
	DW	09H
	DW	05H
	DW	01H
	DW	0bH
	DW	02H
	DW	01H
	DW	08H
	DW	01H
	DW	05H
	DW	07H
	DW	01cH
	DW	08H
	DW	03H
	DW	05H
	DW	0aH
	DW	02H
	DW	011H
	DW	03H
	DW	026H
	DW	016H
	DW	01H
	DW	02H
	DW	012H
	DW	0cH
	DW	0aH
	DW	04H
	DW	026H
	DW	012H
	DW	01H
	DW	04H
	DW	02cH
	DW	013H
	DW	04H
	DW	01H
	DW	08H
	DW	04H
	DW	01H
	DW	0cH
	DW	01H
	DW	04H
	DW	01fH
	DW	0cH
	DW	01H
	DW	0eH
	DW	07H
	DW	04bH
	DW	07H
	DW	05H
	DW	0aH
	DW	06H
	DW	06H
	DW	0dH
	DW	03H
	DW	02H
	DW	0bH
	DW	0bH
	DW	03H
	DW	02H
	DW	05H
	DW	01cH
	DW	0fH
	DW	06H
	DW	012H
	DW	012H
	DW	05H
	DW	06H
	DW	04H
	DW	03H
	DW	010H
	DW	01H
	DW	07H
	DW	012H
	DW	07H
	DW	024H
	DW	03H
	DW	05H
	DW	03H
	DW	01H
	DW	07H
	DW	01H
	DW	09H
	DW	01H
	DW	0aH
	DW	07H
	DW	02H
	DW	04H
	DW	02H
	DW	06H
	DW	02H
	DW	09H
	DW	07H
	DW	04H
	DW	03H
	DW	020H
	DW	0cH
	DW	03H
	DW	07H
	DW	0aH
	DW	02H
	DW	017H
	DW	010H
	DW	03H
	DW	01H
	DW	0cH
	DW	03H
	DW	01fH
	DW	04H
	DW	0bH
	DW	01H
	DW	03H
	DW	08H
	DW	09H
	DW	05H
	DW	01H
	DW	01eH
	DW	0fH
	DW	06H
	DW	0cH
	DW	03H
	DW	02H
	DW	02H
	DW	0bH
	DW	013H
	DW	09H
	DW	0eH
	DW	02H
	DW	06H
	DW	02H
	DW	03H
	DW	013H
	DW	0dH
	DW	011H
	DW	05H
	DW	03H
	DW	03H
	DW	019H
	DW	03H
	DW	0eH
	DW	01H
	DW	01H
	DW	01H
	DW	024H
	DW	01H
	DW	03H
	DW	02H
	DW	013H
	DW	03H
	DW	0dH
	DW	024H
	DW	09H
	DW	0dH
	DW	01fH
	DW	06H
	DW	04H
	DW	010H
	DW	022H
	DW	02H
	DW	05H
	DW	04H
	DW	02H
	DW	03H
	DW	03H
	DW	05H
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	03H
	DW	01H
	DW	011H
	DW	03H
	DW	02H
	DW	03H
	DW	05H
	DW	03H
	DW	01H
	DW	03H
	DW	02H
	DW	03H
	DW	05H
	DW	06H
	DW	03H
	DW	0cH
	DW	0bH
	DW	01H
	DW	03H
	DW	01H
	DW	02H
	DW	01aH
	DW	07H
	DW	0cH
	DW	07H
	DW	02H
	DW	0eH
	DW	03H
	DW	03H
	DW	07H
	DW	07H
	DW	0bH
	DW	019H
	DW	019H
	DW	01cH
	DW	010H
	DW	04H
	DW	024H
	DW	01H
	DW	02H
	DW	01H
	DW	06H
	DW	02H
	DW	01H
	DW	09H
	DW	03H
	DW	01bH
	DW	011H
	DW	04H
	DW	03H
	DW	04H
	DW	0dH
	DW	04H
	DW	01H
	DW	03H
	DW	02H
	DW	02H
	DW	01H
	DW	0aH
	DW	04H
	DW	02H
	DW	04H
	DW	06H
	DW	03H
	DW	08H
	DW	02H
	DW	01H
	DW	012H
	DW	01H
	DW	01H
	DW	018H
	DW	02H
	DW	02H
	DW	04H
	DW	021H
	DW	02H
	DW	03H
	DW	03fH
	DW	07H
	DW	01H
	DW	06H
	DW	028H
	DW	07H
	DW	03H
	DW	04H
	DW	04H
	DW	02H
	DW	04H
	DW	0fH
	DW	012H
	DW	01H
	DW	010H
	DW	01H
	DW	01H
	DW	0bH
	DW	02H
	DW	029H
	DW	0eH
	DW	01H
	DW	03H
	DW	012H
	DW	0dH
	DW	03H
	DW	02H
	DW	04H
	DW	010H
	DW	02H
	DW	011H
	DW	07H
	DW	0fH
	DW	018H
	DW	07H
	DW	012H
	DW	0dH
	DW	02cH
	DW	02H
	DW	02H
	DW	03H
	DW	06H
	DW	01H
	DW	01H
	DW	07H
	DW	05H
	DW	01H
	DW	07H
	DW	01H
	DW	04H
	DW	03H
	DW	03H
	DW	05H
	DW	0aH
	DW	08H
	DW	02H
	DW	03H
	DW	01H
	DW	08H
	DW	01H
	DW	01H
	DW	01bH
	DW	04H
	DW	02H
	DW	01H
	DW	0cH
	DW	01H
	DW	02H
	DW	01H
	DW	0aH
	DW	06H
	DW	01H
	DW	06H
	DW	07H
	DW	05H
	DW	02H
	DW	03H
	DW	07H
	DW	0bH
	DW	05H
	DW	0bH
	DW	03H
	DW	06H
	DW	06H
	DW	02H
	DW	03H
	DW	0fH
	DW	04H
	DW	09H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	0bH
	DW	02H
	DW	08H
	DW	0cH
	DW	08H
	DW	05H
	DW	04H
	DW	02H
	DW	03H
	DW	01H
	DW	05H
	DW	02H
	DW	02H
	DW	01H
	DW	0eH
	DW	01H
	DW	0cH
	DW	0bH
	DW	04H
	DW	01H
	DW	0bH
	DW	011H
	DW	011H
	DW	04H
	DW	03H
	DW	02H
	DW	05H
	DW	05H
	DW	07H
	DW	03H
	DW	01H
	DW	05H
	DW	09H
	DW	09H
	DW	08H
	DW	02H
	DW	05H
	DW	06H
	DW	06H
	DW	0dH
	DW	0dH
	DW	02H
	DW	01H
	DW	02H
	DW	06H
	DW	01H
	DW	02H
	DW	02H
	DW	031H
	DW	04H
	DW	09H
	DW	01H
	DW	02H
	DW	0aH
	DW	010H
	DW	07H
	DW	08H
	DW	04H
	DW	03H
	DW	02H
	DW	017H
	DW	04H
	DW	03aH
	DW	03H
	DW	01dH
	DW	01H
	DW	0eH
	DW	013H
	DW	013H
	DW	0bH
	DW	0bH
	DW	02H
	DW	07H
	DW	05H
	DW	01H
	DW	03H
	DW	04H
	DW	06H
	DW	02H
	DW	012H
	DW	05H
	DW	0cH
	DW	0cH
	DW	011H
	DW	011H
	DW	03H
	DW	03H
	DW	02H
	DW	04H
	DW	01H
	DW	06H
	DW	02H
	DW	03H
	DW	04H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	05H
	DW	01H
	DW	01H
	DW	09H
	DW	01H
	DW	03H
	DW	01H
	DW	03H
	DW	06H
	DW	01H
	DW	08H
	DW	01H
	DW	01H
	DW	02H
	DW	06H
	DW	04H
	DW	0eH
	DW	03H
	DW	01H
	DW	04H
	DW	0bH
	DW	04H
	DW	01H
	DW	03H
	DW	020H
	DW	01H
	DW	02H
	DW	04H
	DW	0dH
	DW	04H
	DW	01H
	DW	02H
	DW	04H
	DW	02H
	DW	01H
	DW	03H
	DW	01H
	DW	0bH
	DW	01H
	DW	04H
	DW	02H
	DW	01H
	DW	04H
	DW	04H
	DW	06H
	DW	03H
	DW	05H
	DW	01H
	DW	06H
	DW	05H
	DW	07H
	DW	06H
	DW	03H
	DW	017H
	DW	03H
	DW	05H
	DW	03H
	DW	05H
	DW	03H
	DW	03H
	DW	0dH
	DW	03H
	DW	09H
	DW	0aH
	DW	01H
	DW	0cH
	DW	0aH
	DW	02H
	DW	03H
	DW	012H
	DW	0dH
	DW	07H
	DW	0a0H
	DW	034H
	DW	04H
	DW	02H
	DW	02H
	DW	03H
	DW	02H
	DW	0eH
	DW	05H
	DW	04H
	DW	0cH
	DW	04H
	DW	06H
	DW	04H
	DW	01H
	DW	014H
	DW	04H
	DW	0bH
	DW	06H
	DW	02H
	DW	0cH
	DW	01bH
	DW	01H
	DW	04H
	DW	01H
	DW	02H
	DW	02H
	DW	07H
	DW	04H
	DW	05H
	DW	02H
	DW	01cH
	DW	03H
	DW	07H
	DW	019H
	DW	08H
	DW	03H
	DW	013H
	DW	03H
	DW	06H
	DW	0aH
	DW	02H
	DW	02H
	DW	01H
	DW	0aH
	DW	02H
	DW	05H
	DW	04H
	DW	01H
	DW	03H
	DW	04H
	DW	01H
	DW	05H
	DW	03H
	DW	02H
	DW	06H
	DW	09H
	DW	03H
	DW	06H
	DW	02H
	DW	010H
	DW	03H
	DW	03H
	DW	010H
	DW	04H
	DW	05H
	DW	05H
	DW	03H
	DW	02H
	DW	01H
	DW	02H
	DW	010H
	DW	0fH
	DW	08H
	DW	02H
	DW	06H
	DW	015H
	DW	02H
	DW	04H
	DW	01H
	DW	016H
	DW	05H
	DW	08H
	DW	01H
	DW	01H
	DW	015H
	DW	0bH
	DW	02H
	DW	01H
	DW	0bH
	DW	0bH
	DW	013H
	DW	0dH
	DW	0cH
	DW	04H
	DW	02H
	DW	03H
	DW	02H
	DW	03H
	DW	06H
	DW	01H
	DW	08H
	DW	0bH
	DW	01H
	DW	04H
	DW	02H
	DW	09H
	DW	05H
	DW	02H
	DW	01H
	DW	0bH
	DW	02H
	DW	09H
	DW	01H
	DW	01H
	DW	02H
	DW	0eH
	DW	01fH
	DW	09H
	DW	03H
	DW	04H
	DW	015H
	DW	0eH
	DW	04H
	DW	08H
	DW	01H
	DW	07H
	DW	02H
	DW	02H
	DW	02H
	DW	05H
	DW	01H
	DW	04H
	DW	014H
	DW	03H
	DW	03H
	DW	04H
	DW	0aH
	DW	01H
	DW	0bH
	DW	09H
	DW	08H
	DW	02H
	DW	01H
	DW	04H
	DW	05H
	DW	0eH
	DW	0cH
	DW	0eH
	DW	02H
	DW	011H
	DW	09H
	DW	06H
	DW	01fH
	DW	04H
	DW	0eH
	DW	01H
	DW	014H
	DW	0dH
	DW	01aH
	DW	05H
	DW	02H
	DW	07H
	DW	03H
	DW	06H
	DW	0dH
	DW	02H
	DW	04H
	DW	02H
	DW	013H
	DW	06H
	DW	02H
	DW	02H
	DW	012H
	DW	09H
	DW	03H
	DW	05H
	DW	0cH
	DW	0cH
	DW	0eH
	DW	04H
	DW	06H
	DW	02H
	DW	03H
	DW	06H
	DW	09H
	DW	05H
	DW	016H
	DW	04H
	DW	05H
	DW	019H
	DW	06H
	DW	04H
	DW	08H
	DW	05H
	DW	02H
	DW	06H
	DW	01bH
	DW	02H
	DW	023H
	DW	02H
	DW	010H
	DW	03H
	DW	07H
	DW	08H
	DW	08H
	DW	06H
	DW	06H
	DW	05H
	DW	09H
	DW	011H
	DW	02H
	DW	014H
	DW	06H
	DW	013H
	DW	02H
	DW	0dH
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	011H
	DW	0cH
	DW	02H
	DW	0eH
	DW	07H
	DW	01H
	DW	04H
	DW	012H
	DW	0cH
	DW	026H
	DW	021H
	DW	02H
	DW	0aH
	DW	01H
	DW	01H
	DW	02H
	DW	0dH
	DW	0eH
	DW	011H
	DW	0bH
	DW	032H
	DW	06H
	DW	021H
	DW	014H
	DW	01aH
	DW	04aH
	DW	010H
	DW	017H
	DW	02dH
	DW	032H
	DW	0dH
	DW	026H
	DW	021H
	DW	06H
	DW	06H
	DW	07H
	DW	04H
	DW	04H
	DW	02H
	DW	01H
	DW	03H
	DW	02H
	DW	05H
	DW	08H
	DW	07H
	DW	08H
	DW	09H
	DW	03H
	DW	0bH
	DW	015H
	DW	09H
	DW	0dH
	DW	01H
	DW	03H
	DW	0aH
	DW	06H
	DW	07H
	DW	01H
	DW	02H
	DW	02H
	DW	012H
	DW	05H
	DW	05H
	DW	01H
	DW	09H
	DW	09H
	DW	02H
	DW	044H
	DW	09H
	DW	013H
	DW	0dH
	DW	02H
	DW	05H
	DW	01H
	DW	04H
	DW	04H
	DW	07H
	DW	04H
	DW	0dH
	DW	03H
	DW	09H
	DW	0aH
	DW	015H
	DW	011H
	DW	03H
	DW	01aH
	DW	02H
	DW	01H
	DW	05H
	DW	02H
	DW	04H
	DW	05H
	DW	04H
	DW	01H
	DW	07H
	DW	04H
	DW	07H
	DW	03H
	DW	04H
	DW	02H
	DW	01H
	DW	06H
	DW	01H
	DW	01H
	DW	014H
	DW	04H
	DW	01H
	DW	09H
	DW	02H
	DW	02H
	DW	01H
	DW	03H
	DW	03H
	DW	02H
	DW	03H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	014H
	DW	02H
	DW	03H
	DW	01H
	DW	06H
	DW	02H
	DW	03H
	DW	06H
	DW	02H
	DW	04H
	DW	08H
	DW	01H
	DW	03H
	DW	02H
	DW	0aH
	DW	03H
	DW	05H
	DW	03H
	DW	04H
	DW	04H
	DW	03H
	DW	04H
	DW	010H
	DW	01H
	DW	06H
	DW	01H
	DW	0aH
	DW	02H
	DW	04H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	0aH
	DW	0bH
	DW	02H
	DW	02H
	DW	03H
	DW	01H
	DW	018H
	DW	01fH
	DW	04H
	DW	0aH
	DW	0aH
	DW	02H
	DW	05H
	DW	0cH
	DW	010H
	DW	0a4H
	DW	0fH
	DW	04H
	DW	010H
	DW	07H
	DW	09H
	DW	0fH
	DW	013H
	DW	011H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	05H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	04H
	DW	03H
	DW	01H
	DW	03H
	DW	01H
	DW	03H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	03H
	DW	03H
	DW	07H
	DW	02H
	DW	08H
	DW	01H
	DW	02H
	DW	02H
	DW	02H
	DW	01H
	DW	03H
	DW	04H
	DW	03H
	DW	07H
	DW	08H
	DW	0cH
	DW	05cH
	DW	02H
	DW	0aH
	DW	03H
	DW	01H
	DW	03H
	DW	0eH
	DW	05H
	DW	019H
	DW	010H
	DW	02aH
	DW	04H
	DW	07H
	DW	07H
	DW	04H
	DW	02H
	DW	015H
	DW	05H
	DW	01bH
	DW	01aH
	DW	01bH
	DW	015H
	DW	019H
	DW	01eH
	DW	01fH
	DW	02H
	DW	01H
	DW	05H
	DW	0dH
	DW	03H
	DW	016H
	DW	05H
	DW	06H
	DW	06H
	DW	0bH
	DW	09H
	DW	0cH
	DW	01H
	DW	05H
	DW	09H
	DW	07H
	DW	05H
	DW	05H
	DW	016H
	DW	03cH
	DW	03H
	DW	05H
	DW	0dH
	DW	01H
	DW	01H
	DW	08H
	DW	01H
	DW	01H
	DW	03H
	DW	03H
	DW	02H
	DW	01H
	DW	09H
	DW	03H
	DW	03H
	DW	012H
	DW	04H
	DW	01H
	DW	02H
	DW	03H
	DW	07H
	DW	06H
	DW	03H
	DW	01H
	DW	02H
	DW	03H
	DW	09H
	DW	01H
	DW	03H
	DW	01H
	DW	03H
	DW	02H
	DW	01H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	0bH
	DW	03H
	DW	01H
	DW	06H
	DW	09H
	DW	01H
	DW	03H
	DW	02H
	DW	03H
	DW	01H
	DW	02H
	DW	01H
	DW	05H
	DW	01H
	DW	01H
	DW	04H
	DW	03H
	DW	04H
	DW	01H
	DW	02H
	DW	02H
	DW	04H
	DW	04H
	DW	01H
	DW	07H
	DW	02H
	DW	01H
	DW	02H
	DW	02H
	DW	03H
	DW	05H
	DW	0dH
	DW	012H
	DW	03H
	DW	04H
	DW	0eH
	DW	09H
	DW	09H
	DW	04H
	DW	010H
	DW	03H
	DW	07H
	DW	05H
	DW	08H
	DW	02H
	DW	06H
	DW	030H
	DW	01cH
	DW	03H
	DW	01H
	DW	01H
	DW	04H
	DW	02H
	DW	0eH
	DW	08H
	DW	02H
	DW	09H
	DW	02H
	DW	01H
	DW	0fH
	DW	02H
	DW	04H
	DW	03H
	DW	02H
	DW	0aH
	DW	010H
	DW	0cH
	DW	08H
	DW	07H
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	07H
	DW	04H
	DW	01H
	DW	06H
	DW	04H
	DW	026H
	DW	027H
	DW	010H
	DW	017H
	DW	07H
	DW	0fH
	DW	0fH
	DW	03H
	DW	02H
	DW	0cH
	DW	07H
	DW	015H
	DW	025H
	DW	01bH
	DW	06H
	DW	05H
	DW	04H
	DW	08H
	DW	02H
	DW	0aH
	DW	08H
	DW	08H
	DW	06H
	DW	05H
	DW	01H
	DW	02H
	DW	01H
	DW	03H
	DW	018H
	DW	01H
	DW	010H
	DW	011H
	DW	09H
	DW	017H
	DW	0aH
	DW	011H
	DW	06H
	DW	01H
	DW	033H
	DW	037H
	DW	02cH
	DW	0dH
	DW	0126H
	DW	09H
	DW	03H
	DW	06H
	DW	02H
	DW	04H
	DW	02H
	DW	02H
	DW	0fH
	DW	01H
	DW	01H
	DW	01H
	DW	0dH
	DW	015H
	DW	011H
	DW	044H
	DW	0eH
	DW	08H
	DW	09H
	DW	04H
	DW	01H
	DW	04H
	DW	09H
	DW	03H
	DW	0bH
	DW	07H
	DW	01H
	DW	01H
	DW	01H
	DW	05H
	DW	06H
	DW	03H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	03H
	DW	08H
	DW	01H
	DW	02H
	DW	02H
	DW	04H
	DW	01H
	DW	05H
	DW	05H
	DW	02H
	DW	01H
	DW	04H
	DW	03H
	DW	07H
	DW	0dH
	DW	04H
	DW	01H
	DW	04H
	DW	01H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	05H
	DW	05H
	DW	0aH
	DW	01H
	DW	06H
	DW	01H
	DW	05H
	DW	02H
	DW	01H
	DW	05H
	DW	02H
	DW	04H
	DW	01H
	DW	04H
	DW	05H
	DW	07H
	DW	03H
	DW	012H
	DW	02H
	DW	09H
	DW	0bH
	DW	020H
	DW	04H
	DW	03H
	DW	03H
	DW	02H
	DW	04H
	DW	07H
	DW	0bH
	DW	010H
	DW	09H
	DW	0bH
	DW	08H
	DW	0dH
	DW	026H
	DW	020H
	DW	08H
	DW	04H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	04H
	DW	04H
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	01H
	DW	015H
	DW	03H
	DW	0bH
	DW	01H
	DW	010H
	DW	01H
	DW	01H
	DW	06H
	DW	01H
	DW	03H
	DW	02H
	DW	04H
	DW	09H
	DW	08H
	DW	039H
	DW	07H
	DW	02cH
	DW	01H
	DW	03H
	DW	03H
	DW	0dH
	DW	03H
	DW	0aH
	DW	01H
	DW	01H
	DW	07H
	DW	05H
	DW	02H
	DW	07H
	DW	015H
	DW	02fH
	DW	03fH
	DW	03H
	DW	0fH
	DW	04H
	DW	07H
	DW	01H
	DW	010H
	DW	01H
	DW	01H
	DW	02H
	DW	08H
	DW	02H
	DW	03H
	DW	02aH
	DW	0fH
	DW	04H
	DW	01H
	DW	01dH
	DW	07H
	DW	016H
	DW	0aH
	DW	03H
	DW	04eH
	DW	010H
	DW	0cH
	DW	014H
	DW	012H
	DW	04H
	DW	043H
	DW	0bH
	DW	05H
	DW	01H
	DW	03H
	DW	0fH
	DW	06H
	DW	015H
	DW	01fH
	DW	020H
	DW	01bH
	DW	012H
	DW	0dH
	DW	047H
	DW	023H
	DW	05H
	DW	08eH
	DW	04H
	DW	0aH
	DW	01H
	DW	02H
	DW	032H
	DW	013H
	DW	021H
	DW	010H
	DW	023H
	DW	025H
	DW	010H
	DW	013H
	DW	01bH
	DW	07H
	DW	01H
	DW	085H
	DW	013H
	DW	01H
	DW	04H
	DW	08H
	DW	07H
	DW	014H
	DW	01H
	DW	04H
	DW	04H
	DW	01H
	DW	0aH
	DW	03H
	DW	01H
	DW	06H
	DW	01H
	DW	02H
	DW	033H
	DW	05H
	DW	028H
	DW	0fH
	DW	018H
	DW	02bH
	DW	05990H
	DW	0bH
	DW	01H
	DW	0dH
	DW	09aH
	DW	046H
	DW	03H
	DW	01H
	DW	01H
	DW	07H
	DW	04H
	DW	0aH
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
CONST	ENDS
;	COMDAT ?ranges@?1??GetGlyphRangesChineseFull@ImFontAtlas@@QEAAPEBGXZ@4QBGB
CONST	SEGMENT
?ranges@?1??GetGlyphRangesChineseFull@ImFontAtlas@@QEAAPEBGXZ@4QBGB DW 020H ; `ImFontAtlas::GetGlyphRangesChineseFull'::`2'::ranges
	DW	0ffH
	DW	02000H
	DW	0206fH
	DW	03000H
	DW	030ffH
	DW	031f0H
	DW	031ffH
	DW	0ff00H
	DW	0ffefH
	DW	0fffdH
	DW	0fffdH
	DW	04e00H
	DW	09fafH
	DW	00H
CONST	ENDS
;	COMDAT ?base_ranges@?1??GetGlyphRangesJapanese@ImFontAtlas@@QEAAPEBGXZ@4PAGA
_DATA	SEGMENT
?base_ranges@?1??GetGlyphRangesJapanese@ImFontAtlas@@QEAAPEBGXZ@4PAGA DW 020H ; `ImFontAtlas::GetGlyphRangesJapanese'::`2'::base_ranges
	DW	0ffH
	DW	03000H
	DW	030ffH
	DW	031f0H
	DW	031ffH
	DW	0ff00H
	DW	0ffefH
	DW	0fffdH
	DW	0fffdH
_DATA	ENDS
;	COMDAT ?ranges@?1??GetGlyphRangesCyrillic@ImFontAtlas@@QEAAPEBGXZ@4QBGB
CONST	SEGMENT
?ranges@?1??GetGlyphRangesCyrillic@ImFontAtlas@@QEAAPEBGXZ@4QBGB DW 020H ; `ImFontAtlas::GetGlyphRangesCyrillic'::`2'::ranges
	DW	0ffH
	DW	0400H
	DW	052fH
	DW	02de0H
	DW	02dffH
	DW	0a640H
	DW	0a69fH
	DW	00H
CONST	ENDS
;	COMDAT ??_C@_0L@EPCGLJHG@?$CFs?0?5?$CF?40fpx@
CONST	SEGMENT
??_C@_0L@EPCGLJHG@?$CFs?0?5?$CF?40fpx@ DB '%s, %.0fpx', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@CONABPA@ProggyClean?4ttf?0?5?$CFdpx@
CONST	SEGMENT
??_C@_0BG@CONABPA@ProggyClean?4ttf?0?5?$CFdpx@ DB 'ProggyClean.ttf, %dpx', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04KODIGLGG@maxp@
CONST	SEGMENT
??_C@_04KODIGLGG@maxp@ DB 'maxp', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PCFDEHHD@GPOS@
CONST	SEGMENT
??_C@_04PCFDEHHD@GPOS@ DB 'GPOS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HJGCPIEK@CFF?5@
CONST	SEGMENT
??_C@_04HJGCPIEK@CFF?5@ DB 'CFF ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04ONMNCIMC@hmtx@
CONST	SEGMENT
??_C@_04ONMNCIMC@hmtx@ DB 'hmtx', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HHMMLDJI@kern@
CONST	SEGMENT
??_C@_04HHMMLDJI@kern@ DB 'kern', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LLIHEPK@glyf@
CONST	SEGMENT
??_C@_04LLIHEPK@glyf@ DB 'glyf', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04FMPHLIKP@hhea@
CONST	SEGMENT
??_C@_04FMPHLIKP@hhea@ DB 'hhea', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04DACNFKGE@loca@
CONST	SEGMENT
??_C@_04DACNFKGE@loca@ DB 'loca', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04NEODDMOL@head@
CONST	SEGMENT
??_C@_04NEODDMOL@head@ DB 'head', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04EICJPCEA@cmap@
CONST	SEGMENT
??_C@_04EICJPCEA@cmap@ DB 'cmap', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LLEFIKCJ@OTTO@
CONST	SEGMENT
??_C@_04LLEFIKCJ@OTTO@ DB 'OTTO', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04KIOEMAHO@ttcf@
CONST	SEGMENT
??_C@_04KIOEMAHO@ttcf@ DB 'ttcf', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LBBEMOBJ@typ1@
CONST	SEGMENT
??_C@_04LBBEMOBJ@typ1@ DB 'typ1', 00H			; `string'
	ORG $+4
?proggy_clean_ttf_compressed_data_base85@@3QBDB DB '7])#######hV0qs''/###'
	DB	'[),##/l:$#Q6>##5[n42>c-TH`->>#/e>11NNV=Bv(*:.F?uu#(gRU.o0XGH`'
	DB	'$vhLG1hxt9?W`#,5LsCp#-i>.r$<$6pD>Lb'';9Crc6tgXmKVeU2cD4Eo3R/2'
	DB	'*>]b(MC;$jPfY.;h^`IWM9<Lh2TlS+f-s$o6Q<BWH`YiU.xfLq$N;$0iR/GX:'
	DB	'U(jcW2p/W*q?-qmnUCI;jHSAiFWM.R*kU@C=GH?a9wp8f$e.-4^Qg1)Q-GL(l'
	DB	'f(r/7GrRgwV%MS=C#`8ND>Qo#t''X#(v#Y9w0#1D$CIf;W''#pWUPXOuxXuU('
	DB	'H9M(1<q-UE31#^-V''8IRUo7Qf./L>=Ke$$''5F%)]0^#0X@U.a<r:QLtFsLc'
	DB	'L6##lOj)#.Y5<-R&KgLwqJfLgN&;Q?gI^#DY2uLi@^rMl9t=cWq6##weg>$FB'
	DB	'jVQTSDgEKnIS7EM9>ZY9w0#L;>>#Mx&4Mvt//L[MkA#W@lK.N''[0#7RL_&#w'
	DB	'+F%HtG9M#XL`N&.,GM4Pg;-<nLENhvx>-VsM.M0rJfLH2eTM`*oJMHRC`Nkfi'
	DB	'mM2J,W-jXS:)r0wK#@Fge$U>`w''N7G#$#fB#$E^$#:9:hk+eOe--6x)F7*E%'
	DB	'?76%^GMHePW-Z5l''&GiF#$956:rS?dA#fiK:)Yr+`&#0j@''DbG&#^$PG.Ll'
	DB	'+DNa<XCMKEV*N)LN/N*b=%Q6pia-Xg8I$<MR&,VdJe$<(7G;Ckl''&hF;;$<_'
	DB	'=X(b.RS%%)###MPBuuE1V:v&cX&#2m#(&cV]`k9OhLMbn%s$G2,B$BfD3X*sp'
	DB	'5#l,$R#]x_X1xKX%b5U*[r5iMfUo9U`N99hG)tm+/Us9pG)XPu`<0s-)WTt(g'
	DB	'CRxIg(%6sfh=ktMKn3j)<6<b5Sk_/0(^]AaN#(p/L>&VZ>1i%h1S9u5o@YaaW'
	DB	'$e+b<TWFn/Z:Oh(Cx2$lNEoN^e)#CFY@@I;BOQ*sRwZtZxRcU7uW6CXow0i(?'
	DB	'$Q[cjOd[P4d)]>ROPOpxTO7Stwi1::iB1q)C_=dV26J;2,]7op$]uQr@_V7$q'
	DB	'^%lQwtuHY]=DX,n3L#0PHDO4f9>dC@O>HBuKPpP*E,N+b3L#lpR/MrTEH.IAQ'
	DB	'k.a>D[.e;mc.x]Ip.PH^''/aqUO/$1WxLoW0[iLA<QT;5HKD+@qQ''NQ(3_PL'
	DB	'hE48R.qAPSwQ0/WK?Z,[x?-J;jQTWA0X@KJ(_Y8N-:/M74:/-ZpKrUss?d#dZ'
	DB	'q]DAbkU*JqkL+nwX@@47`5>w=4h(9.`GCRUxHPeR`5Mjol(dUWxZa(>STrPkr'
	DB	'JiWx`5U7F#.g*jrohGg`cg:lSTvEY/EV_7H4Q9[Z%cnv;JQYZ5q.l7Zeas:HO'
	DB	'IZOB?G<Nald$qs]@]L<J7bR*>gv:[7MI2k).''2($5FNP&EQ(,)U]W]+fh18.'
	DB	'vsai00);D3@4ku5P?DP8aJt+;qUM]=+b''8@;mViBKx0DE[-auGl8:PJ&Dj+M'
	DB	'6OC]O^((##]`0i)drT;-7X`=-H3[igUnPG-NZlo.#k@h#=Ork$m>a>$-?Tm$U'
	DB	'V(?#P6YY#''/###xe7q.73rI3*pP/$1>s9)W,JrM7SN]''/4C#v$U`0#V.[0>'
	DB	'xQsH$fEmPMgY2u7Kh(G%siIfLSoS+MK2eTM$=5,M8p`A.;_R%#u[K#$x4AG8.'
	DB	'kK/HSB==-''Ie/QTtG?-.*^N-4B/ZM_3YlQC7(p7q)&](`6_c)$/*JL(L-^(]'
	DB	'$wIM`dPtOdGA,U3:w2M-0<q-]L_?^)1vw''.,MRsqVr.L;aN&#/EgJ)PBc[-f'
	DB	'>+WomX2u7lqM2iEumMTcsF?-aT=Z-97UEnXglEn1K-bnEO`guFt(c%=;Am_Qs'
	DB	'@jLooI&NX;]0#j4#F14;gl8-GQpgwhrq8''=l_f-b49''UOqkLu7-##oDY2L('
	DB	'te+Mch&gLYtJ,MEtJfLh''x''M=$CS-ZZ%P]8bZ>#S?YY#%Q&q''3^Fw&?D)U'
	DB	'DNrocM3A76//oL?#h7gl85[qW/NDOk%16ij;+:1a''iNIdb-ou8.P*w,v5#EI'
	DB	'$TWS>Pot-R*H''-SEpA:g)f+O$%%`kA#G=8RMmG1&O`>to8bC]T&$,n.LoO>2'
	DB	'9sp3dt-52U%VM#q7''DHpg+#Z9%H[K<L%a2E-grWVM3@2=-k22tL]4$##6We'''
	DB	'8UJCKE[d_=%wI;''6X-GsLX4j^SgJ$##R*w,vP3wK#iiW&#*h^D&R?jp7+/u&'
	DB	'#(AP##XU8c$fSYW-J95_-Dp[g9wcO&#M-h1OcJlc-*vpw0xUX&#OQFKNX@QI'''
	DB	'IoPp7nb,QU//MQ&ZDkKP)X<WSVL(68uVl&#c''[0#(s1X&xm$Y%B7*K:eDA32'
	DB	'3j998GXbA#pwMs-jgD$9QISB-A_(aN4xoFM^@C58D0+Q+q3n0#3U1InDjF682'
	DB	'-SjMXJK)(h$hxua_K]ul92%''BOU&#BRRh-slg8KDlr:%L71Ka:.A;%YULjDP'
	DB	'mL<LYs8i#XwJOYaKPKc1h:''9Ke,g)b),78=I39B;xiY$bgGw-&.Zi9InXDuY'
	DB	'a%G*f2Bq7mn9^#p1vv%#(Wi-;/Z5ho;#2:;%d&#x9v68C5g?ntX0X)pT`;%pB'
	DB	'3q7mgGN)3%(P8nTd5L7GeA-GL@+%J3u2:(Yf>et`e;)f#Km8&+DC$I46>#Kr]'
	DB	']u-[=99tts1.qb#q72g1WJO81q+eN''03''eM>&1XxY-caEnOj%2n8)),?ILR'
	DB	'5^.Ibn<-X-Mq7[a82Lq:F&#ce+S9wsCK*x`569E8ew''He]h:sI[2LM$[guka'
	DB	'3ZRd6:t%IG:;$%YiJ:Nq=?eAw;/:nnDq0(CYcMpG)qLN4$##&J<j$UpK<Q4a1'
	DB	']MupW^-sj_$%[HK%''F####QRZJ::Y3EGl4''@%FkiAOg#p[##O`gukTfBHag'
	DB	'L<LHw%q&OV0##F=6/:chIm0@eCP8X]:kFI%hl8hgO@RcBhS-@Qb$%+m=hPDLg'
	DB	'*%K8ln(wcf3/''DW-$.lR?n[nCH-eXOONTJlh:.RYF%3''p6sq:UIMA945&^H'
	DB	'FS87@$EP2iG<-lCO$%c`uKGD3rC$x0BL8aFn--`ke%#HMP''vh1/R&O_J9''u'
	DB	'm,.<tx[@%wsJk&bUT2`0uMv7gg#qp/ij.L56''hl;.s5CUrxjOM7-##.l+Au'''
	DB	'A&O:-T72L]P`&=;ctp''XScX*rU.>-XTt,%OVU4)S1+R-#dg0/Nn?Ku1^0f$B'
	DB	'*P:Rowwm-`0PKjYDDM''3]d39VZHEl4,.j'']Pk-M.h^&:0FACm$maq-&sgw0'
	DB	't7/6(^xtk%LuH88Fj-ekm>GA#_>568x6(OFRl-IZp`&b,_P''$M<Jnq79VsJW'
	DB	'/mWS*PUiq76;]/NM_>hLbxfc$mj`,O;&%W2m`Zh:/)Uetw:aJ%]K9h:TcF]u_'
	DB	'-Sj9,VK3M.*''&0D[Ca]J9gp8,kAW]%(?A%R$f<->Zts''^kn=-^@c4%-pY6q'
	DB	'I%J%1IGxfLU9CP8cbPlXv);C=b),<2mOvP8up,UVf3839acAWAW-W?#ao/^#%'
	DB	'KYo8fRULNd2.>%m]UK:n%r$''sw]J;5pAoO_#2mO3n,''=H5(etHg*`+RLgv>'
	DB	'=4U8guD$I%D:W>-r5V*%j*W:Kvej.Lp$<M-SGZ'':+Q_k+uvOSLiEo(<aD/K<'
	DB	'CCc`''Lx>''?;++O''>()jLR-^u68PHm8ZFWe+ej8h:9r6L*0//c&iH&R8pRb'
	DB	'A#Kjm%upV1g:a_#Ur7FuA#(tRh#.Y5K+@?3<-8m0$PEn;J:rh6?I6uG<-`wMU'
	DB	'''ircp0LaE_OtlMb&1#6T.#FDKu#1Lw%u%+GM+X''e?YLfjM[VO0MbuFp7;>Q'
	DB	'&#WIo)0@F%q7c#4XAXN-U&VB<HFF*qL($/V,;(kXZejWO`<[5??ewY(*9=%wD'
	DB	'c;,u<''9t3W-(H1th3+G]ucQ]kLs7df($/*JL]@*t7Bu_G3_7mp7<iaQjO@.k'
	DB	'Lg;x3B0lqp7Hf,^Ze7-##@/c58Mo(3;knp0%)A7?-W+eI''o8)b<nKnw''Ho8'
	DB	'C=Y>pqB>0ie&jhZ[?iLR@@_AvA-iQC(=ksRZRVp7`.=+NpBC%rh&3]R:8XDmE'
	DB	'5^V8O(x<<aG/1N$#FX$0V5Y6x''aErI3I$7x%E`v<-BY,)%-?Psf*l?%C3.mM'
	DB	'(=/M0:JxG''?7WhH%o''a<-80g0NBxoO(GH<dM]n.+%q@jH?f.UsJ2Ggs&4<-'
	DB	'e47&Kl+f//9@`b+?.TeN_&B8Ss?v;^Trk;f#YvJkl&w$]>-+k?''(<S:68tq*'
	DB	'WoDfZu'';mM?8X[ma8W%*`-=;D.(nc7/;)g:T1=^J$&BRV(-lTmNB6xqB[@0*'
	DB	'o.erM*<SWF]u2=st-*(6v>^](H.aREZSi,#1:[IXaZFOm<-ui#qUq2$##Ri;u'
	DB	'75OK#(RtaW-K-F`S+cF]uN`-KMQ%rP/Xri.LRcB##=YL3BgM/3MD?@f&1''BW'
	DB	'-)Ju<L25gl8uhVm1hL$##*8###''A3/LkKW+(^rWX?5W_8g)a(m&K8P>#bmmW'
	DB	'CMkk&#TR`C,5d>g)F;t,4:@_l8G/5h4vUd%&%950:VXD''QdWoY-F$BtUwmfe'
	DB	'$YqL''8(PWX(P?^@Po3$##`MSs?DWBZ/S>+4%>fX,VWv/w''KD`LP5IbH;rTV'
	DB	'>n3cEK8U#bX]l-/V+^lj3;vlMb&[5YQ8#pekX9JP3XUC72L,,?+Ni&co7ApnO'
	DB	'*5NK,((W-i:$,kp''UDAO(G0Sq7MVjJsbIu)''Z,*[>br5fX^:FPAWr-m2KgL'
	DB	'<LUN098kTF&#lvo58=/vjDo;.;)Ka*hLR#/k=rKbxuV`>Q_nN6''8uTG&#1T5'
	DB	'g)uLv:873UpTLgH+#FgpH''_o1780Ph8KmxQJ8#H72L4@768@Tm&Qh4CB/5Ov'
	DB	'mA&,Q&QbUoi$a_%3M01H)4x7I^&KQVgtFnV+;[Pc>[m4k//,]1?#`VY[Jr*3&'
	DB	'&slRfLiVZJ:]?=K3Sw=[$=uRB?3xk48@aeg<Z''<$#4H)6,>e0jT6''N#(q%.'
	DB	'O=?2S]u*(m<-V8J''(1)G][68hW$5''q[GC&5j`TE?m''esFGNRM)j,ffZ?-q'
	DB	'x8;->g4t*:CIP/[Qap7/9''#(1sao7w-.qNUdkJ)tCF&#B^;xGvn2r9FEPFFF'
	DB	'cL@.iFNkTve$m%#QvQS8U@)2Z+3K:AKM5isZ88+dKQ)W6>J%CL<KE>`.d*(B`'
	DB	'-n8D9oK<Up]c$X$(,)M8Zt7/[rdkqTgl-0cuGMv''?>-XV1q[''-5k''cAZ69'
	DB	'e;D_?$ZPP&s^+7])$*$#@QYi9,5P&#9r+$%CE=68>K8r0=dSC%%(@p7.m7jil'
	DB	'Q02''0-VWAg<a/''''3u.=4L$Y)6k/K:_[3=&jvL<L0C/2''v:^;-DIBW,B4E'
	DB	'68:kZ;%?8(Q8BH=kO65BW?xSG&#@uU,DS*,?.+(o(#1vCS8#CHF>TlGW''b)T'
	DB	'q7VT9q^*^$$.:&N@@$&)WHtPm*5_rO0&e%K&#-30j(E4#''Zb.o/(Tpm$>K'''
	DB	'f@[PvFl,hfINTNU6u''0pao7%XUp9]5.>%h`8_=VYbxuel.NTSsJfLacFu3B'''
	DB	'lQSu/m6-Oqem8T+oE--$0a/k]uj9EwsG>%veR*hv^BFpQj:K''#SJ,sB-''#]'
	DB	'(j.Lg92rTw-*n%@/;39rrJF,l#qV%OrtBeC6/,;qB3ebNW[?,Hqj2L.1NP&Gj'
	DB	'UR=1D8QaS3Up&@*9wP?+lo7b?@%''k4`p0Z$22%K3+iCZj?XJN4Nm&+YF]u@-'
	DB	'W$U%VEQ/,,>>#)D<h#`)h0:<Q6909ua+&VU%n2:cG3FJ-%@Bj-DgLr`Hw&HAK'
	DB	'jKjseK</xKT*)B,N9X3]krc12t''pgTV(Lv-tL[xg_%=M_q7a^x?7Ubd>#%8c'
	DB	'Y#YZ?=,`Wdxu/ae&#w6)R89tI#6@s''(6Bf7a&?S=^ZI_kS&ai`&=tE72L_D,'
	DB	';^R)7[$s<Eh#c&)q.MXI%#v9ROa5FZO%sF7q7Nwb&#ptUJ:aqJe$Sl68%.D##'
	DB	'#EC><?-aF&#RNQv>o8lKN%5/$(vdfq7+ebA#u1p]ovUKW&Y%q]''>$1@-[xfn'
	DB	'$7ZTp7mM,G,Ko7a&Gu%G[RMxJs[0MM%wci.LFDK)(<c`Q8N)jEIF*+?P2a8g%'
	DB	')$q]o2aH8C&<SibC/q,(e:v;-b#6[$NtDZ84Je2KNvB#$P5?tQ3nt(0d=j.LQ'
	DB	'f./Ll33+(;q3L-w=8dX$#WF&uIJ@-bfI>%:_i2B5CsR8&9Z&#=mPEnm0f`<&c'
	DB	')QL5uJ#%u%lJj+D-r;BoF&#4DoS97h5g)E#o:&S4weDF,9^Hoe`h*L+_a*NrL'
	DB	'W-1pG_&2UdB86e%B/:=>)N4xeW.*wft-;$''58-ESqr<b?UI(_%@[P46>#U`'''
	DB	'6AQ]m&6/`Z>#S?YY#Vc;r7U2&326d=w&H####?TZ`*4?&.MK?LP8Vxg>$[QXc'
	DB	'%QJv92.(Db*B)gb*BM9dM*hJMAo*c&#b0v=Pjer]$gG&JXDf->''StvU7505l'
	DB	'9$AFvgYRI^&<^b68?j#q9QX4SM''RO#&sL1IM.rJfLUAj221]d##DW=m83u5;'
	DB	'''bYx,*Sl0hL(W;;$doB&O/TQ:(Z^xBdLjL<Lni;''''X.`$#8+1GD:k$YUWs'
	DB	'bn8ogh6rxZ2Z9]%nd+>V#*8U_72Lh+2Q8Cj0i:6hp&$C/:p(HK>T8Y[gHQ4`4'
	DB	')''$Ab(Nof%V''8hL&#<NEdtg(n''=S1A(Q1/I&4([%dM`,Iu''1:_hL>SfD0'
	DB	'7&6D<fp8dHM7/g+tlPN9J*rKaPct&?''uBCem^jn%9_K)<,C5K3s=5g&GmJb*'
	DB	'[SYq7K;TRLGCsM-$$;S%:Y@r7AK0pprpL<Lrh,q7e/%KWK:50I^+m''vi`3?%'
	DB	'Zp+<-d+$L-Sv:@.o19n$s0&39;kn;S%BSq*$3WoJSCLweV[aZ''MQIjO<7;X-'
	DB	'X;&+dMLvu#^UsGEC9WEc[X(wI7#2.(F0jV*eZf<-Qv3J-c+J5AlrB#$p(H68L'
	DB	'vEA''q3n0#m,[`*8Ft)FcYgEud]CWfm68,(aLA$@EFTgLXoBq/UPlp7:d[/;r'
	DB	'_ix=:TF`S5H-b<LI&HY(K=h#)]Lk$K14lVfm:x$H<3^Ql<M`$OhapBnkup''D'
	DB	'#L$Pb_`N*g]2e;X/Dtg,bsj&K#2[-:iYr''_wgH)NUIR8a1n#S?Yej''h8^58'
	DB	'UbZd+^FKD*T@;6A7aQC[K8d-(v6GI$x:T<&''Gp5Uf>@M.*J:;$-rv29''M]8'
	DB	'qMv-tLp,''886iaC=Hb*YJoKJ,(j%K=H`K.v9HggqBIiZu''QvBT.#=)0ukru'
	DB	'V&.)3=(^1`o*Pj4<-<aN((^7(''#Z0wK#5GX@7u][`*S^43933A4rl][`*O4C'
	DB	'gLEl]v$1Q3AeF37dbXk,.)vj#x''d`;qgbQR%FW,2(?LO=s%Sc68%NP''##Ao'
	DB	'tl8x=BE#j1UD([3$M(]UI2LX3RpKN@;/#f''f/&_mt&F)XdF<9t4)Qa.*kTLw'
	DB	'Q''(TTB9.xH''>#MJ+gLq9-##@HuZPN0]u:h7.T..G:;$/Usj(T7`Q8tT72Ln'
	DB	'Yl<-qx8;-HV7Q-&Xdx%1a,hC=0u+HlsV>nuIQL-5<N?)NBS)QN*_I,?&)2''I'
	DB	'M%L3I)X((e/dl2&8''<M:^#M*Q+[T.Xri.LYS3v%fF`68h;b-X[/En''CR.q7'
	DB	'E)p''/kle2HM,u;^%OKC-N+Ll%F9CF<Nf''^#t2L,;27W:0O@6##U6W7:$rJf'
	DB	'LWHj$#)woqBefIZ.PK<b*t7ed;p*_m;4ExK#h@&]>_>@kXQtMacfD.m-VAb8;'
	DB	'IReM3$wf0''''hra*so568''Ip&vRs849''MRYSp%:t:h5qSgwpEr$B>Q,;s('
	DB	'C#$)`svQuF$##-D,##,g68@2[T;.XSdN9Qe)rpt._K-#5wF)sP''##p#C0c%-'
	DB	'Gb%hd+<-j''Ai*x&&HMkT]C''OSl##5RG[JXaHN;d''uA#x._U;.`PU@(Z3dt'
	DB	'4r152@:v,''R.Sj''w#0<-;kPI)FfJ&#AYJ&#//)>-k=m=*XnK$>=)72L]0I%'
	DB	'>.G690a:$##<,);?;72#?x9+d;^V''9;jY@;)br#q^YQpx:X#Te$Z^''=-=bG'
	DB	'hLf:D6&bNwZ9-ZD#n^9HhLMr5G;'']d&6''wYmTFmL<LD)F^%[tC''8;+9E#C'
	DB	'$g%#5Y>q9wI>P(9mI[>kC-ekLC/R&CH+s''B;K-M6$EB%is00:+A4[7xks.Lr'
	DB	'Nk0&E)wILYF@2L''0Nb$+pv<(2.768/FrY&h$^3i&@+G%JT''<-,v`3;_)I9M'
	DB	'^AE]CN?Cl2AZg+%4iTpT3<n-&%H%b<FDj2M<hH=&Eh<2Len$b*aTX=-8QxN)k'
	DB	'11IM1c^j%9s<L<NFSo)B?+<-(GxsF,^-Eh@$4dXhN$+#rxK8''je''D7k`e;)'
	DB	'2pYwPA''_p9&@^18ml1^[@g4t*[JOa*[=Qp7(qJ_oOL^(''7fB&Hq-:sf,sNj'
	DB	'8xq^>$U4O]GKx''m9)b@p7YsvK3w^YR-CdQ*:Ir<($u&)#(&?L9Rg3H)4fiEp'
	DB	'^iI9O8KnTj,]H?D*r7''M;PwZ9K0E^k&-cpI;.p/6_vwoFMV<->#%Xi.LxVnr'
	DB	'U(4&8/P+:hLSKj$#U%]49t''I:rgMi''FL@a:0Y-uA[39'',(vbma*hU%<-SR'
	DB	'F`Tt:542R_VV$p@[p8DV[A,?1839FWdF<TddF<9Ah-6&9tWoDlh]&1SpGMq>T'
	DB	'i1O*H&#(AL8[_P%.M>v^-))qOT*F5Cq0`Ye%+$B6i:7@0IX<N+T+0MlMBPQ*V'
	DB	'j>SsD<U4JHY8kD2)2fU/M#$e.)T4,_=8hLim[&);?UkK''-x?''(:siIfL<$p'
	DB	'FM`i<?%W(mGDHM%>iWP,##P`%/L<eXi:@Z9C.7o=@(pXdAO/NLQ8lPl+HPOQa'
	DB	'8wD8=^GlPa8TKI1CjhsCTSLJM''/Wl>-S(qw%sf/@%#B6;/U7K]uZbi^Oc^2n'
	DB	'<bhPmUkMw>%t<)''mEVE''''n`WnJra$^TKvX5B>;_aSEK'',(hwa0:i4G?.B'
	DB	'ci.(X[?b*($,=-n<.Q%`(X=?+@Am*Js0&=3bh8K]mL<LoNs''6,''85`0?t/'''
	DB	'_U59@]ddF<#LdF<eWdF<OuN/45rY<-L@&#+fm>69=Lb,OcZV/);TTm8VI;?%O'
	DB	'tJ<(b4mq7M6:u?KRdF<gR@2L=FNU-<b[(9c/ML3m;Z[$oF3g)GAWqpARc=<RO'
	DB	'u7cL5l;-[A]%/+fsd;l#SafT/f*W]0=O''$(Tb<[)*@e775R-:Yob%g*>l*:x'
	DB	'P?Yb.5)%w_I?7uk5JC+FS(m#i''k.''a0i)9<7b''fs''59hq$*5Uhv##pi^8'
	DB	'+hIEBF`nvo`;''l0.^S1<-wUK2/Coh58KKhLjM=SO*rfO`+qC`W-On.=AJ56>'
	DB	'>i2@2LH6A:&5q`?9I3@@''04&p2/LVa*T-4<-i3;M9UvZd+N7>b*eIwg:CC)c'
	DB	'<>nO&#<IGe;__.thjZl<%w(Wk2xmp4Q@I#I9,DF]u7-P=.-_:YJ]aS@V?6*C('
	DB	')dOp7:WL,b&3Rg/.cmM9&r^>$(>.Z-I&J(Q0Hd5Q%7Co-b`-c<N(6r@ip+Aur'
	DB	'K<m86QIth*#v;-OBqi+L7wDE-Ir8K[''m+DDSLwK&/.?-V%U_%3:qKNu$_b*B'
	DB	'-kp7NaD''QdWQPKYq[@>P)hI;*_F]u`Rb[.j8_Q/<&>uu+VsH$sM9TA%?)(vm'
	DB	'J80),P7E>)tjD%2L=-t#fK[%`v=Q8<FfNkgg^oIbah*#8/Qt$F&:K*-(N/''+'
	DB	'1vMB,u()-a.VUU*#[e%gAAO(S>WlA2);Sa>gXm8YB`1d@K#n]76-a$U,mF<fX'
	DB	']idqd)<3,]J7JmW4`6]uks=4-72L(jEk+:bJ0M^q-8Dm_Z?0olP1C9Sa&H[d&'
	DB	'c$ooQUj]Exd*3ZM@-WGW2%s'',B-_M%>%Ul:#/''xoFM9QX-$.QN''>[%$Z$u'
	DB	'F6pA6Ki2O5:8w*vP1<-1`[G,)-m#>0`P&#eb#.3i)rtB61(o''$?X3B</R90;'
	DB	'eZ]%Ncq;-Tl]#F>2Qft^ae_5tKL9MUe9b*sLEQ95C&`=G?@Mj=wh*''3E>=-<'
	DB	')Gt*Iw)''QG:`@IwOf7&]1i''S01B+Ev/Nac#9S;=;YQpg_6U`*kVY39xK,[/'
	DB	'6Aj7:''1Bm-_1EYfa1+o&o4hp7KN_Q(OlIo@S%;jVdn0''1<Vc52=u`3^o-n1'
	DB	'''g4v58Hj&6_t7$##?M)c<$bgQ_''SY((-xkA#Y(,p''H9rIVY-b,''%bCPF7'
	DB	'.J<Up^,(dU1VY*5#WkTU>h19w,WQhLI)3S#f$2(eb,jr*b;3Vw]*7NH%$c4Vs'
	DB	',eD9>XW8?N]o+(*pgC%/72LV-u<Hp,3@e^9UB1J+ak9-TN/mhKPg+AJYd$Mlv'
	DB	'AF_jCK*.O-^(63adMT->W%iewS8W6m2rtCpo''RS1R84=@paTKt)>=%&1[)*v'
	DB	'p''u+x,VrwN;&]kuO9JDbg=pO$J*.jVe;u''m0dr9l,<*wMK*Oe=g8lV_KEBF'
	DB	'kO''oU]^=[-792#ok,)i]lR8qQ2oA8wcRCZ^7w/Njh;?.stX?Q1>S1q4Bn$)K'
	DB	'1<-rGdO''$Wr.Lc.CG)$/*JL4tNR/,SVO3,aUw''DJN:)Ss;wGn9A32ijw%FL'
	DB	'+Z0Fn.U9;reSq)bmI32U==5ALuG&#Vf1398/pVo1*c-(aY168o<`JsSbk-,1N'
	DB	';$>0:OUas(3:8Z972LSfF8eb=c-;>SPw7.6hn3m`9^Xkn(r.qS[0;T%&Qc=+S'
	DB	'TRxX''q1BNk3&*eu2;&8q$&x>Q#Q7^Tf+6<(d%ZVmj2bDi%.3L2n+4W''$PiD'
	DB	'DG)g,r%+?,$@?uou5tSe2aN_AQU*<h`e-GI7)?OK2A.d7_c)?wQ5AS@DL3r#7'
	DB	'fSkgl6-++D:''A,uq7SvlB$pcpH''q3n0#_%dY#xCpr-l<F0NR@-##FEV6NTF'
	DB	'6##$l84N1w?AO>''IAOURQ##V^Fv-XFbGM7Fl(N<3DhLGF%q.1rC$#:T__&Pi'
	DB	'68%0xi_&[qFJ(77j_&JWoF.V735&T,[R*:xFR*K5>>#`bW-?4Ne_&6Ne_&6Ne'
	DB	'_&n`kr-#GJcM6X;uM6X;uM(.a..^2TkL%oR(#;u.T%fAr%4tJ8&><1=GHZ_+m'
	DB	'9/#H1F^R#SC#*N=BA9(D?v[UiFY>>^8p,KKF.W]L29uLkLlu/+4T<XoIB&hx='
	DB	'T1PcDaB&;HH+-AFr?(m9HZV)FKS8JCw;SD=6[^/DZUL`EUDf]GGlG&>w$)F./'
	DB	'^n3+rlo+DB;5sIYGNk+i1t-69Jg--0pao7Sm#K)pdHW&;LuDNH@H>#/X-TI(;'
	DB	'P>#,Gc>#0Su>#4`1?#8lC?#<xU?#@.i?#D:%@#HF7@#LRI@#P_[@#Tkn@#Xw*'
	DB	'A#]-=A#a9OA#d<F&#*;G##.GY##2Sl##6`($#:l:$#>xL$#B.`$#F:r$#JF.%'
	DB	'#NR@%#R_R%#Vke%#Zww%#_-4&#3^Rh%Sflr-k''MS.o?.5/sWel/wpEM0%3'''
	DB	'/1)K^f1-d>G21&v(35>V`39V7A4=onx4A1OY5EI0;6Ibgr6M$HS7Q<)58C5w,'
	DB	';WoA*#[%T*#`1g*#d=#+#hI5+#lUG+#pbY+#tnl+#x$),#&1;,#*=M,#.I`,#'
	DB	'2Ur,#6b.-#;w[H#iQtA#m^0B#qjBB#uvTB##-hB#''9$C#+E6C#/QHC#3^ZC#'
	DB	'7jmC#;v)D#?,<D#C8ND#GDaD#KPsD#O]/E#g1A5#KA*1#gC17#MGd;#8(02#L'
	DB	'-d3#rWM4#Hga1#,<w0#T.j<#O#''2#CYN1#qa^:#_4m3#o@/=#eG8=#t8J5#`'
	DB	'+78#4uI-#m3B2#SB[8#Q0@8#i[*9#iOn8#1Nm;#^sN9#qh<9#:=x-#P;K2#$%'
	DB	'X9#bC+.#Rg;<#mN=.#MTF.#RZO.#2?)4#Y#(/#[)1/#b;L/#dAU/#0Sv;#lY$'
	DB	'0#n`-0#sf60#(F24#wrH0#%/e0#TmD<#%JSMFove:CTBEXI:<eh2g)B,3h2^G'
	DB	'3i;#d3jD>)4kMYD4lVu`4m`:&5niUA5@(A5BA1]PBB:xlBCC=2CDLXMCEUtiC'
	DB	'f&0g2''tN?PGT4CPGT4CPGT4CPGT4CPGT4CPGT4CPGT4CPGT4CPGT4CPGT4CP'
	DB	'GT4CPGT4CPGT4CP-qekC`.9kEg^+F$kwViFJTB&5KTB&5KTB&5KTB&5KTB&5K'
	DB	'TB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5o,^<-28ZI''O'
	DB	'?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?'
	DB	';xpO?;xp;7q-#lLYI:xvD=#', 00H		; proggy_clean_ttf_compressed_data_base85
	ORG $+3
?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A DD 000000000r ; 0 ; FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA
	DD	040400000r			; 3
	DD	041400000r			; 12
	DD	041980000r			; 19
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	041500000r			; 13
	DD	000000000r			; 0
	DD	040e00000r			; 7
	DD	041800000r			; 16
	DD	03f800000r			; 1
	DD	041000000r			; 8
	DD	041f80000r			; 31
	DD	000000000r			; 0
	DD	041b80000r			; 23
	DD	041b80000r			; 23
	DD	041300000r			; 11
	DD	041300000r			; 11
	DD	041a80000r			; 21
	DD	000000000r			; 0
	DD	041100000r			; 9
	DD	041b80000r			; 23
	DD	040800000r			; 4
	DD	041300000r			; 11
	DD	0425c0000r			; 55
	DD	041900000r			; 18
	DD	041b80000r			; 23
	DD	041100000r			; 9
	DD	041300000r			; 11
	DD	040800000r			; 4
	DD	042920000r			; 73
	DD	000000000r			; 0
	DD	041880000r			; 17
	DD	041880000r			; 17
	DD	041000000r			; 8
	DD	041000000r			; 8
	DD	0425c0000r			; 55
	DD	000000000r			; 0
	DD	041880000r			; 17
	DD	041880000r			; 17
	DD	041000000r			; 8
	DD	041000000r			; 8
	DD	042b60000r			; 91
	DD	000000000r			; 0
	DD	041880000r			; 17
	DD	041b00000r			; 22
	DD	040a00000r			; 5
	DD	000000000r			; 0
	DD	042da0000r			; 109
	DD	000000000r			; 0
	DD	041500000r			; 13
	DD	041700000r			; 15
	DD	040c00000r			; 6
	DD	040e00000r			; 7
	ORG $+4
?FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS@@3QBDB DB '..-         -XXXXXXX-    X'
	DB	'    -           X           -XXXXXXX          -          XXXX'
	DB	'XXX-     XX          - XX       XX ..-         -X.....X-   X.'
	DB	'X   -          X.X          -X.....X          -          X...'
	DB	'..X-    X..X         -X..X     X..X---         -XXX.XXX-  X..'
	DB	'.X  -         X...X         -X....X           -           X..'
	DB	'..X-    X..X         -X...X   X...XX           -  X.X  - X...'
	DB	'..X -        X.....X        -X...X            -            X.'
	DB	'..X-    X..X         - X...X X...X XX          -  X.X  -X....'
	DB	'...X-       X.......X       -X..X.X           -           X.X'
	DB	'..X-    X..X         -  X...X...X  X.X         -  X.X  -XXXX.'
	DB	'XXXX-       XXXX.XXXX       -X.X X.X          -          X.X '
	DB	'X.X-    X..XXX       -   X.....X   X..X        -  X.X  -   X.'
	DB	'X   -          X.X          -XX   X.X         -         X.X  '
	DB	' XX-    X..X..XXX    -    X...X    X...X       -  X.X  -   X.'
	DB	'X   -    XX    X.X    XX    -      X.X        -        X.X   '
	DB	'   -    X..X..X..XX  -     X.X     X....X      -  X.X  -   X.'
	DB	'X   -   X.X    X.X    X.X   -       X.X       -       X.X    '
	DB	'   -    X..X..X..X.X -    X...X    X.....X     -  X.X  -   X.'
	DB	'X   -  X..X    X.X    X..X  -        X.X      -      X.X     '
	DB	'   -XXX X..X..X..X..X-   X.....X   X......X    -  X.X  -   X.'
	DB	'X   - X...XXXXXX.XXXXXX...X -         X.X   XX-XX   X.X      '
	DB	'   -X..XX........X..X-  X...X...X  X.......X   -  X.X  -   X.'
	DB	'X   -X.....................X-          X.X X.X-X.X X.X       '
	DB	'   -X...X...........X- X...X X...X X........X  -  X.X  -   X.'
	DB	'X   - X...XXXXXX.XXXXXX...X -           X.X..X-X..X.X        '
	DB	'   - X..............X-X...X   X...XX.........X -XXX.XXX-   X.'
	DB	'X   -  X..X    X.X    X..X  -            X...X-X...X         '
	DB	'   -  X.............X-X..X     X..XX..........X-X.....X-   X.'
	DB	'X   -   X.X    X.X    X.X   -           X....X-X....X        '
	DB	'   -  X.............X- XX       XX X......XXXXX-XXXXXXX-   X.'
	DB	'X   -    XX    X.X    XX    -          X.....X-X.....X       '
	DB	'   -   X............X--------------X...X..X    ---------   X.'
	DB	'X   -          X.X          -          XXXXXXX-XXXXXXX       '
	DB	'   -   X...........X -             X..X X..X   -       -XXXX.'
	DB	'XXXX-       XXXX.XXXX       ---------------------------------'
	DB	'----    X..........X -             X.X  X..X   -       -X....'
	DB	'...X-       X.......X       -    XX           XX    -        '
	DB	'   -    X..........X -             XX    X..X  -       - X...'
	DB	'..X -        X.....X        -   X.X           X.X   -        '
	DB	'   -     X........X  -                   X..X  -       -  X..'
	DB	'.X  -         X...X         -  X..X           X..X  -        '
	DB	'   -     X........X  -                    XX   -       -   X.'
	DB	'X   -          X.X          - X...XXXXXXXXXXXXX...X -        '
	DB	'   -     XXXXXXXXXX  -             -------------       -    X'
	DB	'    -           X           -X.....................X-        '
	DB	'   -------------------                                 ------'
	DB	'----------------------------- X...XXXXXXXXXXXXX...X -        '
	DB	'                                                             '
	DB	'                            -  X..X           X..X  -        '
	DB	'                                                             '
	DB	'                            -   X.X           X.X   -        '
	DB	'                                                             '
	DB	'                            -    XX           XX    -        '
	DB	'                                   ', 00H	; FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS
PUBLIC	??_GImFont@@QEAAPEAXI@Z				; ImFont::`scalar deleting destructor'
PUBLIC	??$IM_DELETE@UImFont@@@@YAXPEAUImFont@@@Z	; IM_DELETE<ImFont>
PUBLIC	?_grow_capacity@?$ImVector@UImDrawChannel@@@@QEBAHH@Z ; ImVector<ImDrawChannel>::_grow_capacity
PUBLIC	?_grow_capacity@?$ImVector@UImDrawVert@@@@QEBAHH@Z ; ImVector<ImDrawVert>::_grow_capacity
PUBLIC	?_grow_capacity@?$ImVector@UImVec4@@@@QEBAHH@Z	; ImVector<ImVec4>::_grow_capacity
PUBLIC	?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z		; ImVector<ImVec4>::reserve
PUBLIC	?_grow_capacity@?$ImVector@PEAX@@QEBAHH@Z	; ImVector<void *>::_grow_capacity
PUBLIC	?reserve@?$ImVector@PEAX@@QEAAXH@Z		; ImVector<void *>::reserve
PUBLIC	?_grow_capacity@?$ImVector@UImFontAtlasCustomRect@@@@QEBAHH@Z ; ImVector<ImFontAtlasCustomRect>::_grow_capacity
PUBLIC	?reserve@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXH@Z ; ImVector<ImFontAtlasCustomRect>::reserve
PUBLIC	?_grow_capacity@?$ImVector@UImFontConfig@@@@QEBAHH@Z ; ImVector<ImFontConfig>::_grow_capacity
PUBLIC	?reserve@?$ImVector@UImFontConfig@@@@QEAAXH@Z	; ImVector<ImFontConfig>::reserve
PUBLIC	?_grow_capacity@?$ImVector@UImFontGlyph@@@@QEBAHH@Z ; ImVector<ImFontGlyph>::_grow_capacity
PUBLIC	?reserve@?$ImVector@UImFontGlyph@@@@QEAAXH@Z	; ImVector<ImFontGlyph>::reserve
PUBLIC	?clear@?$ImVector@UImFontBuildSrcData@@@@QEAAXXZ ; ImVector<ImFontBuildSrcData>::clear
PUBLIC	?_grow_capacity@?$ImVector@UImFontBuildSrcData@@@@QEBAHH@Z ; ImVector<ImFontBuildSrcData>::_grow_capacity
PUBLIC	?reserve@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z ; ImVector<ImFontBuildSrcData>::reserve
PUBLIC	?_grow_capacity@?$ImVector@UImFontBuildDstData@@@@QEBAHH@Z ; ImVector<ImFontBuildDstData>::_grow_capacity
PUBLIC	?reserve@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z ; ImVector<ImFontBuildDstData>::reserve
PUBLIC	?_grow_capacity@?$ImVector@Ustbrp_rect@@@@QEBAHH@Z ; ImVector<stbrp_rect>::_grow_capacity
PUBLIC	?reserve@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z	; ImVector<stbrp_rect>::reserve
PUBLIC	?_grow_capacity@?$ImVector@Ustbtt_packedchar@@@@QEBAHH@Z ; ImVector<stbtt_packedchar>::_grow_capacity
PUBLIC	?reserve@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z ; ImVector<stbtt_packedchar>::reserve
PUBLIC	??1ImBitVector@@QEAA@XZ				; ImBitVector::~ImBitVector
PUBLIC	??1ImFontBuildSrcData@@QEAA@XZ			; ImFontBuildSrcData::~ImFontBuildSrcData
PUBLIC	??_GImFontBuildSrcData@@QEAAPEAXI@Z		; ImFontBuildSrcData::`scalar deleting destructor'
PUBLIC	?resize@?$ImVector@G@@QEAAXHAEBG@Z		; ImVector<unsigned short>::resize
PUBLIC	?clear@?$ImVector@UImDrawCmd@@@@QEAAXXZ		; ImVector<ImDrawCmd>::clear
PUBLIC	??A?$ImVector@UImDrawCmd@@@@QEAAAEAUImDrawCmd@@H@Z ; ImVector<ImDrawCmd>::operator[]
PUBLIC	?resize@?$ImVector@UImDrawCmd@@@@QEAAXH@Z	; ImVector<ImDrawCmd>::resize
PUBLIC	?erase@?$ImVector@UImDrawCmd@@@@QEAAPEAUImDrawCmd@@PEBU2@@Z ; ImVector<ImDrawCmd>::erase
PUBLIC	??A?$ImVector@UImDrawChannel@@@@QEAAAEAUImDrawChannel@@H@Z ; ImVector<ImDrawChannel>::operator[]
PUBLIC	?resize@?$ImVector@UImDrawChannel@@@@QEAAXH@Z	; ImVector<ImDrawChannel>::resize
PUBLIC	?reserve@?$ImVector@UImDrawChannel@@@@QEAAXH@Z	; ImVector<ImDrawChannel>::reserve
PUBLIC	?clear@?$ImVector@UImDrawVert@@@@QEAAXXZ	; ImVector<ImDrawVert>::clear
PUBLIC	?resize@?$ImVector@UImDrawVert@@@@QEAAXH@Z	; ImVector<ImDrawVert>::resize
PUBLIC	?clear@?$ImVector@UImVec4@@@@QEAAXXZ		; ImVector<ImVec4>::clear
PUBLIC	?resize@?$ImVector@UImVec4@@@@QEAAXH@Z		; ImVector<ImVec4>::resize
PUBLIC	?push_back@?$ImVector@UImVec4@@@@QEAAXAEBUImVec4@@@Z ; ImVector<ImVec4>::push_back
PUBLIC	?pop_back@?$ImVector@UImVec4@@@@QEAAXXZ		; ImVector<ImVec4>::pop_back
PUBLIC	?clear@?$ImVector@PEAX@@QEAAXXZ			; ImVector<void *>::clear
PUBLIC	?resize@?$ImVector@PEAX@@QEAAXH@Z		; ImVector<void *>::resize
PUBLIC	?push_back@?$ImVector@PEAX@@QEAAXAEBQEAX@Z	; ImVector<void *>::push_back
PUBLIC	?pop_back@?$ImVector@PEAX@@QEAAXXZ		; ImVector<void *>::pop_back
PUBLIC	?reserve_discard@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve_discard
PUBLIC	?push_back@?$ImVector@PEAUImDrawList@@@@QEAAXAEBQEAUImDrawList@@@Z ; ImVector<ImDrawList *>::push_back
PUBLIC	?empty@?$ImVector@I@@QEBA_NXZ			; ImVector<unsigned int>::empty
PUBLIC	?begin@?$ImVector@I@@QEBAPEBIXZ			; ImVector<unsigned int>::begin
PUBLIC	?end@?$ImVector@I@@QEBAPEBIXZ			; ImVector<unsigned int>::end
PUBLIC	?clear_delete@?$ImVector@PEAUImFont@@@@QEAAXXZ	; ImVector<ImFont *>::clear_delete
PUBLIC	??0?$ImVector@UImFontAtlasCustomRect@@@@QEAA@XZ	; ImVector<ImFontAtlasCustomRect>::ImVector<ImFontAtlasCustomRect>
PUBLIC	??1?$ImVector@UImFontAtlasCustomRect@@@@QEAA@XZ	; ImVector<ImFontAtlasCustomRect>::~ImVector<ImFontAtlasCustomRect>
PUBLIC	?clear@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXXZ ; ImVector<ImFontAtlasCustomRect>::clear
PUBLIC	??A?$ImVector@UImFontAtlasCustomRect@@@@QEAAAEAUImFontAtlasCustomRect@@H@Z ; ImVector<ImFontAtlasCustomRect>::operator[]
PUBLIC	?push_back@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXAEBUImFontAtlasCustomRect@@@Z ; ImVector<ImFontAtlasCustomRect>::push_back
PUBLIC	??0?$ImVector@UImFontConfig@@@@QEAA@XZ		; ImVector<ImFontConfig>::ImVector<ImFontConfig>
PUBLIC	??1?$ImVector@UImFontConfig@@@@QEAA@XZ		; ImVector<ImFontConfig>::~ImVector<ImFontConfig>
PUBLIC	?clear@?$ImVector@UImFontConfig@@@@QEAAXXZ	; ImVector<ImFontConfig>::clear
PUBLIC	??A?$ImVector@UImFontConfig@@@@QEAAAEAUImFontConfig@@H@Z ; ImVector<ImFontConfig>::operator[]
PUBLIC	?back@?$ImVector@UImFontConfig@@@@QEAAAEAUImFontConfig@@XZ ; ImVector<ImFontConfig>::back
PUBLIC	?push_back@?$ImVector@UImFontConfig@@@@QEAAXAEBUImFontConfig@@@Z ; ImVector<ImFontConfig>::push_back
PUBLIC	?resize@?$ImVector@M@@QEAAXHAEBM@Z		; ImVector<float>::resize
PUBLIC	??0?$ImVector@UImFontGlyph@@@@QEAA@XZ		; ImVector<ImFontGlyph>::ImVector<ImFontGlyph>
PUBLIC	??1?$ImVector@UImFontGlyph@@@@QEAA@XZ		; ImVector<ImFontGlyph>::~ImVector<ImFontGlyph>
PUBLIC	?clear@?$ImVector@UImFontGlyph@@@@QEAAXXZ	; ImVector<ImFontGlyph>::clear
PUBLIC	??A?$ImVector@UImFontGlyph@@@@QEAAAEAUImFontGlyph@@H@Z ; ImVector<ImFontGlyph>::operator[]
PUBLIC	?back@?$ImVector@UImFontGlyph@@@@QEAAAEAUImFontGlyph@@XZ ; ImVector<ImFontGlyph>::back
PUBLIC	?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z	; ImVector<ImFontGlyph>::resize
PUBLIC	??0?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ	; ImVector<ImFontBuildSrcData>::ImVector<ImFontBuildSrcData>
PUBLIC	??1?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ	; ImVector<ImFontBuildSrcData>::~ImVector<ImFontBuildSrcData>
PUBLIC	?clear_destruct@?$ImVector@UImFontBuildSrcData@@@@QEAAXXZ ; ImVector<ImFontBuildSrcData>::clear_destruct
PUBLIC	?size_in_bytes@?$ImVector@UImFontBuildSrcData@@@@QEBAHXZ ; ImVector<ImFontBuildSrcData>::size_in_bytes
PUBLIC	??A?$ImVector@UImFontBuildSrcData@@@@QEAAAEAUImFontBuildSrcData@@H@Z ; ImVector<ImFontBuildSrcData>::operator[]
PUBLIC	?resize@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z ; ImVector<ImFontBuildSrcData>::resize
PUBLIC	??0?$ImVector@UImFontBuildDstData@@@@QEAA@XZ	; ImVector<ImFontBuildDstData>::ImVector<ImFontBuildDstData>
PUBLIC	??1?$ImVector@UImFontBuildDstData@@@@QEAA@XZ	; ImVector<ImFontBuildDstData>::~ImVector<ImFontBuildDstData>
PUBLIC	?clear@?$ImVector@UImFontBuildDstData@@@@QEAAXXZ ; ImVector<ImFontBuildDstData>::clear
PUBLIC	?size_in_bytes@?$ImVector@UImFontBuildDstData@@@@QEBAHXZ ; ImVector<ImFontBuildDstData>::size_in_bytes
PUBLIC	??A?$ImVector@UImFontBuildDstData@@@@QEAAAEAUImFontBuildDstData@@H@Z ; ImVector<ImFontBuildDstData>::operator[]
PUBLIC	?resize@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z ; ImVector<ImFontBuildDstData>::resize
PUBLIC	??0?$ImVector@Ustbrp_rect@@@@QEAA@XZ		; ImVector<stbrp_rect>::ImVector<stbrp_rect>
PUBLIC	??1?$ImVector@Ustbrp_rect@@@@QEAA@XZ		; ImVector<stbrp_rect>::~ImVector<stbrp_rect>
PUBLIC	?clear@?$ImVector@Ustbrp_rect@@@@QEAAXXZ	; ImVector<stbrp_rect>::clear
PUBLIC	?size_in_bytes@?$ImVector@Ustbrp_rect@@@@QEBAHXZ ; ImVector<stbrp_rect>::size_in_bytes
PUBLIC	??A?$ImVector@Ustbrp_rect@@@@QEAAAEAUstbrp_rect@@H@Z ; ImVector<stbrp_rect>::operator[]
PUBLIC	?resize@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z	; ImVector<stbrp_rect>::resize
PUBLIC	??0?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ	; ImVector<stbtt_packedchar>::ImVector<stbtt_packedchar>
PUBLIC	??1?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ	; ImVector<stbtt_packedchar>::~ImVector<stbtt_packedchar>
PUBLIC	?size_in_bytes@?$ImVector@Ustbtt_packedchar@@@@QEBAHXZ ; ImVector<stbtt_packedchar>::size_in_bytes
PUBLIC	??A?$ImVector@Ustbtt_packedchar@@@@QEAAAEAUstbtt_packedchar@@H@Z ; ImVector<stbtt_packedchar>::operator[]
PUBLIC	?resize@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z ; ImVector<stbtt_packedchar>::resize
PUBLIC	?RenderColorRectWithAlphaCheckerboard@ImGui@@YAXPEAUImDrawList@@UImVec2@@1IM1MH@Z ; ImGui::RenderColorRectWithAlphaCheckerboard
PUBLIC	?RenderArrowDockMenu@ImGui@@YAXPEAUImDrawList@@UImVec2@@MI@Z ; ImGui::RenderArrowDockMenu
PUBLIC	?RenderArrowPointingAt@ImGui@@YAXPEAUImDrawList@@UImVec2@@1HI@Z ; ImGui::RenderArrowPointingAt
PUBLIC	?RenderCheckMark@ImGui@@YAXPEAUImDrawList@@UImVec2@@IM@Z ; ImGui::RenderCheckMark
PUBLIC	?RenderArrow@ImGui@@YAXPEAUImDrawList@@UImVec2@@IHM@Z ; ImGui::RenderArrow
PUBLIC	?RenderText@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IAEBUImVec4@@PEBD3M_N@Z ; ImFont::RenderText
PUBLIC	?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z ; ImFont::CalcWordWrapPositionA
PUBLIC	?FindGlyph@ImFont@@QEBAPEBUImFontGlyph@@G@Z	; ImFont::FindGlyph
PUBLIC	?AddGlyph@ImFont@@QEAAXPEBUImFontConfig@@GMMMMMMMMM@Z ; ImFont::AddGlyph
PUBLIC	?GrowIndex@ImFont@@QEAAXH@Z			; ImFont::GrowIndex
PUBLIC	?SetGlyphVisible@ImFont@@QEAAXG_N@Z		; ImFont::SetGlyphVisible
PUBLIC	?BuildLookupTable@ImFont@@QEAAXXZ		; ImFont::BuildLookupTable
PUBLIC	?ClearOutputData@ImFont@@QEAAXXZ		; ImFont::ClearOutputData
PUBLIC	?GetGlyphRangesDefault@ImFontAtlas@@QEAAPEBGXZ	; ImFontAtlas::GetGlyphRangesDefault
PUBLIC	?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z	; ImFontAtlasBuildFinish
PUBLIC	?ImFontAtlasBuildInit@@YAXPEAUImFontAtlas@@@Z	; ImFontAtlasBuildInit
PUBLIC	?ImFontAtlasBuildRender32bppRectFromString@@YAXPEAUImFontAtlas@@HHHHPEBDDI@Z ; ImFontAtlasBuildRender32bppRectFromString
PUBLIC	?ImFontAtlasBuildRender8bppRectFromString@@YAXPEAUImFontAtlas@@HHHHPEBDDE@Z ; ImFontAtlasBuildRender8bppRectFromString
PUBLIC	?ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z ; ImFontAtlasBuildPackCustomRects
PUBLIC	?ImFontAtlasBuildSetupFont@@YAXPEAUImFontAtlas@@PEAUImFont@@PEAUImFontConfig@@MM@Z ; ImFontAtlasBuildSetupFont
PUBLIC	?ImFontAtlasGetBuilderForStbTruetype@@YAPEBUImFontBuilderIO@@XZ ; ImFontAtlasGetBuilderForStbTruetype
PUBLIC	?ImFontAtlasBuildMultiplyRectAlpha8@@YAXQEBEPEAEHHHHH@Z ; ImFontAtlasBuildMultiplyRectAlpha8
PUBLIC	?ImFontAtlasBuildMultiplyCalcLookupTable@@YAXQEAEM@Z ; ImFontAtlasBuildMultiplyCalcLookupTable
PUBLIC	?Build@ImFontAtlas@@QEAA_NXZ			; ImFontAtlas::Build
PUBLIC	?CalcCustomRectUV@ImFontAtlas@@QEBAXPEBUImFontAtlasCustomRect@@PEAUImVec2@@1@Z ; ImFontAtlas::CalcCustomRectUV
PUBLIC	?AddCustomRectRegular@ImFontAtlas@@QEAAHHH@Z	; ImFontAtlas::AddCustomRectRegular
PUBLIC	?AddFontFromMemoryCompressedBase85TTF@ImFontAtlas@@QEAAPEAUImFont@@PEBDMPEBUImFontConfig@@PEBG@Z ; ImFontAtlas::AddFontFromMemoryCompressedBase85TTF
PUBLIC	?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z ; ImFontAtlas::AddFontFromMemoryCompressedTTF
PUBLIC	?AddFontFromMemoryTTF@ImFontAtlas@@QEAAPEAUImFont@@PEAXHMPEBUImFontConfig@@PEBG@Z ; ImFontAtlas::AddFontFromMemoryTTF
PUBLIC	?AddFontDefault@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z ; ImFontAtlas::AddFontDefault
PUBLIC	?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z ; ImFontAtlas::AddFont
PUBLIC	?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z ; ImFontAtlas::GetTexDataAsRGBA32
PUBLIC	?GetTexDataAsAlpha8@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z ; ImFontAtlas::GetTexDataAsAlpha8
PUBLIC	?Clear@ImFontAtlas@@QEAAXXZ			; ImFontAtlas::Clear
PUBLIC	?ClearFonts@ImFontAtlas@@QEAAXXZ		; ImFontAtlas::ClearFonts
PUBLIC	?ClearTexData@ImFontAtlas@@QEAAXXZ		; ImFontAtlas::ClearTexData
PUBLIC	?ClearInputData@ImFontAtlas@@QEAAXXZ		; ImFontAtlas::ClearInputData
PUBLIC	??0ImFontConfig@@QEAA@XZ			; ImFontConfig::ImFontConfig
PUBLIC	?ShadeVertsLinearUV@ImGui@@YAXPEAUImDrawList@@HHAEBUImVec2@@111_N@Z ; ImGui::ShadeVertsLinearUV
PUBLIC	?ShadeVertsLinearColorGradientKeepAlpha@ImGui@@YAXPEAUImDrawList@@HHUImVec2@@1II@Z ; ImGui::ShadeVertsLinearColorGradientKeepAlpha
PUBLIC	??0ImDrawChannel@@QEAA@XZ			; ImDrawChannel::ImDrawChannel
PUBLIC	?AddImageRounded@ImDrawList@@QEAAXPEAXAEBUImVec2@@111IMH@Z ; ImDrawList::AddImageRounded
PUBLIC	?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z	; ImDrawList::PathRect
PUBLIC	?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z ; ImDrawList::_PathArcToN
PUBLIC	?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z ; ImDrawList::_PathArcToFastEx
PUBLIC	?PrimRectUV@ImDrawList@@QEAAXAEBUImVec2@@000I@Z	; ImDrawList::PrimRectUV
PUBLIC	?PrimRect@ImDrawList@@QEAAXAEBUImVec2@@0I@Z	; ImDrawList::PrimRect
PUBLIC	?PrimReserve@ImDrawList@@QEAAXHH@Z		; ImDrawList::PrimReserve
PUBLIC	?_OnChangedVtxOffset@ImDrawList@@QEAAXXZ	; ImDrawList::_OnChangedVtxOffset
PUBLIC	?_OnChangedTextureID@ImDrawList@@QEAAXXZ	; ImDrawList::_OnChangedTextureID
PUBLIC	?_OnChangedClipRect@ImDrawList@@QEAAXXZ		; ImDrawList::_OnChangedClipRect
PUBLIC	?AddCallback@ImDrawList@@QEAAXP6AXPEBU1@PEBUImDrawCmd@@@ZPEAX@Z ; ImDrawList::AddCallback
PUBLIC	?SetBit@ImBitVector@@QEAAXH@Z			; ImBitVector::SetBit
PUBLIC	?TestBit@ImBitVector@@QEBA_NH@Z			; ImBitVector::TestBit
PUBLIC	?Clear@ImBitVector@@QEAAXXZ			; ImBitVector::Clear
PUBLIC	?Create@ImBitVector@@QEAAXH@Z			; ImBitVector::Create
PUBLIC	?GetCustomRectByIndex@ImFontAtlas@@QEAAPEAUImFontAtlasCustomRect@@H@Z ; ImFontAtlas::GetCustomRectByIndex
PUBLIC	??0ImFontAtlasCustomRect@@QEAA@XZ		; ImFontAtlasCustomRect::ImFontAtlasCustomRect
PUBLIC	?PrimWriteIdx@ImDrawList@@QEAAXG@Z		; ImDrawList::PrimWriteIdx
PUBLIC	?PrimWriteVtx@ImDrawList@@QEAAXAEBUImVec2@@0I@Z	; ImDrawList::PrimWriteVtx
PUBLIC	?Clear@ImDrawListSplitter@@QEAAXXZ		; ImDrawListSplitter::Clear
PUBLIC	??0ImDrawCmd@@QEAA@XZ				; ImDrawCmd::ImDrawCmd
PUBLIC	?_CalcCircleAutoSegmentCount@ImDrawList@@QEBAHM@Z ; ImDrawList::_CalcCircleAutoSegmentCount
PUBLIC	?AddBezierCubic@ImDrawList@@QEAAXAEBUImVec2@@000IMH@Z ; ImDrawList::AddBezierCubic
PUBLIC	?AddTriangle@ImDrawList@@QEAAXAEBUImVec2@@00IM@Z ; ImDrawList::AddTriangle
PUBLIC	?AddRectFilledMultiColor@ImDrawList@@QEAAXAEBUImVec2@@0IIII@Z ; ImDrawList::AddRectFilledMultiColor
PUBLIC	?RenderChar@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IG@Z ; ImFont::RenderChar
PUBLIC	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA
PUBLIC	?FindGlyphNoFallback@ImFont@@QEBAPEBUImFontGlyph@@G@Z ; ImFont::FindGlyphNoFallback
PUBLIC	??1ImFont@@QEAA@XZ				; ImFont::~ImFont
PUBLIC	??0ImFont@@QEAA@XZ				; ImFont::ImFont
PUBLIC	?SetCurrentChannel@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z ; ImDrawListSplitter::SetCurrentChannel
PUBLIC	?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z ; ImDrawListSplitter::Merge
PUBLIC	?Split@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z ; ImDrawListSplitter::Split
PUBLIC	?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ	; ImDrawListSplitter::ClearFreeMemory
PUBLIC	?_PopUnusedDrawCmd@ImDrawList@@QEAAXXZ		; ImDrawList::_PopUnusedDrawCmd
PUBLIC	?_ClearFreeMemory@ImDrawList@@QEAAXXZ		; ImDrawList::_ClearFreeMemory
PUBLIC	?_ResetForNewFrame@ImDrawList@@QEAAXXZ		; ImDrawList::_ResetForNewFrame
PUBLIC	?AddDrawCmd@ImDrawList@@QEAAXXZ			; ImDrawList::AddDrawCmd
PUBLIC	?PathArcToFast@ImDrawList@@QEAAXAEBUImVec2@@MHH@Z ; ImDrawList::PathArcToFast
PUBLIC	?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z	; ImDrawList::PathArcTo
PUBLIC	?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z ; ImDrawList::AddImage
PUBLIC	?AddText@ImDrawList@@QEAAXAEBUImVec2@@IPEBD1@Z	; ImDrawList::AddText
PUBLIC	?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z ; ImDrawList::AddText
PUBLIC	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z	; ImDrawList::AddLine
PUBLIC	?PopTextureID@ImDrawList@@QEAAXXZ		; ImDrawList::PopTextureID
PUBLIC	?PushTextureID@ImDrawList@@QEAAXPEAX@Z		; ImDrawList::PushTextureID
PUBLIC	?PopClipRect@ImDrawList@@QEAAXXZ		; ImDrawList::PopClipRect
PUBLIC	?PushClipRect@ImDrawList@@QEAAXAEBUImVec2@@0_N@Z ; ImDrawList::PushClipRect
PUBLIC	?SetCircleTessellationMaxError@ImDrawListSharedData@@QEAAXM@Z ; ImDrawListSharedData::SetCircleTessellationMaxError
PUBLIC	??0ImDrawListSharedData@@QEAA@XZ		; ImDrawListSharedData::ImDrawListSharedData
PUBLIC	?GetMouseCursorTexData@ImFontAtlas@@QEAA_NHPEAUImVec2@@0QEAU2@1@Z ; ImFontAtlas::GetMouseCursorTexData
PUBLIC	??1ImFontAtlas@@QEAA@XZ				; ImFontAtlas::~ImFontAtlas
PUBLIC	??0ImFontAtlas@@QEAA@XZ				; ImFontAtlas::ImFontAtlas
PUBLIC	?Clear@ImDrawData@@QEAAXXZ			; ImDrawData::Clear
PUBLIC	?ImBezierCubicCalc@@YA?AUImVec2@@AEBU1@000M@Z	; ImBezierCubicCalc
PUBLIC	?CalcRoundingFlagsForRectInRect@ImGui@@YAHAEBUImRect@@0M@Z ; ImGui::CalcRoundingFlagsForRectInRect
PUBLIC	?RenderRectFilledWithHole@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@1IM@Z ; ImGui::RenderRectFilledWithHole
PUBLIC	?AddDrawListToDrawDataEx@ImGui@@YAXPEAUImDrawData@@PEAU?$ImVector@PEAUImDrawList@@@@PEAUImDrawList@@@Z ; ImGui::AddDrawListToDrawDataEx
PUBLIC	?StyleColorsDark@ImGui@@YAXPEAUImGuiStyle@@@Z	; ImGui::StyleColorsDark
PUBLIC	?RenderBullet@ImGui@@YAXPEAUImDrawList@@UImVec2@@I@Z ; ImGui::RenderBullet
PUBLIC	?PathBezierCubicCurveTo@ImDrawList@@QEAAXAEBUImVec2@@00H@Z ; ImDrawList::PathBezierCubicCurveTo
PUBLIC	?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z ; ImDrawList::AddConvexPolyFilled
PUBLIC	?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z ; ImDrawList::AddPolyline
PUBLIC	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
PUBLIC	?AddCircle@ImDrawList@@QEAAXAEBUImVec2@@MIHM@Z	; ImDrawList::AddCircle
PUBLIC	?AddTriangleFilled@ImDrawList@@QEAAXAEBUImVec2@@00I@Z ; ImDrawList::AddTriangleFilled
PUBLIC	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
PUBLIC	?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z	; ImDrawList::AddRect
?stb__barrier_in_b@@3PEBEEB DQ 01H DUP (?)		; stb__barrier_in_b
_BSS	ENDS
;	COMDAT ?io@?1??ImFontAtlasGetBuilderForStbTruetype@@YAPEBUImFontBuilderIO@@XZ@4U2@A
_BSS	SEGMENT
?io@?1??ImFontAtlasGetBuilderForStbTruetype@@YAPEBUImFontBuilderIO@@XZ@4U2@A DQ 01H DUP (?) ; `ImFontAtlasGetBuilderForStbTruetype'::`2'::io
?stb__barrier_out_e@@3PEAEEA DQ 01H DUP (?)		; stb__barrier_out_e
?stb__barrier_out_b@@3PEAEEA DQ 01H DUP (?)		; stb__barrier_out_b
?stb__dout@@3PEAEEA DQ 01H DUP (?)			; stb__dout
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GImFont@@QEAAPEAXI@Z DD imagerel $LN6
	DD	imagerel $LN6+23
	DD	imagerel $unwind$??_GImFont@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$IM_DELETE@UImFont@@@@YAXPEAUImFont@@@Z DD imagerel $LN20
	DD	imagerel $LN20+51
	DD	imagerel $unwind$??$IM_DELETE@UImFont@@@@YAXPEAUImFont@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z DD imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z DD imagerel $LN26+28
	DD	imagerel $LN26+129
	DD	imagerel $chain$0$?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z DD imagerel $LN26+129
	DD	imagerel $LN26+140
	DD	imagerel $chain$1$?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@PEAX@@QEAAXH@Z DD imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@PEAX@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?reserve@?$ImVector@PEAX@@QEAAXH@Z DD imagerel $LN26+28
	DD	imagerel $LN26+129
	DD	imagerel $chain$0$?reserve@?$ImVector@PEAX@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?reserve@?$ImVector@PEAX@@QEAAXH@Z DD imagerel $LN26+129
	DD	imagerel $LN26+140
	DD	imagerel $chain$1$?reserve@?$ImVector@PEAX@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXH@Z DD imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?reserve@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXH@Z DD imagerel $LN26+28
	DD	imagerel $LN26+129
	DD	imagerel $chain$0$?reserve@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?reserve@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXH@Z DD imagerel $LN26+129
	DD	imagerel $LN26+140
	DD	imagerel $chain$1$?reserve@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImFontConfig@@@@QEAAXH@Z DD imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImFontConfig@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?reserve@?$ImVector@UImFontConfig@@@@QEAAXH@Z DD imagerel $LN26+28
	DD	imagerel $LN26+132
	DD	imagerel $chain$0$?reserve@?$ImVector@UImFontConfig@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?reserve@?$ImVector@UImFontConfig@@@@QEAAXH@Z DD imagerel $LN26+132
	DD	imagerel $LN26+143
	DD	imagerel $chain$1$?reserve@?$ImVector@UImFontConfig@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImFontGlyph@@@@QEAAXH@Z DD imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImFontGlyph@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?reserve@?$ImVector@UImFontGlyph@@@@QEAAXH@Z DD imagerel $LN26+28
	DD	imagerel $LN26+134
	DD	imagerel $chain$0$?reserve@?$ImVector@UImFontGlyph@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?reserve@?$ImVector@UImFontGlyph@@@@QEAAXH@Z DD imagerel $LN26+134
	DD	imagerel $LN26+145
	DD	imagerel $chain$1$?reserve@?$ImVector@UImFontGlyph@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@UImFontBuildSrcData@@@@QEAAXXZ DD imagerel $LN15
	DD	imagerel $LN15+63
	DD	imagerel $unwind$?clear@?$ImVector@UImFontBuildSrcData@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z DD imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?reserve@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z DD imagerel $LN26+28
	DD	imagerel $LN26+132
	DD	imagerel $chain$0$?reserve@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?reserve@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z DD imagerel $LN26+132
	DD	imagerel $LN26+143
	DD	imagerel $chain$1$?reserve@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z DD imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?reserve@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z DD imagerel $LN26+28
	DD	imagerel $LN26+129
	DD	imagerel $chain$0$?reserve@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?reserve@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z DD imagerel $LN26+129
	DD	imagerel $LN26+140
	DD	imagerel $chain$1$?reserve@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z DD imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?reserve@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z DD imagerel $LN26+28
	DD	imagerel $LN26+134
	DD	imagerel $chain$0$?reserve@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?reserve@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z DD imagerel $LN26+134
	DD	imagerel $LN26+145
	DD	imagerel $chain$1$?reserve@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z DD imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?reserve@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z DD imagerel $LN26+28
	DD	imagerel $LN26+126
	DD	imagerel $chain$0$?reserve@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?reserve@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z DD imagerel $LN26+126
	DD	imagerel $LN26+137
	DD	imagerel $chain$1$?reserve@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ImBitVector@@QEAA@XZ DD imagerel $LN18
	DD	imagerel $LN18+43
	DD	imagerel $unwind$??1ImBitVector@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ImFontBuildSrcData@@QEAA@XZ DD imagerel $LN33
	DD	imagerel $LN33+89
	DD	imagerel $unwind$??1ImFontBuildSrcData@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GImFontBuildSrcData@@QEAAPEAXI@Z DD imagerel $LN37
	DD	imagerel $LN37+92
	DD	imagerel $unwind$??_GImFontBuildSrcData@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@G@@QEAAXHAEBG@Z DD imagerel $LN24
	DD	imagerel $LN24+118
	DD	imagerel $unwind$?resize@?$ImVector@G@@QEAAXHAEBG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@UImDrawCmd@@@@QEAAXXZ DD imagerel $LN15
	DD	imagerel $LN15+63
	DD	imagerel $unwind$?clear@?$ImVector@UImDrawCmd@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@UImDrawCmd@@@@QEAAXH@Z DD imagerel $LN12
	DD	imagerel $LN12+70
	DD	imagerel $unwind$?resize@?$ImVector@UImDrawCmd@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?erase@?$ImVector@UImDrawCmd@@@@QEAAPEAUImDrawCmd@@PEBU2@@Z DD imagerel $LN4
	DD	imagerel $LN4+98
	DD	imagerel $unwind$?erase@?$ImVector@UImDrawCmd@@@@QEAAPEAUImDrawCmd@@PEBU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@UImDrawChannel@@@@QEAAXH@Z DD imagerel $LN12
	DD	imagerel $LN12+70
	DD	imagerel $unwind$?resize@?$ImVector@UImDrawChannel@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImDrawChannel@@@@QEAAXH@Z DD imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImDrawChannel@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?reserve@?$ImVector@UImDrawChannel@@@@QEAAXH@Z DD imagerel $LN26+28
	DD	imagerel $LN26+129
	DD	imagerel $chain$0$?reserve@?$ImVector@UImDrawChannel@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?reserve@?$ImVector@UImDrawChannel@@@@QEAAXH@Z DD imagerel $LN26+129
	DD	imagerel $LN26+140
	DD	imagerel $chain$1$?reserve@?$ImVector@UImDrawChannel@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@UImDrawVert@@@@QEAAXXZ DD imagerel $LN15
	DD	imagerel $LN15+63
	DD	imagerel $unwind$?clear@?$ImVector@UImDrawVert@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@UImDrawVert@@@@QEAAXH@Z DD imagerel $LN12
	DD	imagerel $LN12+70
	DD	imagerel $unwind$?resize@?$ImVector@UImDrawVert@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@UImVec4@@@@QEAAXXZ DD imagerel $LN15
	DD	imagerel $LN15+63
	DD	imagerel $unwind$?clear@?$ImVector@UImVec4@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@UImVec4@@@@QEAAXH@Z DD imagerel $LN11
	DD	imagerel $LN11+52
	DD	imagerel $unwind$?resize@?$ImVector@UImVec4@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$ImVector@UImVec4@@@@QEAAXAEBUImVec4@@@Z DD imagerel $LN11
	DD	imagerel $LN11+98
	DD	imagerel $unwind$?push_back@?$ImVector@UImVec4@@@@QEAAXAEBUImVec4@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@PEAX@@QEAAXXZ DD imagerel $LN15
	DD	imagerel $LN15+63
	DD	imagerel $unwind$?clear@?$ImVector@PEAX@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@PEAX@@QEAAXH@Z DD imagerel $LN11
	DD	imagerel $LN11+52
	DD	imagerel $unwind$?resize@?$ImVector@PEAX@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$ImVector@PEAX@@QEAAXAEBQEAX@Z DD imagerel $LN11
	DD	imagerel $LN11+95
	DD	imagerel $unwind$?push_back@?$ImVector@PEAX@@QEAAXAEBQEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve_discard@?$ImVector@UImVec2@@@@QEAAXH@Z DD imagerel $LN25
	DD	imagerel $LN25+103
	DD	imagerel $unwind$?reserve_discard@?$ImVector@UImVec2@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$ImVector@PEAUImDrawList@@@@QEAAXAEBQEAUImDrawList@@@Z DD imagerel $LN11
	DD	imagerel $LN11+95
	DD	imagerel $unwind$?push_back@?$ImVector@PEAUImDrawList@@@@QEAAXAEBQEAUImDrawList@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear_delete@?$ImVector@PEAUImFont@@@@QEAAXXZ DD imagerel $LN43
	DD	imagerel $LN43+11
	DD	imagerel $unwind$?clear_delete@?$ImVector@PEAUImFont@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?clear_delete@?$ImVector@PEAUImFont@@@@QEAAXXZ DD imagerel $LN43+11
	DD	imagerel $LN43+25
	DD	imagerel $chain$0$?clear_delete@?$ImVector@PEAUImFont@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?clear_delete@?$ImVector@PEAUImFont@@@@QEAAXXZ DD imagerel $LN43+25
	DD	imagerel $LN43+117
	DD	imagerel $chain$2$?clear_delete@?$ImVector@PEAUImFont@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?clear_delete@?$ImVector@PEAUImFont@@@@QEAAXXZ DD imagerel $LN43+117
	DD	imagerel $LN43+131
	DD	imagerel $chain$3$?clear_delete@?$ImVector@PEAUImFont@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?clear_delete@?$ImVector@PEAUImFont@@@@QEAAXXZ DD imagerel $LN43+131
	DD	imagerel $LN43+182
	DD	imagerel $chain$4$?clear_delete@?$ImVector@PEAUImFont@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@UImFontAtlasCustomRect@@@@QEAA@XZ DD imagerel $LN14
	DD	imagerel $LN14+35
	DD	imagerel $unwind$??1?$ImVector@UImFontAtlasCustomRect@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXXZ DD imagerel $LN15
	DD	imagerel $LN15+63
	DD	imagerel $unwind$?clear@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXAEBUImFontAtlasCustomRect@@@Z DD imagerel $LN35
	DD	imagerel $LN35+72
	DD	imagerel $unwind$?push_back@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXAEBUImFontAtlasCustomRect@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?push_back@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXAEBUImFontAtlasCustomRect@@@Z DD imagerel $LN35+72
	DD	imagerel $LN35+173
	DD	imagerel $chain$0$?push_back@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXAEBUImFontAtlasCustomRect@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?push_back@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXAEBUImFontAtlasCustomRect@@@Z DD imagerel $LN35+173
	DD	imagerel $LN35+219
	DD	imagerel $chain$1$?push_back@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXAEBUImFontAtlasCustomRect@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@UImFontConfig@@@@QEAA@XZ DD imagerel $LN14
	DD	imagerel $LN14+35
	DD	imagerel $unwind$??1?$ImVector@UImFontConfig@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@UImFontConfig@@@@QEAAXXZ DD imagerel $LN15
	DD	imagerel $LN15+63
	DD	imagerel $unwind$?clear@?$ImVector@UImFontConfig@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$ImVector@UImFontConfig@@@@QEAAXAEBUImFontConfig@@@Z DD imagerel $LN35
	DD	imagerel $LN35+72
	DD	imagerel $unwind$?push_back@?$ImVector@UImFontConfig@@@@QEAAXAEBUImFontConfig@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?push_back@?$ImVector@UImFontConfig@@@@QEAAXAEBUImFontConfig@@@Z DD imagerel $LN35+72
	DD	imagerel $LN35+179
	DD	imagerel $chain$0$?push_back@?$ImVector@UImFontConfig@@@@QEAAXAEBUImFontConfig@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?push_back@?$ImVector@UImFontConfig@@@@QEAAXAEBUImFontConfig@@@Z DD imagerel $LN35+179
	DD	imagerel $LN35+298
	DD	imagerel $chain$1$?push_back@?$ImVector@UImFontConfig@@@@QEAAXAEBUImFontConfig@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@M@@QEAAXHAEBM@Z DD imagerel $LN24
	DD	imagerel $LN24+116
	DD	imagerel $unwind$?resize@?$ImVector@M@@QEAAXHAEBM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@UImFontGlyph@@@@QEAA@XZ DD imagerel $LN14
	DD	imagerel $LN14+35
	DD	imagerel $unwind$??1?$ImVector@UImFontGlyph@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@UImFontGlyph@@@@QEAAXXZ DD imagerel $LN15
	DD	imagerel $LN15+63
	DD	imagerel $unwind$?clear@?$ImVector@UImFontGlyph@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z DD imagerel $LN38
	DD	imagerel $LN38+26
	DD	imagerel $unwind$?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z DD imagerel $LN38+26
	DD	imagerel $LN38+200
	DD	imagerel $chain$1$?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z DD imagerel $LN38+200
	DD	imagerel $LN38+218
	DD	imagerel $chain$3$?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z DD imagerel $LN38+218
	DD	imagerel $LN38+231
	DD	imagerel $chain$4$?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ DD imagerel $LN14
	DD	imagerel $LN14+35
	DD	imagerel $unwind$??1?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear_destruct@?$ImVector@UImFontBuildSrcData@@@@QEAAXXZ DD imagerel $LN57
	DD	imagerel $LN57+217
	DD	imagerel $unwind$?clear_destruct@?$ImVector@UImFontBuildSrcData@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z DD imagerel $LN38
	DD	imagerel $LN38+26
	DD	imagerel $unwind$?resize@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?resize@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z DD imagerel $LN38+26
	DD	imagerel $LN38+198
	DD	imagerel $chain$1$?resize@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?resize@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z DD imagerel $LN38+198
	DD	imagerel $LN38+216
	DD	imagerel $chain$3$?resize@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?resize@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z DD imagerel $LN38+216
	DD	imagerel $LN38+229
	DD	imagerel $chain$4$?resize@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@UImFontBuildDstData@@@@QEAA@XZ DD imagerel $LN14
	DD	imagerel $LN14+35
	DD	imagerel $unwind$??1?$ImVector@UImFontBuildDstData@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@UImFontBuildDstData@@@@QEAAXXZ DD imagerel $LN15
	DD	imagerel $LN15+63
	DD	imagerel $unwind$?clear@?$ImVector@UImFontBuildDstData@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z DD imagerel $LN38
	DD	imagerel $LN38+26
	DD	imagerel $unwind$?resize@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?resize@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z DD imagerel $LN38+26
	DD	imagerel $LN38+188
	DD	imagerel $chain$1$?resize@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?resize@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z DD imagerel $LN38+188
	DD	imagerel $LN38+206
	DD	imagerel $chain$3$?resize@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?resize@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z DD imagerel $LN38+206
	DD	imagerel $LN38+219
	DD	imagerel $chain$4$?resize@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@Ustbrp_rect@@@@QEAA@XZ DD imagerel $LN14
	DD	imagerel $LN14+35
	DD	imagerel $unwind$??1?$ImVector@Ustbrp_rect@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@Ustbrp_rect@@@@QEAAXXZ DD imagerel $LN15
	DD	imagerel $LN15+63
	DD	imagerel $unwind$?clear@?$ImVector@Ustbrp_rect@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z DD imagerel $LN38
	DD	imagerel $LN38+26
	DD	imagerel $unwind$?resize@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?resize@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z DD imagerel $LN38+26
	DD	imagerel $LN38+200
	DD	imagerel $chain$1$?resize@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?resize@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z DD imagerel $LN38+200
	DD	imagerel $LN38+218
	DD	imagerel $chain$3$?resize@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?resize@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z DD imagerel $LN38+218
	DD	imagerel $LN38+231
	DD	imagerel $chain$4$?resize@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ DD imagerel $LN14
	DD	imagerel $LN14+35
	DD	imagerel $unwind$??1?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z DD imagerel $LN38
	DD	imagerel $LN38+26
	DD	imagerel $unwind$?resize@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?resize@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z DD imagerel $LN38+26
	DD	imagerel $LN38+188
	DD	imagerel $chain$1$?resize@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?resize@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z DD imagerel $LN38+188
	DD	imagerel $LN38+206
	DD	imagerel $chain$3$?resize@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?resize@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z DD imagerel $LN38+206
	DD	imagerel $LN38+219
	DD	imagerel $chain$4$?resize@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stb_decompress@@YAIPEAEPEBEI@Z DD imagerel ?stb_decompress@@YAIPEAEPEBEI@Z
	DD	imagerel ?stb_decompress@@YAIPEAEPEBEI@Z+335
	DD	imagerel $unwind$?stb_decompress@@YAIPEAEPEBEI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stb_adler32@@YAIIPEAEI@Z DD imagerel ?stb_adler32@@YAIIPEAEI@Z
	DD	imagerel ?stb_adler32@@YAIIPEAEI@Z+51
	DD	imagerel $unwind$?stb_adler32@@YAIIPEAEI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?stb_adler32@@YAIIPEAEI@Z DD imagerel ?stb_adler32@@YAIIPEAEI@Z+51
	DD	imagerel ?stb_adler32@@YAIIPEAEI@Z+316
	DD	imagerel $chain$0$?stb_adler32@@YAIIPEAEI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?stb_adler32@@YAIIPEAEI@Z DD imagerel ?stb_adler32@@YAIIPEAEI@Z+316
	DD	imagerel ?stb_adler32@@YAIIPEAEI@Z+331
	DD	imagerel $chain$1$?stb_adler32@@YAIIPEAEI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stb_decompress_token@@YAPEBEPEBE@Z DD imagerel ?stb_decompress_token@@YAPEBEPEBE@Z
	DD	imagerel ?stb_decompress_token@@YAPEBEPEBE@Z+583
	DD	imagerel $unwind$?stb_decompress_token@@YAPEBEPEBE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stb__lit@@YAXPEBEI@Z DD imagerel ?stb__lit@@YAXPEBEI@Z
	DD	imagerel ?stb__lit@@YAXPEBEI@Z+81
	DD	imagerel $unwind$?stb__lit@@YAXPEBEI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?RenderColorRectWithAlphaCheckerboard@ImGui@@YAXPEAUImDrawList@@UImVec2@@1IM1MH@Z DD imagerel $LN82
	DD	imagerel $LN82+70
	DD	imagerel $unwind$?RenderColorRectWithAlphaCheckerboard@ImGui@@YAXPEAUImDrawList@@UImVec2@@1IM1MH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?RenderColorRectWithAlphaCheckerboard@ImGui@@YAXPEAUImDrawList@@UImVec2@@1IM1MH@Z DD imagerel $LN82+70
	DD	imagerel $LN82+319
	DD	imagerel $chain$3$?RenderColorRectWithAlphaCheckerboard@ImGui@@YAXPEAUImDrawList@@UImVec2@@1IM1MH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$11$?RenderColorRectWithAlphaCheckerboard@ImGui@@YAXPEAUImDrawList@@UImVec2@@1IM1MH@Z DD imagerel $LN82+319
	DD	imagerel $LN82+803
	DD	imagerel $chain$11$?RenderColorRectWithAlphaCheckerboard@ImGui@@YAXPEAUImDrawList@@UImVec2@@1IM1MH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$12$?RenderColorRectWithAlphaCheckerboard@ImGui@@YAXPEAUImDrawList@@UImVec2@@1IM1MH@Z DD imagerel $LN82+803
	DD	imagerel $LN82+846
	DD	imagerel $chain$12$?RenderColorRectWithAlphaCheckerboard@ImGui@@YAXPEAUImDrawList@@UImVec2@@1IM1MH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$13$?RenderColorRectWithAlphaCheckerboard@ImGui@@YAXPEAUImDrawList@@UImVec2@@1IM1MH@Z DD imagerel $LN82+846
	DD	imagerel $LN82+891
	DD	imagerel $chain$13$?RenderColorRectWithAlphaCheckerboard@ImGui@@YAXPEAUImDrawList@@UImVec2@@1IM1MH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?RenderArrowDockMenu@ImGui@@YAXPEAUImDrawList@@UImVec2@@MI@Z DD imagerel $LN167
	DD	imagerel $LN167+18
	DD	imagerel $unwind$?RenderArrowDockMenu@ImGui@@YAXPEAUImDrawList@@UImVec2@@MI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?RenderArrowDockMenu@ImGui@@YAXPEAUImDrawList@@UImVec2@@MI@Z DD imagerel $LN167+18
	DD	imagerel $LN167+279
	DD	imagerel $chain$1$?RenderArrowDockMenu@ImGui@@YAXPEAUImDrawList@@UImVec2@@MI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?RenderArrowDockMenu@ImGui@@YAXPEAUImDrawList@@UImVec2@@MI@Z DD imagerel $LN167+279
	DD	imagerel $LN167+286
	DD	imagerel $chain$2$?RenderArrowDockMenu@ImGui@@YAXPEAUImDrawList@@UImVec2@@MI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?RenderArrowDockMenu@ImGui@@YAXPEAUImDrawList@@UImVec2@@MI@Z DD imagerel $LN167+286
	DD	imagerel $LN167+560
	DD	imagerel $chain$4$?RenderArrowDockMenu@ImGui@@YAXPEAUImDrawList@@UImVec2@@MI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?RenderArrowDockMenu@ImGui@@YAXPEAUImDrawList@@UImVec2@@MI@Z DD imagerel $LN167+560
	DD	imagerel $LN167+567
	DD	imagerel $chain$5$?RenderArrowDockMenu@ImGui@@YAXPEAUImDrawList@@UImVec2@@MI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?RenderArrowPointingAt@ImGui@@YAXPEAUImDrawList@@UImVec2@@1HI@Z DD imagerel $LN169
	DD	imagerel $LN169+911
	DD	imagerel $unwind$?RenderArrowPointingAt@ImGui@@YAXPEAUImDrawList@@UImVec2@@1HI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?RenderCheckMark@ImGui@@YAXPEAUImDrawList@@UImVec2@@IM@Z DD imagerel $LN53
	DD	imagerel $LN53+512
	DD	imagerel $unwind$?RenderCheckMark@ImGui@@YAXPEAUImDrawList@@UImVec2@@IM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?RenderArrow@ImGui@@YAXPEAUImDrawList@@UImVec2@@IHM@Z DD imagerel $LN87
	DD	imagerel $LN87+487
	DD	imagerel $unwind$?RenderArrow@ImGui@@YAXPEAUImDrawList@@UImVec2@@IHM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IAEBUImVec4@@PEBD3M_N@Z DD imagerel $LN147
	DD	imagerel $LN147+140
	DD	imagerel $unwind$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IAEBUImVec4@@PEBD3M_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IAEBUImVec4@@PEBD3M_N@Z DD imagerel $LN147+140
	DD	imagerel $LN147+535
	DD	imagerel $chain$3$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IAEBUImVec4@@PEBD3M_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IAEBUImVec4@@PEBD3M_N@Z DD imagerel $LN147+535
	DD	imagerel $LN147+627
	DD	imagerel $chain$5$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IAEBUImVec4@@PEBD3M_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IAEBUImVec4@@PEBD3M_N@Z DD imagerel $LN147+627
	DD	imagerel $LN147+1567
	DD	imagerel $chain$9$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IAEBUImVec4@@PEBD3M_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IAEBUImVec4@@PEBD3M_N@Z DD imagerel $LN147+1567
	DD	imagerel $LN147+1657
	DD	imagerel $chain$10$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IAEBUImVec4@@PEBD3M_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$11$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IAEBUImVec4@@PEBD3M_N@Z DD imagerel $LN147+1657
	DD	imagerel $LN147+1690
	DD	imagerel $chain$11$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IAEBUImVec4@@PEBD3M_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$12$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IAEBUImVec4@@PEBD3M_N@Z DD imagerel $LN147+1690
	DD	imagerel $LN147+1725
	DD	imagerel $chain$12$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IAEBUImVec4@@PEBD3M_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z DD imagerel $LN55
	DD	imagerel $LN55+70
	DD	imagerel $unwind$?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z DD imagerel $LN55+70
	DD	imagerel $LN55+365
	DD	imagerel $chain$0$?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z DD imagerel $LN55+365
	DD	imagerel $LN55+391
	DD	imagerel $chain$1$?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AddGlyph@ImFont@@QEAAXPEBUImFontConfig@@GMMMMMMMMM@Z DD imagerel $LN35
	DD	imagerel $LN35+522
	DD	imagerel $unwind$?AddGlyph@ImFont@@QEAAXPEBUImFontConfig@@GMMMMMMMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GrowIndex@ImFont@@QEAAXH@Z DD imagerel $LN44
	DD	imagerel $LN44+27
	DD	imagerel $unwind$?GrowIndex@ImFont@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?GrowIndex@ImFont@@QEAAXH@Z DD imagerel $LN44+27
	DD	imagerel $LN44+179
	DD	imagerel $chain$1$?GrowIndex@ImFont@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?GrowIndex@ImFont@@QEAAXH@Z DD imagerel $LN44+179
	DD	imagerel $LN44+218
	DD	imagerel $chain$2$?GrowIndex@ImFont@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?GrowIndex@ImFont@@QEAAXH@Z DD imagerel $LN44+218
	DD	imagerel $LN44+227
	DD	imagerel $chain$3$?GrowIndex@ImFont@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?BuildLookupTable@ImFont@@QEAAXXZ DD imagerel $LN264
	DD	imagerel $LN264+1372
	DD	imagerel $unwind$?BuildLookupTable@ImFont@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FindFirstExistingGlyph@@YAGPEAUImFont@@PEBGH@Z DD imagerel ?FindFirstExistingGlyph@@YAGPEAUImFont@@PEBGH@Z
	DD	imagerel ?FindFirstExistingGlyph@@YAGPEAUImFont@@PEBGH@Z+113
	DD	imagerel $unwind$?FindFirstExistingGlyph@@YAGPEAUImFont@@PEBGH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ClearOutputData@ImFont@@QEAAXXZ DD imagerel $LN43
	DD	imagerel $LN43+171
	DD	imagerel $unwind$?ClearOutputData@ImFont@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z DD imagerel $LN44
	DD	imagerel $LN44+18
	DD	imagerel $unwind$?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z DD imagerel $LN44+18
	DD	imagerel $LN44+55
	DD	imagerel $chain$0$?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z DD imagerel $LN44+55
	DD	imagerel $LN44+345
	DD	imagerel $chain$4$?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z DD imagerel $LN44+345
	DD	imagerel $LN44+358
	DD	imagerel $chain$5$?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z DD imagerel $LN44+358
	DD	imagerel $LN44+423
	DD	imagerel $chain$6$?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImFontAtlasBuildInit@@YAXPEAUImFontAtlas@@@Z DD imagerel $LN38
	DD	imagerel $LN38+192
	DD	imagerel $unwind$?ImFontAtlasBuildInit@@YAXPEAUImFontAtlas@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z DD imagerel ?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z
	DD	imagerel ?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z+21
	DD	imagerel $unwind$?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z DD imagerel ?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z+21
	DD	imagerel ?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z+415
	DD	imagerel $chain$7$?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z DD imagerel ?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z+415
	DD	imagerel ?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z+422
	DD	imagerel $chain$8$?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z DD imagerel ?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z+422
	DD	imagerel ?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z+522
	DD	imagerel $chain$9$?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImFontAtlasBuildRenderDefaultTexData@@YAXPEAUImFontAtlas@@@Z DD imagerel ?ImFontAtlasBuildRenderDefaultTexData@@YAXPEAUImFontAtlas@@@Z
	DD	imagerel ?ImFontAtlasBuildRenderDefaultTexData@@YAXPEAUImFontAtlas@@@Z+313
	DD	imagerel $unwind$?ImFontAtlasBuildRenderDefaultTexData@@YAXPEAUImFontAtlas@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImFontAtlasBuildRender32bppRectFromString@@YAXPEAUImFontAtlas@@HHHHPEBDDI@Z DD imagerel $LN84
	DD	imagerel $LN84+941
	DD	imagerel $unwind$?ImFontAtlasBuildRender32bppRectFromString@@YAXPEAUImFontAtlas@@HHHHPEBDDI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImFontAtlasBuildRender8bppRectFromString@@YAXPEAUImFontAtlas@@HHHHPEBDDE@Z DD imagerel $LN29
	DD	imagerel $LN29+155
	DD	imagerel $unwind$?ImFontAtlasBuildRender8bppRectFromString@@YAXPEAUImFontAtlas@@HHHHPEBDDE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z DD imagerel $LN91
	DD	imagerel $LN91+347
	DD	imagerel $unwind$?ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImFontAtlasBuildSetupFont@@YAXPEAUImFontAtlas@@PEAUImFont@@PEAUImFontConfig@@MM@Z DD imagerel $LN8
	DD	imagerel $LN8+114
	DD	imagerel $unwind$?ImFontAtlasBuildSetupFont@@YAXPEAUImFontAtlas@@PEAUImFont@@PEAUImFontConfig@@MM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z DD imagerel ?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z
	DD	imagerel ?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z+5065
	DD	imagerel $unwind$?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?UnpackBitVectorToFlatIndexList@@YAXPEBUImBitVector@@PEAU?$ImVector@H@@@Z DD imagerel ?UnpackBitVectorToFlatIndexList@@YAXPEBUImBitVector@@PEAU?$ImVector@H@@@Z
	DD	imagerel ?UnpackBitVectorToFlatIndexList@@YAXPEBUImBitVector@@PEAU?$ImVector@H@@@Z+38
	DD	imagerel $unwind$?UnpackBitVectorToFlatIndexList@@YAXPEBUImBitVector@@PEAU?$ImVector@H@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?UnpackBitVectorToFlatIndexList@@YAXPEBUImBitVector@@PEAU?$ImVector@H@@@Z DD imagerel ?UnpackBitVectorToFlatIndexList@@YAXPEBUImBitVector@@PEAU?$ImVector@H@@@Z+38
	DD	imagerel ?UnpackBitVectorToFlatIndexList@@YAXPEBUImBitVector@@PEAU?$ImVector@H@@@Z+210
	DD	imagerel $chain$3$?UnpackBitVectorToFlatIndexList@@YAXPEBUImBitVector@@PEAU?$ImVector@H@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?UnpackBitVectorToFlatIndexList@@YAXPEBUImBitVector@@PEAU?$ImVector@H@@@Z DD imagerel ?UnpackBitVectorToFlatIndexList@@YAXPEBUImBitVector@@PEAU?$ImVector@H@@@Z+210
	DD	imagerel ?UnpackBitVectorToFlatIndexList@@YAXPEBUImBitVector@@PEAU?$ImVector@H@@@Z+222
	DD	imagerel $chain$4$?UnpackBitVectorToFlatIndexList@@YAXPEBUImBitVector@@PEAU?$ImVector@H@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImFontAtlasBuildMultiplyRectAlpha8@@YAXQEBEPEAEHHHHH@Z DD imagerel $LN20
	DD	imagerel $LN20+45
	DD	imagerel $unwind$?ImFontAtlasBuildMultiplyRectAlpha8@@YAXQEBEPEAEHHHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?ImFontAtlasBuildMultiplyRectAlpha8@@YAXQEBEPEAEHHHHH@Z DD imagerel $LN20+45
	DD	imagerel $LN20+100
	DD	imagerel $chain$0$?ImFontAtlasBuildMultiplyRectAlpha8@@YAXQEBEPEAEHHHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?ImFontAtlasBuildMultiplyRectAlpha8@@YAXQEBEPEAEHHHHH@Z DD imagerel $LN20+100
	DD	imagerel $LN20+105
	DD	imagerel $chain$1$?ImFontAtlasBuildMultiplyRectAlpha8@@YAXQEBEPEAEHHHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Build@ImFontAtlas@@QEAA_NXZ DD imagerel $LN27
	DD	imagerel $LN27+415
	DD	imagerel $unwind$?Build@ImFontAtlas@@QEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AddCustomRectRegular@ImFontAtlas@@QEAAHHH@Z DD imagerel $LN10
	DD	imagerel $LN10+69
	DD	imagerel $unwind$?AddCustomRectRegular@ImFontAtlas@@QEAAHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AddFontFromMemoryCompressedBase85TTF@ImFontAtlas@@QEAAPEAUImFont@@PEBDMPEBUImFontConfig@@PEBG@Z DD imagerel $LN53
	DD	imagerel $LN53+398
	DD	imagerel $unwind$?AddFontFromMemoryCompressedBase85TTF@ImFontAtlas@@QEAAPEAUImFont@@PEBDMPEBUImFontConfig@@PEBG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z DD imagerel $LN64
	DD	imagerel $LN64+28
	DD	imagerel $unwind$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z DD imagerel $LN64+28
	DD	imagerel $LN64+214
	DD	imagerel $chain$5$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z DD imagerel $LN64+214
	DD	imagerel $LN64+325
	DD	imagerel $chain$6$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z DD imagerel $LN64+325
	DD	imagerel $LN64+345
	DD	imagerel $chain$7$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z DD imagerel $LN64+345
	DD	imagerel $LN64+681
	DD	imagerel $chain$8$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z DD imagerel $LN64+681
	DD	imagerel $LN64+745
	DD	imagerel $chain$9$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AddFontFromMemoryTTF@ImFontAtlas@@QEAAPEAUImFont@@PEAXHMPEBUImFontConfig@@PEBG@Z DD imagerel $LN16
	DD	imagerel $LN16+346
	DD	imagerel $unwind$?AddFontFromMemoryTTF@ImFontAtlas@@QEAAPEAUImFont@@PEAXHMPEBUImFontConfig@@PEBG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AddFontDefault@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z DD imagerel $LN19
	DD	imagerel $LN19+364
	DD	imagerel $unwind$?AddFontDefault@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Decode85@@YAXPEBEPEAE@Z DD imagerel ?Decode85@@YAXPEBEPEAE@Z
	DD	imagerel ?Decode85@@YAXPEBEPEAE@Z+198
	DD	imagerel $unwind$?Decode85@@YAXPEBEPEAE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z DD imagerel $LN80
	DD	imagerel $LN80+15
	DD	imagerel $unwind$?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z DD imagerel $LN80+15
	DD	imagerel $LN80+232
	DD	imagerel $chain$1$?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z DD imagerel $LN80+232
	DD	imagerel $LN80+349
	DD	imagerel $chain$2$?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z DD imagerel $LN80+349
	DD	imagerel $LN80+519
	DD	imagerel $chain$3$?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z DD imagerel $LN80+519
	DD	imagerel $LN80+588
	DD	imagerel $chain$4$?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z DD imagerel $LN80+588
	DD	imagerel $LN80+623
	DD	imagerel $chain$5$?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z DD imagerel $LN62
	DD	imagerel $LN62+40
	DD	imagerel $unwind$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z DD imagerel $LN62+40
	DD	imagerel $LN62+47
	DD	imagerel $chain$0$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z DD imagerel $LN62+47
	DD	imagerel $LN62+68
	DD	imagerel $chain$1$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z DD imagerel $LN62+68
	DD	imagerel $LN62+533
	DD	imagerel $chain$2$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z DD imagerel $LN62+533
	DD	imagerel $LN62+553
	DD	imagerel $chain$3$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z DD imagerel $LN62+553
	DD	imagerel $LN62+572
	DD	imagerel $chain$4$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z DD imagerel $LN62+572
	DD	imagerel $LN62+600
	DD	imagerel $chain$5$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetTexDataAsAlpha8@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z DD imagerel $LN35
	DD	imagerel $LN35+451
	DD	imagerel $unwind$?GetTexDataAsAlpha8@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Clear@ImFontAtlas@@QEAAXXZ DD imagerel $LN48
	DD	imagerel $LN48+11
	DD	imagerel $unwind$?Clear@ImFontAtlas@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?Clear@ImFontAtlas@@QEAAXXZ DD imagerel $LN48+11
	DD	imagerel $LN48+39
	DD	imagerel $chain$0$?Clear@ImFontAtlas@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?Clear@ImFontAtlas@@QEAAXXZ DD imagerel $LN48+39
	DD	imagerel $LN48+133
	DD	imagerel $chain$2$?Clear@ImFontAtlas@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?Clear@ImFontAtlas@@QEAAXXZ DD imagerel $LN48+133
	DD	imagerel $LN48+147
	DD	imagerel $chain$3$?Clear@ImFontAtlas@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?Clear@ImFontAtlas@@QEAAXXZ DD imagerel $LN48+147
	DD	imagerel $LN48+203
	DD	imagerel $chain$4$?Clear@ImFontAtlas@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ClearFonts@ImFontAtlas@@QEAAXXZ DD imagerel $LN46
	DD	imagerel $LN46+11
	DD	imagerel $unwind$?ClearFonts@ImFontAtlas@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?ClearFonts@ImFontAtlas@@QEAAXXZ DD imagerel $LN46+11
	DD	imagerel $LN46+26
	DD	imagerel $chain$0$?ClearFonts@ImFontAtlas@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?ClearFonts@ImFontAtlas@@QEAAXXZ DD imagerel $LN46+26
	DD	imagerel $LN46+117
	DD	imagerel $chain$2$?ClearFonts@ImFontAtlas@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?ClearFonts@ImFontAtlas@@QEAAXXZ DD imagerel $LN46+117
	DD	imagerel $LN46+131
	DD	imagerel $chain$3$?ClearFonts@ImFontAtlas@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?ClearFonts@ImFontAtlas@@QEAAXXZ DD imagerel $LN46+131
	DD	imagerel $LN46+187
	DD	imagerel $chain$4$?ClearFonts@ImFontAtlas@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ClearTexData@ImFontAtlas@@QEAAXXZ DD imagerel $LN26
	DD	imagerel $LN26+94
	DD	imagerel $unwind$?ClearTexData@ImFontAtlas@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ClearInputData@ImFontAtlas@@QEAAXXZ DD imagerel $LN79
	DD	imagerel $LN79+12
	DD	imagerel $unwind$?ClearInputData@ImFontAtlas@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?ClearInputData@ImFontAtlas@@QEAAXXZ DD imagerel $LN79+12
	DD	imagerel $LN79+32
	DD	imagerel $chain$1$?ClearInputData@ImFontAtlas@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?ClearInputData@ImFontAtlas@@QEAAXXZ DD imagerel $LN79+32
	DD	imagerel $LN79+125
	DD	imagerel $chain$2$?ClearInputData@ImFontAtlas@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?ClearInputData@ImFontAtlas@@QEAAXXZ DD imagerel $LN79+125
	DD	imagerel $LN79+138
	DD	imagerel $chain$3$?ClearInputData@ImFontAtlas@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?ClearInputData@ImFontAtlas@@QEAAXXZ DD imagerel $LN79+138
	DD	imagerel $LN79+233
	DD	imagerel $chain$4$?ClearInputData@ImFontAtlas@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?ClearInputData@ImFontAtlas@@QEAAXXZ DD imagerel $LN79+233
	DD	imagerel $LN79+331
	DD	imagerel $chain$5$?ClearInputData@ImFontAtlas@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ShadeVertsLinearUV@ImGui@@YAXPEAUImDrawList@@HHAEBUImVec2@@111_N@Z DD imagerel $LN133
	DD	imagerel $LN133+712
	DD	imagerel $unwind$?ShadeVertsLinearUV@ImGui@@YAXPEAUImDrawList@@HHAEBUImVec2@@111_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ShadeVertsLinearColorGradientKeepAlpha@ImGui@@YAXPEAUImDrawList@@HHUImVec2@@1II@Z DD imagerel $LN56
	DD	imagerel $LN56+223
	DD	imagerel $unwind$?ShadeVertsLinearColorGradientKeepAlpha@ImGui@@YAXPEAUImDrawList@@HHUImVec2@@1II@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?ShadeVertsLinearColorGradientKeepAlpha@ImGui@@YAXPEAUImDrawList@@HHUImVec2@@1II@Z DD imagerel $LN56+223
	DD	imagerel $LN56+1065
	DD	imagerel $chain$4$?ShadeVertsLinearColorGradientKeepAlpha@ImGui@@YAXPEAUImDrawList@@HHUImVec2@@1II@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?ShadeVertsLinearColorGradientKeepAlpha@ImGui@@YAXPEAUImDrawList@@HHUImVec2@@1II@Z DD imagerel $LN56+1065
	DD	imagerel $LN56+1109
	DD	imagerel $chain$5$?ShadeVertsLinearColorGradientKeepAlpha@ImGui@@YAXPEAUImDrawList@@HHUImVec2@@1II@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AddImageRounded@ImDrawList@@QEAAXPEAXAEBUImVec2@@111IMH@Z DD imagerel $LN20
	DD	imagerel $LN20+72
	DD	imagerel $unwind$?AddImageRounded@ImDrawList@@QEAAXPEAXAEBUImVec2@@111IMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?AddImageRounded@ImDrawList@@QEAAXPEAXAEBUImVec2@@111IMH@Z DD imagerel $LN20+72
	DD	imagerel $LN20+225
	DD	imagerel $chain$1$?AddImageRounded@ImDrawList@@QEAAXPEAXAEBUImVec2@@111IMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?AddImageRounded@ImDrawList@@QEAAXPEAXAEBUImVec2@@111IMH@Z DD imagerel $LN20+225
	DD	imagerel $LN20+290
	DD	imagerel $chain$2$?AddImageRounded@ImDrawList@@QEAAXPEAXAEBUImVec2@@111IMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z DD imagerel $LN159
	DD	imagerel $LN159+271
	DD	imagerel $unwind$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z DD imagerel $LN159+271
	DD	imagerel $LN159+312
	DD	imagerel $chain$1$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z DD imagerel $LN159+312
	DD	imagerel $LN159+320
	DD	imagerel $chain$2$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z DD imagerel $LN159+320
	DD	imagerel $LN159+727
	DD	imagerel $chain$4$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z DD imagerel $LN159+727
	DD	imagerel $LN159+878
	DD	imagerel $chain$5$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z DD imagerel $LN159+878
	DD	imagerel $LN159+953
	DD	imagerel $chain$6$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z DD imagerel $LN159+953
	DD	imagerel $LN159+990
	DD	imagerel $chain$7$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z DD imagerel $LN159+990
	DD	imagerel $LN159+1025
	DD	imagerel $chain$8$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z DD imagerel $LN159+1025
	DD	imagerel $LN159+1391
	DD	imagerel $chain$9$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?PathBezierCubicCurveToCasteljau@@YAXPEAU?$ImVector@UImVec2@@@@MMMMMMMMMH@Z DD imagerel ?PathBezierCubicCurveToCasteljau@@YAXPEAU?$ImVector@UImVec2@@@@MMMMMMMMMH@Z
	DD	imagerel ?PathBezierCubicCurveToCasteljau@@YAXPEAU?$ImVector@UImVec2@@@@MMMMMMMMMH@Z+836
	DD	imagerel $unwind$?PathBezierCubicCurveToCasteljau@@YAXPEAU?$ImVector@UImVec2@@@@MMMMMMMMMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD imagerel $LN27
	DD	imagerel $LN27+67
	DD	imagerel $unwind$?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD imagerel $LN27+67
	DD	imagerel $LN27+110
	DD	imagerel $chain$1$?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD imagerel $LN27+110
	DD	imagerel $LN27+324
	DD	imagerel $chain$4$?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD imagerel $LN27+324
	DD	imagerel $LN27+340
	DD	imagerel $chain$5$?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD imagerel $LN27+340
	DD	imagerel $LN27+369
	DD	imagerel $chain$6$?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z DD imagerel $LN59
	DD	imagerel $LN59+73
	DD	imagerel $unwind$?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z DD imagerel $LN59+73
	DD	imagerel $LN59+86
	DD	imagerel $chain$1$?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z DD imagerel $LN59+86
	DD	imagerel $LN59+326
	DD	imagerel $chain$3$?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z DD imagerel $LN59+326
	DD	imagerel $LN59+560
	DD	imagerel $chain$4$?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z DD imagerel $LN59+560
	DD	imagerel $LN59+660
	DD	imagerel $chain$5$?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?PrimRectUV@ImDrawList@@QEAAXAEBUImVec2@@000I@Z DD imagerel $LN12
	DD	imagerel $LN12+334
	DD	imagerel $unwind$?PrimRectUV@ImDrawList@@QEAAXAEBUImVec2@@000I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?PrimRect@ImDrawList@@QEAAXAEBUImVec2@@0I@Z DD imagerel $LN8
	DD	imagerel $LN8+278
	DD	imagerel $unwind$?PrimRect@ImDrawList@@QEAAXAEBUImVec2@@0I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?PrimReserve@ImDrawList@@QEAAXHH@Z DD imagerel $LN29
	DD	imagerel $LN29+273
	DD	imagerel $unwind$?PrimReserve@ImDrawList@@QEAAXHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_OnChangedTextureID@ImDrawList@@QEAAXXZ DD imagerel $LN18
	DD	imagerel $LN18+169
	DD	imagerel $unwind$?_OnChangedTextureID@ImDrawList@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_OnChangedClipRect@ImDrawList@@QEAAXXZ DD imagerel $LN17
	DD	imagerel $LN17+175
	DD	imagerel $unwind$?_OnChangedClipRect@ImDrawList@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AddCallback@ImDrawList@@QEAAXP6AXPEBU1@PEBUImDrawCmd@@@ZPEAX@Z DD imagerel $LN6
	DD	imagerel $LN6+77
	DD	imagerel $unwind$?AddCallback@ImDrawList@@QEAAXP6AXPEBU1@PEBUImDrawCmd@@@ZPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbtt_PackFontRangesRenderIntoRects DD imagerel stbtt_PackFontRangesRenderIntoRects
	DD	imagerel stbtt_PackFontRangesRenderIntoRects+276
	DD	imagerel $unwind$stbtt_PackFontRangesRenderIntoRects
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$stbtt_PackFontRangesRenderIntoRects DD imagerel stbtt_PackFontRangesRenderIntoRects+276
	DD	imagerel stbtt_PackFontRangesRenderIntoRects+437
	DD	imagerel $chain$1$stbtt_PackFontRangesRenderIntoRects
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$stbtt_PackFontRangesRenderIntoRects DD imagerel stbtt_PackFontRangesRenderIntoRects+437
	DD	imagerel stbtt_PackFontRangesRenderIntoRects+1713
	DD	imagerel $chain$6$stbtt_PackFontRangesRenderIntoRects
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$stbtt_PackFontRangesRenderIntoRects DD imagerel stbtt_PackFontRangesRenderIntoRects+1713
	DD	imagerel stbtt_PackFontRangesRenderIntoRects+1804
	DD	imagerel $chain$7$stbtt_PackFontRangesRenderIntoRects
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbtt__v_prefilter@@YAXPEAEHHHI@Z DD imagerel ?stbtt__v_prefilter@@YAXPEAEHHHI@Z
	DD	imagerel ?stbtt__v_prefilter@@YAXPEAEHHHI@Z+45
	DD	imagerel $unwind$?stbtt__v_prefilter@@YAXPEAEHHHI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?stbtt__v_prefilter@@YAXPEAEHHHI@Z DD imagerel ?stbtt__v_prefilter@@YAXPEAEHHHI@Z+45
	DD	imagerel ?stbtt__v_prefilter@@YAXPEAEHHHI@Z+660
	DD	imagerel $chain$1$?stbtt__v_prefilter@@YAXPEAEHHHI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?stbtt__v_prefilter@@YAXPEAEHHHI@Z DD imagerel ?stbtt__v_prefilter@@YAXPEAEHHHI@Z+660
	DD	imagerel ?stbtt__v_prefilter@@YAXPEAEHHHI@Z+661
	DD	imagerel $chain$2$?stbtt__v_prefilter@@YAXPEAEHHHI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbtt__h_prefilter@@YAXPEAEHHHI@Z DD imagerel ?stbtt__h_prefilter@@YAXPEAEHHHI@Z
	DD	imagerel ?stbtt__h_prefilter@@YAXPEAEHHHI@Z+42
	DD	imagerel $unwind$?stbtt__h_prefilter@@YAXPEAEHHHI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?stbtt__h_prefilter@@YAXPEAEHHHI@Z DD imagerel ?stbtt__h_prefilter@@YAXPEAEHHHI@Z+42
	DD	imagerel ?stbtt__h_prefilter@@YAXPEAEHHHI@Z+680
	DD	imagerel $chain$2$?stbtt__h_prefilter@@YAXPEAEHHHI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?stbtt__h_prefilter@@YAXPEAEHHHI@Z DD imagerel ?stbtt__h_prefilter@@YAXPEAEHHHI@Z+680
	DD	imagerel ?stbtt__h_prefilter@@YAXPEAEHHHI@Z+681
	DD	imagerel $chain$3$?stbtt__h_prefilter@@YAXPEAEHHHI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbtt_PackEnd DD imagerel stbtt_PackEnd
	DD	imagerel stbtt_PackEnd+81
	DD	imagerel $unwind$stbtt_PackEnd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbtt_PackBegin DD imagerel stbtt_PackBegin
	DD	imagerel stbtt_PackBegin+280
	DD	imagerel $unwind$stbtt_PackBegin
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbtt_MakeGlyphBitmapSubpixel DD imagerel stbtt_MakeGlyphBitmapSubpixel
	DD	imagerel stbtt_MakeGlyphBitmapSubpixel+535
	DD	imagerel $unwind$stbtt_MakeGlyphBitmapSubpixel
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbtt_Rasterize DD imagerel stbtt_Rasterize
	DD	imagerel stbtt_Rasterize+293
	DD	imagerel $unwind$stbtt_Rasterize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z DD imagerel ?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z
	DD	imagerel ?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z+212
	DD	imagerel $unwind$?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z DD imagerel ?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z+212
	DD	imagerel ?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z+905
	DD	imagerel $chain$3$?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z DD imagerel ?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z+905
	DD	imagerel ?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z+953
	DD	imagerel $chain$4$?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z DD imagerel ?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z+953
	DD	imagerel ?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z+1016
	DD	imagerel $chain$5$?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z DD imagerel ?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z
	DD	imagerel ?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z+421
	DD	imagerel $unwind$?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z DD imagerel ?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z+421
	DD	imagerel ?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z+1112
	DD	imagerel $chain$0$?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z DD imagerel ?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z+1112
	DD	imagerel ?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z+1180
	DD	imagerel $chain$1$?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z DD imagerel ?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z
	DD	imagerel ?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z+220
	DD	imagerel $unwind$?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z DD imagerel ?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z+220
	DD	imagerel ?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z+430
	DD	imagerel $chain$0$?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z DD imagerel ?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z+430
	DD	imagerel ?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z+491
	DD	imagerel $chain$1$?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z DD imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z
	DD	imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+276
	DD	imagerel $unwind$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z DD imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+276
	DD	imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+295
	DD	imagerel $chain$1$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z DD imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+295
	DD	imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+351
	DD	imagerel $chain$2$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z DD imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+351
	DD	imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+624
	DD	imagerel $chain$3$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z DD imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+624
	DD	imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+648
	DD	imagerel $chain$4$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z DD imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+648
	DD	imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+825
	DD	imagerel $chain$5$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z DD imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+825
	DD	imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+858
	DD	imagerel $chain$6$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbtt__sort_edges@@YAXPEAUstbtt__edge@@H@Z DD imagerel ?stbtt__sort_edges@@YAXPEAUstbtt__edge@@H@Z
	DD	imagerel ?stbtt__sort_edges@@YAXPEAUstbtt__edge@@H@Z+163
	DD	imagerel $unwind$?stbtt__sort_edges@@YAXPEAUstbtt__edge@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z DD imagerel ?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z
	DD	imagerel ?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z+15
	DD	imagerel $unwind$?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z DD imagerel ?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z+15
	DD	imagerel ?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z+465
	DD	imagerel $chain$3$?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z DD imagerel ?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z+465
	DD	imagerel ?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z+466
	DD	imagerel $chain$4$?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z DD imagerel ?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z
	DD	imagerel ?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z+16
	DD	imagerel $unwind$?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z DD imagerel ?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z+16
	DD	imagerel ?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z+158
	DD	imagerel $chain$0$?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z DD imagerel ?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z+158
	DD	imagerel ?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z+163
	DD	imagerel $chain$1$?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z DD imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z
	DD	imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+31
	DD	imagerel $unwind$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z DD imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+31
	DD	imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+37
	DD	imagerel $chain$0$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z DD imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+37
	DD	imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+237
	DD	imagerel $chain$7$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$14$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z DD imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+237
	DD	imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+1089
	DD	imagerel $chain$14$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$15$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z DD imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+1089
	DD	imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+1152
	DD	imagerel $chain$15$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$16$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z DD imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+1152
	DD	imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+1216
	DD	imagerel $chain$16$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$17$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z DD imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+1216
	DD	imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+1273
	DD	imagerel $chain$17$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z DD imagerel ?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z
	DD	imagerel ?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z+105
	DD	imagerel $unwind$?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z DD imagerel ?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z+105
	DD	imagerel ?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z+1592
	DD	imagerel $chain$7$?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z DD imagerel ?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z+1592
	DD	imagerel ?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z+1593
	DD	imagerel $chain$8$?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z DD imagerel ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z
	DD	imagerel ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z+27
	DD	imagerel $unwind$?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z DD imagerel ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z+27
	DD	imagerel ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z+221
	DD	imagerel $chain$2$?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z DD imagerel ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z+221
	DD	imagerel ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z+305
	DD	imagerel $chain$4$?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z DD imagerel ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z+305
	DD	imagerel ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z+310
	DD	imagerel $chain$5$?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z DD imagerel ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z+310
	DD	imagerel ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z+315
	DD	imagerel $chain$6$?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z DD imagerel ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z+315
	DD	imagerel ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z+320
	DD	imagerel $chain$7$?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbtt__new_active@@YAPEAUstbtt__active_edge@@PEAUstbtt__hheap@@PEAUstbtt__edge@@HMPEAX@Z DD imagerel ?stbtt__new_active@@YAPEAUstbtt__active_edge@@PEAUstbtt__hheap@@PEAUstbtt__edge@@HMPEAX@Z
	DD	imagerel ?stbtt__new_active@@YAPEAUstbtt__active_edge@@PEAUstbtt__hheap@@PEAUstbtt__edge@@HMPEAX@Z+299
	DD	imagerel $unwind$?stbtt__new_active@@YAPEAUstbtt__active_edge@@PEAUstbtt__hheap@@PEAUstbtt__edge@@HMPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z DD imagerel ?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z
	DD	imagerel ?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z+12
	DD	imagerel $unwind$?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z DD imagerel ?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z+12
	DD	imagerel ?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z+57
	DD	imagerel $chain$0$?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z DD imagerel ?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z+57
	DD	imagerel ?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z+62
	DD	imagerel $chain$1$?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbtt__hheap_alloc@@YAPEAXPEAUstbtt__hheap@@_KPEAX@Z DD imagerel ?stbtt__hheap_alloc@@YAPEAXPEAUstbtt__hheap@@_KPEAX@Z
	DD	imagerel ?stbtt__hheap_alloc@@YAPEAXPEAUstbtt__hheap@@_KPEAX@Z+123
	DD	imagerel $unwind$?stbtt__hheap_alloc@@YAPEAXPEAUstbtt__hheap@@_KPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbtt_GetGlyphBitmapBox DD imagerel stbtt_GetGlyphBitmapBox
	DD	imagerel stbtt_GetGlyphBitmapBox+81
	DD	imagerel $unwind$stbtt_GetGlyphBitmapBox
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbtt_GetGlyphBitmapBoxSubpixel DD imagerel stbtt_GetGlyphBitmapBoxSubpixel
	DD	imagerel stbtt_GetGlyphBitmapBoxSubpixel+311
	DD	imagerel $unwind$stbtt_GetGlyphBitmapBoxSubpixel
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$stbtt_GetGlyphBitmapBoxSubpixel DD imagerel stbtt_GetGlyphBitmapBoxSubpixel+311
	DD	imagerel stbtt_GetGlyphBitmapBoxSubpixel+526
	DD	imagerel $chain$0$stbtt_GetGlyphBitmapBoxSubpixel
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$stbtt_GetGlyphBitmapBoxSubpixel DD imagerel stbtt_GetGlyphBitmapBoxSubpixel+526
	DD	imagerel stbtt_GetGlyphBitmapBoxSubpixel+607
	DD	imagerel $chain$1$stbtt_GetGlyphBitmapBoxSubpixel
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbtt_GetFontVMetrics DD imagerel stbtt_GetFontVMetrics
	DD	imagerel stbtt_GetFontVMetrics+157
	DD	imagerel $unwind$stbtt_GetFontVMetrics
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbtt_GetGlyphHMetrics DD imagerel stbtt_GetGlyphHMetrics
	DD	imagerel stbtt_GetGlyphHMetrics+261
	DD	imagerel $unwind$stbtt_GetGlyphHMetrics
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbtt_GetGlyphShape DD imagerel stbtt_GetGlyphShape
	DD	imagerel stbtt_GetGlyphShape+56
	DD	imagerel $unwind$stbtt_GetGlyphShape
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$stbtt_GetGlyphShape DD imagerel stbtt_GetGlyphShape+56
	DD	imagerel stbtt_GetGlyphShape+220
	DD	imagerel $chain$0$stbtt_GetGlyphShape
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$stbtt_GetGlyphShape DD imagerel stbtt_GetGlyphShape+220
	DD	imagerel stbtt_GetGlyphShape+247
	DD	imagerel $chain$1$stbtt_GetGlyphShape
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbtt__GetGlyphInfoT2@@YAHPEBUstbtt_fontinfo@@HPEAH111@Z DD imagerel ?stbtt__GetGlyphInfoT2@@YAHPEBUstbtt_fontinfo@@HPEAH111@Z
	DD	imagerel ?stbtt__GetGlyphInfoT2@@YAHPEBUstbtt_fontinfo@@HPEAH111@Z+198
	DD	imagerel $unwind$?stbtt__GetGlyphInfoT2@@YAHPEBUstbtt_fontinfo@@HPEAH111@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbtt__GetGlyphShapeT2@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z DD imagerel ?stbtt__GetGlyphShapeT2@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z
	DD	imagerel ?stbtt__GetGlyphShapeT2@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z+227
	DD	imagerel $unwind$?stbtt__GetGlyphShapeT2@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z DD imagerel ?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z
	DD	imagerel ?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z+3168
	DD	imagerel $unwind$?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbtt__cid_get_glyph_subrs@@YA?AUstbtt__buf@@PEBUstbtt_fontinfo@@H@Z DD imagerel ?stbtt__cid_get_glyph_subrs@@YA?AUstbtt__buf@@PEBUstbtt_fontinfo@@H@Z
	DD	imagerel ?stbtt__cid_get_glyph_subrs@@YA?AUstbtt__buf@@PEBUstbtt_fontinfo@@H@Z+459
	DD	imagerel $unwind$?stbtt__cid_get_glyph_subrs@@YA?AUstbtt__buf@@PEBUstbtt_fontinfo@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbtt__get_subr@@YA?AUstbtt__buf@@U1@H@Z DD imagerel ?stbtt__get_subr@@YA?AUstbtt__buf@@U1@H@Z
	DD	imagerel ?stbtt__get_subr@@YA?AUstbtt__buf@@U1@H@Z+190
	DD	imagerel $unwind$?stbtt__get_subr@@YA?AUstbtt__buf@@U1@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z DD imagerel ?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z
	DD	imagerel ?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z+145
	DD	imagerel $unwind$?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbtt__csctx_rmove_to@@YAXPEAUstbtt__csctx@@MM@Z DD imagerel ?stbtt__csctx_rmove_to@@YAXPEAUstbtt__csctx@@MM@Z
	DD	imagerel ?stbtt__csctx_rmove_to@@YAXPEAUstbtt__csctx@@MM@Z+188
	DD	imagerel $unwind$?stbtt__csctx_rmove_to@@YAXPEAUstbtt__csctx@@MM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z DD imagerel ?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z
	DD	imagerel ?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z+25
	DD	imagerel $unwind$?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z DD imagerel ?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z+25
	DD	imagerel ?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z+230
	DD	imagerel $chain$1$?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z DD imagerel ?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z+230
	DD	imagerel ?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z+296
	DD	imagerel $chain$2$?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbtt__GetGlyphShapeTT@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z DD imagerel ?stbtt__GetGlyphShapeTT@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z
	DD	imagerel ?stbtt__GetGlyphShapeTT@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z+3332
	DD	imagerel $unwind$?stbtt__GetGlyphShapeTT@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z DD imagerel ?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z
	DD	imagerel ?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z+24
	DD	imagerel $unwind$?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z DD imagerel ?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z+24
	DD	imagerel ?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z+151
	DD	imagerel $chain$0$?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z DD imagerel ?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z+151
	DD	imagerel ?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z+229
	DD	imagerel $chain$1$?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbtt_GetGlyphBox DD imagerel stbtt_GetGlyphBox
	DD	imagerel stbtt_GetGlyphBox+373
	DD	imagerel $unwind$stbtt_GetGlyphBox
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbtt_FindGlyphIndex DD imagerel stbtt_FindGlyphIndex
	DD	imagerel stbtt_FindGlyphIndex+301
	DD	imagerel $unwind$stbtt_FindGlyphIndex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$stbtt_FindGlyphIndex DD imagerel stbtt_FindGlyphIndex+301
	DD	imagerel stbtt_FindGlyphIndex+472
	DD	imagerel $chain$0$stbtt_FindGlyphIndex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$stbtt_FindGlyphIndex DD imagerel stbtt_FindGlyphIndex+472
	DD	imagerel stbtt_FindGlyphIndex+888
	DD	imagerel $chain$1$stbtt_FindGlyphIndex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbtt_InitFont_internal@@YAHPEAUstbtt_fontinfo@@PEAEH@Z DD imagerel ?stbtt_InitFont_internal@@YAHPEAUstbtt_fontinfo@@PEAEH@Z
	DD	imagerel ?stbtt_InitFont_internal@@YAHPEAUstbtt_fontinfo@@PEAEH@Z+1351
	DD	imagerel $unwind$?stbtt_InitFont_internal@@YAHPEAUstbtt_fontinfo@@PEAEH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbtt__get_subrs@@YA?AUstbtt__buf@@U1@0@Z DD imagerel ?stbtt__get_subrs@@YA?AUstbtt__buf@@U1@0@Z
	DD	imagerel ?stbtt__get_subrs@@YA?AUstbtt__buf@@U1@0@Z+356
	DD	imagerel $unwind$?stbtt__get_subrs@@YA?AUstbtt__buf@@U1@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbtt__find_table@@YAIPEAEIPEBD@Z DD imagerel ?stbtt__find_table@@YAIPEAEIPEBD@Z
	DD	imagerel ?stbtt__find_table@@YAIPEAEIPEBD@Z+169
	DD	imagerel $unwind$?stbtt__find_table@@YAIPEAEIPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z DD imagerel ?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z
	DD	imagerel ?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z+322
	DD	imagerel $unwind$?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbtt__dict_get_ints@@YAXPEAUstbtt__buf@@HHPEAI@Z DD imagerel ?stbtt__dict_get_ints@@YAXPEAUstbtt__buf@@HHPEAI@Z
	DD	imagerel ?stbtt__dict_get_ints@@YAXPEAUstbtt__buf@@HHPEAI@Z+101
	DD	imagerel $unwind$?stbtt__dict_get_ints@@YAXPEAUstbtt__buf@@HHPEAI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbtt__dict_get@@YA?AUstbtt__buf@@PEAU1@H@Z DD imagerel ?stbtt__dict_get@@YA?AUstbtt__buf@@PEAU1@H@Z
	DD	imagerel ?stbtt__dict_get@@YA?AUstbtt__buf@@PEAU1@H@Z+397
	DD	imagerel $unwind$?stbtt__dict_get@@YA?AUstbtt__buf@@PEAU1@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z DD imagerel ?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z
	DD	imagerel ?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z+323
	DD	imagerel $unwind$?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z DD imagerel ?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z+323
	DD	imagerel ?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z+364
	DD	imagerel $chain$0$?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z DD imagerel ?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z+364
	DD	imagerel ?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z+422
	DD	imagerel $chain$2$?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z DD imagerel ?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z+422
	DD	imagerel ?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z+475
	DD	imagerel $chain$4$?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z DD imagerel ?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z+475
	DD	imagerel ?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z+521
	DD	imagerel $chain$6$?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z DD imagerel ?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z+521
	DD	imagerel ?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z+554
	DD	imagerel $chain$8$?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z DD imagerel ?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z+554
	DD	imagerel ?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z+561
	DD	imagerel $chain$9$?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z DD imagerel ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z
	DD	imagerel ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z+136
	DD	imagerel $unwind$?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z DD imagerel ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z+136
	DD	imagerel ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z+190
	DD	imagerel $chain$0$?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z DD imagerel ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z+190
	DD	imagerel ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z+273
	DD	imagerel $chain$1$?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbrp_pack_rects DD imagerel stbrp_pack_rects
	DD	imagerel stbrp_pack_rects+12
	DD	imagerel $unwind$stbrp_pack_rects
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$stbrp_pack_rects DD imagerel stbrp_pack_rects+12
	DD	imagerel stbrp_pack_rects+104
	DD	imagerel $chain$0$stbrp_pack_rects
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$stbrp_pack_rects DD imagerel stbrp_pack_rects+104
	DD	imagerel stbrp_pack_rects+377
	DD	imagerel $chain$4$stbrp_pack_rects
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$stbrp_pack_rects DD imagerel stbrp_pack_rects+377
	DD	imagerel stbrp_pack_rects+387
	DD	imagerel $chain$5$stbrp_pack_rects
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$stbrp_pack_rects DD imagerel stbrp_pack_rects+387
	DD	imagerel stbrp_pack_rects+485
	DD	imagerel $chain$6$stbrp_pack_rects
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbrp__skyline_pack_rectangle@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z DD imagerel ?stbrp__skyline_pack_rectangle@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z
	DD	imagerel ?stbrp__skyline_pack_rectangle@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z+208
	DD	imagerel $unwind$?stbrp__skyline_pack_rectangle@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z DD imagerel ?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z
	DD	imagerel ?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z+116
	DD	imagerel $unwind$?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z DD imagerel ?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z+116
	DD	imagerel ?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z+674
	DD	imagerel $chain$3$?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z DD imagerel ?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z+674
	DD	imagerel ?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z+697
	DD	imagerel $chain$4$?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z DD imagerel ?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z
	DD	imagerel ?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z+40
	DD	imagerel $unwind$?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z DD imagerel ?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z+40
	DD	imagerel ?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z+163
	DD	imagerel $chain$0$?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z DD imagerel ?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z+163
	DD	imagerel ?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z+192
	DD	imagerel $chain$1$?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbrp_init_target DD imagerel stbrp_init_target
	DD	imagerel stbrp_init_target+88
	DD	imagerel $unwind$stbrp_init_target
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$stbrp_init_target DD imagerel stbrp_init_target+88
	DD	imagerel stbrp_init_target+275
	DD	imagerel $chain$1$stbrp_init_target
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$stbrp_init_target DD imagerel stbrp_init_target+275
	DD	imagerel stbrp_init_target+456
	DD	imagerel $chain$2$stbrp_init_target
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Clear@ImBitVector@@QEAAXXZ DD imagerel $LN17
	DD	imagerel $LN17+63
	DD	imagerel $unwind$?Clear@ImBitVector@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Create@ImBitVector@@QEAAXH@Z DD imagerel $LN13
	DD	imagerel $LN13+93
	DD	imagerel $unwind$?Create@ImBitVector@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImClamp@@YA?AUImVec2@@AEBU1@0U1@@Z DD imagerel ?ImClamp@@YA?AUImVec2@@AEBU1@0U1@@Z
	DD	imagerel ?ImClamp@@YA?AUImVec2@@AEBU1@0U1@@Z+74
	DD	imagerel $unwind$?ImClamp@@YA?AUImVec2@@AEBU1@0U1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_CalcCircleAutoSegmentCount@ImDrawList@@QEBAHM@Z DD imagerel $LN14
	DD	imagerel $LN14+144
	DD	imagerel $unwind$?_CalcCircleAutoSegmentCount@ImDrawList@@QEBAHM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AddBezierCubic@ImDrawList@@QEAAXAEBUImVec2@@000IMH@Z DD imagerel $LN8
	DD	imagerel $LN8+119
	DD	imagerel $unwind$?AddBezierCubic@ImDrawList@@QEAAXAEBUImVec2@@000IMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AddTriangle@ImDrawList@@QEAAXAEBUImVec2@@00IM@Z DD imagerel $LN8
	DD	imagerel $LN8+128
	DD	imagerel $unwind$?AddTriangle@ImDrawList@@QEAAXAEBUImVec2@@00IM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AddRectFilledMultiColor@ImDrawList@@QEAAXAEBUImVec2@@0IIII@Z DD imagerel $LN30
	DD	imagerel $LN30+94
	DD	imagerel $unwind$?AddRectFilledMultiColor@ImDrawList@@QEAAXAEBUImVec2@@0IIII@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?AddRectFilledMultiColor@ImDrawList@@QEAAXAEBUImVec2@@0IIII@Z DD imagerel $LN30+94
	DD	imagerel $LN30+443
	DD	imagerel $chain$1$?AddRectFilledMultiColor@ImDrawList@@QEAAXAEBUImVec2@@0IIII@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?AddRectFilledMultiColor@ImDrawList@@QEAAXAEBUImVec2@@0IIII@Z DD imagerel $LN30+443
	DD	imagerel $LN30+474
	DD	imagerel $chain$2$?AddRectFilledMultiColor@ImDrawList@@QEAAXAEBUImVec2@@0IIII@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?RenderChar@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IG@Z DD imagerel $LN26
	DD	imagerel $LN26+115
	DD	imagerel $unwind$?RenderChar@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?RenderChar@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IG@Z DD imagerel $LN26+115
	DD	imagerel $LN26+399
	DD	imagerel $chain$2$?RenderChar@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?RenderChar@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IG@Z DD imagerel $LN26+399
	DD	imagerel $LN26+422
	DD	imagerel $chain$3$?RenderChar@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z DD imagerel $LN77
	DD	imagerel $LN77+23
	DD	imagerel $unwind$?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z DD imagerel $LN77+23
	DD	imagerel $LN77+163
	DD	imagerel $chain$9$?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z DD imagerel $LN77+163
	DD	imagerel $LN77+465
	DD	imagerel $chain$10$?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$11$?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z DD imagerel $LN77+465
	DD	imagerel $LN77+520
	DD	imagerel $chain$11$?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$12$?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z DD imagerel $LN77+520
	DD	imagerel $LN77+538
	DD	imagerel $chain$12$?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$13$?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z DD imagerel $LN77+538
	DD	imagerel $LN77+585
	DD	imagerel $chain$13$?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$14$?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z DD imagerel $LN77+585
	DD	imagerel $LN77+601
	DD	imagerel $chain$14$?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ImFont@@QEAA@XZ DD imagerel $LN42
	DD	imagerel $LN42+123
	DD	imagerel $unwind$??1ImFont@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SetCurrentChannel@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z DD imagerel $LN18
	DD	imagerel $LN18+212
	DD	imagerel $unwind$?SetCurrentChannel@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z DD imagerel $LN126
	DD	imagerel $LN126+31
	DD	imagerel $unwind$?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z DD imagerel $LN126+31
	DD	imagerel $LN126+38
	DD	imagerel $chain$0$?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z DD imagerel $LN126+38
	DD	imagerel $LN126+844
	DD	imagerel $chain$5$?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z DD imagerel $LN126+844
	DD	imagerel $LN126+896
	DD	imagerel $chain$6$?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z DD imagerel $LN126+896
	DD	imagerel $LN126+975
	DD	imagerel $chain$7$?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Split@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z DD imagerel $LN61
	DD	imagerel $LN61+112
	DD	imagerel $unwind$?Split@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?Split@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z DD imagerel $LN61+112
	DD	imagerel $LN61+300
	DD	imagerel $chain$1$?Split@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?Split@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z DD imagerel $LN61+300
	DD	imagerel $LN61+311
	DD	imagerel $chain$2$?Split@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ DD imagerel $LN59
	DD	imagerel $LN59+12
	DD	imagerel $unwind$?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ DD imagerel $LN59+12
	DD	imagerel $LN59+31
	DD	imagerel $chain$0$?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ DD imagerel $LN59+31
	DD	imagerel $LN59+193
	DD	imagerel $chain$2$?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ DD imagerel $LN59+193
	DD	imagerel $LN59+216
	DD	imagerel $chain$3$?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ DD imagerel $LN59+216
	DD	imagerel $LN59+259
	DD	imagerel $chain$4$?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_ClearFreeMemory@ImDrawList@@QEAAXXZ DD imagerel $LN82
	DD	imagerel $LN82+300
	DD	imagerel $unwind$?_ClearFreeMemory@ImDrawList@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_ResetForNewFrame@ImDrawList@@QEAAXXZ DD imagerel $LN69
	DD	imagerel $LN69+435
	DD	imagerel $unwind$?_ResetForNewFrame@ImDrawList@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AddDrawCmd@ImDrawList@@QEAAXXZ DD imagerel $LN17
	DD	imagerel $LN17+182
	DD	imagerel $unwind$?AddDrawCmd@ImDrawList@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?PathArcToFast@ImDrawList@@QEAAXAEBUImVec2@@MHH@Z DD imagerel $LN5
	DD	imagerel $LN5+63
	DD	imagerel $unwind$?PathArcToFast@ImDrawList@@QEAAXAEBUImVec2@@MHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD imagerel $LN91
	DD	imagerel $LN91+109
	DD	imagerel $unwind$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD imagerel $LN91+109
	DD	imagerel $LN91+179
	DD	imagerel $chain$3$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD imagerel $LN91+179
	DD	imagerel $LN91+187
	DD	imagerel $chain$4$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD imagerel $LN91+187
	DD	imagerel $LN91+675
	DD	imagerel $chain$8$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD imagerel $LN91+675
	DD	imagerel $LN91+724
	DD	imagerel $chain$9$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD imagerel $LN91+724
	DD	imagerel $LN91+860
	DD	imagerel $chain$10$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$11$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD imagerel $LN91+860
	DD	imagerel $LN91+887
	DD	imagerel $chain$11$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$12$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD imagerel $LN91+887
	DD	imagerel $LN91+911
	DD	imagerel $chain$12$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$13$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD imagerel $LN91+911
	DD	imagerel $LN91+1029
	DD	imagerel $chain$13$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z DD imagerel $LN17
	DD	imagerel $LN17+46
	DD	imagerel $unwind$?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z DD imagerel $LN17+46
	DD	imagerel $LN17+128
	DD	imagerel $chain$0$?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z DD imagerel $LN17+128
	DD	imagerel $LN17+190
	DD	imagerel $chain$1$?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AddText@ImDrawList@@QEAAXAEBUImVec2@@IPEBD1@Z DD imagerel $LN33
	DD	imagerel $LN33+118
	DD	imagerel $unwind$?AddText@ImDrawList@@QEAAXAEBUImVec2@@IPEBD1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z DD imagerel $LN30
	DD	imagerel $LN30+271
	DD	imagerel $unwind$?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z DD imagerel $LN43
	DD	imagerel $LN43+49
	DD	imagerel $unwind$?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z DD imagerel $LN43+49
	DD	imagerel $LN43+64
	DD	imagerel $chain$1$?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z DD imagerel $LN43+64
	DD	imagerel $LN43+219
	DD	imagerel $chain$2$?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z DD imagerel $LN43+219
	DD	imagerel $LN43+349
	DD	imagerel $chain$3$?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z DD imagerel $LN43+349
	DD	imagerel $LN43+350
	DD	imagerel $chain$4$?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?PushTextureID@ImDrawList@@QEAAXPEAX@Z DD imagerel $LN13
	DD	imagerel $LN13+120
	DD	imagerel $unwind$?PushTextureID@ImDrawList@@QEAAXPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?PushClipRect@ImDrawList@@QEAAXAEBUImVec2@@0_N@Z DD imagerel $LN35
	DD	imagerel $LN35+267
	DD	imagerel $unwind$?PushClipRect@ImDrawList@@QEAAXAEBUImVec2@@0_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SetCircleTessellationMaxError@ImDrawListSharedData@@QEAAXM@Z DD imagerel $LN31
	DD	imagerel $LN31+25
	DD	imagerel $unwind$?SetCircleTessellationMaxError@ImDrawListSharedData@@QEAAXM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?SetCircleTessellationMaxError@ImDrawListSharedData@@QEAAXM@Z DD imagerel $LN31+25
	DD	imagerel $LN31+244
	DD	imagerel $chain$4$?SetCircleTessellationMaxError@ImDrawListSharedData@@QEAAXM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?SetCircleTessellationMaxError@ImDrawListSharedData@@QEAAXM@Z DD imagerel $LN31+244
	DD	imagerel $LN31+250
	DD	imagerel $chain$5$?SetCircleTessellationMaxError@ImDrawListSharedData@@QEAAXM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImDrawListSharedData@@QEAA@XZ DD imagerel $LN39
	DD	imagerel $LN39+274
	DD	imagerel $unwind$??0ImDrawListSharedData@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ImFontAtlas@@QEAA@XZ DD imagerel $LN81
	DD	imagerel $LN81+308
	DD	imagerel $unwind$??1ImFontAtlas@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImFontAtlas@@QEAA@XZ DD imagerel $LN32
	DD	imagerel $LN32+124
	DD	imagerel $unwind$??0ImFontAtlas@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Clear@ImDrawData@@QEAAXXZ DD imagerel $LN14
	DD	imagerel $LN14+97
	DD	imagerel $unwind$?Clear@ImDrawData@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImBezierCubicCalc@@YA?AUImVec2@@AEBU1@000M@Z DD imagerel $LN6
	DD	imagerel $LN6+180
	DD	imagerel $unwind$?ImBezierCubicCalc@@YA?AUImVec2@@AEBU1@000M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?RenderRectFilledWithHole@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@1IM@Z DD imagerel $LN58
	DD	imagerel $LN58+945
	DD	imagerel $unwind$?RenderRectFilledWithHole@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@1IM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AddDrawListToDrawDataEx@ImGui@@YAXPEAUImDrawData@@PEAU?$ImVector@PEAUImDrawList@@@@PEAUImDrawList@@@Z DD imagerel $LN24
	DD	imagerel $LN24+149
	DD	imagerel $unwind$?AddDrawListToDrawDataEx@ImGui@@YAXPEAUImDrawData@@PEAU?$ImVector@PEAUImDrawList@@@@PEAUImDrawList@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?StyleColorsDark@ImGui@@YAXPEAUImGuiStyle@@@Z DD imagerel $LN125
	DD	imagerel $LN125+2539
	DD	imagerel $unwind$?StyleColorsDark@ImGui@@YAXPEAUImGuiStyle@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?RenderBullet@ImGui@@YAXPEAUImDrawList@@UImVec2@@I@Z DD imagerel $LN91
	DD	imagerel $LN91+94
	DD	imagerel $unwind$?RenderBullet@ImGui@@YAXPEAUImDrawList@@UImVec2@@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?RenderBullet@ImGui@@YAXPEAUImDrawList@@UImVec2@@I@Z DD imagerel $LN91+94
	DD	imagerel $LN91+141
	DD	imagerel $chain$0$?RenderBullet@ImGui@@YAXPEAUImDrawList@@UImVec2@@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?RenderBullet@ImGui@@YAXPEAUImDrawList@@UImVec2@@I@Z DD imagerel $LN91+141
	DD	imagerel $LN91+152
	DD	imagerel $chain$1$?RenderBullet@ImGui@@YAXPEAUImDrawList@@UImVec2@@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?PathBezierCubicCurveTo@ImDrawList@@QEAAXAEBUImVec2@@00H@Z DD imagerel $LN26
	DD	imagerel $LN26+130
	DD	imagerel $unwind$?PathBezierCubicCurveTo@ImDrawList@@QEAAXAEBUImVec2@@00H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z DD imagerel $LN88
	DD	imagerel $LN88+59
	DD	imagerel $unwind$?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z DD imagerel $LN88+59
	DD	imagerel $LN88+86
	DD	imagerel $chain$1$?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z DD imagerel $LN88+86
	DD	imagerel $LN88+1209
	DD	imagerel $chain$8$?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z DD imagerel $LN88+1209
	DD	imagerel $LN88+1371
	DD	imagerel $chain$9$?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z DD imagerel $LN88+1371
	DD	imagerel $LN88+1385
	DD	imagerel $chain$10$?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z DD imagerel $LN301
	DD	imagerel $LN301+78
	DD	imagerel $unwind$?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z DD imagerel $LN301+78
	DD	imagerel $LN301+170
	DD	imagerel $chain$5$?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z DD imagerel $LN301+170
	DD	imagerel $LN301+1077
	DD	imagerel $chain$8$?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z DD imagerel $LN301+1077
	DD	imagerel $LN301+1555
	DD	imagerel $chain$10$?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$11$?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z DD imagerel $LN301+1555
	DD	imagerel $LN301+2099
	DD	imagerel $chain$11$?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$12$?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z DD imagerel $LN301+2099
	DD	imagerel $LN301+2126
	DD	imagerel $chain$12$?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$13$?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z DD imagerel $LN301+2126
	DD	imagerel $LN301+3345
	DD	imagerel $chain$13$?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$14$?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z DD imagerel $LN301+3345
	DD	imagerel $LN301+3888
	DD	imagerel $chain$14$?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$15$?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z DD imagerel $LN301+3888
	DD	imagerel $LN301+3902
	DD	imagerel $chain$15$?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z DD imagerel $LN19
	DD	imagerel $LN19+190
	DD	imagerel $unwind$?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AddCircle@ImDrawList@@QEAAXAEBUImVec2@@MIHM@Z DD imagerel $LN19
	DD	imagerel $LN19+218
	DD	imagerel $unwind$?AddCircle@ImDrawList@@QEAAXAEBUImVec2@@MIHM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AddTriangleFilled@ImDrawList@@QEAAXAEBUImVec2@@00I@Z DD imagerel $LN8
	DD	imagerel $LN8+108
	DD	imagerel $unwind$?AddTriangleFilled@ImDrawList@@QEAAXAEBUImVec2@@00I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z DD imagerel $LN20
	DD	imagerel $LN20+133
	DD	imagerel $unwind$?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z DD imagerel $LN20+133
	DD	imagerel $LN20+400
	DD	imagerel $chain$0$?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z DD imagerel $LN20+400
	DD	imagerel $LN20+421
	DD	imagerel $chain$1$?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z DD imagerel $LN37
	DD	imagerel $LN37+263
	DD	imagerel $unwind$?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z DD 041701H
	DD	0a3417H
	DD	070137217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z DD 021H
	DD	imagerel $LN20
	DD	imagerel $LN20+133
	DD	imagerel $unwind$?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z DD 020521H
	DD	036805H
	DD	imagerel $LN20
	DD	imagerel $LN20+133
	DD	imagerel $unwind$?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z DD 082101H
	DD	0c6421H
	DD	0b5421H
	DD	0a3421H
	DD	0701d7221H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AddTriangleFilled@ImDrawList@@QEAAXAEBUImVec2@@00I@Z DD 060f01H
	DD	07540fH
	DD	06340fH
	DD	0600b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AddCircle@ImDrawList@@QEAAXAEBUImVec2@@MIHM@Z DD 041701H
	DD	083417H
	DD	070135217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z DD 041701H
	DD	083417H
	DD	070135217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$15$?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z DD 021H
	DD	imagerel $LN301
	DD	imagerel $LN301+78
	DD	imagerel $unwind$?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$14$?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z DD 021H
	DD	imagerel $LN301+78
	DD	imagerel $LN301+170
	DD	imagerel $chain$5$?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$13$?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z DD 021H
	DD	imagerel $LN301+170
	DD	imagerel $LN301+1077
	DD	imagerel $chain$8$?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$12$?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z DD 021H
	DD	imagerel $LN301+1077
	DD	imagerel $LN301+1555
	DD	imagerel $chain$10$?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$11$?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z DD 020621H
	DD	06d806H
	DD	imagerel $LN301+1077
	DD	imagerel $LN301+1555
	DD	imagerel $chain$10$?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z DD 041721H
	DD	08b817H
	DD	09a809H
	DD	imagerel $LN301+170
	DD	imagerel $LN301+1077
	DD	imagerel $chain$8$?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z DD 061721H
	DD	07c817H
	DD	01cd411H
	DD	01e6404H
	DD	imagerel $LN301+78
	DD	imagerel $LN301+170
	DD	imagerel $chain$5$?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z DD 0c4521H
	DD	0255445H
	DD	0a9831H
	DD	0b881fH
	DD	0c7812H
	DD	0d6809H
	DD	01dc404H
	DD	imagerel $LN301
	DD	imagerel $LN301+78
	DD	imagerel $unwind$?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z DD 061801H
	DD	01f0118H
	DD	0e00ff011H
	DD	0300c700dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z DD 021H
	DD	imagerel $LN88
	DD	imagerel $LN88+59
	DD	imagerel $unwind$?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z DD 021H
	DD	imagerel $LN88+59
	DD	imagerel $LN88+86
	DD	imagerel $chain$1$?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z DD 0e3d21H
	DD	03a83dH
	DD	067835H
	DD	076828H
	DD	010d420H
	DD	019c417H
	DD	0176410H
	DD	0165404H
	DD	imagerel $LN88+59
	DD	imagerel $LN88+86
	DD	imagerel $chain$1$?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z DD 040a21H
	DD	04980aH
	DD	058805H
	DD	imagerel $LN88
	DD	imagerel $LN88+59
	DD	imagerel $unwind$?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z DD 061a01H
	DD	011011aH
	DD	0e011f013H
	DD	0300e700fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?PathBezierCubicCurveTo@ImDrawList@@QEAAXAEBUImVec2@@00H@Z DD 020601H
	DD	03002b206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?RenderBullet@ImGui@@YAXPEAUImDrawList@@UImVec2@@I@Z DD 021H
	DD	imagerel $LN91
	DD	imagerel $LN91+94
	DD	imagerel $unwind$?RenderBullet@ImGui@@YAXPEAUImDrawList@@UImVec2@@I@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?RenderBullet@ImGui@@YAXPEAUImDrawList@@UImVec2@@I@Z DD 020521H
	DD	0c3405H
	DD	imagerel $LN91
	DD	imagerel $LN91+94
	DD	imagerel $unwind$?RenderBullet@ImGui@@YAXPEAUImDrawList@@UImVec2@@I@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?RenderBullet@ImGui@@YAXPEAUImDrawList@@UImVec2@@I@Z DD 041701H
	DD	0d6417H
	DD	070137217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?StyleColorsDark@ImGui@@YAXPEAUImGuiStyle@@@Z DD 071301H
	DD	08813H
	DD	01780eH
	DD	026809H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AddDrawListToDrawDataEx@ImGui@@YAXPEAUImDrawData@@PEAU?$ImVector@PEAUImDrawList@@@@PEAUImDrawList@@@Z DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?RenderRectFilledWithHole@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@1IM@Z DD 0156801H
	DD	05a868H
	DD	06985dH
	DD	078852H
	DD	087847H
	DD	09683bH
	DD	01c341dH
	DD	014011dH
	DD	0e010f012H
	DD	0c00cd00eH
	DD	06009700aH
	DD	05008H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImBezierCubicCalc@@YA?AUImVec2@@AEBU1@000M@Z DD 032201H
	DD	06822H
	DD	02204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Clear@ImDrawData@@QEAAXXZ DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0ImFontAtlas@@QEAA@XZ DB 00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0ImFontAtlas@@QEAA@XZ DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0ImFontAtlas@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0ImFontAtlas@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???0ImFontAtlas@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0ImFontAtlas@@QEAA@XZ DB 028H
	DD	imagerel $stateUnwindMap$??0ImFontAtlas@@QEAA@XZ
	DD	imagerel $ip2state$??0ImFontAtlas@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImFontAtlas@@QEAA@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0ImFontAtlas@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1ImFontAtlas@@QEAA@XZ DB 04H
	DB	':'
	DB	00H
	DB	'M', 02H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1ImFontAtlas@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1ImFontAtlas@@QEAA@XZ DB 068H
	DD	imagerel $stateUnwindMap$??1ImFontAtlas@@QEAA@XZ
	DD	imagerel $ip2state$??1ImFontAtlas@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ImFontAtlas@@QEAA@XZ DD 0a1a19H
	DD	09e41aH
	DD	08741aH
	DD	07641aH
	DD	06341aH
	DD	0f016321aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1ImFontAtlas@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0ImDrawListSharedData@@QEAA@XZ DB 00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0ImDrawListSharedData@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0ImDrawListSharedData@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0ImDrawListSharedData@@QEAA@XZ DB 028H
	DD	imagerel $stateUnwindMap$??0ImDrawListSharedData@@QEAA@XZ
	DD	imagerel $ip2state$??0ImDrawListSharedData@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImDrawListSharedData@@QEAA@XZ DD 0e2511H
	DD	029825H
	DD	03881fH
	DD	047819H
	DD	056814H
	DD	010640fH
	DD	0f340fH
	DD	0700bb20fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0ImDrawListSharedData@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?SetCircleTessellationMaxError@ImDrawListSharedData@@QEAAXM@Z DD 021H
	DD	imagerel $LN31
	DD	imagerel $LN31+25
	DD	imagerel $unwind$?SetCircleTessellationMaxError@ImDrawListSharedData@@QEAAXM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?SetCircleTessellationMaxError@ImDrawListSharedData@@QEAAXM@Z DD 0a2f21H
	DD	02782fH
	DD	036822H
	DD	0c7416H
	DD	0b540cH
	DD	0a3405H
	DD	imagerel $LN31
	DD	imagerel $LN31+25
	DD	imagerel $unwind$?SetCircleTessellationMaxError@ImDrawListSharedData@@QEAAXM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SetCircleTessellationMaxError@ImDrawListSharedData@@QEAAXM@Z DD 020601H
	DD	060027206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?PushClipRect@ImDrawList@@QEAAXAEBUImVec2@@0_N@Z DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?PushTextureID@ImDrawList@@QEAAXPEAX@Z DD 060f01H
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z DD 020021H
	DD	0d7400H
	DD	imagerel $LN43
	DD	imagerel $LN43+49
	DD	imagerel $unwind$?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z DD 021H
	DD	imagerel $LN43+49
	DD	imagerel $LN43+64
	DD	imagerel $chain$1$?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z DD 020521H
	DD	046805H
	DD	imagerel $LN43+49
	DD	imagerel $LN43+64
	DD	imagerel $chain$1$?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z DD 040a21H
	DD	0d740aH
	DD	0c3405H
	DD	imagerel $LN43
	DD	imagerel $LN43+49
	DD	imagerel $unwind$?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z DD 061d01H
	DD	0f641dH
	DD	0e541dH
	DD	0e019921dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z DD 010401H
	DD	0c204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AddText@ImDrawList@@QEAAXAEBUImVec2@@IPEBD1@Z DD 010401H
	DD	0c204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z DD 021H
	DD	imagerel $LN17
	DD	imagerel $LN17+46
	DD	imagerel $unwind$?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z DD 020521H
	DD	0a6405H
	DD	imagerel $LN17
	DD	imagerel $LN17+46
	DD	imagerel $unwind$?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z DD 081301H
	DD	0c5413H
	DD	0b3413H
	DD	0f00f5213H
	DD	0700be00dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$13$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD 080021H
	DD	068800H
	DD	077800H
	DD	086800H
	DD	0183400H
	DD	imagerel $LN91
	DD	imagerel $LN91+109
	DD	imagerel $unwind$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$12$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD 021H
	DD	imagerel $LN91
	DD	imagerel $LN91+109
	DD	imagerel $unwind$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$11$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD 021H
	DD	imagerel $LN91+109
	DD	imagerel $LN91+179
	DD	imagerel $chain$3$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD 020021H
	DD	0147400H
	DD	imagerel $LN91+179
	DD	imagerel $LN91+187
	DD	imagerel $chain$4$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD 060021H
	DD	012d400H
	DD	013c400H
	DD	0147400H
	DD	imagerel $LN91+179
	DD	imagerel $LN91+187
	DD	imagerel $chain$4$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD 082421H
	DD	012d424H
	DD	013c41cH
	DD	0147414H
	DD	01b6408H
	DD	imagerel $LN91+179
	DD	imagerel $LN91+187
	DD	imagerel $chain$4$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD 020821H
	DD	0195408H
	DD	imagerel $LN91+109
	DD	imagerel $LN91+179
	DD	imagerel $chain$3$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD 082721H
	DD	068827H
	DD	077815H
	DD	086810H
	DD	0183408H
	DD	imagerel $LN91
	DD	imagerel $LN91+109
	DD	imagerel $unwind$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD 082901H
	DD	04a829H
	DD	05981cH
	DD	015010bH
	DD	0e002f004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?PathArcToFast@ImDrawList@@QEAAXAEBUImVec2@@MHH@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AddDrawCmd@ImDrawList@@QEAAXXZ DD 063d01H
	DD	06783dH
	DD	076810H
	DD	03002f209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_ResetForNewFrame@ImDrawList@@QEAAXXZ DD 060f01H
	DD	0f640fH
	DD	0e340fH
	DD	0700bb20fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_ClearFreeMemory@ImDrawList@@QEAAXXZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ DD 021H
	DD	imagerel $LN59
	DD	imagerel $LN59+12
	DD	imagerel $unwind$?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ DD 021H
	DD	imagerel $LN59+12
	DD	imagerel $LN59+31
	DD	imagerel $chain$0$?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ DD 040a21H
	DD	08e40aH
	DD	066405H
	DD	imagerel $LN59+12
	DD	imagerel $LN59+31
	DD	imagerel $chain$0$?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ DD 020521H
	DD	077405H
	DD	imagerel $LN59
	DD	imagerel $LN59+12
	DD	imagerel $unwind$?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ DD 040a01H
	DD	09340aH
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?Split@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z DD 021H
	DD	imagerel $LN61
	DD	imagerel $LN61+112
	DD	imagerel $unwind$?Split@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?Split@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z DD 040f21H
	DD	0df40fH
	DD	0ac405H
	DD	imagerel $LN61
	DD	imagerel $LN61+112
	DD	imagerel $unwind$?Split@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Split@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z DD 060b01H
	DD	0e007320bH
	DD	060047005H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z DD 021H
	DD	imagerel $LN126
	DD	imagerel $LN126+31
	DD	imagerel $unwind$?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z DD 021H
	DD	imagerel $LN126+31
	DD	imagerel $LN126+38
	DD	imagerel $chain$0$?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z DD 0a1421H
	DD	07e414H
	DD	08c410H
	DD	09740cH
	DD	0a6408H
	DD	0b5404H
	DD	imagerel $LN126+31
	DD	imagerel $LN126+38
	DD	imagerel $chain$0$?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z DD 020421H
	DD	0c3404H
	DD	imagerel $LN126
	DD	imagerel $LN126+31
	DD	imagerel $unwind$?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z DD 030f01H
	DD	0f00bc20fH
	DD	0d009H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SetCurrentChannel@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1ImFont@@QEAA@XZ DB 02H
	DB	012H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1ImFont@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1ImFont@@QEAA@XZ DB 068H
	DD	imagerel $stateUnwindMap$??1ImFont@@QEAA@XZ
	DD	imagerel $ip2state$??1ImFont@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ImFont@@QEAA@XZ DD 020619H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1ImFont@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$14$?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z DD 021H
	DD	imagerel $LN77
	DD	imagerel $LN77+23
	DD	imagerel $unwind$?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$13$?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z DD 040021H
	DD	068800H
	DD	077800H
	DD	imagerel $LN77
	DD	imagerel $LN77+23
	DD	imagerel $unwind$?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$12$?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z DD 060021H
	DD	068800H
	DD	077800H
	DD	086800H
	DD	imagerel $LN77
	DD	imagerel $LN77+23
	DD	imagerel $unwind$?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$11$?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z DD 021H
	DD	imagerel $LN77+23
	DD	imagerel $LN77+163
	DD	imagerel $chain$9$?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z DD 020821H
	DD	0165408H
	DD	imagerel $LN77+23
	DD	imagerel $LN77+163
	DD	imagerel $chain$9$?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z DD 0143a21H
	DD	03b83aH
	DD	04a835H
	DD	059830H
	DD	06882bH
	DD	077823H
	DD	08681fH
	DD	012f418H
	DD	019e414H
	DD	018c410H
	DD	0177404H
	DD	imagerel $LN77
	DD	imagerel $LN77+23
	DD	imagerel $unwind$?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z DD 040c01H
	DD	013010cH
	DD	030046005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?RenderChar@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IG@Z DD 021H
	DD	imagerel $LN26
	DD	imagerel $LN26+115
	DD	imagerel $unwind$?RenderChar@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IG@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?RenderChar@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IG@Z DD 061e21H
	DD	06781eH
	DD	076813H
	DD	0137408H
	DD	imagerel $LN26
	DD	imagerel $LN26+115
	DD	imagerel $unwind$?RenderChar@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IG@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?RenderChar@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IG@Z DD 062901H
	DD	058829H
	DD	014340dH
	DD	06006f20dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?AddRectFilledMultiColor@ImDrawList@@QEAAXAEBUImVec2@@0IIII@Z DD 021H
	DD	imagerel $LN30
	DD	imagerel $LN30+94
	DD	imagerel $unwind$?AddRectFilledMultiColor@ImDrawList@@QEAAXAEBUImVec2@@0IIII@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?AddRectFilledMultiColor@ImDrawList@@QEAAXAEBUImVec2@@0IIII@Z DD 040a21H
	DD	02780aH
	DD	036805H
	DD	imagerel $LN30
	DD	imagerel $LN30+94
	DD	imagerel $unwind$?AddRectFilledMultiColor@ImDrawList@@QEAAXAEBUImVec2@@0IIII@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AddRectFilledMultiColor@ImDrawList@@QEAAXAEBUImVec2@@0IIII@Z DD 0c1e01H
	DD	0f741eH
	DD	0e641eH
	DD	0d541eH
	DD	0c341eH
	DD	0f01a721eH
	DD	0c016e018H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AddTriangle@ImDrawList@@QEAAXAEBUImVec2@@00IM@Z DD 060f01H
	DD	09540fH
	DD	08340fH
	DD	0600b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AddBezierCubic@ImDrawList@@QEAAXAEBUImVec2@@000IMH@Z DD 060f01H
	DD	09540fH
	DD	08340fH
	DD	0600b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_CalcCircleAutoSegmentCount@ImDrawList@@QEBAHM@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImClamp@@YA?AUImVec2@@AEBU1@0U1@@Z DD 010401H
	DD	02204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Create@ImBitVector@@QEAAXH@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Clear@ImBitVector@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$stbrp_init_target DD 021H
	DD	imagerel stbrp_init_target
	DD	imagerel stbrp_init_target+88
	DD	imagerel $unwind$stbrp_init_target
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$stbrp_init_target DD 040921H
	DD	07809H
	DD	016805H
	DD	imagerel stbrp_init_target
	DD	imagerel stbrp_init_target+88
	DD	imagerel $unwind$stbrp_init_target
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbrp_init_target DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0e016321aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z DD 021H
	DD	imagerel ?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z
	DD	imagerel ?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z+40
	DD	imagerel $unwind$?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z DD 020521H
	DD	033405H
	DD	imagerel ?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z
	DD	imagerel ?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z+40
	DD	imagerel $unwind$?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z DD 081301H
	DD	067413H
	DD	056413H
	DD	045413H
	DD	0e011f013H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z DD 021H
	DD	imagerel ?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z
	DD	imagerel ?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z+116
	DD	imagerel $unwind$?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z DD 082c21H
	DD	012642cH
	DD	0ff41cH
	DD	010e414H
	DD	011d408H
	DD	imagerel ?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z
	DD	imagerel ?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z+116
	DD	imagerel $unwind$?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z DD 061601H
	DD	0130116H
	DD	0700dc00fH
	DD	0300b500cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbrp__skyline_pack_rectangle@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$stbrp_pack_rects DD 021H
	DD	imagerel stbrp_pack_rects
	DD	imagerel stbrp_pack_rects+12
	DD	imagerel $unwind$stbrp_pack_rects
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$stbrp_pack_rects DD 021H
	DD	imagerel stbrp_pack_rects+12
	DD	imagerel stbrp_pack_rects+104
	DD	imagerel $chain$0$stbrp_pack_rects
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$stbrp_pack_rects DD 081b21H
	DD	0e641bH
	DD	06c413H
	DD	0d540eH
	DD	0c3405H
	DD	imagerel stbrp_pack_rects+12
	DD	imagerel stbrp_pack_rects+104
	DD	imagerel $chain$0$stbrp_pack_rects
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$stbrp_pack_rects DD 020521H
	DD	077405H
	DD	imagerel stbrp_pack_rects
	DD	imagerel stbrp_pack_rects+12
	DD	imagerel $unwind$stbrp_pack_rects
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbrp_pack_rects DD 040a01H
	DD	0f006720aH
	DD	0d002e004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z DD 021H
	DD	imagerel ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z
	DD	imagerel ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z+136
	DD	imagerel $unwind$?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z DD 020521H
	DD	027405H
	DD	imagerel ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z
	DD	imagerel ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z+136
	DD	imagerel $unwind$?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z DD 010201H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z DD 021H
	DD	imagerel ?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z
	DD	imagerel ?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z+323
	DD	imagerel $unwind$?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z DD 020021H
	DD	03400H
	DD	imagerel ?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z
	DD	imagerel ?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z+323
	DD	imagerel $unwind$?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z DD 020021H
	DD	03400H
	DD	imagerel ?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z
	DD	imagerel ?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z+323
	DD	imagerel $unwind$?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z DD 020021H
	DD	03400H
	DD	imagerel ?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z
	DD	imagerel ?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z+323
	DD	imagerel $unwind$?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z DD 020021H
	DD	03400H
	DD	imagerel ?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z
	DD	imagerel ?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z+323
	DD	imagerel $unwind$?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z DD 020421H
	DD	03404H
	DD	imagerel ?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z
	DD	imagerel ?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z+323
	DD	imagerel $unwind$?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbtt__dict_get@@YA?AUstbtt__buf@@PEAU1@H@Z DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0e016321aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbtt__dict_get_ints@@YAXPEAUstbtt__buf@@HHPEAI@Z DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z DD 071001H
	DD	056410H
	DD	045410H
	DD	023410H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbtt__find_table@@YAIPEAEIPEBD@Z DD 040a01H
	DD	02740aH
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbtt__get_subrs@@YA?AUstbtt__buf@@U1@0@Z DD 082119H
	DD	0135412H
	DD	0103412H
	DD	0e00eb212H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	050H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbtt_InitFont_internal@@YAHPEAUstbtt_fontinfo@@PEAEH@Z DD 0d3219H
	DD	096824H
	DD	01f341cH
	DD	014011cH
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	088H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$stbtt_FindGlyphIndex DD 021H
	DD	imagerel stbtt_FindGlyphIndex
	DD	imagerel stbtt_FindGlyphIndex+301
	DD	imagerel $unwind$stbtt_FindGlyphIndex
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$stbtt_FindGlyphIndex DD 020521H
	DD	05e405H
	DD	imagerel stbtt_FindGlyphIndex
	DD	imagerel stbtt_FindGlyphIndex+301
	DD	imagerel $unwind$stbtt_FindGlyphIndex
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbtt_FindGlyphIndex DD 0a1601H
	DD	086416H
	DD	075416H
	DD	063416H
	DD	0d014f016H
	DD	07010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbtt_GetGlyphBox DD 061b19H
	DD	0f008b20cH
	DD	07004e006H
	DD	030026003H
	DD	imagerel __GSHandlerCheck
	DD	058H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z DD 021H
	DD	imagerel ?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z
	DD	imagerel ?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z+24
	DD	imagerel $unwind$?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z DD 020421H
	DD	03404H
	DD	imagerel ?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z
	DD	imagerel ?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z+24
	DD	imagerel $unwind$?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbtt__GetGlyphShapeTT@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z DD 01d6519H
	DD	0be853H
	DD	0cd84bH
	DD	0dc843H
	DD	0eb83bH
	DD	0fa833H
	DD	010982bH
	DD	0118826H
	DD	0127821H
	DD	013681dH
	DD	0333419H
	DD	0280119H
	DD	0e010f012H
	DD	0c00cd00eH
	DD	06009700aH
	DD	05008H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z DD 021H
	DD	imagerel ?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z
	DD	imagerel ?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z+25
	DD	imagerel $unwind$?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z DD 040a21H
	DD	03740aH
	DD	023405H
	DD	imagerel ?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z
	DD	imagerel ?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z+25
	DD	imagerel $unwind$?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z DD 010201H
	DD	06002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbtt__csctx_rmove_to@@YAXPEAUstbtt__csctx@@MM@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z DD 030c01H
	DD	04680cH
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbtt__get_subr@@YA?AUstbtt__buf@@U1@H@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbtt__cid_get_glyph_subrs@@YA?AUstbtt__buf@@PEBUstbtt_fontinfo@@H@Z DD 0a1801H
	DD	0106418H
	DD	0f5418H
	DD	0e3418H
	DD	0f0149218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z DD 01f7801H
	DD	0297878H
	DD	021f874H
	DD	022e86cH
	DD	023d864H
	DD	024c85cH
	DD	025b852H
	DD	026a847H
	DD	027983bH
	DD	0288833H
	DD	02a682bH
	DD	0603427H
	DD	0560127H
	DD	0e017f019H
	DD	0c013d015H
	DD	060107011H
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbtt__GetGlyphShapeT2@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z DD 072119H
	DD	01b340fH
	DD	014010fH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbtt__GetGlyphInfoT2@@YAHPEBUstbtt_fontinfo@@HPEAH111@Z DD 061b19H
	DD	0f008b20cH
	DD	07004e006H
	DD	030026003H
	DD	imagerel __GSHandlerCheck
	DD	058H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$stbtt_GetGlyphShape DD 021H
	DD	imagerel stbtt_GetGlyphShape
	DD	imagerel stbtt_GetGlyphShape+56
	DD	imagerel $unwind$stbtt_GetGlyphShape
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$stbtt_GetGlyphShape DD 020821H
	DD	01b3408H
	DD	imagerel stbtt_GetGlyphShape
	DD	imagerel stbtt_GetGlyphShape+56
	DD	imagerel $unwind$stbtt_GetGlyphShape
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbtt_GetGlyphShape DD 051d19H
	DD	014010bH
	DD	060037004H
	DD	05002H
	DD	imagerel __GSHandlerCheck
	DD	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbtt_GetGlyphHMetrics DD 091601H
	DD	05e416H
	DD	047416H
	DD	036416H
	DD	023416H
	DD	0f016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbtt_GetFontVMetrics DD 060f01H
	DD	03740fH
	DD	02640aH
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$stbtt_GetGlyphBitmapBoxSubpixel DD 021H
	DD	imagerel stbtt_GetGlyphBitmapBoxSubpixel
	DD	imagerel stbtt_GetGlyphBitmapBoxSubpixel+311
	DD	imagerel $unwind$stbtt_GetGlyphBitmapBoxSubpixel
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$stbtt_GetGlyphBitmapBoxSubpixel DD 020821H
	DD	086808H
	DD	imagerel stbtt_GetGlyphBitmapBoxSubpixel
	DD	imagerel stbtt_GetGlyphBitmapBoxSubpixel+311
	DD	imagerel $unwind$stbtt_GetGlyphBitmapBoxSubpixel
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbtt_GetGlyphBitmapBoxSubpixel DD 0d2d19H
	DD	06881eH
	DD	077818H
	DD	01a3413H
	DD	0120113H
	DD	0e00af00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	058H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbtt_GetGlyphBitmapBox DD 010401H
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbtt__hheap_alloc@@YAPEAXPEAUstbtt__hheap@@_KPEAX@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z DD 021H
	DD	imagerel ?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z
	DD	imagerel ?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z+12
	DD	imagerel $unwind$?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z DD 020521H
	DD	043405H
	DD	imagerel ?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z
	DD	imagerel ?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z+12
	DD	imagerel $unwind$?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbtt__new_active@@YAPEAUstbtt__active_edge@@PEAUstbtt__hheap@@PEAUstbtt__edge@@HMPEAX@Z DD 081b01H
	DD	02681bH
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z DD 021H
	DD	imagerel ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z
	DD	imagerel ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z+27
	DD	imagerel $unwind$?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z DD 020021H
	DD	017800H
	DD	imagerel ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z
	DD	imagerel ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z+27
	DD	imagerel $unwind$?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z DD 040021H
	DD	08800H
	DD	017800H
	DD	imagerel ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z
	DD	imagerel ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z+27
	DD	imagerel $unwind$?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z DD 060021H
	DD	08800H
	DD	017800H
	DD	026800H
	DD	imagerel ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z
	DD	imagerel ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z+27
	DD	imagerel $unwind$?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z DD 063221H
	DD	026832H
	DD	08819H
	DD	017805H
	DD	imagerel ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z
	DD	imagerel ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z+27
	DD	imagerel $unwind$?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z DD 021H
	DD	imagerel ?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z
	DD	imagerel ?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z+105
	DD	imagerel $unwind$?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z DD 020621H
	DD	04f806H
	DD	imagerel ?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z
	DD	imagerel ?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z+105
	DD	imagerel $unwind$?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z DD 0176901H
	DD	06d869H
	DD	07c863H
	DD	09a85eH
	DD	0a9859H
	DD	0b8854H
	DD	0c784fH
	DD	0d6846H
	DD	05e83eH
	DD	08b828H
	DD	01e3418H
	DD	01c0118H
	DD	07011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$17$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z DD 021H
	DD	imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z
	DD	imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+31
	DD	imagerel $unwind$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$16$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z DD 020021H
	DD	062f400H
	DD	imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+31
	DD	imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+37
	DD	imagerel $chain$0$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$15$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z DD 021H
	DD	imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+37
	DD	imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+237
	DD	imagerel $chain$7$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$14$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z DD 0e5c21H
	DD	029d85cH
	DD	02ac84aH
	DD	02bb838H
	DD	02ca826H
	DD	02e8819H
	DD	02f7810H
	DD	0306808H
	DD	imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+37
	DD	imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+237
	DD	imagerel $chain$7$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z DD 0e2e21H
	DD	02d982eH
	DD	062f426H
	DD	063e41fH
	DD	064d418H
	DD	065c411H
	DD	066740aH
	DD	0675404H
	DD	imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+31
	DD	imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+37
	DD	imagerel $chain$0$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z DD 020421H
	DD	06d3404H
	DD	imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z
	DD	imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+31
	DD	imagerel $unwind$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z DD 031d19H
	DD	068010bH
	DD	06004H
	DD	imagerel __GSHandlerCheck
	DD	0280H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z DD 021H
	DD	imagerel ?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z
	DD	imagerel ?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z+16
	DD	imagerel $unwind$?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z DD 020421H
	DD	03404H
	DD	imagerel ?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z
	DD	imagerel ?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z+16
	DD	imagerel $unwind$?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z DD 021H
	DD	imagerel ?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z
	DD	imagerel ?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z+15
	DD	imagerel $unwind$?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z DD 081921H
	DD	04f419H
	DD	0ae414H
	DD	09740cH
	DD	083405H
	DD	imagerel ?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z
	DD	imagerel ?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z+15
	DD	imagerel $unwind$?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z DD 030f01H
	DD	0600b420fH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbtt__sort_edges@@YAXPEAUstbtt__edge@@H@Z DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z DD 021H
	DD	imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z
	DD	imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+276
	DD	imagerel $unwind$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z DD 021H
	DD	imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+276
	DD	imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+295
	DD	imagerel $chain$1$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z DD 021H
	DD	imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+295
	DD	imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+351
	DD	imagerel $chain$2$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z DD 020521H
	DD	0fd405H
	DD	imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+295
	DD	imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+351
	DD	imagerel $chain$2$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z DD 020521H
	DD	0ef405H
	DD	imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+276
	DD	imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+295
	DD	imagerel $chain$1$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z DD 041021H
	DD	010c410H
	DD	0176408H
	DD	imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z
	DD	imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+276
	DD	imagerel $unwind$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z DD 081201H
	DD	066812H
	DD	011010dH
	DD	07004e006H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z DD 021H
	DD	imagerel ?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z
	DD	imagerel ?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z+220
	DD	imagerel $unwind$?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z DD 020521H
	DD	0a8805H
	DD	imagerel ?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z
	DD	imagerel ?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z+220
	DD	imagerel $unwind$?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z DD 0157f01H
	DD	05d87fH
	DD	06c866H
	DD	07b857H
	DD	08a852H
	DD	099849H
	DD	0b7834H
	DD	0c6821H
	DD	01d6413H
	DD	01c3413H
	DD	01a0113H
	DD	0700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z DD 021H
	DD	imagerel ?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z
	DD	imagerel ?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z+421
	DD	imagerel $unwind$?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z DD 020921H
	DD	08d809H
	DD	imagerel ?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z
	DD	imagerel ?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z+421
	DD	imagerel $unwind$?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z DD 019a101H
	DD	06f8a1H
	DD	07e87aH
	DD	09c86fH
	DD	0ab866H
	DD	0ba861H
	DD	0c985cH
	DD	0d8854H
	DD	0e7840H
	DD	0f6839H
	DD	023641dH
	DD	022341dH
	DD	020011dH
	DD	07016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z DD 080021H
	DD	0a9800H
	DD	0b8800H
	DD	0c7800H
	DD	0d6800H
	DD	imagerel ?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z
	DD	imagerel ?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z+212
	DD	imagerel $unwind$?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z DD 021H
	DD	imagerel ?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z
	DD	imagerel ?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z+212
	DD	imagerel $unwind$?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z DD 082221H
	DD	0a9822H
	DD	0b8819H
	DD	0c7810H
	DD	0d6808H
	DD	imagerel ?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z
	DD	imagerel ?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z+212
	DD	imagerel $unwind$?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z DD 0d3219H
	DD	09a820H
	DD	0253417H
	DD	01c0117H
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	080H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbtt_Rasterize DD 082701H
	DD	067827H
	DD	076814H
	DD	012640fH
	DD	07008f20fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbtt_MakeGlyphBitmapSubpixel DD 0113819H
	DD	0a9826H
	DD	0b8821H
	DD	0c781cH
	DD	0d6818H
	DD	01c0114H
	DD	0e00bf00dH
	DD	07007c009H
	DD	050056006H
	DD	03004H
	DD	imagerel __GSHandlerCheck
	DD	098H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbtt_PackBegin DD 0a1a01H
	DD	0b741aH
	DD	0a641aH
	DD	09541aH
	DD	08341aH
	DD	0e016521aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbtt_PackEnd DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?stbtt__h_prefilter@@YAXPEAEHHHI@Z DD 021H
	DD	imagerel ?stbtt__h_prefilter@@YAXPEAEHHHI@Z
	DD	imagerel ?stbtt__h_prefilter@@YAXPEAEHHHI@Z+42
	DD	imagerel $unwind$?stbtt__h_prefilter@@YAXPEAEHHHI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?stbtt__h_prefilter@@YAXPEAEHHHI@Z DD 061421H
	DD	06f414H
	DD	0ec40cH
	DD	0d5405H
	DD	imagerel ?stbtt__h_prefilter@@YAXPEAEHHHI@Z
	DD	imagerel ?stbtt__h_prefilter@@YAXPEAEHHHI@Z+42
	DD	imagerel $unwind$?stbtt__h_prefilter@@YAXPEAEHHHI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbtt__h_prefilter@@YAXPEAEHHHI@Z DD 052119H
	DD	0e00e6212H
	DD	0600b700cH
	DD	0300aH
	DD	imagerel __GSHandlerCheck
	DD	028H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?stbtt__v_prefilter@@YAXPEAEHHHI@Z DD 021H
	DD	imagerel ?stbtt__v_prefilter@@YAXPEAEHHHI@Z
	DD	imagerel ?stbtt__v_prefilter@@YAXPEAEHHHI@Z+45
	DD	imagerel $unwind$?stbtt__v_prefilter@@YAXPEAEHHHI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?stbtt__v_prefilter@@YAXPEAEHHHI@Z DD 041f21H
	DD	0ec41fH
	DD	0d5405H
	DD	imagerel ?stbtt__v_prefilter@@YAXPEAEHHHI@Z
	DD	imagerel ?stbtt__v_prefilter@@YAXPEAEHHHI@Z+45
	DD	imagerel $unwind$?stbtt__v_prefilter@@YAXPEAEHHHI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbtt__v_prefilter@@YAXPEAEHHHI@Z DD 062219H
	DD	0f00f5213H
	DD	0700be00dH
	DD	03009600aH
	DD	imagerel __GSHandlerCheck
	DD	028H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$stbtt_PackFontRangesRenderIntoRects DD 021H
	DD	imagerel stbtt_PackFontRangesRenderIntoRects+276
	DD	imagerel stbtt_PackFontRangesRenderIntoRects+437
	DD	imagerel $chain$1$stbtt_PackFontRangesRenderIntoRects
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$stbtt_PackFontRangesRenderIntoRects DD 0a3621H
	DD	0157836H
	DD	016682eH
	DD	02ec426H
	DD	039741eH
	DD	0ee809H
	DD	imagerel stbtt_PackFontRangesRenderIntoRects+276
	DD	imagerel stbtt_PackFontRangesRenderIntoRects+437
	DD	imagerel $chain$1$stbtt_PackFontRangesRenderIntoRects
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$stbtt_PackFontRangesRenderIntoRects DD 046021H
	DD	012a860H
	DD	011b809H
	DD	imagerel stbtt_PackFontRangesRenderIntoRects
	DD	imagerel stbtt_PackFontRangesRenderIntoRects+276
	DD	imagerel $unwind$stbtt_PackFontRangesRenderIntoRects
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbtt_PackFontRangesRenderIntoRects DD 0104019H
	DD	0fd832H
	DD	010c82aH
	DD	0139822H
	DD	014881dH
	DD	02f0118H
	DD	0e00af00cH
	DD	06006d008H
	DD	050043005H
	DD	imagerel __GSHandlerCheck
	DD	0d8H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AddCallback@ImDrawList@@QEAAXP6AXPEBU1@PEBUImDrawCmd@@@ZPEAX@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_OnChangedClipRect@ImDrawList@@QEAAXXZ DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0e016321aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_OnChangedTextureID@ImDrawList@@QEAAXXZ DD 084d01H
	DD	06644dH
	DD	08540fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?PrimReserve@ImDrawList@@QEAAXHH@Z DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0f0143218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?PrimRect@ImDrawList@@QEAAXAEBUImVec2@@0I@Z DD 032c01H
	DD	0682cH
	DD	02204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?PrimRectUV@ImDrawList@@QEAAXAEBUImVec2@@000I@Z DD 0a4f01H
	DD	0984fH
	DD	018845H
	DD	027834H
	DD	03682aH
	DD	030027206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z DD 021H
	DD	imagerel $LN59
	DD	imagerel $LN59+73
	DD	imagerel $unwind$?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z DD 021H
	DD	imagerel $LN59+73
	DD	imagerel $LN59+86
	DD	imagerel $chain$1$?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z DD 040a21H
	DD	06d40aH
	DD	0fc405H
	DD	imagerel $LN59+73
	DD	imagerel $LN59+86
	DD	imagerel $chain$1$?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z DD 040d21H
	DD	0d640dH
	DD	0c3405H
	DD	imagerel $LN59
	DD	imagerel $LN59+73
	DD	imagerel $unwind$?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z DD 072601H
	DD	026826H
	DD	0f007620bH
	DD	07003e005H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD 021H
	DD	imagerel $LN27
	DD	imagerel $LN27+67
	DD	imagerel $unwind$?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD 021H
	DD	imagerel $LN27+67
	DD	imagerel $LN27+110
	DD	imagerel $chain$1$?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD 061921H
	DD	03a819H
	DD	06780aH
	DD	076805H
	DD	imagerel $LN27+67
	DD	imagerel $LN27+110
	DD	imagerel $chain$1$?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD 041721H
	DD	0137417H
	DD	0126408H
	DD	imagerel $LN27
	DD	imagerel $LN27+67
	DD	imagerel $unwind$?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD 082c01H
	DD	04982cH
	DD	05881fH
	DD	014340dH
	DD	05006f20dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?PathBezierCubicCurveToCasteljau@@YAXPEAU?$ImVector@UImVec2@@@@MMMMMMMMMH@Z DD 019a901H
	DD	07f8a9H
	DD	08e895H
	DD	09d87aH
	DD	0ac861H
	DD	0bb858H
	DD	0ca84fH
	DD	0d9838H
	DD	0e8829H
	DD	0f7824H
	DD	010681dH
	DD	0243419H
	DD	0220119H
	DD	07012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z DD 021H
	DD	imagerel $LN159+271
	DD	imagerel $LN159+312
	DD	imagerel $chain$1$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z DD 020021H
	DD	0146400H
	DD	imagerel $LN159+271
	DD	imagerel $LN159+312
	DD	imagerel $chain$1$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z DD 021H
	DD	imagerel $LN159+271
	DD	imagerel $LN159+312
	DD	imagerel $chain$1$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z DD 021H
	DD	imagerel $LN159+312
	DD	imagerel $LN159+320
	DD	imagerel $chain$2$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z DD 020021H
	DD	048800H
	DD	imagerel $LN159+312
	DD	imagerel $LN159+320
	DD	imagerel $chain$2$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z DD 040b21H
	DD	04880bH
	DD	057805H
	DD	imagerel $LN159+312
	DD	imagerel $LN159+320
	DD	imagerel $chain$2$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z DD 020821H
	DD	0146408H
	DD	imagerel $LN159+271
	DD	imagerel $LN159+312
	DD	imagerel $chain$1$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z DD 041021H
	DD	0157410H
	DD	0123408H
	DD	imagerel $LN159
	DD	imagerel $LN159+271
	DD	imagerel $unwind$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z DD 082e01H
	DD	03982eH
	DD	066825H
	DD	0f006d20aH
	DD	05002e004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?AddImageRounded@ImDrawList@@QEAAXPEAXAEBUImVec2@@111IMH@Z DD 021H
	DD	imagerel $LN20
	DD	imagerel $LN20+72
	DD	imagerel $unwind$?AddImageRounded@ImDrawList@@QEAAXPEAXAEBUImVec2@@111IMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?AddImageRounded@ImDrawList@@QEAAXPEAXAEBUImVec2@@111IMH@Z DD 040a21H
	DD	0de40aH
	DD	0c3405H
	DD	imagerel $LN20
	DD	imagerel $LN20+72
	DD	imagerel $unwind$?AddImageRounded@ImDrawList@@QEAAXPEAXAEBUImVec2@@111IMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AddImageRounded@ImDrawList@@QEAAXPEAXAEBUImVec2@@111IMH@Z DD 081301H
	DD	0f6413H
	DD	0e5413H
	DD	0f00f7213H
	DD	0700bc00dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?ShadeVertsLinearColorGradientKeepAlpha@ImGui@@YAXPEAUImDrawList@@HHUImVec2@@1II@Z DD 021H
	DD	imagerel $LN56
	DD	imagerel $LN56+223
	DD	imagerel $unwind$?ShadeVertsLinearColorGradientKeepAlpha@ImGui@@YAXPEAUImDrawList@@HHUImVec2@@1II@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?ShadeVertsLinearColorGradientKeepAlpha@ImGui@@YAXPEAUImDrawList@@HHUImVec2@@1II@Z DD 0a3221H
	DD	06a832H
	DD	079829H
	DD	08881fH
	DD	097813H
	DD	0a6808H
	DD	imagerel $LN56
	DD	imagerel $LN56+223
	DD	imagerel $unwind$?ShadeVertsLinearColorGradientKeepAlpha@ImGui@@YAXPEAUImDrawList@@HHUImVec2@@1II@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ShadeVertsLinearColorGradientKeepAlpha@ImGui@@YAXPEAUImDrawList@@HHUImVec2@@1II@Z DD 0116901H
	DD	01f869H
	DD	02e84dH
	DD	03d83cH
	DD	04c82cH
	DD	05b81cH
	DD	016010eH
	DD	07005e007H
	DD	050036004H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ShadeVertsLinearUV@ImGui@@YAXPEAUImDrawList@@HHAEBUImVec2@@111_N@Z DD 095d01H
	DD	0985dH
	DD	018855H
	DD	027818H
	DD	036813H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?ClearInputData@ImFontAtlas@@QEAAXXZ DD 021H
	DD	imagerel $LN79
	DD	imagerel $LN79+12
	DD	imagerel $unwind$?ClearInputData@ImFontAtlas@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?ClearInputData@ImFontAtlas@@QEAAXXZ DD 020021H
	DD	08e400H
	DD	imagerel $LN79
	DD	imagerel $LN79+12
	DD	imagerel $unwind$?ClearInputData@ImFontAtlas@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?ClearInputData@ImFontAtlas@@QEAAXXZ DD 021H
	DD	imagerel $LN79+12
	DD	imagerel $LN79+32
	DD	imagerel $chain$1$?ClearInputData@ImFontAtlas@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?ClearInputData@ImFontAtlas@@QEAAXXZ DD 020521H
	DD	077405H
	DD	imagerel $LN79+12
	DD	imagerel $LN79+32
	DD	imagerel $chain$1$?ClearInputData@ImFontAtlas@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?ClearInputData@ImFontAtlas@@QEAAXXZ DD 040d21H
	DD	08e40dH
	DD	066405H
	DD	imagerel $LN79
	DD	imagerel $LN79+12
	DD	imagerel $unwind$?ClearInputData@ImFontAtlas@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ClearInputData@ImFontAtlas@@QEAAXXZ DD 040a01H
	DD	09340aH
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ClearTexData@ImFontAtlas@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?ClearFonts@ImFontAtlas@@QEAAXXZ DD 021H
	DD	imagerel $LN46
	DD	imagerel $LN46+11
	DD	imagerel $unwind$?ClearFonts@ImFontAtlas@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?ClearFonts@ImFontAtlas@@QEAAXXZ DD 021H
	DD	imagerel $LN46+11
	DD	imagerel $LN46+26
	DD	imagerel $chain$0$?ClearFonts@ImFontAtlas@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?ClearFonts@ImFontAtlas@@QEAAXXZ DD 040c21H
	DD	08740cH
	DD	076405H
	DD	imagerel $LN46+11
	DD	imagerel $LN46+26
	DD	imagerel $chain$0$?ClearFonts@ImFontAtlas@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?ClearFonts@ImFontAtlas@@QEAAXXZ DD 020521H
	DD	063405H
	DD	imagerel $LN46
	DD	imagerel $LN46+11
	DD	imagerel $unwind$?ClearFonts@ImFontAtlas@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ClearFonts@ImFontAtlas@@QEAAXXZ DD 040b01H
	DD	09540bH
	DD	0e007320bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?Clear@ImFontAtlas@@QEAAXXZ DD 021H
	DD	imagerel $LN48
	DD	imagerel $LN48+11
	DD	imagerel $unwind$?Clear@ImFontAtlas@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?Clear@ImFontAtlas@@QEAAXXZ DD 021H
	DD	imagerel $LN48+11
	DD	imagerel $LN48+39
	DD	imagerel $chain$0$?Clear@ImFontAtlas@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?Clear@ImFontAtlas@@QEAAXXZ DD 040a21H
	DD	08e40aH
	DD	063405H
	DD	imagerel $LN48+11
	DD	imagerel $LN48+39
	DD	imagerel $chain$0$?Clear@ImFontAtlas@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?Clear@ImFontAtlas@@QEAAXXZ DD 020521H
	DD	076405H
	DD	imagerel $LN48
	DD	imagerel $LN48+11
	DD	imagerel $unwind$?Clear@ImFontAtlas@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Clear@ImFontAtlas@@QEAAXXZ DD 040b01H
	DD	09740bH
	DD	0f007320bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetTexDataAsAlpha8@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z DD 072519H
	DD	0317417H
	DD	0303417H
	DD	02c0117H
	DD	0500bH
	DD	imagerel __GSHandlerCheck
	DD	0150H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z DD 021H
	DD	imagerel $LN62
	DD	imagerel $LN62+40
	DD	imagerel $unwind$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z DD 021H
	DD	imagerel $LN62+40
	DD	imagerel $LN62+47
	DD	imagerel $chain$0$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z DD 021H
	DD	imagerel $LN62+47
	DD	imagerel $LN62+68
	DD	imagerel $chain$1$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z DD 020421H
	DD	02f7404H
	DD	imagerel $LN62+47
	DD	imagerel $LN62+68
	DD	imagerel $chain$1$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z DD 020421H
	DD	02df404H
	DD	imagerel $LN62+40
	DD	imagerel $LN62+47
	DD	imagerel $chain$0$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z DD 020421H
	DD	02ee404H
	DD	imagerel $LN62
	DD	imagerel $LN62+40
	DD	imagerel $unwind$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z DD 052019H
	DD	0300112H
	DD	030056006H
	DD	05004H
	DD	imagerel __GSHandlerCheck
	DD	0150H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z DD 021H
	DD	imagerel $LN80
	DD	imagerel $LN80+15
	DD	imagerel $unwind$?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z DD 020021H
	DD	0bf400H
	DD	imagerel $LN80
	DD	imagerel $LN80+15
	DD	imagerel $unwind$?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z DD 021H
	DD	imagerel $LN80+15
	DD	imagerel $LN80+232
	DD	imagerel $chain$1$?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z DD 020521H
	DD	0ae405H
	DD	imagerel $LN80+15
	DD	imagerel $LN80+232
	DD	imagerel $chain$1$?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z DD 040d21H
	DD	0bf40dH
	DD	095405H
	DD	imagerel $LN80
	DD	imagerel $LN80+15
	DD	imagerel $unwind$?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z DD 040801H
	DD	070043208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Decode85@@YAXPEBEPEAE@Z DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AddFontDefault@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z DD 052019H
	DD	02f3412H
	DD	02c0112H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	0150H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AddFontFromMemoryTTF@ImFontAtlas@@QEAAPEAUImFont@@PEAXHMPEBUImFontConfig@@PEBG@Z DD 030e01H
	DD	028010eH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z DD 021H
	DD	imagerel $LN64
	DD	imagerel $LN64+28
	DD	imagerel $unwind$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z DD 0a0021H
	DD	01e8800H
	DD	01f7800H
	DD	0206800H
	DD	042e400H
	DD	0476400H
	DD	imagerel $LN64
	DD	imagerel $LN64+28
	DD	imagerel $unwind$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z DD 021H
	DD	imagerel $LN64+28
	DD	imagerel $LN64+214
	DD	imagerel $chain$5$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z DD 020821H
	DD	0487408H
	DD	imagerel $LN64+28
	DD	imagerel $LN64+214
	DD	imagerel $chain$5$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z DD 0c2421H
	DD	01e8824H
	DD	01f781fH
	DD	020681bH
	DD	042e417H
	DD	047640cH
	DD	0463404H
	DD	imagerel $LN64
	DD	imagerel $LN64+28
	DD	imagerel $unwind$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z DD 061901H
	DD	01d9819H
	DD	0430114H
	DD	05004f006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AddFontFromMemoryCompressedBase85TTF@ImFontAtlas@@QEAAPEAUImFont@@PEBDMPEBUImFontConfig@@PEBG@Z DD 0a1901H
	DD	036819H
	DD	0c6414H
	DD	0b5414H
	DD	0a3414H
	DD	070107214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AddCustomRectRegular@ImFontAtlas@@QEAAHHH@Z DD 020601H
	DD	030027206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Build@ImFontAtlas@@QEAA_NXZ DD 052019H
	DD	02f3412H
	DD	02c0112H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	0150H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?ImFontAtlasBuildMultiplyRectAlpha8@@YAXQEBEPEAEHHHHH@Z DD 021H
	DD	imagerel $LN20
	DD	imagerel $LN20+45
	DD	imagerel $unwind$?ImFontAtlasBuildMultiplyRectAlpha8@@YAXQEBEPEAEHHHHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?ImFontAtlasBuildMultiplyRectAlpha8@@YAXQEBEPEAEHHHHH@Z DD 020421H
	DD	03404H
	DD	imagerel $LN20
	DD	imagerel $LN20+45
	DD	imagerel $unwind$?ImFontAtlasBuildMultiplyRectAlpha8@@YAXQEBEPEAEHHHHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImFontAtlasBuildMultiplyRectAlpha8@@YAXQEBEPEAEHHHHH@Z DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?UnpackBitVectorToFlatIndexList@@YAXPEBUImBitVector@@PEAU?$ImVector@H@@@Z DD 021H
	DD	imagerel ?UnpackBitVectorToFlatIndexList@@YAXPEBUImBitVector@@PEAU?$ImVector@H@@@Z
	DD	imagerel ?UnpackBitVectorToFlatIndexList@@YAXPEBUImBitVector@@PEAU?$ImVector@H@@@Z+38
	DD	imagerel $unwind$?UnpackBitVectorToFlatIndexList@@YAXPEBUImBitVector@@PEAU?$ImVector@H@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?UnpackBitVectorToFlatIndexList@@YAXPEBUImBitVector@@PEAU?$ImVector@H@@@Z DD 081421H
	DD	04f414H
	DD	0c740fH
	DD	0b640aH
	DD	0a5405H
	DD	imagerel ?UnpackBitVectorToFlatIndexList@@YAXPEBUImBitVector@@PEAU?$ImVector@H@@@Z
	DD	imagerel ?UnpackBitVectorToFlatIndexList@@YAXPEBUImBitVector@@PEAU?$ImVector@H@@@Z+38
	DD	imagerel $unwind$?UnpackBitVectorToFlatIndexList@@YAXPEBUImBitVector@@PEAU?$ImVector@H@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?UnpackBitVectorToFlatIndexList@@YAXPEBUImBitVector@@PEAU?$ImVector@H@@@Z DD 050c01H
	DD	0e008420cH
	DD	0c004d006H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z DB 012H
	DB	0adH, 02H
	DB	00H
	DB	0fcH
	DB	02H
	DB	08eH
	DB	04H
	DB	019H, 015H
	DB	0eH
	DB	090H
	DB	010H
	DB	089H, '('
	DB	012H
	DB	0e5H, 05H
	DB	010H
	DB	09aH
	DB	014H
	DB	'U', 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z DB 01aH
	DB	0aH
	DD	imagerel ??1?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ
	DB	0a1H
	DB	03H
	DB	03aH
	DD	imagerel ??1?$ImVector@UImFontBuildDstData@@@@QEAA@XZ
	DB	021H
	DB	03H
	DB	070H
	DB	080H
	DB	080H
	DB	090H
	DB	05aH
	DD	imagerel ??1?$ImVector@Ustbrp_rect@@@@QEAA@XZ
	DB	061H
	DB	03H
	DB	03aH
	DD	imagerel ??1?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ
	DB	061H
	DB	02H
	DB	03eH
	DD	imagerel __imp___std_terminate
	DB	09eH
	DD	imagerel __imp___std_terminate
	DB	03dH
	DB	02H
	DD	imagerel __imp___std_terminate
	DB	0dH
	DB	03H
	DD	imagerel __imp___std_terminate
	DB	07dH
	DB	03H
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z
	DD	imagerel $ip2state$?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z DD 01d6619H
	DD	026d855H
	DD	027c84dH
	DD	028b845H
	DD	029a83dH
	DD	02a9838H
	DD	02b8833H
	DD	02c782eH
	DD	02d682aH
	DD	0657426H
	DD	0646426H
	DD	0633426H
	DD	05c0126H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z
	DD	0252H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImFontAtlasBuildSetupFont@@YAXPEAUImFontAtlas@@PEAUImFont@@PEAUImFontConfig@@MM@Z DD 081c01H
	DD	02681cH
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z DB 02H
	DB	0ccH
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$ImVector@Ustbrp_rect@@@@QEAA@XZ
	DB	040H
	DB	03eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z DB 028H
	DD	imagerel $stateUnwindMap$?ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z
	DD	imagerel $ip2state$?ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z DD 0a1a11H
	DD	0b741aH
	DD	0a641aH
	DD	09541aH
	DD	08341aH
	DD	0e016521aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImFontAtlasBuildRender8bppRectFromString@@YAXPEAUImFontAtlas@@HHHHPEBDDE@Z DD 060f01H
	DD	03740fH
	DD	02640aH
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImFontAtlasBuildRender32bppRectFromString@@YAXPEAUImFontAtlas@@HHHHPEBDDI@Z DD 040a01H
	DD	02740aH
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImFontAtlasBuildRenderDefaultTexData@@YAXPEAUImFontAtlas@@@Z DD 060f01H
	DD	0b640fH
	DD	0a340fH
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z DD 0100021H
	DD	036800H
	DD	08f400H
	DD	09e400H
	DD	0ac400H
	DD	0b7400H
	DD	0116400H
	DD	0105400H
	DD	0f3400H
	DD	imagerel ?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z
	DD	imagerel ?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z+21
	DD	imagerel $unwind$?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z DD 021H
	DD	imagerel ?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z
	DD	imagerel ?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z+21
	DD	imagerel $unwind$?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z DD 0104521H
	DD	08f445H
	DD	036834H
	DD	09e42eH
	DD	0ac41bH
	DD	0b7417H
	DD	0116413H
	DD	010540fH
	DD	0f3404H
	DD	imagerel ?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z
	DD	imagerel ?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z+21
	DD	imagerel $unwind$?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z DD 020901H
	DD	0d005b209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImFontAtlasBuildInit@@YAXPEAUImFontAtlas@@@Z DD 0a1c01H
	DD	0de41cH
	DD	0c741cH
	DD	0b641cH
	DD	0a341cH
	DD	05015721cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z DD 021H
	DD	imagerel $LN44
	DD	imagerel $LN44+18
	DD	imagerel $unwind$?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z DD 021H
	DD	imagerel $LN44+18
	DD	imagerel $LN44+55
	DD	imagerel $chain$0$?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z DD 081d21H
	DD	06881dH
	DD	077817H
	DD	086812H
	DD	015e408H
	DD	imagerel $LN44+18
	DD	imagerel $LN44+55
	DD	imagerel $chain$0$?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z DD 020821H
	DD	0145408H
	DD	imagerel $LN44
	DD	imagerel $LN44+18
	DD	imagerel $unwind$?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z DD 071201H
	DD	0176412H
	DD	0163412H
	DD	0120112H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ClearOutputData@ImFont@@QEAAXXZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FindFirstExistingGlyph@@YAGPEAUImFont@@PEBGH@Z DD 040a01H
	DD	02740aH
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?BuildLookupTable@ImFont@@QEAAXXZ DD 0a2719H
	DD	0f6418H
	DD	0e5418H
	DD	0d3418H
	DD	0f0147218H
	DD	07010e012H
	DD	imagerel __GSHandlerCheck
	DD	030H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?GrowIndex@ImFont@@QEAAXH@Z DD 021H
	DD	imagerel $LN44
	DD	imagerel $LN44+27
	DD	imagerel $unwind$?GrowIndex@ImFont@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?GrowIndex@ImFont@@QEAAXH@Z DD 020021H
	DD	0a6400H
	DD	imagerel $LN44
	DD	imagerel $LN44+27
	DD	imagerel $unwind$?GrowIndex@ImFont@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?GrowIndex@ImFont@@QEAAXH@Z DD 040f21H
	DD	0a640fH
	DD	085405H
	DD	imagerel $LN44
	DD	imagerel $LN44+27
	DD	imagerel $unwind$?GrowIndex@ImFont@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GrowIndex@ImFont@@QEAAXH@Z DD 040901H
	DD	0e0053209H
	DD	030027003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AddGlyph@ImFont@@QEAAXPEBUImFontConfig@@GMMMMMMMMM@Z DD 0c2201H
	DD	028822H
	DD	03781cH
	DD	046814H
	DD	0d640fH
	DD	0c340fH
	DD	0700b920fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z DD 021H
	DD	imagerel $LN55
	DD	imagerel $LN55+70
	DD	imagerel $unwind$?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z DD 020521H
	DD	0ad405H
	DD	imagerel $LN55
	DD	imagerel $LN55+70
	DD	imagerel $unwind$?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z DD 0a1601H
	DD	0c5416H
	DD	0b3416H
	DD	0f0123216H
	DD	0c00ee010H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$12$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IAEBUImVec4@@PEBD3M_N@Z DD 021H
	DD	imagerel $LN147
	DD	imagerel $LN147+140
	DD	imagerel $unwind$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IAEBUImVec4@@PEBD3M_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$11$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IAEBUImVec4@@PEBD3M_N@Z DD 021H
	DD	imagerel $LN147+140
	DD	imagerel $LN147+535
	DD	imagerel $chain$3$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IAEBUImVec4@@PEBD3M_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IAEBUImVec4@@PEBD3M_N@Z DD 021H
	DD	imagerel $LN147+535
	DD	imagerel $LN147+627
	DD	imagerel $chain$5$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IAEBUImVec4@@PEBD3M_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IAEBUImVec4@@PEBD3M_N@Z DD 081e21H
	DD	06d81eH
	DD	07c818H
	DD	08b812H
	DD	09a809H
	DD	imagerel $LN147+535
	DD	imagerel $LN147+627
	DD	imagerel $chain$5$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IAEBUImVec4@@PEBD3M_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IAEBUImVec4@@PEBD3M_N@Z DD 041321H
	DD	01dd413H
	DD	024c408H
	DD	imagerel $LN147+140
	DD	imagerel $LN147+535
	DD	imagerel $chain$3$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IAEBUImVec4@@PEBD3M_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IAEBUImVec4@@PEBD3M_N@Z DD 083121H
	DD	0b8831H
	DD	0c781fH
	DD	0d6813H
	DD	01ce408H
	DD	imagerel $LN147
	DD	imagerel $LN147+140
	DD	imagerel $unwind$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IAEBUImVec4@@PEBD3M_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IAEBUImVec4@@PEBD3M_N@Z DD 0d4101H
	DD	04f841H
	DD	05e83bH
	DD	0a9831H
	DD	01e0112H
	DD	07009f00bH
	DD	050076008H
	DD	03006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?RenderArrow@ImGui@@YAXPEAUImDrawList@@UImVec2@@IHM@Z DD 0c5d01H
	DD	04985dH
	DD	05882aH
	DD	067821H
	DD	076819H
	DD	014340dH
	DD	07006f20dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?RenderCheckMark@ImGui@@YAXPEAUImDrawList@@UImVec2@@IM@Z DD 0e3401H
	DD	049834H
	DD	05882aH
	DD	06781fH
	DD	076811H
	DD	011010cH
	DD	060047005H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?RenderArrowPointingAt@ImGui@@YAXPEAUImDrawList@@UImVec2@@1HI@Z DD 060c01H
	DD	0f340cH
	DD	07008720cH
	DD	050066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?RenderArrowDockMenu@ImGui@@YAXPEAUImDrawList@@UImVec2@@MI@Z DD 021H
	DD	imagerel $LN167+279
	DD	imagerel $LN167+286
	DD	imagerel $chain$2$?RenderArrowDockMenu@ImGui@@YAXPEAUImDrawList@@UImVec2@@MI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?RenderArrowDockMenu@ImGui@@YAXPEAUImDrawList@@UImVec2@@MI@Z DD 040d21H
	DD	0e740dH
	DD	0143408H
	DD	imagerel $LN167+279
	DD	imagerel $LN167+286
	DD	imagerel $chain$2$?RenderArrowDockMenu@ImGui@@YAXPEAUImDrawList@@UImVec2@@MI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?RenderArrowDockMenu@ImGui@@YAXPEAUImDrawList@@UImVec2@@MI@Z DD 021H
	DD	imagerel $LN167
	DD	imagerel $LN167+18
	DD	imagerel $unwind$?RenderArrowDockMenu@ImGui@@YAXPEAUImDrawList@@UImVec2@@MI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?RenderArrowDockMenu@ImGui@@YAXPEAUImDrawList@@UImVec2@@MI@Z DD 041121H
	DD	059811H
	DD	068805H
	DD	imagerel $LN167
	DD	imagerel $LN167+18
	DD	imagerel $unwind$?RenderArrowDockMenu@ImGui@@YAXPEAUImDrawList@@UImVec2@@MI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?RenderArrowDockMenu@ImGui@@YAXPEAUImDrawList@@UImVec2@@MI@Z DD 030901H
	DD	06005e209H
	DD	05004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$13$?RenderColorRectWithAlphaCheckerboard@ImGui@@YAXPEAUImDrawList@@UImVec2@@1IM1MH@Z DD 021H
	DD	imagerel $LN82
	DD	imagerel $LN82+70
	DD	imagerel $unwind$?RenderColorRectWithAlphaCheckerboard@ImGui@@YAXPEAUImDrawList@@UImVec2@@1IM1MH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$12$?RenderColorRectWithAlphaCheckerboard@ImGui@@YAXPEAUImDrawList@@UImVec2@@1IM1MH@Z DD 021H
	DD	imagerel $LN82+70
	DD	imagerel $LN82+319
	DD	imagerel $chain$3$?RenderColorRectWithAlphaCheckerboard@ImGui@@YAXPEAUImDrawList@@UImVec2@@1IM1MH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$11$?RenderColorRectWithAlphaCheckerboard@ImGui@@YAXPEAUImDrawList@@UImVec2@@1IM1MH@Z DD 0105521H
	DD	07e855H
	DD	09c84fH
	DD	0ba846H
	DD	0c983dH
	DD	0d882dH
	DD	0e781eH
	DD	0f6816H
	DD	020e408H
	DD	imagerel $LN82+70
	DD	imagerel $LN82+319
	DD	imagerel $chain$3$?RenderColorRectWithAlphaCheckerboard@ImGui@@YAXPEAUImDrawList@@UImVec2@@1IM1MH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?RenderColorRectWithAlphaCheckerboard@ImGui@@YAXPEAUImDrawList@@UImVec2@@1IM1MH@Z DD 082721H
	DD	06f827H
	DD	08d821H
	DD	0ab813H
	DD	0216408H
	DD	imagerel $LN82
	DD	imagerel $LN82+70
	DD	imagerel $unwind$?RenderColorRectWithAlphaCheckerboard@ImGui@@YAXPEAUImDrawList@@UImVec2@@1IM1MH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?RenderColorRectWithAlphaCheckerboard@ImGui@@YAXPEAUImDrawList@@UImVec2@@1IM1MH@Z DD 050b01H
	DD	022010bH
	DD	050037004H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stb__lit@@YAXPEBEI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stb_decompress_token@@YAPEBEPEBE@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?stb_adler32@@YAIIPEAEI@Z DD 021H
	DD	imagerel ?stb_adler32@@YAIIPEAEI@Z
	DD	imagerel ?stb_adler32@@YAIIPEAEI@Z+51
	DD	imagerel $unwind$?stb_adler32@@YAIIPEAEI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?stb_adler32@@YAIIPEAEI@Z DD 020521H
	DD	047405H
	DD	imagerel ?stb_adler32@@YAIIPEAEI@Z
	DD	imagerel ?stb_adler32@@YAIIPEAEI@Z+51
	DD	imagerel $unwind$?stb_adler32@@YAIIPEAEI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stb_adler32@@YAIIPEAEI@Z DD 030601H
	DD	053406H
	DD	06006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stb_decompress@@YAIPEAEPEBEI@Z DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0e016321aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?resize@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z DD 021H
	DD	imagerel $LN38
	DD	imagerel $LN38+26
	DD	imagerel $unwind$?resize@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?resize@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z DD 020021H
	DD	076400H
	DD	imagerel $LN38
	DD	imagerel $LN38+26
	DD	imagerel $unwind$?resize@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?resize@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z DD 043021H
	DD	065430H
	DD	076405H
	DD	imagerel $LN38
	DD	imagerel $LN38+26
	DD	imagerel $unwind$?resize@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ DB 00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ DD 019H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?resize@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z DD 021H
	DD	imagerel $LN38
	DD	imagerel $LN38+26
	DD	imagerel $unwind$?resize@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?resize@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z DD 020021H
	DD	076400H
	DD	imagerel $LN38
	DD	imagerel $LN38+26
	DD	imagerel $unwind$?resize@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?resize@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z DD 043421H
	DD	065434H
	DD	076405H
	DD	imagerel $LN38
	DD	imagerel $LN38+26
	DD	imagerel $unwind$?resize@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@Ustbrp_rect@@@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@Ustbrp_rect@@@@QEAA@XZ DB 00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@Ustbrp_rect@@@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1?$ImVector@Ustbrp_rect@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@Ustbrp_rect@@@@QEAA@XZ DD 019H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@Ustbrp_rect@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?resize@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z DD 021H
	DD	imagerel $LN38
	DD	imagerel $LN38+26
	DD	imagerel $unwind$?resize@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?resize@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z DD 020021H
	DD	076400H
	DD	imagerel $LN38
	DD	imagerel $LN38+26
	DD	imagerel $unwind$?resize@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?resize@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z DD 043021H
	DD	065430H
	DD	076405H
	DD	imagerel $LN38
	DD	imagerel $LN38+26
	DD	imagerel $unwind$?resize@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@UImFontBuildDstData@@@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@UImFontBuildDstData@@@@QEAA@XZ DB 00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@UImFontBuildDstData@@@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1?$ImVector@UImFontBuildDstData@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@UImFontBuildDstData@@@@QEAA@XZ DD 019H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@UImFontBuildDstData@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?resize@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z DD 021H
	DD	imagerel $LN38
	DD	imagerel $LN38+26
	DD	imagerel $unwind$?resize@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?resize@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z DD 020021H
	DD	076400H
	DD	imagerel $LN38
	DD	imagerel $LN38+26
	DD	imagerel $unwind$?resize@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?resize@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z DD 043421H
	DD	065434H
	DD	076405H
	DD	imagerel $LN38
	DD	imagerel $LN38+26
	DD	imagerel $unwind$?resize@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?clear_destruct@?$ImVector@UImFontBuildSrcData@@@@QEAAXXZ DB 00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?clear_destruct@?$ImVector@UImFontBuildSrcData@@@@QEAAXXZ DB 02H
	DB	0eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?clear_destruct@?$ImVector@UImFontBuildSrcData@@@@QEAAXXZ DB 028H
	DD	imagerel $stateUnwindMap$?clear_destruct@?$ImVector@UImFontBuildSrcData@@@@QEAAXXZ
	DD	imagerel $ip2state$?clear_destruct@?$ImVector@UImFontBuildSrcData@@@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear_destruct@?$ImVector@UImFontBuildSrcData@@@@QEAAXXZ DD 0a1a11H
	DD	09e41aH
	DD	08741aH
	DD	07641aH
	DD	06341aH
	DD	0f016321aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?clear_destruct@?$ImVector@UImFontBuildSrcData@@@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ DB 00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ DD 019H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z DD 021H
	DD	imagerel $LN38
	DD	imagerel $LN38+26
	DD	imagerel $unwind$?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z DD 020021H
	DD	076400H
	DD	imagerel $LN38
	DD	imagerel $LN38+26
	DD	imagerel $unwind$?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z DD 043421H
	DD	065434H
	DD	076405H
	DD	imagerel $LN38
	DD	imagerel $LN38+26
	DD	imagerel $unwind$?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@UImFontGlyph@@@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@UImFontGlyph@@@@QEAA@XZ DB 00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@UImFontGlyph@@@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1?$ImVector@UImFontGlyph@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@UImFontGlyph@@@@QEAA@XZ DD 019H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@UImFontGlyph@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@M@@QEAAXHAEBM@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?push_back@?$ImVector@UImFontConfig@@@@QEAAXAEBUImFontConfig@@@Z DD 021H
	DD	imagerel $LN35
	DD	imagerel $LN35+72
	DD	imagerel $unwind$?push_back@?$ImVector@UImFontConfig@@@@QEAAXAEBUImFontConfig@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?push_back@?$ImVector@UImFontConfig@@@@QEAAXAEBUImFontConfig@@@Z DD 020521H
	DD	065405H
	DD	imagerel $LN35
	DD	imagerel $LN35+72
	DD	imagerel $unwind$?push_back@?$ImVector@UImFontConfig@@@@QEAAXAEBUImFontConfig@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$ImVector@UImFontConfig@@@@QEAAXAEBUImFontConfig@@@Z DD 060f01H
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@UImFontConfig@@@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@UImFontConfig@@@@QEAA@XZ DB 00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@UImFontConfig@@@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1?$ImVector@UImFontConfig@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@UImFontConfig@@@@QEAA@XZ DD 019H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@UImFontConfig@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?push_back@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXAEBUImFontAtlasCustomRect@@@Z DD 021H
	DD	imagerel $LN35
	DD	imagerel $LN35+72
	DD	imagerel $unwind$?push_back@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXAEBUImFontAtlasCustomRect@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?push_back@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXAEBUImFontAtlasCustomRect@@@Z DD 020521H
	DD	066405H
	DD	imagerel $LN35
	DD	imagerel $LN35+72
	DD	imagerel $unwind$?push_back@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXAEBUImFontAtlasCustomRect@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXAEBUImFontAtlasCustomRect@@@Z DD 060f01H
	DD	08540fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@UImFontAtlasCustomRect@@@@QEAA@XZ DB 00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@UImFontAtlasCustomRect@@@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1?$ImVector@UImFontAtlasCustomRect@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@UImFontAtlasCustomRect@@@@QEAA@XZ DD 019H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@UImFontAtlasCustomRect@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?clear_delete@?$ImVector@PEAUImFont@@@@QEAAXXZ DD 021H
	DD	imagerel $LN43
	DD	imagerel $LN43+11
	DD	imagerel $unwind$?clear_delete@?$ImVector@PEAUImFont@@@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?clear_delete@?$ImVector@PEAUImFont@@@@QEAAXXZ DD 021H
	DD	imagerel $LN43+11
	DD	imagerel $LN43+25
	DD	imagerel $chain$0$?clear_delete@?$ImVector@PEAUImFont@@@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?clear_delete@?$ImVector@PEAUImFont@@@@QEAAXXZ DD 040c21H
	DD	08740cH
	DD	076405H
	DD	imagerel $LN43+11
	DD	imagerel $LN43+25
	DD	imagerel $chain$0$?clear_delete@?$ImVector@PEAUImFont@@@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?clear_delete@?$ImVector@PEAUImFont@@@@QEAAXXZ DD 020521H
	DD	063405H
	DD	imagerel $LN43
	DD	imagerel $LN43+11
	DD	imagerel $unwind$?clear_delete@?$ImVector@PEAUImFont@@@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear_delete@?$ImVector@PEAUImFont@@@@QEAAXXZ DD 040b01H
	DD	09e40bH
	DD	0f007320bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$ImVector@PEAUImDrawList@@@@QEAAXAEBQEAUImDrawList@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve_discard@?$ImVector@UImVec2@@@@QEAAXH@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$ImVector@PEAX@@QEAAXAEBQEAX@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@PEAX@@QEAAXH@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@PEAX@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$ImVector@UImVec4@@@@QEAAXAEBUImVec4@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@UImVec4@@@@QEAAXH@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@UImVec4@@@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@UImDrawVert@@@@QEAAXH@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@UImDrawVert@@@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?reserve@?$ImVector@UImDrawChannel@@@@QEAAXH@Z DD 021H
	DD	imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImDrawChannel@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?reserve@?$ImVector@UImDrawChannel@@@@QEAAXH@Z DD 020521H
	DD	066405H
	DD	imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImDrawChannel@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImDrawChannel@@@@QEAAXH@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@UImDrawChannel@@@@QEAAXH@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?erase@?$ImVector@UImDrawCmd@@@@QEAAPEAUImDrawCmd@@PEBU2@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@UImDrawCmd@@@@QEAAXH@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@UImDrawCmd@@@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@G@@QEAAXHAEBG@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??_GImFontBuildSrcData@@QEAAPEAXI@Z DB 00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??_GImFontBuildSrcData@@QEAAPEAXI@Z DB 02H
	DB	0eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??_GImFontBuildSrcData@@QEAAPEAXI@Z DB 068H
	DD	imagerel $stateUnwindMap$??_GImFontBuildSrcData@@QEAAPEAXI@Z
	DD	imagerel $ip2state$??_GImFontBuildSrcData@@QEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GImFontBuildSrcData@@QEAAPEAXI@Z DD 020619H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??_GImFontBuildSrcData@@QEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1ImFontBuildSrcData@@QEAA@XZ DB 00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1ImFontBuildSrcData@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1ImFontBuildSrcData@@QEAA@XZ DB 068H
	DD	imagerel $stateUnwindMap$??1ImFontBuildSrcData@@QEAA@XZ
	DD	imagerel $ip2state$??1ImFontBuildSrcData@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ImFontBuildSrcData@@QEAA@XZ DD 020619H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1ImFontBuildSrcData@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1ImBitVector@@QEAA@XZ DB 00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1ImBitVector@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1ImBitVector@@QEAA@XZ DB 068H
	DD	imagerel $stateUnwindMap$??1ImBitVector@@QEAA@XZ
	DD	imagerel $ip2state$??1ImBitVector@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ImBitVector@@QEAA@XZ DD 010419H
	DD	04204H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1ImBitVector@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?reserve@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z DD 021H
	DD	imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?reserve@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z DD 020521H
	DD	066405H
	DD	imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?reserve@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z DD 021H
	DD	imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?reserve@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z DD 020521H
	DD	066405H
	DD	imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?reserve@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z DD 021H
	DD	imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?reserve@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z DD 020521H
	DD	066405H
	DD	imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?reserve@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z DD 021H
	DD	imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?reserve@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z DD 020521H
	DD	066405H
	DD	imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@UImFontBuildSrcData@@@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?reserve@?$ImVector@UImFontGlyph@@@@QEAAXH@Z DD 021H
	DD	imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImFontGlyph@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?reserve@?$ImVector@UImFontGlyph@@@@QEAAXH@Z DD 020521H
	DD	066405H
	DD	imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImFontGlyph@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImFontGlyph@@@@QEAAXH@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?reserve@?$ImVector@UImFontConfig@@@@QEAAXH@Z DD 021H
	DD	imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImFontConfig@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?reserve@?$ImVector@UImFontConfig@@@@QEAAXH@Z DD 020521H
	DD	066405H
	DD	imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImFontConfig@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImFontConfig@@@@QEAAXH@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?reserve@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXH@Z DD 021H
	DD	imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?reserve@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXH@Z DD 020521H
	DD	066405H
	DD	imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXH@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?reserve@?$ImVector@PEAX@@QEAAXH@Z DD 021H
	DD	imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@PEAX@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?reserve@?$ImVector@PEAX@@QEAAXH@Z DD 020521H
	DD	066405H
	DD	imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@PEAX@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@PEAX@@QEAAXH@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z DD 021H
	DD	imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z DD 020521H
	DD	066405H
	DD	imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$IM_DELETE@UImFont@@@@YAXPEAUImFont@@@Z DD 020a01H
	DD	03006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GImFont@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 48
$T3 = 56
$T4 = 56
this$ = 80
p_min$ = 88
p_max$ = 96
col$ = 104
rounding$ = 112
flags$ = 120
thickness$ = 128
?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z PROC	; ImDrawList::AddRect, COMDAT

; 1394 : {

$LN37:

; 1395 :     if ((col & IM_COL32_A_MASK) == 0)

	test	r9d, -16777216				; ff000000H
	je	$LN34@AddRect
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 64					; 00000040H

; 1396 :         return;
; 1397 :     if (Flags & ImDrawListFlags_AntiAliasedLines)

	test	BYTE PTR [rcx+48], 1
	mov	edi, r9d
	mov	eax, DWORD PTR flags$[rsp]
	mov	rbx, rcx
	movss	xmm1, DWORD PTR [r8]
	movss	xmm2, DWORD PTR [r8+4]
	movss	xmm3, DWORD PTR [rdx]
	movss	xmm4, DWORD PTR [rdx+4]
	mov	DWORD PTR [rsp+32], eax
	je	SHORT $LN3@AddRect
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm0, DWORD PTR __real@3f000000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1398 :         PathRect(p_min + ImVec2(0.50f, 0.50f), p_max - ImVec2(0.50f, 0.50f), rounding, flags);

	lea	r8, QWORD PTR $T2[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	subss	xmm1, xmm0

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	subss	xmm2, xmm0

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm3, xmm0
	addss	xmm4, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1398 :         PathRect(p_min + ImVec2(0.50f, 0.50f), p_max - ImVec2(0.50f, 0.50f), rounding, flags);

	lea	rdx, QWORD PTR $T4[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T2[rsp], xmm1
	movss	DWORD PTR $T2[rsp+4], xmm2
	movss	DWORD PTR $T4[rsp], xmm3
	movss	DWORD PTR $T4[rsp+4], xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1398 :         PathRect(p_min + ImVec2(0.50f, 0.50f), p_max - ImVec2(0.50f, 0.50f), rounding, flags);

	jmp	SHORT $LN35@AddRect
$LN3@AddRect:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	subss	xmm1, DWORD PTR __real@3efae148

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	subss	xmm2, DWORD PTR __real@3efae148

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm3, DWORD PTR __real@3f000000
	addss	xmm4, DWORD PTR __real@3f000000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1400 :         PathRect(p_min + ImVec2(0.50f, 0.50f), p_max - ImVec2(0.49f, 0.49f), rounding, flags); // Better looking lower-right corner and rounded non-AA shapes.

	lea	r8, QWORD PTR $T3[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T3[rsp], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1400 :         PathRect(p_min + ImVec2(0.50f, 0.50f), p_max - ImVec2(0.49f, 0.49f), rounding, flags); // Better looking lower-right corner and rounded non-AA shapes.

	lea	rdx, QWORD PTR $T1[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T3[rsp+4], xmm2
	movss	DWORD PTR $T1[rsp], xmm3
	movss	DWORD PTR $T1[rsp+4], xmm4
$LN35@AddRect:

; 2808 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

	movss	xmm3, DWORD PTR rounding$[rsp]
	call	?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z ; ImDrawList::PathRect
	movss	xmm0, DWORD PTR thickness$[rsp]
	mov	r9d, edi
	mov	r8d, DWORD PTR [rbx+120]
	mov	rcx, rbx
	mov	rdx, QWORD PTR [rbx+128]
	movss	DWORD PTR [rsp+40], xmm0
	mov	DWORD PTR [rsp+32], 1
	call	?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z ; ImDrawList::AddPolyline
	mov	DWORD PTR [rbx+120], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1402 : }

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 64					; 00000040H
	pop	rdi
$LN34@AddRect:
	ret	0
?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z ENDP	; ImDrawList::AddRect
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z
_TEXT	SEGMENT
this$ = 80
p_min$ = 88
p_max$ = 96
col$ = 104
rounding$ = 112
flags$ = 120
?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z PROC	; ImDrawList::AddRectFilled, COMDAT

; 1405 : {

$LN20:

; 1406 :     if ((col & IM_COL32_A_MASK) == 0)

	test	r9d, -16777216				; ff000000H
	je	$LN18@AddRectFil
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 64					; 00000040H

; 1407 :         return;
; 1408 :     if (rounding < 0.5f || (flags & ImDrawFlags_RoundCornersMask_) == ImDrawFlags_RoundCornersNone)

	movss	xmm0, DWORD PTR __real@3f000000
	mov	edi, r9d
	movss	xmm3, DWORD PTR rounding$[rsp]
	mov	rsi, r8
	comiss	xmm0, xmm3
	mov	rbp, rdx
	mov	rbx, rcx
	ja	SHORT $LN5@AddRectFil
	mov	ecx, DWORD PTR flags$[rsp]
	mov	eax, ecx
	and	eax, 496				; 000001f0H
	cmp	eax, 256				; 00000100H
	je	SHORT $LN5@AddRectFil

; 1411 :         PrimRect(p_min, p_max, col);
; 1412 :     }
; 1413 :     else
; 1414 :     {
; 1415 :         PathRect(p_min, p_max, rounding, flags);

	mov	DWORD PTR [rsp+32], ecx
	mov	rcx, rbx
	call	?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z ; ImDrawList::PathRect
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	r8d, DWORD PTR [rbx+120]
	mov	r9d, edi
	mov	rdx, QWORD PTR [rbx+128]
	mov	rcx, rbx
	call	?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z ; ImDrawList::AddConvexPolyFilled
	mov	DWORD PTR [rbx+120], 0
	jmp	$LN4@AddRectFil
$LN5@AddRectFil:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1410 :         PrimReserve(6, 4);

	mov	edx, 6
	movaps	XMMWORD PTR [rsp+48], xmm6
	mov	rcx, rbx
	lea	r8d, QWORD PTR [rdx-2]
	call	?PrimReserve@ImDrawList@@QEAAXHH@Z	; ImDrawList::PrimReserve

; 665  :     ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;

	movzx	edx, WORD PTR [rbx+52]
	mov	rax, QWORD PTR [rbx+56]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm1, DWORD PTR [rsi]
	movss	xmm2, DWORD PTR [rbp+4]
	movss	xmm3, DWORD PTR [rbp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 666  :     _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);

	lea	ecx, DWORD PTR [rdx+1]
	movss	xmm6, DWORD PTR [rax+4]
	movss	xmm5, DWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm4, DWORD PTR [rsi+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 666  :     _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);

	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax], dx
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+2], cx
	lea	ecx, DWORD PTR [rdx+2]
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+4], cx

; 667  :     _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx+2); _IdxWritePtr[5] = (ImDrawIdx)(idx+3);

	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+6], dx
	add	dx, 3
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+8], cx
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+10], dx

; 668  :     _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;

	movsd	xmm0, QWORD PTR [rbp]
	mov	rax, QWORD PTR [rbx+72]
	movsd	QWORD PTR [rax], xmm0
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+8], xmm5
	movss	DWORD PTR [rax+12], xmm6
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+16], edi

; 669  :     _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col;

	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+20], xmm1
	movss	DWORD PTR [rax+24], xmm2
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+28], xmm5
	movss	DWORD PTR [rax+32], xmm6
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+36], edi

; 670  :     _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col;

	movsd	xmm0, QWORD PTR [rsi]
	mov	rax, QWORD PTR [rbx+72]
	movsd	QWORD PTR [rax+40], xmm0
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+48], xmm5
	movss	DWORD PTR [rax+52], xmm6
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+56], edi

; 671  :     _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv; _VtxWritePtr[3].col = col;

	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+60], xmm3
	movss	DWORD PTR [rax+64], xmm4
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+68], xmm5
	movss	DWORD PTR [rax+72], xmm6
	mov	rax, QWORD PTR [rbx+72]

; 672  :     _VtxWritePtr += 4;
; 673  :     _VtxCurrentIdx += 4;
; 674  :     _IdxWritePtr += 6;

	movaps	xmm6, XMMWORD PTR [rsp+48]
	mov	DWORD PTR [rax+76], edi
	add	QWORD PTR [rbx+72], 80			; 00000050H
	add	DWORD PTR [rbx+52], 4
	add	QWORD PTR [rbx+80], 12
$LN4@AddRectFil:

; 1416 :         PathFillConvex(col);
; 1417 :     }
; 1418 : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 64					; 00000040H
	pop	rdi
$LN18@AddRectFil:
	ret	0
?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ENDP	; ImDrawList::AddRectFilled
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?AddTriangleFilled@ImDrawList@@QEAAXAEBUImVec2@@00I@Z
_TEXT	SEGMENT
this$ = 48
p1$ = 56
p2$ = 64
p3$ = 72
col$ = 80
?AddTriangleFilled@ImDrawList@@QEAAXAEBUImVec2@@00I@Z PROC ; ImDrawList::AddTriangleFilled, COMDAT

; 1472 : {

$LN8:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	push	rsi
	sub	rsp, 32					; 00000020H

; 1473 :     if ((col & IM_COL32_A_MASK) == 0)

	test	DWORD PTR col$[rsp], -16777216		; ff000000H
	mov	rsi, r9
	mov	rbp, r8
	mov	rbx, rcx
	je	SHORT $LN1@AddTriangl

; 1474 :         return;
; 1475 : 
; 1476 :     PathLineTo(p1);

	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo

; 1477 :     PathLineTo(p2);

	mov	rdx, rbp
	mov	rcx, rbx
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo

; 1478 :     PathLineTo(p3);

	mov	rdx, rsi
	mov	rcx, rbx
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	r9d, DWORD PTR col$[rsp]
	mov	rcx, rbx
	mov	r8d, DWORD PTR [rbx+120]
	mov	rdx, QWORD PTR [rbx+128]
	call	?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z ; ImDrawList::AddConvexPolyFilled
	mov	DWORD PTR [rbx+120], 0
$LN1@AddTriangl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1480 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
?AddTriangleFilled@ImDrawList@@QEAAXAEBUImVec2@@00I@Z ENDP ; ImDrawList::AddTriangleFilled
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?AddCircle@ImDrawList@@QEAAXAEBUImVec2@@MIHM@Z
_TEXT	SEGMENT
this$ = 64
center$ = 72
radius$ = 80
col$ = 88
num_segments$ = 96
thickness$ = 104
?AddCircle@ImDrawList@@QEAAXAEBUImVec2@@MIHM@Z PROC	; ImDrawList::AddCircle, COMDAT

; 1483 : {

$LN19:

; 1484 :     if ((col & IM_COL32_A_MASK) == 0 || radius < 0.5f)

	test	r9d, -16777216				; ff000000H
	je	$LN17@AddCircle
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 48					; 00000030H
	movss	xmm3, DWORD PTR __real@3f000000
	mov	edi, r9d
	comiss	xmm3, xmm2
	mov	rbx, rcx
	ja	$LN3@AddCircle

; 1485 :         return;
; 1486 : 
; 1487 :     if (num_segments <= 0)

	mov	eax, DWORD PTR num_segments$[rsp]
	test	eax, eax
	jg	SHORT $LN4@AddCircle

; 1488 :     {
; 1489 :         // Use arc with automatic segment count
; 1490 :         _PathArcToFastEx(center, radius - 0.5f, 0, IM_DRAWLIST_ARCFAST_SAMPLE_MAX, 0);

	subss	xmm2, xmm3
	mov	DWORD PTR [rsp+32], 48			; 00000030H
	xor	r9d, r9d
	call	?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z ; ImDrawList::_PathArcToFastEx

; 1491 :         _Path.Size--;

	dec	DWORD PTR [rbx+120]

; 1492 :     }

	jmp	SHORT $LN5@AddCircle
$LN4@AddCircle:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	cmp	eax, 3
	jge	SHORT $LN9@AddCircle
	mov	eax, 3
	jmp	SHORT $LN10@AddCircle
$LN9@AddCircle:
	mov	ecx, 512				; 00000200H
	cmp	eax, ecx
	cmovg	eax, ecx
$LN10@AddCircle:
	movd	xmm0, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1500 :         PathArcTo(center, radius - 0.5f, 0.0f, a_max, num_segments - 1);

	subss	xmm2, xmm3
	cvtdq2ps xmm0, xmm0
	dec	eax
	mov	rcx, rbx
	mov	DWORD PTR [rsp+40], eax
	xorps	xmm3, xmm3
	movaps	xmm1, xmm0
	subss	xmm1, DWORD PTR __real@3f800000
	mulss	xmm1, DWORD PTR __real@40c90fdb
	divss	xmm1, xmm0
	movss	DWORD PTR [rsp+32], xmm1
	call	?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z ; ImDrawList::PathArcTo
$LN5@AddCircle:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2808 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

	movss	xmm0, DWORD PTR thickness$[rsp]
	mov	r9d, edi
	mov	r8d, DWORD PTR [rbx+120]
	mov	rcx, rbx
	mov	rdx, QWORD PTR [rbx+128]
	movss	DWORD PTR [rsp+40], xmm0
	mov	DWORD PTR [rsp+32], 1
	call	?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z ; ImDrawList::AddPolyline
	mov	DWORD PTR [rbx+120], 0
$LN3@AddCircle:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1504 : }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 48					; 00000030H
	pop	rdi
$LN17@AddCircle:
	ret	0
?AddCircle@ImDrawList@@QEAAXAEBUImVec2@@MIHM@Z ENDP	; ImDrawList::AddCircle
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z
_TEXT	SEGMENT
this$ = 64
center$ = 72
radius$ = 80
col$ = 88
num_segments$ = 96
?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z PROC ; ImDrawList::AddCircleFilled, COMDAT

; 1507 : {

$LN19:

; 1508 :     if ((col & IM_COL32_A_MASK) == 0 || radius < 0.5f)

	test	r9d, -16777216				; ff000000H
	je	$LN17@AddCircleF
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 48					; 00000030H
	movss	xmm0, DWORD PTR __real@3f000000
	mov	edi, r9d
	comiss	xmm0, xmm2
	mov	rbx, rcx
	ja	$LN3@AddCircleF

; 1509 :         return;
; 1510 : 
; 1511 :     if (num_segments <= 0)

	mov	eax, DWORD PTR num_segments$[rsp]
	test	eax, eax
	jg	SHORT $LN4@AddCircleF

; 1512 :     {
; 1513 :         // Use arc with automatic segment count
; 1514 :         _PathArcToFastEx(center, radius, 0, IM_DRAWLIST_ARCFAST_SAMPLE_MAX, 0);

	xor	r9d, r9d
	mov	DWORD PTR [rsp+32], 48			; 00000030H
	call	?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z ; ImDrawList::_PathArcToFastEx

; 1515 :         _Path.Size--;

	dec	DWORD PTR [rbx+120]

; 1516 :     }

	jmp	SHORT $LN5@AddCircleF
$LN4@AddCircleF:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	cmp	eax, 3
	jge	SHORT $LN9@AddCircleF
	mov	eax, 3
	jmp	SHORT $LN10@AddCircleF
$LN9@AddCircleF:
	mov	ecx, 512				; 00000200H
	cmp	eax, ecx
	cmovg	eax, ecx
$LN10@AddCircleF:
	movd	xmm0, eax
	xorps	xmm3, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1523 :         const float a_max = (IM_PI * 2.0f) * ((float)num_segments - 1.0f) / (float)num_segments;

	cvtdq2ps xmm0, xmm0

; 1524 :         PathArcTo(center, radius, 0.0f, a_max, num_segments - 1);

	dec	eax
	mov	rcx, rbx
	mov	DWORD PTR [rsp+40], eax
	movaps	xmm1, xmm0
	subss	xmm1, DWORD PTR __real@3f800000
	mulss	xmm1, DWORD PTR __real@40c90fdb
	divss	xmm1, xmm0
	movss	DWORD PTR [rsp+32], xmm1
	call	?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z ; ImDrawList::PathArcTo
$LN5@AddCircleF:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	r8d, DWORD PTR [rbx+120]
	mov	r9d, edi
	mov	rdx, QWORD PTR [rbx+128]
	mov	rcx, rbx
	call	?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z ; ImDrawList::AddConvexPolyFilled
	mov	DWORD PTR [rbx+120], 0
$LN3@AddCircleF:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1528 : }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 48					; 00000030H
	pop	rdi
$LN17@AddCircleF:
	ret	0
?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ENDP ; ImDrawList::AddCircleFilled
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z
_TEXT	SEGMENT
tv5861 = 32
thick_line$1$ = 33
i1$1$ = 36
tv5160 = 40
col_trans$1$ = 44
tv5582 = 48
tv5580 = 48
tv5159 = 48
tex_uvs$15 = 48
tv5161 = 64
integer_thickness$1$ = 72
tv5281 = 80
this$ = 288
points$ = 296
idx2$1$ = 304
tv5855 = 304
points_count$ = 304
col$ = 312
flags$ = 320
thickness$ = 328
?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z PROC	; ImDrawList::AddPolyline, COMDAT

; 716  : {

$LN301:
	mov	r11, rsp
	mov	DWORD PTR [r11+32], r9d
	mov	QWORD PTR [r11+8], rcx
	push	rbx
	push	rdi
	push	r14
	push	r15
	sub	rsp, 248				; 000000f8H
	movsxd	r14, r8d
	mov	r15d, r9d
	mov	rdi, rdx
	mov	rbx, rcx

; 717  :     if (points_count < 2 || (col & IM_COL32_A_MASK) == 0)

	cmp	r14d, 2
	jl	$LN24@AddPolylin
	test	r9d, -16777216				; ff000000H
	je	$LN24@AddPolylin

; 718  :         return;
; 719  : 
; 720  :     const bool closed = (flags & ImDrawFlags_Closed) != 0;
; 721  :     const ImVec2 opaque_uv = _Data->TexUvWhitePixel;

	mov	rax, QWORD PTR [rcx+56]

; 722  :     const int count = closed ? points_count : points_count - 1; // The number of line segments we need to draw
; 723  :     const bool thick_line = (thickness > _FringeScale);

	lea	ecx, DWORD PTR [r14-1]
	and	BYTE PTR flags$[rsp], 1

; 724  : 
; 725  :     if (Flags & ImDrawListFlags_AntiAliasedLines)

	mov	edx, DWORD PTR [rbx+48]
	mov	QWORD PTR [r11-48], r12
	movaps	XMMWORD PTR [r11-72], xmm6
	movss	xmm6, DWORD PTR [rax]
	movaps	XMMWORD PTR [r11-88], xmm7
	movss	xmm7, DWORD PTR [rax+4]
	mov	eax, r14d
	movaps	XMMWORD PTR [r11-104], xmm8
	cmove	eax, ecx
	movss	xmm8, DWORD PTR thickness$[rsp]
	movaps	XMMWORD PTR [r11-120], xmm9
	movss	xmm9, DWORD PTR [rbx+192]
	comiss	xmm8, xmm9
	movsxd	r12, eax
	mov	QWORD PTR [r11+16], rbp
	mov	QWORD PTR tv5161[rsp], r12
	seta	r8b
	mov	BYTE PTR thick_line$1$[rsp], r8b
	test	dl, 1
	je	$LN25@AddPolylin
	mov	QWORD PTR [r11-40], rsi

; 726  :     {
; 727  :         // Anti-aliased stroke
; 728  :         const float AA_SIZE = _FringeScale;
; 729  :         const ImU32 col_trans = col & ~IM_COL32_A_MASK;

	mov	ecx, r9d
	and	ecx, 16777215				; 00ffffffH
	mov	QWORD PTR [r11-56], r13
	movaps	XMMWORD PTR [rsp+112], xmm12

; 739  :         const bool use_texture = (Flags & ImDrawListFlags_AntiAliasedLinesUseTex) && (integer_thickness < IM_DRAWLIST_TEX_LINES_WIDTH_MAX) && (fractional_thickness <= 0.00001f) && (AA_SIZE == 1.0f);

	mov	r13d, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movss	xmm12, DWORD PTR __real@3f800000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 739  :         const bool use_texture = (Flags & ImDrawListFlags_AntiAliasedLinesUseTex) && (integer_thickness < IM_DRAWLIST_TEX_LINES_WIDTH_MAX) && (fractional_thickness <= 0.00001f) && (AA_SIZE == 1.0f);

	mov	esi, 3
	mov	DWORD PTR col_trans$1$[rsp], ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm8, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 733  :         const int integer_thickness = (int)thickness;

	cvttss2si ecx, xmm8
	mov	DWORD PTR integer_thickness$1$[rsp], ecx

; 739  :         const bool use_texture = (Flags & ImDrawListFlags_AntiAliasedLinesUseTex) && (integer_thickness < IM_DRAWLIST_TEX_LINES_WIDTH_MAX) && (fractional_thickness <= 0.00001f) && (AA_SIZE == 1.0f);

	test	dl, r13b
	je	SHORT $LN46@AddPolylin
	cmp	ecx, 63					; 0000003fH
	jge	SHORT $LN46@AddPolylin
	movss	xmm1, DWORD PTR __real@3727c5ac
	movaps	xmm2, xmm8
	movd	xmm0, ecx
	cvtdq2ps xmm0, xmm0
	subss	xmm2, xmm0
	comiss	xmm1, xmm2
	jb	SHORT $LN46@AddPolylin
	ucomiss	xmm9, xmm12
	jp	SHORT $LN46@AddPolylin
	jne	SHORT $LN46@AddPolylin

; 745  :         const int vtx_count = use_texture ? (points_count * 2) : (thick_line ? points_count * 4 : points_count * 3);

	mov	ebp, r14d
	mov	BYTE PTR tv5855[rsp], 1
	imul	ebp, r13d
	lea	edx, DWORD PTR [rax+rax*2]
	mov	BYTE PTR tv5861[rsp], 1
	add	edx, edx
	mov	DWORD PTR tv5160[rsp], ebp
	mov	r8d, ebp
	jmp	SHORT $LN297@AddPolylin
$LN46@AddPolylin:

; 740  : 
; 741  :         // We should never hit this, because NewFrame() doesn't set ImDrawListFlags_AntiAliasedLinesUseTex unless ImFontAtlasFlags_NoBakedLines is off
; 742  :         IM_ASSERT_PARANOID(!use_texture || !(_Data->Font->ContainerAtlas->Flags & ImFontAtlasFlags_NoBakedLines));
; 743  : 
; 744  :         const int idx_count = use_texture ? (count * 6) : (thick_line ? count * 18 : count * 12);

	xor	ecx, ecx
	mov	BYTE PTR tv5861[rsp], cl
	mov	BYTE PTR tv5855[rsp], cl
	test	r8b, r8b
	je	SHORT $LN48@AddPolylin
	lea	edx, DWORD PTR [rax+rax*8]

; 745  :         const int vtx_count = use_texture ? (points_count * 2) : (thick_line ? points_count * 4 : points_count * 3);

	mov	ebp, r14d
	imul	ebp, 4
	add	edx, edx
	mov	rcx, rbx
	mov	r8d, ebp
	mov	DWORD PTR tv5160[rsp], ebp
	call	?PrimReserve@ImDrawList@@QEAAXHH@Z	; ImDrawList::PrimReserve

; 746  :         PrimReserve(idx_count, vtx_count);
; 747  : 
; 748  :         // Temporary buffer
; 749  :         // The first <points_count> items are normals at each line point, then after that there are either 2 or 4 temp points for each line point
; 750  :         _Data->TempBuffer.reserve_discard(points_count * ((use_texture || !thick_line) ? 3 : 5));

	mov	esi, 5
	jmp	SHORT $LN298@AddPolylin
$LN48@AddPolylin:

; 745  :         const int vtx_count = use_texture ? (points_count * 2) : (thick_line ? points_count * 4 : points_count * 3);

	mov	BYTE PTR tv5861[rsp], cl
	lea	edx, DWORD PTR [rax+rax*2]
	mov	ecx, r14d
	imul	ecx, esi
	shl	edx, 2
	mov	DWORD PTR tv5160[rsp], ecx
	mov	r8d, ecx
$LN297@AddPolylin:

; 746  :         PrimReserve(idx_count, vtx_count);
; 747  : 
; 748  :         // Temporary buffer
; 749  :         // The first <points_count> items are normals at each line point, then after that there are either 2 or 4 temp points for each line point
; 750  :         _Data->TempBuffer.reserve_discard(points_count * ((use_texture || !thick_line) ? 3 : 5));

	mov	rcx, rbx
	call	?PrimReserve@ImDrawList@@QEAAXHH@Z	; ImDrawList::PrimReserve
$LN298@AddPolylin:
	mov	rcx, QWORD PTR [rbx+56]
	imul	esi, r14d
	add	rcx, 48					; 00000030H
	mov	edx, esi
	call	?reserve_discard@?$ImVector@UImVec2@@@@QEAAXH@Z ; ImVector<ImVec2>::reserve_discard

; 751  :         ImVec2* temp_normals = _Data->TempBuffer.Data;

	mov	rax, QWORD PTR [rbx+56]
	xor	r10d, r10d

; 752  :         ImVec2* temp_points = temp_normals + points_count;
; 753  : 
; 754  :         // Calculate normals (tangents) for each line segment
; 755  :         for (int i1 = 0; i1 < count; i1++)

	movss	xmm4, DWORD PTR __xmm@80000000800000008000000080000000
	mov	r9, r14
	mov	ecx, r10d
	mov	r8d, r10d
	xorps	xmm5, xmm5
	mov	r11, QWORD PTR [rax+56]
	lea	rsi, QWORD PTR [r11+r14*8]
	cmp	r12, 4
	jl	$LC219@AddPolylin
	lea	rax, QWORD PTR [r12-3]
	mov	r15d, ecx
	mov	rbx, rax
	npad	12
$LL232@AddPolylin:

; 756  :         {
; 757  :             const int i2 = (i1 + 1) == points_count ? 0 : i1 + 1;
; 758  :             float dx = points[i2].x - points[i1].x;

	lea	rbp, QWORD PTR [rdi+r8*8]
	mov	rdx, r10
	lea	ecx, DWORD PTR [r13-1]
	cmp	ecx, r14d
	lea	rax, QWORD PTR [r8+1]
	cmovne	rdx, rax
	movss	xmm2, DWORD PTR [rdi+rdx*8]

; 759  :             float dy = points[i2].y - points[i1].y;

	movss	xmm3, DWORD PTR [rdi+rdx*8+4]
	subss	xmm2, DWORD PTR [rbp]
	subss	xmm3, DWORD PTR [rbp+4]

; 760  :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm5
	jbe	SHORT $LN222@AddPolylin
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 446  : static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

	movaps	xmm0, xmm1
	rsqrtss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 760  :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN222@AddPolylin:

; 761  :             temp_normals[i1].x = dy;

	movss	DWORD PTR [r11+r8*8], xmm3
	lea	r9, QWORD PTR [r11+r8*8]

; 762  :             temp_normals[i1].y = -dx;

	xorps	xmm2, xmm4
	lea	rdx, QWORD PTR [r8+2]
	movss	DWORD PTR [r9+4], xmm2
	cmp	r13d, r14d
	mov	rax, r10
	cmovne	rax, rdx
	movss	xmm2, DWORD PTR [rdi+rax*8]
	movss	xmm3, DWORD PTR [rdi+rax*8+4]
	subss	xmm2, DWORD PTR [rbp+8]
	subss	xmm3, DWORD PTR [rbp+12]
	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm5
	jbe	SHORT $LN225@AddPolylin
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 446  : static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

	movaps	xmm0, xmm1
	rsqrtss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 760  :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN225@AddPolylin:

; 761  :             temp_normals[i1].x = dy;

	movss	DWORD PTR [r9+8], xmm3
	lea	eax, DWORD PTR [r13+1]

; 762  :             temp_normals[i1].y = -dx;

	xorps	xmm2, xmm4
	lea	r12, QWORD PTR [r8+3]
	movss	DWORD PTR [r9+12], xmm2
	cmp	eax, r14d
	mov	rcx, r10
	cmovne	rcx, r12
	movss	xmm2, DWORD PTR [rdi+rcx*8]
	movss	xmm3, DWORD PTR [rdi+rcx*8+4]
	subss	xmm2, DWORD PTR [rdi+rdx*8]
	subss	xmm3, DWORD PTR [rbp+20]
	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm5
	jbe	SHORT $LN228@AddPolylin
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 446  : static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

	movaps	xmm0, xmm1
	rsqrtss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 760  :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN228@AddPolylin:

; 761  :             temp_normals[i1].x = dy;

	movss	DWORD PTR [r11+rdx*8], xmm3
	lea	rcx, QWORD PTR [r8+4]

; 762  :             temp_normals[i1].y = -dx;

	xorps	xmm2, xmm4
	lea	eax, DWORD PTR [r13+2]
	movss	DWORD PTR [r9+20], xmm2
	cmp	eax, r14d
	mov	rdx, r10
	mov	r8, rcx
	cmovne	rdx, rcx
	movss	xmm2, DWORD PTR [rdi+rdx*8]
	movss	xmm3, DWORD PTR [rdi+rdx*8+4]
	subss	xmm2, DWORD PTR [rdi+r12*8]
	subss	xmm3, DWORD PTR [rbp+28]
	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm5
	jbe	SHORT $LN231@AddPolylin
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 446  : static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

	movaps	xmm0, xmm1
	rsqrtss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 760  :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN231@AddPolylin:

; 762  :             temp_normals[i1].y = -dx;

	add	r15d, 4
	movss	DWORD PTR [r11+r12*8], xmm3
	add	r13d, 4
	xorps	xmm2, xmm4
	movss	DWORD PTR [r9+28], xmm2
	cmp	rcx, rbx
	jl	$LL232@AddPolylin
	mov	rbx, QWORD PTR this$[rsp]
	mov	r9, r14
	mov	r12, QWORD PTR tv5161[rsp]
	mov	DWORD PTR i1$1$[rsp], r15d
	mov	ecx, DWORD PTR i1$1$[rsp]
	mov	r15d, DWORD PTR col$[rsp]
$LC219@AddPolylin:

; 752  :         ImVec2* temp_points = temp_normals + points_count;
; 753  : 
; 754  :         // Calculate normals (tangents) for each line segment
; 755  :         for (int i1 = 0; i1 < count; i1++)

	cmp	r8, r12
	jge	SHORT $LN218@AddPolylin
	inc	ecx
$LC4@AddPolylin:

; 756  :         {
; 757  :             const int i2 = (i1 + 1) == points_count ? 0 : i1 + 1;
; 758  :             float dx = points[i2].x - points[i1].x;

	cmp	ecx, r14d
	lea	rdx, QWORD PTR [r8+1]
	mov	rax, r10
	cmovne	rax, rdx
	movss	xmm2, DWORD PTR [rdi+rax*8]

; 759  :             float dy = points[i2].y - points[i1].y;

	movss	xmm3, DWORD PTR [rdi+rax*8+4]
	subss	xmm2, DWORD PTR [rdi+r8*8]
	subss	xmm3, DWORD PTR [rdi+r8*8+4]

; 760  :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm5
	jbe	SHORT $LN27@AddPolylin
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 446  : static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

	movaps	xmm0, xmm1
	rsqrtss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 760  :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN27@AddPolylin:

; 762  :             temp_normals[i1].y = -dx;

	xorps	xmm2, xmm4
	movss	DWORD PTR [r11+r8*8], xmm3
	inc	ecx
	movss	DWORD PTR [r11+r8*8+4], xmm2
	mov	r8, rdx
	cmp	rdx, r12
	jl	SHORT $LC4@AddPolylin
$LN218@AddPolylin:

; 763  :         }
; 764  :         if (!closed)

	movzx	eax, BYTE PTR flags$[rsp]
	mov	r8, r9
	test	al, al
	jne	SHORT $LN233@AddPolylin

; 765  :             temp_normals[points_count - 1] = temp_normals[points_count - 2];

	movsd	xmm0, QWORD PTR [r11+r9*8-16]
	movsd	QWORD PTR [r11+r9*8-8], xmm0
$LN233@AddPolylin:

; 766  : 
; 767  :         // If we are drawing a one-pixel-wide line without a texture, or a textured line of any width, we only need 2 or 3 vertices per point
; 768  :         if (use_texture || !thick_line)

	movss	xmm4, DWORD PTR __real@3f000000
	cmp	BYTE PTR tv5855[rsp], r10b
	jne	$LN244@AddPolylin
	cmp	BYTE PTR thick_line$1$[rsp], r10b
	je	$LN61@AddPolylin
	movaps	XMMWORD PTR [rsp+144], xmm10

; 863  :                 }
; 864  :             }
; 865  :         }
; 866  :         else
; 867  :         {
; 868  :             // [PATH 2] Non texture-based lines (thick): we need to draw the solid line core and thus require four vertices per point
; 869  :             const float half_inner_thickness = (thickness - AA_SIZE) * 0.5f;

	subss	xmm8, xmm9
	movaps	XMMWORD PTR [rsp+128], xmm11
	movaps	xmm10, xmm4

; 870  : 
; 871  :             // If line is not closed, the first and last points need to be generated differently as there are no normals to blend
; 872  :             if (!closed)

	lea	rdx, QWORD PTR [rsi+16]
	mulss	xmm8, xmm10
	movaps	xmm11, xmm8
	addss	xmm11, xmm9
	test	al, al
	jne	$LN39@AddPolylin
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2536 : static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	movaps	xmm0, xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 879  :                 temp_points[points_last * 4 + 0] = points[points_last] + temp_normals[points_last] * (half_inner_thickness + AA_SIZE);

	lea	eax, DWORD PTR [r14*4-4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2536 : static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	mulss	xmm0, DWORD PTR [r11+4]
	movaps	xmm1, xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 879  :                 temp_points[points_last * 4 + 0] = points[points_last] + temp_normals[points_last] * (half_inner_thickness + AA_SIZE);

	movsxd	rcx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2536 : static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	mulss	xmm1, DWORD PTR [r11]

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm0, DWORD PTR [rdi+4]
	addss	xmm1, DWORD PTR [rdi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 875  :                 temp_points[0] = points[0] + temp_normals[0] * (half_inner_thickness + AA_SIZE);

	movss	DWORD PTR [rsi+4], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2536 : static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	movaps	xmm0, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 875  :                 temp_points[0] = points[0] + temp_normals[0] * (half_inner_thickness + AA_SIZE);

	movss	DWORD PTR [rsi], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2536 : static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	movaps	xmm1, xmm8
	mulss	xmm0, DWORD PTR [r11+4]
	mulss	xmm1, DWORD PTR [r11]

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm0, DWORD PTR [rdi+4]
	addss	xmm1, DWORD PTR [rdi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 876  :                 temp_points[1] = points[0] + temp_normals[0] * (half_inner_thickness);

	movss	DWORD PTR [rsi+12], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2536 : static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	movaps	xmm0, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 876  :                 temp_points[1] = points[0] + temp_normals[0] * (half_inner_thickness);

	movss	DWORD PTR [rsi+8], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2536 : static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	movaps	xmm1, xmm8
	mulss	xmm0, DWORD PTR [r11]
	mulss	xmm1, DWORD PTR [r11+4]

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm2, DWORD PTR [rdi]
	subss	xmm2, xmm0
	movss	xmm0, DWORD PTR [rdi+4]
	subss	xmm0, xmm1

; 2536 : static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	movaps	xmm1, xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 877  :                 temp_points[2] = points[0] - temp_normals[0] * (half_inner_thickness);

	movss	DWORD PTR [rdx], xmm2
	movss	DWORD PTR [rdx+4], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2536 : static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	movaps	xmm0, xmm11
	mulss	xmm0, DWORD PTR [r11]
	mulss	xmm1, DWORD PTR [r11+4]

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm2, DWORD PTR [rdi]
	subss	xmm2, xmm0
	movss	xmm0, DWORD PTR [rdi+4]
	subss	xmm0, xmm1

; 2536 : static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	movaps	xmm1, xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 878  :                 temp_points[3] = points[0] - temp_normals[0] * (half_inner_thickness + AA_SIZE);

	movss	DWORD PTR [rsi+24], xmm2
	movss	DWORD PTR [rsi+28], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2536 : static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	movaps	xmm0, xmm11
	mulss	xmm0, DWORD PTR [r11+r8*8-4]
	mulss	xmm1, DWORD PTR [r11+r8*8-8]

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm0, DWORD PTR [rdi+r8*8-4]
	addss	xmm1, DWORD PTR [rdi+r8*8-8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 879  :                 temp_points[points_last * 4 + 0] = points[points_last] + temp_normals[points_last] * (half_inner_thickness + AA_SIZE);

	movss	DWORD PTR [rsi+rcx*8+4], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2536 : static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	movaps	xmm0, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 879  :                 temp_points[points_last * 4 + 0] = points[points_last] + temp_normals[points_last] * (half_inner_thickness + AA_SIZE);

	movss	DWORD PTR [rsi+rcx*8], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2536 : static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	movaps	xmm1, xmm8
	mulss	xmm0, DWORD PTR [r11+r8*8-4]
	mulss	xmm1, DWORD PTR [r11+r8*8-8]

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm0, DWORD PTR [rdi+r8*8-4]
	addss	xmm1, DWORD PTR [rdi+r8*8-8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 880  :                 temp_points[points_last * 4 + 1] = points[points_last] + temp_normals[points_last] * (half_inner_thickness);

	movss	DWORD PTR [rsi+rcx*8+12], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2536 : static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	movaps	xmm0, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 880  :                 temp_points[points_last * 4 + 1] = points[points_last] + temp_normals[points_last] * (half_inner_thickness);

	movss	DWORD PTR [rsi+rcx*8+8], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2536 : static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	movaps	xmm1, xmm8
	mulss	xmm0, DWORD PTR [r11+r8*8-8]
	mulss	xmm1, DWORD PTR [r11+r8*8-4]

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm2, DWORD PTR [rdi+r8*8-8]
	subss	xmm2, xmm0
	movss	xmm0, DWORD PTR [rdi+r8*8-4]
	subss	xmm0, xmm1

; 2536 : static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	movaps	xmm1, xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 881  :                 temp_points[points_last * 4 + 2] = points[points_last] - temp_normals[points_last] * (half_inner_thickness);

	movss	DWORD PTR [rsi+rcx*8+16], xmm2
	movss	DWORD PTR [rsi+rcx*8+20], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2536 : static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	movaps	xmm0, xmm11
	mulss	xmm0, DWORD PTR [r11+r8*8-8]

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm2, DWORD PTR [rdi+r8*8-8]

; 2536 : static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	mulss	xmm1, DWORD PTR [r11+r8*8-4]

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	subss	xmm2, xmm0
	movss	xmm0, DWORD PTR [rdi+r8*8-4]
	subss	xmm0, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 882  :                 temp_points[points_last * 4 + 3] = points[points_last] - temp_normals[points_last] * (half_inner_thickness + AA_SIZE);

	movss	DWORD PTR [rsi+rcx*8+24], xmm2
	movss	DWORD PTR [rsi+rcx*8+28], xmm0
$LN39@AddPolylin:

; 883  :             }
; 884  : 
; 885  :             // Generate the indices to form a number of triangles for each line segment, and the vertices for the line edges
; 886  :             // This takes points n and n+1 and writes into n+1, with the first point in a closed line being generated from the final one (as n+1 wraps)
; 887  :             // FIXME-OPT: Merge the different loops, possibly remove the temporary buffer.
; 888  :             unsigned int idx1 = _VtxCurrentIdx; // Vertex index for start of line segment

	lea	r13, QWORD PTR [rbx+52]
	mov	r12d, DWORD PTR [r13]

; 889  :             for (int i1 = 0; i1 < count; i1++) // i1 is the first point of the line segment

	cmp	QWORD PTR tv5161[rsp], r10
	jle	$LN15@AddPolylin

; 765  :             temp_normals[points_count - 1] = temp_normals[points_count - 2];

	movss	xmm9, DWORD PTR __real@42c80000
	mov	rdx, r10
	mov	r15, QWORD PTR tv5161[rsp]
	mov	ebp, 1

; 889  :             for (int i1 = 0; i1 < count; i1++) // i1 is the first point of the line segment

	movaps	XMMWORD PTR [rsp+96], xmm13
	movss	xmm13, DWORD PTR __real@358637bd
	npad	14
$LL16@AddPolylin:

; 890  :             {
; 891  :                 const int i2 = (i1 + 1) == points_count ? 0 : (i1 + 1); // i2 is the second point of the line segment
; 892  :                 const unsigned int idx2 = (i1 + 1) == points_count ? _VtxCurrentIdx : (idx1 + 4); // Vertex index for end of segment

	lea	rcx, QWORD PTR [rdx+1]
	cmp	ebp, r14d
	mov	rax, r10
	mov	QWORD PTR tv5580[rsp], rcx
	cmovne	rax, rcx
	jne	SHORT $LN68@AddPolylin
	mov	r8d, DWORD PTR [r13]
	jmp	SHORT $LN299@AddPolylin
$LN68@AddPolylin:
	lea	r8d, DWORD PTR [r12+4]
$LN299@AddPolylin:

; 893  : 
; 894  :                 // Average normals
; 895  :                 float dm_x = (temp_normals[i1].x + temp_normals[i2].x) * 0.5f;

	movss	xmm4, DWORD PTR [r11+rdx*8]
	lea	rcx, QWORD PTR [rax*8]

; 896  :                 float dm_y = (temp_normals[i1].y + temp_normals[i2].y) * 0.5f;

	movss	xmm5, DWORD PTR [rcx+r11+4]
	addss	xmm5, DWORD PTR [r11+rdx*8+4]
	addss	xmm4, DWORD PTR [rcx+r11]
	mov	DWORD PTR idx2$1$[rsp], r8d
	mulss	xmm5, xmm10
	mulss	xmm4, xmm10

; 897  :                 IM_FIXNORMAL2F(dm_x, dm_y);

	movaps	xmm1, xmm5
	mulss	xmm1, xmm5
	movaps	xmm0, xmm4
	mulss	xmm0, xmm4
	addss	xmm1, xmm0
	comiss	xmm1, xmm13
	jbe	SHORT $LN40@AddPolylin
	movaps	xmm0, xmm12
	divss	xmm0, xmm1
	movaps	xmm1, xmm9
	minss	xmm1, xmm0
	mulss	xmm4, xmm1
	mulss	xmm5, xmm1
$LN40@AddPolylin:

; 898  :                 float dm_out_x = dm_x * (half_inner_thickness + AA_SIZE);
; 899  :                 float dm_out_y = dm_y * (half_inner_thickness + AA_SIZE);
; 900  :                 float dm_in_x = dm_x * half_inner_thickness;
; 901  :                 float dm_in_y = dm_y * half_inner_thickness;
; 902  : 
; 903  :                 // Add temporary vertices
; 904  :                 ImVec2* out_vtx = &temp_points[i2 * 4];

	shl	rax, 5

; 905  :                 out_vtx[0].x = points[i2].x + dm_out_x;
; 906  :                 out_vtx[0].y = points[i2].y + dm_out_y;
; 907  :                 out_vtx[1].x = points[i2].x + dm_in_x;
; 908  :                 out_vtx[1].y = points[i2].y + dm_in_y;
; 909  :                 out_vtx[2].x = points[i2].x - dm_in_x;
; 910  :                 out_vtx[2].y = points[i2].y - dm_in_y;
; 911  :                 out_vtx[3].x = points[i2].x - dm_out_x;
; 912  :                 out_vtx[3].y = points[i2].y - dm_out_y;
; 913  : 
; 914  :                 // Add indexes
; 915  :                 _IdxWritePtr[0]  = (ImDrawIdx)(idx2 + 1); _IdxWritePtr[1]  = (ImDrawIdx)(idx1 + 1); _IdxWritePtr[2]  = (ImDrawIdx)(idx1 + 2);

	lea	edx, DWORD PTR [r12+2]
	add	rax, rsi
	lea	r9d, DWORD PTR [r8+1]
	movaps	xmm2, xmm11
	movaps	xmm3, xmm11
	mulss	xmm2, xmm4

; 916  :                 _IdxWritePtr[3]  = (ImDrawIdx)(idx1 + 2); _IdxWritePtr[4]  = (ImDrawIdx)(idx2 + 2); _IdxWritePtr[5]  = (ImDrawIdx)(idx2 + 1);

	add	r8w, 2
	inc	ebp
	mulss	xmm3, xmm5
	movaps	xmm0, xmm2
	mulss	xmm4, xmm8
	addss	xmm0, DWORD PTR [rcx+rdi]
	mulss	xmm5, xmm8
	movaps	xmm1, xmm4
	movss	DWORD PTR [rax], xmm0
	movaps	xmm0, xmm3
	addss	xmm0, DWORD PTR [rcx+rdi+4]
	movss	DWORD PTR [rax+4], xmm0
	movaps	xmm0, xmm5
	addss	xmm1, DWORD PTR [rcx+rdi]
	movss	DWORD PTR [rax+8], xmm1
	addss	xmm0, DWORD PTR [rcx+rdi+4]
	movss	DWORD PTR [rax+12], xmm0
	movss	xmm1, DWORD PTR [rcx+rdi]
	subss	xmm1, xmm4
	movss	DWORD PTR [rax+16], xmm1
	movss	xmm0, DWORD PTR [rcx+rdi+4]
	subss	xmm0, xmm5
	movss	DWORD PTR [rax+20], xmm0
	movss	xmm1, DWORD PTR [rcx+rdi]
	subss	xmm1, xmm2
	movss	DWORD PTR [rax+24], xmm1
	movss	xmm0, DWORD PTR [rcx+rdi+4]
	lea	ecx, DWORD PTR [r12+1]
	subss	xmm0, xmm3
	movss	DWORD PTR [rax+28], xmm0
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax], r9w
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+2], cx
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+4], dx
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+6], dx
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+8], r8w
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+10], r9w

; 917  :                 _IdxWritePtr[6]  = (ImDrawIdx)(idx2 + 1); _IdxWritePtr[7]  = (ImDrawIdx)(idx1 + 1); _IdxWritePtr[8]  = (ImDrawIdx)(idx1 + 0);

	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+12], r9w
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+14], cx
	mov	rax, QWORD PTR [rbx+80]

; 918  :                 _IdxWritePtr[9]  = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[10] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[11] = (ImDrawIdx)(idx2 + 1);

	mov	ecx, DWORD PTR idx2$1$[rsp]
	mov	WORD PTR [rax+16], r12w
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+18], r12w

; 919  :                 _IdxWritePtr[12] = (ImDrawIdx)(idx2 + 2); _IdxWritePtr[13] = (ImDrawIdx)(idx1 + 2); _IdxWritePtr[14] = (ImDrawIdx)(idx1 + 3);

	add	r12w, 3
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+20], cx

; 920  :                 _IdxWritePtr[15] = (ImDrawIdx)(idx1 + 3); _IdxWritePtr[16] = (ImDrawIdx)(idx2 + 3); _IdxWritePtr[17] = (ImDrawIdx)(idx2 + 2);

	add	cx, 3
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+22], r9w
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+24], r8w
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+26], dx
	mov	rax, QWORD PTR [rbx+80]
	mov	rdx, QWORD PTR tv5580[rsp]
	mov	WORD PTR [rax+28], r12w
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+30], r12w
	mov	rax, QWORD PTR [rbx+80]

; 921  :                 _IdxWritePtr += 18;
; 922  : 
; 923  :                 idx1 = idx2;

	mov	r12d, DWORD PTR idx2$1$[rsp]
	mov	WORD PTR [rax+32], cx
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+34], r8w
	add	QWORD PTR [rbx+80], 36			; 00000024H
	cmp	rdx, r15
	jl	$LL16@AddPolylin

; 882  :                 temp_points[points_last * 4 + 3] = points[points_last] - temp_normals[points_last] * (half_inner_thickness + AA_SIZE);

	movaps	xmm13, XMMWORD PTR [rsp+96]
	lea	rdx, QWORD PTR [rsi+16]
	mov	r15d, DWORD PTR col$[rsp]
	mov	r9, r14
$LN15@AddPolylin:

; 924  :             }
; 925  : 
; 926  :             // Add vertices
; 927  :             for (int i = 0; i < points_count; i++)

	movaps	xmm11, XMMWORD PTR [rsp+128]
	movaps	xmm10, XMMWORD PTR [rsp+144]
	test	r9, r9
	je	$LN12@AddPolylin
	mov	ecx, DWORD PTR col_trans$1$[rsp]
	npad	14
$LL19@AddPolylin:

; 928  :             {
; 929  :                 _VtxWritePtr[0].pos = temp_points[i * 4 + 0]; _VtxWritePtr[0].uv = opaque_uv; _VtxWritePtr[0].col = col_trans;

	movsd	xmm0, QWORD PTR [rdx-16]
	lea	rdx, QWORD PTR [rdx+32]
	mov	rax, QWORD PTR [rbx+72]
	inc	r10
	movsd	QWORD PTR [rax], xmm0
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+8], xmm6
	movss	DWORD PTR [rax+12], xmm7
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+16], ecx

; 930  :                 _VtxWritePtr[1].pos = temp_points[i * 4 + 1]; _VtxWritePtr[1].uv = opaque_uv; _VtxWritePtr[1].col = col;

	movsd	xmm0, QWORD PTR [rdx-40]
	mov	rax, QWORD PTR [rbx+72]
	movsd	QWORD PTR [rax+20], xmm0
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+28], xmm6
	movss	DWORD PTR [rax+32], xmm7
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+36], r15d

; 931  :                 _VtxWritePtr[2].pos = temp_points[i * 4 + 2]; _VtxWritePtr[2].uv = opaque_uv; _VtxWritePtr[2].col = col;

	movsd	xmm0, QWORD PTR [rdx-32]
	mov	rax, QWORD PTR [rbx+72]
	movsd	QWORD PTR [rax+40], xmm0
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+48], xmm6
	movss	DWORD PTR [rax+52], xmm7
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+56], r15d

; 932  :                 _VtxWritePtr[3].pos = temp_points[i * 4 + 3]; _VtxWritePtr[3].uv = opaque_uv; _VtxWritePtr[3].col = col_trans;

	mov	rax, QWORD PTR [rbx+72]
	movsd	xmm0, QWORD PTR [rdx-24]
	movsd	QWORD PTR [rax+60], xmm0
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+68], xmm6
	movss	DWORD PTR [rax+72], xmm7
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+76], ecx

; 933  :                 _VtxWritePtr += 4;

	add	QWORD PTR [rbx+72], 80			; 00000050H
	cmp	r10, r9
	jl	$LL19@AddPolylin

; 717  :     if (points_count < 2 || (col & IM_COL32_A_MASK) == 0)

	jmp	$LN12@AddPolylin
$LN244@AddPolylin:

; 769  :         {
; 770  :             // [PATH 1] Texture-based lines (thick or non-thick)
; 771  :             // [PATH 2] Non texture-based lines (non-thick)
; 772  : 
; 773  :             // The width of the geometry we need to draw - this is essentially <thickness> pixels for the line itself, plus "one pixel" for AA.
; 774  :             // - In the texture-based path, we don't use AA_SIZE here because the +1 is tied to the generated texture
; 775  :             //   (see ImFontAtlasBuildRenderLinesTexData() function), and so alternate values won't work without changes to that code.
; 776  :             // - In the non texture-based paths, we would allow AA_SIZE to potentially be != 1.0f with a patch (e.g. fringe_scale patch to
; 777  :             //   allow scaling geometry while preserving one-screen-pixel AA fringe).
; 778  :             const float half_draw_size = use_texture ? ((thickness * 0.5f) + 1) : AA_SIZE;

	movaps	xmm9, xmm8
	mulss	xmm9, xmm4
	addss	xmm9, xmm12
$LN61@AddPolylin:

; 779  : 
; 780  :             // If line is not closed, the first and last points need to be generated differently as there are no normals to blend
; 781  :             if (!closed)

	test	al, al
	jne	$LN32@AddPolylin
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2536 : static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	movaps	xmm0, xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 785  :                 temp_points[(points_count-1)*2+0] = points[points_count-1] + temp_normals[points_count-1] * half_draw_size;

	lea	eax, DWORD PTR [r14+r14]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2536 : static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	mulss	xmm0, DWORD PTR [r11+4]
	movaps	xmm1, xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 785  :                 temp_points[(points_count-1)*2+0] = points[points_count-1] + temp_normals[points_count-1] * half_draw_size;

	movsxd	rcx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2536 : static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	mulss	xmm1, DWORD PTR [r11]

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm0, DWORD PTR [rdi+4]
	addss	xmm1, DWORD PTR [rdi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 783  :                 temp_points[0] = points[0] + temp_normals[0] * half_draw_size;

	movss	DWORD PTR [rsi+4], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2536 : static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	movaps	xmm0, xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 783  :                 temp_points[0] = points[0] + temp_normals[0] * half_draw_size;

	movss	DWORD PTR [rsi], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2536 : static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	movaps	xmm1, xmm9
	mulss	xmm0, DWORD PTR [r11]
	mulss	xmm1, DWORD PTR [r11+4]

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm2, DWORD PTR [rdi]
	subss	xmm2, xmm0
	movss	xmm0, DWORD PTR [rdi+4]
	subss	xmm0, xmm1

; 2536 : static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	movaps	xmm1, xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 784  :                 temp_points[1] = points[0] - temp_normals[0] * half_draw_size;

	movss	DWORD PTR [rsi+8], xmm2
	movss	DWORD PTR [rsi+12], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2536 : static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	movaps	xmm0, xmm9
	mulss	xmm0, DWORD PTR [r11+r8*8-4]
	mulss	xmm1, DWORD PTR [r11+r8*8-8]

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm0, DWORD PTR [rdi+r8*8-4]
	addss	xmm1, DWORD PTR [rdi+r8*8-8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 785  :                 temp_points[(points_count-1)*2+0] = points[points_count-1] + temp_normals[points_count-1] * half_draw_size;

	movss	DWORD PTR [rsi+rcx*8-12], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2536 : static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	movaps	xmm0, xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 785  :                 temp_points[(points_count-1)*2+0] = points[points_count-1] + temp_normals[points_count-1] * half_draw_size;

	movss	DWORD PTR [rsi+rcx*8-16], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2536 : static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	movaps	xmm1, xmm9
	mulss	xmm0, DWORD PTR [r11+r8*8-8]

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm2, DWORD PTR [rdi+r8*8-8]

; 2536 : static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	mulss	xmm1, DWORD PTR [r11+r8*8-4]

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	subss	xmm2, xmm0
	movss	xmm0, DWORD PTR [rdi+r8*8-4]
	subss	xmm0, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 786  :                 temp_points[(points_count-1)*2+1] = points[points_count-1] - temp_normals[points_count-1] * half_draw_size;

	movss	DWORD PTR [rsi+rcx*8-8], xmm2
	movss	DWORD PTR [rsi+rcx*8-4], xmm0
$LN32@AddPolylin:

; 787  :             }
; 788  : 
; 789  :             // Generate the indices to form a number of triangles for each line segment, and the vertices for the line edges
; 790  :             // This takes points n and n+1 and writes into n+1, with the first point in a closed line being generated from the final one (as n+1 wraps)
; 791  :             // FIXME-OPT: Merge the different loops, possibly remove the temporary buffer.
; 792  :             unsigned int idx1 = _VtxCurrentIdx; // Vertex index for start of line segment

	mov	r8d, DWORD PTR [rbx+52]
	lea	r13, QWORD PTR [rbx+52]

; 793  :             for (int i1 = 0; i1 < count; i1++) // i1 is the first point of the line segment

	test	r12, r12
	jle	$LN6@AddPolylin

; 765  :             temp_normals[points_count - 1] = temp_normals[points_count - 2];

	movss	xmm8, DWORD PTR __real@358637bd
	mov	r9, r10
	movss	xmm5, DWORD PTR __real@42c80000
	mov	ebp, 1
	movzx	r15d, BYTE PTR tv5855[rsp]
	npad	14
$LL7@AddPolylin:

; 794  :             {
; 795  :                 const int i2 = (i1 + 1) == points_count ? 0 : i1 + 1; // i2 is the second point of the line segment
; 796  :                 const unsigned int idx2 = ((i1 + 1) == points_count) ? _VtxCurrentIdx : (idx1 + (use_texture ? 2 : 3)); // Vertex index for end of segment

	lea	rax, QWORD PTR [r9+1]
	cmp	ebp, r14d
	mov	rcx, r10
	mov	QWORD PTR tv5582[rsp], rax
	cmovne	rcx, rax
	jne	SHORT $LN64@AddPolylin
	mov	edx, DWORD PTR [r13]
	jmp	SHORT $LN65@AddPolylin
$LN64@AddPolylin:
	movzx	edx, BYTE PTR tv5861[rsp]
	xor	edx, 1
	add	edx, 2
	add	edx, r8d
$LN65@AddPolylin:

; 797  : 
; 798  :                 // Average normals
; 799  :                 float dm_x = (temp_normals[i1].x + temp_normals[i2].x) * 0.5f;

	movss	xmm2, DWORD PTR [r11+r9*8]
	lea	rax, QWORD PTR [rcx*8]

; 800  :                 float dm_y = (temp_normals[i1].y + temp_normals[i2].y) * 0.5f;

	movss	xmm3, DWORD PTR [rax+r11+4]
	addss	xmm3, DWORD PTR [r11+r9*8+4]
	addss	xmm2, DWORD PTR [rax+r11]
	mulss	xmm3, xmm4
	mulss	xmm2, xmm4

; 801  :                 IM_FIXNORMAL2F(dm_x, dm_y);

	movaps	xmm1, xmm3
	mulss	xmm1, xmm3
	movaps	xmm0, xmm2
	mulss	xmm0, xmm2
	addss	xmm1, xmm0
	comiss	xmm1, xmm8
	jbe	SHORT $LN33@AddPolylin
	movaps	xmm0, xmm12
	divss	xmm0, xmm1
	movaps	xmm1, xmm5
	minss	xmm1, xmm0
	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN33@AddPolylin:

; 802  :                 dm_x *= half_draw_size; // dm_x, dm_y are offset to the outer edge of the AA area

	mulss	xmm2, xmm9

; 803  :                 dm_y *= half_draw_size;
; 804  : 
; 805  :                 // Add temporary vertexes for the outer edges
; 806  :                 ImVec2* out_vtx = &temp_points[i2 * 2];
; 807  :                 out_vtx[0].x = points[i2].x + dm_x;
; 808  :                 out_vtx[0].y = points[i2].y + dm_y;
; 809  :                 out_vtx[1].x = points[i2].x - dm_x;
; 810  :                 out_vtx[1].y = points[i2].y - dm_y;

	lea	r12d, DWORD PTR [rdx+1]
	shl	rcx, 4
	lea	r9d, DWORD PTR [r8+1]
	add	rcx, rsi
	mulss	xmm3, xmm9
	movaps	xmm0, xmm2
	addss	xmm0, DWORD PTR [rax+rdi]
	movaps	xmm1, xmm3
	movss	DWORD PTR [rcx], xmm0
	addss	xmm1, DWORD PTR [rax+rdi+4]
	movss	DWORD PTR [rcx+4], xmm1
	movss	xmm0, DWORD PTR [rax+rdi]
	subss	xmm0, xmm2
	movss	DWORD PTR [rcx+8], xmm0
	movss	xmm1, DWORD PTR [rax+rdi+4]
	subss	xmm1, xmm3
	movss	DWORD PTR [rcx+12], xmm1
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax], dx

; 811  : 
; 812  :                 if (use_texture)

	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+2], r8w
	mov	rax, QWORD PTR [rbx+80]
	test	r15b, r15b
	je	SHORT $LN35@AddPolylin

; 813  :                 {
; 814  :                     // Add indices for two triangles
; 815  :                     _IdxWritePtr[0] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[1] = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[2] = (ImDrawIdx)(idx1 + 1); // Right tri

	mov	WORD PTR [rax+4], r9w

; 816  :                     _IdxWritePtr[3] = (ImDrawIdx)(idx2 + 1); _IdxWritePtr[4] = (ImDrawIdx)(idx1 + 1); _IdxWritePtr[5] = (ImDrawIdx)(idx2 + 0); // Left tri

	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+6], r12w
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+8], r9w
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+10], dx

; 817  :                     _IdxWritePtr += 6;

	add	QWORD PTR [rbx+80], 12

; 818  :                 }

	jmp	SHORT $LN36@AddPolylin
$LN35@AddPolylin:

; 819  :                 else
; 820  :                 {
; 821  :                     // Add indexes for four triangles
; 822  :                     _IdxWritePtr[0] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[1] = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[2] = (ImDrawIdx)(idx1 + 2); // Right tri 1

	lea	ecx, DWORD PTR [r8+2]
	mov	WORD PTR [rax+4], cx

; 823  :                     _IdxWritePtr[3] = (ImDrawIdx)(idx1 + 2); _IdxWritePtr[4] = (ImDrawIdx)(idx2 + 2); _IdxWritePtr[5] = (ImDrawIdx)(idx2 + 0); // Right tri 2

	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+6], cx
	lea	ecx, DWORD PTR [rdx+2]
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+8], cx
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+10], dx

; 824  :                     _IdxWritePtr[6] = (ImDrawIdx)(idx2 + 1); _IdxWritePtr[7] = (ImDrawIdx)(idx1 + 1); _IdxWritePtr[8] = (ImDrawIdx)(idx1 + 0); // Left tri 1

	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+12], r12w
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+14], r9w
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+16], r8w
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+18], r8w

; 825  :                     _IdxWritePtr[9] = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[10] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[11] = (ImDrawIdx)(idx2 + 1); // Left tri 2

	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+20], dx
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+22], r12w

; 826  :                     _IdxWritePtr += 12;

	add	QWORD PTR [rbx+80], 24
$LN36@AddPolylin:

; 793  :             for (int i1 = 0; i1 < count; i1++) // i1 is the first point of the line segment

	mov	r9, QWORD PTR tv5582[rsp]
	inc	ebp

; 827  :                 }
; 828  : 
; 829  :                 idx1 = idx2;

	mov	r8d, edx
	cmp	r9, QWORD PTR tv5161[rsp]
	jl	$LL7@AddPolylin
	mov	r15d, DWORD PTR col$[rsp]
	mov	r9, r14
$LN6@AddPolylin:

; 830  :             }
; 831  : 
; 832  :             // Add vertexes for each point on the line
; 833  :             if (use_texture)

	cmp	BYTE PTR tv5855[rsp], r10b
	je	$LN37@AddPolylin

; 834  :             {
; 835  :                 // If we're using textures we only need to emit the left/right edge vertices
; 836  :                 ImVec4 tex_uvs = _Data->TexUvLines[integer_thickness];

	mov	rax, QWORD PTR [rbx+56]
	movsxd	rdx, DWORD PTR integer_thickness$1$[rsp]
	add	rdx, rdx
	mov	rcx, QWORD PTR [rax+520]
	movups	xmm0, XMMWORD PTR [rcx+rdx*8]
	movups	XMMWORD PTR tex_uvs$15[rsp], xmm0

; 837  :                 /*if (fractional_thickness != 0.0f) // Currently always zero when use_texture==false!
; 838  :                 {
; 839  :                     const ImVec4 tex_uvs_1 = _Data->TexUvLines[integer_thickness + 1];
; 840  :                     tex_uvs.x = tex_uvs.x + (tex_uvs_1.x - tex_uvs.x) * fractional_thickness; // inlined ImLerp()
; 841  :                     tex_uvs.y = tex_uvs.y + (tex_uvs_1.y - tex_uvs.y) * fractional_thickness;
; 842  :                     tex_uvs.z = tex_uvs.z + (tex_uvs_1.z - tex_uvs.z) * fractional_thickness;
; 843  :                     tex_uvs.w = tex_uvs.w + (tex_uvs_1.w - tex_uvs.w) * fractional_thickness;
; 844  :                 }*/
; 845  :                 ImVec2 tex_uv0(tex_uvs.x, tex_uvs.y);
; 846  :                 ImVec2 tex_uv1(tex_uvs.z, tex_uvs.w);
; 847  :                 for (int i = 0; i < points_count; i++)

	test	r9, r9
	je	$LN12@AddPolylin

; 765  :             temp_normals[points_count - 1] = temp_normals[points_count - 2];

	movss	xmm1, DWORD PTR tex_uvs$15[rsp+12]
	movss	xmm2, DWORD PTR tex_uvs$15[rsp+8]
	movss	xmm3, DWORD PTR tex_uvs$15[rsp+4]
	movss	xmm4, DWORD PTR tex_uvs$15[rsp]
	npad	7
$LL10@AddPolylin:

; 848  :                 {
; 849  :                     _VtxWritePtr[0].pos = temp_points[i * 2 + 0]; _VtxWritePtr[0].uv = tex_uv0; _VtxWritePtr[0].col = col; // Left-side outer edge

	movsd	xmm0, QWORD PTR [rsi]
	lea	rsi, QWORD PTR [rsi+16]
	mov	rax, QWORD PTR [rbx+72]
	inc	r10
	movsd	QWORD PTR [rax], xmm0
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+8], xmm4
	movss	DWORD PTR [rax+12], xmm3
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+16], r15d

; 850  :                     _VtxWritePtr[1].pos = temp_points[i * 2 + 1]; _VtxWritePtr[1].uv = tex_uv1; _VtxWritePtr[1].col = col; // Right-side outer edge

	mov	rax, QWORD PTR [rbx+72]
	movsd	xmm0, QWORD PTR [rsi-8]
	movsd	QWORD PTR [rax+20], xmm0
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+28], xmm2
	movss	DWORD PTR [rax+32], xmm1
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+36], r15d

; 851  :                     _VtxWritePtr += 2;

	add	QWORD PTR [rbx+72], 40			; 00000028H
	cmp	r10, r9
	jl	SHORT $LL10@AddPolylin

; 852  :                 }
; 853  :             }

	jmp	$LN12@AddPolylin
$LN37@AddPolylin:

; 854  :             else
; 855  :             {
; 856  :                 // If we're not using a texture, we need the center vertex as well
; 857  :                 for (int i = 0; i < points_count; i++)

	test	r9, r9
	je	$LN12@AddPolylin
	mov	ecx, DWORD PTR col_trans$1$[rsp]
	npad	7
$LL13@AddPolylin:

; 858  :                 {
; 859  :                     _VtxWritePtr[0].pos = points[i];              _VtxWritePtr[0].uv = opaque_uv; _VtxWritePtr[0].col = col;       // Center of line

	movsd	xmm0, QWORD PTR [rdi]
	lea	rdi, QWORD PTR [rdi+8]
	mov	rax, QWORD PTR [rbx+72]
	lea	rsi, QWORD PTR [rsi+16]
	inc	r10
	movsd	QWORD PTR [rax], xmm0
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+8], xmm6
	movss	DWORD PTR [rax+12], xmm7
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+16], r15d

; 860  :                     _VtxWritePtr[1].pos = temp_points[i * 2 + 0]; _VtxWritePtr[1].uv = opaque_uv; _VtxWritePtr[1].col = col_trans; // Left-side outer edge

	movsd	xmm0, QWORD PTR [rsi-16]
	mov	rax, QWORD PTR [rbx+72]
	movsd	QWORD PTR [rax+20], xmm0
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+28], xmm6
	movss	DWORD PTR [rax+32], xmm7
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+36], ecx

; 861  :                     _VtxWritePtr[2].pos = temp_points[i * 2 + 1]; _VtxWritePtr[2].uv = opaque_uv; _VtxWritePtr[2].col = col_trans; // Right-side outer edge

	mov	rax, QWORD PTR [rbx+72]
	movsd	xmm0, QWORD PTR [rsi-8]
	movsd	QWORD PTR [rax+40], xmm0
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+48], xmm6
	movss	DWORD PTR [rax+52], xmm7
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+56], ecx

; 862  :                     _VtxWritePtr += 3;

	add	QWORD PTR [rbx+72], 60			; 0000003cH
	cmp	r10, r9
	jl	SHORT $LL13@AddPolylin
$LN12@AddPolylin:

; 934  :             }
; 935  :         }
; 936  :         _VtxCurrentIdx += (ImDrawIdx)vtx_count;

	movzx	eax, WORD PTR tv5160[rsp]
	add	DWORD PTR [r13], eax
	mov	r13, QWORD PTR [rsp+224]
	movaps	xmm12, XMMWORD PTR [rsp+112]
	mov	rsi, QWORD PTR [rsp+240]

; 937  :     }

	jmp	$LN296@AddPolylin
$LN25@AddPolylin:

; 938  :     else
; 939  :     {
; 940  :         // [PATH 4] Non texture-based, Non anti-aliased lines
; 941  :         const int idx_count = count * 6;

	lea	edx, DWORD PTR [rax+rax*2]

; 942  :         const int vtx_count = count * 4;    // FIXME-OPT: Not sharing edges
; 943  :         PrimReserve(idx_count, vtx_count);

	mov	rcx, rbx
	add	edx, edx
	lea	r8d, DWORD PTR [rax*4]
	call	?PrimReserve@ImDrawList@@QEAAXHH@Z	; ImDrawList::PrimReserve

; 944  : 
; 945  :         for (int i1 = 0; i1 < count; i1++)

	test	r12, r12
	jle	$LN296@AddPolylin

; 765  :             temp_normals[points_count - 1] = temp_normals[points_count - 2];

	mulss	xmm8, DWORD PTR __real@3f000000
	xor	r10d, r10d
	mov	r8d, r10d
	xorps	xmm5, xmm5
	lea	ebp, QWORD PTR [r10+1]
	npad	11
$LL22@AddPolylin:

; 946  :         {
; 947  :             const int i2 = (i1 + 1) == points_count ? 0 : i1 + 1;
; 948  :             const ImVec2& p1 = points[i1];
; 949  :             const ImVec2& p2 = points[i2];
; 950  : 
; 951  :             float dx = p2.x - p1.x;

	movss	xmm4, DWORD PTR [rdi+r8*8]
	lea	rdx, QWORD PTR [rdi+r8*8]
	cmp	ebp, r14d
	lea	rax, QWORD PTR [r8+1]
	mov	rcx, r10
	mov	r8, rax
	cmovne	rcx, rax
	movss	xmm2, DWORD PTR [rdi+rcx*8]

; 952  :             float dy = p2.y - p1.y;

	movss	xmm3, DWORD PTR [rdi+rcx*8+4]
	subss	xmm2, xmm4
	subss	xmm3, DWORD PTR [rdx+4]

; 953  :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm5
	jbe	SHORT $LN42@AddPolylin
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 446  : static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

	movaps	xmm0, xmm1
	rsqrtss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 953  :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN42@AddPolylin:

; 954  :             dx *= (thickness * 0.5f);
; 955  :             dy *= (thickness * 0.5f);
; 956  : 
; 957  :             _VtxWritePtr[0].pos.x = p1.x + dy; _VtxWritePtr[0].pos.y = p1.y - dx; _VtxWritePtr[0].uv = opaque_uv; _VtxWritePtr[0].col = col;

	mov	rax, QWORD PTR [rbx+72]
	inc	ebp
	mulss	xmm3, xmm8
	mulss	xmm2, xmm8
	movaps	xmm0, xmm3
	addss	xmm0, xmm4
	movss	DWORD PTR [rax], xmm0

; 958  :             _VtxWritePtr[1].pos.x = p2.x + dy; _VtxWritePtr[1].pos.y = p2.y - dx; _VtxWritePtr[1].uv = opaque_uv; _VtxWritePtr[1].col = col;

	movaps	xmm0, xmm3
	movss	xmm1, DWORD PTR [rdx+4]
	mov	rax, QWORD PTR [rbx+72]
	subss	xmm1, xmm2
	movss	DWORD PTR [rax+4], xmm1
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+8], xmm6
	movss	DWORD PTR [rax+12], xmm7
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+16], r15d
	addss	xmm0, DWORD PTR [rdi+rcx*8]
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+20], xmm0
	movss	xmm1, DWORD PTR [rdi+rcx*8+4]
	mov	rax, QWORD PTR [rbx+72]
	subss	xmm1, xmm2
	movss	DWORD PTR [rax+24], xmm1

; 959  :             _VtxWritePtr[2].pos.x = p2.x - dy; _VtxWritePtr[2].pos.y = p2.y + dx; _VtxWritePtr[2].uv = opaque_uv; _VtxWritePtr[2].col = col;

	movaps	xmm1, xmm2
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+28], xmm6
	movss	DWORD PTR [rax+32], xmm7
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+36], r15d
	movss	xmm0, DWORD PTR [rdi+rcx*8]
	mov	rax, QWORD PTR [rbx+72]
	subss	xmm0, xmm3
	movss	DWORD PTR [rax+40], xmm0
	addss	xmm1, DWORD PTR [rdi+rcx*8+4]
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+44], xmm1
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+48], xmm6
	movss	DWORD PTR [rax+52], xmm7
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+56], r15d

; 960  :             _VtxWritePtr[3].pos.x = p1.x - dy; _VtxWritePtr[3].pos.y = p1.y + dx; _VtxWritePtr[3].uv = opaque_uv; _VtxWritePtr[3].col = col;

	movss	xmm0, DWORD PTR [rdx]
	mov	rax, QWORD PTR [rbx+72]
	subss	xmm0, xmm3
	movss	DWORD PTR [rax+60], xmm0
	addss	xmm2, DWORD PTR [rdx+4]
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+64], xmm2
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+68], xmm6
	movss	DWORD PTR [rax+72], xmm7
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+76], r15d

; 961  :             _VtxWritePtr += 4;
; 962  : 
; 963  :             _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx + 1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx + 2);

	mov	rcx, QWORD PTR [rbx+80]
	movzx	eax, WORD PTR [rbx+52]
	add	QWORD PTR [rbx+72], 80			; 00000050H
	mov	WORD PTR [rcx], ax
	movzx	ecx, WORD PTR [rbx+52]
	mov	rax, QWORD PTR [rbx+80]
	inc	cx
	mov	WORD PTR [rax+2], cx
	mov	rax, QWORD PTR [rbx+80]
	movzx	ecx, WORD PTR [rbx+52]
	add	cx, 2
	mov	WORD PTR [rax+4], cx

; 964  :             _IdxWritePtr[3] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[4] = (ImDrawIdx)(_VtxCurrentIdx + 2); _IdxWritePtr[5] = (ImDrawIdx)(_VtxCurrentIdx + 3);

	mov	rcx, QWORD PTR [rbx+80]
	movzx	eax, WORD PTR [rbx+52]
	mov	WORD PTR [rcx+6], ax
	mov	rax, QWORD PTR [rbx+80]
	movzx	ecx, WORD PTR [rbx+52]
	add	cx, 2
	mov	WORD PTR [rax+8], cx
	movzx	ecx, WORD PTR [rbx+52]
	mov	rax, QWORD PTR [rbx+80]
	add	cx, 3
	mov	WORD PTR [rax+10], cx

; 965  :             _IdxWritePtr += 6;

	add	QWORD PTR [rbx+80], 12

; 966  :             _VtxCurrentIdx += 4;

	add	DWORD PTR [rbx+52], 4
	cmp	r8, r12
	jl	$LL22@AddPolylin
$LN296@AddPolylin:
	mov	rbp, QWORD PTR [rsp+296]
	movaps	xmm7, XMMWORD PTR [rsp+192]
	movaps	xmm6, XMMWORD PTR [rsp+208]
	mov	r12, QWORD PTR [rsp+232]
	movaps	xmm8, XMMWORD PTR [rsp+176]
	movaps	xmm9, XMMWORD PTR [rsp+160]
$LN24@AddPolylin:

; 967  :         }
; 968  :     }
; 969  : }

	add	rsp, 248				; 000000f8H
	pop	r15
	pop	r14
	pop	rdi
	pop	rbx
	ret	0
?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z ENDP	; ImDrawList::AddPolyline
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z
_TEXT	SEGMENT
col_trans$1$ = 32
vtx_count$1$ = 36
this$ = 176
points$ = 184
tv2041 = 192
points_count$ = 192
col$ = 200
?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z PROC ; ImDrawList::AddConvexPolyFilled, COMDAT

; 974  : {

$LN88:

; 975  :     if (points_count < 3 || (col & IM_COL32_A_MASK) == 0)

	cmp	r8d, 3
	jl	$LN85@AddConvexP
	mov	r11, rsp
	push	rbx
	push	rdi
	push	r14
	push	r15
	sub	rsp, 136				; 00000088H

; 974  : {

	mov	r14d, r8d
	mov	r15d, r9d
	mov	rdi, rdx
	mov	rbx, rcx

; 975  :     if (points_count < 3 || (col & IM_COL32_A_MASK) == 0)

	test	r9d, -16777216				; ff000000H
	je	$LN18@AddConvexP

; 976  :         return;
; 977  : 
; 978  :     const ImVec2 uv = _Data->TexUvWhitePixel;
; 979  : 
; 980  :     if (Flags & ImDrawListFlags_AntiAliasedFill)

	test	BYTE PTR [rcx+48], 4
	mov	rax, QWORD PTR [rcx+56]
	movaps	XMMWORD PTR [r11-88], xmm8
	movaps	XMMWORD PTR [r11-104], xmm9
	movss	xmm8, DWORD PTR [rax]
	movss	xmm9, DWORD PTR [rax+4]
	je	$LN19@AddConvexP
	mov	QWORD PTR [r11+8], rbp

; 981  :     {
; 982  :         // Anti-aliased Fill
; 983  :         const float AA_SIZE = _FringeScale;
; 984  :         const ImU32 col_trans = col & ~IM_COL32_A_MASK;
; 985  :         const int idx_count = (points_count - 2)*3 + points_count * 6;

	lea	edx, DWORD PTR [r14*8-6]
	mov	QWORD PTR [r11+16], rsi
	mov	eax, r9d
	mov	QWORD PTR [r11+32], r12
	and	eax, 16777215				; 00ffffffH
	mov	QWORD PTR [r11-40], r13
	add	edx, r14d
	movaps	XMMWORD PTR [rsp+112], xmm6
	mov	DWORD PTR col_trans$1$[rsp], eax

; 986  :         const int vtx_count = (points_count * 2);

	lea	eax, DWORD PTR [r14+r14]
	movaps	XMMWORD PTR [rsp+96], xmm7

; 987  :         PrimReserve(idx_count, vtx_count);

	mov	r8d, eax
	movaps	XMMWORD PTR [r11-120], xmm10
	movss	xmm10, DWORD PTR [rcx+192]
	mov	DWORD PTR vtx_count$1$[rsp], eax
	call	?PrimReserve@ImDrawList@@QEAAXHH@Z	; ImDrawList::PrimReserve

; 988  : 
; 989  :         // Add indexes for fill
; 990  :         unsigned int vtx_inner_idx = _VtxCurrentIdx;

	mov	ebp, DWORD PTR [rbx+52]
	lea	rsi, QWORD PTR [rbx+80]
	mov	r8d, 2
	npad	14
$LL4@AddConvexP:

; 991  :         unsigned int vtx_outer_idx = _VtxCurrentIdx + 1;
; 992  :         for (int i = 2; i < points_count; i++)
; 993  :         {
; 994  :             _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + ((i - 1) << 1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_inner_idx + (i << 1));

	mov	rax, QWORD PTR [rsi]
	movzx	edx, r8w
	add	dx, dx
	inc	r8d
	add	dx, bp
	mov	WORD PTR [rax], bp
	mov	rax, QWORD PTR [rsi]
	lea	ecx, DWORD PTR [rdx-2]
	mov	WORD PTR [rax+2], cx
	mov	rax, QWORD PTR [rsi]
	mov	WORD PTR [rax+4], dx

; 995  :             _IdxWritePtr += 3;

	add	QWORD PTR [rsi], 6
	cmp	r8d, r14d
	jl	SHORT $LL4@AddConvexP

; 996  :         }
; 997  : 
; 998  :         // Compute normals
; 999  :         _Data->TempBuffer.reserve_discard(points_count);

	mov	rcx, QWORD PTR [rbx+56]
	mov	edx, r14d
	add	rcx, 48					; 00000030H
	call	?reserve_discard@?$ImVector@UImVec2@@@@QEAAXH@Z ; ImVector<ImVec2>::reserve_discard

; 1000 :         ImVec2* temp_normals = _Data->TempBuffer.Data;

	mov	rax, QWORD PTR [rbx+56]

; 1001 :         for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)

	lea	r12d, DWORD PTR [r14-1]
	movss	xmm4, DWORD PTR __xmm@80000000800000008000000080000000
	xor	r13d, r13d
	mov	r8d, r13d
	xorps	xmm5, xmm5
	mov	edx, r13d
	mov	r10, QWORD PTR [rax+56]
	cmp	r14d, 4
	jl	$LN64@AddConvexP
	lea	eax, DWORD PTR [r14-3]
	mov	r9, r10
	mov	DWORD PTR tv2041[rsp], eax
	sub	r9, rdi
	movsxd	rax, r14d
	mov	r13d, 12
	sub	r13, rdi
	lea	rcx, QWORD PTR [rax*8-8]
	lea	rax, QWORD PTR [rdi+12]
$LL48@AddConvexP:

; 1002 :         {
; 1003 :             const ImVec2& p0 = points[i0];
; 1004 :             const ImVec2& p1 = points[i1];
; 1005 :             float dx = p1.x - p0.x;

	movss	xmm2, DWORD PTR [rax-12]

; 1006 :             float dy = p1.y - p0.y;

	movss	xmm3, DWORD PTR [rax-8]
	subss	xmm2, DWORD PTR [rcx+rdi]
	subss	xmm3, DWORD PTR [rcx+rdi+4]

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm5
	jbe	SHORT $LN44@AddConvexP
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 446  : static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

	movaps	xmm0, xmm1
	rsqrtss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN44@AddConvexP:

; 1008 :             temp_normals[i0].x = dy;

	movss	DWORD PTR [rcx+r10], xmm3

; 1009 :             temp_normals[i0].y = -dx;

	xorps	xmm2, xmm4
	movss	DWORD PTR [rcx+r10+4], xmm2
	movss	xmm2, DWORD PTR [rax-4]
	movss	xmm3, DWORD PTR [rax]
	subss	xmm2, DWORD PTR [rax-12]
	subss	xmm3, DWORD PTR [rax-8]
	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm5
	jbe	SHORT $LN45@AddConvexP
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 446  : static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

	movaps	xmm0, xmm1
	rsqrtss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN45@AddConvexP:

; 1008 :             temp_normals[i0].x = dy;

	movss	DWORD PTR [r9+rax-12], xmm3

; 1009 :             temp_normals[i0].y = -dx;

	xorps	xmm2, xmm4
	movss	DWORD PTR [r9+rax-8], xmm2
	movss	xmm2, DWORD PTR [rax+4]
	movss	xmm3, DWORD PTR [rax+8]
	subss	xmm2, DWORD PTR [rax-4]
	subss	xmm3, DWORD PTR [rax]
	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm5
	jbe	SHORT $LN46@AddConvexP
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 446  : static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

	movaps	xmm0, xmm1
	rsqrtss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN46@AddConvexP:

; 1008 :             temp_normals[i0].x = dy;

	movss	DWORD PTR [r9+rax-4], xmm3

; 1009 :             temp_normals[i0].y = -dx;

	xorps	xmm2, xmm4
	movss	DWORD PTR [rax+r9], xmm2
	movss	xmm2, DWORD PTR [rax+12]
	movss	xmm3, DWORD PTR [rax+16]
	subss	xmm2, DWORD PTR [rax+4]
	subss	xmm3, DWORD PTR [rax+8]
	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm5
	jbe	SHORT $LN47@AddConvexP
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 446  : static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

	movaps	xmm0, xmm1
	rsqrtss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN47@AddConvexP:

; 1008 :             temp_normals[i0].x = dy;

	movss	DWORD PTR [r9+rax+4], xmm3
	lea	r11, QWORD PTR [rdx+3]

; 1009 :             temp_normals[i0].y = -dx;

	xorps	xmm2, xmm4
	lea	rcx, QWORD PTR [rax+r13]
	movss	DWORD PTR [r9+rax+8], xmm2
	add	rdx, 4
	add	rax, 32					; 00000020H
	add	r8d, 4
	cmp	r8d, DWORD PTR tv2041[rsp]
	jl	$LL48@AddConvexP

; 1001 :         for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)

	xor	r13d, r13d
	cmp	r8d, r14d
	jl	SHORT $LN49@AddConvexP
	jmp	SHORT $LN63@AddConvexP
$LN64@AddConvexP:
	movsxd	r11, r12d
$LN49@AddConvexP:
	mov	eax, r14d
	lea	rcx, QWORD PTR [r11*8]
	sub	eax, r8d
	lea	rdx, QWORD PTR [rdi+rdx*8]
	mov	r8d, eax
$LC7@AddConvexP:

; 1002 :         {
; 1003 :             const ImVec2& p0 = points[i0];
; 1004 :             const ImVec2& p1 = points[i1];
; 1005 :             float dx = p1.x - p0.x;

	movss	xmm2, DWORD PTR [rdx]

; 1006 :             float dy = p1.y - p0.y;

	movss	xmm3, DWORD PTR [rdx+4]
	subss	xmm2, DWORD PTR [rcx+rdi]
	subss	xmm3, DWORD PTR [rcx+rdi+4]

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm5
	jbe	SHORT $LN21@AddConvexP
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 446  : static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

	movaps	xmm0, xmm1
	rsqrtss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN21@AddConvexP:

; 1008 :             temp_normals[i0].x = dy;

	movss	DWORD PTR [rcx+r10], xmm3

; 1009 :             temp_normals[i0].y = -dx;

	xorps	xmm2, xmm4
	movss	DWORD PTR [rcx+r10+4], xmm2
	mov	rcx, rdx
	sub	rcx, rdi
	add	rdx, 8
	sub	r8, 1
	jne	SHORT $LC7@AddConvexP

; 1001 :         for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)

	mov	r9, r10
	lea	rsi, QWORD PTR [rbx+80]
	sub	r9, rdi
$LN63@AddConvexP:

; 1010 :         }
; 1011 : 
; 1012 :         for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)

	movss	xmm4, DWORD PTR __real@3f000000
	add	rdi, 4
	movss	xmm7, DWORD PTR __real@358637bd
	movss	xmm5, DWORD PTR __real@3f800000
	movss	xmm6, DWORD PTR __real@42c80000
	mov	r11d, DWORD PTR col_trans$1$[rsp]
	mulss	xmm10, xmm4
	npad	1
$LL10@AddConvexP:

; 1013 :         {
; 1014 :             // Average normals
; 1015 :             const ImVec2& n0 = temp_normals[i0];
; 1016 :             const ImVec2& n1 = temp_normals[i1];
; 1017 :             float dm_x = (n0.x + n1.x) * 0.5f;

	movss	xmm2, DWORD PTR [rdi+r9-4]

; 1018 :             float dm_y = (n0.y + n1.y) * 0.5f;

	movss	xmm3, DWORD PTR [rdi+r9]
	movsxd	rax, r12d
	addss	xmm2, DWORD PTR [r10+rax*8]
	addss	xmm3, DWORD PTR [r10+rax*8+4]
	mulss	xmm2, xmm4
	mulss	xmm3, xmm4

; 1019 :             IM_FIXNORMAL2F(dm_x, dm_y);

	movaps	xmm0, xmm2
	mulss	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm7
	jbe	SHORT $LN22@AddConvexP
	movaps	xmm0, xmm5
	divss	xmm0, xmm1
	movaps	xmm1, xmm6
	minss	xmm1, xmm0
	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN22@AddConvexP:

; 1020 :             dm_x *= AA_SIZE * 0.5f;
; 1021 :             dm_y *= AA_SIZE * 0.5f;
; 1022 : 
; 1023 :             // Add vertices
; 1024 :             _VtxWritePtr[0].pos.x = (points[i1].x - dm_x); _VtxWritePtr[0].pos.y = (points[i1].y - dm_y); _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;        // Inner

	movss	xmm0, DWORD PTR [rdi-4]

; 1025 :             _VtxWritePtr[1].pos.x = (points[i1].x + dm_x); _VtxWritePtr[1].pos.y = (points[i1].y + dm_y); _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col_trans;  // Outer
; 1026 :             _VtxWritePtr += 2;
; 1027 : 
; 1028 :             // Add indexes for fringes
; 1029 :             _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1)); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + (i0 << 1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1));

	movzx	edx, r13w
	mov	rax, QWORD PTR [rbx+72]
	add	r12w, r12w
	mulss	xmm2, xmm10
	add	dx, dx
	mulss	xmm3, xmm10
	lea	ecx, DWORD PTR [r12+rbp]
	subss	xmm0, xmm2
	lea	r8d, DWORD PTR [rdx+rbp]
	movss	DWORD PTR [rax], xmm0
	movss	xmm1, DWORD PTR [rdi]
	mov	rax, QWORD PTR [rbx+72]
	subss	xmm1, xmm3
	movss	DWORD PTR [rax+4], xmm1
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+8], xmm8
	movss	DWORD PTR [rax+12], xmm9
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+16], r15d
	addss	xmm2, DWORD PTR [rdi-4]
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+20], xmm2
	addss	xmm3, DWORD PTR [rdi]
	mov	rax, QWORD PTR [rbx+72]
	add	rdi, 8
	movss	DWORD PTR [rax+24], xmm3
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+28], xmm8
	movss	DWORD PTR [rax+32], xmm9
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+36], r11d
	mov	rax, QWORD PTR [rsi]
	add	QWORD PTR [rbx+72], 40			; 00000028H
	mov	WORD PTR [rax], r8w
	mov	rax, QWORD PTR [rsi]
	mov	WORD PTR [rax+2], cx
	lea	ecx, DWORD PTR [rbp+1]
	mov	rax, QWORD PTR [rsi]
	add	cx, r12w
	mov	r12d, r13d
	inc	r13d
	mov	WORD PTR [rax+4], cx

; 1030 :             _IdxWritePtr[3] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1)); _IdxWritePtr[4] = (ImDrawIdx)(vtx_outer_idx + (i1 << 1)); _IdxWritePtr[5] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1));

	mov	rax, QWORD PTR [rsi]
	mov	WORD PTR [rax+6], cx
	lea	ecx, DWORD PTR [rbp+1]
	mov	rax, QWORD PTR [rsi]
	add	ecx, edx
	mov	WORD PTR [rax+8], cx
	mov	rax, QWORD PTR [rsi]
	mov	WORD PTR [rax+10], r8w

; 1031 :             _IdxWritePtr += 6;

	add	QWORD PTR [rsi], 12
	cmp	r13d, r14d
	jl	$LL10@AddConvexP

; 1010 :         }
; 1011 : 
; 1012 :         for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)

	movaps	xmm10, XMMWORD PTR [rsp+48]
	movaps	xmm7, XMMWORD PTR [rsp+96]
	movaps	xmm6, XMMWORD PTR [rsp+112]
	mov	r13, QWORD PTR [rsp+128]
	mov	r12, QWORD PTR [rsp+200]
	mov	rsi, QWORD PTR [rsp+184]
	mov	rbp, QWORD PTR [rsp+176]

; 1032 :         }
; 1033 :         _VtxCurrentIdx += (ImDrawIdx)vtx_count;

	movzx	eax, WORD PTR vtx_count$1$[rsp]

; 1034 :     }

	jmp	$LN86@AddConvexP
$LN19@AddConvexP:

; 1035 :     else
; 1036 :     {
; 1037 :         // Non Anti-aliased Fill
; 1038 :         const int idx_count = (points_count - 2)*3;

	lea	eax, DWORD PTR [r14-2]

; 1039 :         const int vtx_count = points_count;
; 1040 :         PrimReserve(idx_count, vtx_count);

	mov	r8d, r14d
	lea	edx, DWORD PTR [rax+rax*2]
	call	?PrimReserve@ImDrawList@@QEAAXHH@Z	; ImDrawList::PrimReserve
	mov	rcx, r14
	npad	5
$LL13@AddConvexP:

; 1041 :         for (int i = 0; i < vtx_count; i++)
; 1042 :         {
; 1043 :             _VtxWritePtr[0].pos = points[i]; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;

	mov	rax, QWORD PTR [rbx+72]
	movsd	xmm0, QWORD PTR [rdi]
	lea	rdi, QWORD PTR [rdi+8]
	movsd	QWORD PTR [rax], xmm0
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+8], xmm8
	movss	DWORD PTR [rax+12], xmm9
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+16], r15d

; 1044 :             _VtxWritePtr++;

	add	QWORD PTR [rbx+72], 20
	sub	rcx, 1
	jne	SHORT $LL13@AddConvexP
	mov	r8d, 2
	npad	7
$LL16@AddConvexP:

; 1045 :         }
; 1046 :         for (int i = 2; i < points_count; i++)
; 1047 :         {
; 1048 :             _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx + i - 1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx + i);

	mov	rcx, QWORD PTR [rbx+80]
	movzx	eax, WORD PTR [rbx+52]
	mov	WORD PTR [rcx], ax
	lea	ecx, DWORD PTR [r8-1]
	add	cx, WORD PTR [rbx+52]
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+2], cx
	movzx	ecx, r8w
	mov	rax, QWORD PTR [rbx+80]
	inc	r8d
	add	cx, WORD PTR [rbx+52]
	mov	WORD PTR [rax+4], cx

; 1049 :             _IdxWritePtr += 3;

	add	QWORD PTR [rbx+80], 6
	cmp	r8d, r14d
	jl	SHORT $LL16@AddConvexP

; 1050 :         }
; 1051 :         _VtxCurrentIdx += (ImDrawIdx)vtx_count;

	movzx	eax, r14w
$LN86@AddConvexP:
	add	DWORD PTR [rbx+52], eax
	movaps	xmm8, XMMWORD PTR [rsp+80]
	movaps	xmm9, XMMWORD PTR [rsp+64]
$LN18@AddConvexP:

; 1052 :     }
; 1053 : }

	add	rsp, 136				; 00000088H
	pop	r15
	pop	r14
	pop	rdi
	pop	rbx
$LN85@AddConvexP:
	ret	0
?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z ENDP ; ImDrawList::AddConvexPolyFilled
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?PathBezierCubicCurveTo@ImDrawList@@QEAAXAEBUImVec2@@00H@Z
_TEXT	SEGMENT
this$ = 112
p2$ = 120
p3$ = 128
p4$ = 136
num_segments$dead$ = 144
?PathBezierCubicCurveTo@ImDrawList@@QEAAXAEBUImVec2@@00H@Z PROC ; ImDrawList::PathBezierCubicCurveTo, COMDAT

; 1290 : {

$LN26:
	push	rbx
	sub	rsp, 96					; 00000060H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	movsxd	r11, DWORD PTR [rcx+120]
	mov	r10, QWORD PTR [rcx+128]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1295 :         PathBezierCubicCurveToCasteljau(&_Path, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, p4.x, p4.y, _Data->CurveTessellationTol, 0); // Auto-tessellated

	mov	rax, QWORD PTR [rcx+56]
	add	rcx, 120				; 00000078H
	movss	xmm3, DWORD PTR [r9+4]
	mov	DWORD PTR [rsp+80], 0
	movss	xmm2, DWORD PTR [r10+r11*8-4]
	movss	xmm0, DWORD PTR [rax+20]
	movss	xmm1, DWORD PTR [r10+r11*8-8]
	movss	DWORD PTR [rsp+72], xmm0
	movss	xmm0, DWORD PTR [r9]
	movss	DWORD PTR [rsp+64], xmm3
	movss	xmm3, DWORD PTR [r8+4]
	movss	DWORD PTR [rsp+56], xmm0
	movss	xmm0, DWORD PTR [r8]
	movss	DWORD PTR [rsp+48], xmm3
	movss	xmm3, DWORD PTR [rdx+4]
	movss	DWORD PTR [rsp+40], xmm0
	movss	DWORD PTR [rsp+32], xmm3
	movss	xmm3, DWORD PTR [rdx]
	call	?PathBezierCubicCurveToCasteljau@@YAXPEAU?$ImVector@UImVec2@@@@MMMMMMMMMH@Z ; PathBezierCubicCurveToCasteljau

; 1296 :     }
; 1297 :     else
; 1298 :     {
; 1299 :         float t_step = 1.0f / (float)num_segments;
; 1300 :         for (int i_step = 1; i_step <= num_segments; i_step++)
; 1301 :             _Path.push_back(ImBezierCubicCalc(p1, p2, p3, p4, t_step * i_step));
; 1302 :     }
; 1303 : }

	add	rsp, 96					; 00000060H
	pop	rbx
	ret	0
?PathBezierCubicCurveTo@ImDrawList@@QEAAXAEBUImVec2@@00H@Z ENDP ; ImDrawList::PathBezierCubicCurveTo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?RenderBullet@ImGui@@YAXPEAUImDrawList@@UImVec2@@I@Z
_TEXT	SEGMENT
pos$ = 48
draw_list$ = 80
col$ = 96
?RenderBullet@ImGui@@YAXPEAUImDrawList@@UImVec2@@I@Z PROC ; ImGui::RenderBullet, COMDAT

; 3856 : {

$LN91:

; 1508 :     if ((col & IM_COL32_A_MASK) == 0 || radius < 0.5f)

	test	r8d, -16777216				; ff000000H
	je	$LN89@RenderBull
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 64					; 00000040H

; 3857 :     // FIXME-OPT: This should be baked in font.
; 3858 :     draw_list->AddCircleFilled(pos, draw_list->_Data->FontSize * 0.20f, col, 8);

	mov	rax, QWORD PTR [rcx+56]
	mov	esi, r8d

; 1508 :     if ((col & IM_COL32_A_MASK) == 0 || radius < 0.5f)

	movss	xmm0, DWORD PTR __real@3f000000

; 3856 : {

	mov	rdi, rcx
	mov	QWORD PTR pos$[rsp], rdx

; 3857 :     // FIXME-OPT: This should be baked in font.
; 3858 :     draw_list->AddCircleFilled(pos, draw_list->_Data->FontSize * 0.20f, col, 8);

	movss	xmm2, DWORD PTR [rax+16]
	mulss	xmm2, DWORD PTR __real@3e4ccccd

; 1508 :     if ((col & IM_COL32_A_MASK) == 0 || radius < 0.5f)

	comiss	xmm0, xmm2
	ja	SHORT $LN5@RenderBull

; 1186 :         _PathArcToN(center, radius, a_min, a_max, num_segments);

	movss	xmm0, DWORD PTR __real@40afede0
	lea	rdx, QWORD PTR pos$[rsp]
	mov	DWORD PTR [rsp+40], 7
	xorps	xmm3, xmm3
	movss	DWORD PTR [rsp+32], xmm0

; 1508 :     if ((col & IM_COL32_A_MASK) == 0 || radius < 0.5f)

	mov	QWORD PTR [rsp+96], rbx

; 1186 :         _PathArcToN(center, radius, a_min, a_max, num_segments);

	call	?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z ; ImDrawList::_PathArcToN
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	r8d, DWORD PTR [rdi+120]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1186 :         _PathArcToN(center, radius, a_min, a_max, num_segments);

	lea	rbx, QWORD PTR [rdi+120]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	rdx, QWORD PTR [rdi+128]
	mov	r9d, esi
	mov	rcx, rdi
	call	?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z ; ImDrawList::AddConvexPolyFilled
	mov	DWORD PTR [rbx], 0
	mov	rbx, QWORD PTR [rsp+96]
$LN5@RenderBull:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3859 : }

	mov	rsi, QWORD PTR [rsp+104]
	add	rsp, 64					; 00000040H
	pop	rdi
$LN89@RenderBull:
	ret	0
?RenderBullet@ImGui@@YAXPEAUImDrawList@@UImVec2@@I@Z ENDP ; ImGui::RenderBullet
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?StyleColorsDark@ImGui@@YAXPEAUImGuiStyle@@@Z
_TEXT	SEGMENT
dst$ = 64
?StyleColorsDark@ImGui@@YAXPEAUImGuiStyle@@@Z PROC	; ImGui::StyleColorsDark, COMDAT

; 175  : {

$LN125:
	sub	rsp, 56					; 00000038H
	movaps	XMMWORD PTR [rsp+32], xmm6
	movaps	XMMWORD PTR [rsp+16], xmm7
	movaps	XMMWORD PTR [rsp], xmm8

; 176  :     ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();

	test	rcx, rcx
	jne	SHORT $LN4@StyleColor
	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	add	rcx, 14552				; 000038d8H
$LN4@StyleColor:

; 177  :     ImVec4* colors = style->Colors;
; 178  : 
; 179  :     colors[ImGuiCol_Text]                   = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);

	mov	DWORD PTR [rcx+224], 1065353216		; 3f800000H

; 180  :     colors[ImGuiCol_TextDisabled]           = ImVec4(0.50f, 0.50f, 0.50f, 1.00f);
; 181  :     colors[ImGuiCol_WindowBg]               = ImVec4(0.06f, 0.06f, 0.06f, 0.94f);
; 182  :     colors[ImGuiCol_ChildBg]                = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);

	xor	eax, eax
	mov	DWORD PTR [rcx+228], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+232], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+236], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+240], 1056964608		; 3f000000H
	mov	DWORD PTR [rcx+244], 1056964608		; 3f000000H
	mov	DWORD PTR [rcx+248], 1056964608		; 3f000000H
	mov	DWORD PTR [rcx+252], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+256], 1031127695		; 3d75c28fH
	mov	DWORD PTR [rcx+260], 1031127695		; 3d75c28fH
	mov	DWORD PTR [rcx+264], 1031127695		; 3d75c28fH
	mov	QWORD PTR [rcx+268], 1064346583		; 3f70a3d7H
	mov	QWORD PTR [rcx+276], rax
	mov	DWORD PTR [rcx+284], eax

; 183  :     colors[ImGuiCol_PopupBg]                = ImVec4(0.08f, 0.08f, 0.08f, 0.94f);

	mov	DWORD PTR [rcx+288], 1034147594		; 3da3d70aH
	mov	DWORD PTR [rcx+292], 1034147594		; 3da3d70aH
	mov	DWORD PTR [rcx+296], 1034147594		; 3da3d70aH
	mov	DWORD PTR [rcx+300], 1064346583		; 3f70a3d7H

; 184  :     colors[ImGuiCol_Border]                 = ImVec4(0.43f, 0.43f, 0.50f, 0.50f);

	mov	DWORD PTR [rcx+304], 1054615798		; 3edc28f6H
	mov	DWORD PTR [rcx+308], 1054615798		; 3edc28f6H
	mov	DWORD PTR [rcx+312], 1056964608		; 3f000000H
	mov	QWORD PTR [rcx+316], 1056964608		; 3f000000H

; 185  :     colors[ImGuiCol_BorderShadow]           = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);

	mov	QWORD PTR [rcx+324], rax
	mov	DWORD PTR [rcx+332], eax

; 186  :     colors[ImGuiCol_FrameBg]                = ImVec4(0.16f, 0.29f, 0.48f, 0.54f);

	mov	DWORD PTR [rcx+336], 1042536202		; 3e23d70aH
	mov	DWORD PTR [rcx+340], 1049918177		; 3e947ae1H
	mov	DWORD PTR [rcx+344], 1056293519		; 3ef5c28fH
	mov	DWORD PTR [rcx+348], 1057635697		; 3f0a3d71H

; 187  :     colors[ImGuiCol_FrameBgHovered]         = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);

	mov	DWORD PTR [rcx+352], 1048911544		; 3e851eb8H
	mov	DWORD PTR [rcx+356], 1058474557		; 3f170a3dH
	mov	DWORD PTR [rcx+360], 1065017672		; 3f7ae148H
	mov	DWORD PTR [rcx+364], 1053609165		; 3ecccccdH

; 188  :     colors[ImGuiCol_FrameBgActive]          = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);

	mov	DWORD PTR [rcx+368], 1048911544		; 3e851eb8H
	mov	DWORD PTR [rcx+372], 1058474557		; 3f170a3dH
	mov	DWORD PTR [rcx+376], 1065017672		; 3f7ae148H
	mov	DWORD PTR [rcx+380], 1059816735		; 3f2b851fH

; 189  :     colors[ImGuiCol_TitleBg]                = ImVec4(0.04f, 0.04f, 0.04f, 1.00f);

	mov	DWORD PTR [rcx+384], 1025758986		; 3d23d70aH
	mov	DWORD PTR [rcx+388], 1025758986		; 3d23d70aH
	mov	DWORD PTR [rcx+392], 1025758986		; 3d23d70aH
	mov	DWORD PTR [rcx+396], 1065353216		; 3f800000H

; 190  :     colors[ImGuiCol_TitleBgActive]          = ImVec4(0.16f, 0.29f, 0.48f, 1.00f);

	mov	DWORD PTR [rcx+400], 1042536202		; 3e23d70aH
	mov	DWORD PTR [rcx+404], 1049918177		; 3e947ae1H
	mov	DWORD PTR [rcx+408], 1056293519		; 3ef5c28fH
	mov	QWORD PTR [rcx+412], 1065353216		; 3f800000H

; 191  :     colors[ImGuiCol_TitleBgCollapsed]       = ImVec4(0.00f, 0.00f, 0.00f, 0.51f);

	mov	QWORD PTR [rcx+420], rax
	mov	DWORD PTR [rcx+428], 1057132380		; 3f028f5cH

; 192  :     colors[ImGuiCol_MenuBarBg]              = ImVec4(0.14f, 0.14f, 0.14f, 1.00f);

	mov	DWORD PTR [rcx+432], 1041194025		; 3e0f5c29H
	mov	DWORD PTR [rcx+436], 1041194025		; 3e0f5c29H
	mov	DWORD PTR [rcx+440], 1041194025		; 3e0f5c29H
	mov	DWORD PTR [rcx+444], 1065353216		; 3f800000H

; 193  :     colors[ImGuiCol_ScrollbarBg]            = ImVec4(0.02f, 0.02f, 0.02f, 0.53f);

	mov	DWORD PTR [rcx+448], 1017370378		; 3ca3d70aH
	mov	DWORD PTR [rcx+452], 1017370378		; 3ca3d70aH
	mov	DWORD PTR [rcx+456], 1017370378		; 3ca3d70aH
	mov	DWORD PTR [rcx+460], 1057467924		; 3f07ae14H

; 194  :     colors[ImGuiCol_ScrollbarGrab]          = ImVec4(0.31f, 0.31f, 0.31f, 1.00f);

	mov	DWORD PTR [rcx+464], 1050589266		; 3e9eb852H
	mov	DWORD PTR [rcx+468], 1050589266		; 3e9eb852H
	mov	DWORD PTR [rcx+472], 1050589266		; 3e9eb852H
	mov	DWORD PTR [rcx+476], 1065353216		; 3f800000H

; 195  :     colors[ImGuiCol_ScrollbarGrabHovered]   = ImVec4(0.41f, 0.41f, 0.41f, 1.00f);

	mov	DWORD PTR [rcx+480], 1053944709		; 3ed1eb85H
	mov	DWORD PTR [rcx+484], 1053944709		; 3ed1eb85H
	mov	DWORD PTR [rcx+488], 1053944709		; 3ed1eb85H
	mov	DWORD PTR [rcx+492], 1065353216		; 3f800000H

; 196  :     colors[ImGuiCol_ScrollbarGrabActive]    = ImVec4(0.51f, 0.51f, 0.51f, 1.00f);

	mov	DWORD PTR [rcx+496], 1057132380		; 3f028f5cH
	mov	DWORD PTR [rcx+500], 1057132380		; 3f028f5cH
	mov	DWORD PTR [rcx+504], 1057132380		; 3f028f5cH
	mov	DWORD PTR [rcx+508], 1065353216		; 3f800000H

; 197  :     colors[ImGuiCol_CheckMark]              = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);

	mov	DWORD PTR [rcx+512], 1048911544		; 3e851eb8H
	mov	DWORD PTR [rcx+516], 1058474557		; 3f170a3dH
	mov	DWORD PTR [rcx+520], 1065017672		; 3f7ae148H
	mov	DWORD PTR [rcx+524], 1065353216		; 3f800000H

; 198  :     colors[ImGuiCol_SliderGrab]             = ImVec4(0.24f, 0.52f, 0.88f, 1.00f);

	mov	DWORD PTR [rcx+528], 1047904911		; 3e75c28fH
	mov	DWORD PTR [rcx+532], 1057300152		; 3f051eb8H
	mov	DWORD PTR [rcx+536], 1063339950		; 3f6147aeH
	mov	DWORD PTR [rcx+540], 1065353216		; 3f800000H

; 199  :     colors[ImGuiCol_SliderGrabActive]       = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);

	mov	DWORD PTR [rcx+544], 1048911544		; 3e851eb8H
	mov	DWORD PTR [rcx+548], 1058474557		; 3f170a3dH
	mov	DWORD PTR [rcx+552], 1065017672		; 3f7ae148H
	mov	DWORD PTR [rcx+556], 1065353216		; 3f800000H

; 200  :     colors[ImGuiCol_Button]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);

	mov	DWORD PTR [rcx+560], 1048911544		; 3e851eb8H
	mov	DWORD PTR [rcx+564], 1058474557		; 3f170a3dH
	mov	DWORD PTR [rcx+568], 1065017672		; 3f7ae148H
	mov	DWORD PTR [rcx+572], 1053609165		; 3ecccccdH

; 201  :     colors[ImGuiCol_ButtonHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);

	mov	DWORD PTR [rcx+576], 1048911544		; 3e851eb8H
	mov	DWORD PTR [rcx+580], 1058474557		; 3f170a3dH
	mov	DWORD PTR [rcx+584], 1065017672		; 3f7ae148H
	mov	DWORD PTR [rcx+588], 1065353216		; 3f800000H

; 202  :     colors[ImGuiCol_ButtonActive]           = ImVec4(0.06f, 0.53f, 0.98f, 1.00f);

	mov	DWORD PTR [rcx+592], 1031127695		; 3d75c28fH
	mov	DWORD PTR [rcx+596], 1057467924		; 3f07ae14H
	mov	DWORD PTR [rcx+600], 1065017672		; 3f7ae148H
	mov	DWORD PTR [rcx+604], 1065353216		; 3f800000H

; 203  :     colors[ImGuiCol_Header]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.31f);

	mov	DWORD PTR [rcx+608], 1048911544		; 3e851eb8H
	mov	DWORD PTR [rcx+612], 1058474557		; 3f170a3dH
	mov	DWORD PTR [rcx+616], 1065017672		; 3f7ae148H
	mov	DWORD PTR [rcx+620], 1050589266		; 3e9eb852H

; 204  :     colors[ImGuiCol_HeaderHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 0.80f);

	mov	DWORD PTR [rcx+624], 1048911544		; 3e851eb8H
	mov	DWORD PTR [rcx+628], 1058474557		; 3f170a3dH
	mov	DWORD PTR [rcx+632], 1065017672		; 3f7ae148H
	mov	DWORD PTR [rcx+636], 1061997773		; 3f4ccccdH

; 205  :     colors[ImGuiCol_HeaderActive]           = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);

	mov	DWORD PTR [rcx+640], 1048911544		; 3e851eb8H
	mov	DWORD PTR [rcx+644], 1058474557		; 3f170a3dH
	mov	DWORD PTR [rcx+648], 1065017672		; 3f7ae148H
	mov	DWORD PTR [rcx+652], 1065353216		; 3f800000H

; 206  :     colors[ImGuiCol_Separator]              = colors[ImGuiCol_Border];

	movups	xmm0, XMMWORD PTR [rcx+304]
	movups	XMMWORD PTR [rcx+656], xmm0

; 207  :     colors[ImGuiCol_SeparatorHovered]       = ImVec4(0.10f, 0.40f, 0.75f, 0.78f);

	mov	DWORD PTR [rcx+672], 1036831949		; 3dcccccdH
	mov	DWORD PTR [rcx+676], 1053609165		; 3ecccccdH
	mov	DWORD PTR [rcx+680], 1061158912		; 3f400000H
	mov	DWORD PTR [rcx+684], 1061662228		; 3f47ae14H

; 208  :     colors[ImGuiCol_SeparatorActive]        = ImVec4(0.10f, 0.40f, 0.75f, 1.00f);

	mov	DWORD PTR [rcx+688], 1036831949		; 3dcccccdH
	mov	DWORD PTR [rcx+692], 1053609165		; 3ecccccdH
	mov	DWORD PTR [rcx+696], 1061158912		; 3f400000H
	mov	DWORD PTR [rcx+700], 1065353216		; 3f800000H

; 209  :     colors[ImGuiCol_ResizeGrip]             = ImVec4(0.26f, 0.59f, 0.98f, 0.20f);

	mov	DWORD PTR [rcx+704], 1048911544		; 3e851eb8H
	mov	DWORD PTR [rcx+708], 1058474557		; 3f170a3dH
	mov	DWORD PTR [rcx+712], 1065017672		; 3f7ae148H
	mov	DWORD PTR [rcx+716], 1045220557		; 3e4ccccdH

; 210  :     colors[ImGuiCol_ResizeGripHovered]      = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);

	mov	DWORD PTR [rcx+720], 1048911544		; 3e851eb8H
	mov	DWORD PTR [rcx+724], 1058474557		; 3f170a3dH
	mov	DWORD PTR [rcx+728], 1065017672		; 3f7ae148H
	mov	DWORD PTR [rcx+732], 1059816735		; 3f2b851fH

; 211  :     colors[ImGuiCol_ResizeGripActive]       = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);

	mov	DWORD PTR [rcx+736], 1048911544		; 3e851eb8H
	mov	DWORD PTR [rcx+740], 1058474557		; 3f170a3dH
	mov	DWORD PTR [rcx+744], 1065017672		; 3f7ae148H
	mov	DWORD PTR [rcx+748], 1064514355		; 3f733333H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 467  : static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t)          { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }

	movss	xmm0, DWORD PTR [rcx+612]
	movss	xmm7, DWORD PTR __real@3f4ccccd
	movss	xmm4, DWORD PTR [rcx+608]
	movss	xmm3, DWORD PTR [rcx+408]
	movss	xmm1, DWORD PTR [rcx+620]
	movss	xmm2, DWORD PTR [rcx+412]
	movss	xmm5, DWORD PTR [rcx+404]
	subss	xmm2, xmm1
	movss	xmm6, DWORD PTR [rcx+400]
	subss	xmm5, xmm0
	mulss	xmm2, xmm7
	mulss	xmm5, xmm7
	addss	xmm2, xmm1
	addss	xmm5, xmm0
	movss	xmm0, DWORD PTR [rcx+616]
	subss	xmm3, xmm0
	mulss	xmm3, xmm7
	addss	xmm3, xmm0
	movaps	xmm0, xmm6
	subss	xmm0, xmm4
	mulss	xmm0, xmm7
	addss	xmm0, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 212  :     colors[ImGuiCol_Tab]                    = ImLerp(colors[ImGuiCol_Header],       colors[ImGuiCol_TitleBgActive], 0.80f);

	movss	DWORD PTR [rcx+752], xmm0
	movss	DWORD PTR [rcx+756], xmm5
	movss	DWORD PTR [rcx+760], xmm3
	movss	DWORD PTR [rcx+764], xmm2

; 213  :     colors[ImGuiCol_TabHovered]             = colors[ImGuiCol_HeaderHovered];

	movups	xmm0, XMMWORD PTR [rcx+624]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 467  : static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t)          { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }

	movss	xmm2, DWORD PTR __real@3f19999a
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 213  :     colors[ImGuiCol_TabHovered]             = colors[ImGuiCol_HeaderHovered];

	movups	XMMWORD PTR [rcx+768], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 467  : static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t)          { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }

	movss	xmm0, DWORD PTR [rcx+644]
	movss	xmm4, DWORD PTR [rcx+404]
	movss	xmm8, DWORD PTR [rcx+640]
	subss	xmm4, xmm0
	movss	xmm3, DWORD PTR [rcx+408]
	mulss	xmm4, xmm2
	addss	xmm4, xmm0
	movss	xmm0, DWORD PTR [rcx+648]
	movss	xmm1, DWORD PTR [rcx+652]
	subss	xmm3, xmm0
	subss	xmm6, xmm8
	mulss	xmm3, xmm2
	mulss	xmm6, xmm2
	addss	xmm3, xmm0
	movss	xmm0, DWORD PTR [rcx+412]
	subss	xmm0, xmm1
	addss	xmm6, xmm8
	mulss	xmm0, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 214  :     colors[ImGuiCol_TabActive]              = ImLerp(colors[ImGuiCol_HeaderActive], colors[ImGuiCol_TitleBgActive], 0.60f);

	movss	DWORD PTR [rcx+784], xmm6
	movss	DWORD PTR [rcx+788], xmm4
	movss	DWORD PTR [rcx+792], xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 467  : static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t)          { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }

	addss	xmm0, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 214  :     colors[ImGuiCol_TabActive]              = ImLerp(colors[ImGuiCol_HeaderActive], colors[ImGuiCol_TitleBgActive], 0.60f);

	movss	DWORD PTR [rcx+796], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 467  : static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t)          { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }

	movss	xmm0, DWORD PTR [rcx+756]
	movss	xmm1, DWORD PTR [rcx+760]
	movss	xmm3, DWORD PTR [rcx+752]
	movss	xmm4, DWORD PTR [rcx+388]
	movss	xmm2, DWORD PTR [rcx+392]
	subss	xmm4, xmm0
	movss	xmm6, DWORD PTR [rcx+384]
	subss	xmm2, xmm1
	mulss	xmm4, xmm7
	mulss	xmm2, xmm7
	addss	xmm4, xmm0
	movss	xmm0, DWORD PTR [rcx+764]
	addss	xmm2, xmm1
	movss	xmm1, DWORD PTR [rcx+396]
	subss	xmm1, xmm0
	mulss	xmm1, xmm7
	addss	xmm1, xmm0
	movaps	xmm0, xmm6
	subss	xmm0, xmm3
	mulss	xmm0, xmm7
	addss	xmm0, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 215  :     colors[ImGuiCol_TabUnfocused]           = ImLerp(colors[ImGuiCol_Tab],          colors[ImGuiCol_TitleBg], 0.80f);

	movss	DWORD PTR [rcx+800], xmm0
	movss	DWORD PTR [rcx+804], xmm4
	movss	DWORD PTR [rcx+808], xmm2
	movss	DWORD PTR [rcx+812], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 467  : static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t)          { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }

	movss	xmm3, DWORD PTR __real@3ecccccd
	movss	xmm0, DWORD PTR [rcx+788]
	movss	xmm1, DWORD PTR [rcx+796]
	movss	xmm2, DWORD PTR [rcx+392]
	movss	xmm4, DWORD PTR [rcx+784]
	movss	xmm5, DWORD PTR [rcx+388]
	subss	xmm6, xmm4
	subss	xmm5, xmm0
	mulss	xmm6, xmm3
	mulss	xmm5, xmm3
	addss	xmm6, xmm4
	addss	xmm5, xmm0
	movss	xmm0, DWORD PTR [rcx+792]
	subss	xmm2, xmm0
	mulss	xmm2, xmm3
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR [rcx+396]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 216  :     colors[ImGuiCol_TabUnfocusedActive]     = ImLerp(colors[ImGuiCol_TabActive],    colors[ImGuiCol_TitleBg], 0.40f);

	movss	DWORD PTR [rcx+816], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 467  : static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t)          { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }

	subss	xmm0, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 216  :     colors[ImGuiCol_TabUnfocusedActive]     = ImLerp(colors[ImGuiCol_TabActive],    colors[ImGuiCol_TitleBg], 0.40f);

	movss	DWORD PTR [rcx+820], xmm5
	movss	DWORD PTR [rcx+824], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 467  : static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t)          { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }

	mulss	xmm0, xmm3
	addss	xmm0, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 216  :     colors[ImGuiCol_TabUnfocusedActive]     = ImLerp(colors[ImGuiCol_TabActive],    colors[ImGuiCol_TitleBg], 0.40f);

	movss	DWORD PTR [rcx+828], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2551 : static inline ImVec4  operator*(const ImVec4& lhs, const ImVec4& rhs)   { return ImVec4(lhs.x * rhs.x, lhs.y * rhs.y, lhs.z * rhs.z, lhs.w * rhs.w); }

	movss	xmm2, DWORD PTR [rcx+652]
	mulss	xmm2, DWORD PTR __real@3f333333
	movss	xmm0, DWORD PTR [rcx+644]
	movss	xmm1, DWORD PTR [rcx+648]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 217  :     colors[ImGuiCol_DockingPreview]         = colors[ImGuiCol_HeaderActive] * ImVec4(1.0f, 1.0f, 1.0f, 0.7f);

	movss	DWORD PTR [rcx+832], xmm8
	movss	DWORD PTR [rcx+836], xmm0
	movss	DWORD PTR [rcx+840], xmm1
	movss	DWORD PTR [rcx+844], xmm2

; 218  :     colors[ImGuiCol_DockingEmptyBg]         = ImVec4(0.20f, 0.20f, 0.20f, 1.00f);

	mov	DWORD PTR [rcx+848], 1045220557		; 3e4ccccdH
	mov	DWORD PTR [rcx+852], 1045220557		; 3e4ccccdH
	mov	DWORD PTR [rcx+856], 1045220557		; 3e4ccccdH
	mov	DWORD PTR [rcx+860], 1065353216		; 3f800000H

; 219  :     colors[ImGuiCol_PlotLines]              = ImVec4(0.61f, 0.61f, 0.61f, 1.00f);

	mov	DWORD PTR [rcx+864], 1058810102		; 3f1c28f6H
	mov	DWORD PTR [rcx+868], 1058810102		; 3f1c28f6H
	mov	DWORD PTR [rcx+872], 1058810102		; 3f1c28f6H
	mov	DWORD PTR [rcx+876], 1065353216		; 3f800000H

; 220  :     colors[ImGuiCol_PlotLinesHovered]       = ImVec4(1.00f, 0.43f, 0.35f, 1.00f);

	mov	DWORD PTR [rcx+880], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+884], 1054615798		; 3edc28f6H
	mov	DWORD PTR [rcx+888], 1051931443		; 3eb33333H
	mov	DWORD PTR [rcx+892], 1065353216		; 3f800000H

; 221  :     colors[ImGuiCol_PlotHistogram]          = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);

	mov	DWORD PTR [rcx+896], 1063675494		; 3f666666H
	mov	QWORD PTR [rcx+900], 1060320051		; 3f333333H
	mov	DWORD PTR [rcx+908], 1065353216		; 3f800000H

; 222  :     colors[ImGuiCol_PlotHistogramHovered]   = ImVec4(1.00f, 0.60f, 0.00f, 1.00f);

	mov	DWORD PTR [rcx+912], 1065353216		; 3f800000H
	mov	QWORD PTR [rcx+916], 1058642330		; 3f19999aH
	mov	DWORD PTR [rcx+924], 1065353216		; 3f800000H

; 223  :     colors[ImGuiCol_TableHeaderBg]          = ImVec4(0.19f, 0.19f, 0.20f, 1.00f);

	mov	DWORD PTR [rcx+928], 1044549468		; 3e428f5cH
	mov	DWORD PTR [rcx+932], 1044549468		; 3e428f5cH
	mov	DWORD PTR [rcx+936], 1045220557		; 3e4ccccdH
	mov	DWORD PTR [rcx+940], 1065353216		; 3f800000H

; 224  :     colors[ImGuiCol_TableBorderStrong]      = ImVec4(0.31f, 0.31f, 0.35f, 1.00f);   // Prefer using Alpha=1.0 here

	mov	DWORD PTR [rcx+944], 1050589266		; 3e9eb852H
	mov	DWORD PTR [rcx+948], 1050589266		; 3e9eb852H
	mov	DWORD PTR [rcx+952], 1051931443		; 3eb33333H
	mov	DWORD PTR [rcx+956], 1065353216		; 3f800000H

; 225  :     colors[ImGuiCol_TableBorderLight]       = ImVec4(0.23f, 0.23f, 0.25f, 1.00f);   // Prefer using Alpha=1.0 here

	mov	DWORD PTR [rcx+960], 1047233823		; 3e6b851fH
	mov	DWORD PTR [rcx+964], 1047233823		; 3e6b851fH
	mov	DWORD PTR [rcx+968], 1048576000		; 3e800000H
	mov	QWORD PTR [rcx+972], 1065353216		; 3f800000H

; 226  :     colors[ImGuiCol_TableRowBg]             = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);

	mov	QWORD PTR [rcx+980], rax
	mov	DWORD PTR [rcx+988], eax

; 227  :     colors[ImGuiCol_TableRowBgAlt]          = ImVec4(1.00f, 1.00f, 1.00f, 0.06f);

	mov	DWORD PTR [rcx+992], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+996], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+1000], 1065353216	; 3f800000H
	mov	DWORD PTR [rcx+1004], 1031127695	; 3d75c28fH

; 228  :     colors[ImGuiCol_TextSelectedBg]         = ImVec4(0.26f, 0.59f, 0.98f, 0.35f);

	mov	DWORD PTR [rcx+1008], 1048911544	; 3e851eb8H
	mov	DWORD PTR [rcx+1012], 1058474557	; 3f170a3dH
	mov	DWORD PTR [rcx+1016], 1065017672	; 3f7ae148H
	mov	DWORD PTR [rcx+1020], 1051931443	; 3eb33333H

; 229  :     colors[ImGuiCol_DragDropTarget]         = ImVec4(1.00f, 1.00f, 0.00f, 0.90f);

	mov	DWORD PTR [rcx+1024], 1065353216	; 3f800000H
	mov	QWORD PTR [rcx+1028], 1065353216	; 3f800000H
	mov	DWORD PTR [rcx+1036], 1063675494	; 3f666666H

; 230  :     colors[ImGuiCol_NavHighlight]           = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);

	mov	DWORD PTR [rcx+1040], 1048911544	; 3e851eb8H
	mov	DWORD PTR [rcx+1044], 1058474557	; 3f170a3dH
	mov	DWORD PTR [rcx+1048], 1065017672	; 3f7ae148H
	mov	DWORD PTR [rcx+1052], 1065353216	; 3f800000H

; 231  :     colors[ImGuiCol_NavWindowingHighlight]  = ImVec4(1.00f, 1.00f, 1.00f, 0.70f);

	mov	DWORD PTR [rcx+1056], 1065353216	; 3f800000H
	mov	DWORD PTR [rcx+1060], 1065353216	; 3f800000H
	mov	DWORD PTR [rcx+1064], 1065353216	; 3f800000H
	mov	DWORD PTR [rcx+1068], 1060320051	; 3f333333H

; 232  :     colors[ImGuiCol_NavWindowingDimBg]      = ImVec4(0.80f, 0.80f, 0.80f, 0.20f);

	mov	DWORD PTR [rcx+1072], 1061997773	; 3f4ccccdH
	mov	DWORD PTR [rcx+1076], 1061997773	; 3f4ccccdH
	mov	DWORD PTR [rcx+1080], 1061997773	; 3f4ccccdH
	mov	DWORD PTR [rcx+1084], 1045220557	; 3e4ccccdH

; 233  :     colors[ImGuiCol_ModalWindowDimBg]       = ImVec4(0.80f, 0.80f, 0.80f, 0.35f);

	mov	DWORD PTR [rcx+1088], 1061997773	; 3f4ccccdH
	mov	DWORD PTR [rcx+1092], 1061997773	; 3f4ccccdH
	mov	DWORD PTR [rcx+1096], 1061997773	; 3f4ccccdH
	mov	DWORD PTR [rcx+1100], 1051931443	; 3eb33333H

; 234  : }

	movaps	xmm6, XMMWORD PTR [rsp+32]
	movaps	xmm7, XMMWORD PTR [rsp+16]
	movaps	xmm8, XMMWORD PTR [rsp]
	add	rsp, 56					; 00000038H
	ret	0
?StyleColorsDark@ImGui@@YAXPEAUImGuiStyle@@@Z ENDP	; ImGui::StyleColorsDark
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?AddDrawListToDrawDataEx@ImGui@@YAXPEAUImDrawData@@PEAU?$ImVector@PEAUImDrawList@@@@PEAUImDrawList@@@Z
_TEXT	SEGMENT
draw_data$ = 48
out_list$ = 56
draw_list$ = 64
?AddDrawListToDrawDataEx@ImGui@@YAXPEAUImDrawData@@PEAU?$ImVector@PEAUImDrawList@@@@PEAUImDrawList@@@Z PROC ; ImGui::AddDrawListToDrawDataEx, COMDAT

; 1830 : {

$LN24:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1831 :     if (draw_list->CmdBuffer.Size == 0)

	mov	eax, DWORD PTR [r8]
	mov	rdi, r8
	mov	rbx, rdx
	mov	rsi, rcx
	test	eax, eax
	je	SHORT $LN1@AddDrawLis

; 1832 :         return;
; 1833 :     if (draw_list->CmdBuffer.Size == 1 && draw_list->CmdBuffer[0].ElemCount == 0 && draw_list->CmdBuffer[0].UserCallback == NULL)

	cmp	eax, 1
	jne	SHORT $LN3@AddDrawLis
	mov	rax, QWORD PTR [r8+8]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN3@AddDrawLis
	cmp	QWORD PTR [rax+40], 0
	je	SHORT $LN1@AddDrawLis
$LN3@AddDrawLis:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	r8d, DWORD PTR [rdx]
	mov	ecx, DWORD PTR [rdx+4]
	cmp	r8d, ecx
	jne	SHORT $LN12@AddDrawLis
	inc	r8d

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN16@AddDrawLis
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN17@AddDrawLis
$LN16@AddDrawLis:
	mov	eax, 8
$LN17@AddDrawLis:
	cmp	eax, r8d

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rcx, rbx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	r8d, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, r8d
	call	?reserve@?$ImVector@PEAUImDrawList@@@@QEAAXH@Z ; ImVector<ImDrawList *>::reserve
$LN12@AddDrawLis:
	movsxd	rcx, DWORD PTR [rbx]
	mov	rax, QWORD PTR [rbx+8]
	mov	QWORD PTR [rax+rcx*8], rdi
	inc	DWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1863 :     draw_data->CmdListsCount++;

	inc	DWORD PTR [rsi+4]

; 1864 :     draw_data->TotalVtxCount += draw_list->VtxBuffer.Size;

	mov	eax, DWORD PTR [rdi+32]
	add	DWORD PTR [rsi+12], eax

; 1865 :     draw_data->TotalIdxCount += draw_list->IdxBuffer.Size;

	mov	eax, DWORD PTR [rdi+16]
	add	DWORD PTR [rsi+8], eax
$LN1@AddDrawLis:

; 1866 : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?AddDrawListToDrawDataEx@ImGui@@YAXPEAUImDrawData@@PEAU?$ImVector@PEAUImDrawList@@@@PEAUImDrawList@@@Z ENDP ; ImGui::AddDrawListToDrawDataEx
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?RenderRectFilledWithHole@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@1IM@Z
_TEXT	SEGMENT
tv888 = 48
$T1 = 52
$T2 = 52
$T3 = 52
$T4 = 52
$T5 = 52
$T6 = 60
$T7 = 60
$T8 = 60
$T9 = 60
$T10 = 60
$T11 = 60
draw_list$ = 224
fill_L$1$ = 232
$T12 = 232
$T13 = 232
outer$ = 232
fill_R$1$ = 240
$T14 = 240
$T15 = 240
$T16 = 240
inner$ = 240
col$ = 248
rounding$ = 256
?RenderRectFilledWithHole@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@1IM@Z PROC ; ImGui::RenderRectFilledWithHole, COMDAT

; 3967 : {

$LN58:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-87]
	sub	rsp, 160				; 000000a0H

; 3968 :     const bool fill_L = (inner.Min.x > outer.Min.x);
; 3969 :     const bool fill_R = (inner.Max.x < outer.Max.x);
; 3970 :     const bool fill_U = (inner.Min.y > outer.Min.y);
; 3971 :     const bool fill_D = (inner.Max.y < outer.Max.y);

	movss	xmm1, DWORD PTR [rdx+12]
	mov	rdi, rdx
	movss	xmm2, DWORD PTR [r8+4]
	mov	esi, r9d
	movss	xmm0, DWORD PTR [r8+12]
	mov	rbx, r8
	movaps	XMMWORD PTR [rax-72], xmm6
	mov	r14, rcx

; 3972 :     if (fill_L) draw_list->AddRectFilled(ImVec2(outer.Min.x, inner.Min.y), ImVec2(inner.Min.x, inner.Max.y), col, rounding, ImDrawFlags_RoundCornersNone | (fill_U ? 0 : ImDrawFlags_RoundCornersTopLeft)    | (fill_D ? 0 : ImDrawFlags_RoundCornersBottomLeft));

	movss	xmm6, DWORD PTR rounding$[rbp-129]
	movaps	XMMWORD PTR [rax-88], xmm7
	movss	xmm7, DWORD PTR [r8+8]
	movaps	XMMWORD PTR [rax-104], xmm8
	movss	xmm8, DWORD PTR [rdx+8]
	movaps	XMMWORD PTR [rax-120], xmm9
	movss	xmm9, DWORD PTR [r8]
	movaps	XMMWORD PTR [rsp+80], xmm10
	movss	xmm10, DWORD PTR [rdx]
	comiss	xmm9, xmm10
	seta	al
	comiss	xmm8, xmm7
	mov	BYTE PTR fill_L$1$[rbp-129], al
	seta	r13b
	comiss	xmm2, DWORD PTR [rdx+4]
	mov	BYTE PTR fill_R$1$[rbp-129], r13b
	mov	edx, 256				; 00000100H
	seta	r15b
	comiss	xmm1, xmm0
	seta	r12b
	test	al, al
	je	SHORT $LN43@RenderRect
	movzx	eax, r12b
	movzx	ecx, r15b
	xor	ecx, 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T5[rbp-129], xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3972 :     if (fill_L) draw_list->AddRectFilled(ImVec2(outer.Min.x, inner.Min.y), ImVec2(inner.Min.x, inner.Max.y), col, rounding, ImDrawFlags_RoundCornersNone | (fill_U ? 0 : ImDrawFlags_RoundCornersTopLeft)    | (fill_D ? 0 : ImDrawFlags_RoundCornersBottomLeft));

	shl	ecx, 4
	lea	r8, QWORD PTR $T5[rbp-129]
	xor	al, 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T5[rbp-125], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3972 :     if (fill_L) draw_list->AddRectFilled(ImVec2(outer.Min.x, inner.Min.y), ImVec2(inner.Min.x, inner.Max.y), col, rounding, ImDrawFlags_RoundCornersNone | (fill_U ? 0 : ImDrawFlags_RoundCornersTopLeft)    | (fill_D ? 0 : ImDrawFlags_RoundCornersBottomLeft));

	movzx	eax, al
	mov	DWORD PTR tv888[rbp-129], eax
	shl	eax, 6
	or	ecx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T11[rbp-129], xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3972 :     if (fill_L) draw_list->AddRectFilled(ImVec2(outer.Min.x, inner.Min.y), ImVec2(inner.Min.x, inner.Max.y), col, rounding, ImDrawFlags_RoundCornersNone | (fill_U ? 0 : ImDrawFlags_RoundCornersTopLeft)    | (fill_D ? 0 : ImDrawFlags_RoundCornersBottomLeft));

	or	ecx, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T11[rbp-125], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3972 :     if (fill_L) draw_list->AddRectFilled(ImVec2(outer.Min.x, inner.Min.y), ImVec2(inner.Min.x, inner.Max.y), col, rounding, ImDrawFlags_RoundCornersNone | (fill_U ? 0 : ImDrawFlags_RoundCornersTopLeft)    | (fill_D ? 0 : ImDrawFlags_RoundCornersBottomLeft));

	mov	DWORD PTR [rsp+40], ecx
	lea	rdx, QWORD PTR $T11[rbp-129]
	mov	rcx, r14
	movss	DWORD PTR [rsp+32], xmm6
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
	mov	eax, DWORD PTR tv888[rbp-129]
	mov	edx, 256				; 00000100H
	jmp	SHORT $LN2@RenderRect
$LN43@RenderRect:
	comiss	xmm1, xmm0
	setbe	al
$LN2@RenderRect:

; 3973 :     if (fill_R) draw_list->AddRectFilled(ImVec2(inner.Max.x, inner.Min.y), ImVec2(outer.Max.x, inner.Max.y), col, rounding, ImDrawFlags_RoundCornersNone | (fill_U ? 0 : ImDrawFlags_RoundCornersTopRight)   | (fill_D ? 0 : ImDrawFlags_RoundCornersBottomRight));

	test	r13b, r13b
	je	SHORT $LN3@RenderRect
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm0, DWORD PTR [rdi+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3973 :     if (fill_R) draw_list->AddRectFilled(ImVec2(inner.Max.x, inner.Min.y), ImVec2(outer.Max.x, inner.Max.y), col, rounding, ImDrawFlags_RoundCornersNone | (fill_U ? 0 : ImDrawFlags_RoundCornersTopRight)   | (fill_D ? 0 : ImDrawFlags_RoundCornersBottomRight));

	lea	r8, QWORD PTR $T10[rbp-129]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm1, DWORD PTR [rbx+12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3973 :     if (fill_R) draw_list->AddRectFilled(ImVec2(inner.Max.x, inner.Min.y), ImVec2(outer.Max.x, inner.Max.y), col, rounding, ImDrawFlags_RoundCornersNone | (fill_U ? 0 : ImDrawFlags_RoundCornersTopRight)   | (fill_D ? 0 : ImDrawFlags_RoundCornersBottomRight));

	mov	r9d, esi
	movzx	ecx, r15b
	xor	ecx, 1
	movzx	eax, al
	shl	ecx, 5
	shl	eax, 7
	or	ecx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T10[rbp-129], xmm0
	movss	xmm0, DWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3973 :     if (fill_R) draw_list->AddRectFilled(ImVec2(inner.Max.x, inner.Min.y), ImVec2(outer.Max.x, inner.Max.y), col, rounding, ImDrawFlags_RoundCornersNone | (fill_U ? 0 : ImDrawFlags_RoundCornersTopRight)   | (fill_D ? 0 : ImDrawFlags_RoundCornersBottomRight));

	or	ecx, edx
	mov	DWORD PTR [rsp+40], ecx
	lea	rdx, QWORD PTR $T4[rbp-129]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T10[rbp-125], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3973 :     if (fill_R) draw_list->AddRectFilled(ImVec2(inner.Max.x, inner.Min.y), ImVec2(outer.Max.x, inner.Max.y), col, rounding, ImDrawFlags_RoundCornersNone | (fill_U ? 0 : ImDrawFlags_RoundCornersTopRight)   | (fill_D ? 0 : ImDrawFlags_RoundCornersBottomRight));

	mov	rcx, r14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm1, DWORD PTR [rbx+4]
	movss	DWORD PTR $T4[rbp-129], xmm0
	movss	DWORD PTR $T4[rbp-125], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3973 :     if (fill_R) draw_list->AddRectFilled(ImVec2(inner.Max.x, inner.Min.y), ImVec2(outer.Max.x, inner.Max.y), col, rounding, ImDrawFlags_RoundCornersNone | (fill_U ? 0 : ImDrawFlags_RoundCornersTopRight)   | (fill_D ? 0 : ImDrawFlags_RoundCornersBottomRight));

	movss	DWORD PTR [rsp+32], xmm6
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
$LN3@RenderRect:

; 3974 :     if (fill_U) draw_list->AddRectFilled(ImVec2(inner.Min.x, outer.Min.y), ImVec2(inner.Max.x, inner.Min.y), col, rounding, ImDrawFlags_RoundCornersNone | (fill_L ? 0 : ImDrawFlags_RoundCornersTopLeft)    | (fill_R ? 0 : ImDrawFlags_RoundCornersTopRight));

	test	r15b, r15b
	je	SHORT $LN44@RenderRect
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm0, DWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3974 :     if (fill_U) draw_list->AddRectFilled(ImVec2(inner.Min.x, outer.Min.y), ImVec2(inner.Max.x, inner.Min.y), col, rounding, ImDrawFlags_RoundCornersNone | (fill_L ? 0 : ImDrawFlags_RoundCornersTopLeft)    | (fill_R ? 0 : ImDrawFlags_RoundCornersTopRight));

	lea	r8, QWORD PTR $T9[rbp-129]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm1, DWORD PTR [rbx+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3974 :     if (fill_U) draw_list->AddRectFilled(ImVec2(inner.Min.x, outer.Min.y), ImVec2(inner.Max.x, inner.Min.y), col, rounding, ImDrawFlags_RoundCornersNone | (fill_L ? 0 : ImDrawFlags_RoundCornersTopLeft)    | (fill_R ? 0 : ImDrawFlags_RoundCornersTopRight));

	lea	rdx, QWORD PTR $T3[rbp-129]
	comiss	xmm8, xmm7
	mov	eax, 256				; 00000100H
	mov	ecx, 272				; 00000110H
	mov	r9d, esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T9[rbp-129], xmm0
	movss	xmm0, DWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3974 :     if (fill_U) draw_list->AddRectFilled(ImVec2(inner.Min.x, outer.Min.y), ImVec2(inner.Max.x, inner.Min.y), col, rounding, ImDrawFlags_RoundCornersNone | (fill_L ? 0 : ImDrawFlags_RoundCornersTopLeft)    | (fill_R ? 0 : ImDrawFlags_RoundCornersTopRight));

	setbe	r13b
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T9[rbp-125], xmm1
	movss	xmm1, DWORD PTR [rdi+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3974 :     if (fill_U) draw_list->AddRectFilled(ImVec2(inner.Min.x, outer.Min.y), ImVec2(inner.Max.x, inner.Min.y), col, rounding, ImDrawFlags_RoundCornersNone | (fill_L ? 0 : ImDrawFlags_RoundCornersTopLeft)    | (fill_R ? 0 : ImDrawFlags_RoundCornersTopRight));

	comiss	xmm9, xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T3[rbp-129], xmm0
	movss	DWORD PTR $T3[rbp-125], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3974 :     if (fill_U) draw_list->AddRectFilled(ImVec2(inner.Min.x, outer.Min.y), ImVec2(inner.Max.x, inner.Min.y), col, rounding, ImDrawFlags_RoundCornersNone | (fill_L ? 0 : ImDrawFlags_RoundCornersTopLeft)    | (fill_R ? 0 : ImDrawFlags_RoundCornersTopRight));

	cmova	ecx, eax
	movzx	eax, r13b
	shl	eax, 5
	or	ecx, eax
	mov	DWORD PTR [rsp+40], ecx
	mov	rcx, r14
	movss	DWORD PTR [rsp+32], xmm6
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
	jmp	SHORT $LN4@RenderRect
$LN44@RenderRect:
	comiss	xmm8, xmm7
	setbe	r13b
$LN4@RenderRect:

; 3975 :     if (fill_D) draw_list->AddRectFilled(ImVec2(inner.Min.x, inner.Max.y), ImVec2(inner.Max.x, outer.Max.y), col, rounding, ImDrawFlags_RoundCornersNone | (fill_L ? 0 : ImDrawFlags_RoundCornersBottomLeft) | (fill_R ? 0 : ImDrawFlags_RoundCornersBottomRight));

	test	r12b, r12b
	je	SHORT $LN5@RenderRect
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm0, DWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3975 :     if (fill_D) draw_list->AddRectFilled(ImVec2(inner.Min.x, inner.Max.y), ImVec2(inner.Max.x, outer.Max.y), col, rounding, ImDrawFlags_RoundCornersNone | (fill_L ? 0 : ImDrawFlags_RoundCornersBottomLeft) | (fill_R ? 0 : ImDrawFlags_RoundCornersBottomRight));

	lea	r8, QWORD PTR $T8[rbp-129]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm1, DWORD PTR [rdi+12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3975 :     if (fill_D) draw_list->AddRectFilled(ImVec2(inner.Min.x, inner.Max.y), ImVec2(inner.Max.x, outer.Max.y), col, rounding, ImDrawFlags_RoundCornersNone | (fill_L ? 0 : ImDrawFlags_RoundCornersBottomLeft) | (fill_R ? 0 : ImDrawFlags_RoundCornersBottomRight));

	lea	rdx, QWORD PTR $T2[rbp-129]
	mov	eax, 256				; 00000100H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T8[rbp-129], xmm0
	movss	xmm0, DWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3975 :     if (fill_D) draw_list->AddRectFilled(ImVec2(inner.Min.x, inner.Max.y), ImVec2(inner.Max.x, outer.Max.y), col, rounding, ImDrawFlags_RoundCornersNone | (fill_L ? 0 : ImDrawFlags_RoundCornersBottomLeft) | (fill_R ? 0 : ImDrawFlags_RoundCornersBottomRight));

	mov	ecx, 320				; 00000140H
	comiss	xmm9, xmm10
	mov	r9d, esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T8[rbp-125], xmm1
	movss	xmm1, DWORD PTR [rbx+12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3975 :     if (fill_D) draw_list->AddRectFilled(ImVec2(inner.Min.x, inner.Max.y), ImVec2(inner.Max.x, outer.Max.y), col, rounding, ImDrawFlags_RoundCornersNone | (fill_L ? 0 : ImDrawFlags_RoundCornersBottomLeft) | (fill_R ? 0 : ImDrawFlags_RoundCornersBottomRight));

	cmova	ecx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T2[rbp-129], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3975 :     if (fill_D) draw_list->AddRectFilled(ImVec2(inner.Min.x, inner.Max.y), ImVec2(inner.Max.x, outer.Max.y), col, rounding, ImDrawFlags_RoundCornersNone | (fill_L ? 0 : ImDrawFlags_RoundCornersBottomLeft) | (fill_R ? 0 : ImDrawFlags_RoundCornersBottomRight));

	movzx	eax, r13b
	shl	eax, 7
	or	ecx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T2[rbp-125], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3975 :     if (fill_D) draw_list->AddRectFilled(ImVec2(inner.Min.x, inner.Max.y), ImVec2(inner.Max.x, outer.Max.y), col, rounding, ImDrawFlags_RoundCornersNone | (fill_L ? 0 : ImDrawFlags_RoundCornersBottomLeft) | (fill_R ? 0 : ImDrawFlags_RoundCornersBottomRight));

	mov	DWORD PTR [rsp+40], ecx
	mov	rcx, r14
	movss	DWORD PTR [rsp+32], xmm6
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
$LN5@RenderRect:

; 3976 :     if (fill_L && fill_U) draw_list->AddRectFilled(ImVec2(outer.Min.x, outer.Min.y), ImVec2(inner.Min.x, inner.Min.y), col, rounding, ImDrawFlags_RoundCornersTopLeft);

	cmp	BYTE PTR fill_L$1$[rbp-129], 0
	je	SHORT $LN6@RenderRect
	test	r15b, r15b
	je	SHORT $LN6@RenderRect
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm0, DWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3976 :     if (fill_L && fill_U) draw_list->AddRectFilled(ImVec2(outer.Min.x, outer.Min.y), ImVec2(inner.Min.x, inner.Min.y), col, rounding, ImDrawFlags_RoundCornersTopLeft);

	lea	r8, QWORD PTR $T7[rbp-129]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm1, DWORD PTR [rbx+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3976 :     if (fill_L && fill_U) draw_list->AddRectFilled(ImVec2(outer.Min.x, outer.Min.y), ImVec2(inner.Min.x, inner.Min.y), col, rounding, ImDrawFlags_RoundCornersTopLeft);

	lea	rdx, QWORD PTR $T1[rbp-129]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T7[rbp-129], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3976 :     if (fill_L && fill_U) draw_list->AddRectFilled(ImVec2(outer.Min.x, outer.Min.y), ImVec2(inner.Min.x, inner.Min.y), col, rounding, ImDrawFlags_RoundCornersTopLeft);

	mov	r9d, esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm0, DWORD PTR [rdi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3976 :     if (fill_L && fill_U) draw_list->AddRectFilled(ImVec2(outer.Min.x, outer.Min.y), ImVec2(inner.Min.x, inner.Min.y), col, rounding, ImDrawFlags_RoundCornersTopLeft);

	mov	rcx, r14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T7[rbp-125], xmm1
	movss	xmm1, DWORD PTR [rdi+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3976 :     if (fill_L && fill_U) draw_list->AddRectFilled(ImVec2(outer.Min.x, outer.Min.y), ImVec2(inner.Min.x, inner.Min.y), col, rounding, ImDrawFlags_RoundCornersTopLeft);

	mov	DWORD PTR [rsp+40], 16
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T1[rbp-129], xmm0
	movss	DWORD PTR $T1[rbp-125], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3976 :     if (fill_L && fill_U) draw_list->AddRectFilled(ImVec2(outer.Min.x, outer.Min.y), ImVec2(inner.Min.x, inner.Min.y), col, rounding, ImDrawFlags_RoundCornersTopLeft);

	movss	DWORD PTR [rsp+32], xmm6
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
$LN6@RenderRect:

; 3977 :     if (fill_R && fill_U) draw_list->AddRectFilled(ImVec2(inner.Max.x, outer.Min.y), ImVec2(outer.Max.x, inner.Min.y), col, rounding, ImDrawFlags_RoundCornersTopRight);

	movzx	r13d, BYTE PTR fill_R$1$[rbp-129]
	test	r13b, r13b
	je	SHORT $LN7@RenderRect
	test	r15b, r15b
	je	SHORT $LN7@RenderRect
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm0, DWORD PTR [rdi+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3977 :     if (fill_R && fill_U) draw_list->AddRectFilled(ImVec2(inner.Max.x, outer.Min.y), ImVec2(outer.Max.x, inner.Min.y), col, rounding, ImDrawFlags_RoundCornersTopRight);

	lea	r8, QWORD PTR $T16[rbp-129]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm1, DWORD PTR [rbx+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3977 :     if (fill_R && fill_U) draw_list->AddRectFilled(ImVec2(inner.Max.x, outer.Min.y), ImVec2(outer.Max.x, inner.Min.y), col, rounding, ImDrawFlags_RoundCornersTopRight);

	lea	rdx, QWORD PTR $T6[rbp-129]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T16[rbp-129], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3977 :     if (fill_R && fill_U) draw_list->AddRectFilled(ImVec2(inner.Max.x, outer.Min.y), ImVec2(outer.Max.x, inner.Min.y), col, rounding, ImDrawFlags_RoundCornersTopRight);

	mov	r9d, esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm0, DWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3977 :     if (fill_R && fill_U) draw_list->AddRectFilled(ImVec2(inner.Max.x, outer.Min.y), ImVec2(outer.Max.x, inner.Min.y), col, rounding, ImDrawFlags_RoundCornersTopRight);

	mov	rcx, r14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T16[rbp-125], xmm1
	movss	xmm1, DWORD PTR [rdi+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3977 :     if (fill_R && fill_U) draw_list->AddRectFilled(ImVec2(inner.Max.x, outer.Min.y), ImVec2(outer.Max.x, inner.Min.y), col, rounding, ImDrawFlags_RoundCornersTopRight);

	mov	DWORD PTR [rsp+40], 32			; 00000020H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T6[rbp-129], xmm0
	movss	DWORD PTR $T6[rbp-125], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3977 :     if (fill_R && fill_U) draw_list->AddRectFilled(ImVec2(inner.Max.x, outer.Min.y), ImVec2(outer.Max.x, inner.Min.y), col, rounding, ImDrawFlags_RoundCornersTopRight);

	movss	DWORD PTR [rsp+32], xmm6
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
$LN7@RenderRect:

; 3978 :     if (fill_L && fill_D) draw_list->AddRectFilled(ImVec2(outer.Min.x, inner.Max.y), ImVec2(inner.Min.x, outer.Max.y), col, rounding, ImDrawFlags_RoundCornersBottomLeft);

	cmp	BYTE PTR fill_L$1$[rbp-129], 0
	je	SHORT $LN8@RenderRect
	test	r12b, r12b
	je	SHORT $LN8@RenderRect
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm0, DWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3978 :     if (fill_L && fill_D) draw_list->AddRectFilled(ImVec2(outer.Min.x, inner.Max.y), ImVec2(inner.Min.x, outer.Max.y), col, rounding, ImDrawFlags_RoundCornersBottomLeft);

	lea	r8, QWORD PTR $T13[rbp-129]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm1, DWORD PTR [rdi+12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3978 :     if (fill_L && fill_D) draw_list->AddRectFilled(ImVec2(outer.Min.x, inner.Max.y), ImVec2(inner.Min.x, outer.Max.y), col, rounding, ImDrawFlags_RoundCornersBottomLeft);

	lea	rdx, QWORD PTR $T15[rbp-129]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T13[rbp-129], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3978 :     if (fill_L && fill_D) draw_list->AddRectFilled(ImVec2(outer.Min.x, inner.Max.y), ImVec2(inner.Min.x, outer.Max.y), col, rounding, ImDrawFlags_RoundCornersBottomLeft);

	mov	r9d, esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm0, DWORD PTR [rdi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3978 :     if (fill_L && fill_D) draw_list->AddRectFilled(ImVec2(outer.Min.x, inner.Max.y), ImVec2(inner.Min.x, outer.Max.y), col, rounding, ImDrawFlags_RoundCornersBottomLeft);

	mov	rcx, r14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T13[rbp-125], xmm1
	movss	xmm1, DWORD PTR [rbx+12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3978 :     if (fill_L && fill_D) draw_list->AddRectFilled(ImVec2(outer.Min.x, inner.Max.y), ImVec2(inner.Min.x, outer.Max.y), col, rounding, ImDrawFlags_RoundCornersBottomLeft);

	mov	DWORD PTR [rsp+40], 64			; 00000040H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T15[rbp-129], xmm0
	movss	DWORD PTR $T15[rbp-125], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3978 :     if (fill_L && fill_D) draw_list->AddRectFilled(ImVec2(outer.Min.x, inner.Max.y), ImVec2(inner.Min.x, outer.Max.y), col, rounding, ImDrawFlags_RoundCornersBottomLeft);

	movss	DWORD PTR [rsp+32], xmm6
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
$LN8@RenderRect:

; 3979 :     if (fill_R && fill_D) draw_list->AddRectFilled(ImVec2(inner.Max.x, inner.Max.y), ImVec2(outer.Max.x, outer.Max.y), col, rounding, ImDrawFlags_RoundCornersBottomRight);

	test	r13b, r13b
	je	SHORT $LN9@RenderRect
	test	r12b, r12b
	je	SHORT $LN9@RenderRect
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm0, DWORD PTR [rdi+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3979 :     if (fill_R && fill_D) draw_list->AddRectFilled(ImVec2(inner.Max.x, inner.Max.y), ImVec2(outer.Max.x, outer.Max.y), col, rounding, ImDrawFlags_RoundCornersBottomRight);

	lea	r8, QWORD PTR $T12[rbp-129]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm1, DWORD PTR [rdi+12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3979 :     if (fill_R && fill_D) draw_list->AddRectFilled(ImVec2(inner.Max.x, inner.Max.y), ImVec2(outer.Max.x, outer.Max.y), col, rounding, ImDrawFlags_RoundCornersBottomRight);

	lea	rdx, QWORD PTR $T14[rbp-129]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T12[rbp-129], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3979 :     if (fill_R && fill_D) draw_list->AddRectFilled(ImVec2(inner.Max.x, inner.Max.y), ImVec2(outer.Max.x, outer.Max.y), col, rounding, ImDrawFlags_RoundCornersBottomRight);

	mov	r9d, esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm0, DWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3979 :     if (fill_R && fill_D) draw_list->AddRectFilled(ImVec2(inner.Max.x, inner.Max.y), ImVec2(outer.Max.x, outer.Max.y), col, rounding, ImDrawFlags_RoundCornersBottomRight);

	mov	rcx, r14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T12[rbp-125], xmm1
	movss	xmm1, DWORD PTR [rbx+12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3979 :     if (fill_R && fill_D) draw_list->AddRectFilled(ImVec2(inner.Max.x, inner.Max.y), ImVec2(outer.Max.x, outer.Max.y), col, rounding, ImDrawFlags_RoundCornersBottomRight);

	mov	DWORD PTR [rsp+40], 128			; 00000080H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T14[rbp-129], xmm0
	movss	DWORD PTR $T14[rbp-125], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3979 :     if (fill_R && fill_D) draw_list->AddRectFilled(ImVec2(inner.Max.x, inner.Max.y), ImVec2(outer.Max.x, outer.Max.y), col, rounding, ImDrawFlags_RoundCornersBottomRight);

	movss	DWORD PTR [rsp+32], xmm6
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
$LN9@RenderRect:

; 3980 : }

	lea	r11, QWORD PTR [rsp+160]
	mov	rbx, QWORD PTR [r11+64]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?RenderRectFilledWithHole@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@1IM@Z ENDP ; ImGui::RenderRectFilledWithHole
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?CalcRoundingFlagsForRectInRect@ImGui@@YAHAEBUImRect@@0M@Z
_TEXT	SEGMENT
r_in$ = 8
r_outer$ = 16
tv144 = 24
threshold$ = 24
?CalcRoundingFlagsForRectInRect@ImGui@@YAHAEBUImRect@@0M@Z PROC ; ImGui::CalcRoundingFlagsForRectInRect, COMDAT

; 3984 :     bool round_l = r_in.Min.x <= r_outer.Min.x + threshold;
; 3985 :     bool round_r = r_in.Max.x >= r_outer.Max.x - threshold;

	movss	xmm1, DWORD PTR [rdx+8]
	movaps	xmm0, xmm2
	addss	xmm0, DWORD PTR [rdx]
	movaps	xmm3, xmm2
	subss	xmm1, xmm3
	comiss	xmm0, DWORD PTR [rcx]
	movss	xmm0, DWORD PTR [rcx+8]
	setae	r9b
	comiss	xmm0, xmm1

; 3986 :     bool round_t = r_in.Min.y <= r_outer.Min.y + threshold;
; 3987 :     bool round_b = r_in.Max.y >= r_outer.Max.y - threshold;

	movss	xmm0, DWORD PTR [rcx+12]
	movaps	xmm1, xmm2
	addss	xmm1, DWORD PTR [rdx+4]
	movss	xmm2, DWORD PTR [rdx+12]
	setae	r10b
	subss	xmm2, xmm3
	comiss	xmm1, DWORD PTR [rcx+4]
	setae	r8b
	comiss	xmm0, xmm2
	setae	r11b

; 3988 :     return ImDrawFlags_RoundCornersNone

	xor	eax, eax
	test	r8b, r8b
	je	SHORT $LN3@CalcRoundi
	test	r9b, r9b
	je	SHORT $LN3@CalcRoundi
	mov	ecx, 272				; 00000110H
	jmp	SHORT $LN12@CalcRoundi
$LN3@CalcRoundi:
	mov	ecx, 256				; 00000100H
	test	r8b, r8b
	je	SHORT $LN5@CalcRoundi
$LN12@CalcRoundi:
	mov	r8d, 32					; 00000020H
	test	r10b, r10b
	jne	SHORT $LN6@CalcRoundi
$LN5@CalcRoundi:
	mov	r8d, eax
$LN6@CalcRoundi:
	test	r11b, r11b
	je	SHORT $LN7@CalcRoundi
	test	r9b, r9b
	je	SHORT $LN7@CalcRoundi
	mov	edx, 64					; 00000040H
	jmp	SHORT $LN11@CalcRoundi
$LN7@CalcRoundi:
	mov	edx, eax
	test	r11b, r11b
	je	SHORT $LN10@CalcRoundi
$LN11@CalcRoundi:
	test	r10b, r10b
	je	SHORT $LN10@CalcRoundi
	mov	eax, 128				; 00000080H
$LN10@CalcRoundi:
	or	eax, edx
	or	eax, r8d
	or	eax, ecx

; 3989 :         | ((round_t && round_l) ? ImDrawFlags_RoundCornersTopLeft : 0) | ((round_t && round_r) ? ImDrawFlags_RoundCornersTopRight : 0)
; 3990 :         | ((round_b && round_l) ? ImDrawFlags_RoundCornersBottomLeft : 0) | ((round_b && round_r) ? ImDrawFlags_RoundCornersBottomRight : 0);
; 3991 : }

	ret	0
?CalcRoundingFlagsForRectInRect@ImGui@@YAHAEBUImRect@@0M@Z ENDP ; ImGui::CalcRoundingFlagsForRectInRect
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?ImBezierCubicCalc@@YA?AUImVec2@@AEBU1@000M@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 32
p1$ = 40
p2$ = 48
p3$ = 56
p4$ = 64
t$ = 72
?ImBezierCubicCalc@@YA?AUImVec2@@AEBU1@000M@Z PROC	; ImBezierCubicCalc, COMDAT

; 1227 : {

$LN6:
	sub	rsp, 24

; 1228 :     float u = 1.0f - t;

	movss	xmm1, DWORD PTR t$[rsp]
	movss	xmm0, DWORD PTR __real@3f800000

; 1229 :     float w1 = u * u * u;
; 1230 :     float w2 = 3 * u * u * t;
; 1231 :     float w3 = 3 * u * t * t;
; 1232 :     float w4 = t * t * t;

	movaps	xmm3, xmm1

; 1233 :     return ImVec2(w1 * p1.x + w2 * p2.x + w3 * p3.x + w4 * p4.x, w1 * p1.y + w2 * p2.y + w3 * p3.y + w4 * p4.y);

	mov	rax, QWORD PTR p4$[rsp]
	subss	xmm0, xmm1
	movaps	XMMWORD PTR [rsp], xmm6
	mulss	xmm3, xmm1
	movaps	xmm4, xmm0
	movaps	xmm5, xmm0
	mulss	xmm4, DWORD PTR __real@40400000
	mulss	xmm5, xmm0
	movaps	xmm6, xmm4
	mulss	xmm3, xmm1
	mulss	xmm6, xmm0
	mulss	xmm5, xmm0
	mulss	xmm6, xmm1
	mulss	xmm4, xmm1
	movaps	xmm2, xmm5
	mulss	xmm2, DWORD PTR [rdx]
	movaps	xmm0, xmm6
	mulss	xmm6, DWORD PTR [r8+4]
	mulss	xmm0, DWORD PTR [r8]
	mulss	xmm5, DWORD PTR [rdx+4]
	addss	xmm2, xmm0
	mulss	xmm4, xmm1
	addss	xmm6, xmm5
	movaps	xmm0, xmm3
	mulss	xmm3, DWORD PTR [rax+4]
	mulss	xmm0, DWORD PTR [rax]
	movaps	xmm1, xmm4
	mov	rax, rcx
	mulss	xmm4, DWORD PTR [r9+4]
	mulss	xmm1, DWORD PTR [r9]
	addss	xmm6, xmm4
	addss	xmm2, xmm1
	addss	xmm6, xmm3
	addss	xmm2, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR [rcx+4], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1234 : }

	movaps	xmm6, XMMWORD PTR [rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR [rcx], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1234 : }

	add	rsp, 24
	ret	0
?ImBezierCubicCalc@@YA?AUImVec2@@AEBU1@000M@Z ENDP	; ImBezierCubicCalc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?Clear@ImDrawData@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?Clear@ImDrawData@@QEAAXXZ PROC				; ImDrawData::Clear, COMDAT

; 1819 : {

$LN14:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1820 :     Valid = false;
; 1821 :     CmdListsCount = TotalIdxCount = TotalVtxCount = 0;

	xor	esi, esi
	mov	BYTE PTR [rcx], 0
	mov	QWORD PTR [rcx+8], rsi
	mov	rbx, rcx
	mov	DWORD PTR [rcx+4], esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	ecx, DWORD PTR [rcx+20]
	test	ecx, ecx
	jns	SHORT $LN4@Clear

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	eax, ecx
	cdq
	sub	eax, edx
	mov	edx, esi
	sar	eax, 1
	add	eax, ecx

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	lea	rcx, QWORD PTR [rbx+16]

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	eax, eax
	cmovg	edx, eax

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	call	?reserve@?$ImVector@PEAUImDrawList@@@@QEAAXH@Z ; ImVector<ImDrawList *>::reserve
$LN4@Clear:
	mov	DWORD PTR [rbx+16], esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1823 :     DisplayPos = DisplaySize = FramebufferScale = ImVec2(0.0f, 0.0f);

	mov	QWORD PTR [rbx+48], rsi
	mov	QWORD PTR [rbx+40], rsi
	mov	QWORD PTR [rbx+32], rsi

; 1824 :     OwnerViewport = NULL;

	mov	QWORD PTR [rbx+56], rsi

; 1825 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?Clear@ImDrawData@@QEAAXXZ ENDP				; ImDrawData::Clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ??0ImFontAtlas@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0ImFontAtlas@@QEAA@XZ PROC				; ImFontAtlas::ImFontAtlas, COMDAT

; 2033 : {

$LN32:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 269  :     constexpr ImVec2()                      : x(0.0f), y(0.0f) { }

	xor	edx, edx
	mov	QWORD PTR [rcx+72], rdx
	mov	QWORD PTR [rcx+80], rdx

; 1903 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rcx+88], rdx
	mov	QWORD PTR [rcx+96], rdx
	mov	QWORD PTR [rcx+104], rdx
	mov	QWORD PTR [rcx+112], rdx
	mov	QWORD PTR [rcx+120], rdx
	mov	QWORD PTR [rcx+128], rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2033 : {

	lea	rax, QWORD PTR [rcx+136]
	mov	ecx, 64					; 00000040H
	npad	6
$LL27@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 282  :     constexpr ImVec4()                                        : x(0.0f), y(0.0f), z(0.0f), w(0.0f) { }

	mov	QWORD PTR [rax], rdx
	mov	QWORD PTR [rax+8], rdx
	lea	rax, QWORD PTR [rax+16]
	sub	rcx, 1
	jne	SHORT $LL27@ImFontAtla
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2034 :     memset(this, 0, sizeof(*this));

	xor	edx, edx
	mov	r8d, 1184				; 000004a0H
	mov	rcx, rbx
	call	memset

; 2035 :     TexGlyphPadding = 1;

	mov	DWORD PTR [rbx+20], 1

; 2036 :     PackIdMouseCursors = PackIdLines = -1;

	mov	QWORD PTR [rbx+1172], -1

; 2037 : }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0ImFontAtlas@@QEAA@XZ ENDP				; ImFontAtlas::ImFontAtlas
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???0ImFontAtlas@@QEAA@XZ@4HA PROC		; `ImFontAtlas::ImFontAtlas'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 88					; 00000058H
	jmp	??1?$ImVector@PEAUImFont@@@@QEAA@XZ	; ImVector<ImFont *>::~ImVector<ImFont *>
?dtor$0@?0???0ImFontAtlas@@QEAA@XZ@4HA ENDP		; `ImFontAtlas::ImFontAtlas'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$1@?0???0ImFontAtlas@@QEAA@XZ@4HA PROC		; `ImFontAtlas::ImFontAtlas'::`1'::dtor$1
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 104				; 00000068H
	jmp	??1?$ImVector@UImFontAtlasCustomRect@@@@QEAA@XZ ; ImVector<ImFontAtlasCustomRect>::~ImVector<ImFontAtlasCustomRect>
?dtor$1@?0???0ImFontAtlas@@QEAA@XZ@4HA ENDP		; `ImFontAtlas::ImFontAtlas'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$2@?0???0ImFontAtlas@@QEAA@XZ@4HA PROC		; `ImFontAtlas::ImFontAtlas'::`1'::dtor$2
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 120				; 00000078H
	jmp	??1?$ImVector@UImFontConfig@@@@QEAA@XZ	; ImVector<ImFontConfig>::~ImVector<ImFontConfig>
?dtor$2@?0???0ImFontAtlas@@QEAA@XZ@4HA ENDP		; `ImFontAtlas::ImFontAtlas'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ??1ImFontAtlas@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1ImFontAtlas@@QEAA@XZ PROC				; ImFontAtlas::~ImFontAtlas, COMDAT

; 2040 : {

$LN81:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	mov	QWORD PTR [rsp+32], r14
	push	r15
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 2090 :     ClearInputData();

	call	?ClearInputData@ImFontAtlas@@QEAAXXZ	; ImFontAtlas::ClearInputData

; 2091 :     ClearTexData();

	mov	rcx, rbx
	call	?ClearTexData@ImFontAtlas@@QEAAXXZ	; ImFontAtlas::ClearTexData
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1909 :     inline void         clear_delete()                      { for (int n = 0; n < Size; n++) IM_DELETE(Data[n]); clear(); }     // Important: never called automatically! always explicit.

	xor	esi, esi
	cmp	DWORD PTR [rbx+88], esi
	jle	SHORT $LN77@ImFontAtla
	xor	r14d, r14d
	npad	12
$LL10@ImFontAtla:
	mov	rax, QWORD PTR [rbx+96]
	mov	rdi, QWORD PTR [r14+rax]

; 1876 : template<typename T> void IM_DELETE(T* p)   { if (p) { p->~T(); ImGui::MemFree(p); } }

	test	rdi, rdi
	je	SHORT $LN8@ImFontAtla
	mov	rcx, rdi
	call	??1ImFont@@QEAA@XZ			; ImFont::~ImFont
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN20@ImFontAtla

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN20@ImFontAtla:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	mov	rcx, rdi
	call	QWORD PTR __imp_free
$LN8@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1909 :     inline void         clear_delete()                      { for (int n = 0; n < Size; n++) IM_DELETE(Data[n]); clear(); }     // Important: never called automatically! always explicit.

	inc	esi
	add	r14, 8
	cmp	esi, DWORD PTR [rbx+88]
	jl	SHORT $LL10@ImFontAtla
$LN77@ImFontAtla:

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	rcx, QWORD PTR [rbx+96]
	test	rcx, rcx
	je	SHORT $LN27@ImFontAtla
	mov	QWORD PTR [rbx+88], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN31@ImFontAtla

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN31@ImFontAtla:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx+96], 0
$LN27@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2085 :     TexReady = false;

	mov	BYTE PTR [rbx+40], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1906 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

	mov	rcx, QWORD PTR [rbx+128]
	test	rcx, rcx
	je	SHORT $LN45@ImFontAtla
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN43@ImFontAtla

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN43@ImFontAtla:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
	npad	1
$LN45@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1906 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

	mov	rcx, QWORD PTR [rbx+112]
	test	rcx, rcx
	je	SHORT $LN57@ImFontAtla
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN55@ImFontAtla

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN55@ImFontAtla:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
	npad	1
$LN57@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1906 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

	mov	rcx, QWORD PTR [rbx+96]
	test	rcx, rcx
	je	SHORT $LN78@ImFontAtla
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN67@ImFontAtla

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN67@ImFontAtla:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
	npad	1
$LN78@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2043 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+64]
	mov	r14, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r15
	ret	0
??1ImFontAtlas@@QEAA@XZ ENDP				; ImFontAtlas::~ImFontAtlas
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?GetMouseCursorTexData@ImFontAtlas@@QEAA_NHPEAUImVec2@@0QEAU2@1@Z
_TEXT	SEGMENT
this$ = 8
cursor_type$ = 16
out_offset$ = 24
out_size$ = 32
out_uv_border$ = 40
out_uv_fill$ = 48
?GetMouseCursorTexData@ImFontAtlas@@QEAA_NHPEAUImVec2@@0QEAU2@1@Z PROC ; ImFontAtlas::GetMouseCursorTexData, COMDAT

; 2297 : {

	mov	r11, rcx

; 2298 :     if (cursor_type <= ImGuiMouseCursor_None || cursor_type >= ImGuiMouseCursor_COUNT)

	cmp	edx, 8
	ja	$LN3@GetMouseCu

; 2300 :     if (Flags & ImFontAtlasFlags_NoMouseCursors)

	test	BYTE PTR [rcx], 2
	jne	$LN3@GetMouseCu
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	r10, DWORD PTR [rcx+1172]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2305 :     ImVec2 pos = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][0] + ImVec2((float)r->X, (float)r->Y);

	movsxd	rax, edx
	lea	rdx, OFFSET FLAT:?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	shl	r10, 5
	add	r10, QWORD PTR [rcx+112]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2305 :     ImVec2 pos = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][0] + ImVec2((float)r->X, (float)r->Y);

	lea	rcx, QWORD PTR [rax+rax*2]

; 2306 :     ImVec2 size = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][1];

	movss	xmm2, DWORD PTR [rdx+rcx*8+8]
	movzx	eax, WORD PTR [r10+4]

; 2307 :     *out_size = size;

	movaps	xmm0, xmm2
	movss	xmm4, DWORD PTR [rdx+rcx*8+12]
	unpcklps xmm0, xmm4
	movd	xmm5, eax
	movzx	eax, WORD PTR [r10+6]
	cvtdq2ps xmm5, xmm5
	movd	xmm3, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm5, DWORD PTR [rdx+rcx*8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2309 :     out_uv_border[0] = (pos) * TexUvScale;

	mov	rax, QWORD PTR out_uv_border$[rsp]
	cvtdq2ps xmm3, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2540 : static inline ImVec2  operator*(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }

	movaps	xmm1, xmm5

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm3, DWORD PTR [rdx+rcx*8+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2307 :     *out_size = size;

	movsd	QWORD PTR [r9], xmm0

; 2308 :     *out_offset = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][2];

	movsd	xmm0, QWORD PTR [rdx+rcx*8+16]
	movsd	QWORD PTR [r8], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2540 : static inline ImVec2  operator*(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }

	mulss	xmm1, DWORD PTR [r11+72]
	movaps	xmm0, xmm3

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm4, xmm3

; 2540 : static inline ImVec2  operator*(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }

	mulss	xmm0, DWORD PTR [r11+76]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2309 :     out_uv_border[0] = (pos) * TexUvScale;

	movss	DWORD PTR [rax], xmm1

; 2310 :     out_uv_border[1] = (pos + size) * TexUvScale;

	movaps	xmm1, xmm2
	addss	xmm1, xmm5
	addss	xmm5, DWORD PTR __real@42f60000
	movss	DWORD PTR [rax+4], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2540 : static inline ImVec2  operator*(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }

	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR [r11+76]
	mulss	xmm1, DWORD PTR [r11+72]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2310 :     out_uv_border[1] = (pos + size) * TexUvScale;

	movss	DWORD PTR [rax+12], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2540 : static inline ImVec2  operator*(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }

	movaps	xmm0, xmm5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2313 :     out_uv_fill[1] = (pos + size) * TexUvScale;

	addss	xmm5, xmm2
	movss	DWORD PTR [rax+8], xmm1
	mov	rax, QWORD PTR out_uv_fill$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2540 : static inline ImVec2  operator*(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }

	mulss	xmm0, DWORD PTR [r11+72]
	mulss	xmm3, DWORD PTR [r11+76]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2312 :     out_uv_fill[0] = (pos) * TexUvScale;

	movss	DWORD PTR [rax], xmm0
	movss	DWORD PTR [rax+4], xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2540 : static inline ImVec2  operator*(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }

	mulss	xmm5, DWORD PTR [r11+72]
	mulss	xmm4, DWORD PTR [r11+76]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2313 :     out_uv_fill[1] = (pos + size) * TexUvScale;

	movss	DWORD PTR [rax+8], xmm5
	movss	DWORD PTR [rax+12], xmm4

; 2314 :     return true;

	mov	al, 1

; 2315 : }

	ret	0
$LN3@GetMouseCu:

; 2299 :         return false;

	xor	al, al

; 2315 : }

	ret	0
?GetMouseCursorTexData@ImFontAtlas@@QEAA_NHPEAUImVec2@@0QEAU2@1@Z ENDP ; ImFontAtlas::GetMouseCursorTexData
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ??0ImDrawListSharedData@@QEAA@XZ
_TEXT	SEGMENT
this$ = 112
??0ImDrawListSharedData@@QEAA@XZ PROC			; ImDrawListSharedData::ImDrawListSharedData, COMDAT

; 366  : {

$LN39:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 96					; 00000060H
	movaps	XMMWORD PTR [rsp+80], xmm6
	movaps	XMMWORD PTR [rsp+64], xmm7
	movaps	XMMWORD PTR [rsp+48], xmm8
	movaps	XMMWORD PTR [rsp+32], xmm9
	mov	rdi, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 269  :     constexpr ImVec2()                      : x(0.0f), y(0.0f) { }

	xor	ebx, ebx
	mov	QWORD PTR [rcx], rbx

; 282  :     constexpr ImVec4()                                        : x(0.0f), y(0.0f), z(0.0f), w(0.0f) { }

	mov	QWORD PTR [rcx+28], rbx
	mov	QWORD PTR [rcx+36], rbx

; 1903 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rcx+48], rbx
	mov	QWORD PTR [rcx+56], rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 366  : {

	lea	rsi, QWORD PTR [rcx+64]
	mov	rax, rsi
	mov	ecx, 48					; 00000030H
	npad	7
$LL32@ImDrawList:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 269  :     constexpr ImVec2()                      : x(0.0f), y(0.0f) { }

	mov	QWORD PTR [rax], rbx
	lea	rax, QWORD PTR [rax+8]
	sub	rcx, 1
	jne	SHORT $LL32@ImDrawList
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 367  :     memset(this, 0, sizeof(*this));

	xor	edx, edx
	mov	r8d, 528				; 00000210H
	mov	rcx, rdi
	call	memset
	movss	xmm8, DWORD PTR __real@40490fdb
	movss	xmm9, DWORD PTR __real@42400000
	npad	1
$LL4@ImDrawList:
	movd	xmm7, ebx

; 369  :     {
; 370  :         const float a = ((float)i * 2 * IM_PI) / (float)IM_ARRAYSIZE(ArcFastVtx);

	cvtdq2ps xmm7, xmm7
	addss	xmm7, xmm7
	mulss	xmm7, xmm8
	divss	xmm7, xmm9

; 371  :         ArcFastVtx[i] = ImVec2(ImCos(a), ImSin(a));

	movaps	xmm0, xmm7
	call	sinf
	movaps	xmm6, xmm0
	movaps	xmm0, xmm7
	call	cosf
	movss	DWORD PTR [rsi], xmm0
	movss	DWORD PTR [rsi+4], xmm6

; 368  :     for (int i = 0; i < IM_ARRAYSIZE(ArcFastVtx); i++)

	inc	ebx
	add	rsi, 8
	cmp	ebx, 48					; 00000030H
	jl	SHORT $LL4@ImDrawList

; 372  :     }
; 373  :     ArcFastRadiusCutoff = IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_R(IM_DRAWLIST_ARCFAST_SAMPLE_MAX, CircleSegmentMaxError);

	movss	xmm0, DWORD PTR __real@3d860a92
	call	cosf
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movss	xmm0, DWORD PTR [rdi+24]
	divss	xmm0, xmm1
	movss	DWORD PTR [rdi+448], xmm0

; 374  : }

	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+120]
	mov	rsi, QWORD PTR [rsp+128]
	movaps	xmm6, XMMWORD PTR [rsp+80]
	movaps	xmm7, XMMWORD PTR [rsp+64]
	movaps	xmm8, XMMWORD PTR [rsp+48]
	movaps	xmm9, XMMWORD PTR [rsp+32]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
??0ImDrawListSharedData@@QEAA@XZ ENDP			; ImDrawListSharedData::ImDrawListSharedData
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 112
?dtor$0@?0???0ImDrawListSharedData@@QEAA@XZ@4HA PROC	; `ImDrawListSharedData::ImDrawListSharedData'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 48					; 00000030H
	jmp	??1?$ImVector@UImVec2@@@@QEAA@XZ	; ImVector<ImVec2>::~ImVector<ImVec2>
?dtor$0@?0???0ImDrawListSharedData@@QEAA@XZ@4HA ENDP	; `ImDrawListSharedData::ImDrawListSharedData'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?SetCircleTessellationMaxError@ImDrawListSharedData@@QEAAXM@Z
_TEXT	SEGMENT
this$ = 80
max_error$ = 88
?SetCircleTessellationMaxError@ImDrawListSharedData@@QEAAXM@Z PROC ; ImDrawListSharedData::SetCircleTessellationMaxError, COMDAT

; 377  : {

$LN31:
	push	rsi
	sub	rsp, 64					; 00000040H

; 378  :     if (CircleSegmentMaxError == max_error)

	movss	xmm0, DWORD PTR [rcx+24]
	mov	rsi, rcx
	ucomiss	xmm0, xmm1
	jp	SHORT $LN25@SetCircleT
	je	$LN1@SetCircleT
$LN25@SetCircleT:
	mov	QWORD PTR [rsp+80], rbx

; 379  :         return;
; 380  : 
; 381  :     IM_ASSERT(max_error > 0.0f);
; 382  :     CircleSegmentMaxError = max_error;

	xor	ebx, ebx
	mov	QWORD PTR [rsp+88], rbp
	mov	ebp, 512				; 00000200H
	mov	QWORD PTR [rsp+96], rdi
	lea	rdi, QWORD PTR [rcx+452]
	movaps	XMMWORD PTR [rsp+48], xmm6
	movss	xmm6, DWORD PTR __real@3f800000
	movaps	XMMWORD PTR [rsp+32], xmm7
	movss	xmm7, DWORD PTR __real@40490fdb
	movss	DWORD PTR [rcx+24], xmm1
$LL4@SetCircleT:

; 383  :     for (int i = 0; i < IM_ARRAYSIZE(CircleSegmentCounts); i++)
; 384  :     {
; 385  :         const float radius = (float)i;

	movd	xmm0, ebx
	cvtdq2ps xmm0, xmm0

; 386  :         CircleSegmentCounts[i] = (ImU8)((i > 0) ? IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(radius, CircleSegmentMaxError) : IM_DRAWLIST_ARCFAST_SAMPLE_MAX);

	test	ebx, ebx
	je	SHORT $LN7@SetCircleT
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	movss	xmm1, DWORD PTR [rsi+24]
	minss	xmm1, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 386  :         CircleSegmentCounts[i] = (ImU8)((i > 0) ? IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(radius, CircleSegmentMaxError) : IM_DRAWLIST_ARCFAST_SAMPLE_MAX);

	divss	xmm1, xmm0
	movaps	xmm0, xmm6
	subss	xmm0, xmm1
	call	acosf
	movaps	xmm1, xmm7
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	call	ceilf
	cvttss2si eax, xmm0
	inc	eax
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	cmp	eax, 4
	jge	SHORT $LN15@SetCircleT
	mov	eax, 4
	jmp	SHORT $LN8@SetCircleT
$LN15@SetCircleT:
	cmp	eax, ebp
	cmovg	eax, ebp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 386  :         CircleSegmentCounts[i] = (ImU8)((i > 0) ? IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(radius, CircleSegmentMaxError) : IM_DRAWLIST_ARCFAST_SAMPLE_MAX);

	jmp	SHORT $LN8@SetCircleT
$LN7@SetCircleT:
	mov	eax, 48					; 00000030H
$LN8@SetCircleT:
	mov	BYTE PTR [rdi], al
	inc	ebx
	inc	rdi
	cmp	ebx, 64					; 00000040H
	jl	SHORT $LL4@SetCircleT

; 387  :     }
; 388  :     ArcFastRadiusCutoff = IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_R(IM_DRAWLIST_ARCFAST_SAMPLE_MAX, CircleSegmentMaxError);

	movss	xmm0, DWORD PTR __real@3d860a92
	movaps	xmm7, XMMWORD PTR [rsp+32]
	mov	rdi, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rbx, QWORD PTR [rsp+80]
	call	cosf
	movss	xmm1, DWORD PTR [rsi+24]
	subss	xmm6, xmm0
	divss	xmm1, xmm6
	movaps	xmm6, XMMWORD PTR [rsp+48]
	movss	DWORD PTR [rsi+448], xmm1
$LN1@SetCircleT:

; 389  : }

	add	rsp, 64					; 00000040H
	pop	rsi
	ret	0
?SetCircleTessellationMaxError@ImDrawListSharedData@@QEAAXM@Z ENDP ; ImDrawListSharedData::SetCircleTessellationMaxError
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?PushClipRect@ImDrawList@@QEAAXAEBUImVec2@@0_N@Z
_TEXT	SEGMENT
cr$ = 32
this$ = 64
cr_min$ = 72
cr_max$ = 80
intersect_with_current_clip_rect$ = 88
?PushClipRect@ImDrawList@@QEAAXAEBUImVec2@@0_N@Z PROC	; ImDrawList::PushClipRect, COMDAT

; 578  : {

$LN35:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 48					; 00000030H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	xmm2, DWORD PTR [rdx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 578  : {

	mov	rdi, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	xmm1, DWORD PTR [rdx+4]
	movss	xmm5, DWORD PTR [r8]
	movss	xmm3, DWORD PTR [r8+4]
	movss	DWORD PTR cr$[rsp], xmm2
	movss	DWORD PTR cr$[rsp+4], xmm1
	movss	DWORD PTR cr$[rsp+8], xmm5
	movss	DWORD PTR cr$[rsp+12], xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 580  :     if (intersect_with_current_clip_rect)

	test	r9b, r9b
	je	SHORT $LN6@PushClipRe

; 581  :     {
; 582  :         ImVec4 current = _CmdHeader.ClipRect;

	movups	xmm0, XMMWORD PTR [rcx+136]
	comiss	xmm0, xmm2

; 583  :         if (cr.x < current.x) cr.x = current.x;

	jbe	SHORT $LN3@PushClipRe
	movss	DWORD PTR cr$[rsp], xmm0
	movaps	xmm2, xmm0
$LN3@PushClipRe:

; 584  :         if (cr.y < current.y) cr.y = current.y;

	movaps	xmm4, xmm0
	shufps	xmm4, xmm0, 85				; 00000055H
	comiss	xmm4, xmm1
	jbe	SHORT $LN4@PushClipRe
	movss	DWORD PTR cr$[rsp+4], xmm4
	movaps	xmm1, xmm4
$LN4@PushClipRe:

; 585  :         if (cr.z > current.z) cr.z = current.z;

	movaps	xmm4, xmm0
	shufps	xmm4, xmm0, 170				; 000000aaH
	comiss	xmm5, xmm4
	jbe	SHORT $LN5@PushClipRe
	movss	DWORD PTR cr$[rsp+8], xmm4
	movaps	xmm5, xmm4
$LN5@PushClipRe:

; 586  :         if (cr.w > current.w) cr.w = current.w;

	shufps	xmm0, xmm0, 255				; 000000ffH
	comiss	xmm3, xmm0
	jbe	SHORT $LN6@PushClipRe
	movss	DWORD PTR cr$[rsp+12], xmm0
	movaps	xmm3, xmm0
$LN6@PushClipRe:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	comiss	xmm2, xmm5
	jb	SHORT $LN12@PushClipRe
	movss	DWORD PTR cr$[rsp+8], xmm2
$LN12@PushClipRe:
	comiss	xmm1, xmm3
	jb	SHORT $LN16@PushClipRe
	movss	DWORD PTR cr$[rsp+12], xmm1
$LN16@PushClipRe:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	r8d, DWORD PTR [rcx+88]
	mov	ecx, DWORD PTR [rcx+92]
	cmp	r8d, ecx
	jne	SHORT $LN19@PushClipRe
	inc	r8d

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN23@PushClipRe
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN24@PushClipRe
$LN23@PushClipRe:
	mov	eax, 8
$LN24@PushClipRe:
	cmp	eax, r8d

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	lea	rcx, QWORD PTR [rdi+88]

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	r8d, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, r8d
	call	?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z	; ImVector<ImVec4>::reserve
$LN19@PushClipRe:
	movsxd	rcx, DWORD PTR [rdi+88]
	mov	rax, QWORD PTR [rdi+96]
	add	rcx, rcx
	movups	xmm0, XMMWORD PTR cr$[rsp]
	movups	XMMWORD PTR [rax+rcx*8], xmm0
	inc	DWORD PTR [rdi+88]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 593  :     _OnChangedClipRect();

	mov	rcx, rdi
	movups	XMMWORD PTR [rdi+136], xmm0

; 594  : }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 48					; 00000030H
	pop	rdi

; 593  :     _OnChangedClipRect();

	jmp	?_OnChangedClipRect@ImDrawList@@QEAAXXZ	; ImDrawList::_OnChangedClipRect
?PushClipRect@ImDrawList@@QEAAXAEBUImVec2@@0_N@Z ENDP	; ImDrawList::PushClipRect
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?PopClipRect@ImDrawList@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?PopClipRect@ImDrawList@@QEAAXXZ PROC			; ImDrawList::PopClipRect, COMDAT
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	mov	eax, DWORD PTR [rcx+88]
	sub	eax, 1
	mov	DWORD PTR [rcx+88], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 604  :     _CmdHeader.ClipRect = (_ClipRectStack.Size == 0) ? _Data->ClipRectFullscreen : _ClipRectStack.Data[_ClipRectStack.Size - 1];

	jne	SHORT $LN3@PopClipRec
	mov	rax, QWORD PTR [rcx+56]
	add	rax, 28
	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR [rcx+136], xmm0

; 605  :     _OnChangedClipRect();

	jmp	?_OnChangedClipRect@ImDrawList@@QEAAXXZ	; ImDrawList::_OnChangedClipRect
$LN3@PopClipRec:

; 604  :     _CmdHeader.ClipRect = (_ClipRectStack.Size == 0) ? _Data->ClipRectFullscreen : _ClipRectStack.Data[_ClipRectStack.Size - 1];

	dec	eax
	cdqe
	shl	rax, 4
	add	rax, QWORD PTR [rcx+96]
	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR [rcx+136], xmm0

; 605  :     _OnChangedClipRect();

	jmp	?_OnChangedClipRect@ImDrawList@@QEAAXXZ	; ImDrawList::_OnChangedClipRect
?PopClipRect@ImDrawList@@QEAAXXZ ENDP			; ImDrawList::PopClipRect
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?PushTextureID@ImDrawList@@QEAAXPEAX@Z
_TEXT	SEGMENT
this$ = 48
texture_id$ = 56
?PushTextureID@ImDrawList@@QEAAXPEAX@Z PROC		; ImDrawList::PushTextureID, COMDAT

; 609  : {

$LN13:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	r8d, DWORD PTR [rcx+104]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 609  : {

	mov	rdi, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	ecx, DWORD PTR [rcx+108]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 609  : {

	mov	rsi, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	cmp	r8d, ecx
	jne	SHORT $LN4@PushTextur
	inc	r8d

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN8@PushTextur
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN9@PushTextur
$LN8@PushTextur:
	mov	eax, 8
$LN9@PushTextur:
	cmp	eax, r8d

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	lea	rcx, QWORD PTR [rdi+104]

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	r8d, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, r8d
	call	?reserve@?$ImVector@PEAX@@QEAAXH@Z	; ImVector<void *>::reserve
$LN4@PushTextur:
	movsxd	rdx, DWORD PTR [rdi+104]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 612  :     _OnChangedTextureID();

	mov	rcx, rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rax, QWORD PTR [rdi+112]
	mov	QWORD PTR [rax+rdx*8], rsi
	inc	DWORD PTR [rdi+104]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 611  :     _CmdHeader.TextureId = texture_id;

	mov	QWORD PTR [rdi+152], rsi

; 613  : }

	mov	rbx, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi

; 612  :     _OnChangedTextureID();

	jmp	?_OnChangedTextureID@ImDrawList@@QEAAXXZ ; ImDrawList::_OnChangedTextureID
?PushTextureID@ImDrawList@@QEAAXPEAX@Z ENDP		; ImDrawList::PushTextureID
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?PopTextureID@ImDrawList@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?PopTextureID@ImDrawList@@QEAAXXZ PROC			; ImDrawList::PopTextureID, COMDAT

; 616  : {

	mov	rdx, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	movsxd	rcx, DWORD PTR [rcx+104]
	lea	eax, DWORD PTR [rcx-1]
	mov	DWORD PTR [rdx+104], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 618  :     _CmdHeader.TextureId = (_TextureIdStack.Size == 0) ? (ImTextureID)NULL : _TextureIdStack.Data[_TextureIdStack.Size - 1];

	test	eax, eax
	jne	SHORT $LN3@PopTexture
	xor	eax, eax

; 619  :     _OnChangedTextureID();

	mov	rcx, rdx
	mov	QWORD PTR [rdx+152], rax
	jmp	?_OnChangedTextureID@ImDrawList@@QEAAXXZ ; ImDrawList::_OnChangedTextureID
$LN3@PopTexture:

; 618  :     _CmdHeader.TextureId = (_TextureIdStack.Size == 0) ? (ImTextureID)NULL : _TextureIdStack.Data[_TextureIdStack.Size - 1];

	mov	rax, QWORD PTR [rdx+112]
	mov	rax, QWORD PTR [rax+rcx*8-16]

; 619  :     _OnChangedTextureID();

	mov	rcx, rdx
	mov	QWORD PTR [rdx+152], rax
	jmp	?_OnChangedTextureID@ImDrawList@@QEAAXXZ ; ImDrawList::_OnChangedTextureID
?PopTextureID@ImDrawList@@QEAAXXZ ENDP			; ImDrawList::PopTextureID
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 48
this$ = 96
p1$ = 104
p2$ = 112
col$ = 120
thickness$ = 128
?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z PROC	; ImDrawList::AddLine, COMDAT

; 1383 : {

$LN43:

; 1384 :     if ((col & IM_COL32_A_MASK) == 0)

	test	r9d, -16777216				; ff000000H
	je	$LN41@AddLine
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	r14
	sub	rsp, 80					; 00000050H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movss	xmm0, DWORD PTR [rdx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1383 : {

	mov	r14, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	r8d, DWORD PTR [rcx+120]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1383 : {

	mov	rsi, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	ecx, DWORD PTR [rcx+124]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1383 : {

	mov	ebp, r9d

; 1384 :     if ((col & IM_COL32_A_MASK) == 0)

	mov	QWORD PTR [rsp+96], rbx
	mov	QWORD PTR [rsp+104], rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edi, 8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1384 :     if ((col & IM_COL32_A_MASK) == 0)

	movaps	XMMWORD PTR [rsp+64], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movss	xmm6, DWORD PTR __real@3f000000
	addss	xmm0, xmm6

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T2[rsp], xmm0

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movss	xmm0, DWORD PTR [rdx+4]
	addss	xmm0, xmm6

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T2[rsp+4], xmm0

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	cmp	r8d, ecx
	jne	SHORT $LN13@AddLine
	inc	r8d

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN17@AddLine
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN18@AddLine
$LN17@AddLine:
	mov	eax, edi
$LN18@AddLine:
	cmp	eax, r8d

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	lea	rcx, QWORD PTR [rsi+120]

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	r8d, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, r8d
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN13@AddLine:
	mov	rax, QWORD PTR $T2[rsp]
	movsxd	rdx, DWORD PTR [rsi+120]
	mov	rcx, QWORD PTR [rsi+128]
	mov	QWORD PTR [rcx+rdx*8], rax
	mov	ecx, DWORD PTR [rsi+120]
	inc	ecx
	mov	DWORD PTR [rsi+120], ecx

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movss	xmm0, DWORD PTR [r14]
	movss	xmm1, DWORD PTR [r14+4]
	addss	xmm0, xmm6

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	r8d, DWORD PTR [rsi+124]

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm1, xmm6

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	movaps	xmm6, XMMWORD PTR [rsp+64]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T1[rsp], xmm0
	movss	DWORD PTR $T1[rsp+4], xmm1

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	cmp	ecx, r8d
	jne	SHORT $LN28@AddLine
	inc	ecx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	r8d, r8d
	je	SHORT $LN32@AddLine
	mov	eax, r8d
	cdq
	sub	eax, edx
	sar	eax, 1
	lea	edi, DWORD PTR [r8+rax]
$LN32@AddLine:
	cmp	edi, ecx
	cmovg	ecx, edi

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, ecx
	lea	rcx, QWORD PTR [rsi+120]
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN28@AddLine:
	movsxd	rdx, DWORD PTR [rsi+120]

; 2808 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

	xor	edi, edi

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rcx, QWORD PTR [rsi+128]

; 2808 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

	mov	r9d, ebp

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rax, QWORD PTR $T1[rsp]

; 2808 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

	movss	xmm0, DWORD PTR thickness$[rsp]
	movss	DWORD PTR [rsp+40], xmm0

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	QWORD PTR [rcx+rdx*8], rax

; 2808 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

	mov	rcx, rsi

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	inc	DWORD PTR [rsi+120]

; 2808 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

	mov	r8d, DWORD PTR [rsi+120]
	mov	rdx, QWORD PTR [rsi+128]
	mov	DWORD PTR [rsp+32], edi
	call	?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z ; ImDrawList::AddPolyline
	mov	rbx, QWORD PTR [rsp+96]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1389 : }

	mov	rbp, QWORD PTR [rsp+112]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2808 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

	mov	DWORD PTR [rsi+120], edi
	mov	rdi, QWORD PTR [rsp+104]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1389 : }

	mov	rsi, QWORD PTR [rsp+120]
	add	rsp, 80					; 00000050H
	pop	r14
$LN41@AddLine:
	ret	0
?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ENDP	; ImDrawList::AddLine
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z
_TEXT	SEGMENT
clip_rect$ = 80
this$ = 112
font$ = 120
font_size$ = 128
pos$ = 136
col$ = 144
text_begin$ = 152
text_end$ = 160
wrap_width$ = 168
cpu_fine_clip_rect$ = 176
?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z PROC ; ImDrawList::AddText, COMDAT

; 1577 : {

$LN30:
	sub	rsp, 104				; 00000068H
	mov	r11, rdx

; 1578 :     if ((col & IM_COL32_A_MASK) == 0)

	mov	edx, DWORD PTR col$[rsp]
	test	edx, -16777216				; ff000000H
	je	$LN1@AddText

; 1579 :         return;
; 1580 : 
; 1581 :     if (text_end == NULL)

	mov	r8, QWORD PTR text_end$[rsp]
	mov	r10, QWORD PTR text_begin$[rsp]
	test	r8, r8
	jne	SHORT $LN3@AddText

; 1582 :         text_end = text_begin + strlen(text_begin);

	mov	r8, -1
$LL27@AddText:
	inc	r8
	cmp	BYTE PTR [r10+r8], 0
	jne	SHORT $LL27@AddText
	add	r8, r10
$LN3@AddText:

; 1583 :     if (text_begin == text_end)

	cmp	r10, r8
	je	$LN1@AddText

; 1584 :         return;
; 1585 : 
; 1586 :     // Pull default font/size from the shared ImDrawListSharedData instance
; 1587 :     if (font == NULL)

	test	r11, r11
	jne	SHORT $LN25@AddText

; 1588 :         font = _Data->Font;

	mov	rax, QWORD PTR [rcx+56]
	mov	r11, QWORD PTR [rax+8]
$LN25@AddText:

; 1589 :     if (font_size == 0.0f)

	xorps	xmm0, xmm0
	ucomiss	xmm2, xmm0
	jp	SHORT $LN6@AddText
	jne	SHORT $LN6@AddText

; 1590 :         font_size = _Data->FontSize;

	mov	rax, QWORD PTR [rcx+56]
	movss	xmm2, DWORD PTR [rax+16]
$LN6@AddText:

; 1591 : 
; 1592 :     IM_ASSERT(font->ContainerAtlas->TexID == _CmdHeader.TextureId);  // Use high-level ImGui::PushFont() or low-level ImDrawList::PushTextureId() to change font.
; 1593 : 
; 1594 :     ImVec4 clip_rect = _CmdHeader.ClipRect;

	movups	xmm1, XMMWORD PTR [rcx+136]

; 1595 :     if (cpu_fine_clip_rect)

	mov	rax, QWORD PTR cpu_fine_clip_rect$[rsp]
	movups	XMMWORD PTR clip_rect$[rsp], xmm1
	test	rax, rax
	je	SHORT $LN28@AddText

; 1596 :     {
; 1597 :         clip_rect.x = ImMax(clip_rect.x, cpu_fine_clip_rect->x);

	movss	xmm0, DWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	comiss	xmm1, xmm0
	jae	SHORT $LN12@AddText
	movss	DWORD PTR clip_rect$[rsp], xmm0
$LN12@AddText:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1598 :         clip_rect.y = ImMax(clip_rect.y, cpu_fine_clip_rect->y);

	movss	xmm1, DWORD PTR [rax+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movss	xmm0, DWORD PTR clip_rect$[rsp+4]
	comiss	xmm0, xmm1
	jae	SHORT $LN16@AddText
	movss	DWORD PTR clip_rect$[rsp+4], xmm1
$LN16@AddText:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1599 :         clip_rect.z = ImMin(clip_rect.z, cpu_fine_clip_rect->z);

	movss	xmm0, DWORD PTR [rax+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	comiss	xmm0, DWORD PTR clip_rect$[rsp+8]
	ja	SHORT $LN20@AddText
	movss	DWORD PTR clip_rect$[rsp+8], xmm0
$LN20@AddText:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1600 :         clip_rect.w = ImMin(clip_rect.w, cpu_fine_clip_rect->w);

	movss	xmm0, DWORD PTR [rax+12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	comiss	xmm0, DWORD PTR clip_rect$[rsp+12]
	ja	SHORT $LN24@AddText
	movss	DWORD PTR clip_rect$[rsp+12], xmm0
$LN24@AddText:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1602 :     font->RenderText(this, font_size, pos, col, clip_rect, text_begin, text_end, wrap_width, cpu_fine_clip_rect != NULL);

	test	rax, rax
$LN28@AddText:
	movss	xmm0, DWORD PTR wrap_width$[rsp]
	setne	al
	mov	BYTE PTR [rsp+72], al
	lea	rax, QWORD PTR clip_rect$[rsp]
	movss	DWORD PTR [rsp+64], xmm0
	mov	QWORD PTR [rsp+56], r8
	mov	QWORD PTR [rsp+48], r10
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], edx
	mov	rdx, rcx
	mov	rcx, r11
	call	?RenderText@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IAEBUImVec4@@PEBD3M_N@Z ; ImFont::RenderText
$LN1@AddText:

; 1603 : }

	add	rsp, 104				; 00000068H
	ret	0
?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z ENDP ; ImDrawList::AddText
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?AddText@ImDrawList@@QEAAXAEBUImVec2@@IPEBD1@Z
_TEXT	SEGMENT
clip_rect$1 = 80
this$ = 112
pos$ = 120
col$ = 128
text_begin$ = 136
text_end$dead$ = 144
?AddText@ImDrawList@@QEAAXAEBUImVec2@@IPEBD1@Z PROC	; ImDrawList::AddText, COMDAT

; 1606 : {

$LN33:
	sub	rsp, 104				; 00000068H

; 1578 :     if ((col & IM_COL32_A_MASK) == 0)

	test	r8d, -16777216				; ff000000H
	je	SHORT $LN3@AddText

; 1579 :         return;
; 1580 : 
; 1581 :     if (text_end == NULL)
; 1582 :         text_end = text_begin + strlen(text_begin);

	mov	r10, -1
$LL31@AddText:
	inc	r10
	cmp	BYTE PTR [r9+r10], 0
	jne	SHORT $LL31@AddText
	add	r10, r9

; 1583 :     if (text_begin == text_end)

	cmp	r9, r10
	je	SHORT $LN3@AddText

; 1584 :         return;
; 1585 : 
; 1586 :     // Pull default font/size from the shared ImDrawListSharedData instance
; 1587 :     if (font == NULL)
; 1588 :         font = _Data->Font;

	mov	rax, QWORD PTR [rcx+56]
	xorps	xmm1, xmm1

; 1589 :     if (font_size == 0.0f)
; 1590 :         font_size = _Data->FontSize;
; 1591 : 
; 1592 :     IM_ASSERT(font->ContainerAtlas->TexID == _CmdHeader.TextureId);  // Use high-level ImGui::PushFont() or low-level ImDrawList::PushTextureId() to change font.
; 1593 : 
; 1594 :     ImVec4 clip_rect = _CmdHeader.ClipRect;

	movups	xmm0, XMMWORD PTR [rcx+136]

; 1595 :     if (cpu_fine_clip_rect)
; 1596 :     {
; 1597 :         clip_rect.x = ImMax(clip_rect.x, cpu_fine_clip_rect->x);
; 1598 :         clip_rect.y = ImMax(clip_rect.y, cpu_fine_clip_rect->y);
; 1599 :         clip_rect.z = ImMin(clip_rect.z, cpu_fine_clip_rect->z);
; 1600 :         clip_rect.w = ImMin(clip_rect.w, cpu_fine_clip_rect->w);
; 1601 :     }
; 1602 :     font->RenderText(this, font_size, pos, col, clip_rect, text_begin, text_end, wrap_width, cpu_fine_clip_rect != NULL);

	mov	BYTE PTR [rsp+72], 0
	movss	DWORD PTR [rsp+64], xmm1
	movss	xmm2, DWORD PTR [rax+16]
	mov	QWORD PTR [rsp+56], r10
	mov	QWORD PTR [rsp+48], r9
	lea	r9, QWORD PTR clip_rect$1[rsp]
	mov	QWORD PTR [rsp+40], r9
	mov	r9, rdx
	mov	rdx, rcx
	mov	DWORD PTR [rsp+32], r8d
	mov	rcx, QWORD PTR [rax+8]
	movups	XMMWORD PTR clip_rect$1[rsp], xmm0
	call	?RenderText@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IAEBUImVec4@@PEBD3M_N@Z ; ImFont::RenderText
$LN3@AddText:

; 1607 :     AddText(NULL, 0.0f, pos, col, text_begin, text_end);
; 1608 : }

	add	rsp, 104				; 00000068H
	ret	0
?AddText@ImDrawList@@QEAAXAEBUImVec2@@IPEBD1@Z ENDP	; ImDrawList::AddText
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z
_TEXT	SEGMENT
this$ = 80
user_texture_id$ = 88
p_min$ = 96
p_max$ = 104
uv_min$ = 112
uv_max$ = 120
col$ = 128
?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z PROC	; ImDrawList::AddImage, COMDAT

; 1611 : {

$LN17:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rdi
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H

; 1612 :     if ((col & IM_COL32_A_MASK) == 0)

	mov	ebp, DWORD PTR col$[rsp]
	mov	r14, r9
	mov	r15, r8
	mov	rdi, rdx
	mov	rbx, rcx
	test	ebp, -16777216				; ff000000H
	je	SHORT $LN4@AddImage
	mov	QWORD PTR [rsp+80], rsi

; 1613 :         return;
; 1614 : 
; 1615 :     const bool push_texture_id = user_texture_id != _CmdHeader.TextureId;

	mov	rsi, QWORD PTR [rcx+152]

; 1616 :     if (push_texture_id)

	cmp	rdx, rsi
	je	SHORT $LN3@AddImage

; 1617 :         PushTextureID(user_texture_id);

	call	?PushTextureID@ImDrawList@@QEAAXPEAX@Z	; ImDrawList::PushTextureID
$LN3@AddImage:

; 1618 : 
; 1619 :     PrimReserve(6, 4);

	mov	edx, 6
	mov	rcx, rbx
	lea	r8d, QWORD PTR [rdx-2]
	call	?PrimReserve@ImDrawList@@QEAAXHH@Z	; ImDrawList::PrimReserve

; 1620 :     PrimRectUV(p_min, p_max, uv_min, uv_max, col);

	mov	rax, QWORD PTR uv_max$[rsp]
	mov	r8, r14
	mov	r9, QWORD PTR uv_min$[rsp]
	mov	rdx, r15
	mov	DWORD PTR [rsp+40], ebp
	mov	rcx, rbx
	mov	QWORD PTR [rsp+32], rax
	call	?PrimRectUV@ImDrawList@@QEAAXAEBUImVec2@@000I@Z ; ImDrawList::PrimRectUV

; 1621 : 
; 1622 :     if (push_texture_id)

	cmp	rdi, rsi
	mov	rsi, QWORD PTR [rsp+80]
	je	SHORT $LN4@AddImage
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	movsxd	rcx, DWORD PTR [rbx+104]
	lea	eax, DWORD PTR [rcx-1]
	mov	DWORD PTR [rbx+104], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 618  :     _CmdHeader.TextureId = (_TextureIdStack.Size == 0) ? (ImTextureID)NULL : _TextureIdStack.Data[_TextureIdStack.Size - 1];

	test	eax, eax
	jne	SHORT $LN8@AddImage
	xor	eax, eax
	jmp	SHORT $LN9@AddImage
$LN8@AddImage:
	mov	rax, QWORD PTR [rbx+112]
	mov	rax, QWORD PTR [rax+rcx*8-16]
$LN9@AddImage:

; 619  :     _OnChangedTextureID();

	mov	rcx, rbx
	mov	QWORD PTR [rbx+152], rax
	call	?_OnChangedTextureID@ImDrawList@@QEAAXXZ ; ImDrawList::_OnChangedTextureID
$LN4@AddImage:

; 1623 :         PopTextureID();
; 1624 : }

	mov	rbx, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+96]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z ENDP	; ImDrawList::AddImage
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 48
this$ = 192
center$ = 200
a_emit_end$1$ = 208
radius$ = 208
a_min$ = 216
a_max$ = 224
num_segments$ = 232
?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z PROC	; ImDrawList::PathArcTo, COMDAT

; 1177 : {

$LN91:
	push	r14
	push	r15
	sub	rsp, 168				; 000000a8H

; 1178 :     if (radius < 0.5f)

	movss	xmm0, DWORD PTR __real@3f000000
	mov	r14, rdx
	movaps	XMMWORD PTR [rsp+80], xmm9
	mov	r15, rcx
	movaps	xmm9, xmm2
	movaps	XMMWORD PTR [rsp+64], xmm10
	comiss	xmm0, xmm9
	movaps	xmm10, xmm3
	jbe	SHORT $LN2@PathArcTo

; 1179 :     {
; 1180 :         _Path.push_back(center);

	add	rcx, 120				; 00000078H
	call	?push_back@?$ImVector@UImVec2@@@@QEAAXAEBUImVec2@@@Z ; ImVector<ImVec2>::push_back

; 1181 :         return;

	jmp	$LN5@PathArcTo
$LN2@PathArcTo:

; 1182 :     }
; 1183 : 
; 1184 :     if (num_segments > 0)

	mov	eax, DWORD PTR num_segments$[rsp]
	test	eax, eax
	jle	SHORT $LN3@PathArcTo

; 1185 :     {
; 1186 :         _PathArcToN(center, radius, a_min, a_max, num_segments);

	movss	xmm0, DWORD PTR a_max$[rsp]
	mov	DWORD PTR [rsp+40], eax
	movss	DWORD PTR [rsp+32], xmm0
	call	?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z ; ImDrawList::_PathArcToN

; 1187 :         return;

	jmp	$LN5@PathArcTo
$LN3@PathArcTo:

; 1188 :     }
; 1189 : 
; 1190 :     // Automatic segment count
; 1191 :     if (radius <= _Data->ArcFastRadiusCutoff)

	mov	rax, QWORD PTR [rcx+56]
	mov	QWORD PTR [rsp+192], rbx
	movaps	XMMWORD PTR [rsp+128], xmm6
	movaps	XMMWORD PTR [rsp+112], xmm7
	movss	xmm0, DWORD PTR [rax+448]
	comiss	xmm0, xmm9
	movaps	XMMWORD PTR [rsp+96], xmm8
	jb	$LN4@PathArcTo

; 1192 :     {
; 1193 :         const bool a_is_reverse = a_max < a_min;

	movss	xmm7, DWORD PTR a_max$[rsp]

; 1194 : 
; 1195 :         // We are going to use precomputed values for mid samples.
; 1196 :         // Determine first and last sample in lookup table that belong to the arc.
; 1197 :         const float a_min_sample_f = IM_DRAWLIST_ARCFAST_SAMPLE_MAX * a_min / (IM_PI * 2.0f);

	movaps	xmm1, xmm10
	movss	xmm8, DWORD PTR __real@42400000

; 1198 :         const float a_max_sample_f = IM_DRAWLIST_ARCFAST_SAMPLE_MAX * a_max / (IM_PI * 2.0f);

	movaps	xmm6, xmm7
	mov	QWORD PTR [rsp+200], rbp
	mov	QWORD PTR [rsp+216], rsi
	comiss	xmm10, xmm7
	mov	QWORD PTR [rsp+160], rdi
	mov	QWORD PTR [rsp+152], r12
	mov	QWORD PTR [rsp+144], r13
	mulss	xmm1, xmm8
	mulss	xmm6, xmm8
	seta	al
	divss	xmm1, DWORD PTR __real@40c90fdb
	divss	xmm6, DWORD PTR __real@40c90fdb

; 1200 :         const int a_min_sample = a_is_reverse ? (int)ImFloorSigned(a_min_sample_f) : (int)ImCeil(a_min_sample_f);

	test	al, al
	je	SHORT $LN10@PathArcTo
	xorps	xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 473  : static inline float  ImFloorSigned(float f)                                     { return (float)((f >= 0 || (float)(int)f == f) ? (int)f : (int)f - 1); } // Decent replacement for floorf()

	comiss	xmm1, xmm0
	cvttss2si eax, xmm1
	jae	SHORT $LN60@PathArcTo
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	ucomiss	xmm0, xmm1
	jp	SHORT $LN67@PathArcTo
	je	SHORT $LN60@PathArcTo
$LN67@PathArcTo:
	dec	eax
$LN60@PathArcTo:
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1200 :         const int a_min_sample = a_is_reverse ? (int)ImFloorSigned(a_min_sample_f) : (int)ImCeil(a_min_sample_f);

	cvttss2si r13d, xmm0

; 1201 :         const int a_max_sample = a_is_reverse ? (int)ImCeil(a_max_sample_f) : (int)ImFloorSigned(a_max_sample_f);

	movaps	xmm0, xmm6
	call	ceilf
	cvttss2si r12d, xmm0

; 1202 :         const int a_mid_samples = a_is_reverse ? ImMax(a_min_sample - a_max_sample, 0) : ImMax(a_max_sample - a_min_sample, 0);

	mov	eax, r13d
	sub	eax, r12d
	jmp	SHORT $LN89@PathArcTo
$LN10@PathArcTo:

; 1200 :         const int a_min_sample = a_is_reverse ? (int)ImFloorSigned(a_min_sample_f) : (int)ImCeil(a_min_sample_f);

	movaps	xmm0, xmm1
	call	ceilf
	cvttss2si r13d, xmm0
	xorps	xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 473  : static inline float  ImFloorSigned(float f)                                     { return (float)((f >= 0 || (float)(int)f == f) ? (int)f : (int)f - 1); } // Decent replacement for floorf()

	comiss	xmm6, xmm0
	cvttss2si eax, xmm6
	jae	SHORT $LN61@PathArcTo
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	ucomiss	xmm0, xmm6
	jp	SHORT $LN66@PathArcTo
	je	SHORT $LN61@PathArcTo
$LN66@PathArcTo:
	dec	eax
$LN61@PathArcTo:
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1201 :         const int a_max_sample = a_is_reverse ? (int)ImCeil(a_max_sample_f) : (int)ImFloorSigned(a_max_sample_f);

	cvttss2si r12d, xmm0

; 1202 :         const int a_mid_samples = a_is_reverse ? ImMax(a_min_sample - a_max_sample, 0) : ImMax(a_max_sample - a_min_sample, 0);

	mov	eax, r12d
	sub	eax, r13d
$LN89@PathArcTo:

; 1208 : 
; 1209 :         _Path.reserve(_Path.Size + (a_mid_samples + 1 + (a_emit_start ? 1 : 0) + (a_emit_end ? 1 : 0)));

	movd	xmm0, r13d
	lea	rcx, QWORD PTR [r15+120]
	cvtdq2ps xmm0, xmm0
	mov	esi, 0
	cmovns	esi, eax
	movd	xmm1, r12d
	mulss	xmm0, DWORD PTR __real@40490fdb
	cvtdq2ps xmm1, xmm1
	addss	xmm0, xmm0
	mulss	xmm1, DWORD PTR __real@40490fdb
	divss	xmm0, xmm8
	addss	xmm1, xmm1
	subss	xmm0, xmm10
	divss	xmm1, xmm8
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	andps	xmm0, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1206 :         const bool a_emit_start = ImAbs(a_min_segment_angle - a_min) >= 1e-5f;

	comiss	xmm0, DWORD PTR __real@3727c5ac

; 1207 :         const bool a_emit_end = ImAbs(a_max - a_max_segment_angle) >= 1e-5f;

	movaps	xmm0, xmm7
	subss	xmm0, xmm1
	setae	bl
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	andps	xmm0, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1207 :         const bool a_emit_end = ImAbs(a_max - a_max_segment_angle) >= 1e-5f;

	comiss	xmm0, DWORD PTR __real@3727c5ac
	setae	al

; 1208 : 
; 1209 :         _Path.reserve(_Path.Size + (a_mid_samples + 1 + (a_emit_start ? 1 : 0) + (a_emit_end ? 1 : 0)));

	movzx	edx, al
	mov	BYTE PTR a_emit_end$1$[rsp], al
	movzx	eax, bl
	inc	eax
	add	edx, eax
	add	edx, DWORD PTR [r15+120]
	add	edx, esi
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
	lea	rax, QWORD PTR [r15+124]

; 1210 :         if (a_emit_start)

	mov	ebp, 8
	test	bl, bl
	je	$LN63@PathArcTo

; 1211 :             _Path.push_back(ImVec2(center.x + ImCos(a_min) * radius, center.y + ImSin(a_min) * radius));

	movaps	xmm0, xmm10
	call	cosf
	mulss	xmm0, xmm9
	addss	xmm0, DWORD PTR [r14]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T2[rsp], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1211 :             _Path.push_back(ImVec2(center.x + ImCos(a_min) * radius, center.y + ImSin(a_min) * radius));

	movaps	xmm0, xmm10
	call	sinf
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	ecx, DWORD PTR [r15+120]
	lea	rbx, QWORD PTR [r15+124]
	mov	r8d, DWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1211 :             _Path.push_back(ImVec2(center.x + ImCos(a_min) * radius, center.y + ImSin(a_min) * radius));

	mulss	xmm0, xmm9
	addss	xmm0, DWORD PTR [r14+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T2[rsp+4], xmm0

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	cmp	ecx, r8d
	jne	SHORT $LN45@PathArcTo
	inc	ecx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	r8d, r8d
	je	SHORT $LN49@PathArcTo
	mov	eax, r8d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r8d
	jmp	SHORT $LN50@PathArcTo
$LN49@PathArcTo:
	mov	eax, ebp
$LN50@PathArcTo:
	cmp	eax, ecx
	cmovg	ecx, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, ecx
	lea	rcx, QWORD PTR [r15+120]
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN45@PathArcTo:
	movsxd	rdx, DWORD PTR [r15+120]
	mov	rcx, QWORD PTR [r15+128]
	mov	rax, QWORD PTR $T2[rsp]
	mov	QWORD PTR [rcx+rdx*8], rax
	inc	DWORD PTR [r15+120]
	jmp	SHORT $LN62@PathArcTo
$LN63@PathArcTo:
	mov	rbx, rax
$LN62@PathArcTo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1212 :         if (a_mid_samples > 0)

	test	esi, esi
	mov	rsi, QWORD PTR [rsp+216]
	jle	SHORT $LN7@PathArcTo

; 1213 :             _PathArcToFastEx(center, radius, a_min_sample, a_max_sample, 0);

	mov	r9d, r13d
	mov	DWORD PTR [rsp+32], r12d
	movaps	xmm2, xmm9
	mov	rdx, r14
	mov	rcx, r15
	call	?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z ; ImDrawList::_PathArcToFastEx
$LN7@PathArcTo:

; 1214 :         if (a_emit_end)

	cmp	BYTE PTR a_emit_end$1$[rsp], 0
	mov	r13, QWORD PTR [rsp+144]
	mov	r12, QWORD PTR [rsp+152]
	je	SHORT $LN88@PathArcTo

; 1215 :             _Path.push_back(ImVec2(center.x + ImCos(a_max) * radius, center.y + ImSin(a_max) * radius));

	movaps	xmm0, xmm7
	call	cosf
	mulss	xmm0, xmm9
	addss	xmm0, DWORD PTR [r14]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T1[rsp], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1215 :             _Path.push_back(ImVec2(center.x + ImCos(a_max) * radius, center.y + ImSin(a_max) * radius));

	movaps	xmm0, xmm7
	call	sinf
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	ecx, DWORD PTR [r15+120]
	mov	r8d, DWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1215 :             _Path.push_back(ImVec2(center.x + ImCos(a_max) * radius, center.y + ImSin(a_max) * radius));

	mulss	xmm0, xmm9
	addss	xmm0, DWORD PTR [r14+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T1[rsp+4], xmm0

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	cmp	ecx, r8d
	jne	SHORT $LN54@PathArcTo
	inc	ecx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	r8d, r8d
	je	SHORT $LN58@PathArcTo
	mov	eax, r8d
	cdq
	sub	eax, edx
	sar	eax, 1
	lea	ebp, DWORD PTR [r8+rax]
$LN58@PathArcTo:
	cmp	ebp, ecx
	cmovg	ecx, ebp

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, ecx
	lea	rcx, QWORD PTR [r15+120]
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN54@PathArcTo:
	movsxd	rdx, DWORD PTR [r15+120]
	mov	rcx, QWORD PTR [r15+128]
	mov	rax, QWORD PTR $T1[rsp]
	mov	QWORD PTR [rcx+rdx*8], rax
	inc	DWORD PTR [r15+120]
$LN88@PathArcTo:
	mov	rdi, QWORD PTR [rsp+160]
	mov	rbp, QWORD PTR [rsp+200]
$LN86@PathArcTo:
	movaps	xmm6, XMMWORD PTR [rsp+128]
	movaps	xmm7, XMMWORD PTR [rsp+112]
	mov	rbx, QWORD PTR [rsp+192]
	movaps	xmm8, XMMWORD PTR [rsp+96]
$LN5@PathArcTo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1224 : }

	movaps	xmm9, XMMWORD PTR [rsp+80]
	movaps	xmm10, XMMWORD PTR [rsp+64]
	add	rsp, 168				; 000000a8H
	pop	r15
	pop	r14
	ret	0
$LN4@PathArcTo:

; 1216 :     }
; 1217 :     else
; 1218 :     {
; 1219 :         const float arc_length = ImAbs(a_max - a_min);

	movss	xmm8, DWORD PTR a_max$[rsp]

; 1220 :         const int circle_segment_count = _CalcCircleAutoSegmentCount(radius);

	movaps	xmm1, xmm9

; 1221 :         const int arc_segment_count = ImMax((int)ImCeil(circle_segment_count * arc_length / (IM_PI * 2.0f)), (int)(2.0f * IM_PI / arc_length));

	movss	xmm6, DWORD PTR __real@40c90fdb
	movaps	xmm7, xmm8
	subss	xmm7, xmm10
	movaps	xmm0, xmm6
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	andps	xmm7, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1221 :         const int arc_segment_count = ImMax((int)ImCeil(circle_segment_count * arc_length / (IM_PI * 2.0f)), (int)(2.0f * IM_PI / arc_length));

	divss	xmm0, xmm7
	cvttss2si ebx, xmm0
	call	?_CalcCircleAutoSegmentCount@ImDrawList@@QEBAHM@Z ; ImDrawList::_CalcCircleAutoSegmentCount
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm7
	divss	xmm0, xmm6
	call	ceilf
	cvttss2si eax, xmm0

; 1222 :         _PathArcToN(center, radius, a_min, a_max, arc_segment_count);

	mov	rdx, r14
	mov	rcx, r15
	movaps	xmm3, xmm10
	movaps	xmm2, xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	cmp	eax, ebx
	cmovge	ebx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1222 :         _PathArcToN(center, radius, a_min, a_max, arc_segment_count);

	mov	DWORD PTR [rsp+40], ebx
	movss	DWORD PTR [rsp+32], xmm8
	call	?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z ; ImDrawList::_PathArcToN
	jmp	$LN86@PathArcTo
?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z ENDP	; ImDrawList::PathArcTo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?PathArcToFast@ImDrawList@@QEAAXAEBUImVec2@@MHH@Z
_TEXT	SEGMENT
this$ = 64
center$ = 72
radius$ = 80
a_min_of_12$ = 88
a_max_of_12$ = 96
?PathArcToFast@ImDrawList@@QEAAXAEBUImVec2@@MHH@Z PROC	; ImDrawList::PathArcToFast, COMDAT

; 1167 : {

$LN5:
	sub	rsp, 56					; 00000038H

; 1168 :     if (radius < 0.5f)

	movss	xmm0, DWORD PTR __real@3f000000
	comiss	xmm0, xmm2
	jbe	SHORT $LN2@PathArcToF

; 1169 :     {
; 1170 :         _Path.push_back(center);

	add	rcx, 120				; 00000078H

; 1174 : }

	add	rsp, 56					; 00000038H

; 1169 :     {
; 1170 :         _Path.push_back(center);

	jmp	?push_back@?$ImVector@UImVec2@@@@QEAAXAEBUImVec2@@@Z ; ImVector<ImVec2>::push_back
$LN2@PathArcToF:

; 1171 :         return;
; 1172 :     }
; 1173 :     _PathArcToFastEx(center, radius, a_min_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, a_max_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, 0);

	mov	eax, DWORD PTR a_max_of_12$[rsp]
	lea	r9d, DWORD PTR [r9*4]
	lea	eax, DWORD PTR [rax*4]
	mov	DWORD PTR [rsp+32], eax
	call	?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z ; ImDrawList::_PathArcToFastEx

; 1174 : }

	add	rsp, 56					; 00000038H
	ret	0
?PathArcToFast@ImDrawList@@QEAAXAEBUImVec2@@MHH@Z ENDP	; ImDrawList::PathArcToFast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?AddDrawCmd@ImDrawList@@QEAAXXZ
_TEXT	SEGMENT
draw_cmd$ = 32
this$ = 144
?AddDrawCmd@ImDrawList@@QEAAXXZ PROC			; ImDrawList::AddDrawCmd, COMDAT

; 443  : {

$LN17:
	push	rbx
	sub	rsp, 128				; 00000080H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2640 :     ImDrawCmd() { memset(this, 0, sizeof(*this)); } // Also ensure our padding fields are zeroed

	xor	eax, eax
	movaps	XMMWORD PTR [rsp+112], xmm6
	mov	QWORD PTR draw_cmd$[rsp+48], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 443  : {

	mov	rbx, rcx

; 444  :     ImDrawCmd draw_cmd;
; 445  :     draw_cmd.ClipRect = _CmdHeader.ClipRect;    // Same as calling ImDrawCmd_HeaderCopy()
; 446  :     draw_cmd.TextureId = _CmdHeader.TextureId;

	mov	rax, QWORD PTR [rcx+152]
	xorps	xmm6, xmm6
	mov	QWORD PTR draw_cmd$[rsp+16], rax

; 447  :     draw_cmd.VtxOffset = _CmdHeader.VtxOffset;

	mov	eax, DWORD PTR [rcx+160]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	r8d, DWORD PTR [rbx+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 447  :     draw_cmd.VtxOffset = _CmdHeader.VtxOffset;

	mov	DWORD PTR draw_cmd$[rsp+24], eax

; 448  :     draw_cmd.IdxOffset = IdxBuffer.Size;

	mov	eax, DWORD PTR [rcx+16]
	movaps	XMMWORD PTR [rsp+96], xmm7
	movups	xmm7, XMMWORD PTR [rcx+136]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	ecx, DWORD PTR [rcx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 448  :     draw_cmd.IdxOffset = IdxBuffer.Size;

	mov	DWORD PTR draw_cmd$[rsp+28], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	cmp	ecx, r8d
	jne	SHORT $LN8@AddDrawCmd
	inc	ecx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	r8d, r8d
	je	SHORT $LN12@AddDrawCmd
	mov	eax, r8d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r8d
	jmp	SHORT $LN13@AddDrawCmd
$LN12@AddDrawCmd:
	mov	eax, 8
$LN13@AddDrawCmd:
	cmp	eax, ecx
	cmovg	ecx, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, ecx
	mov	rcx, rbx
	call	?reserve@?$ImVector@UImDrawCmd@@@@QEAAXH@Z ; ImVector<ImDrawCmd>::reserve
$LN8@AddDrawCmd:
	movsxd	rax, DWORD PTR [rbx]
	movups	xmm0, XMMWORD PTR draw_cmd$[rsp+16]
	imul	rcx, rax, 56				; 00000038H
	mov	rax, QWORD PTR [rbx+8]
	movups	XMMWORD PTR [rcx+rax], xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 452  : }

	movaps	xmm7, XMMWORD PTR [rsp+96]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	movups	XMMWORD PTR [rcx+rax+16], xmm0
	movsd	xmm0, QWORD PTR draw_cmd$[rsp+48]
	movups	XMMWORD PTR [rcx+rax+32], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 452  : }

	movaps	xmm6, XMMWORD PTR [rsp+112]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	movsd	QWORD PTR [rcx+rax+48], xmm0
	inc	DWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 452  : }

	add	rsp, 128				; 00000080H
	pop	rbx
	ret	0
?AddDrawCmd@ImDrawList@@QEAAXXZ ENDP			; ImDrawList::AddDrawCmd
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?_ResetForNewFrame@ImDrawList@@QEAAXXZ
_TEXT	SEGMENT
$T1 = 32
this$ = 112
?_ResetForNewFrame@ImDrawList@@QEAAXXZ PROC		; ImDrawList::_ResetForNewFrame, COMDAT

; 393  : {

$LN69:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 96					; 00000060H

; 394  :     // Verify that the ImDrawCmd fields we want to memcmp() are contiguous in memory.
; 395  :     IM_STATIC_ASSERT(IM_OFFSETOF(ImDrawCmd, ClipRect) == 0);
; 396  :     IM_STATIC_ASSERT(IM_OFFSETOF(ImDrawCmd, TextureId) == sizeof(ImVec4));
; 397  :     IM_STATIC_ASSERT(IM_OFFSETOF(ImDrawCmd, VtxOffset) == sizeof(ImVec4) + sizeof(ImTextureID));
; 398  :     if (_Splitter._Count > 1)

	cmp	DWORD PTR [rcx+172], 1
	mov	rbx, rcx
	jle	SHORT $LN2@ResetForNe

; 399  :         _Splitter.Merge(this);

	add	rcx, 168				; 000000a8H
	mov	rdx, rbx
	call	?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z ; ImDrawListSplitter::Merge
$LN2@ResetForNe:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	ecx, DWORD PTR [rbx+4]
	xor	esi, esi
	test	ecx, ecx
	jns	SHORT $LN5@ResetForNe

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	eax, ecx
	cdq
	sub	eax, edx
	mov	edx, esi
	sar	eax, 1
	add	eax, ecx

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	rcx, rbx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	eax, eax
	cmovg	edx, eax

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	call	?reserve@?$ImVector@UImDrawCmd@@@@QEAAXH@Z ; ImVector<ImDrawCmd>::reserve
$LN5@ResetForNe:
	mov	DWORD PTR [rbx], esi
	mov	ecx, DWORD PTR [rbx+20]
	test	ecx, ecx
	jns	SHORT $LN12@ResetForNe

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	eax, ecx
	cdq
	sub	eax, edx
	mov	edx, esi
	sar	eax, 1
	add	eax, ecx

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	lea	rcx, QWORD PTR [rbx+16]

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	eax, eax
	cmovg	edx, eax

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	call	?reserve@?$ImVector@G@@QEAAXH@Z		; ImVector<unsigned short>::reserve
$LN12@ResetForNe:
	mov	DWORD PTR [rbx+16], esi
	mov	ecx, DWORD PTR [rbx+36]
	test	ecx, ecx
	jns	SHORT $LN19@ResetForNe

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	eax, ecx
	cdq
	sub	eax, edx
	mov	edx, esi
	sar	eax, 1
	add	eax, ecx

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	lea	rcx, QWORD PTR [rbx+32]

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	eax, eax
	cmovg	edx, eax

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	call	?reserve@?$ImVector@UImDrawVert@@@@QEAAXH@Z ; ImVector<ImDrawVert>::reserve
$LN19@ResetForNe:
	mov	DWORD PTR [rbx+32], esi
	xorps	xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 404  :     Flags = _Data->InitialFlags;

	mov	rax, QWORD PTR [rbx+56]
	mov	ecx, DWORD PTR [rax+44]
	mov	DWORD PTR [rbx+48], ecx

; 405  :     memset(&_CmdHeader, 0, sizeof(_CmdHeader));

	movups	XMMWORD PTR [rbx+136], xmm0
	movups	XMMWORD PTR [rbx+152], xmm0

; 406  :     _VtxCurrentIdx = 0;

	mov	DWORD PTR [rbx+52], esi

; 407  :     _VtxWritePtr = NULL;

	mov	QWORD PTR [rbx+72], rsi

; 408  :     _IdxWritePtr = NULL;

	mov	QWORD PTR [rbx+80], rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	ecx, DWORD PTR [rbx+92]
	test	ecx, ecx
	jns	SHORT $LN26@ResetForNe

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	eax, ecx
	cdq
	sub	eax, edx
	mov	edx, esi
	sar	eax, 1
	add	eax, ecx

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	lea	rcx, QWORD PTR [rbx+88]

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	eax, eax
	cmovg	edx, eax

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	call	?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z	; ImVector<ImVec4>::reserve
$LN26@ResetForNe:
	mov	DWORD PTR [rbx+88], esi
	mov	ecx, DWORD PTR [rbx+108]
	test	ecx, ecx
	jns	SHORT $LN33@ResetForNe

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	eax, ecx
	cdq
	sub	eax, edx
	mov	edx, esi
	sar	eax, 1
	add	eax, ecx

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	lea	rcx, QWORD PTR [rbx+104]

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	eax, eax
	cmovg	edx, eax

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	call	?reserve@?$ImVector@PEAX@@QEAAXH@Z	; ImVector<void *>::reserve
$LN33@ResetForNe:
	mov	DWORD PTR [rbx+104], esi
	mov	ecx, DWORD PTR [rbx+124]
	test	ecx, ecx
	jns	SHORT $LN40@ResetForNe

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	eax, ecx
	cdq
	sub	eax, edx
	mov	edx, esi
	sar	eax, 1
	add	eax, ecx

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	lea	rcx, QWORD PTR [rbx+120]

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	eax, eax
	cmovg	edx, eax

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN40@ResetForNe:
	mov	DWORD PTR [rbx+120], esi

; 2640 :     ImDrawCmd() { memset(this, 0, sizeof(*this)); } // Also ensure our padding fields are zeroed

	xor	eax, eax

; 2688 :     inline void                 Clear() { _Current = 0; _Count = 1; } // Do not clear Channels[] so our allocations are reused next frame

	mov	DWORD PTR [rbx+168], esi
	xorps	xmm0, xmm0
	mov	DWORD PTR [rbx+172], 1

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	ecx, DWORD PTR [rbx]
	mov	r8d, DWORD PTR [rbx+4]

; 2640 :     ImDrawCmd() { memset(this, 0, sizeof(*this)); } // Also ensure our padding fields are zeroed

	mov	QWORD PTR $T1[rsp+48], rax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	cmp	ecx, r8d
	jne	SHORT $LN53@ResetForNe
	inc	ecx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	r8d, r8d
	je	SHORT $LN57@ResetForNe
	mov	eax, r8d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r8d
	jmp	SHORT $LN58@ResetForNe
$LN57@ResetForNe:
	mov	eax, 8
$LN58@ResetForNe:
	cmp	eax, ecx
	cmovg	ecx, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, ecx
	mov	rcx, rbx
	call	?reserve@?$ImVector@UImDrawCmd@@@@QEAAXH@Z ; ImVector<ImDrawCmd>::reserve
	xorps	xmm0, xmm0
$LN53@ResetForNe:
	movsxd	rax, DWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 415  : }

	mov	rsi, QWORD PTR [rsp+120]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	imul	rcx, rax, 56				; 00000038H
	mov	rax, QWORD PTR [rbx+8]
	movups	XMMWORD PTR [rcx+rax], xmm0
	movups	XMMWORD PTR [rcx+rax+16], xmm0
	movups	XMMWORD PTR [rcx+rax+32], xmm0
	movsd	xmm0, QWORD PTR $T1[rsp+48]
	movsd	QWORD PTR [rcx+rax+48], xmm0
	inc	DWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 414  :     _FringeScale = 1.0f;

	mov	DWORD PTR [rbx+192], 1065353216		; 3f800000H

; 415  : }

	mov	rbx, QWORD PTR [rsp+112]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
?_ResetForNewFrame@ImDrawList@@QEAAXXZ ENDP		; ImDrawList::_ResetForNewFrame
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?_ClearFreeMemory@ImDrawList@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_ClearFreeMemory@ImDrawList@@QEAAXXZ PROC		; ImDrawList::_ClearFreeMemory, COMDAT

; 418  : {

$LN82:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	xor	edi, edi
	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN4@ClearFreeM
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx], rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN8@ClearFreeM

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN8@ClearFreeM:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx+8], rdi
$LN4@ClearFreeM:
	mov	rcx, QWORD PTR [rbx+24]
	test	rcx, rcx
	je	SHORT $LN15@ClearFreeM
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx+16], rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN19@ClearFreeM

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN19@ClearFreeM:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx+24], rdi
$LN15@ClearFreeM:
	mov	rcx, QWORD PTR [rbx+40]
	test	rcx, rcx
	je	SHORT $LN26@ClearFreeM
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx+32], rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN30@ClearFreeM

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN30@ClearFreeM:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx+40], rdi
$LN26@ClearFreeM:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 422  :     Flags = ImDrawListFlags_None;

	mov	QWORD PTR [rbx+48], rdi

; 423  :     _VtxCurrentIdx = 0;
; 424  :     _VtxWritePtr = NULL;

	mov	QWORD PTR [rbx+72], rdi

; 425  :     _IdxWritePtr = NULL;

	mov	QWORD PTR [rbx+80], rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	rcx, QWORD PTR [rbx+96]
	test	rcx, rcx
	je	SHORT $LN37@ClearFreeM
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx+88], rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN41@ClearFreeM

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN41@ClearFreeM:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx+96], rdi
$LN37@ClearFreeM:
	mov	rcx, QWORD PTR [rbx+112]
	test	rcx, rcx
	je	SHORT $LN48@ClearFreeM
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx+104], rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN52@ClearFreeM

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN52@ClearFreeM:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx+112], rdi
$LN48@ClearFreeM:
	mov	rcx, QWORD PTR [rbx+128]
	test	rcx, rcx
	je	SHORT $LN59@ClearFreeM
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx+120], rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN63@ClearFreeM

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN63@ClearFreeM:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx+128], rdi
$LN59@ClearFreeM:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 429  :     _Splitter.ClearFreeMemory();

	lea	rcx, QWORD PTR [rbx+168]

; 430  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi

; 429  :     _Splitter.ClearFreeMemory();

	jmp	?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ ; ImDrawListSplitter::ClearFreeMemory
?_ClearFreeMemory@ImDrawList@@QEAAXXZ ENDP		; ImDrawList::_ClearFreeMemory
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?_PopUnusedDrawCmd@ImDrawList@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_PopUnusedDrawCmd@ImDrawList@@QEAAXXZ PROC		; ImDrawList::_PopUnusedDrawCmd, COMDAT

; 458  :     while (CmdBuffer.Size > 0)

	mov	eax, DWORD PTR [rcx]
	test	eax, eax
	jle	SHORT $LN10@PopUnusedD
	npad	10
$LL2@PopUnusedD:

; 459  :     {
; 460  :         ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];

	mov	edx, eax
	imul	r8, rdx, 56				; 00000038H
	mov	rdx, QWORD PTR [rcx+8]

; 461  :         if (curr_cmd->ElemCount != 0 || curr_cmd->UserCallback != NULL)

	cmp	DWORD PTR [r8+rdx-24], 0
	jne	SHORT $LN10@PopUnusedD
	cmp	QWORD PTR [r8+rdx-16], 0
	jne	SHORT $LN10@PopUnusedD
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	dec	eax
	mov	DWORD PTR [rcx], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 458  :     while (CmdBuffer.Size > 0)

	test	eax, eax
	jg	SHORT $LL2@PopUnusedD
$LN10@PopUnusedD:

; 462  :             return;// break;
; 463  :         CmdBuffer.pop_back();
; 464  :     }
; 465  : }

	ret	0
?_PopUnusedDrawCmd@ImDrawList@@QEAAXXZ ENDP		; ImDrawList::_PopUnusedDrawCmd
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ PROC	; ImDrawListSplitter::ClearFreeMemory, COMDAT

; 1676 : {

$LN59:
	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	sub	rsp, 32					; 00000020H

; 1677 :     for (int i = 0; i < _Channels.Size; i++)

	xor	ebp, ebp
	mov	QWORD PTR [rsp+56], rdi
	mov	rbx, rcx
	mov	edi, ebp
	cmp	DWORD PTR [rcx+8], ebp
	jle	$LN3@ClearFreeM
	mov	QWORD PTR [rsp+48], rsi
	mov	QWORD PTR [rsp+64], r14
	mov	r14d, ebp
	npad	4
$LL4@ClearFreeM:

; 1678 :     {
; 1679 :         if (i == _Current)

	cmp	edi, DWORD PTR [rbx]
	jne	SHORT $LN5@ClearFreeM
	xorps	xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rax, edi
	shl	rax, 5
	add	rax, QWORD PTR [rbx+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1680 :             memset(&_Channels[i], 0, sizeof(_Channels[i]));  // Current channel is a copy of CmdBuffer/IdxBuffer, don't destruct again

	movups	XMMWORD PTR [rax], xmm0
	movups	XMMWORD PTR [rax+16], xmm0
$LN5@ClearFreeM:

; 1681 :         _Channels[i]._CmdBuffer.clear();

	mov	rsi, QWORD PTR [rbx+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	rcx, QWORD PTR [rsi+r14+8]
	test	rcx, rcx
	je	SHORT $LN12@ClearFreeM
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rsi+r14], rbp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN16@ClearFreeM

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN16@ClearFreeM:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rsi+r14+8], rbp
$LN12@ClearFreeM:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1682 :         _Channels[i]._IdxBuffer.clear();

	mov	rsi, QWORD PTR [rbx+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	rcx, QWORD PTR [rsi+r14+24]
	test	rcx, rcx
	je	SHORT $LN2@ClearFreeM
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rsi+r14+16], rbp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN29@ClearFreeM

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN29@ClearFreeM:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rsi+r14+24], rbp
$LN2@ClearFreeM:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1677 :     for (int i = 0; i < _Channels.Size; i++)

	inc	edi
	add	r14, 32					; 00000020H
	cmp	edi, DWORD PTR [rbx+8]
	jl	$LL4@ClearFreeM
	mov	r14, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+48]
$LN3@ClearFreeM:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	rdi, QWORD PTR [rsp+56]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1684 :     _Current = 0;

	mov	DWORD PTR [rbx], ebp

; 1685 :     _Count = 1;

	mov	DWORD PTR [rbx+4], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	rcx, QWORD PTR [rbx+16]
	test	rcx, rcx
	je	SHORT $LN36@ClearFreeM
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx+8], rbp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN40@ClearFreeM

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN40@ClearFreeM:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx+16], rbp
$LN36@ClearFreeM:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1687 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ ENDP	; ImDrawListSplitter::ClearFreeMemory
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?Split@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z
_TEXT	SEGMENT
this$ = 80
draw_list$dead$ = 88
$T1 = 88
channels_count$ = 96
?Split@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z PROC ; ImDrawListSplitter::Split, COMDAT

; 1690 : {

$LN61:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 1691 :     IM_UNUSED(draw_list);
; 1692 :     IM_ASSERT(_Current == 0 && _Count <= 1 && "Nested channel splitting is not supported. Please use separate instances of ImDrawListSplitter.");
; 1693 :     int old_channels_count = _Channels.Size;

	movsxd	rsi, DWORD PTR [rcx+8]
	mov	rbp, rcx
	movsxd	rbx, r8d

; 1694 :     if (old_channels_count < channels_count)

	cmp	esi, ebx
	jge	SHORT $LN5@Split

; 1695 :     {
; 1696 :         _Channels.reserve(channels_count); // Avoid over reserving since this is likely to stay stable

	mov	edx, ebx
	add	rcx, 8
	call	?reserve@?$ImVector@UImDrawChannel@@@@QEAAXH@Z ; ImVector<ImDrawChannel>::reserve
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	ecx, DWORD PTR [rbp+12]
	cmp	ebx, ecx
	jle	SHORT $LN13@Split

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN17@Split
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN18@Split
$LN17@Split:
	mov	eax, 8
$LN18@Split:
	cmp	eax, ebx

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	lea	rcx, QWORD PTR [rbp+8]

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	edx, ebx
	cmovg	edx, eax

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	call	?reserve@?$ImVector@UImDrawChannel@@@@QEAAXH@Z ; ImVector<ImDrawChannel>::reserve
$LN13@Split:
	mov	DWORD PTR [rbp+8], ebx
$LN5@Split:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1699 :     _Count = channels_count;

	mov	DWORD PTR [rbp+4], ebx
	xorps	xmm0, xmm0

; 1700 : 
; 1701 :     // Channels[] (24/32 bytes each) hold storage that we'll swap with draw_list->_CmdBuffer/_IdxBuffer
; 1702 :     // The content of Channels[0] at this point doesn't matter. We clear it to make state tidy in a debugger but we don't strictly need to.
; 1703 :     // When we switch to the next channel, we'll copy draw_list->_CmdBuffer/_IdxBuffer into Channels[0] and then Channels[1] into draw_list->CmdBuffer/_IdxBuffer
; 1704 :     memset(&_Channels[0], 0, sizeof(ImDrawChannel));

	mov	rax, QWORD PTR [rbp+16]

; 1705 :     for (int i = 1; i < channels_count; i++)

	mov	r14, rbx
	movups	XMMWORD PTR [rax], xmm0
	movups	XMMWORD PTR [rax+16], xmm0
	cmp	rbx, 1
	jle	$LN3@Split
	mov	QWORD PTR [rsp+80], r12

; 1706 :     {
; 1707 :         if (i >= old_channels_count)

	mov	edi, 1
	mov	QWORD PTR [rsp+104], r15
	xor	r12d, r12d
	mov	r15, rsi
	mov	esi, 32					; 00000020H
	npad	6
$LL4@Split:
	mov	rbx, QWORD PTR [rbp+16]
	add	rbx, rsi
	cmp	rdi, r15
	jl	SHORT $LN6@Split

; 1708 :         {
; 1709 :             IM_PLACEMENT_NEW(&_Channels[i]) ImDrawChannel();

	mov	QWORD PTR $T1[rsp], rbx
	test	rbx, rbx
	je	SHORT $LN2@Split
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rbx], xmm0
	movups	XMMWORD PTR [rbx+16], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1903 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rbx], r12
	mov	QWORD PTR [rbx+8], r12
	mov	QWORD PTR [rbx+16], r12
	mov	QWORD PTR [rbx+24], r12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1710 :         }

	jmp	SHORT $LN2@Split
$LN6@Split:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	ecx, DWORD PTR [rbx+4]
	test	ecx, ecx
	jns	SHORT $LN32@Split

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	eax, ecx
	cdq
	sub	eax, edx
	mov	edx, r12d
	sar	eax, 1
	add	eax, ecx

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	rcx, rbx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	eax, eax
	cmovg	edx, eax

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	call	?reserve@?$ImVector@UImDrawCmd@@@@QEAAXH@Z ; ImVector<ImDrawCmd>::reserve
$LN32@Split:
	mov	DWORD PTR [rbx], r12d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1714 :             _Channels[i]._IdxBuffer.resize(0);

	mov	rbx, QWORD PTR [rbp+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	ecx, DWORD PTR [rbx+rsi+20]
	test	ecx, ecx
	jns	SHORT $LN41@Split

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	eax, ecx
	cdq
	sub	eax, edx
	mov	edx, r12d
	sar	eax, 1
	add	eax, ecx

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	lea	rcx, QWORD PTR [rbx+16]

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	eax, eax
	cmovg	edx, eax

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	add	rcx, rsi
	call	?reserve@?$ImVector@G@@QEAAXH@Z		; ImVector<unsigned short>::reserve
$LN41@Split:
	mov	DWORD PTR [rbx+rsi+16], r12d
$LN2@Split:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1705 :     for (int i = 1; i < channels_count; i++)

	inc	rdi
	add	rsi, 32					; 00000020H
	cmp	rdi, r14
	jl	$LL4@Split
	mov	r15, QWORD PTR [rsp+104]
	mov	r12, QWORD PTR [rsp+80]
$LN3@Split:

; 1715 :         }
; 1716 :     }
; 1717 : }

	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
?Split@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z ENDP ; ImDrawListSplitter::Split
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z
_TEXT	SEGMENT
$T1 = 32
new_idx_buffer_count$1$ = 128
this$ = 128
draw_list$ = 136
new_cmd_buffer_count$1$ = 144
i$1$ = 152
?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z PROC	; ImDrawListSplitter::Merge, COMDAT

; 1720 : {

$LN126:
	mov	rax, rsp
	mov	QWORD PTR [rax+16], rdx
	push	r13
	push	r15
	sub	rsp, 104				; 00000068H

; 1721 :     // Note that we never use or rely on _Channels.Size because it is merely a buffer that we never shrink back to 0 to keep all sub-buffers ready for use.
; 1722 :     if (_Count <= 1)

	cmp	DWORD PTR [rcx+4], 1
	mov	r15, rdx
	mov	r13, rcx
	jle	$LN1@Merge
	mov	QWORD PTR [rax-24], rbx

; 1723 :         return;
; 1724 : 
; 1725 :     SetCurrentChannel(draw_list, 0);

	xor	r8d, r8d
	mov	QWORD PTR [rax-32], rbp
	mov	QWORD PTR [rax-40], rsi
	mov	QWORD PTR [rax-48], rdi
	mov	QWORD PTR [rax-56], r12
	mov	QWORD PTR [rax-64], r14
	call	?SetCurrentChannel@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z ; ImDrawListSplitter::SetCurrentChannel

; 458  :     while (CmdBuffer.Size > 0)

	mov	r8d, DWORD PTR [r15]
	test	r8d, r8d
	jle	SHORT $LN95@Merge

; 462  :             return;// break;
; 463  :         CmdBuffer.pop_back();

	mov	edx, r8d
	npad	6
$LL57@Merge:

; 459  :     {
; 460  :         ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];

	mov	eax, edx
	imul	rcx, rax, 56				; 00000038H
	mov	rax, QWORD PTR [r15+8]

; 461  :         if (curr_cmd->ElemCount != 0 || curr_cmd->UserCallback != NULL)

	cmp	DWORD PTR [rcx+rax-24], 0
	jne	SHORT $LN95@Merge
	cmp	QWORD PTR [rcx+rax-16], 0
	jne	SHORT $LN95@Merge
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	lea	r8d, DWORD PTR [rdx-1]
	mov	DWORD PTR [r15], r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 458  :     while (CmdBuffer.Size > 0)

	mov	edx, r8d
	test	r8d, r8d
	jg	SHORT $LL57@Merge
$LN95@Merge:

; 1726 :     draw_list->_PopUnusedDrawCmd();
; 1727 : 
; 1728 :     // Calculate our final buffer sizes. Also fix the incorrect IdxOffset values in each command.
; 1729 :     int new_cmd_buffer_count = 0;
; 1730 :     int new_idx_buffer_count = 0;
; 1731 :     ImDrawCmd* last_cmd = (_Count > 0 && draw_list->CmdBuffer.Size > 0) ? &draw_list->CmdBuffer.back() : NULL;

	mov	edx, DWORD PTR [r13+4]
	xor	r9d, r9d
	xor	r10d, r10d
	mov	DWORD PTR new_cmd_buffer_count$1$[rsp], r9d
	mov	DWORD PTR new_idx_buffer_count$1$[rsp], r10d
	test	edx, edx
	jle	SHORT $LN85@Merge
	test	r8d, r8d
	jle	SHORT $LN85@Merge
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	lea	r11, QWORD PTR [r15+8]
	lea	eax, DWORD PTR [r8-1]
	mov	QWORD PTR $T1[rsp], r11
	movsxd	rcx, eax
	imul	r14, rcx, 56				; 00000038H
	add	r14, QWORD PTR [r11]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1732 :     int idx_offset = last_cmd ? last_cmd->IdxOffset + last_cmd->ElemCount : 0;

	je	SHORT $LN26@Merge
	mov	edi, DWORD PTR [r14+32]
	add	edi, DWORD PTR [r14+28]
	jmp	SHORT $LN27@Merge
$LN85@Merge:

; 1726 :     draw_list->_PopUnusedDrawCmd();
; 1727 : 
; 1728 :     // Calculate our final buffer sizes. Also fix the incorrect IdxOffset values in each command.
; 1729 :     int new_cmd_buffer_count = 0;
; 1730 :     int new_idx_buffer_count = 0;
; 1731 :     ImDrawCmd* last_cmd = (_Count > 0 && draw_list->CmdBuffer.Size > 0) ? &draw_list->CmdBuffer.back() : NULL;

	xor	r14d, r14d
	lea	r11, QWORD PTR [r15+8]
$LN26@Merge:

; 1732 :     int idx_offset = last_cmd ? last_cmd->IdxOffset + last_cmd->ElemCount : 0;

	xor	edi, edi
	mov	QWORD PTR $T1[rsp], r11
$LN27@Merge:

; 1733 :     for (int i = 1; i < _Count; i++)

	mov	DWORD PTR i$1$[rsp], 1
	mov	r12d, 32				; 00000020H
	cmp	edx, 1
	jle	$LN93@Merge
	mov	r15d, r12d
	npad	7
$LL4@Merge:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	rbx, QWORD PTR [r13+16]
	add	rbx, r15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1736 :         if (ch._CmdBuffer.Size > 0 && ch._CmdBuffer.back().ElemCount == 0 && ch._CmdBuffer.back().UserCallback == NULL) // Equivalent of PopUnusedDrawCmd()

	mov	edx, DWORD PTR [rbx]
	mov	esi, edx
	test	edx, edx
	jle	SHORT $LN12@Merge
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	lea	r8d, DWORD PTR [rdx-1]
	movsxd	rax, r8d
	imul	rcx, rax, 56				; 00000038H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1736 :         if (ch._CmdBuffer.Size > 0 && ch._CmdBuffer.back().ElemCount == 0 && ch._CmdBuffer.back().UserCallback == NULL) // Equivalent of PopUnusedDrawCmd()

	mov	rax, QWORD PTR [rbx+8]
	cmp	DWORD PTR [rcx+rax+32], 0
	jne	SHORT $LN12@Merge
	cmp	QWORD PTR [rcx+rax+40], 0
	jne	SHORT $LN12@Merge
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	mov	DWORD PTR [rbx], r8d
	mov	esi, r8d
$LN12@Merge:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1739 :         if (ch._CmdBuffer.Size > 0 && last_cmd != NULL)

	mov	ebp, esi
	test	esi, esi
	jle	SHORT $LN14@Merge
	test	r14, r14
	je	SHORT $LN94@Merge

; 1740 :         {
; 1741 :             // Do not include ImDrawCmd_AreSequentialIdxOffset() in the compare as we rebuild IdxOffset values ourselves.
; 1742 :             // Manipulating IdxOffset (e.g. by reordering draw commands like done by RenderDimmedBackgroundBehindWindow()) is not supported within a splitter.
; 1743 :             ImDrawCmd* next_cmd = &ch._CmdBuffer[0];

	mov	r12, QWORD PTR [rbx+8]

; 1744 :             if (ImDrawCmd_HeaderCompare(last_cmd, next_cmd) == 0 && last_cmd->UserCallback == NULL && next_cmd->UserCallback == NULL)

	mov	r8d, 28
	mov	rdx, r12
	mov	rcx, r14
	call	memcmp
	test	eax, eax
	jne	SHORT $LN94@Merge
	cmp	QWORD PTR [r14+40], 0
	jne	SHORT $LN94@Merge
	cmp	QWORD PTR [r12+40], 0
	jne	SHORT $LN94@Merge

; 1745 :             {
; 1746 :                 // Merge previous channel last draw command with current channel first draw command if matching.
; 1747 :                 last_cmd->ElemCount += next_cmd->ElemCount;

	mov	eax, DWORD PTR [r12+32]
	add	DWORD PTR [r14+32], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1941 :     inline T*           erase(const T* it)                  { IM_ASSERT(it >= Data && it < Data + Size); const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + 1, ((size_t)Size - (size_t)off - 1) * sizeof(T)); Size--; return Data + off; }

	movsxd	rax, DWORD PTR [rbx]
	mov	rcx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1748 :                 idx_offset += next_cmd->ElemCount;

	add	edi, DWORD PTR [r12+32]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1941 :     inline T*           erase(const T* it)                  { IM_ASSERT(it >= Data && it < Data + Size); const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + 1, ((size_t)Size - (size_t)off - 1) * sizeof(T)); Size--; return Data + off; }

	imul	r8, rax, 56				; 00000038H
	lea	rdx, QWORD PTR [rcx+56]
	sub	r8, 56					; 00000038H
	call	memmove
	dec	DWORD PTR [rbx]
	mov	ebp, DWORD PTR [rbx]
	mov	r9d, DWORD PTR new_cmd_buffer_count$1$[rsp]
	mov	r10d, DWORD PTR new_idx_buffer_count$1$[rsp]
$LN14@Merge:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1752 :         if (ch._CmdBuffer.Size > 0)

	test	ebp, ebp
	jle	SHORT $LN91@Merge
$LN94@Merge:

; 1753 :             last_cmd = &ch._CmdBuffer.back();

	mov	r9d, DWORD PTR new_cmd_buffer_count$1$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	lea	eax, DWORD PTR [rbp-1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1753 :             last_cmd = &ch._CmdBuffer.back();

	mov	r10d, DWORD PTR new_idx_buffer_count$1$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	movsxd	rcx, eax
	imul	r14, rcx, 56				; 00000038H
	add	r14, QWORD PTR [rbx+8]
$LN91@Merge:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1755 :         new_idx_buffer_count += ch._IdxBuffer.Size;

	add	r10d, DWORD PTR [rbx+16]
	add	r9d, ebp

; 1756 :         for (int cmd_n = 0; cmd_n < ch._CmdBuffer.Size; cmd_n++)

	xor	ecx, ecx
	mov	DWORD PTR new_cmd_buffer_count$1$[rsp], r9d
	mov	DWORD PTR new_idx_buffer_count$1$[rsp], r10d
	test	ebp, ebp
	jle	SHORT $LN2@Merge

; 1754 :         new_cmd_buffer_count += ch._CmdBuffer.Size;

	mov	rdx, QWORD PTR [rbx+8]
	xor	eax, eax
	npad	11
$LL7@Merge:

; 1757 :         {
; 1758 :             ch._CmdBuffer.Data[cmd_n].IdxOffset = idx_offset;

	mov	DWORD PTR [rdx+rax+28], edi
	lea	rax, QWORD PTR [rax+56]

; 1759 :             idx_offset += ch._CmdBuffer.Data[cmd_n].ElemCount;

	mov	rdx, QWORD PTR [rbx+8]
	inc	ecx
	add	edi, DWORD PTR [rdx+rax-24]
	cmp	ecx, DWORD PTR [rbx]
	jl	SHORT $LL7@Merge
$LN2@Merge:

; 1733 :     for (int i = 1; i < _Count; i++)

	mov	ecx, DWORD PTR i$1$[rsp]
	add	r15, 32					; 00000020H
	inc	ecx
	mov	DWORD PTR i$1$[rsp], ecx
	cmp	ecx, DWORD PTR [r13+4]
	jl	$LL4@Merge

; 1753 :             last_cmd = &ch._CmdBuffer.back();

	mov	r15, QWORD PTR draw_list$[rsp]
	mov	r12d, 32				; 00000020H
$LN93@Merge:

; 1762 :     draw_list->CmdBuffer.resize(draw_list->CmdBuffer.Size + new_cmd_buffer_count);

	mov	edi, DWORD PTR [r15]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	ebx, 8
	mov	ecx, DWORD PTR [r15+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1762 :     draw_list->CmdBuffer.resize(draw_list->CmdBuffer.Size + new_cmd_buffer_count);

	add	edi, r9d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	cmp	edi, ecx
	jle	SHORT $LN35@Merge

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN39@Merge
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN40@Merge
$LN39@Merge:
	mov	eax, ebx
$LN40@Merge:
	cmp	eax, edi
	mov	edx, edi

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	rcx, r15

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	edx, eax

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	call	?reserve@?$ImVector@UImDrawCmd@@@@QEAAXH@Z ; ImVector<ImDrawCmd>::reserve
$LN35@Merge:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1763 :     draw_list->IdxBuffer.resize(draw_list->IdxBuffer.Size + new_idx_buffer_count);

	movsxd	rbp, DWORD PTR new_idx_buffer_count$1$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [r15], edi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1763 :     draw_list->IdxBuffer.resize(draw_list->IdxBuffer.Size + new_idx_buffer_count);

	mov	edi, DWORD PTR [r15+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	ecx, DWORD PTR [r15+20]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1763 :     draw_list->IdxBuffer.resize(draw_list->IdxBuffer.Size + new_idx_buffer_count);

	add	edi, ebp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	cmp	edi, ecx
	jle	SHORT $LN42@Merge

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN46@Merge
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	lea	ebx, DWORD PTR [rcx+rax]
$LN46@Merge:
	cmp	ebx, edi

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	lea	rcx, QWORD PTR [r15+16]

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	edx, edi
	cmovg	edx, ebx

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	call	?reserve@?$ImVector@G@@QEAAXH@Z		; ImVector<unsigned short>::reserve
$LN42@Merge:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1766 :     ImDrawCmd* cmd_write = draw_list->CmdBuffer.Data + draw_list->CmdBuffer.Size - new_cmd_buffer_count;

	movsxd	rax, DWORD PTR new_cmd_buffer_count$1$[rsp]

; 1768 :     for (int i = 1; i < _Count; i++)

	mov	esi, 1
	mov	rbx, QWORD PTR $T1[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [r15+16], edi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1766 :     ImDrawCmd* cmd_write = draw_list->CmdBuffer.Data + draw_list->CmdBuffer.Size - new_cmd_buffer_count;

	movsxd	rcx, DWORD PTR [r15]
	sub	rcx, rax

; 1767 :     ImDrawIdx* idx_write = draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size - new_idx_buffer_count;

	mov	rax, QWORD PTR [r15+24]
	mov	rdx, QWORD PTR [rbx]
	imul	r14, rcx, 56				; 00000038H
	movsxd	rcx, edi
	sub	rcx, rbp
	add	r14, rdx
	lea	rbp, QWORD PTR [rax+rcx*2]

; 1768 :     for (int i = 1; i < _Count; i++)

	cmp	DWORD PTR [r13+4], esi
	jle	SHORT $LN9@Merge
	npad	10
$LL10@Merge:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	rdi, QWORD PTR [r13+16]
	add	rdi, r12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1771 :         if (int sz = ch._CmdBuffer.Size) { memcpy(cmd_write, ch._CmdBuffer.Data, sz * sizeof(ImDrawCmd)); cmd_write += sz; }

	movsxd	rax, DWORD PTR [rdi]
	test	eax, eax
	je	SHORT $LN16@Merge
	mov	rdx, QWORD PTR [rdi+8]
	mov	rcx, r14
	imul	rbx, rax, 56				; 00000038H
	mov	r8, rbx
	call	memcpy
	add	r14, rbx
$LN16@Merge:

; 1772 :         if (int sz = ch._IdxBuffer.Size) { memcpy(idx_write, ch._IdxBuffer.Data, sz * sizeof(ImDrawIdx)); idx_write += sz; }

	movsxd	rax, DWORD PTR [rdi+16]
	test	eax, eax
	je	SHORT $LN8@Merge
	mov	rdx, QWORD PTR [rdi+24]
	mov	rbx, rax
	add	rbx, rbx
	mov	rcx, rbp
	mov	r8, rbx
	call	memcpy
	add	rbp, rbx
$LN8@Merge:

; 1768 :     for (int i = 1; i < _Count; i++)

	inc	esi
	add	r12, 32					; 00000020H
	cmp	esi, DWORD PTR [r13+4]
	jl	SHORT $LL10@Merge
	mov	rbx, QWORD PTR $T1[rsp]
	mov	rdx, QWORD PTR [rbx]
$LN9@Merge:

; 1773 :     }
; 1774 :     draw_list->_IdxWritePtr = idx_write;
; 1775 : 
; 1776 :     // Ensure there's always a non-callback draw command trailing the command-buffer
; 1777 :     if (draw_list->CmdBuffer.Size == 0 || draw_list->CmdBuffer.back().UserCallback != NULL)

	movsxd	rax, DWORD PTR [r15]
	mov	r14, QWORD PTR [rsp+56]
	mov	r12, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	QWORD PTR [r15+80], rbp
	mov	rbp, QWORD PTR [rsp+88]
	test	eax, eax
	je	SHORT $LN86@Merge
	imul	rcx, rax, 56				; 00000038H
	cmp	QWORD PTR [rcx+rdx-16], 0
	je	SHORT $LN18@Merge
$LN86@Merge:

; 1778 :         draw_list->AddDrawCmd();

	mov	rcx, r15
	call	?AddDrawCmd@ImDrawList@@QEAAXXZ		; ImDrawList::AddDrawCmd
$LN18@Merge:

; 1779 : 
; 1780 :     // If current command is used with different settings we need to add a new command
; 1781 :     ImDrawCmd* curr_cmd = &draw_list->CmdBuffer.Data[draw_list->CmdBuffer.Size - 1];

	movsxd	rax, DWORD PTR [r15]

; 1782 :     if (curr_cmd->ElemCount == 0)

	lea	rdx, QWORD PTR [r15+136]
	imul	rcx, rax, 56				; 00000038H
	add	rcx, -56				; ffffffffffffffc8H
	add	rcx, QWORD PTR [rbx]
	mov	rbx, QWORD PTR [rsp+96]
	cmp	DWORD PTR [rcx+32], 0
	jne	SHORT $LN20@Merge

; 1783 :         ImDrawCmd_HeaderCopy(curr_cmd, &draw_list->_CmdHeader); // Copy ClipRect, TextureId, VtxOffset

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0
	movsd	xmm1, QWORD PTR [rdx+16]
	movsd	QWORD PTR [rcx+16], xmm1
	mov	eax, DWORD PTR [rdx+24]
	mov	DWORD PTR [rcx+24], eax

; 1786 : 
; 1787 :     _Count = 1;

	mov	DWORD PTR [r13+4], 1

; 1788 : }

	add	rsp, 104				; 00000068H
	pop	r15
	pop	r13
	ret	0
$LN20@Merge:

; 1784 :     else if (ImDrawCmd_HeaderCompare(curr_cmd, &draw_list->_CmdHeader) != 0)

	mov	r8d, 28
	call	memcmp
	test	eax, eax
	je	SHORT $LN22@Merge

; 1785 :         draw_list->AddDrawCmd();

	mov	rcx, r15
	call	?AddDrawCmd@ImDrawList@@QEAAXXZ		; ImDrawList::AddDrawCmd
$LN22@Merge:

; 1786 : 
; 1787 :     _Count = 1;

	mov	DWORD PTR [r13+4], 1
$LN1@Merge:

; 1788 : }

	add	rsp, 104				; 00000068H
	pop	r15
	pop	r13
	ret	0
?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z ENDP	; ImDrawListSplitter::Merge
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?SetCurrentChannel@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z
_TEXT	SEGMENT
this$ = 48
draw_list$ = 56
idx$ = 64
?SetCurrentChannel@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z PROC ; ImDrawListSplitter::SetCurrentChannel, COMDAT

; 1791 : {

$LN18:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1792 :     IM_ASSERT(idx >= 0 && idx < _Count);
; 1793 :     if (_Current == idx)

	movsxd	rax, DWORD PTR [rcx]
	mov	rbx, rdx
	mov	rdx, rcx
	cmp	eax, r8d
	je	$LN7@SetCurrent

; 1794 :         return;
; 1795 : 
; 1796 :     // Overwrite ImVector (12/16 bytes), four times. This is merely a silly optimization instead of doing .swap()
; 1797 :     memcpy(&_Channels.Data[_Current]._CmdBuffer, &draw_list->CmdBuffer, sizeof(draw_list->CmdBuffer));

	movups	xmm0, XMMWORD PTR [rbx]
	mov	r9, rax
	mov	rax, QWORD PTR [rcx+16]
	shl	r9, 5
	movups	XMMWORD PTR [r9+rax], xmm0

; 1798 :     memcpy(&_Channels.Data[_Current]._IdxBuffer, &draw_list->IdxBuffer, sizeof(draw_list->IdxBuffer));

	movsxd	rcx, DWORD PTR [rcx]
	mov	rax, QWORD PTR [rdx+16]
	movups	xmm0, XMMWORD PTR [rbx+16]
	shl	rcx, 5
	movups	XMMWORD PTR [rcx+rax+16], xmm0

; 1799 :     _Current = idx;
; 1800 :     memcpy(&draw_list->CmdBuffer, &_Channels.Data[idx]._CmdBuffer, sizeof(draw_list->CmdBuffer));

	mov	rax, QWORD PTR [rdx+16]
	mov	DWORD PTR [rdx], r8d
	movsxd	rcx, r8d
	shl	rcx, 5
	movups	xmm0, XMMWORD PTR [rcx+rax]
	movups	XMMWORD PTR [rbx], xmm0

; 1801 :     memcpy(&draw_list->IdxBuffer, &_Channels.Data[idx]._IdxBuffer, sizeof(draw_list->IdxBuffer));

	mov	rax, QWORD PTR [rdx+16]
	movups	xmm0, XMMWORD PTR [rcx+rax+16]
	movups	XMMWORD PTR [rbx+16], xmm0

; 1802 :     draw_list->_IdxWritePtr = draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size;

	mov	rax, QWORD PTR [rbx+24]
	movsxd	rcx, DWORD PTR [rbx+16]
	lea	rcx, QWORD PTR [rax+rcx*2]

; 1803 : 
; 1804 :     // If current command is used with different settings we need to add a new command
; 1805 :     ImDrawCmd* curr_cmd = (draw_list->CmdBuffer.Size == 0) ? NULL : &draw_list->CmdBuffer.Data[draw_list->CmdBuffer.Size - 1];

	movsxd	rax, DWORD PTR [rbx]
	mov	QWORD PTR [rbx+80], rcx
	test	eax, eax
	je	SHORT $LN12@SetCurrent
	imul	rcx, rax, 56				; 00000038H
	mov	rax, QWORD PTR [rbx+8]
	add	rax, -56				; ffffffffffffffc8H
	add	rcx, rax

; 1806 :     if (curr_cmd == NULL)

	je	SHORT $LN12@SetCurrent

; 1807 :         draw_list->AddDrawCmd();
; 1808 :     else if (curr_cmd->ElemCount == 0)

	cmp	DWORD PTR [rcx+32], 0
	lea	rdx, QWORD PTR [rbx+136]
	jne	SHORT $LN5@SetCurrent

; 1809 :         ImDrawCmd_HeaderCopy(curr_cmd, &draw_list->_CmdHeader); // Copy ClipRect, TextureId, VtxOffset

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0
	movsd	xmm1, QWORD PTR [rdx+16]
	movsd	QWORD PTR [rcx+16], xmm1
	mov	eax, DWORD PTR [rdx+24]
	mov	DWORD PTR [rcx+24], eax

; 1812 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN5@SetCurrent:

; 1810 :     else if (ImDrawCmd_HeaderCompare(curr_cmd, &draw_list->_CmdHeader) != 0)

	mov	r8d, 28
	call	memcmp
	test	eax, eax
	je	SHORT $LN7@SetCurrent
$LN12@SetCurrent:

; 1811 :         draw_list->AddDrawCmd();

	mov	rcx, rbx

; 1812 : }

	add	rsp, 32					; 00000020H
	pop	rbx

; 1811 :         draw_list->AddDrawCmd();

	jmp	?AddDrawCmd@ImDrawList@@QEAAXXZ		; ImDrawList::AddDrawCmd
$LN7@SetCurrent:

; 1812 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?SetCurrentChannel@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z ENDP ; ImDrawListSplitter::SetCurrentChannel
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ??0ImFont@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0ImFont@@QEAA@XZ PROC					; ImFont::ImFont, COMDAT
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1903 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

	xor	edx, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3183 :     FallbackChar = (ImWchar)-1;

	mov	DWORD PTR [rcx+82], -1			; ffffffffH

; 3194 :     MetricsTotalSurface = 0;
; 3195 :     memset(Used4kPagesMap, 0, sizeof(Used4kPagesMap));

	xor	eax, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1903 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rcx], rdx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+24], rdx
	mov	QWORD PTR [rcx+32], rdx
	mov	QWORD PTR [rcx+40], rdx
	mov	QWORD PTR [rcx+48], rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3182 :     FallbackAdvanceX = 0.0f;

	mov	QWORD PTR [rcx+16], rdx

; 3184 :     EllipsisChar = (ImWchar)-1;
; 3185 :     EllipsisWidth = EllipsisCharStep = 0.0f;

	mov	QWORD PTR [rcx+88], rdx

; 3186 :     EllipsisCharCount = 0;

	mov	WORD PTR [rcx+86], dx

; 3187 :     FallbackGlyph = NULL;

	mov	QWORD PTR [rcx+56], rdx

; 3188 :     ContainerAtlas = NULL;

	mov	QWORD PTR [rcx+64], rdx

; 3189 :     ConfigData = NULL;

	mov	QWORD PTR [rcx+72], rdx

; 3190 :     ConfigDataCount = 0;

	mov	WORD PTR [rcx+80], dx

; 3191 :     DirtyLookupTables = false;

	mov	BYTE PTR [rcx+96], dl

; 3192 :     Scale = 1.0f;
; 3193 :     Ascent = Descent = 0.0f;

	mov	QWORD PTR [rcx+108], rdx
	mov	QWORD PTR [rcx+100], 1065353216		; 3f800000H

; 3194 :     MetricsTotalSurface = 0;
; 3195 :     memset(Used4kPagesMap, 0, sizeof(Used4kPagesMap));

	mov	WORD PTR [rcx+116], ax

; 3196 : }

	mov	rax, rcx
	ret	0
??0ImFont@@QEAA@XZ ENDP					; ImFont::ImFont
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ??1ImFont@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1ImFont@@QEAA@XZ PROC					; ImFont::~ImFont, COMDAT

; 3199 : {

$LN42:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 3200 :     ClearOutputData();

	call	?ClearOutputData@ImFont@@QEAAXXZ	; ImFont::ClearOutputData
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1906 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

	mov	rcx, QWORD PTR [rbx+48]
	test	rcx, rcx
	je	SHORT $LN11@ImFont
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN9@ImFont

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN9@ImFont:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
	npad	1
$LN11@ImFont:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1906 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

	mov	rcx, QWORD PTR [rbx+32]
	test	rcx, rcx
	je	SHORT $LN23@ImFont
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN21@ImFont

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN21@ImFont:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
	npad	1
$LN23@ImFont:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1906 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

	mov	rcx, QWORD PTR [rbx+8]
	test	rcx, rcx
	je	SHORT $LN39@ImFont
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN33@ImFont

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN33@ImFont:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
	npad	1
$LN39@ImFont:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3201 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1ImFont@@QEAA@XZ ENDP					; ImFont::~ImFont
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?FindGlyphNoFallback@ImFont@@QEBAPEBUImFontGlyph@@G@Z
_TEXT	SEGMENT
this$ = 8
c$ = 16
?FindGlyphNoFallback@ImFont@@QEBAPEBUImFontGlyph@@G@Z PROC ; ImFont::FindGlyphNoFallback, COMDAT

; 3410 :     if (c >= (size_t)IndexLookup.Size)

	movsxd	rax, DWORD PTR [rcx+24]
	movzx	edx, dx
	cmp	rdx, rax
	jae	SHORT $LN5@FindGlyphN

; 3411 :         return NULL;
; 3412 :     const ImWchar i = IndexLookup.Data[c];

	mov	rax, QWORD PTR [rcx+32]
	movzx	edx, WORD PTR [rax+rdx*2]

; 3413 :     if (i == (ImWchar)-1)

	mov	eax, 65535				; 0000ffffH
	cmp	dx, ax
	je	SHORT $LN5@FindGlyphN

; 3415 :     return &Glyphs.Data[i];

	mov	rax, QWORD PTR [rcx+48]
	lea	rdx, QWORD PTR [rdx+rdx*4]
	lea	rax, QWORD PTR [rax+rdx*8]

; 3416 : }

	ret	0
$LN5@FindGlyphN:

; 3414 :         return NULL;

	xor	eax, eax

; 3416 : }

	ret	0
?FindGlyphNoFallback@ImFont@@QEBAPEBUImFontGlyph@@G@Z ENDP ; ImFont::FindGlyphNoFallback
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z
_TEXT	SEGMENT
this$ = 176
__$ReturnUdt$ = 184
size$ = 192
max_width$ = 200
c$1 = 208
wrap_width$ = 208
text_begin$ = 216
text_end$ = 224
remaining$ = 232
?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z PROC ; ImFont::CalcTextSizeA, COMDAT

; 3530 : {

$LN77:
	mov	rax, rsp
	push	rbx
	push	rsi
	sub	rsp, 152				; 00000098H

; 3531 :     if (!text_end)

	mov	rbx, QWORD PTR text_begin$[rsp]
	mov	rsi, rdx
	mov	QWORD PTR [rax+16], rdi
	mov	rdi, QWORD PTR text_end$[rsp]
	mov	QWORD PTR [rax+24], r12
	mov	QWORD PTR [rax+32], r14
	mov	QWORD PTR [rax-24], r15
	mov	r15, rcx
	movaps	XMMWORD PTR [rax-40], xmm6
	movaps	XMMWORD PTR [rax-56], xmm7
	movaps	xmm7, xmm2
	movaps	XMMWORD PTR [rax-72], xmm8
	movaps	XMMWORD PTR [rax-88], xmm9
	movaps	XMMWORD PTR [rax-104], xmm10
	movaps	XMMWORD PTR [rax-120], xmm11
	movaps	xmm11, xmm3
	test	rdi, rdi
	jne	SHORT $LN4@CalcTextSi

; 3532 :         text_end = text_begin + strlen(text_begin); // FIXME-OPT: Need to avoid this.

	mov	rdi, -1
$LL53@CalcTextSi:
	inc	rdi
	cmp	BYTE PTR [rbx+rdi], 0
	jne	SHORT $LL53@CalcTextSi
	add	rdi, rbx
$LN4@CalcTextSi:

; 3536 : 
; 3537 :     ImVec2 text_size = ImVec2(0, 0);
; 3538 :     float line_width = 0.0f;
; 3539 : 
; 3540 :     const bool word_wrap_enabled = (wrap_width > 0.0f);

	movss	xmm10, DWORD PTR wrap_width$[rsp]
	xorps	xmm8, xmm8
	comiss	xmm10, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	QWORD PTR [rdx], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3535 :     const float scale = size / FontSize;

	movaps	xmm9, xmm7
	xorps	xmm6, xmm6
	divss	xmm9, DWORD PTR [rcx+20]

; 3536 : 
; 3537 :     ImVec2 text_size = ImVec2(0, 0);
; 3538 :     float line_width = 0.0f;
; 3539 : 
; 3540 :     const bool word_wrap_enabled = (wrap_width > 0.0f);

	seta	r12b

; 3541 :     const char* word_wrap_eol = NULL;

	xor	r14d, r14d

; 3542 : 
; 3543 :     const char* s = text_begin;
; 3544 :     while (s < text_end)

	cmp	rbx, rdi
	jae	$LN3@CalcTextSi
	mov	QWORD PTR [rsp+176], rbp
	npad	5
$LL2@CalcTextSi:

; 3545 :     {
; 3546 :         if (word_wrap_enabled)

	test	r12b, r12b
	je	SHORT $LN7@CalcTextSi

; 3547 :         {
; 3548 :             // Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.
; 3549 :             if (!word_wrap_eol)

	test	r14, r14
	jne	SHORT $LN6@CalcTextSi

; 3550 :                 word_wrap_eol = CalcWordWrapPositionA(scale, s, text_end, wrap_width - line_width);

	movaps	xmm0, xmm10
	mov	r9, rdi
	subss	xmm0, xmm6
	mov	r8, rbx
	movaps	xmm1, xmm9
	mov	rcx, r15
	movss	DWORD PTR [rsp+32], xmm0
	call	?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z ; ImFont::CalcWordWrapPositionA
	mov	r14, rax
$LN6@CalcTextSi:

; 3551 : 
; 3552 :             if (s >= word_wrap_eol)

	cmp	rbx, r14
	jb	SHORT $LN7@CalcTextSi

; 3553 :             {
; 3554 :                 if (text_size.x < line_width)

	comiss	xmm6, DWORD PTR [rsi]
	jbe	SHORT $LN8@CalcTextSi

; 3555 :                     text_size.x = line_width;

	movss	DWORD PTR [rsi], xmm6
$LN8@CalcTextSi:

; 3556 :                 text_size.y += line_height;

	movaps	xmm0, xmm7

; 3557 :                 line_width = 0.0f;
; 3558 :                 word_wrap_eol = NULL;

	xor	r14d, r14d
	movaps	xmm6, xmm8
	addss	xmm0, DWORD PTR [rsi+4]
	movss	DWORD PTR [rsi+4], xmm0

; 3421 :     while (text < text_end && ImCharIsBlankA(*text))

	cmp	rbx, rdi
	jae	SHORT $LN55@CalcTextSi
$LL25@CalcTextSi:
	movzx	eax, BYTE PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 375  : static inline bool      ImCharIsBlankA(char c)          { return c == ' ' || c == '\t'; }

	cmp	al, 32					; 00000020H
	je	SHORT $LN51@CalcTextSi
	cmp	al, 9
	jne	SHORT $LN55@CalcTextSi
$LN51@CalcTextSi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3422 :         text++;

	inc	rbx
	cmp	rbx, rdi
	jb	SHORT $LL25@CalcTextSi
$LN55@CalcTextSi:

; 3423 :     if (*text == '\n')

	cmp	BYTE PTR [rbx], 10
	jne	$LN44@CalcTextSi

; 3424 :         text++;

	inc	rbx

; 3559 :                 s = CalcWordWrapNextLineStartA(s, text_end); // Wrapping skips upcoming blanks
; 3560 :                 continue;

	jmp	$LN44@CalcTextSi
$LN7@CalcTextSi:

; 3561 :             }
; 3562 :         }
; 3563 : 
; 3564 :         // Decode and advance source
; 3565 :         const char* prev_s = s;
; 3566 :         unsigned int c = (unsigned int)*s;

	movsx	eax, BYTE PTR [rbx]
	mov	rbp, rbx
	mov	DWORD PTR c$1[rsp], eax
	cmp	eax, 128				; 00000080H

; 3567 :         if (c < 0x80)

	jae	SHORT $LN9@CalcTextSi

; 3568 :             s += 1;

	mov	ecx, 1
	jmp	SHORT $LN10@CalcTextSi
$LN9@CalcTextSi:

; 3569 :         else
; 3570 :             s += ImTextCharFromUtf8(&c, s, text_end);

	mov	r8, rdi
	lea	rcx, QWORD PTR c$1[rsp]
	mov	rdx, rbx
	call	?ImTextCharFromUtf8@@YAHPEAIPEBD1@Z	; ImTextCharFromUtf8
	movsxd	rcx, eax
	mov	eax, DWORD PTR c$1[rsp]
$LN10@CalcTextSi:

; 3571 : 
; 3572 :         if (c < 32)

	add	rbx, rcx
	cmp	eax, 32					; 00000020H
	jae	SHORT $LN13@CalcTextSi

; 3573 :         {
; 3574 :             if (c == '\n')

	cmp	eax, 10
	jne	SHORT $LN12@CalcTextSi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movss	xmm0, DWORD PTR [rsi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3577 :                 text_size.y += line_height;

	movaps	xmm1, xmm7
	addss	xmm1, DWORD PTR [rsi+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm0, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3578 :                 line_width = 0.0f;

	movaps	xmm6, xmm8
	movss	DWORD PTR [rsi+4], xmm1
	movss	DWORD PTR [rsi], xmm0

; 3579 :                 continue;

	jmp	SHORT $LN44@CalcTextSi
$LN12@CalcTextSi:

; 3580 :             }
; 3581 :             if (c == '\r')

	cmp	eax, 13
	je	SHORT $LN44@CalcTextSi
$LN13@CalcTextSi:

; 3582 :                 continue;
; 3583 :         }
; 3584 : 
; 3585 :         const float char_width = ((int)c < IndexAdvanceX.Size ? IndexAdvanceX.Data[c] : FallbackAdvanceX) * scale;

	cmp	eax, DWORD PTR [r15]
	jge	SHORT $LN20@CalcTextSi
	mov	ecx, eax
	mov	rax, QWORD PTR [r15+8]
	movss	xmm0, DWORD PTR [rax+rcx*4]
	jmp	SHORT $LN21@CalcTextSi
$LN20@CalcTextSi:
	movss	xmm0, DWORD PTR [r15+16]
$LN21@CalcTextSi:
	mulss	xmm0, xmm9

; 3586 :         if (line_width + char_width >= max_width)

	addss	xmm0, xmm6
	comiss	xmm0, xmm11
	jae	SHORT $LN42@CalcTextSi

; 3589 :             break;
; 3590 :         }
; 3591 : 
; 3592 :         line_width += char_width;

	movaps	xmm6, xmm0
$LN44@CalcTextSi:

; 3542 : 
; 3543 :     const char* s = text_begin;
; 3544 :     while (s < text_end)

	cmp	rbx, rdi
	jb	$LL2@CalcTextSi

; 3586 :         if (line_width + char_width >= max_width)

	jmp	SHORT $LN75@CalcTextSi
$LN42@CalcTextSi:

; 3587 :         {
; 3588 :             s = prev_s;

	mov	rbx, rbp
$LN75@CalcTextSi:
	mov	rbp, QWORD PTR [rsp+176]
$LN3@CalcTextSi:

; 3593 :     }
; 3594 : 
; 3595 :     if (text_size.x < line_width)

	comiss	xmm6, DWORD PTR [rsi]
	mov	r15, QWORD PTR [rsp+144]
	mov	r14, QWORD PTR [rsp+200]
	mov	r12, QWORD PTR [rsp+192]
	mov	rdi, QWORD PTR [rsp+184]
	movaps	xmm11, XMMWORD PTR [rsp+48]
	movaps	xmm10, XMMWORD PTR [rsp+64]
	movaps	xmm9, XMMWORD PTR [rsp+80]
	jbe	SHORT $LN15@CalcTextSi

; 3596 :         text_size.x = line_width;

	movss	DWORD PTR [rsi], xmm6
$LN15@CalcTextSi:

; 3597 : 
; 3598 :     if (line_width > 0 || text_size.y == 0.0f)

	comiss	xmm6, xmm8
	movaps	xmm6, XMMWORD PTR [rsp+128]
	ja	SHORT $LN50@CalcTextSi
	movss	xmm0, DWORD PTR [rsi+4]
	ucomiss	xmm0, xmm8
	jp	SHORT $LN16@CalcTextSi
	jne	SHORT $LN16@CalcTextSi
$LN50@CalcTextSi:

; 3599 :         text_size.y += line_height;

	addss	xmm7, DWORD PTR [rsi+4]
	movss	DWORD PTR [rsi+4], xmm7
$LN16@CalcTextSi:

; 3600 : 
; 3601 :     if (remaining)

	mov	rax, QWORD PTR remaining$[rsp]
	movaps	xmm8, XMMWORD PTR [rsp+96]
	movaps	xmm7, XMMWORD PTR [rsp+112]
	test	rax, rax
	je	SHORT $LN54@CalcTextSi

; 3602 :         *remaining = s;

	mov	QWORD PTR [rax], rbx
$LN54@CalcTextSi:

; 3603 : 
; 3604 :     return text_size;
; 3605 : }

	mov	rax, rsi
	add	rsp, 152				; 00000098H
	pop	rsi
	pop	rbx
	ret	0
?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ENDP ; ImFont::CalcTextSizeA
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?RenderChar@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IG@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 64
$T4 = 144
this$ = 144
draw_list$ = 152
size$ = 160
pos$ = 168
col$ = 176
c$ = 184
?RenderChar@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IG@Z PROC ; ImFont::RenderChar, COMDAT

; 3609 : {

$LN26:
	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	sub	rsp, 128				; 00000080H
	mov	r10d, DWORD PTR col$[rsp]
	mov	r8, rcx

; 3400 :     if (c >= (size_t)IndexLookup.Size)

	movzx	ecx, WORD PTR c$[rsp]

; 3609 : {

	mov	rsi, rdx
	movaps	XMMWORD PTR [rsp+80], xmm8
	movaps	xmm8, xmm2

; 3400 :     if (c >= (size_t)IndexLookup.Size)

	movsxd	rax, DWORD PTR [r8+24]
	cmp	rcx, rax
	jb	SHORT $LN9@RenderChar

; 3401 :         return FallbackGlyph;

	mov	rbx, QWORD PTR [r8+56]
	jmp	SHORT $LN8@RenderChar
$LN9@RenderChar:

; 3402 :     const ImWchar i = IndexLookup.Data[c];

	mov	rax, QWORD PTR [r8+32]
	movzx	ecx, WORD PTR [rax+rcx*2]

; 3403 :     if (i == (ImWchar)-1)

	mov	eax, 65535				; 0000ffffH
	cmp	cx, ax
	jne	SHORT $LN10@RenderChar

; 3404 :         return FallbackGlyph;

	mov	rbx, QWORD PTR [r8+56]
	jmp	SHORT $LN8@RenderChar
$LN10@RenderChar:

; 3405 :     return &Glyphs.Data[i];

	mov	rax, QWORD PTR [r8+48]
	lea	rcx, QWORD PTR [rcx+rcx*4]
	lea	rbx, QWORD PTR [rax+rcx*8]
$LN8@RenderChar:

; 3610 :     const ImFontGlyph* glyph = FindGlyph(c);
; 3611 :     if (!glyph || !glyph->Visible)

	test	rbx, rbx
	je	$LN3@RenderChar
	mov	eax, DWORD PTR [rbx]
	test	al, 2
	je	$LN3@RenderChar
	mov	QWORD PTR [rsp+152], rdi
	xorps	xmm0, xmm0

; 3612 :         return;
; 3613 :     if (glyph->Colored)
; 3614 :         col |= ~IM_COL32_A_MASK;
; 3615 :     float scale = (size >= 0.0f) ? (size / FontSize) : 1.0f;

	mov	edi, r10d
	movaps	XMMWORD PTR [rsp+112], xmm6
	or	edi, 16777215				; 00ffffffH
	movaps	XMMWORD PTR [rsp+96], xmm7
	test	al, 1
	cmove	edi, r10d
	comiss	xmm8, xmm0
	jb	SHORT $LN6@RenderChar
	divss	xmm8, DWORD PTR [r8+20]
	jmp	SHORT $LN7@RenderChar
$LN6@RenderChar:
	movss	xmm8, DWORD PTR __real@3f800000
$LN7@RenderChar:

; 3616 :     float x = IM_FLOOR(pos.x);

	cvttss2si eax, DWORD PTR [r9]

; 3617 :     float y = IM_FLOOR(pos.y);
; 3618 :     draw_list->PrimReserve(6, 4);

	mov	edx, 6
	mov	rcx, rsi
	lea	r8d, QWORD PTR [rdx-2]
	movd	xmm6, eax
	cvttss2si eax, DWORD PTR [r9+4]
	cvtdq2ps xmm6, xmm6
	movd	xmm7, eax
	cvtdq2ps xmm7, xmm7
	call	?PrimReserve@ImDrawList@@QEAAXHH@Z	; ImDrawList::PrimReserve

; 3619 :     draw_list->PrimRectUV(ImVec2(x + glyph->X0 * scale, y + glyph->Y0 * scale), ImVec2(x + glyph->X1 * scale, y + glyph->Y1 * scale), ImVec2(glyph->U0, glyph->V0), ImVec2(glyph->U1, glyph->V1), col);

	lea	rax, QWORD PTR $T4[rsp]
	mov	DWORD PTR [rsp+40], edi
	lea	r9, QWORD PTR $T1[rsp]
	mov	rcx, rsi
	lea	r8, QWORD PTR $T2[rsp]
	mov	QWORD PTR [rsp+32], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm0, DWORD PTR [rbx+32]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3619 :     draw_list->PrimRectUV(ImVec2(x + glyph->X0 * scale, y + glyph->Y0 * scale), ImVec2(x + glyph->X1 * scale, y + glyph->Y1 * scale), ImVec2(glyph->U0, glyph->V0), ImVec2(glyph->U1, glyph->V1), col);

	lea	rdx, QWORD PTR $T3[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm1, DWORD PTR [rbx+36]
	movss	DWORD PTR $T4[rsp], xmm0
	movss	xmm0, DWORD PTR [rbx+24]
	movss	DWORD PTR $T1[rsp], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3619 :     draw_list->PrimRectUV(ImVec2(x + glyph->X0 * scale, y + glyph->Y0 * scale), ImVec2(x + glyph->X1 * scale, y + glyph->Y1 * scale), ImVec2(glyph->U0, glyph->V0), ImVec2(glyph->U1, glyph->V1), col);

	movaps	xmm0, xmm8
	mulss	xmm0, DWORD PTR [rbx+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T4[rsp+4], xmm1
	movss	xmm1, DWORD PTR [rbx+28]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3619 :     draw_list->PrimRectUV(ImVec2(x + glyph->X0 * scale, y + glyph->Y0 * scale), ImVec2(x + glyph->X1 * scale, y + glyph->Y1 * scale), ImVec2(glyph->U0, glyph->V0), ImVec2(glyph->U1, glyph->V1), col);

	addss	xmm0, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T1[rsp+4], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3619 :     draw_list->PrimRectUV(ImVec2(x + glyph->X0 * scale, y + glyph->Y0 * scale), ImVec2(x + glyph->X1 * scale, y + glyph->Y1 * scale), ImVec2(glyph->U0, glyph->V0), ImVec2(glyph->U1, glyph->V1), col);

	movaps	xmm1, xmm8
	mulss	xmm1, DWORD PTR [rbx+20]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T2[rsp], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3619 :     draw_list->PrimRectUV(ImVec2(x + glyph->X0 * scale, y + glyph->Y0 * scale), ImVec2(x + glyph->X1 * scale, y + glyph->Y1 * scale), ImVec2(glyph->U0, glyph->V0), ImVec2(glyph->U1, glyph->V1), col);

	movaps	xmm0, xmm8
	mulss	xmm0, DWORD PTR [rbx+8]
	addss	xmm1, xmm7
	mulss	xmm8, DWORD PTR [rbx+12]
	addss	xmm0, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T2[rsp+4], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3619 :     draw_list->PrimRectUV(ImVec2(x + glyph->X0 * scale, y + glyph->Y0 * scale), ImVec2(x + glyph->X1 * scale, y + glyph->Y1 * scale), ImVec2(glyph->U0, glyph->V0), ImVec2(glyph->U1, glyph->V1), col);

	addss	xmm8, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T3[rsp], xmm0
	movss	DWORD PTR $T3[rsp+4], xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3619 :     draw_list->PrimRectUV(ImVec2(x + glyph->X0 * scale, y + glyph->Y0 * scale), ImVec2(x + glyph->X1 * scale, y + glyph->Y1 * scale), ImVec2(glyph->U0, glyph->V0), ImVec2(glyph->U1, glyph->V1), col);

	call	?PrimRectUV@ImDrawList@@QEAAXAEBUImVec2@@000I@Z ; ImDrawList::PrimRectUV
	movaps	xmm7, XMMWORD PTR [rsp+96]
	movaps	xmm6, XMMWORD PTR [rsp+112]
	mov	rdi, QWORD PTR [rsp+152]
$LN3@RenderChar:

; 3620 : }

	mov	rbx, QWORD PTR [rsp+160]
	movaps	xmm8, XMMWORD PTR [rsp+80]
	add	rsp, 128				; 00000080H
	pop	rsi
	ret	0
?RenderChar@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IG@Z ENDP ; ImFont::RenderChar
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?AddRectFilledMultiColor@ImDrawList@@QEAAXAEBUImVec2@@0IIII@Z
_TEXT	SEGMENT
this$ = 96
p_min$ = 104
p_max$ = 112
col_upr_left$ = 120
col_upr_right$ = 128
col_bot_right$ = 136
col_bot_left$ = 144
?AddRectFilledMultiColor@ImDrawList@@QEAAXAEBUImVec2@@0IIII@Z PROC ; ImDrawList::AddRectFilledMultiColor, COMDAT

; 1422 : {

$LN30:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 64					; 00000040H

; 1423 :     if (((col_upr_left | col_upr_right | col_bot_right | col_bot_left) & IM_COL32_A_MASK) == 0)

	mov	esi, DWORD PTR col_upr_right$[rsp]
	mov	eax, r9d
	mov	ebp, DWORD PTR col_bot_right$[rsp]
	or	eax, esi
	mov	r14d, DWORD PTR col_bot_left$[rsp]
	or	eax, ebp
	or	eax, r14d
	mov	edi, r9d
	mov	r15, r8
	mov	r12, rdx
	mov	rbx, rcx
	test	eax, -16777216				; ff000000H
	je	$LN1@AddRectFil

; 1424 :         return;
; 1425 : 
; 1426 :     const ImVec2 uv = _Data->TexUvWhitePixel;

	mov	rax, QWORD PTR [rcx+56]

; 1427 :     PrimReserve(6, 4);

	mov	edx, 6
	movaps	XMMWORD PTR [rsp+48], xmm6
	movaps	XMMWORD PTR [rsp+32], xmm7
	movss	xmm6, DWORD PTR [rax]
	lea	r8d, QWORD PTR [rdx-2]
	movss	xmm7, DWORD PTR [rax+4]
	call	?PrimReserve@ImDrawList@@QEAAXHH@Z	; ImDrawList::PrimReserve
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2839 :     inline    void  PrimWriteIdx(ImDrawIdx idx)                                     { *_IdxWritePtr = idx; _IdxWritePtr++; }

	mov	rcx, QWORD PTR [rbx+80]
	movzx	eax, WORD PTR [rbx+52]
	mov	WORD PTR [rcx], ax
	add	QWORD PTR [rbx+80], 2
	mov	rcx, QWORD PTR [rbx+80]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1428 :     PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx + 1)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx + 2));

	movzx	eax, WORD PTR [rbx+52]
	inc	ax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2839 :     inline    void  PrimWriteIdx(ImDrawIdx idx)                                     { *_IdxWritePtr = idx; _IdxWritePtr++; }

	mov	WORD PTR [rcx], ax
	add	QWORD PTR [rbx+80], 2
	mov	rcx, QWORD PTR [rbx+80]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1428 :     PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx + 1)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx + 2));

	movzx	eax, WORD PTR [rbx+52]
	add	ax, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2839 :     inline    void  PrimWriteIdx(ImDrawIdx idx)                                     { *_IdxWritePtr = idx; _IdxWritePtr++; }

	mov	WORD PTR [rcx], ax
	add	QWORD PTR [rbx+80], 2
	movzx	eax, WORD PTR [rbx+52]
	mov	rcx, QWORD PTR [rbx+80]
	mov	WORD PTR [rcx], ax
	add	QWORD PTR [rbx+80], 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1429 :     PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx + 2)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx + 3));

	movzx	eax, WORD PTR [rbx+52]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2839 :     inline    void  PrimWriteIdx(ImDrawIdx idx)                                     { *_IdxWritePtr = idx; _IdxWritePtr++; }

	mov	rcx, QWORD PTR [rbx+80]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1429 :     PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx + 2)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx + 3));

	add	ax, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2839 :     inline    void  PrimWriteIdx(ImDrawIdx idx)                                     { *_IdxWritePtr = idx; _IdxWritePtr++; }

	mov	WORD PTR [rcx], ax
	add	QWORD PTR [rbx+80], 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1429 :     PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx + 2)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx + 3));

	movzx	eax, WORD PTR [rbx+52]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2839 :     inline    void  PrimWriteIdx(ImDrawIdx idx)                                     { *_IdxWritePtr = idx; _IdxWritePtr++; }

	mov	rcx, QWORD PTR [rbx+80]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1429 :     PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx + 2)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx + 3));

	add	ax, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2839 :     inline    void  PrimWriteIdx(ImDrawIdx idx)                                     { *_IdxWritePtr = idx; _IdxWritePtr++; }

	mov	WORD PTR [rcx], ax
	add	QWORD PTR [rbx+80], 2

; 2838 :     inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col)    { _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }

	movsd	xmm0, QWORD PTR [r12]
	mov	rax, QWORD PTR [rbx+72]
	movsd	QWORD PTR [rax], xmm0
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+8], xmm6
	movss	DWORD PTR [rax+12], xmm7
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+16], edi
	inc	DWORD PTR [rbx+52]
	mov	rax, QWORD PTR [rbx+72]
	add	rax, 20
	mov	QWORD PTR [rbx+72], rax

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm0, DWORD PTR [r15]
	movss	xmm1, DWORD PTR [r12+4]

; 2838 :     inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col)    { _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }

	movss	DWORD PTR [rax], xmm0
	movss	DWORD PTR [rax+4], xmm1
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+8], xmm6
	movss	DWORD PTR [rax+12], xmm7
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+16], esi
	add	QWORD PTR [rbx+72], 20
	inc	DWORD PTR [rbx+52]
	movsd	xmm0, QWORD PTR [r15]
	mov	rax, QWORD PTR [rbx+72]
	movsd	QWORD PTR [rax], xmm0
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+8], xmm6
	movss	DWORD PTR [rax+12], xmm7
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+16], ebp
	mov	rax, QWORD PTR [rbx+72]
	inc	DWORD PTR [rbx+52]
	add	rax, 20
	mov	QWORD PTR [rbx+72], rax

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm0, DWORD PTR [r12]
	movss	xmm1, DWORD PTR [r15+4]

; 2838 :     inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col)    { _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }

	movss	DWORD PTR [rax], xmm0
	movss	DWORD PTR [rax+4], xmm1
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+8], xmm6
	movss	DWORD PTR [rax+12], xmm7
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+16], r14d
	add	QWORD PTR [rbx+72], 20
	inc	DWORD PTR [rbx+52]
	movaps	xmm7, XMMWORD PTR [rsp+32]
	movaps	xmm6, XMMWORD PTR [rsp+48]
$LN1@AddRectFil:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1434 : }

	mov	rbx, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+104]
	mov	rsi, QWORD PTR [rsp+112]
	mov	rdi, QWORD PTR [rsp+120]
	add	rsp, 64					; 00000040H
	pop	r15
	pop	r14
	pop	r12
	ret	0
?AddRectFilledMultiColor@ImDrawList@@QEAAXAEBUImVec2@@0IIII@Z ENDP ; ImDrawList::AddRectFilledMultiColor
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?AddTriangle@ImDrawList@@QEAAXAEBUImVec2@@00IM@Z
_TEXT	SEGMENT
this$ = 64
p1$ = 72
p2$ = 80
p3$ = 88
col$ = 96
thickness$ = 104
?AddTriangle@ImDrawList@@QEAAXAEBUImVec2@@00IM@Z PROC	; ImDrawList::AddTriangle, COMDAT

; 1461 : {

$LN8:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	push	rsi
	sub	rsp, 48					; 00000030H

; 1462 :     if ((col & IM_COL32_A_MASK) == 0)

	test	DWORD PTR col$[rsp], -16777216		; ff000000H
	mov	rsi, r9
	mov	rbp, r8
	mov	rbx, rcx
	je	SHORT $LN1@AddTriangl

; 1463 :         return;
; 1464 : 
; 1465 :     PathLineTo(p1);

	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo

; 1466 :     PathLineTo(p2);

	mov	rdx, rbp
	mov	rcx, rbx
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo

; 1467 :     PathLineTo(p3);

	mov	rdx, rsi
	mov	rcx, rbx
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2808 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

	movss	xmm0, DWORD PTR thickness$[rsp]
	mov	rcx, rbx
	mov	r9d, DWORD PTR col$[rsp]
	mov	r8d, DWORD PTR [rbx+120]
	mov	rdx, QWORD PTR [rbx+128]
	movss	DWORD PTR [rsp+40], xmm0
	mov	DWORD PTR [rsp+32], 1
	call	?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z ; ImDrawList::AddPolyline
	mov	DWORD PTR [rbx+120], 0
$LN1@AddTriangl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1469 : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rsi
	ret	0
?AddTriangle@ImDrawList@@QEAAXAEBUImVec2@@00IM@Z ENDP	; ImDrawList::AddTriangle
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?AddBezierCubic@ImDrawList@@QEAAXAEBUImVec2@@000IMH@Z
_TEXT	SEGMENT
this$ = 64
p1$ = 72
p2$ = 80
p3$ = 88
p4$ = 96
col$ = 104
thickness$ = 112
num_segments$dead$ = 120
?AddBezierCubic@ImDrawList@@QEAAXAEBUImVec2@@000IMH@Z PROC ; ImDrawList::AddBezierCubic, COMDAT

; 1556 : {

$LN8:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	push	rsi
	sub	rsp, 48					; 00000030H

; 1557 :     if ((col & IM_COL32_A_MASK) == 0)

	test	DWORD PTR col$[rsp], -16777216		; ff000000H
	mov	rsi, r9
	mov	rbp, r8
	mov	rbx, rcx
	je	SHORT $LN1@AddBezierC

; 1558 :         return;
; 1559 : 
; 1560 :     PathLineTo(p1);

	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo

; 1561 :     PathBezierCubicCurveTo(p2, p3, p4, num_segments);

	mov	r9, QWORD PTR p4$[rsp]
	mov	r8, rsi
	mov	rdx, rbp
	mov	rcx, rbx
	call	?PathBezierCubicCurveTo@ImDrawList@@QEAAXAEBUImVec2@@00H@Z ; ImDrawList::PathBezierCubicCurveTo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2808 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

	movss	xmm0, DWORD PTR thickness$[rsp]
	xor	esi, esi
	mov	r9d, DWORD PTR col$[rsp]
	mov	rcx, rbx
	mov	r8d, DWORD PTR [rbx+120]
	mov	rdx, QWORD PTR [rbx+128]
	movss	DWORD PTR [rsp+40], xmm0
	mov	DWORD PTR [rsp+32], esi
	call	?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z ; ImDrawList::AddPolyline
	mov	DWORD PTR [rbx+120], esi
$LN1@AddBezierC:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1563 : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rsi
	ret	0
?AddBezierCubic@ImDrawList@@QEAAXAEBUImVec2@@000IMH@Z ENDP ; ImDrawList::AddBezierCubic
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?_CalcCircleAutoSegmentCount@ImDrawList@@QEBAHM@Z
_TEXT	SEGMENT
this$ = 48
radius$ = 56
?_CalcCircleAutoSegmentCount@ImDrawList@@QEBAHM@Z PROC	; ImDrawList::_CalcCircleAutoSegmentCount, COMDAT

; 567  : {

$LN14:
	sub	rsp, 40					; 00000028H

; 568  :     // Automatic segment count
; 569  :     const int radius_idx = (int)(radius + 0.999999f); // ceil to never reduce accuracy

	movaps	xmm0, xmm1
	movaps	xmm2, xmm1
	addss	xmm0, DWORD PTR __real@3f7fffef
	cvttss2si eax, xmm0

; 570  :     if (radius_idx >= 0 && radius_idx < IM_ARRAYSIZE(_Data->CircleSegmentCounts))

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN2@CalcCircle

; 571  :         return _Data->CircleSegmentCounts[radius_idx]; // Use cached value

	movsxd	rdx, eax
	mov	rax, QWORD PTR [rcx+56]
	movzx	eax, BYTE PTR [rdx+rax+452]

; 574  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN2@CalcCircle:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	mov	rax, QWORD PTR [rcx+56]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 573  :         return IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(radius, _Data->CircleSegmentMaxError);

	movss	xmm0, DWORD PTR __real@3f800000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	movss	xmm1, DWORD PTR [rax+24]
	minss	xmm1, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 573  :         return IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(radius, _Data->CircleSegmentMaxError);

	divss	xmm1, xmm2
	subss	xmm0, xmm1
	call	acosf
	movss	xmm1, DWORD PTR __real@40490fdb
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	call	ceilf
	cvttss2si eax, xmm0
	inc	eax
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	cmp	eax, 4
	jge	SHORT $LN11@CalcCircle
	mov	eax, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 574  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN11@CalcCircle:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	mov	ecx, 512				; 00000200H
	cmp	eax, ecx
	cmovg	eax, ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 574  : }

	add	rsp, 40					; 00000028H
	ret	0
?_CalcCircleAutoSegmentCount@ImDrawList@@QEBAHM@Z ENDP	; ImDrawList::_CalcCircleAutoSegmentCount
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??D@YA?AUImVec2@@AEBU0@M@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
lhs$ = 16
rhs$ = 24
??D@YA?AUImVec2@@AEBU0@M@Z PROC				; operator*, COMDAT

; 2536 : static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	movaps	xmm0, xmm2
	mov	rax, rcx
	mulss	xmm0, DWORD PTR [rdx]
	mulss	xmm2, DWORD PTR [rdx+4]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR [rcx], xmm0
	movss	DWORD PTR [rcx+4], xmm2

; 2536 : static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	ret	0
??D@YA?AUImVec2@@AEBU0@M@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??H@YA?AUImVec2@@AEBU0@0@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
lhs$ = 16
rhs$ = 24
??H@YA?AUImVec2@@AEBU0@0@Z PROC				; operator+, COMDAT

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movss	xmm0, DWORD PTR [rdx]
	mov	rax, rcx
	movss	xmm1, DWORD PTR [rdx+4]
	addss	xmm0, DWORD PTR [r8]
	addss	xmm1, DWORD PTR [r8+4]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR [rcx], xmm0
	movss	DWORD PTR [rcx+4], xmm1

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	ret	0
??H@YA?AUImVec2@@AEBU0@0@Z ENDP				; operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??G@YA?AUImVec2@@AEBU0@0@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
lhs$ = 16
rhs$ = 24
??G@YA?AUImVec2@@AEBU0@0@Z PROC				; operator-, COMDAT

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm0, DWORD PTR [rdx]
	mov	rax, rcx
	movss	xmm1, DWORD PTR [rdx+4]
	subss	xmm0, DWORD PTR [r8]
	subss	xmm1, DWORD PTR [r8+4]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR [rcx], xmm0
	movss	DWORD PTR [rcx+4], xmm1

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	ret	0
??G@YA?AUImVec2@@AEBU0@0@Z ENDP				; operator-
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??D@YA?AUImVec2@@AEBU0@0@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
lhs$ = 16
rhs$ = 24
??D@YA?AUImVec2@@AEBU0@0@Z PROC				; operator*, COMDAT

; 2540 : static inline ImVec2  operator*(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }

	movss	xmm0, DWORD PTR [rdx]
	mov	rax, rcx
	movss	xmm1, DWORD PTR [rdx+4]
	mulss	xmm0, DWORD PTR [r8]
	mulss	xmm1, DWORD PTR [r8+4]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR [rcx], xmm0
	movss	DWORD PTR [rcx+4], xmm1

; 2540 : static inline ImVec2  operator*(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }

	ret	0
??D@YA?AUImVec2@@AEBU0@0@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??Y@YAAEAUImVec2@@AEAU0@AEBU0@@Z
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
??Y@YAAEAUImVec2@@AEAU0@AEBU0@@Z PROC			; operator+=, COMDAT

; 2545 : static inline ImVec2& operator+=(ImVec2& lhs, const ImVec2& rhs)        { lhs.x += rhs.x; lhs.y += rhs.y; return lhs; }

	movss	xmm0, DWORD PTR [rcx]
	mov	rax, rcx
	addss	xmm0, DWORD PTR [rdx]
	movss	DWORD PTR [rcx], xmm0
	movss	xmm1, DWORD PTR [rdx+4]
	addss	xmm1, DWORD PTR [rcx+4]
	movss	DWORD PTR [rcx+4], xmm1
	ret	0
??Y@YAAEAUImVec2@@AEAU0@AEBU0@@Z ENDP			; operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??D@YA?AUImVec4@@AEBU0@0@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
lhs$ = 16
rhs$ = 24
??D@YA?AUImVec4@@AEBU0@0@Z PROC				; operator*, COMDAT

; 2551 : static inline ImVec4  operator*(const ImVec4& lhs, const ImVec4& rhs)   { return ImVec4(lhs.x * rhs.x, lhs.y * rhs.y, lhs.z * rhs.z, lhs.w * rhs.w); }

	movups	xmm1, XMMWORD PTR [rdx]
	mov	rax, rcx
	movups	xmm0, XMMWORD PTR [r8]
	mulps	xmm1, xmm0

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movups	XMMWORD PTR [rcx], xmm1

; 2551 : static inline ImVec4  operator*(const ImVec4& lhs, const ImVec4& rhs)   { return ImVec4(lhs.x * rhs.x, lhs.y * rhs.y, lhs.z * rhs.z, lhs.w * rhs.w); }

	ret	0
??D@YA?AUImVec4@@AEBU0@0@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??0ImDrawCmd@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0ImDrawCmd@@QEAA@XZ PROC				; ImDrawCmd::ImDrawCmd, COMDAT

; 2640 :     ImDrawCmd() { memset(this, 0, sizeof(*this)); } // Also ensure our padding fields are zeroed

	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	movups	XMMWORD PTR [rcx+16], xmm0
	movups	XMMWORD PTR [rcx+32], xmm0
	mov	QWORD PTR [rcx+48], rax
	mov	rax, rcx
	ret	0
??0ImDrawCmd@@QEAA@XZ ENDP				; ImDrawCmd::ImDrawCmd
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?Clear@ImDrawListSplitter@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?Clear@ImDrawListSplitter@@QEAAXXZ PROC			; ImDrawListSplitter::Clear, COMDAT

; 2688 :     inline void                 Clear() { _Current = 0; _Count = 1; } // Do not clear Channels[] so our allocations are reused next frame

	mov	DWORD PTR [rcx], 0
	mov	DWORD PTR [rcx+4], 1
	ret	0
?Clear@ImDrawListSplitter@@QEAAXXZ ENDP			; ImDrawListSplitter::Clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?PrimWriteVtx@ImDrawList@@QEAAXAEBUImVec2@@0I@Z
_TEXT	SEGMENT
this$ = 8
pos$ = 16
uv$ = 24
col$ = 32
?PrimWriteVtx@ImDrawList@@QEAAXAEBUImVec2@@0I@Z PROC	; ImDrawList::PrimWriteVtx, COMDAT

; 2838 :     inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col)    { _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }

	mov	rax, QWORD PTR [rcx+72]
	movsd	xmm0, QWORD PTR [rdx]
	movsd	xmm1, QWORD PTR [r8]
	movsd	QWORD PTR [rax], xmm0
	mov	rax, QWORD PTR [rcx+72]
	movsd	QWORD PTR [rax+8], xmm1
	mov	rax, QWORD PTR [rcx+72]
	mov	DWORD PTR [rax+16], r9d
	add	QWORD PTR [rcx+72], 20
	inc	DWORD PTR [rcx+52]
	ret	0
?PrimWriteVtx@ImDrawList@@QEAAXAEBUImVec2@@0I@Z ENDP	; ImDrawList::PrimWriteVtx
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?PrimWriteIdx@ImDrawList@@QEAAXG@Z
_TEXT	SEGMENT
this$ = 8
idx$ = 16
?PrimWriteIdx@ImDrawList@@QEAAXG@Z PROC			; ImDrawList::PrimWriteIdx, COMDAT

; 2839 :     inline    void  PrimWriteIdx(ImDrawIdx idx)                                     { *_IdxWritePtr = idx; _IdxWritePtr++; }

	mov	rax, QWORD PTR [rcx+80]
	mov	WORD PTR [rax], dx
	add	QWORD PTR [rcx+80], 2
	ret	0
?PrimWriteIdx@ImDrawList@@QEAAXG@Z ENDP			; ImDrawList::PrimWriteIdx
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??0ImFontAtlasCustomRect@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0ImFontAtlasCustomRect@@QEAA@XZ PROC			; ImFontAtlasCustomRect::ImFontAtlasCustomRect, COMDAT

; 2950 :     ImFontAtlasCustomRect()         { Width = Height = 0; X = Y = 0xFFFF; GlyphID = 0; GlyphAdvanceX = 0.0f; GlyphOffset = ImVec2(0, 0); Font = NULL; }

	xor	edx, edx
	mov	DWORD PTR [rcx+4], -1			; ffffffffH
	mov	DWORD PTR [rcx], edx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], rdx
	mov	QWORD PTR [rcx+24], rdx
	ret	0
??0ImFontAtlasCustomRect@@QEAA@XZ ENDP			; ImFontAtlasCustomRect::ImFontAtlasCustomRect
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?GetCustomRectByIndex@ImFontAtlas@@QEAAPEAUImFontAtlasCustomRect@@H@Z
_TEXT	SEGMENT
this$ = 8
index$ = 16
?GetCustomRectByIndex@ImFontAtlas@@QEAAPEAUImFontAtlasCustomRect@@H@Z PROC ; ImFontAtlas::GetCustomRectByIndex, COMDAT

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rax, edx
	shl	rax, 5
	add	rax, QWORD PTR [rcx+112]

; 3037 :     ImFontAtlasCustomRect*      GetCustomRectByIndex(int index) { IM_ASSERT(index >= 0); return &CustomRects[index]; }

	ret	0
?GetCustomRectByIndex@ImFontAtlas@@QEAAPEAUImFontAtlasCustomRect@@H@Z ENDP ; ImFontAtlas::GetCustomRectByIndex
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?ImQsort@@YAXPEAX_K1P6AHPEBX2@Z@Z
_TEXT	SEGMENT
base$ = 8
count$ = 16
size_of_element$dead$ = 24
compare_func$ = 32
?ImQsort@@YAXPEAX_K1P6AHPEBX2@Z@Z PROC			; ImQsort, COMDAT

; 349  : static inline void      ImQsort(void* base, size_t count, size_t size_of_element, int(IMGUI_CDECL *compare_func)(void const*, void const*)) { if (count > 1) qsort(base, count, size_of_element, compare_func); }

	cmp	rdx, 1
	jbe	SHORT $LN2@ImQsort
	mov	r8d, 24
	rex_jmp	QWORD PTR __imp_qsort
$LN2@ImQsort:
	ret	0
?ImQsort@@YAXPEAX_K1P6AHPEBX2@Z@Z ENDP			; ImQsort
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?ImUpperPowerOfTwo@@YAHH@Z
_TEXT	SEGMENT
v$ = 8
?ImUpperPowerOfTwo@@YAHH@Z PROC				; ImUpperPowerOfTwo, COMDAT

; 358  : static inline int       ImUpperPowerOfTwo(int v)        { v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++; return v; }

	dec	ecx
	mov	eax, ecx
	sar	eax, 1
	or	ecx, eax
	mov	eax, ecx
	sar	eax, 2
	or	ecx, eax
	mov	eax, ecx
	sar	eax, 4
	or	ecx, eax
	mov	eax, ecx
	sar	eax, 8
	or	ecx, eax
	mov	eax, ecx
	sar	eax, 16
	or	eax, ecx
	inc	eax
	ret	0
?ImUpperPowerOfTwo@@YAHH@Z ENDP				; ImUpperPowerOfTwo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?ImCharIsBlankA@@YA_ND@Z
_TEXT	SEGMENT
c$ = 8
?ImCharIsBlankA@@YA_ND@Z PROC				; ImCharIsBlankA, COMDAT

; 375  : static inline bool      ImCharIsBlankA(char c)          { return c == ' ' || c == '\t'; }

	cmp	cl, 32					; 00000020H
	je	SHORT $LN3@ImCharIsBl
	cmp	cl, 9
	je	SHORT $LN3@ImCharIsBl
	xor	al, al
	ret	0
$LN3@ImCharIsBl:
	mov	al, 1
	ret	0
?ImCharIsBlankA@@YA_ND@Z ENDP				; ImCharIsBlankA
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?ImCharIsBlankW@@YA_NI@Z
_TEXT	SEGMENT
c$ = 8
?ImCharIsBlankW@@YA_NI@Z PROC				; ImCharIsBlankW, COMDAT

; 376  : static inline bool      ImCharIsBlankW(unsigned int c)  { return c == ' ' || c == '\t' || c == 0x3000; }

	cmp	ecx, 32					; 00000020H
	je	SHORT $LN3@ImCharIsBl
	cmp	ecx, 9
	je	SHORT $LN3@ImCharIsBl
	cmp	ecx, 12288				; 00003000H
	je	SHORT $LN3@ImCharIsBl
	xor	al, al
	ret	0
$LN3@ImCharIsBl:
	mov	al, 1
	ret	0
?ImCharIsBlankW@@YA_NI@Z ENDP				; ImCharIsBlankW
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?ImAbs@@YAHH@Z
_TEXT	SEGMENT
x$ = 8
?ImAbs@@YAHH@Z PROC					; ImAbs, COMDAT

; 440  : static inline int    ImAbs(int x)               { return x < 0 ? -x : x; }

	mov	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx
	ret	0
?ImAbs@@YAHH@Z ENDP					; ImAbs
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?ImAbs@@YAMM@Z
_TEXT	SEGMENT
x$ = 8
?ImAbs@@YAMM@Z PROC					; ImAbs, COMDAT
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	andps	xmm0, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 441  : static inline float  ImAbs(float x)             { return fabsf(x); }

	ret	0
?ImAbs@@YAMM@Z ENDP					; ImAbs
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?ImRsqrt@@YAMM@Z
_TEXT	SEGMENT
x$ = 8
?ImRsqrt@@YAMM@Z PROC					; ImRsqrt, COMDAT

; 446  : static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

	rsqrtss	xmm0, xmm0
	ret	0
?ImRsqrt@@YAMM@Z ENDP					; ImRsqrt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?ImMin@@YA?AUImVec2@@AEBU1@0@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
lhs$ = 16
rhs$ = 24
?ImMin@@YA?AUImVec2@@AEBU1@0@Z PROC			; ImMin, COMDAT

; 462  : static inline ImVec2 ImMin(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x < rhs.x ? lhs.x : rhs.x, lhs.y < rhs.y ? lhs.y : rhs.y); }

	movss	xmm0, DWORD PTR [rdx]
	mov	rax, rcx
	movss	xmm1, DWORD PTR [rdx+4]
	minss	xmm0, DWORD PTR [r8]
	minss	xmm1, DWORD PTR [r8+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR [rcx], xmm0
	movss	DWORD PTR [rcx+4], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 462  : static inline ImVec2 ImMin(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x < rhs.x ? lhs.x : rhs.x, lhs.y < rhs.y ? lhs.y : rhs.y); }

	ret	0
?ImMin@@YA?AUImVec2@@AEBU1@0@Z ENDP			; ImMin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?ImMax@@YA?AUImVec2@@AEBU1@0@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
lhs$ = 16
rhs$ = 24
?ImMax@@YA?AUImVec2@@AEBU1@0@Z PROC			; ImMax, COMDAT

; 463  : static inline ImVec2 ImMax(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x >= rhs.x ? lhs.x : rhs.x, lhs.y >= rhs.y ? lhs.y : rhs.y); }

	movss	xmm0, DWORD PTR [rdx]
	mov	rax, rcx
	movss	xmm1, DWORD PTR [rdx+4]
	maxss	xmm0, DWORD PTR [r8]
	maxss	xmm1, DWORD PTR [r8+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR [rcx], xmm0
	movss	DWORD PTR [rcx+4], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 463  : static inline ImVec2 ImMax(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x >= rhs.x ? lhs.x : rhs.x, lhs.y >= rhs.y ? lhs.y : rhs.y); }

	ret	0
?ImMax@@YA?AUImVec2@@AEBU1@0@Z ENDP			; ImMax
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?ImClamp@@YA?AUImVec2@@AEBU1@0U1@@Z
_TEXT	SEGMENT
mx$ = 0
__$ReturnUdt$ = 32
v$ = 40
mn$ = 48
?ImClamp@@YA?AUImVec2@@AEBU1@0U1@@Z PROC		; ImClamp, COMDAT

; 464  : static inline ImVec2 ImClamp(const ImVec2& v, const ImVec2& mn, ImVec2 mx)      { return ImVec2((v.x < mn.x) ? mn.x : (v.x > mx.x) ? mx.x : v.x, (v.y < mn.y) ? mn.y : (v.y > mx.y) ? mx.y : v.y); }

	sub	rsp, 24
	movss	xmm0, DWORD PTR [rdx+4]
	movss	xmm1, DWORD PTR [r8+4]
	comiss	xmm1, xmm0
	mov	QWORD PTR mx$[rsp], r9
	ja	SHORT $LN6@ImClamp
	movss	xmm1, DWORD PTR mx$[rsp+4]
	minss	xmm1, xmm0
$LN6@ImClamp:
	movss	xmm2, DWORD PTR [rdx]
	movss	xmm0, DWORD PTR [r8]
	comiss	xmm0, xmm2
	ja	SHORT $LN10@ImClamp
	movss	xmm0, DWORD PTR mx$[rsp]
	minss	xmm0, xmm2
$LN10@ImClamp:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR [rcx], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 464  : static inline ImVec2 ImClamp(const ImVec2& v, const ImVec2& mn, ImVec2 mx)      { return ImVec2((v.x < mn.x) ? mn.x : (v.x > mx.x) ? mx.x : v.x, (v.y < mn.y) ? mn.y : (v.y > mx.y) ? mx.y : v.y); }

	mov	rax, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR [rcx+4], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 464  : static inline ImVec2 ImClamp(const ImVec2& v, const ImVec2& mn, ImVec2 mx)      { return ImVec2((v.x < mn.x) ? mn.x : (v.x > mx.x) ? mx.x : v.x, (v.y < mn.y) ? mn.y : (v.y > mx.y) ? mx.y : v.y); }

	add	rsp, 24
	ret	0
?ImClamp@@YA?AUImVec2@@AEBU1@0U1@@Z ENDP		; ImClamp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?ImLerp@@YA?AUImVec4@@AEBU1@0M@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
a$ = 16
b$ = 24
t$ = 32
?ImLerp@@YA?AUImVec4@@AEBU1@0M@Z PROC			; ImLerp, COMDAT

; 467  : static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t)          { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }

	movups	xmm1, XMMWORD PTR [rdx]
	mov	rax, rcx
	movups	xmm2, XMMWORD PTR [r8]
	movaps	xmm0, xmm3
	subps	xmm2, xmm1
	shufps	xmm0, xmm0, 0
	mulps	xmm2, xmm0
	addps	xmm2, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movups	XMMWORD PTR [rcx], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 467  : static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t)          { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }

	ret	0
?ImLerp@@YA?AUImVec4@@AEBU1@0M@Z ENDP			; ImLerp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?ImLengthSqr@@YAMAEBUImVec2@@@Z
_TEXT	SEGMENT
lhs$ = 8
?ImLengthSqr@@YAMAEBUImVec2@@@Z PROC			; ImLengthSqr, COMDAT

; 469  : static inline float  ImLengthSqr(const ImVec2& lhs)                             { return (lhs.x * lhs.x) + (lhs.y * lhs.y); }

	movss	xmm1, DWORD PTR [rcx+4]
	movss	xmm0, DWORD PTR [rcx]
	mulss	xmm0, xmm0
	mulss	xmm1, xmm1
	addss	xmm0, xmm1
	ret	0
?ImLengthSqr@@YAMAEBUImVec2@@@Z ENDP			; ImLengthSqr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?ImFloor@@YAMM@Z
_TEXT	SEGMENT
f$ = 8
?ImFloor@@YAMM@Z PROC					; ImFloor, COMDAT

; 472  : static inline float  ImFloor(float f)                                           { return (float)(int)(f); }

	cvttss2si eax, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	ret	0
?ImFloor@@YAMM@Z ENDP					; ImFloor
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?ImFloorSigned@@YAMM@Z
_TEXT	SEGMENT
f$ = 8
?ImFloorSigned@@YAMM@Z PROC				; ImFloorSigned, COMDAT

; 473  : static inline float  ImFloorSigned(float f)                                     { return (float)((f >= 0 || (float)(int)f == f) ? (int)f : (int)f - 1); } // Decent replacement for floorf()

	xorps	xmm1, xmm1
	comiss	xmm0, xmm1
	cvttss2si eax, xmm0
	jae	SHORT $LN5@ImFloorSig
	movd	xmm1, eax
	cvtdq2ps xmm1, xmm1
	ucomiss	xmm1, xmm0
	jp	SHORT $LN6@ImFloorSig
	je	SHORT $LN5@ImFloorSig
$LN6@ImFloorSig:
	dec	eax
$LN5@ImFloorSig:
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	ret	0
?ImFloorSigned@@YAMM@Z ENDP				; ImFloorSigned
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?ImDot@@YAMAEBUImVec2@@0@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
?ImDot@@YAMAEBUImVec2@@0@Z PROC				; ImDot, COMDAT

; 477  : static inline float  ImDot(const ImVec2& a, const ImVec2& b)                    { return a.x * b.x + a.y * b.y; }

	movss	xmm0, DWORD PTR [rcx+4]
	movss	xmm1, DWORD PTR [rcx]
	mulss	xmm0, DWORD PTR [rdx+4]
	mulss	xmm1, DWORD PTR [rdx]
	addss	xmm0, xmm1
	ret	0
?ImDot@@YAMAEBUImVec2@@0@Z ENDP				; ImDot
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?ImMul@@YA?AUImVec2@@AEBU1@0@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
lhs$ = 16
rhs$ = 24
?ImMul@@YA?AUImVec2@@AEBU1@0@Z PROC			; ImMul, COMDAT

; 480  : static inline ImVec2 ImMul(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }

	movss	xmm0, DWORD PTR [rdx]
	mov	rax, rcx
	movss	xmm1, DWORD PTR [rdx+4]
	mulss	xmm0, DWORD PTR [r8]
	mulss	xmm1, DWORD PTR [r8+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR [rcx], xmm0
	movss	DWORD PTR [rcx+4], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 480  : static inline ImVec2 ImMul(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }

	ret	0
?ImMul@@YA?AUImVec2@@AEBU1@0@Z ENDP			; ImMul
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?Create@ImBitVector@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
sz$ = 56
?Create@ImBitVector@@QEAAXH@Z PROC			; ImBitVector::Create, COMDAT

; 597  :     void            Create(int sz)              { Storage.resize((sz + 31) >> 5); memset(Storage.Data, 0, (size_t)Storage.Size * sizeof(Storage.Data[0])); }

$LN13:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	r8d, DWORD PTR [rcx+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 597  :     void            Create(int sz)              { Storage.resize((sz + 31) >> 5); memset(Storage.Data, 0, (size_t)Storage.Size * sizeof(Storage.Data[0])); }

	lea	ebx, DWORD PTR [rdx+31]
	sar	ebx, 5
	mov	rdi, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	cmp	ebx, r8d
	jle	SHORT $LN4@Create

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	r8d, r8d
	je	SHORT $LN8@Create
	mov	eax, r8d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r8d
	jmp	SHORT $LN9@Create
$LN8@Create:
	mov	eax, 8
$LN9@Create:
	cmp	eax, ebx
	mov	edx, ebx
	cmovg	edx, eax

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	call	?reserve@?$ImVector@I@@QEAAXH@Z		; ImVector<unsigned int>::reserve
$LN4@Create:
	mov	DWORD PTR [rdi], ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 597  :     void            Create(int sz)              { Storage.resize((sz + 31) >> 5); memset(Storage.Data, 0, (size_t)Storage.Size * sizeof(Storage.Data[0])); }

	xor	edx, edx
	mov	rcx, QWORD PTR [rdi+8]
	movsxd	r8, ebx
	shl	r8, 2
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	jmp	memset
?Create@ImBitVector@@QEAAXH@Z ENDP			; ImBitVector::Create
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?Clear@ImBitVector@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?Clear@ImBitVector@@QEAAXXZ PROC			; ImBitVector::Clear, COMDAT

; 598  :     void            Clear()                     { Storage.clear(); }

$LN17:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN4@Clear
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN8@Clear

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN8@Clear:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx+8], 0
$LN4@Clear:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 598  :     void            Clear()                     { Storage.clear(); }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?Clear@ImBitVector@@QEAAXXZ ENDP			; ImBitVector::Clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?TestBit@ImBitVector@@QEBA_NH@Z
_TEXT	SEGMENT
this$ = 8
n$ = 16
?TestBit@ImBitVector@@QEBA_NH@Z PROC			; ImBitVector::TestBit, COMDAT

; 599  :     bool            TestBit(int n) const        { IM_ASSERT(n < (Storage.Size << 5)); return IM_BITARRAY_TESTBIT(Storage.Data, n); }

	mov	rax, QWORD PTR [rcx+8]
	movsxd	r8, edx
	and	edx, 31
	sar	r8, 5
	mov	eax, DWORD PTR [rax+r8*4]
	bt	eax, edx
	setb	al
	ret	0
?TestBit@ImBitVector@@QEBA_NH@Z ENDP			; ImBitVector::TestBit
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?SetBit@ImBitVector@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 8
n$ = 16
?SetBit@ImBitVector@@QEAAXH@Z PROC			; ImBitVector::SetBit, COMDAT

; 600  :     void            SetBit(int n)               { IM_ASSERT(n < (Storage.Size << 5)); ImBitArraySetBit(Storage.Data, n); }

	mov	r8, QWORD PTR [rcx+8]

; 560  : inline void     ImBitArraySetBit(ImU32* arr, int n)             { ImU32 mask = (ImU32)1 << (n & 31); arr[n >> 5] |= mask; }

	movsxd	rax, edx
	and	edx, 31
	sar	rax, 5
	lea	rcx, QWORD PTR [r8+rax*4]
	mov	eax, DWORD PTR [r8+rax*4]
	bts	eax, edx
	mov	DWORD PTR [rcx], eax

; 600  :     void            SetBit(int n)               { IM_ASSERT(n < (Storage.Size << 5)); ImBitArraySetBit(Storage.Data, n); }

	ret	0
?SetBit@ImBitVector@@QEAAXH@Z ENDP			; ImBitVector::SetBit
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_rectpack.h
;	COMDAT stbrp_setup_allow_out_of_mem
_TEXT	SEGMENT
context$ = 8
allow_out_of_mem$dead$ = 16
stbrp_setup_allow_out_of_mem PROC			; COMDAT

; 247  :    if (allow_out_of_mem)
; 248  :       // if it's ok to run out of memory, then don't bother aligning them;
; 249  :       // this gives better packing, but may fail due to OOM (even though
; 250  :       // the rectangles easily fit). @TODO a smarter approach would be to only
; 251  :       // quantize once we've hit OOM, then we could get rid of this parameter.
; 252  :       context->align = 1;
; 253  :    else {
; 254  :       // if it's not ok to run out of memory, then quantize the widths
; 255  :       // so that num_nodes is always enough nodes.
; 256  :       //
; 257  :       // I.e. num_nodes * align >= width
; 258  :       //                  align >= width / num_nodes
; 259  :       //                  align = ceil(width/num_nodes)
; 260  : 
; 261  :       context->align = (context->width + context->num_nodes-1) / context->num_nodes;

	mov	eax, DWORD PTR [rcx]
	dec	eax
	add	eax, DWORD PTR [rcx+20]
	cdq
	idiv	DWORD PTR [rcx+20]

; 262  :    }
; 263  : }

	mov	DWORD PTR [rcx+8], eax
	ret	0
stbrp_setup_allow_out_of_mem ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_rectpack.h
;	COMDAT stbrp_init_target
_TEXT	SEGMENT
context$ = 48
width$ = 56
height$ = 64
nodes$ = 72
num_nodes$ = 80
stbrp_init_target PROC					; COMDAT

; 266  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 267  :    int i;
; 268  : 
; 269  :    for (i=0; i < num_nodes-1; ++i)

	mov	edi, DWORD PTR num_nodes$[rsp]
	xor	r14d, r14d
	mov	r10, rcx
	movq	xmm4, r9
	mov	ebp, r8d
	punpcklqdq xmm4, xmm4
	mov	esi, edx
	mov	r11d, r14d
	lea	ecx, DWORD PTR [rdi-1]
	test	ecx, ecx
	jle	$LN13@stbrp_init
	cmp	ecx, 4
	jb	$LN13@stbrp_init
	cmp	DWORD PTR __isa_available, 2
	jl	$LN13@stbrp_init

; 270  :       nodes[i].next = &nodes[i+1];

	mov	eax, ecx
	movaps	XMMWORD PTR [rsp+16], xmm6
	movaps	XMMWORD PTR [rsp], xmm7
	movdqa	xmm7, XMMWORD PTR __xmm@00000003000000020000000100000000
	and	eax, -2147483645			; ffffffff80000003H
	jge	SHORT $LN19@stbrp_init
	dec	eax
	or	eax, -4
	inc	eax
$LN19@stbrp_init:

; 267  :    int i;
; 268  : 
; 269  :    for (i=0; i < num_nodes-1; ++i)

	movdqa	xmm5, XMMWORD PTR __xmm@00000001000000010000000100000001
	lea	rdx, QWORD PTR [r9+40]

; 270  :       nodes[i].next = &nodes[i+1];

	mov	r8d, ecx
	sub	r8d, eax
	mov	eax, 4
	movd	xmm6, eax
$LL4@stbrp_init:
	movd	xmm1, r11d
	lea	eax, DWORD PTR [r11+2]
	pshufd	xmm1, xmm1, 0
	lea	rdx, QWORD PTR [rdx+64]
	movq	xmm3, xmm7
	movq	xmm0, xmm5
	paddd	xmm1, xmm3
	add	r11d, 4
	paddd	xmm1, xmm0
	movq	xmm0, xmm5
	pmovsxdq xmm2, xmm1
	movd	xmm1, eax
	pshufd	xmm1, xmm1, 0
	paddd	xmm1, xmm3
	paddd	xmm1, xmm0
	psllq	xmm2, xmm6
	paddq	xmm2, xmm4
	movq	QWORD PTR [rdx-96], xmm2
	psrldq	xmm2, 8
	movq	QWORD PTR [rdx-80], xmm2
	pmovsxdq xmm2, xmm1
	psllq	xmm2, xmm6
	paddq	xmm2, xmm4
	movq	QWORD PTR [rdx-64], xmm2
	psrldq	xmm2, 8
	movq	QWORD PTR [rdx-48], xmm2
	cmp	r11d, r8d
	jl	SHORT $LL4@stbrp_init

; 267  :    int i;
; 268  : 
; 269  :    for (i=0; i < num_nodes-1; ++i)

	movaps	xmm7, XMMWORD PTR [rsp]
	movaps	xmm6, XMMWORD PTR [rsp+16]
$LN13@stbrp_init:
	movsxd	rbx, r11d
	movsxd	r8, ecx
	cmp	rbx, r8
	jge	SHORT $LN3@stbrp_init
	mov	rax, rbx
	lea	edx, DWORD PTR [r11+1]
	shl	rax, 4
	sub	r8, rbx
	add	rax, 8
	add	rax, r9
	add	r11d, r8d
	npad	10
$LL12@stbrp_init:

; 270  :       nodes[i].next = &nodes[i+1];

	movsxd	rcx, edx
	lea	rax, QWORD PTR [rax+16]
	shl	rcx, 4
	inc	edx
	add	rcx, r9
	mov	QWORD PTR [rax-16], rcx
	sub	r8, 1
	jne	SHORT $LL12@stbrp_init
$LN3@stbrp_init:

; 286  :    context->extra[1].y = (1<<30);
; 287  :    context->extra[1].next = NULL;
; 288  : }

	mov	rbx, QWORD PTR [rsp+48]
	lea	rcx, QWORD PTR [r10+40]
	movsxd	rax, r11d
	add	rax, rax
	mov	QWORD PTR [r9+rax*8+8], r14

; 261  :       context->align = (context->width + context->num_nodes-1) / context->num_nodes;

	lea	eax, DWORD PTR [rdi-1]

; 271  :    nodes[i].next = NULL;
; 272  :    context->init_mode = STBRP__INIT_skyline;
; 273  :    context->heuristic = STBRP_HEURISTIC_Skyline_default;
; 274  :    context->free_head = &nodes[0];
; 275  :    context->active_head = &context->extra[0];
; 276  :    context->width = width;

	mov	DWORD PTR [r10], esi

; 261  :       context->align = (context->width + context->num_nodes-1) / context->num_nodes;

	add	eax, esi

; 277  :    context->height = height;

	mov	DWORD PTR [r10+4], ebp

; 261  :       context->align = (context->width + context->num_nodes-1) / context->num_nodes;

	cdq

; 286  :    context->extra[1].y = (1<<30);
; 287  :    context->extra[1].next = NULL;
; 288  : }

	mov	rbp, QWORD PTR [rsp+56]
	mov	DWORD PTR [r10+20], edi
	mov	QWORD PTR [r10+12], 1
	mov	QWORD PTR [r10+32], r9
	mov	QWORD PTR [r10+24], rcx

; 261  :       context->align = (context->width + context->num_nodes-1) / context->num_nodes;

	idiv	edi

; 286  :    context->extra[1].y = (1<<30);
; 287  :    context->extra[1].next = NULL;
; 288  : }

	mov	rdi, QWORD PTR [rsp+72]

; 261  :       context->align = (context->width + context->num_nodes-1) / context->num_nodes;

	mov	DWORD PTR [r10+8], eax

; 278  :    context->num_nodes = num_nodes;
; 279  :    stbrp_setup_allow_out_of_mem(context, 0);
; 280  : 
; 281  :    // node 0 is the full width, node 1 is the sentinel (lets us not store width explicitly)
; 282  :    context->extra[0].x = 0;
; 283  :    context->extra[0].y = 0;
; 284  :    context->extra[0].next = &context->extra[1];

	lea	rax, QWORD PTR [r10+56]

; 285  :    context->extra[1].x = (stbrp_coord) width;

	mov	DWORD PTR [rax], esi

; 286  :    context->extra[1].y = (1<<30);
; 287  :    context->extra[1].next = NULL;
; 288  : }

	mov	rsi, QWORD PTR [rsp+64]
	mov	DWORD PTR [rcx], r14d
	mov	DWORD PTR [r10+44], r14d
	mov	QWORD PTR [r10+48], rax
	mov	DWORD PTR [r10+60], 1073741824		; 40000000H
	mov	QWORD PTR [r10+64], r14
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
stbrp_init_target ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_rectpack.h
;	COMDAT ?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z
_TEXT	SEGMENT
c$dead$ = 24
first$ = 32
x0$ = 40
width$ = 48
pwaste$ = 56
?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z PROC ; stbrp__skyline_find_min_y, COMDAT

; 292  : {

	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	push	r15

; 293  :    stbrp_node *node = first;
; 294  :    int x1 = x0 + width;
; 295  :    int min_y, visited_width, waste_area;
; 296  : 
; 297  :    STBRP__NOTUSED(c);
; 298  : 
; 299  :    STBRP_ASSERT(first->x <= x0);
; 300  : 
; 301  :    #if 0
; 302  :    // skip in case we're past the node
; 303  :    while (node->next->x <= x0)
; 304  :       ++node;
; 305  :    #else
; 306  :    STBRP_ASSERT(node->next->x > x0); // we ended up handling this in the caller for efficiency
; 307  :    #endif
; 308  : 
; 309  :    STBRP_ASSERT(node->x <= x0);
; 310  : 
; 311  :    min_y = 0;

	xor	edi, edi
	lea	ebp, DWORD PTR [r8+r9]
	mov	r15d, r9d
	mov	r14d, r8d

; 312  :    waste_area = 0;

	mov	esi, edi

; 313  :    visited_width = 0;

	mov	r10d, edi

; 314  :    while (node->x < x1) {

	cmp	DWORD PTR [rdx], ebp
	jge	SHORT $LN23@stbrp__sky
	mov	QWORD PTR [rsp+24], rbx
	npad	3
$LL11@stbrp__sky:

; 315  :       if (node->y > min_y) {

	mov	ebx, DWORD PTR [rdx+4]
	cmp	ebx, edi
	jle	SHORT $LN13@stbrp__sky

; 316  :          // raise min_y higher.
; 317  :          // we've accounted for all waste up to min_y,
; 318  :          // but we'll now add more waste for everything we've visted
; 319  :          waste_area += visited_width * (node->y - min_y);
; 320  :          min_y = node->y;
; 321  :          // the first time through, visited_width might be reduced
; 322  :          if (node->x < x0)

	mov	r8d, DWORD PTR [rdx]
	mov	ecx, ebx
	mov	rdx, QWORD PTR [rdx+8]
	sub	ecx, edi
	imul	ecx, r10d
	mov	edi, ebx
	mov	r11d, DWORD PTR [rdx]
	mov	eax, r11d
	cmp	r8d, r14d
	jge	SHORT $LN15@stbrp__sky

; 323  :             visited_width += node->next->x - x0;

	sub	eax, r14d
	add	r10d, eax
	jmp	SHORT $LN14@stbrp__sky
$LN15@stbrp__sky:

; 324  :          else
; 325  :             visited_width += node->next->x - node->x;

	sub	eax, r8d
	add	r10d, eax

; 326  :       } else {

	jmp	SHORT $LN14@stbrp__sky
$LN13@stbrp__sky:

; 327  :          // add waste area
; 328  :          int under_width = node->next->x - node->x;

	mov	r9, QWORD PTR [rdx+8]

; 329  :          if (under_width + visited_width > width)
; 330  :             under_width = width - visited_width;
; 331  :          waste_area += under_width * (min_y - node->y);

	mov	r8d, r15d
	sub	r8d, r10d
	mov	r11d, DWORD PTR [r9]
	mov	ecx, r11d
	sub	ecx, DWORD PTR [rdx]

; 332  :          visited_width += under_width;

	mov	rdx, r9
	lea	eax, DWORD PTR [rcx+r10]
	cmp	eax, r15d
	cmovle	r8d, ecx
	mov	ecx, edi
	sub	ecx, ebx
	add	r10d, r8d
	imul	ecx, r8d
$LN14@stbrp__sky:

; 333  :       }
; 334  :       node = node->next;

	add	esi, ecx
	cmp	r11d, ebp
	jl	SHORT $LL11@stbrp__sky

; 335  :    }
; 336  : 
; 337  :    *pwaste = waste_area;

	mov	rcx, QWORD PTR pwaste$[rsp]
	mov	rbx, QWORD PTR [rsp+24]
	mov	DWORD PTR [rcx], esi
	jmp	SHORT $LN28@stbrp__sky
$LN23@stbrp__sky:
	mov	rax, QWORD PTR pwaste$[rsp]
	mov	DWORD PTR [rax], edi
$LN28@stbrp__sky:

; 338  :    return min_y;
; 339  : }

	mov	rbp, QWORD PTR [rsp+32]
	mov	eax, edi
	mov	rdi, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+40]
	pop	r15
	pop	r14
	ret	0
?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z ENDP ; stbrp__skyline_find_min_y
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_rectpack.h
;	COMDAT ?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z
_TEXT	SEGMENT
tv461 = 48
best$1$ = 56
waste$1 = 56
tv465 = 64
waste$2 = 64
tv468 = 72
tail$1$ = 80
prev$2$ = 88
$T3 = 96
__$ReturnAddress$ = 192
width$2$ = 200
c$ = 200
tv455 = 208
best_waste$1$ = 208
width$ = 208
height$ = 216
?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z PROC ; stbrp__skyline_find_best_pos, COMDAT

; 348  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	push	rbp
	push	rdi
	push	r12
	sub	rsp, 152				; 00000098H

; 349  :    int best_waste = (1<<30), best_x, best_y = (1 << 30);
; 350  :    stbrp__findresult fr;
; 351  :    stbrp_node **prev, *node, *tail, **best = NULL;
; 352  : 
; 353  :    // align to multiple of c->align
; 354  :    width = (width + c->align - 1);

	dec	r8d
	mov	r11, rdx
	add	r8d, DWORD PTR [rdx+8]
	mov	rbx, rcx

; 355  :    width -= width % c->align;

	mov	eax, r8d
	mov	ecx, 1073741824				; 40000000H
	cdq
	mov	DWORD PTR best_waste$1$[rsp], ecx
	idiv	DWORD PTR [r11+8]

; 356  :    STBRP_ASSERT(width % c->align == 0);
; 357  : 
; 358  :    // if it can't possibly fit, bail immediately
; 359  :    if (width > c->width || height > c->height) {

	mov	ebp, DWORD PTR [r11]
	mov	edi, r9d
	xor	r9d, r9d
	sub	r8d, edx
	mov	QWORD PTR tv468[rsp], r9
	mov	r12d, ecx
	mov	DWORD PTR width$2$[rsp], r8d
	mov	ecx, r9d
	mov	QWORD PTR best$1$[rsp], rcx
	cmp	r8d, ebp
	jg	$LN20@stbrp__sky
	mov	eax, DWORD PTR [r11+4]
	mov	DWORD PTR tv461[rsp], eax
	cmp	edi, eax
	jg	$LN20@stbrp__sky
	mov	QWORD PTR [rsp+136], r13

; 363  :    }
; 364  : 
; 365  :    node = c->active_head;

	lea	r13, QWORD PTR [r11+24]
	mov	QWORD PTR [rsp+128], r14

; 366  :    prev = &c->active_head;

	mov	rbx, r13
	mov	QWORD PTR [rsp+120], r15

; 367  :    while (node->x + width <= c->width) {

	lea	r14, QWORD PTR [r11+16]
	mov	r15, QWORD PTR [r13]
	mov	QWORD PTR [rsp+144], rsi
	mov	rdi, r15
	mov	QWORD PTR prev$2$[rsp], r13
	mov	QWORD PTR tail$1$[rsp], r15
	mov	edx, DWORD PTR [r15]
	mov	DWORD PTR tv465[rsp], edx
	lea	eax, DWORD PTR [rdx+r8]
	cmp	eax, ebp
	jg	$LN51@stbrp__sky

; 370  :       if (c->heuristic == STBRP_HEURISTIC_Skyline_BL_sortHeight) { // actually just want to test BL

	mov	eax, DWORD PTR [r14]

; 377  :          // best-fit
; 378  :          if (y + height <= c->height) {

	mov	ecx, edx
	mov	QWORD PTR $T3[rsp], r14
	mov	r13d, r8d
	mov	DWORD PTR tv455[rsp], eax
	mov	r14d, r9d
	mov	r15d, r12d
	npad	6
$LL5@stbrp__sky:

; 368  :       int y,waste;
; 369  :       y = stbrp__skyline_find_min_y(c, node, node->x, width, &waste);

	lea	rax, QWORD PTR waste$1[rsp]
	mov	r9d, r13d
	mov	r8d, ecx
	mov	QWORD PTR [rsp+32], rax
	mov	rdx, rdi
	mov	esi, r12d
	call	?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z ; stbrp__skyline_find_min_y

; 370  :       if (c->heuristic == STBRP_HEURISTIC_Skyline_BL_sortHeight) { // actually just want to test BL

	cmp	DWORD PTR tv455[rsp], 0
	mov	ecx, eax
	jne	SHORT $LN21@stbrp__sky

; 371  :          // bottom left
; 372  :          if (y < best_y) {

	cmp	eax, r12d
	cmovl	r12d, eax

; 373  :             best_y = y;
; 374  :             best = prev;
; 375  :          }
; 376  :       } else {

	cmp	eax, esi
	cmovge	rbx, r14
	jmp	SHORT $LN77@stbrp__sky
$LN21@stbrp__sky:

; 377  :          // best-fit
; 378  :          if (y + height <= c->height) {

	mov	eax, DWORD PTR height$[rsp]
	add	eax, ecx
	cmp	eax, DWORD PTR tv461[rsp]
	jg	SHORT $LN25@stbrp__sky

; 379  :             // can only use it if it first vertically
; 380  :             if (y < best_y || (y == best_y && waste < best_waste)) {

	mov	eax, DWORD PTR waste$1[rsp]
	cmp	ecx, r12d
	jl	SHORT $LN26@stbrp__sky
	jne	SHORT $LN25@stbrp__sky
	cmp	eax, r15d
	jge	SHORT $LN25@stbrp__sky
$LN26@stbrp__sky:

; 381  :                best_y = y;

	mov	r12d, ecx

; 382  :                best_waste = waste;

	mov	r15d, eax
$LN77@stbrp__sky:

; 383  :                best = prev;
; 384  :             }
; 385  :          }
; 386  :       }
; 387  :       prev = &node->next;

	mov	r14, rbx
$LN25@stbrp__sky:
	lea	rbx, QWORD PTR [rdi+8]

; 388  :       node = node->next;

	mov	rdi, QWORD PTR [rdi+8]
	mov	ecx, DWORD PTR [rdi]
	lea	eax, DWORD PTR [rcx+r13]
	cmp	eax, ebp
	jle	SHORT $LL5@stbrp__sky

; 389  :    }
; 390  : 
; 391  :    best_x = (best == NULL) ? 0 : (*best)->x;

	mov	r13, QWORD PTR prev$2$[rsp]
	test	r14, r14
	mov	QWORD PTR best$1$[rsp], r14
	mov	r14, QWORD PTR $T3[rsp]
	mov	rcx, QWORD PTR best$1$[rsp]
	mov	DWORD PTR best_waste$1$[rsp], r15d
	mov	r15, QWORD PTR tail$1$[rsp]
	je	SHORT $LN56@stbrp__sky
	mov	rax, QWORD PTR [rcx]
	mov	r9d, DWORD PTR [rax]
	mov	QWORD PTR tv468[rsp], r9
	jmp	SHORT $LN51@stbrp__sky
$LN56@stbrp__sky:
	xor	r9d, r9d
$LN51@stbrp__sky:

; 392  : 
; 393  :    // if doing best-fit (BF), we also have to try aligning right edge to each node position
; 394  :    //
; 395  :    // e.g, if fitting
; 396  :    //
; 397  :    //     ____________________
; 398  :    //    |____________________|
; 399  :    //
; 400  :    //            into
; 401  :    //
; 402  :    //   |                         |
; 403  :    //   |             ____________|
; 404  :    //   |____________|
; 405  :    //
; 406  :    // then right-aligned reduces waste, but bottom-left BL is always chooses left-aligned
; 407  :    //
; 408  :    // This makes BF take about 2x the time
; 409  : 
; 410  :    if (c->heuristic == STBRP_HEURISTIC_Skyline_BF_sortHeight) {

	cmp	DWORD PTR [r14], 1
	jne	$LN10@stbrp__sky

; 411  :       tail = c->active_head;
; 412  :       node = c->active_head;
; 413  :       prev = &c->active_head;
; 414  :       // find first node that's admissible
; 415  :       while (tail->x < width)

	mov	eax, DWORD PTR width$2$[rsp]
	mov	r14, r15
	cmp	DWORD PTR tv465[rsp], eax
	jge	SHORT $LN37@stbrp__sky
$LL7@stbrp__sky:

; 416  :          tail = tail->next;

	mov	r15, QWORD PTR [r15+8]
	cmp	DWORD PTR [r15], eax
	jl	SHORT $LL7@stbrp__sky
$LN37@stbrp__sky:

; 417  :       while (tail) {

	test	r15, r15
	je	$LN10@stbrp__sky
	mov	rsi, QWORD PTR [r14+8]
	lea	rdi, QWORD PTR [r14+8]
	mov	ebp, DWORD PTR [rsi]
	npad	4
$LL9@stbrp__sky:

; 418  :          int xpos = tail->x - width;

	mov	ebx, DWORD PTR [r15]
	sub	ebx, eax

; 419  :          int y,waste;
; 420  :          STBRP_ASSERT(xpos >= 0);
; 421  :          // find the left position that matches this
; 422  :          while (node->next->x <= xpos) {

	cmp	ebp, ebx
	jg	SHORT $LN18@stbrp__sky
	npad	7
$LL14@stbrp__sky:

; 423  :             prev = &node->next;

	mov	r13, rdi

; 424  :             node = node->next;

	mov	r14, rsi
	lea	rdi, QWORD PTR [rsi+8]
	mov	rsi, QWORD PTR [rsi+8]
	mov	ebp, DWORD PTR [rsi]
	cmp	ebp, ebx
	jle	SHORT $LL14@stbrp__sky
$LN18@stbrp__sky:

; 425  :          }
; 426  :          STBRP_ASSERT(node->next->x > xpos && node->x <= xpos);
; 427  :          y = stbrp__skyline_find_min_y(c, node, xpos, width, &waste);

	lea	rcx, QWORD PTR waste$2[rsp]
	mov	r9d, eax
	mov	r8d, ebx
	mov	QWORD PTR [rsp+32], rcx
	mov	rdx, r14
	call	?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z ; stbrp__skyline_find_min_y

; 428  :          if (y + height <= c->height) {

	mov	ecx, DWORD PTR height$[rsp]
	add	ecx, eax
	cmp	ecx, DWORD PTR tv461[rsp]
	jg	SHORT $LN54@stbrp__sky

; 429  :             if (y <= best_y) {

	cmp	eax, r12d
	jg	SHORT $LN54@stbrp__sky

; 430  :                if (y < best_y || waste < best_waste || (waste==best_waste && xpos < best_x)) {

	mov	ecx, DWORD PTR waste$2[rsp]
	jl	SHORT $LN31@stbrp__sky
	cmp	ecx, DWORD PTR best_waste$1$[rsp]
	jl	SHORT $LN31@stbrp__sky
	mov	r9, QWORD PTR tv468[rsp]
	jne	SHORT $LN57@stbrp__sky
	cmp	ebx, r9d
	jge	SHORT $LN57@stbrp__sky
$LN31@stbrp__sky:

; 431  :                   best_x = xpos;
; 432  :                   //STBRP_ASSERT(y <= best_y); [DEAR IMGUI]
; 433  :                   best_y = y;
; 434  :                   best_waste = waste;

	mov	DWORD PTR best_waste$1$[rsp], ecx
	mov	r9d, ebx

; 435  :                   best = prev;

	mov	rcx, r13
	mov	QWORD PTR tv468[rsp], r9
	mov	QWORD PTR best$1$[rsp], rcx
	mov	r12d, eax
	jmp	SHORT $LN30@stbrp__sky
$LN54@stbrp__sky:

; 436  :                }
; 437  :             }
; 438  :          }
; 439  :          tail = tail->next;

	mov	r9, QWORD PTR tv468[rsp]
$LN57@stbrp__sky:
	mov	rcx, QWORD PTR best$1$[rsp]
$LN30@stbrp__sky:
	mov	r15, QWORD PTR [r15+8]
	mov	eax, DWORD PTR width$2$[rsp]
	test	r15, r15
	jne	$LL9@stbrp__sky
$LN10@stbrp__sky:

; 440  :       }
; 441  :    }
; 442  : 
; 443  :    fr.prev_link = best;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]

; 444  :    fr.x = best_x;
; 445  :    fr.y = best_y;
; 446  :    return fr;

	mov	r15, QWORD PTR [rsp+120]
	mov	r14, QWORD PTR [rsp+128]
	mov	r13, QWORD PTR [rsp+136]
	mov	rsi, QWORD PTR [rsp+144]
	mov	QWORD PTR [rax+8], rcx
	mov	DWORD PTR [rax], r9d
	mov	DWORD PTR [rax+4], r12d

; 447  : }

	add	rsp, 152				; 00000098H
	pop	r12
	pop	rdi
	pop	rbp
	pop	rbx
	ret	0
$LN20@stbrp__sky:

; 360  :       fr.prev_link = NULL;

	mov	QWORD PTR [rbx+8], r9

; 361  :       fr.x = fr.y = 0;
; 362  :       return fr;

	mov	rax, rbx
	mov	QWORD PTR [rbx], r9

; 447  : }

	add	rsp, 152				; 00000098H
	pop	r12
	pop	rdi
	pop	rbp
	pop	rbx
	ret	0
?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z ENDP ; stbrp__skyline_find_best_pos
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_rectpack.h
;	COMDAT ?stbrp__skyline_pack_rectangle@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z
_TEXT	SEGMENT
$T1 = 32
__$ReturnAddress$ = 64
context$ = 72
width$ = 80
height$ = 88
?stbrp__skyline_pack_rectangle@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z PROC ; stbrp__skyline_pack_rectangle, COMDAT

; 450  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rcx
	mov	esi, r9d

; 451  :    // find best position according to heuristic
; 452  :    stbrp__findresult res = stbrp__skyline_find_best_pos(context, width, height);

	lea	rcx, QWORD PTR $T1[rsp]
	mov	ebp, r8d
	mov	rbx, rdx
	call	?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z ; stbrp__skyline_find_best_pos
	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR [rdi], xmm0

; 453  :    stbrp_node *node, *cur;
; 454  : 
; 455  :    // bail if:
; 456  :    //    1. it failed
; 457  :    //    2. the best node doesn't fit (we don't always check this)
; 458  :    //    3. we're out of memory
; 459  :    if (res.prev_link == NULL || res.y + height > context->height || context->free_head == NULL) {

	mov	rdx, QWORD PTR [rdi+8]
	test	rdx, rdx
	je	SHORT $LN5@stbrp__sky
	mov	ecx, DWORD PTR [rdi+4]
	add	ecx, esi
	cmp	ecx, DWORD PTR [rbx+4]
	jg	SHORT $LN5@stbrp__sky
	mov	r8, QWORD PTR [rbx+32]
	test	r8, r8
	je	SHORT $LN5@stbrp__sky

; 461  :       return res;
; 462  :    }
; 463  : 
; 464  :    // on success, create new node
; 465  :    node = context->free_head;

	mov	r10d, DWORD PTR [rdi]

; 466  :    node->x = (stbrp_coord) res.x;
; 467  :    node->y = (stbrp_coord) (res.y + height);
; 468  : 
; 469  :    context->free_head = node->next;

	mov	rax, QWORD PTR [r8+8]
	mov	DWORD PTR [r8], r10d
	mov	DWORD PTR [r8+4], ecx
	mov	QWORD PTR [rbx+32], rax

; 470  : 
; 471  :    // insert the new node into the right starting point, and
; 472  :    // let 'cur' point to the remaining nodes needing to be
; 473  :    // stiched back in
; 474  : 
; 475  :    cur = *res.prev_link;

	mov	rax, QWORD PTR [rdx]

; 476  :    if (cur->x < res.x) {

	cmp	DWORD PTR [rax], r10d
	jge	SHORT $LN6@stbrp__sky

; 477  :       // preserve the existing one, so start testing with the next one
; 478  :       stbrp_node *next = cur->next;

	lea	rcx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+8]

; 479  :       cur->next = node;

	mov	QWORD PTR [rcx], r8

; 480  :       cur = next;
; 481  :    } else {

	jmp	SHORT $LN10@stbrp__sky
$LN6@stbrp__sky:

; 482  :       *res.prev_link = node;

	mov	QWORD PTR [rdx], r8
$LN10@stbrp__sky:

; 483  :    }
; 484  : 
; 485  :    // from here, traverse cur and free the nodes, until we get to one
; 486  :    // that shouldn't be freed
; 487  :    while (cur->next && cur->next->x <= res.x + width) {

	mov	rdx, QWORD PTR [rax+8]
	test	rdx, rdx
	je	SHORT $LN14@stbrp__sky
	lea	r9d, DWORD PTR [r10+rbp]
$LL2@stbrp__sky:
	cmp	DWORD PTR [rdx], r9d
	jg	SHORT $LN14@stbrp__sky

; 488  :       stbrp_node *next = cur->next;
; 489  :       // move the current node to the free list
; 490  :       cur->next = context->free_head;

	mov	rcx, QWORD PTR [rbx+32]
	mov	QWORD PTR [rax+8], rcx

; 491  :       context->free_head = cur;

	mov	QWORD PTR [rbx+32], rax

; 492  :       cur = next;

	mov	rax, rdx
	mov	rdx, QWORD PTR [rdx+8]
	test	rdx, rdx
	jne	SHORT $LL2@stbrp__sky
$LN14@stbrp__sky:

; 493  :    }
; 494  : 
; 495  :    // stitch the list back in
; 496  :    node->next = cur;
; 497  : 
; 498  :    if (cur->x < res.x + width)

	lea	ecx, DWORD PTR [r10+rbp]
	mov	QWORD PTR [r8+8], rax
	cmp	DWORD PTR [rax], ecx
	jge	SHORT $LN8@stbrp__sky

; 499  :       cur->x = (stbrp_coord) (res.x + width);

	mov	DWORD PTR [rax], ecx

; 500  : 
; 501  : #ifdef _DEBUG
; 502  :    cur = context->active_head;
; 503  :    while (cur->x < context->width) {
; 504  :       STBRP_ASSERT(cur->x < cur->next->x);
; 505  :       cur = cur->next;
; 506  :    }
; 507  :    STBRP_ASSERT(cur->next == NULL);
; 508  : 
; 509  :    {
; 510  :       int count=0;
; 511  :       cur = context->active_head;
; 512  :       while (cur) {
; 513  :          cur = cur->next;
; 514  :          ++count;
; 515  :       }
; 516  :       cur = context->free_head;
; 517  :       while (cur) {
; 518  :          cur = cur->next;
; 519  :          ++count;
; 520  :       }
; 521  :       STBRP_ASSERT(count == context->num_nodes+2);
; 522  :    }
; 523  : #endif
; 524  : 
; 525  :    return res;

	jmp	SHORT $LN8@stbrp__sky
$LN5@stbrp__sky:

; 460  :       res.prev_link = NULL;

	mov	QWORD PTR [rdi+8], 0
$LN8@stbrp__sky:

; 526  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rax, rdi
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?stbrp__skyline_pack_rectangle@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z ENDP ; stbrp__skyline_pack_rectangle
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_rectpack.h
;	COMDAT ?rect_height_compare@@YAHPEBX0@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
?rect_height_compare@@YAHPEBX0@Z PROC			; rect_height_compare, COMDAT

; 530  :    const stbrp_rect *p = (const stbrp_rect *) a;
; 531  :    const stbrp_rect *q = (const stbrp_rect *) b;
; 532  :    if (p->h > q->h)

	mov	eax, DWORD PTR [rcx+8]
	cmp	eax, DWORD PTR [rdx+8]
	jg	SHORT $LN7@rect_heigh

; 533  :       return -1;
; 534  :    if (p->h < q->h)

	jge	SHORT $LN3@rect_heigh

; 535  :       return  1;

	mov	eax, 1

; 537  : }

	ret	0
$LN3@rect_heigh:

; 536  :    return (p->w > q->w) ? -1 : (p->w < q->w);

	mov	ecx, DWORD PTR [rcx+4]
	mov	edx, DWORD PTR [rdx+4]
	cmp	ecx, edx
	jle	SHORT $LN5@rect_heigh
$LN7@rect_heigh:

; 537  : }

	mov	eax, -1
	ret	0
$LN5@rect_heigh:

; 536  :    return (p->w > q->w) ? -1 : (p->w < q->w);

	xor	eax, eax
	cmp	ecx, edx
	setl	al

; 537  : }

	ret	0
?rect_height_compare@@YAHPEBX0@Z ENDP			; rect_height_compare
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_rectpack.h
;	COMDAT ?rect_original_order@@YAHPEBX0@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
?rect_original_order@@YAHPEBX0@Z PROC			; rect_original_order, COMDAT

; 541  :    const stbrp_rect *p = (const stbrp_rect *) a;
; 542  :    const stbrp_rect *q = (const stbrp_rect *) b;
; 543  :    return (p->was_packed < q->was_packed) ? -1 : (p->was_packed > q->was_packed);

	mov	r8d, DWORD PTR [rcx+20]
	mov	ecx, DWORD PTR [rdx+20]
	cmp	r8d, ecx
	jge	SHORT $LN3@rect_origi
	mov	eax, -1

; 544  : }

	ret	0
$LN3@rect_origi:

; 541  :    const stbrp_rect *p = (const stbrp_rect *) a;
; 542  :    const stbrp_rect *q = (const stbrp_rect *) b;
; 543  :    return (p->was_packed < q->was_packed) ? -1 : (p->was_packed > q->was_packed);

	xor	eax, eax
	cmp	r8d, ecx
	setg	al

; 544  : }

	ret	0
?rect_original_order@@YAHPEBX0@Z ENDP			; rect_original_order
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_rectpack.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_rectpack.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_rectpack.h
;	COMDAT stbrp_pack_rects
_TEXT	SEGMENT
$T1 = 32
context$ = 96
rects$ = 104
num_rects$ = 112
stbrp_pack_rects PROC					; COMDAT

; 547  : {

	push	r13
	push	r14
	push	r15
	sub	rsp, 64					; 00000040H

; 548  :    int i, all_rects_packed = 1;

	xor	eax, eax
	mov	QWORD PTR [rsp+56], rdi
	mov	r13, rdx
	mov	rdi, rcx
	lea	r15d, QWORD PTR [rax+1]

; 549  : 
; 550  :    // we use the 'was_packed' field internally to allow sorting/unsorting
; 551  :    for (i=0; i < num_rects; ++i) {

	test	r8d, r8d
	jle	SHORT $LN3@stbrp_pack
	lea	r9, QWORD PTR [rdx+20]
	npad	12
$LL4@stbrp_pack:

; 552  :       rects[i].was_packed = i;

	mov	DWORD PTR [r9], eax
	lea	r9, QWORD PTR [r9+24]
	inc	eax
	cmp	eax, r8d
	jl	SHORT $LL4@stbrp_pack
$LN3@stbrp_pack:

; 553  :    }
; 554  : 
; 555  :    // sort according to heuristic
; 556  :    STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_height_compare);

	movsxd	r14, r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 349  : static inline void      ImQsort(void* base, size_t count, size_t size_of_element, int(IMGUI_CDECL *compare_func)(void const*, void const*)) { if (count > 1) qsort(base, count, size_of_element, compare_func); }

	cmp	r14, r15
	jbe	SHORT $LN21@stbrp_pack
	lea	r9, OFFSET FLAT:?rect_height_compare@@YAHPEBX0@Z ; rect_height_compare
	mov	r8d, 24
	mov	rdx, r14
	mov	rcx, r13
	call	QWORD PTR __imp_qsort
$LN21@stbrp_pack:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_rectpack.h

; 558  :    for (i=0; i < num_rects; ++i) {

	test	r14, r14
	jle	$LN56@stbrp_pack
	mov	QWORD PTR [rsp+96], rbx
	lea	rbx, QWORD PTR [r13+16]
	mov	QWORD PTR [rsp+104], rbp
	mov	QWORD PTR [rsp+48], r12
	mov	r12, r14
	mov	QWORD PTR [rsp+112], rsi
$LL7@stbrp_pack:

; 559  :       if (rects[i].w == 0 || rects[i].h == 0) {

	mov	ebp, DWORD PTR [rbx-12]
	test	ebp, ebp
	je	$LN13@stbrp_pack
	mov	esi, DWORD PTR [rbx-8]
	test	esi, esi
	je	$LN13@stbrp_pack

; 452  :    stbrp__findresult res = stbrp__skyline_find_best_pos(context, width, height);

	mov	r9d, esi
	lea	rcx, QWORD PTR $T1[rsp]
	mov	r8d, ebp
	mov	rdx, rdi
	call	?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z ; stbrp__skyline_find_best_pos

; 453  :    stbrp_node *node, *cur;
; 454  : 
; 455  :    // bail if:
; 456  :    //    1. it failed
; 457  :    //    2. the best node doesn't fit (we don't always check this)
; 458  :    //    3. we're out of memory
; 459  :    if (res.prev_link == NULL || res.y + height > context->height || context->free_head == NULL) {

	mov	r11, QWORD PTR [rax+8]
	mov	rdx, QWORD PTR [rax]
	test	r11, r11
	je	SHORT $LN27@stbrp_pack
	mov	rcx, rdx
	shr	rcx, 32					; 00000020H
	add	ecx, esi
	cmp	ecx, DWORD PTR [rdi+4]
	jg	SHORT $LN27@stbrp_pack
	mov	r9, QWORD PTR [rdi+32]
	test	r9, r9
	je	SHORT $LN27@stbrp_pack

; 461  :       return res;
; 462  :    }
; 463  : 
; 464  :    // on success, create new node
; 465  :    node = context->free_head;
; 466  :    node->x = (stbrp_coord) res.x;
; 467  :    node->y = (stbrp_coord) (res.y + height);
; 468  : 
; 469  :    context->free_head = node->next;

	mov	rax, QWORD PTR [r9+8]
	mov	DWORD PTR [r9], edx
	mov	DWORD PTR [r9+4], ecx
	mov	QWORD PTR [rdi+32], rax

; 470  : 
; 471  :    // insert the new node into the right starting point, and
; 472  :    // let 'cur' point to the remaining nodes needing to be
; 473  :    // stiched back in
; 474  : 
; 475  :    cur = *res.prev_link;

	mov	rax, QWORD PTR [r11]

; 476  :    if (cur->x < res.x) {

	cmp	DWORD PTR [rax], edx
	jge	SHORT $LN28@stbrp_pack

; 477  :       // preserve the existing one, so start testing with the next one
; 478  :       stbrp_node *next = cur->next;

	lea	rcx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+8]

; 479  :       cur->next = node;

	mov	QWORD PTR [rcx], r9

; 480  :       cur = next;
; 481  :    } else {

	jmp	SHORT $LN37@stbrp_pack
$LN28@stbrp_pack:

; 482  :       *res.prev_link = node;

	mov	QWORD PTR [r11], r9
$LN37@stbrp_pack:

; 483  :    }
; 484  : 
; 485  :    // from here, traverse cur and free the nodes, until we get to one
; 486  :    // that shouldn't be freed
; 487  :    while (cur->next && cur->next->x <= res.x + width) {

	mov	r8, QWORD PTR [rax+8]
	test	r8, r8
	je	SHORT $LN58@stbrp_pack
	lea	r10d, DWORD PTR [rdx+rbp]
$LL24@stbrp_pack:
	cmp	DWORD PTR [r8], r10d
	jg	SHORT $LN58@stbrp_pack

; 488  :       stbrp_node *next = cur->next;
; 489  :       // move the current node to the free list
; 490  :       cur->next = context->free_head;

	mov	rcx, QWORD PTR [rdi+32]
	mov	QWORD PTR [rax+8], rcx

; 491  :       context->free_head = cur;

	mov	QWORD PTR [rdi+32], rax

; 492  :       cur = next;

	mov	rax, r8
	mov	r8, QWORD PTR [r8+8]
	test	r8, r8
	jne	SHORT $LL24@stbrp_pack
$LN58@stbrp_pack:

; 493  :    }
; 494  : 
; 495  :    // stitch the list back in
; 496  :    node->next = cur;
; 497  : 
; 498  :    if (cur->x < res.x + width)

	lea	ecx, DWORD PTR [rdx+rbp]
	mov	QWORD PTR [r9+8], rax
	cmp	DWORD PTR [rax], ecx
	jge	SHORT $LN23@stbrp_pack

; 499  :       cur->x = (stbrp_coord) (res.x + width);

	mov	DWORD PTR [rax], ecx

; 500  : 
; 501  : #ifdef _DEBUG
; 502  :    cur = context->active_head;
; 503  :    while (cur->x < context->width) {
; 504  :       STBRP_ASSERT(cur->x < cur->next->x);
; 505  :       cur = cur->next;
; 506  :    }
; 507  :    STBRP_ASSERT(cur->next == NULL);
; 508  : 
; 509  :    {
; 510  :       int count=0;
; 511  :       cur = context->active_head;
; 512  :       while (cur) {
; 513  :          cur = cur->next;
; 514  :          ++count;
; 515  :       }
; 516  :       cur = context->free_head;
; 517  :       while (cur) {
; 518  :          cur = cur->next;
; 519  :          ++count;
; 520  :       }
; 521  :       STBRP_ASSERT(count == context->num_nodes+2);
; 522  :    }
; 523  : #endif
; 524  : 
; 525  :    return res;

	jmp	SHORT $LN23@stbrp_pack
$LN27@stbrp_pack:

; 460  :       res.prev_link = NULL;

	xor	r11d, r11d
$LN23@stbrp_pack:

; 561  :       } else {
; 562  :          stbrp__findresult fr = stbrp__skyline_pack_rectangle(context, rects[i].w, rects[i].h);
; 563  :          if (fr.prev_link) {

	test	r11, r11
	je	SHORT $LN14@stbrp_pack

; 564  :             rects[i].x = (stbrp_coord) fr.x;

	mov	DWORD PTR [rbx-4], edx

; 565  :             rects[i].y = (stbrp_coord) fr.y;

	shr	rdx, 32					; 00000020H

; 566  :          } else {

	jmp	SHORT $LN5@stbrp_pack
$LN14@stbrp_pack:

; 567  :             rects[i].x = rects[i].y = STBRP__MAXVAL;

	mov	DWORD PTR [rbx-4], 2147483647		; 7fffffffH
	mov	edx, 2147483647				; 7fffffffH
	jmp	SHORT $LN5@stbrp_pack
$LN13@stbrp_pack:

; 560  :          rects[i].x = rects[i].y = 0;  // empty rect needs no space

	mov	DWORD PTR [rbx-4], 0
	xor	edx, edx
$LN5@stbrp_pack:

; 558  :    for (i=0; i < num_rects; ++i) {

	mov	DWORD PTR [rbx], edx
	add	rbx, 24
	sub	r12, r15
	jne	$LL7@stbrp_pack
	mov	r12, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+112]
	mov	rbp, QWORD PTR [rsp+104]
	mov	rbx, QWORD PTR [rsp+96]
$LN56@stbrp_pack:
	mov	rdi, QWORD PTR [rsp+56]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 349  : static inline void      ImQsort(void* base, size_t count, size_t size_of_element, int(IMGUI_CDECL *compare_func)(void const*, void const*)) { if (count > 1) qsort(base, count, size_of_element, compare_func); }

	cmp	r14, r15
	jbe	SHORT $LN33@stbrp_pack
	lea	r9, OFFSET FLAT:?rect_original_order@@YAHPEBX0@Z ; rect_original_order
	mov	r8d, 24
	mov	rdx, r14
	mov	rcx, r13
	call	QWORD PTR __imp_qsort
$LN33@stbrp_pack:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_rectpack.h

; 576  :    for (i=0; i < num_rects; ++i) {

	test	r14, r14
	jle	SHORT $LN57@stbrp_pack
	lea	rax, QWORD PTR [r13+16]
$LL43@stbrp_pack:

; 577  :       rects[i].was_packed = !(rects[i].x == STBRP__MAXVAL && rects[i].y == STBRP__MAXVAL);

	cmp	DWORD PTR [rax-4], 2147483647		; 7fffffffH
	jne	SHORT $LN44@stbrp_pack
	cmp	DWORD PTR [rax], 2147483647		; 7fffffffH
	jne	SHORT $LN44@stbrp_pack
	xor	edx, edx
	jmp	SHORT $LN45@stbrp_pack
$LN44@stbrp_pack:
	mov	edx, 1
$LN45@stbrp_pack:

; 576  :    for (i=0; i < num_rects; ++i) {

	xor	ecx, ecx

; 577  :       rects[i].was_packed = !(rects[i].x == STBRP__MAXVAL && rects[i].y == STBRP__MAXVAL);

	mov	DWORD PTR [rax+4], edx
	test	edx, edx
	cmovne	ecx, r15d
	add	rax, 24
	mov	r15d, ecx
	sub	r14, 1
	jne	SHORT $LL43@stbrp_pack
$LN57@stbrp_pack:

; 578  :       if (!rects[i].was_packed)
; 579  :          all_rects_packed = 0;
; 580  :    }
; 581  : 
; 582  :    // return the all_rects_packed status
; 583  :    return all_rects_packed;
; 584  : }

	mov	eax, r15d
	add	rsp, 64					; 00000040H
	pop	r15
	pop	r14
	pop	r13
	ret	0
stbrp_pack_rects ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z
_TEXT	SEGMENT
b$ = 8
?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z PROC		; stbtt__buf_get8, COMDAT

; 1140 :    if (b->cursor >= b->size)

	movsxd	r8, DWORD PTR [rcx+8]
	mov	rdx, rcx
	cmp	r8d, DWORD PTR [rcx+12]
	jl	SHORT $LN2@stbtt__buf

; 1141 :       return 0;

	xor	al, al

; 1143 : }

	ret	0
$LN2@stbtt__buf:

; 1142 :    return b->data[b->cursor++];

	mov	rax, QWORD PTR [rcx]
	lea	ecx, DWORD PTR [r8+1]
	movzx	eax, BYTE PTR [r8+rax]
	mov	DWORD PTR [rdx+8], ecx

; 1143 : }

	ret	0
?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z ENDP		; stbtt__buf_get8
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__buf_peek8@@YAEPEAUstbtt__buf@@@Z
_TEXT	SEGMENT
b$ = 8
?stbtt__buf_peek8@@YAEPEAUstbtt__buf@@@Z PROC		; stbtt__buf_peek8, COMDAT

; 1146 : {

	mov	rax, rcx

; 1147 :    if (b->cursor >= b->size)

	movsxd	rcx, DWORD PTR [rcx+8]
	cmp	ecx, DWORD PTR [rax+12]
	jl	SHORT $LN2@stbtt__buf

; 1148 :       return 0;

	xor	al, al

; 1150 : }

	ret	0
$LN2@stbtt__buf:

; 1149 :    return b->data[b->cursor];

	mov	rax, QWORD PTR [rax]
	movzx	eax, BYTE PTR [rcx+rax]

; 1150 : }

	ret	0
?stbtt__buf_peek8@@YAEPEAUstbtt__buf@@@Z ENDP		; stbtt__buf_peek8
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__buf_seek@@YAXPEAUstbtt__buf@@H@Z
_TEXT	SEGMENT
b$ = 8
o$ = 16
?stbtt__buf_seek@@YAXPEAUstbtt__buf@@H@Z PROC		; stbtt__buf_seek, COMDAT

; 1154 :    STBTT_assert(!(o > b->size || o < 0));
; 1155 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

	mov	eax, DWORD PTR [rcx+12]
	cmp	edx, eax
	jg	SHORT $LN6@stbtt__buf
	test	edx, edx
	js	SHORT $LN6@stbtt__buf
	mov	DWORD PTR [rcx+8], edx

; 1156 : }

	ret	0
$LN6@stbtt__buf:

; 1154 :    STBTT_assert(!(o > b->size || o < 0));
; 1155 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

	mov	DWORD PTR [rcx+8], eax

; 1156 : }

	ret	0
?stbtt__buf_seek@@YAXPEAUstbtt__buf@@H@Z ENDP		; stbtt__buf_seek
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__buf_skip@@YAXPEAUstbtt__buf@@H@Z
_TEXT	SEGMENT
b$ = 8
o$ = 16
?stbtt__buf_skip@@YAXPEAUstbtt__buf@@H@Z PROC		; stbtt__buf_skip, COMDAT

; 1160 :    stbtt__buf_seek(b, b->cursor + o);

	mov	r8d, DWORD PTR [rcx+8]

; 1155 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

	mov	eax, DWORD PTR [rcx+12]

; 1160 :    stbtt__buf_seek(b, b->cursor + o);

	add	r8d, edx

; 1155 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

	cmp	r8d, eax
	jg	SHORT $LN8@stbtt__buf
	test	r8d, r8d
	js	SHORT $LN8@stbtt__buf
	mov	DWORD PTR [rcx+8], r8d

; 1161 : }

	ret	0
$LN8@stbtt__buf:

; 1155 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

	mov	DWORD PTR [rcx+8], eax

; 1161 : }

	ret	0
?stbtt__buf_skip@@YAXPEAUstbtt__buf@@H@Z ENDP		; stbtt__buf_skip
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z
_TEXT	SEGMENT
b$ = 8
n$ = 16
?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z PROC		; stbtt__buf_get, COMDAT

; 1165 :    stbtt_uint32 v = 0;

	xor	r8d, r8d
	mov	r9, rcx

; 1166 :    int i;
; 1167 :    STBTT_assert(n >= 1 && n <= 4);
; 1168 :    for (i = 0; i < n; i++)

	test	edx, edx
	jle	SHORT $LN16@stbtt__buf

; 1140 :    if (b->cursor >= b->size)

	mov	r10d, DWORD PTR [rcx+12]
	mov	eax, DWORD PTR [rcx+8]
	mov	r11d, edx
$LL7@stbtt__buf:
	cmp	eax, r10d
	jl	SHORT $LN10@stbtt__buf

; 1141 :       return 0;

	xor	cl, cl
	jmp	SHORT $LN9@stbtt__buf
$LN10@stbtt__buf:

; 1142 :    return b->data[b->cursor++];

	mov	rcx, QWORD PTR [r9]
	movsxd	rdx, eax
	inc	eax
	movzx	ecx, BYTE PTR [rdx+rcx]
	mov	DWORD PTR [r9+8], eax
$LN9@stbtt__buf:

; 1169 :       v = (v << 8) | stbtt__buf_get8(b);

	shl	r8d, 8
	movzx	ecx, cl
	or	r8d, ecx
	sub	r11, 1
	jne	SHORT $LL7@stbtt__buf
$LN16@stbtt__buf:

; 1170 :    return v;
; 1171 : }

	mov	eax, r8d
	ret	0
?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z ENDP		; stbtt__buf_get
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__new_buf@@YA?AUstbtt__buf@@PEBX_K@Z
_TEXT	SEGMENT
__$ReturnAddress$ = 8
p$ = 16
size$ = 24
?stbtt__new_buf@@YA?AUstbtt__buf@@PEBX_K@Z PROC		; stbtt__new_buf, COMDAT

; 1175 :    stbtt__buf r;
; 1176 :    STBTT_assert(size < 0x40000000);
; 1177 :    r.data = (stbtt_uint8*) p;

	mov	QWORD PTR [rcx], rdx

; 1178 :    r.size = (int) size;
; 1179 :    r.cursor = 0;
; 1180 :    return r;

	mov	rax, rcx
	mov	DWORD PTR [rcx+12], r8d
	mov	DWORD PTR [rcx+8], 0

; 1181 : }

	ret	0
?stbtt__new_buf@@YA?AUstbtt__buf@@PEBX_K@Z ENDP		; stbtt__new_buf
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__buf_range@@YA?AUstbtt__buf@@PEBU1@HH@Z
_TEXT	SEGMENT
__$ReturnAddress$ = 8
b$ = 16
o$ = 24
s$ = 32
?stbtt__buf_range@@YA?AUstbtt__buf@@PEBU1@HH@Z PROC	; stbtt__buf_range, COMDAT

; 1188 :    stbtt__buf r = stbtt__new_buf(NULL, 0);

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax

; 1189 :    if (o < 0 || s < 0 || o > b->size || s > b->size - o) return r;

	test	r8d, r8d
	js	SHORT $LN3@stbtt__buf
	test	r9d, r9d
	js	SHORT $LN3@stbtt__buf
	mov	eax, DWORD PTR [rdx+12]
	cmp	r8d, eax
	jg	SHORT $LN3@stbtt__buf
	sub	eax, r8d
	cmp	r9d, eax
	jg	SHORT $LN3@stbtt__buf

; 1190 :    r.data = b->data + o;

	movsxd	rax, r8d
	add	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 1191 :    r.size = s;

	mov	DWORD PTR [rcx+12], r9d
$LN3@stbtt__buf:

; 1192 :    return r;
; 1193 : }

	mov	rax, rcx
	ret	0
?stbtt__buf_range@@YA?AUstbtt__buf@@PEBU1@HH@Z ENDP	; stbtt__buf_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z
_TEXT	SEGMENT
__$ReturnAddress$ = 16
b$ = 24
?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z PROC	; stbtt__cff_get_index, COMDAT

; 1196 : {

	push	rbx

; 1197 :    int count, start, offsize;
; 1198 :    start = b->cursor;

	movsxd	rbx, DWORD PTR [rdx+8]
	mov	r10, rdx

; 1140 :    if (b->cursor >= b->size)

	mov	r11d, DWORD PTR [rdx+12]

; 1196 : {

	mov	r9, rcx

; 1140 :    if (b->cursor >= b->size)

	cmp	ebx, r11d
	jl	SHORT $LN16@stbtt__cff

; 1141 :       return 0;

	xor	edx, edx
	mov	r8d, ebx
	xor	al, al
	jmp	SHORT $LN65@stbtt__cff
$LN16@stbtt__cff:

; 1142 :    return b->data[b->cursor++];

	mov	rax, QWORD PTR [rdx]
	lea	r8d, DWORD PTR [rbx+1]
	movzx	edx, BYTE PTR [rbx+rax]
	mov	DWORD PTR [r10+8], r8d
	cmp	r8d, r11d
	jl	SHORT $LN64@stbtt__cff

; 1141 :       return 0;

	xor	al, al
	jmp	SHORT $LN65@stbtt__cff
$LN64@stbtt__cff:

; 1142 :    return b->data[b->cursor++];

	movsxd	rcx, r8d
	inc	r8d
	movzx	eax, BYTE PTR [rcx+rax]
	mov	DWORD PTR [r10+8], r8d
$LN65@stbtt__cff:

; 1169 :       v = (v << 8) | stbtt__buf_get8(b);

	shl	edx, 8
	movzx	eax, al
	or	edx, eax

; 1199 :    count = stbtt__buf_get16(b);
; 1200 :    if (count) {

	je	$LN68@stbtt__cff

; 1140 :    if (b->cursor >= b->size)

	cmp	r8d, r11d
	jl	SHORT $LN19@stbtt__cff

; 1141 :       return 0;

	xor	al, al
	jmp	SHORT $LN18@stbtt__cff
$LN19@stbtt__cff:

; 1142 :    return b->data[b->cursor++];

	mov	rax, QWORD PTR [r10]
	movsxd	rcx, r8d
	inc	r8d
	movzx	eax, BYTE PTR [rcx+rax]
$LN18@stbtt__cff:

; 1201 :       offsize = stbtt__buf_get8(b);

	movzx	eax, al

; 1202 :       STBTT_assert(offsize >= 1 && offsize <= 4);
; 1203 :       stbtt__buf_skip(b, offsize * count);

	imul	edx, eax

; 1160 :    stbtt__buf_seek(b, b->cursor + o);

	add	edx, r8d

; 1155 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

	cmp	edx, r11d
	jg	SHORT $LN28@stbtt__cff
	test	edx, edx
	jns	SHORT $LN29@stbtt__cff
$LN28@stbtt__cff:
	mov	edx, r11d
$LN29@stbtt__cff:

; 1165 :    stbtt_uint32 v = 0;

	xor	r8d, r8d

; 1155 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

	mov	DWORD PTR [r10+8], edx

; 1168 :    for (i = 0; i < n; i++)

	test	eax, eax
	je	SHORT $LN35@stbtt__cff
	mov	QWORD PTR [rsp+16], rdi

; 1142 :    return b->data[b->cursor++];

	mov	rdi, rax
$LL36@stbtt__cff:

; 1140 :    if (b->cursor >= b->size)

	cmp	edx, r11d
	jl	SHORT $LN39@stbtt__cff

; 1141 :       return 0;

	xor	al, al
	jmp	SHORT $LN38@stbtt__cff
$LN39@stbtt__cff:

; 1142 :    return b->data[b->cursor++];

	mov	rax, QWORD PTR [r10]
	movsxd	rcx, edx
	inc	edx
	movzx	eax, BYTE PTR [rcx+rax]
	mov	DWORD PTR [r10+8], edx
$LN38@stbtt__cff:

; 1169 :       v = (v << 8) | stbtt__buf_get8(b);

	shl	r8d, 8
	movzx	eax, al
	or	r8d, eax
	sub	rdi, 1
	jne	SHORT $LL36@stbtt__cff

; 1166 :    int i;
; 1167 :    STBTT_assert(n >= 1 && n <= 4);
; 1168 :    for (i = 0; i < n; i++)

	mov	rdi, QWORD PTR [rsp+16]
$LN35@stbtt__cff:

; 1160 :    stbtt__buf_seek(b, b->cursor + o);

	dec	r8d
	add	r8d, edx

; 1155 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

	cmp	r8d, r11d
	jg	SHORT $LN48@stbtt__cff
	test	r8d, r8d
	jns	SHORT $LN49@stbtt__cff
$LN48@stbtt__cff:
	mov	r8d, r11d
$LN49@stbtt__cff:
	mov	DWORD PTR [r10+8], r8d
$LN68@stbtt__cff:

; 1204 :       stbtt__buf_skip(b, stbtt__buf_get(b, offsize) - 1);
; 1205 :    }
; 1206 :    return stbtt__buf_range(b, start, b->cursor - start);

	sub	r8d, ebx

; 1188 :    stbtt__buf r = stbtt__new_buf(NULL, 0);

	mov	QWORD PTR [r9], 0
	mov	QWORD PTR [r9+8], 0

; 1189 :    if (o < 0 || s < 0 || o > b->size || s > b->size - o) return r;

	test	ebx, ebx
	js	SHORT $LN72@stbtt__cff
	test	r8d, r8d
	js	SHORT $LN72@stbtt__cff
	mov	eax, DWORD PTR [r10+12]
	cmp	ebx, eax
	jg	SHORT $LN72@stbtt__cff
	sub	eax, ebx
	cmp	r8d, eax
	jg	SHORT $LN72@stbtt__cff

; 1190 :    r.data = b->data + o;

	mov	rax, rbx
	add	rax, QWORD PTR [r10]
	mov	QWORD PTR [r9], rax

; 1191 :    r.size = s;

	mov	DWORD PTR [r9+12], r8d
$LN72@stbtt__cff:

; 1207 : }

	mov	rax, r9
	pop	rbx
	ret	0
?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z ENDP	; stbtt__cff_get_index
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z
_TEXT	SEGMENT
b$ = 16
?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z PROC		; stbtt__cff_int, COMDAT

; 1210 : {

	sub	rsp, 8

; 1140 :    if (b->cursor >= b->size)

	movsxd	r8, DWORD PTR [rcx+8]

; 1210 : {

	mov	r9, rcx

; 1140 :    if (b->cursor >= b->size)

	mov	r10d, DWORD PTR [rcx+12]
	cmp	r8d, r10d
	jl	SHORT $LN16@stbtt__cff

; 1141 :       return 0;

	xor	al, al
	jmp	SHORT $LN15@stbtt__cff
$LN16@stbtt__cff:

; 1142 :    return b->data[b->cursor++];

	mov	rax, QWORD PTR [rcx]
	movzx	eax, BYTE PTR [r8+rax]
	inc	r8d
	mov	DWORD PTR [rcx+8], r8d
$LN15@stbtt__cff:

; 1211 :    int b0 = stbtt__buf_get8(b);

	movzx	edx, al

; 1212 :    if (b0 >= 32 && b0 <= 246)       return b0 - 139;

	lea	eax, DWORD PTR [rdx-32]
	cmp	eax, 214				; 000000d6H
	ja	SHORT $LN5@stbtt__cff
	lea	eax, DWORD PTR [rdx-139]

; 1219 : }

	add	rsp, 8
	ret	0
$LN5@stbtt__cff:

; 1213 :    else if (b0 >= 247 && b0 <= 250) return (b0 - 247)*256 + stbtt__buf_get8(b) + 108;

	lea	eax, DWORD PTR [rdx-247]
	cmp	eax, 3
	ja	SHORT $LN7@stbtt__cff

; 1140 :    if (b->cursor >= b->size)

	cmp	r8d, r10d
	jl	SHORT $LN19@stbtt__cff

; 1141 :       return 0;

	xor	cl, cl

; 1213 :    else if (b0 >= 247 && b0 <= 250) return (b0 - 247)*256 + stbtt__buf_get8(b) + 108;

	shl	edx, 8
	movzx	eax, cl
	add	eax, -63124				; ffffffffffff096cH
	add	eax, edx

; 1219 : }

	add	rsp, 8
	ret	0
$LN19@stbtt__cff:

; 1142 :    return b->data[b->cursor++];

	mov	rax, QWORD PTR [r9]
	movsxd	rcx, r8d

; 1213 :    else if (b0 >= 247 && b0 <= 250) return (b0 - 247)*256 + stbtt__buf_get8(b) + 108;

	shl	edx, 8

; 1142 :    return b->data[b->cursor++];

	movzx	ecx, BYTE PTR [rcx+rax]
	lea	eax, DWORD PTR [r8+1]
	mov	DWORD PTR [r9+8], eax

; 1213 :    else if (b0 >= 247 && b0 <= 250) return (b0 - 247)*256 + stbtt__buf_get8(b) + 108;

	movzx	eax, cl
	add	eax, -63124				; ffffffffffff096cH
	add	eax, edx

; 1219 : }

	add	rsp, 8
	ret	0
$LN7@stbtt__cff:

; 1214 :    else if (b0 >= 251 && b0 <= 254) return -(b0 - 251)*256 - stbtt__buf_get8(b) - 108;

	lea	eax, DWORD PTR [rdx-251]
	cmp	eax, 3
	ja	SHORT $LN9@stbtt__cff

; 1140 :    if (b->cursor >= b->size)

	cmp	r8d, r10d
	jl	SHORT $LN22@stbtt__cff

; 1141 :       return 0;

	xor	cl, cl

; 1214 :    else if (b0 >= 251 && b0 <= 254) return -(b0 - 251)*256 - stbtt__buf_get8(b) - 108;

	shl	edx, 8
	mov	eax, 64148				; 0000fa94H
	movzx	ecx, cl
	sub	eax, edx
	sub	eax, ecx

; 1219 : }

	add	rsp, 8
	ret	0
$LN22@stbtt__cff:

; 1142 :    return b->data[b->cursor++];

	mov	rax, QWORD PTR [r9]
	movsxd	rcx, r8d

; 1214 :    else if (b0 >= 251 && b0 <= 254) return -(b0 - 251)*256 - stbtt__buf_get8(b) - 108;

	shl	edx, 8

; 1142 :    return b->data[b->cursor++];

	movzx	ecx, BYTE PTR [rcx+rax]
	lea	eax, DWORD PTR [r8+1]
	mov	DWORD PTR [r9+8], eax

; 1214 :    else if (b0 >= 251 && b0 <= 254) return -(b0 - 251)*256 - stbtt__buf_get8(b) - 108;

	mov	eax, 64148				; 0000fa94H
	sub	eax, edx
	movzx	ecx, cl
	sub	eax, ecx

; 1219 : }

	add	rsp, 8
	ret	0
$LN9@stbtt__cff:

; 1215 :    else if (b0 == 28)               return stbtt__buf_get16(b);

	cmp	edx, 28
	jne	SHORT $LN11@stbtt__cff

; 1140 :    if (b->cursor >= b->size)

	cmp	r8d, r10d
	jl	SHORT $LN33@stbtt__cff

; 1141 :       return 0;

	xor	r8d, r8d
	xor	cl, cl

; 1169 :       v = (v << 8) | stbtt__buf_get8(b);

	shl	r8d, 8
	movzx	eax, cl
	or	eax, r8d

; 1219 : }

	add	rsp, 8
	ret	0
$LN33@stbtt__cff:

; 1142 :    return b->data[b->cursor++];

	mov	rax, QWORD PTR [r9]
	lea	r11d, DWORD PTR [r8+1]
	movsxd	rcx, r8d
	movzx	edx, BYTE PTR [rcx+rax]
	mov	DWORD PTR [r9+8], r11d

; 1169 :       v = (v << 8) | stbtt__buf_get8(b);

	mov	r8d, edx

; 1140 :    if (b->cursor >= b->size)

	cmp	r11d, r10d
	jl	SHORT $LN51@stbtt__cff

; 1141 :       return 0;

	xor	cl, cl

; 1169 :       v = (v << 8) | stbtt__buf_get8(b);

	shl	r8d, 8
	movzx	eax, cl
	or	eax, r8d

; 1219 : }

	add	rsp, 8
	ret	0
$LN51@stbtt__cff:

; 1142 :    return b->data[b->cursor++];

	movsxd	rcx, r11d

; 1169 :       v = (v << 8) | stbtt__buf_get8(b);

	shl	r8d, 8

; 1142 :    return b->data[b->cursor++];

	movzx	ecx, BYTE PTR [rcx+rax]
	lea	eax, DWORD PTR [r11+1]
	mov	DWORD PTR [r9+8], eax

; 1169 :       v = (v << 8) | stbtt__buf_get8(b);

	movzx	eax, cl
	or	eax, r8d

; 1219 : }

	add	rsp, 8
	ret	0
$LN11@stbtt__cff:

; 1216 :    else if (b0 == 29)               return stbtt__buf_get32(b);

	cmp	edx, 29
	jne	$LN4@stbtt__cff
	mov	QWORD PTR [rsp], rbx

; 1140 :    if (b->cursor >= b->size)

	cmp	r8d, r10d
	jl	SHORT $LN44@stbtt__cff

; 1216 :    else if (b0 == 29)               return stbtt__buf_get32(b);

	mov	rbx, QWORD PTR [rsp]

; 1141 :       return 0;

	xor	r8d, r8d
	shl	r8d, 8
	xor	al, al
	shl	r8d, 8

; 1169 :       v = (v << 8) | stbtt__buf_get8(b);

	shl	r8d, 8
	movzx	eax, al
	or	eax, r8d

; 1219 : }

	add	rsp, 8
	ret	0
$LN44@stbtt__cff:

; 1142 :    return b->data[b->cursor++];

	mov	rax, QWORD PTR [r9]
	lea	ebx, DWORD PTR [r8+1]
	movsxd	rcx, r8d
	movzx	edx, BYTE PTR [rcx+rax]
	mov	DWORD PTR [r9+8], ebx

; 1169 :       v = (v << 8) | stbtt__buf_get8(b);

	mov	r11d, edx
	mov	r8d, edx

; 1140 :    if (b->cursor >= b->size)

	cmp	ebx, r10d
	jl	SHORT $LN54@stbtt__cff

; 1216 :    else if (b0 == 29)               return stbtt__buf_get32(b);

	mov	rbx, QWORD PTR [rsp]

; 1141 :       return 0;

	xor	al, al
	shl	r8d, 8
	shl	r8d, 8

; 1169 :       v = (v << 8) | stbtt__buf_get8(b);

	shl	r8d, 8
	movzx	eax, al
	or	eax, r8d

; 1219 : }

	add	rsp, 8
	ret	0
$LN54@stbtt__cff:

; 1142 :    return b->data[b->cursor++];

	movsxd	rcx, ebx
	inc	ebx

; 1169 :       v = (v << 8) | stbtt__buf_get8(b);

	shl	r11d, 8

; 1142 :    return b->data[b->cursor++];

	movzx	edx, BYTE PTR [rcx+rax]

; 1169 :       v = (v << 8) | stbtt__buf_get8(b);

	or	r11d, edx

; 1142 :    return b->data[b->cursor++];

	mov	DWORD PTR [r9+8], ebx

; 1169 :       v = (v << 8) | stbtt__buf_get8(b);

	mov	r8d, r11d

; 1140 :    if (b->cursor >= b->size)

	cmp	ebx, r10d
	jl	SHORT $LN57@stbtt__cff

; 1216 :    else if (b0 == 29)               return stbtt__buf_get32(b);

	mov	rbx, QWORD PTR [rsp]

; 1141 :       return 0;

	xor	al, al
	shl	r8d, 8

; 1169 :       v = (v << 8) | stbtt__buf_get8(b);

	shl	r8d, 8
	movzx	eax, al
	or	eax, r8d

; 1219 : }

	add	rsp, 8
	ret	0
$LN57@stbtt__cff:

; 1142 :    return b->data[b->cursor++];

	movsxd	rcx, ebx
	inc	ebx

; 1169 :       v = (v << 8) | stbtt__buf_get8(b);

	shl	r8d, 8

; 1142 :    return b->data[b->cursor++];

	movzx	edx, BYTE PTR [rcx+rax]

; 1169 :       v = (v << 8) | stbtt__buf_get8(b);

	or	r8d, edx

; 1142 :    return b->data[b->cursor++];

	mov	DWORD PTR [r9+8], ebx
	cmp	ebx, r10d
	jl	SHORT $LN60@stbtt__cff

; 1216 :    else if (b0 == 29)               return stbtt__buf_get32(b);

	mov	rbx, QWORD PTR [rsp]

; 1141 :       return 0;

	xor	al, al

; 1169 :       v = (v << 8) | stbtt__buf_get8(b);

	movzx	eax, al
	shl	r8d, 8
	or	eax, r8d

; 1219 : }

	add	rsp, 8
	ret	0
$LN60@stbtt__cff:

; 1142 :    return b->data[b->cursor++];

	movsxd	rdx, ebx
	lea	ecx, DWORD PTR [rbx+1]

; 1216 :    else if (b0 == 29)               return stbtt__buf_get32(b);

	mov	rbx, QWORD PTR [rsp]

; 1169 :       v = (v << 8) | stbtt__buf_get8(b);

	shl	r8d, 8

; 1142 :    return b->data[b->cursor++];

	movzx	eax, BYTE PTR [rdx+rax]

; 1169 :       v = (v << 8) | stbtt__buf_get8(b);

	movzx	eax, al
	or	eax, r8d

; 1142 :    return b->data[b->cursor++];

	mov	DWORD PTR [r9+8], ecx

; 1219 : }

	add	rsp, 8
	ret	0
$LN4@stbtt__cff:

; 1217 :    STBTT_assert(0);
; 1218 :    return 0;

	xor	eax, eax

; 1219 : }

	add	rsp, 8
	ret	0
?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z ENDP		; stbtt__cff_int
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z
_TEXT	SEGMENT
b$ = 8
?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z PROC	; stbtt__cff_skip_operand, COMDAT

; 1221 : static void stbtt__cff_skip_operand(stbtt__buf *b) {

	mov	r9, rcx

; 1147 :    if (b->cursor >= b->size)

	movsxd	rcx, DWORD PTR [rcx+8]
	mov	r8d, DWORD PTR [r9+12]
	cmp	ecx, r8d
	jge	SHORT $LN7@stbtt__cff

; 1148 :       return 0;
; 1149 :    return b->data[b->cursor];

	mov	r11, QWORD PTR [r9]

; 1222 :    int v, b0 = stbtt__buf_peek8(b);
; 1223 :    STBTT_assert(b0 >= 28);
; 1224 :    if (b0 == 30) {

	cmp	BYTE PTR [rcx+r11], 30
	jne	SHORT $LN7@stbtt__cff

; 1160 :    stbtt__buf_seek(b, b->cursor + o);

	lea	eax, DWORD PTR [rcx+1]

; 1155 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

	cmp	eax, r8d
	jg	SHORT $LN22@stbtt__cff
	test	eax, eax
	js	SHORT $LN22@stbtt__cff
	mov	DWORD PTR [r9+8], eax

; 1225 :       stbtt__buf_skip(b, 1);
; 1226 :       while (b->cursor < b->size) {

	cmp	eax, r8d
	jge	SHORT $LN8@stbtt__cff
	npad	1
$LL5@stbtt__cff:

; 1140 :    if (b->cursor >= b->size)

	cmp	eax, r8d
	jl	SHORT $LN25@stbtt__cff

; 1141 :       return 0;

	xor	cl, cl
	jmp	SHORT $LN31@stbtt__cff
$LN25@stbtt__cff:

; 1142 :    return b->data[b->cursor++];

	movsxd	rcx, eax
	inc	eax
	movzx	ecx, BYTE PTR [rcx+r11]
	mov	DWORD PTR [r9+8], eax
$LN31@stbtt__cff:

; 1227 :          v = stbtt__buf_get8(b);

	movzx	edx, cl
	mov	r10d, eax

; 1228 :          if ((v & 0xF) == 0xF || (v >> 4) == 0xF)

	mov	ecx, edx
	and	ecx, 15
	cmp	cl, 15
	je	SHORT $LN8@stbtt__cff
	and	edx, -16				; fffffff0H
	cmp	edx, 240				; 000000f0H
	je	SHORT $LN8@stbtt__cff

; 1225 :       stbtt__buf_skip(b, 1);
; 1226 :       while (b->cursor < b->size) {

	cmp	eax, r8d
	jl	SHORT $LL5@stbtt__cff

; 1233 :    }
; 1234 : }

	ret	0
$LN22@stbtt__cff:

; 1155 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

	mov	DWORD PTR [r9+8], r8d

; 1233 :    }
; 1234 : }

	ret	0
$LN7@stbtt__cff:

; 1229 :             break;
; 1230 :       }
; 1231 :    } else {
; 1232 :       stbtt__cff_int(b);

	mov	rcx, r9
	jmp	?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z	; stbtt__cff_int
$LN8@stbtt__cff:

; 1233 :    }
; 1234 : }

	ret	0
?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z ENDP	; stbtt__cff_skip_operand
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__dict_get@@YA?AUstbtt__buf@@PEAU1@H@Z
_TEXT	SEGMENT
__$ReturnAddress$ = 48
b$ = 56
key$ = 64
?stbtt__dict_get@@YA?AUstbtt__buf@@PEAU1@H@Z PROC	; stbtt__dict_get, COMDAT

; 1237 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 1155 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

	mov	eax, DWORD PTR [rdx+12]
	xor	r14d, r14d
	test	eax, eax
	mov	esi, r14d

; 1237 : {

	mov	ebp, r8d
	mov	rbx, rdx

; 1155 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

	cmovs	esi, eax

; 1237 : {

	mov	rdi, rcx

; 1155 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

	mov	DWORD PTR [rdx+8], esi

; 1238 :    stbtt__buf_seek(b, 0);
; 1239 :    while (b->cursor < b->size) {

	cmp	esi, eax
	jge	$LN64@stbtt__dic
	npad	4
$LL2@stbtt__dic:

; 1240 :       int start = b->cursor, end, op;
; 1241 :       while (stbtt__buf_peek8(b) >= 28)

	mov	rcx, rbx
	call	?stbtt__buf_peek8@@YAEPEAUstbtt__buf@@@Z ; stbtt__buf_peek8
	cmp	al, 28
	jb	$LN5@stbtt__dic
$LL4@stbtt__dic:

; 1147 :    if (b->cursor >= b->size)

	movsxd	rcx, DWORD PTR [rbx+8]
	mov	r8d, DWORD PTR [rbx+12]
	cmp	ecx, r8d
	jge	SHORT $LN22@stbtt__dic

; 1148 :       return 0;
; 1149 :    return b->data[b->cursor];

	mov	r10, QWORD PTR [rbx]

; 1224 :    if (b0 == 30) {

	cmp	BYTE PTR [rcx+r10], 30
	jne	SHORT $LN22@stbtt__dic

; 1160 :    stbtt__buf_seek(b, b->cursor + o);

	lea	eax, DWORD PTR [rcx+1]

; 1155 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

	cmp	eax, r8d
	jg	SHORT $LN37@stbtt__dic
	test	eax, eax
	js	SHORT $LN37@stbtt__dic
	mov	DWORD PTR [rbx+8], eax

; 1226 :       while (b->cursor < b->size) {

	cmp	eax, r8d
	jge	SHORT $LN23@stbtt__dic
	npad	5
$LL20@stbtt__dic:

; 1140 :    if (b->cursor >= b->size)

	cmp	eax, r8d
	jl	SHORT $LN40@stbtt__dic

; 1141 :       return 0;

	xor	cl, cl
	jmp	SHORT $LN101@stbtt__dic
$LN40@stbtt__dic:

; 1142 :    return b->data[b->cursor++];

	movsxd	rcx, eax
	inc	eax
	movzx	ecx, BYTE PTR [rcx+r10]
	mov	DWORD PTR [rbx+8], eax
$LN101@stbtt__dic:

; 1227 :          v = stbtt__buf_get8(b);

	movzx	edx, cl
	mov	r9d, eax

; 1228 :          if ((v & 0xF) == 0xF || (v >> 4) == 0xF)

	mov	ecx, edx
	and	ecx, 15
	cmp	cl, 15
	je	SHORT $LN23@stbtt__dic
	and	edx, -16				; fffffff0H
	cmp	edx, 240				; 000000f0H
	je	SHORT $LN23@stbtt__dic

; 1225 :       stbtt__buf_skip(b, 1);
; 1226 :       while (b->cursor < b->size) {

	cmp	eax, r8d
	jl	SHORT $LL20@stbtt__dic

; 1229 :             break;
; 1230 :       }
; 1231 :    } else {

	jmp	SHORT $LN23@stbtt__dic
$LN37@stbtt__dic:

; 1155 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

	mov	DWORD PTR [rbx+8], r8d
	jmp	SHORT $LN23@stbtt__dic
$LN22@stbtt__dic:

; 1232 :       stbtt__cff_int(b);

	mov	rcx, rbx
	call	?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z	; stbtt__cff_int
$LN23@stbtt__dic:

; 1240 :       int start = b->cursor, end, op;
; 1241 :       while (stbtt__buf_peek8(b) >= 28)

	mov	rcx, rbx
	call	?stbtt__buf_peek8@@YAEPEAUstbtt__buf@@@Z ; stbtt__buf_peek8
	cmp	al, 28
	jae	$LL4@stbtt__dic
$LN5@stbtt__dic:

; 1242 :          stbtt__cff_skip_operand(b);
; 1243 :       end = b->cursor;

	movsxd	r8, DWORD PTR [rbx+8]

; 1140 :    if (b->cursor >= b->size)

	mov	r9d, DWORD PTR [rbx+12]
	cmp	r8d, r9d
	jl	SHORT $LN43@stbtt__dic

; 1141 :       return 0;

	xor	al, al
	mov	edx, r8d
	jmp	SHORT $LN42@stbtt__dic
$LN43@stbtt__dic:

; 1142 :    return b->data[b->cursor++];

	mov	rax, QWORD PTR [rbx]
	lea	edx, DWORD PTR [r8+1]
	movzx	eax, BYTE PTR [r8+rax]
	mov	DWORD PTR [rbx+8], edx
$LN42@stbtt__dic:

; 1244 :       op = stbtt__buf_get8(b);

	movzx	eax, al

; 1245 :       if (op == 12)  op = stbtt__buf_get8(b) | 0x100;

	cmp	eax, 12
	jne	SHORT $LN6@stbtt__dic

; 1140 :    if (b->cursor >= b->size)

	cmp	edx, r9d
	jl	SHORT $LN46@stbtt__dic

; 1141 :       return 0;

	xor	al, al
	jmp	SHORT $LN45@stbtt__dic
$LN46@stbtt__dic:

; 1142 :    return b->data[b->cursor++];

	mov	rax, QWORD PTR [rbx]
	movsxd	rcx, edx
	inc	edx
	movzx	eax, BYTE PTR [rcx+rax]
	mov	DWORD PTR [rbx+8], edx
$LN45@stbtt__dic:

; 1245 :       if (op == 12)  op = stbtt__buf_get8(b) | 0x100;

	movzx	eax, al
	bts	eax, 8
$LN6@stbtt__dic:

; 1246 :       if (op == key) return stbtt__buf_range(b, start, end-start);

	cmp	eax, ebp
	je	SHORT $LN70@stbtt__dic

; 1238 :    stbtt__buf_seek(b, 0);
; 1239 :    while (b->cursor < b->size) {

	mov	esi, edx
	cmp	edx, r9d
	jl	$LL2@stbtt__dic
$LN64@stbtt__dic:

; 1188 :    stbtt__buf r = stbtt__new_buf(NULL, 0);

	mov	QWORD PTR [rdi], r14
	mov	QWORD PTR [rdi+8], r14

; 1189 :    if (o < 0 || s < 0 || o > b->size || s > b->size - o) return r;

	cmp	DWORD PTR [rbx+12], r14d
	jl	SHORT $LN77@stbtt__dic

; 1190 :    r.data = b->data + o;

	mov	rax, QWORD PTR [rbx]
$LN102@stbtt__dic:

; 1247 :    }
; 1248 :    return stbtt__buf_range(b, 0, 0);
; 1249 : }

	mov	QWORD PTR [rdi], rax
$LN77@stbtt__dic:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN70@stbtt__dic:

; 1246 :       if (op == key) return stbtt__buf_range(b, start, end-start);

	sub	r8d, esi

; 1188 :    stbtt__buf r = stbtt__new_buf(NULL, 0);

	mov	QWORD PTR [rdi], r14
	mov	QWORD PTR [rdi+8], r14

; 1189 :    if (o < 0 || s < 0 || o > b->size || s > b->size - o) return r;

	test	esi, esi
	js	SHORT $LN77@stbtt__dic
	test	r8d, r8d
	js	SHORT $LN77@stbtt__dic
	mov	eax, DWORD PTR [rbx+12]
	cmp	esi, eax
	jg	SHORT $LN77@stbtt__dic
	sub	eax, esi
	cmp	r8d, eax
	jg	SHORT $LN77@stbtt__dic

; 1190 :    r.data = b->data + o;

	movsxd	rax, esi
	add	rax, QWORD PTR [rbx]

; 1191 :    r.size = s;

	mov	DWORD PTR [rdi+12], r8d
	jmp	SHORT $LN102@stbtt__dic
?stbtt__dict_get@@YA?AUstbtt__buf@@PEAU1@H@Z ENDP	; stbtt__dict_get
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__dict_get_ints@@YAXPEAUstbtt__buf@@HHPEAI@Z
_TEXT	SEGMENT
$T1 = 32
operands$ = 32
b$ = 64
key$ = 72
outcount$ = 80
out$ = 88
?stbtt__dict_get_ints@@YAXPEAUstbtt__buf@@HHPEAI@Z PROC	; stbtt__dict_get_ints, COMDAT

; 1252 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	movsxd	rbx, r8d
	mov	rsi, r9

; 1253 :    int i;
; 1254 :    stbtt__buf operands = stbtt__dict_get(b, key);

	mov	r8d, edx
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T1[rsp]
	call	?stbtt__dict_get@@YA?AUstbtt__buf@@PEAU1@H@Z ; stbtt__dict_get

; 1255 :    for (i = 0; i < outcount && operands.cursor < operands.size; i++)

	mov	rdi, rbx
	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR operands$[rsp], xmm0
	test	ebx, ebx
	jle	SHORT $LN10@stbtt__dic
	xor	ebx, ebx
$LL4@stbtt__dic:
	mov	eax, DWORD PTR operands$[rsp+12]
	cmp	DWORD PTR operands$[rsp+8], eax
	jge	SHORT $LN10@stbtt__dic

; 1256 :       out[i] = stbtt__cff_int(&operands);

	lea	rcx, QWORD PTR operands$[rsp]
	call	?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z	; stbtt__cff_int
	mov	DWORD PTR [rsi+rbx*4], eax
	inc	rbx
	cmp	rbx, rdi
	jl	SHORT $LL4@stbtt__dic
$LN10@stbtt__dic:

; 1257 : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?stbtt__dict_get_ints@@YAXPEAUstbtt__buf@@HHPEAI@Z ENDP	; stbtt__dict_get_ints
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__cff_index_count@@YAHPEAUstbtt__buf@@@Z
_TEXT	SEGMENT
b$ = 8
?stbtt__cff_index_count@@YAHPEAUstbtt__buf@@@Z PROC	; stbtt__cff_index_count, COMDAT

; 1155 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

	mov	r10d, DWORD PTR [rcx+12]
	xor	eax, eax
	test	r10d, r10d
	mov	r9d, eax

; 1260 : {

	mov	r8, rcx

; 1155 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

	cmovs	r9d, r10d
	mov	DWORD PTR [rcx+8], r9d

; 1140 :    if (b->cursor >= b->size)

	cmp	r9d, r10d
	jge	SHORT $LN28@stbtt__cff

; 1142 :    return b->data[b->cursor++];

	mov	rax, QWORD PTR [r8]
	movsxd	rcx, r9d
	inc	r9d
	movzx	eax, BYTE PTR [rcx+rax]
	mov	DWORD PTR [r8+8], r9d
	cmp	r9d, r10d
	jl	SHORT $LN24@stbtt__cff
$LN28@stbtt__cff:

; 1141 :       return 0;

	xor	dl, dl

; 1169 :       v = (v << 8) | stbtt__buf_get8(b);

	shl	eax, 8
	movzx	ecx, dl
	or	eax, ecx

; 1261 :    stbtt__buf_seek(b, 0);
; 1262 :    return stbtt__buf_get16(b);
; 1263 : }

	ret	0
$LN24@stbtt__cff:

; 1142 :    return b->data[b->cursor++];

	mov	rcx, QWORD PTR [r8]
	movsxd	rdx, r9d

; 1169 :       v = (v << 8) | stbtt__buf_get8(b);

	shl	eax, 8

; 1142 :    return b->data[b->cursor++];

	movzx	edx, BYTE PTR [rdx+rcx]
	lea	ecx, DWORD PTR [r9+1]
	mov	DWORD PTR [r8+8], ecx

; 1169 :       v = (v << 8) | stbtt__buf_get8(b);

	movzx	ecx, dl
	or	eax, ecx

; 1261 :    stbtt__buf_seek(b, 0);
; 1262 :    return stbtt__buf_get16(b);
; 1263 : }

	ret	0
?stbtt__cff_index_count@@YAHPEAUstbtt__buf@@@Z ENDP	; stbtt__cff_index_count
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z
_TEXT	SEGMENT
__$ReturnAddress$ = 16
b$ = 24
i$ = 32
?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z PROC	; stbtt__cff_index_get, COMDAT

; 1266 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi

; 1155 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

	movsxd	r9, DWORD PTR [rdx+12]
	xor	r10d, r10d
	test	r9d, r9d

; 1266 : {

	mov	r11, rdx
	mov	edi, r8d
	mov	rbx, rcx

; 1155 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

	cmovs	r10d, r9d
	movsxd	rdx, r10d

; 1140 :    if (b->cursor >= b->size)

	cmp	rdx, r9
	jl	SHORT $LN25@stbtt__cff

; 1141 :       return 0;

	xor	esi, esi
	xor	al, al
	jmp	SHORT $LN78@stbtt__cff
$LN25@stbtt__cff:

; 1142 :    return b->data[b->cursor++];

	mov	rax, QWORD PTR [r11]
	inc	r10d
	movzx	esi, BYTE PTR [rdx+rax]
	inc	rdx
	cmp	rdx, r9
	jl	SHORT $LN77@stbtt__cff

; 1141 :       return 0;

	xor	al, al
	jmp	SHORT $LN78@stbtt__cff
$LN77@stbtt__cff:

; 1142 :    return b->data[b->cursor++];

	movzx	eax, BYTE PTR [rdx+rax]
	inc	r10d
$LN78@stbtt__cff:

; 1169 :       v = (v << 8) | stbtt__buf_get8(b);

	shl	esi, 8
	movzx	eax, al
	or	esi, eax

; 1140 :    if (b->cursor >= b->size)

	cmp	r10d, r9d
	jl	SHORT $LN28@stbtt__cff

; 1141 :       return 0;

	xor	al, al
	jmp	SHORT $LN27@stbtt__cff
$LN28@stbtt__cff:

; 1142 :    return b->data[b->cursor++];

	mov	rax, QWORD PTR [r11]
	movsxd	rcx, r10d
	inc	r10d
	movzx	eax, BYTE PTR [rcx+rax]
$LN27@stbtt__cff:

; 1267 :    int count, offsize, start, end;
; 1268 :    stbtt__buf_seek(&b, 0);
; 1269 :    count = stbtt__buf_get16(&b);
; 1270 :    offsize = stbtt__buf_get8(&b);

	movzx	ebp, al

; 1271 :    STBTT_assert(i >= 0 && i < count);
; 1272 :    STBTT_assert(offsize >= 1 && offsize <= 4);
; 1273 :    stbtt__buf_skip(&b, i*offsize);

	mov	eax, ebp
	imul	eax, edi

; 1160 :    stbtt__buf_seek(b, b->cursor + o);

	add	eax, r10d

; 1155 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

	cmp	eax, r9d
	jg	SHORT $LN37@stbtt__cff
	test	eax, eax
	jns	SHORT $LN38@stbtt__cff
$LN37@stbtt__cff:
	mov	eax, r9d
$LN38@stbtt__cff:

; 1165 :    stbtt_uint32 v = 0;

	xor	r10d, r10d

; 1155 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

	mov	DWORD PTR [r11+8], eax

; 1168 :    for (i = 0; i < n; i++)

	test	ebp, ebp
	je	SHORT $LN85@stbtt__cff

; 1142 :    return b->data[b->cursor++];

	mov	rdi, rbp
	mov	r8, rbp
$LL45@stbtt__cff:

; 1140 :    if (b->cursor >= b->size)

	cmp	eax, r9d
	jl	SHORT $LN48@stbtt__cff

; 1141 :       return 0;

	xor	cl, cl
	jmp	SHORT $LN47@stbtt__cff
$LN48@stbtt__cff:

; 1142 :    return b->data[b->cursor++];

	mov	rcx, QWORD PTR [r11]
	movsxd	rdx, eax
	inc	eax
	mov	DWORD PTR [r11+8], eax
	movzx	ecx, BYTE PTR [rdx+rcx]
$LN47@stbtt__cff:

; 1169 :       v = (v << 8) | stbtt__buf_get8(b);

	shl	r10d, 8
	movzx	ecx, cl
	or	r10d, ecx
	sub	r8, 1
	jne	SHORT $LL45@stbtt__cff
$LL56@stbtt__cff:

; 1140 :    if (b->cursor >= b->size)

	cmp	eax, r9d
	jl	SHORT $LN59@stbtt__cff

; 1141 :       return 0;

	xor	cl, cl
	jmp	SHORT $LN58@stbtt__cff
$LN59@stbtt__cff:

; 1142 :    return b->data[b->cursor++];

	mov	rcx, QWORD PTR [r11]
	movsxd	rdx, eax
	inc	eax
	mov	DWORD PTR [r11+8], eax
	movzx	ecx, BYTE PTR [rdx+rcx]
$LN58@stbtt__cff:

; 1169 :       v = (v << 8) | stbtt__buf_get8(b);

	shl	r8d, 8
	movzx	ecx, cl
	or	r8d, ecx
	sub	rdi, 1
	jne	SHORT $LL56@stbtt__cff

; 1166 :    int i;
; 1167 :    STBTT_assert(n >= 1 && n <= 4);
; 1168 :    for (i = 0; i < n; i++)

	jmp	SHORT $LN55@stbtt__cff
$LN85@stbtt__cff:
	xor	r8d, r8d
$LN55@stbtt__cff:

; 1274 :    start = stbtt__buf_get(&b, offsize);
; 1275 :    end = stbtt__buf_get(&b, offsize);
; 1276 :    return stbtt__buf_range(&b, 2+(count+1)*offsize+start, end - start);

	lea	eax, DWORD PTR [rsi+1]

; 1188 :    stbtt__buf r = stbtt__new_buf(NULL, 0);

	mov	QWORD PTR [rbx], 0

; 1274 :    start = stbtt__buf_get(&b, offsize);
; 1275 :    end = stbtt__buf_get(&b, offsize);
; 1276 :    return stbtt__buf_range(&b, 2+(count+1)*offsize+start, end - start);

	imul	eax, ebp
	lea	ecx, DWORD PTR [r10+2]
	sub	r8d, r10d

; 1188 :    stbtt__buf r = stbtt__new_buf(NULL, 0);

	mov	QWORD PTR [rbx+8], 0

; 1274 :    start = stbtt__buf_get(&b, offsize);
; 1275 :    end = stbtt__buf_get(&b, offsize);
; 1276 :    return stbtt__buf_range(&b, 2+(count+1)*offsize+start, end - start);

	add	ecx, eax

; 1189 :    if (o < 0 || s < 0 || o > b->size || s > b->size - o) return r;

	js	SHORT $LN88@stbtt__cff
	test	r8d, r8d
	js	SHORT $LN88@stbtt__cff
	cmp	ecx, r9d
	jg	SHORT $LN88@stbtt__cff
	sub	r9d, ecx
	cmp	r8d, r9d
	jg	SHORT $LN88@stbtt__cff

; 1190 :    r.data = b->data + o;

	movsxd	rax, ecx
	add	rax, QWORD PTR [r11]
	mov	QWORD PTR [rbx], rax

; 1191 :    r.size = s;

	mov	DWORD PTR [rbx+12], r8d
$LN88@stbtt__cff:

; 1277 : }

	mov	rbp, QWORD PTR [rsp+32]
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+16]
	mov	rsi, QWORD PTR [rsp+40]
	pop	rdi
	ret	0
?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z ENDP	; stbtt__cff_index_get
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?ttUSHORT@@YAGPEAE@Z
_TEXT	SEGMENT
p$ = 8
?ttUSHORT@@YAGPEAE@Z PROC				; ttUSHORT, COMDAT

; 1291 : static stbtt_uint16 ttUSHORT(stbtt_uint8 *p) { return p[0]*256 + p[1]; }

	movzx	eax, BYTE PTR [rcx]
	mov	edx, 256				; 00000100H
	movzx	ecx, BYTE PTR [rcx+1]
	imul	eax, edx
	add	ax, cx
	ret	0
?ttUSHORT@@YAGPEAE@Z ENDP				; ttUSHORT
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?ttSHORT@@YAFPEAE@Z
_TEXT	SEGMENT
p$ = 8
?ttSHORT@@YAFPEAE@Z PROC				; ttSHORT, COMDAT

; 1292 : static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }

	movzx	eax, BYTE PTR [rcx]
	mov	edx, 256				; 00000100H
	movzx	ecx, BYTE PTR [rcx+1]
	movsx	edx, dx
	imul	eax, edx
	add	ax, cx
	ret	0
?ttSHORT@@YAFPEAE@Z ENDP				; ttSHORT
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?ttULONG@@YAIPEAE@Z
_TEXT	SEGMENT
p$ = 8
?ttULONG@@YAIPEAE@Z PROC				; ttULONG, COMDAT

; 1293 : static stbtt_uint32 ttULONG(stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }

	movzx	edx, BYTE PTR [rcx+1]
	movzx	eax, BYTE PTR [rcx]
	shl	eax, 8
	add	eax, edx
	movzx	edx, BYTE PTR [rcx+2]
	movzx	ecx, BYTE PTR [rcx+3]
	shl	eax, 8
	add	eax, edx
	shl	eax, 8
	add	eax, ecx
	ret	0
?ttULONG@@YAIPEAE@Z ENDP				; ttULONG
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?ttLONG@@YAHPEAE@Z
_TEXT	SEGMENT
p$ = 8
?ttLONG@@YAHPEAE@Z PROC					; ttLONG, COMDAT

; 1294 : static stbtt_int32 ttLONG(stbtt_uint8 *p)    { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }

	movzx	edx, BYTE PTR [rcx+1]
	movzx	eax, BYTE PTR [rcx]
	shl	eax, 8
	add	eax, edx
	movzx	edx, BYTE PTR [rcx+2]
	movzx	ecx, BYTE PTR [rcx+3]
	shl	eax, 8
	add	eax, edx
	shl	eax, 8
	add	eax, ecx
	ret	0
?ttLONG@@YAHPEAE@Z ENDP					; ttLONG
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__isfont@@YAHPEAE@Z
_TEXT	SEGMENT
font$ = 8
?stbtt__isfont@@YAHPEAE@Z PROC				; stbtt__isfont, COMDAT

; 1301 :    // check the version number
; 1302 :    if (stbtt_tag4(font, '1',0,0,0))  return 1; // TrueType 1

	movzx	eax, BYTE PTR [rcx]
	cmp	al, 49					; 00000031H
	jne	SHORT $LN2@stbtt__isf
	cmp	BYTE PTR [rcx+1], 0
	jne	SHORT $LN6@stbtt__isf
	cmp	BYTE PTR [rcx+2], 0
	jne	SHORT $LN6@stbtt__isf
	cmp	BYTE PTR [rcx+3], 0
$LN14@stbtt__isf:

; 1307 :    return 0;

	je	SHORT $LN9@stbtt__isf
$LN6@stbtt__isf:
	xor	eax, eax

; 1308 : }

	ret	0
$LN2@stbtt__isf:

; 1303 :    if (stbtt_tag(font, "typ1"))   return 1; // TrueType with type 1 font -- we don't support this!

	cmp	al, 116					; 00000074H
	jne	SHORT $LN3@stbtt__isf
	cmp	BYTE PTR [rcx+1], 121			; 00000079H
	jne	SHORT $LN8@stbtt__isf
	cmp	BYTE PTR [rcx+2], 112			; 00000070H
	jne	SHORT $LN6@stbtt__isf
	cmp	BYTE PTR [rcx+3], 49			; 00000031H
	jmp	SHORT $LN14@stbtt__isf
$LN8@stbtt__isf:

; 1306 :    if (stbtt_tag(font, "true"))   return 1; // Apple specification for TrueType fonts

	cmp	BYTE PTR [rcx+1], 114			; 00000072H
	jne	SHORT $LN6@stbtt__isf
	cmp	BYTE PTR [rcx+2], 117			; 00000075H
	jne	SHORT $LN6@stbtt__isf
	xor	eax, eax
	cmp	BYTE PTR [rcx+3], 101			; 00000065H
	sete	al

; 1308 : }

	ret	0
$LN3@stbtt__isf:

; 1304 :    if (stbtt_tag(font, "OTTO"))   return 1; // OpenType with CFF

	cmp	al, 79					; 0000004fH
	jne	SHORT $LN4@stbtt__isf
	cmp	BYTE PTR [rcx+1], 84			; 00000054H
	jne	SHORT $LN6@stbtt__isf
	cmp	BYTE PTR [rcx+2], 84			; 00000054H
	jne	SHORT $LN6@stbtt__isf
	cmp	BYTE PTR [rcx+3], al
	jmp	SHORT $LN14@stbtt__isf
$LN4@stbtt__isf:

; 1305 :    if (stbtt_tag4(font, 0,1,0,0)) return 1; // OpenType 1.0

	test	al, al
	jne	SHORT $LN6@stbtt__isf
	cmp	BYTE PTR [rcx+1], 1
	jne	SHORT $LN6@stbtt__isf
	cmp	BYTE PTR [rcx+2], al
	jne	SHORT $LN6@stbtt__isf
	cmp	BYTE PTR [rcx+3], al
	jne	SHORT $LN6@stbtt__isf
$LN9@stbtt__isf:

; 1306 :    if (stbtt_tag(font, "true"))   return 1; // Apple specification for TrueType fonts

	mov	eax, 1

; 1308 : }

	ret	0
?stbtt__isfont@@YAHPEAE@Z ENDP				; stbtt__isfont
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__find_table@@YAIPEAEIPEBD@Z
_TEXT	SEGMENT
data$ = 8
fontstart$ = 16
tag$ = 24
?stbtt__find_table@@YAIPEAEIPEBD@Z PROC			; stbtt__find_table, COMDAT

; 1312 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rdi

; 1313 :    stbtt_int32 num_tables = ttUSHORT(data+fontstart+4);

	mov	eax, edx

; 1314 :    stbtt_uint32 tabledir = fontstart + 12;

	lea	edi, DWORD PTR [rdx+12]

; 1315 :    stbtt_int32 i;
; 1316 :    for (i=0; i < num_tables; ++i) {

	xor	r9d, r9d
	mov	rbx, rcx
	movzx	r10d, BYTE PTR [rax+rcx+4]
	movzx	eax, BYTE PTR [rax+rcx+5]
	shl	r10d, 8
	add	r10d, eax
	je	SHORT $LN16@stbtt__fin
	movsx	r11d, BYTE PTR [r8]
	npad	3
$LL4@stbtt__fin:

; 1317 :       stbtt_uint32 loc = tabledir + 16*i;

	mov	edx, r9d
	shl	edx, 4
	add	edx, edi

; 1318 :       if (stbtt_tag(data+loc+0, tag))

	add	rdx, rbx
	movzx	eax, BYTE PTR [rdx]
	cmp	eax, r11d
	jne	SHORT $LN2@stbtt__fin
	movzx	ecx, BYTE PTR [rdx+1]
	movsx	eax, BYTE PTR [r8+1]
	cmp	ecx, eax
	jne	SHORT $LN2@stbtt__fin
	movzx	ecx, BYTE PTR [rdx+2]
	movsx	eax, BYTE PTR [r8+2]
	cmp	ecx, eax
	jne	SHORT $LN2@stbtt__fin
	movzx	ecx, BYTE PTR [rdx+3]
	movsx	eax, BYTE PTR [r8+3]
	cmp	ecx, eax
	je	SHORT $LN12@stbtt__fin
$LN2@stbtt__fin:

; 1315 :    stbtt_int32 i;
; 1316 :    for (i=0; i < num_tables; ++i) {

	inc	r9d
	cmp	r9d, r10d
	jl	SHORT $LL4@stbtt__fin
$LN16@stbtt__fin:

; 1319 :          return ttULONG(data+loc+8);
; 1320 :    }
; 1321 :    return 0;

	xor	eax, eax

; 1322 : }

	mov	rbx, QWORD PTR [rsp+8]
	mov	rdi, QWORD PTR [rsp+16]
	ret	0
$LN12@stbtt__fin:

; 1293 : static stbtt_uint32 ttULONG(stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }

	movzx	ecx, BYTE PTR [rdx+9]
	movzx	eax, BYTE PTR [rdx+8]

; 1322 : }

	mov	rbx, QWORD PTR [rsp+8]
	mov	rdi, QWORD PTR [rsp+16]

; 1293 : static stbtt_uint32 ttULONG(stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }

	shl	eax, 8
	add	eax, ecx
	movzx	ecx, BYTE PTR [rdx+10]
	shl	eax, 8
	add	eax, ecx
	movzx	ecx, BYTE PTR [rdx+11]
	shl	eax, 8
	add	eax, ecx

; 1322 : }

	ret	0
?stbtt__find_table@@YAIPEAEIPEBD@Z ENDP			; stbtt__find_table
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt_GetFontOffsetForIndex_internal@@YAHPEAEH@Z
_TEXT	SEGMENT
font_collection$ = 8
index$ = 16
?stbtt_GetFontOffsetForIndex_internal@@YAHPEAEH@Z PROC	; stbtt_GetFontOffsetForIndex_internal, COMDAT

; 1302 :    if (stbtt_tag4(font, '1',0,0,0))  return 1; // TrueType 1

	movzx	eax, BYTE PTR [rcx]

; 1325 : {

	mov	r8, rcx

; 1302 :    if (stbtt_tag4(font, '1',0,0,0))  return 1; // TrueType 1

	cmp	al, 49					; 00000031H
	jne	SHORT $LN9@stbtt_GetF
	cmp	BYTE PTR [rcx+1], 0
	jmp	$LN29@stbtt_GetF
$LN9@stbtt_GetF:

; 1303 :    if (stbtt_tag(font, "typ1"))   return 1; // TrueType with type 1 font -- we don't support this!

	cmp	al, 116					; 00000074H
	jne	$LN10@stbtt_GetF
	cmp	BYTE PTR [rcx+1], 121			; 00000079H
	jne	SHORT $LN24@stbtt_GetF
	cmp	BYTE PTR [rcx+2], 112			; 00000070H
	jne	SHORT $LN13@stbtt_GetF
	cmp	BYTE PTR [rcx+3], 49			; 00000031H
	jmp	$LN27@stbtt_GetF
$LN24@stbtt_GetF:

; 1306 :    if (stbtt_tag(font, "true"))   return 1; // Apple specification for TrueType fonts

	cmp	BYTE PTR [rcx+1], 114			; 00000072H
	jne	SHORT $LN13@stbtt_GetF
	cmp	BYTE PTR [rcx+2], 117			; 00000075H
	jne	SHORT $LN13@stbtt_GetF
	cmp	BYTE PTR [rcx+3], 101			; 00000065H
	je	$LN23@stbtt_GetF
$LN13@stbtt_GetF:

; 1329 : 
; 1330 :    // check if it's a TTC
; 1331 :    if (stbtt_tag(font_collection, "ttcf")) {

	cmp	al, 116					; 00000074H
	jne	$LN4@stbtt_GetF
	cmp	BYTE PTR [rcx+1], al
	jne	$LN4@stbtt_GetF
	cmp	BYTE PTR [rcx+2], 99			; 00000063H
	jne	$LN4@stbtt_GetF
	cmp	BYTE PTR [rcx+3], 102			; 00000066H
	jne	$LN4@stbtt_GetF

; 1293 : static stbtt_uint32 ttULONG(stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }

	movzx	ecx, BYTE PTR [rcx+5]
	movzx	eax, BYTE PTR [r8+6]
	shl	eax, 8
	shl	ecx, 16
	add	ecx, eax
	movzx	eax, BYTE PTR [r8+4]
	shl	eax, 24
	add	ecx, eax
	movzx	eax, BYTE PTR [r8+7]
	add	eax, -65536				; ffff0000H
	add	ecx, eax

; 1332 :       // version 1?
; 1333 :       if (ttULONG(font_collection+4) == 0x00010000 || ttULONG(font_collection+4) == 0x00020000) {

	test	ecx, -65537				; fffeffffH
	jne	$LN4@stbtt_GetF

; 1294 : static stbtt_int32 ttLONG(stbtt_uint8 *p)    { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }

	movzx	eax, BYTE PTR [r8+9]
	movzx	ecx, BYTE PTR [r8+8]
	shl	ecx, 8
	add	ecx, eax
	movzx	eax, BYTE PTR [r8+10]
	shl	ecx, 8
	add	ecx, eax
	movzx	eax, BYTE PTR [r8+11]
	shl	ecx, 8
	add	ecx, eax

; 1334 :          stbtt_int32 n = ttLONG(font_collection+8);
; 1335 :          if (index >= n)

	cmp	edx, ecx
	jge	SHORT $LN4@stbtt_GetF

; 1336 :             return -1;
; 1337 :          return ttULONG(font_collection+12+index*4);

	lea	eax, DWORD PTR [rdx*4]
	movsxd	rdx, eax
	add	rdx, r8

; 1293 : static stbtt_uint32 ttULONG(stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }

	movzx	ecx, BYTE PTR [rdx+13]
	movzx	eax, BYTE PTR [rdx+12]
	shl	eax, 8
	add	eax, ecx
	movzx	ecx, BYTE PTR [rdx+14]
	shl	eax, 8
	add	eax, ecx
	movzx	ecx, BYTE PTR [rdx+15]
	shl	eax, 8
	add	eax, ecx

; 1341 : }

	ret	0
$LN10@stbtt_GetF:

; 1304 :    if (stbtt_tag(font, "OTTO"))   return 1; // OpenType with CFF

	cmp	al, 79					; 0000004fH
	jne	SHORT $LN11@stbtt_GetF
	cmp	BYTE PTR [rcx+1], 84			; 00000054H
	jne	$LN13@stbtt_GetF
	cmp	BYTE PTR [rcx+2], 84			; 00000054H
	jne	$LN13@stbtt_GetF
	cmp	BYTE PTR [rcx+3], al
	jmp	SHORT $LN27@stbtt_GetF
$LN11@stbtt_GetF:

; 1305 :    if (stbtt_tag4(font, 0,1,0,0)) return 1; // OpenType 1.0

	test	al, al
	jne	$LN13@stbtt_GetF
	cmp	BYTE PTR [rcx+1], 1
$LN29@stbtt_GetF:

; 1326 :    // if it's just a font, there's only one valid index
; 1327 :    if (stbtt__isfont(font_collection))
; 1328 :       return index == 0 ? 0 : -1;

	jne	$LN13@stbtt_GetF
	cmp	BYTE PTR [rcx+2], 0
	jne	$LN13@stbtt_GetF
	cmp	BYTE PTR [rcx+3], 0
$LN27@stbtt_GetF:
	jne	$LN13@stbtt_GetF
$LN23@stbtt_GetF:
	neg	edx
	sbb	eax, eax

; 1341 : }

	ret	0
$LN4@stbtt_GetF:

; 1338 :       }
; 1339 :    }
; 1340 :    return -1;

	mov	eax, -1

; 1341 : }

	ret	0
?stbtt_GetFontOffsetForIndex_internal@@YAHPEAEH@Z ENDP	; stbtt_GetFontOffsetForIndex_internal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__get_subrs@@YA?AUstbtt__buf@@U1@0@Z
_TEXT	SEGMENT
subrsoff$ = 32
operands$1 = 48
$T2 = 48
operands$3 = 48
pdict$ = 48
$T4 = 64
$T5 = 64
private_loc$ = 64
__$ArrayPad$ = 80
__$ReturnAddress$ = 128
cff$ = 136
fontdict$ = 144
?stbtt__get_subrs@@YA?AUstbtt__buf@@U1@0@Z PROC		; stbtt__get_subrs, COMDAT

; 1360 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1361 :    stbtt_uint32 subrsoff = 0, private_loc[2] = { 0, 0 };

	xor	r14d, r14d
	mov	rax, r8
	mov	rbp, rdx
	mov	DWORD PTR subrsoff$[rsp], r14d
	mov	rdi, rcx
	mov	QWORD PTR private_loc$[rsp], r14

; 1254 :    stbtt__buf operands = stbtt__dict_get(b, key);

	mov	rdx, rax
	lea	rcx, QWORD PTR $T2[rsp]
	lea	r8d, QWORD PTR [r14+18]
	call	?stbtt__dict_get@@YA?AUstbtt__buf@@PEAU1@H@Z ; stbtt__dict_get
	mov	ebx, r14d
	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR operands$3[rsp], xmm0
$LL9@stbtt__get:

; 1255 :    for (i = 0; i < outcount && operands.cursor < operands.size; i++)

	mov	eax, DWORD PTR operands$3[rsp+12]
	cmp	DWORD PTR operands$3[rsp+8], eax
	jge	SHORT $LN8@stbtt__get

; 1256 :       out[i] = stbtt__cff_int(&operands);

	lea	rcx, QWORD PTR operands$3[rsp]
	call	?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z	; stbtt__cff_int
	mov	DWORD PTR private_loc$[rsp+rbx*4], eax
	inc	rbx
	cmp	rbx, 2
	jl	SHORT $LL9@stbtt__get
$LN8@stbtt__get:

; 1362 :    stbtt__buf pdict;
; 1363 :    stbtt__dict_get_ints(&fontdict, 18, 2, private_loc);
; 1364 :    if (!private_loc[1] || !private_loc[0]) return stbtt__new_buf(NULL, 0);

	movsxd	rsi, DWORD PTR private_loc$[rsp+4]
	test	esi, esi
	je	$LN14@stbtt__get
	mov	ecx, DWORD PTR private_loc$[rsp]
	test	ecx, ecx
	je	$LN14@stbtt__get

; 1188 :    stbtt__buf r = stbtt__new_buf(NULL, 0);

	mov	QWORD PTR $T5[rsp], r14
	mov	QWORD PTR $T5[rsp+8], r14

; 1189 :    if (o < 0 || s < 0 || o > b->size || s > b->size - o) return r;

	test	esi, esi
	js	SHORT $LN18@stbtt__get
	test	ecx, ecx
	js	SHORT $LN18@stbtt__get
	mov	eax, DWORD PTR [rbp+12]
	cmp	esi, eax
	jg	SHORT $LN18@stbtt__get
	sub	eax, esi
	cmp	ecx, eax
	jg	SHORT $LN18@stbtt__get

; 1190 :    r.data = b->data + o;

	mov	rax, rsi

; 1191 :    r.size = s;

	mov	DWORD PTR $T5[rsp+12], ecx
	add	rax, QWORD PTR [rbp]
	mov	QWORD PTR $T5[rsp], rax
$LN18@stbtt__get:

; 1365 :    pdict = stbtt__buf_range(&cff, private_loc[1], private_loc[0]);

	movaps	xmm0, XMMWORD PTR $T5[rsp]

; 1254 :    stbtt__buf operands = stbtt__dict_get(b, key);

	lea	rdx, QWORD PTR pdict$[rsp]
	mov	r8d, 19

; 1365 :    pdict = stbtt__buf_range(&cff, private_loc[1], private_loc[0]);

	movdqa	XMMWORD PTR pdict$[rsp], xmm0

; 1254 :    stbtt__buf operands = stbtt__dict_get(b, key);

	lea	rcx, QWORD PTR $T4[rsp]
	call	?stbtt__dict_get@@YA?AUstbtt__buf@@PEAU1@H@Z ; stbtt__dict_get
	mov	rbx, r14
	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR operands$1[rsp], xmm0
	npad	9
$LL28@stbtt__get:

; 1255 :    for (i = 0; i < outcount && operands.cursor < operands.size; i++)

	mov	eax, DWORD PTR operands$1[rsp+12]
	cmp	DWORD PTR operands$1[rsp+8], eax
	jge	SHORT $LN27@stbtt__get

; 1256 :       out[i] = stbtt__cff_int(&operands);

	lea	rcx, QWORD PTR operands$1[rsp]
	call	?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z	; stbtt__cff_int
	mov	DWORD PTR subrsoff$[rsp+rbx*4], eax
	inc	rbx
	cmp	rbx, 1
	jl	SHORT $LL28@stbtt__get
$LN27@stbtt__get:

; 1366 :    stbtt__dict_get_ints(&pdict, 19, 1, &subrsoff);
; 1367 :    if (!subrsoff) return stbtt__new_buf(NULL, 0);

	mov	eax, DWORD PTR subrsoff$[rsp]
	test	eax, eax
	je	SHORT $LN14@stbtt__get

; 1155 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

	mov	ecx, DWORD PTR [rbp+12]

; 1368 :    stbtt__buf_seek(&cff, private_loc[1]+subrsoff);

	add	eax, esi

; 1155 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

	cmp	eax, ecx
	jg	SHORT $LN40@stbtt__get
	test	eax, eax
	jns	SHORT $LN41@stbtt__get
$LN40@stbtt__get:
	mov	eax, ecx
$LN41@stbtt__get:

; 1369 :    return stbtt__cff_get_index(&cff);

	mov	rdx, rbp

; 1155 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

	mov	DWORD PTR [rbp+8], eax

; 1369 :    return stbtt__cff_get_index(&cff);

	mov	rcx, rdi
	call	?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z ; stbtt__cff_get_index
	jmp	SHORT $LN60@stbtt__get
$LN14@stbtt__get:

; 1370 : }

	mov	QWORD PTR [rdi+8], r14
	mov	QWORD PTR [rdi], r14
$LN60@stbtt__get:
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+96]
	mov	rbx, QWORD PTR [r11+32]
	mov	rbp, QWORD PTR [r11+56]
	mov	rsp, r11
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
?stbtt__get_subrs@@YA?AUstbtt__buf@@U1@0@Z ENDP		; stbtt__get_subrs
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt_InitFont_internal@@YAHPEAUstbtt_fontinfo@@PEAEH@Z
_TEXT	SEGMENT
$T1 = 32
operands$2 = 32
$T3 = 32
operands$4 = 32
$T5 = 32
operands$6 = 32
$T7 = 32
operands$8 = 32
$T9 = 32
$T10 = 32
$T11 = 32
$T12 = 32
$T13 = 32
$T14 = 32
fontstart$GSCopy$1$ = 48
$T15 = 56
$T16 = 56
$T17 = 56
tv1351 = 72
fdselectoff$18 = 72
b$19 = 80
tv1352 = 96
fdarrayoff$20 = 96
$T21 = 112
$T22 = 112
$T23 = 112
topdict$24 = 112
cstype$25 = 128
charstrings$26 = 132
__$ArrayPad$ = 136
info$ = 224
data$ = 232
fontstart$ = 240
?stbtt_InitFont_internal@@YAHPEAUstbtt_fontinfo@@PEAEH@Z PROC ; stbtt_InitFont_internal, COMDAT

; 1389 : {

	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-39]
	sub	rsp, 160				; 000000a0H
	movaps	XMMWORD PTR [rsp+144], xmm6
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-121], rax

; 1390 :    stbtt_uint32 cmap, t;
; 1391 :    stbtt_int32 i,numTables;
; 1392 : 
; 1393 :    info->data = data;

	mov	QWORD PTR [rcx+8], rdx
	mov	r15, rdx

; 1394 :    info->fontstart = fontstart;

	mov	DWORD PTR [rcx+16], r8d

; 1395 :    info->cff = stbtt__new_buf(NULL, 0);

	xor	ebx, ebx
	mov	QWORD PTR [rcx+64], rbx
	mov	r13d, r8d
	mov	QWORD PTR [rcx+72], rbx
	mov	rdi, rcx
	mov	DWORD PTR fontstart$GSCopy$1$[rbp-121], r8d

; 1396 : 
; 1397 :    cmap = stbtt__find_table(data, fontstart, "cmap");       // required

	mov	rcx, r15
	lea	r8, OFFSET FLAT:??_C@_04EICJPCEA@cmap@
	mov	edx, r13d
	call	?stbtt__find_table@@YAIPEAEIPEBD@Z	; stbtt__find_table

; 1398 :    info->loca = stbtt__find_table(data, fontstart, "loca"); // required

	mov	edx, r13d
	mov	r14d, eax
	mov	rcx, r15
	lea	r8, OFFSET FLAT:??_C@_04DACNFKGE@loca@
	call	?stbtt__find_table@@YAIPEAEIPEBD@Z	; stbtt__find_table

; 1399 :    info->head = stbtt__find_table(data, fontstart, "head"); // required

	mov	edx, r13d
	mov	DWORD PTR [rdi+24], eax
	mov	rcx, r15
	lea	r8, OFFSET FLAT:??_C@_04NEODDMOL@head@
	mov	esi, eax
	call	?stbtt__find_table@@YAIPEAEIPEBD@Z	; stbtt__find_table

; 1400 :    info->glyf = stbtt__find_table(data, fontstart, "glyf"); // required

	mov	edx, r13d
	mov	DWORD PTR [rdi+28], eax
	mov	rcx, r15
	lea	r8, OFFSET FLAT:??_C@_04LLIHEPK@glyf@
	mov	r12d, eax
	call	?stbtt__find_table@@YAIPEAEIPEBD@Z	; stbtt__find_table

; 1401 :    info->hhea = stbtt__find_table(data, fontstart, "hhea"); // required

	mov	edx, r13d
	mov	DWORD PTR tv1352[rbp-121], eax
	mov	rcx, r15
	mov	DWORD PTR [rdi+32], eax
	lea	r8, OFFSET FLAT:??_C@_04FMPHLIKP@hhea@
	call	?stbtt__find_table@@YAIPEAEIPEBD@Z	; stbtt__find_table

; 1402 :    info->hmtx = stbtt__find_table(data, fontstart, "hmtx"); // required

	mov	edx, DWORD PTR fontstart$GSCopy$1$[rbp-121]
	lea	r8, OFFSET FLAT:??_C@_04ONMNCIMC@hmtx@
	mov	rcx, r15
	mov	DWORD PTR [rdi+36], eax
	mov	r13d, eax
	call	?stbtt__find_table@@YAIPEAEIPEBD@Z	; stbtt__find_table

; 1403 :    info->kern = stbtt__find_table(data, fontstart, "kern"); // not required

	mov	edx, DWORD PTR fontstart$GSCopy$1$[rbp-121]
	lea	r8, OFFSET FLAT:??_C@_04HHMMLDJI@kern@
	mov	rcx, r15
	mov	DWORD PTR tv1351[rbp-121], eax
	mov	DWORD PTR [rdi+40], eax
	call	?stbtt__find_table@@YAIPEAEIPEBD@Z	; stbtt__find_table

; 1404 :    info->gpos = stbtt__find_table(data, fontstart, "GPOS"); // not required

	mov	edx, DWORD PTR fontstart$GSCopy$1$[rbp-121]
	lea	r8, OFFSET FLAT:??_C@_04PCFDEHHD@GPOS@
	mov	rcx, r15
	mov	DWORD PTR [rdi+44], eax
	call	?stbtt__find_table@@YAIPEAEIPEBD@Z	; stbtt__find_table
	mov	DWORD PTR [rdi+48], eax

; 1405 : 
; 1406 :    if (!cmap || !info->head || !info->hhea || !info->hmtx)

	test	r14d, r14d
	je	SHORT $LN10@stbtt_Init
	test	r12d, r12d
	je	SHORT $LN10@stbtt_Init
	test	r13d, r13d
	je	SHORT $LN10@stbtt_Init
	cmp	DWORD PTR tv1351[rbp-121], ebx
	je	SHORT $LN10@stbtt_Init

; 1408 :    if (info->glyf) {

	cmp	DWORD PTR tv1352[rbp-121], ebx
	je	SHORT $LN11@stbtt_Init

; 1409 :       // required for truetype
; 1410 :       if (!info->loca) return 0;

	test	esi, esi
	jne	$LN12@stbtt_Init
$LN10@stbtt_Init:

; 1407 :       return 0;

	xor	eax, eax
$LN1@stbtt_Init:

; 1499 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-121]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+248]
	movaps	xmm6, XMMWORD PTR [rsp+144]
	add	rsp, 160				; 000000a0H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN11@stbtt_Init:

; 1411 :    } else {
; 1412 :       // initialization for CFF / Type2 fonts (OTF)
; 1413 :       stbtt__buf b, topdict, topdictidx;
; 1414 :       stbtt_uint32 cstype = 2, charstrings = 0, fdarrayoff = 0, fdselectoff = 0;
; 1415 :       stbtt_uint32 cff;
; 1416 : 
; 1417 :       cff = stbtt__find_table(data, fontstart, "CFF ");

	mov	edx, DWORD PTR fontstart$GSCopy$1$[rbp-121]
	lea	r8, OFFSET FLAT:??_C@_04HJGCPIEK@CFF?5@
	mov	rcx, r15
	mov	DWORD PTR cstype$25[rbp-121], 2
	mov	DWORD PTR charstrings$26[rbp-121], ebx
	mov	DWORD PTR fdarrayoff$20[rbp-121], ebx
	mov	DWORD PTR fdselectoff$18[rbp-121], ebx
	call	?stbtt__find_table@@YAIPEAEIPEBD@Z	; stbtt__find_table

; 1418 :       if (!cff) return 0;

	test	eax, eax
	je	SHORT $LN10@stbtt_Init

; 1419 : 
; 1420 :       info->fontdicts = stbtt__new_buf(NULL, 0);

	mov	QWORD PTR [rdi+128], rbx
	mov	QWORD PTR [rdi+136], rbx

; 1421 :       info->fdselect = stbtt__new_buf(NULL, 0);

	mov	QWORD PTR [rdi+144], rbx
	mov	QWORD PTR [rdi+152], rbx

; 1422 : 
; 1423 :       // @TODO this should use size from table (not 512MB)
; 1424 :       info->cff = stbtt__new_buf(data+cff, 512*1024*1024);

	mov	eax, eax
	add	rax, r15
	mov	QWORD PTR [rdi+64], rax
	mov	DWORD PTR [rdi+72], ebx
	mov	DWORD PTR [rdi+76], 536870912		; 20000000H

; 1425 :       b = info->cff;

	movups	xmm2, XMMWORD PTR [rdi+64]

; 1160 :    stbtt__buf_seek(b, b->cursor + o);

	mov	ecx, DWORD PTR [rdi+72]

; 1155 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

	mov	rax, QWORD PTR [rdi+72]

; 1160 :    stbtt__buf_seek(b, b->cursor + o);

	add	ecx, 2

; 1155 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

	movdqa	xmm0, xmm2
	shr	rax, 32					; 00000020H
	psrldq	xmm0, 12
	movd	edx, xmm0

; 1425 :       b = info->cff;

	movaps	XMMWORD PTR b$19[rbp-121], xmm2

; 1155 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

	cmp	ecx, eax
	jg	SHORT $LN143@stbtt_Init
	test	ecx, ecx
	js	SHORT $LN143@stbtt_Init

; 1140 :    if (b->cursor >= b->size)

	cmp	ecx, edx
	jge	SHORT $LN143@stbtt_Init

; 1142 :    return b->data[b->cursor++];

	movsxd	rcx, ecx
	movq	rax, xmm2
	movzx	r8d, BYTE PTR [rcx+rax]
	jmp	SHORT $LN66@stbtt_Init
$LN143@stbtt_Init:

; 1141 :       return 0;

	xor	r8b, r8b
$LN66@stbtt_Init:

; 1426 : 
; 1427 :       // read the header
; 1428 :       stbtt__buf_skip(&b, 2);
; 1429 :       stbtt__buf_seek(&b, stbtt__buf_get8(&b)); // hdrsize

	movzx	eax, r8b

; 1430 : 
; 1431 :       // @TODO the name INDEX could list multiple fonts,
; 1432 :       // but we just use the first one.
; 1433 :       stbtt__cff_get_index(&b);  // name INDEX

	lea	rcx, QWORD PTR $T14[rbp-121]

; 1155 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

	cmp	eax, edx
	cmovle	edx, eax
	mov	DWORD PTR b$19[rbp-113], edx

; 1430 : 
; 1431 :       // @TODO the name INDEX could list multiple fonts,
; 1432 :       // but we just use the first one.
; 1433 :       stbtt__cff_get_index(&b);  // name INDEX

	lea	rdx, QWORD PTR b$19[rbp-121]
	call	?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z ; stbtt__cff_get_index

; 1434 :       topdictidx = stbtt__cff_get_index(&b);

	lea	rdx, QWORD PTR b$19[rbp-121]
	lea	rcx, QWORD PTR $T13[rbp-121]
	call	?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z ; stbtt__cff_get_index

; 1435 :       topdict = stbtt__cff_index_get(topdictidx, 0);

	xor	r8d, r8d
	lea	rdx, QWORD PTR $T10[rbp-121]
	lea	rcx, QWORD PTR $T23[rbp-121]
	movups	xmm0, XMMWORD PTR [rax]
	movaps	XMMWORD PTR $T10[rbp-121], xmm0
	call	?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z ; stbtt__cff_index_get

; 1436 :       stbtt__cff_get_index(&b);  // string INDEX

	lea	rdx, QWORD PTR b$19[rbp-121]
	lea	rcx, QWORD PTR $T12[rbp-121]
	movups	xmm0, XMMWORD PTR [rax]
	movaps	XMMWORD PTR topdict$24[rbp-121], xmm0
	call	?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z ; stbtt__cff_get_index

; 1437 :       info->gsubrs = stbtt__cff_get_index(&b);

	lea	rdx, QWORD PTR b$19[rbp-121]
	lea	rcx, QWORD PTR $T11[rbp-121]
	call	?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z ; stbtt__cff_get_index

; 1254 :    stbtt__buf operands = stbtt__dict_get(b, key);

	mov	r8d, 17
	lea	rdx, QWORD PTR topdict$24[rbp-121]
	lea	rcx, QWORD PTR $T7[rbp-121]

; 1437 :       info->gsubrs = stbtt__cff_get_index(&b);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR [rdi+96], xmm0

; 1254 :    stbtt__buf operands = stbtt__dict_get(b, key);

	call	?stbtt__dict_get@@YA?AUstbtt__buf@@PEAU1@H@Z ; stbtt__dict_get
	mov	rsi, rbx
	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR operands$8[rbp-121], xmm0
$LL79@stbtt_Init:

; 1255 :    for (i = 0; i < outcount && operands.cursor < operands.size; i++)

	mov	eax, DWORD PTR operands$8[rbp-109]
	cmp	DWORD PTR operands$8[rbp-113], eax
	jge	SHORT $LN78@stbtt_Init

; 1256 :       out[i] = stbtt__cff_int(&operands);

	lea	rcx, QWORD PTR operands$8[rbp-121]
	call	?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z	; stbtt__cff_int
	mov	DWORD PTR charstrings$26[rbp+rsi*4-121], eax
	inc	rsi
	cmp	rsi, 1
	jl	SHORT $LL79@stbtt_Init
$LN78@stbtt_Init:

; 1254 :    stbtt__buf operands = stbtt__dict_get(b, key);

	mov	r8d, 262				; 00000106H
	lea	rdx, QWORD PTR topdict$24[rbp-121]
	lea	rcx, QWORD PTR $T5[rbp-121]
	call	?stbtt__dict_get@@YA?AUstbtt__buf@@PEAU1@H@Z ; stbtt__dict_get
	mov	rsi, rbx
	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR operands$6[rbp-121], xmm0
	npad	4
$LL84@stbtt_Init:

; 1255 :    for (i = 0; i < outcount && operands.cursor < operands.size; i++)

	mov	eax, DWORD PTR operands$6[rbp-109]
	cmp	DWORD PTR operands$6[rbp-113], eax
	jge	SHORT $LN83@stbtt_Init

; 1256 :       out[i] = stbtt__cff_int(&operands);

	lea	rcx, QWORD PTR operands$6[rbp-121]
	call	?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z	; stbtt__cff_int
	mov	DWORD PTR cstype$25[rbp+rsi*4-121], eax
	inc	rsi
	cmp	rsi, 1
	jl	SHORT $LL84@stbtt_Init
$LN83@stbtt_Init:

; 1254 :    stbtt__buf operands = stbtt__dict_get(b, key);

	mov	r8d, 292				; 00000124H
	lea	rdx, QWORD PTR topdict$24[rbp-121]
	lea	rcx, QWORD PTR $T3[rbp-121]
	call	?stbtt__dict_get@@YA?AUstbtt__buf@@PEAU1@H@Z ; stbtt__dict_get
	mov	rsi, rbx
	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR operands$4[rbp-121], xmm0
	npad	5
$LL89@stbtt_Init:

; 1255 :    for (i = 0; i < outcount && operands.cursor < operands.size; i++)

	mov	eax, DWORD PTR operands$4[rbp-109]
	cmp	DWORD PTR operands$4[rbp-113], eax
	jge	SHORT $LN88@stbtt_Init

; 1256 :       out[i] = stbtt__cff_int(&operands);

	lea	rcx, QWORD PTR operands$4[rbp-121]
	call	?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z	; stbtt__cff_int
	mov	DWORD PTR fdarrayoff$20[rbp+rsi*4-121], eax
	inc	rsi
	cmp	rsi, 1
	jl	SHORT $LL89@stbtt_Init
$LN88@stbtt_Init:

; 1254 :    stbtt__buf operands = stbtt__dict_get(b, key);

	mov	r8d, 293				; 00000125H
	lea	rdx, QWORD PTR topdict$24[rbp-121]
	lea	rcx, QWORD PTR $T1[rbp-121]
	call	?stbtt__dict_get@@YA?AUstbtt__buf@@PEAU1@H@Z ; stbtt__dict_get
	mov	rsi, rbx
	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR operands$2[rbp-121], xmm0
	npad	5
$LL94@stbtt_Init:

; 1255 :    for (i = 0; i < outcount && operands.cursor < operands.size; i++)

	mov	eax, DWORD PTR operands$2[rbp-109]
	cmp	DWORD PTR operands$2[rbp-113], eax
	jge	SHORT $LN93@stbtt_Init

; 1256 :       out[i] = stbtt__cff_int(&operands);

	lea	rcx, QWORD PTR operands$2[rbp-121]
	call	?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z	; stbtt__cff_int
	mov	DWORD PTR fdselectoff$18[rbp+rsi*4-121], eax
	inc	rsi
	cmp	rsi, 1
	jl	SHORT $LL94@stbtt_Init
$LN93@stbtt_Init:

; 1438 : 
; 1439 :       stbtt__dict_get_ints(&topdict, 17, 1, &charstrings);
; 1440 :       stbtt__dict_get_ints(&topdict, 0x100 | 6, 1, &cstype);
; 1441 :       stbtt__dict_get_ints(&topdict, 0x100 | 36, 1, &fdarrayoff);
; 1442 :       stbtt__dict_get_ints(&topdict, 0x100 | 37, 1, &fdselectoff);
; 1443 :       info->subrs = stbtt__get_subrs(b, topdict);

	movaps	xmm0, XMMWORD PTR topdict$24[rbp-121]
	lea	r8, QWORD PTR $T9[rbp-121]
	movaps	xmm6, XMMWORD PTR b$19[rbp-121]
	lea	rdx, QWORD PTR $T21[rbp-121]
	lea	rcx, QWORD PTR $T17[rbp-121]
	movdqa	XMMWORD PTR $T9[rbp-121], xmm0
	movdqa	XMMWORD PTR $T21[rbp-121], xmm6
	call	?stbtt__get_subrs@@YA?AUstbtt__buf@@U1@0@Z ; stbtt__get_subrs

; 1444 : 
; 1445 :       // we only support Type 2 charstrings
; 1446 :       if (cstype != 2) return 0;

	cmp	DWORD PTR cstype$25[rbp-121], 2
	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR [rdi+112], xmm0
	jne	$LN10@stbtt_Init

; 1447 :       if (charstrings == 0) return 0;

	mov	r12d, DWORD PTR charstrings$26[rbp-121]
	test	r12d, r12d
	je	$LN10@stbtt_Init

; 1448 : 
; 1449 :       if (fdarrayoff) {

	mov	eax, DWORD PTR fdarrayoff$20[rbp-121]
	test	eax, eax
	je	SHORT $LN150@stbtt_Init

; 1450 :          // looks like a CID font
; 1451 :          if (!fdselectoff) return 0;

	movsxd	rsi, DWORD PTR fdselectoff$18[rbp-121]
	test	esi, esi
	je	$LN10@stbtt_Init

; 1155 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

	psrldq	xmm6, 12
	movd	ecx, xmm6
	cmp	eax, ecx
	jg	SHORT $LN112@stbtt_Init
	mov	DWORD PTR b$19[rbp-113], eax
	test	eax, eax
	jns	SHORT $LN113@stbtt_Init
$LN112@stbtt_Init:
	mov	DWORD PTR b$19[rbp-113], ecx
$LN113@stbtt_Init:

; 1452 :          stbtt__buf_seek(&b, fdarrayoff);
; 1453 :          info->fontdicts = stbtt__cff_get_index(&b);

	lea	rdx, QWORD PTR b$19[rbp-121]
	lea	rcx, QWORD PTR $T16[rbp-121]
	call	?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z ; stbtt__cff_get_index

; 1454 :          info->fdselect = stbtt__buf_range(&b, fdselectoff, b.size-fdselectoff);

	mov	ecx, DWORD PTR b$19[rbp-109]
	mov	edx, ecx
	sub	edx, esi

; 1188 :    stbtt__buf r = stbtt__new_buf(NULL, 0);

	mov	QWORD PTR $T22[rbp-121], rbx
	mov	QWORD PTR $T22[rbp-113], rbx

; 1452 :          stbtt__buf_seek(&b, fdarrayoff);
; 1453 :          info->fontdicts = stbtt__cff_get_index(&b);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR [rdi+128], xmm0

; 1189 :    if (o < 0 || s < 0 || o > b->size || s > b->size - o) return r;

	test	esi, esi
	js	SHORT $LN116@stbtt_Init
	test	edx, edx
	js	SHORT $LN116@stbtt_Init
	cmp	esi, ecx
	jg	SHORT $LN116@stbtt_Init

; 1190 :    r.data = b->data + o;

	mov	rax, rsi

; 1191 :    r.size = s;

	mov	DWORD PTR $T22[rbp-109], edx
	add	rax, QWORD PTR b$19[rbp-121]
	mov	QWORD PTR $T22[rbp-121], rax
$LN116@stbtt_Init:

; 1454 :          info->fdselect = stbtt__buf_range(&b, fdselectoff, b.size-fdselectoff);

	movups	xmm0, XMMWORD PTR $T22[rbp-121]
	movups	XMMWORD PTR [rdi+144], xmm0
	jmp	SHORT $LN17@stbtt_Init
$LN150@stbtt_Init:

; 1448 : 
; 1449 :       if (fdarrayoff) {

	mov	ecx, DWORD PTR b$19[rbp-109]
$LN17@stbtt_Init:

; 1155 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

	cmp	r12d, ecx
	jg	SHORT $LN105@stbtt_Init
	mov	DWORD PTR b$19[rbp-113], r12d
	test	r12d, r12d
	jns	SHORT $LN106@stbtt_Init
$LN105@stbtt_Init:
	mov	DWORD PTR b$19[rbp-113], ecx
$LN106@stbtt_Init:

; 1455 :       }
; 1456 : 
; 1457 :       stbtt__buf_seek(&b, charstrings);
; 1458 :       info->charstrings = stbtt__cff_get_index(&b);

	lea	rdx, QWORD PTR b$19[rbp-121]
	lea	rcx, QWORD PTR $T15[rbp-121]
	call	?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z ; stbtt__cff_get_index
	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR [rdi+80], xmm0
$LN12@stbtt_Init:

; 1459 :    }
; 1460 : 
; 1461 :    t = stbtt__find_table(data, fontstart, "maxp");

	mov	edx, DWORD PTR fontstart$GSCopy$1$[rbp-121]
	lea	r8, OFFSET FLAT:??_C@_04KODIGLGG@maxp@
	mov	rcx, r15
	call	?stbtt__find_table@@YAIPEAEIPEBD@Z	; stbtt__find_table

; 1462 :    if (t)

	test	eax, eax
	je	SHORT $LN19@stbtt_Init

; 1463 :       info->numGlyphs = ttUSHORT(data+t+4);

	mov	eax, eax
	movzx	ecx, BYTE PTR [rax+r15+4]
	movzx	eax, BYTE PTR [rax+r15+5]
	shl	ecx, 8
	add	ecx, eax
	jmp	SHORT $LN20@stbtt_Init
$LN19@stbtt_Init:

; 1464 :    else
; 1465 :       info->numGlyphs = 0xffff;

	mov	ecx, 65535				; 0000ffffH
$LN20@stbtt_Init:

; 1466 : 
; 1467 :    info->svg = -1;

	mov	DWORD PTR [rdi+20], ecx
	mov	DWORD PTR [rdi+52], -1

; 1468 : 
; 1469 :    // find a cmap encoding table we understand *now* to avoid searching
; 1470 :    // later. (todo: could make this installable)
; 1471 :    // the same regardless of glyph.
; 1472 :    numTables = ttUSHORT(data + cmap + 2);

	movzx	r9d, BYTE PTR [r14+r15+2]
	movzx	eax, BYTE PTR [r14+r15+3]
	shl	r9d, 8

; 1473 :    info->index_map = 0;

	mov	DWORD PTR [rdi+56], ebx
	add	r9d, eax

; 1474 :    for (i=0; i < numTables; ++i) {

	je	$LN3@stbtt_Init
	npad	12
$LL4@stbtt_Init:

; 1475 :       stbtt_uint32 encoding_record = cmap + 4 + 8 * i;

	lea	eax, DWORD PTR [r14+4]
	lea	eax, DWORD PTR [rax+rbx*8]

; 1476 :       // find an encoding we understand:
; 1477 :       switch(ttUSHORT(data+encoding_record)) {

	movzx	r8d, BYTE PTR [rax+r15]
	mov	ecx, eax
	movzx	eax, BYTE PTR [rax+r15+1]
	shl	r8d, 8
	add	r8d, eax
	je	SHORT $LN24@stbtt_Init
	cmp	r8d, 3
	jne	SHORT $LN2@stbtt_Init

; 1478 :          case STBTT_PLATFORM_ID_MICROSOFT:
; 1479 :             switch (ttUSHORT(data+encoding_record+2)) {

	movzx	edx, BYTE PTR [rcx+r15+2]
	movzx	eax, BYTE PTR [rcx+r15+3]
	shl	edx, 8
	add	edx, eax
	sub	edx, 1
	je	SHORT $LN22@stbtt_Init
	cmp	edx, 9
	jne	SHORT $LN2@stbtt_Init
$LN22@stbtt_Init:

; 1293 : static stbtt_uint32 ttULONG(stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }

	movzx	r8d, BYTE PTR [rcx+r15+4]
	movzx	eax, BYTE PTR [rcx+r15+5]
	shl	r8d, 8

; 1480 :                case STBTT_MS_EID_UNICODE_BMP:
; 1481 :                case STBTT_MS_EID_UNICODE_FULL:
; 1482 :                   // MS/Unicode
; 1483 :                   info->index_map = cmap + ttULONG(data+encoding_record+4);
; 1484 :                   break;
; 1485 :             }
; 1486 :             break;

	jmp	SHORT $LN181@stbtt_Init
$LN24@stbtt_Init:

; 1293 : static stbtt_uint32 ttULONG(stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }

	movzx	eax, BYTE PTR [rcx+r15+4]
	movzx	r8d, BYTE PTR [rcx+r15+5]
	shl	eax, 8
$LN181@stbtt_Init:

; 1474 :    for (i=0; i < numTables; ++i) {

	movzx	edx, BYTE PTR [rcx+r15+7]
	add	r8d, eax
	movzx	eax, BYTE PTR [rcx+r15+6]
	shl	r8d, 8
	add	eax, r8d
	shl	eax, 8
	add	eax, r14d
	add	edx, eax
	mov	DWORD PTR [rdi+56], edx
$LN2@stbtt_Init:
	inc	ebx
	cmp	ebx, r9d
	jl	$LL4@stbtt_Init
$LN3@stbtt_Init:

; 1487 :         case STBTT_PLATFORM_ID_UNICODE:
; 1488 :             // Mac/iOS has these
; 1489 :             // all the encodingIDs are unicode, so we don't bother to check it
; 1490 :             info->index_map = cmap + ttULONG(data+encoding_record+4);
; 1491 :             break;
; 1492 :       }
; 1493 :    }
; 1494 :    if (info->index_map == 0)

	cmp	DWORD PTR [rdi+56], 0
	je	$LN10@stbtt_Init

; 1495 :       return 0;
; 1496 : 
; 1497 :    info->indexToLocFormat = ttUSHORT(data+info->head + 50);

	movsxd	rax, DWORD PTR [rdi+28]
	movzx	ecx, BYTE PTR [rax+r15+50]
	movzx	eax, BYTE PTR [rax+r15+51]
	shl	ecx, 8
	add	ecx, eax

; 1498 :    return 1;

	mov	eax, 1
	mov	DWORD PTR [rdi+60], ecx
	jmp	$LN1@stbtt_Init
?stbtt_InitFont_internal@@YAHPEAUstbtt_fontinfo@@PEAEH@Z ENDP ; stbtt_InitFont_internal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT stbtt_FindGlyphIndex
_TEXT	SEGMENT
info$ = 40
unicode_codepoint$ = 48
stbtt_FindGlyphIndex PROC				; COMDAT

; 1502 : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r12
	push	r13
	push	r15

; 1503 :    stbtt_uint8 *data = info->data;

	mov	rdi, QWORD PTR [rcx+8]

; 1291 : static stbtt_uint16 ttUSHORT(stbtt_uint8 *p) { return p[0]*256 + p[1]; }

	mov	r12d, 256				; 00000100H

; 1502 : {

	movsxd	r9, edx

; 1504 :    stbtt_uint32 index_map = info->index_map;

	mov	edx, DWORD PTR [rcx+56]

; 1505 : 
; 1506 :    stbtt_uint16 format = ttUSHORT(data + index_map + 0);

	mov	ebp, edx

; 1291 : static stbtt_uint16 ttUSHORT(stbtt_uint8 *p) { return p[0]*256 + p[1]; }

	movzx	esi, BYTE PTR [rdi+rdx]
	movzx	eax, BYTE PTR [rdi+rdx+1]
	imul	esi, r12d
	add	si, ax

; 1507 :    if (format == 0) { // apple byte encoding

	jne	SHORT $LN12@stbtt_Find

; 1508 :       stbtt_int32 bytes = ttUSHORT(data + index_map + 2);

	movzx	ecx, BYTE PTR [rdi+rdx+2]
	movzx	eax, BYTE PTR [rdi+rdx+3]
	shl	ecx, 8
	add	eax, -6
	add	ecx, eax

; 1509 :       if (unicode_codepoint < bytes-6)

	cmp	r9d, ecx
	jge	$LN8@stbtt_Find

; 1510 :          return ttBYTE(data + index_map + 6 + unicode_codepoint);

	lea	rax, QWORD PTR [r9+rdx]
	movzx	eax, BYTE PTR [rax+rdi+6]
	jmp	$LN1@stbtt_Find
$LN12@stbtt_Find:

; 1511 :       return 0;
; 1512 :    } else if (format == 6) {

	cmp	si, 6
	jne	SHORT $LN15@stbtt_Find

; 1513 :       stbtt_uint32 first = ttUSHORT(data + index_map + 6);

	movzx	eax, BYTE PTR [rdi+rbp+6]
	movzx	edx, BYTE PTR [rdi+rdx+7]
	shl	eax, 8
	add	edx, eax

; 1515 :       if ((stbtt_uint32) unicode_codepoint >= first && (stbtt_uint32) unicode_codepoint < first+count)

	cmp	r9d, edx
	jb	$LN8@stbtt_Find

; 1514 :       stbtt_uint32 count = ttUSHORT(data + index_map + 8);

	movzx	eax, BYTE PTR [rdi+rbp+9]
	movzx	ecx, BYTE PTR [rdi+rbp+8]

; 1515 :       if ((stbtt_uint32) unicode_codepoint >= first && (stbtt_uint32) unicode_codepoint < first+count)

	add	eax, edx
	shl	ecx, 8
	add	ecx, eax
	cmp	r9d, ecx
	jae	$LN8@stbtt_Find

; 1516 :          return ttUSHORT(data + index_map + 10 + (unicode_codepoint - first)*2);

	sub	r9d, edx
	lea	eax, DWORD PTR [r9+r9]
	add	rax, rbp
	movzx	edx, BYTE PTR [rax+rdi+10]
	movzx	eax, BYTE PTR [rax+rdi+11]
	shl	edx, 8
	add	eax, edx
	jmp	$LN1@stbtt_Find
$LN15@stbtt_Find:

; 1517 :       return 0;
; 1518 :    } else if (format == 2) {

	cmp	si, 2
	je	$LN8@stbtt_Find

; 1519 :       STBTT_assert(0); // @TODO: high-byte mapping for japanese/chinese/korean
; 1520 :       return 0;
; 1521 :    } else if (format == 4) { // standard mapping for windows fonts: binary search collection of ranges

	cmp	si, 4
	jne	$LN20@stbtt_Find

; 1291 : static stbtt_uint16 ttUSHORT(stbtt_uint8 *p) { return p[0]*256 + p[1]; }

	movzx	eax, BYTE PTR [rdi+rdx+7]

; 1524 :       stbtt_uint16 entrySelector = ttUSHORT(data+index_map+10);
; 1525 :       stbtt_uint16 rangeShift = ttUSHORT(data+index_map+12) >> 1;

	lea	esi, DWORD PTR [rdx+14]

; 1291 : static stbtt_uint16 ttUSHORT(stbtt_uint8 *p) { return p[0]*256 + p[1]; }

	movzx	r15d, BYTE PTR [rdi+rdx+6]

; 1526 : 
; 1527 :       // do a binary search of the segments
; 1528 :       stbtt_uint32 endCount = index_map + 14;
; 1529 :       stbtt_uint32 search = endCount;
; 1530 : 
; 1531 :       if (unicode_codepoint > 0xffff)

	mov	r13d, 65535				; 0000ffffH

; 1291 : static stbtt_uint16 ttUSHORT(stbtt_uint8 *p) { return p[0]*256 + p[1]; }

	movzx	r11d, BYTE PTR [rdi+rdx+8]
	movzx	ebx, BYTE PTR [rdi+rdx+10]
	imul	r15d, r12d
	imul	r11d, r12d
	imul	ebx, r12d
	add	r15w, ax
	movzx	eax, BYTE PTR [rdi+rdx+9]
	add	r11w, ax

; 1522 :       stbtt_uint16 segcount = ttUSHORT(data+index_map+6) >> 1;

	shr	r15w, 1

; 1291 : static stbtt_uint16 ttUSHORT(stbtt_uint8 *p) { return p[0]*256 + p[1]; }

	movzx	eax, BYTE PTR [rdi+rdx+11]
	add	bx, ax

; 1523 :       stbtt_uint16 searchRange = ttUSHORT(data+index_map+8) >> 1;

	shr	r11w, 1

; 1526 : 
; 1527 :       // do a binary search of the segments
; 1528 :       stbtt_uint32 endCount = index_map + 14;
; 1529 :       stbtt_uint32 search = endCount;
; 1530 : 
; 1531 :       if (unicode_codepoint > 0xffff)

	cmp	r9d, r13d
	jg	$LN8@stbtt_Find

; 1291 : static stbtt_uint16 ttUSHORT(stbtt_uint8 *p) { return p[0]*256 + p[1]; }

	movzx	eax, BYTE PTR [rdi+rdx+13]
	movzx	ecx, BYTE PTR [rdi+rdx+12]
	shl	ecx, 8
	add	ecx, eax

; 1526 : 
; 1527 :       // do a binary search of the segments
; 1528 :       stbtt_uint32 endCount = index_map + 14;
; 1529 :       stbtt_uint32 search = endCount;
; 1530 : 
; 1531 :       if (unicode_codepoint > 0xffff)

	mov	QWORD PTR [rsp+40], r14
	shr	ecx, 1

; 1532 :          return 0;
; 1533 : 
; 1534 :       // they lie from endCount .. endCount + segCount
; 1535 :       // but searchRange is the nearest power of two, so...
; 1536 :       if (unicode_codepoint >= ttUSHORT(data + search + rangeShift*2))

	mov	r14d, esi
	lea	edx, DWORD PTR [rcx+rcx]
	mov	eax, edx

; 1537 :          search += rangeShift*2;
; 1538 : 
; 1539 :       // now decrement to bias correctly to find smallest
; 1540 :       search -= 2;

	lea	r10d, DWORD PTR [rdx+rsi]
	add	rax, r14
	movzx	ecx, BYTE PTR [rax+rdi+1]
	movzx	eax, BYTE PTR [rax+rdi]
	shl	eax, 8
	add	ecx, eax
	cmp	r9d, ecx
	cmovl	r10d, esi
	sub	r10d, 2

; 1541 :       while (entrySelector) {

	test	bx, bx
	je	SHORT $LN6@stbtt_Find
$LL5@stbtt_Find:

; 1542 :          stbtt_uint16 end;
; 1543 :          searchRange >>= 1;

	shr	r11w, 1

; 1544 :          end = ttUSHORT(data + search + searchRange*2);

	mov	ecx, r10d
	movzx	eax, r11w
	lea	r8d, DWORD PTR [rax+rax]
	mov	eax, r8d
	add	rax, rdi

; 1545 :          if (unicode_codepoint > end)

	movzx	edx, BYTE PTR [rcx+rax]
	movzx	eax, BYTE PTR [rcx+rax+1]
	shl	edx, 8
	add	edx, eax

; 1546 :             search += searchRange*2;
; 1547 :          --entrySelector;

	lea	eax, DWORD PTR [r8+r10]
	cmp	r9d, edx
	cmovle	eax, r10d
	mov	r10d, eax
	add	bx, r13w
	jne	SHORT $LL5@stbtt_Find
$LN6@stbtt_Find:

; 1548 :       }
; 1549 :       search += 2;
; 1550 : 
; 1551 :       {
; 1552 :          stbtt_uint16 offset, start, last;
; 1553 :          stbtt_uint16 item = (stbtt_uint16) ((search - endCount) >> 1);
; 1554 : 
; 1555 :          start = ttUSHORT(data + index_map + 14 + segcount*2 + 2 + 2*item);
; 1556 :          last = ttUSHORT(data + endCount + 2*item);
; 1557 :          if (unicode_codepoint < start || unicode_codepoint > last)

	mov	r14, QWORD PTR [rsp+40]
	sub	r10d, esi
	add	r10d, 2
	movzx	r11d, r15w
	shr	r10d, 1
	movzx	r8d, r10w
	add	r8, r8
	lea	ecx, DWORD PTR [r11+r11]
	add	rcx, r8
	add	rcx, rbp
	lea	rdx, QWORD PTR [r8+rsi]
	movzx	eax, BYTE PTR [rcx+rdi+16]
	movzx	ebx, BYTE PTR [rcx+rdi+17]
	shl	eax, 8
	add	ebx, eax
	cmp	r9d, ebx
	jl	$LN8@stbtt_Find
	movzx	ecx, BYTE PTR [rdx+rdi]
	movzx	eax, BYTE PTR [rdx+rdi+1]
	shl	ecx, 8
	add	ecx, eax
	cmp	r9d, ecx
	jg	$LN8@stbtt_Find

; 1558 :             return 0;
; 1559 : 
; 1560 :          offset = ttUSHORT(data + index_map + 14 + segcount*6 + 2 + 2*item);

	lea	eax, DWORD PTR [r11+r11*2]
	add	eax, eax
	mov	esi, eax
	lea	rdx, QWORD PTR [rax+r8]
	add	rdx, rbp

; 1291 : static stbtt_uint16 ttUSHORT(stbtt_uint8 *p) { return p[0]*256 + p[1]; }

	movzx	r10d, BYTE PTR [rdx+rdi+16]
	movzx	eax, BYTE PTR [rdx+rdi+17]
	imul	r10d, r12d
	add	r10w, ax

; 1561 :          if (offset == 0)

	jne	SHORT $LN27@stbtt_Find

; 1562 :             return (stbtt_uint16) (unicode_codepoint + ttSHORT(data + index_map + 14 + segcount*4 + 2 + 2*item));

	lea	edx, DWORD PTR [r11*4]
	add	rdx, r8
	add	rdx, rbp

; 1292 : static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }

	movzx	eax, BYTE PTR [rdx+rdi+17]
	movzx	r8d, BYTE PTR [rdx+rdi+16]
	imul	r8d, r12d

; 1562 :             return (stbtt_uint16) (unicode_codepoint + ttSHORT(data + index_map + 14 + segcount*4 + 2 + 2*item));

	add	r8w, ax
	add	r8w, r9w
	movzx	eax, r8w
	jmp	$LN1@stbtt_Find
$LN27@stbtt_Find:

; 1563 : 
; 1564 :          return ttUSHORT(data + offset + (unicode_codepoint-start)*2 + index_map + 14 + segcount*6 + 2 + 2*item);

	sub	r9d, ebx
	movzx	ecx, r10w
	lea	eax, DWORD PTR [r9+r9]
	cdqe
	add	rax, rsi
	add	rcx, rax
	add	rcx, r8
	add	rcx, rbp
	movzx	eax, BYTE PTR [rcx+rdi+16]
	movzx	ecx, BYTE PTR [rcx+rdi+17]
	shl	eax, 8
	add	eax, ecx
	jmp	$LN1@stbtt_Find
$LN20@stbtt_Find:

; 1565 :       }
; 1566 :    } else if (format == 12 || format == 13) {

	lea	eax, DWORD PTR [rsi-12]
	cmp	ax, 1
	ja	$LN8@stbtt_Find

; 1293 : static stbtt_uint32 ttULONG(stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }

	movzx	eax, BYTE PTR [rdi+rdx+13]

; 1567 :       stbtt_uint32 ngroups = ttULONG(data+index_map+12);
; 1568 :       stbtt_int32 low,high;
; 1569 :       low = 0; high = (stbtt_int32)ngroups;

	xor	ebx, ebx

; 1293 : static stbtt_uint32 ttULONG(stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }

	movzx	r11d, BYTE PTR [rdi+rdx+12]
	shl	r11d, 8
	add	r11d, eax
	movzx	eax, BYTE PTR [rdi+rdx+14]
	shl	r11d, 8
	add	r11d, eax
	movzx	eax, BYTE PTR [rdi+rdx+15]
	shl	r11d, 8
	add	r11d, eax

; 1570 :       // Binary search the right group.
; 1571 :       while (low < high) {

	test	r11d, r11d
	jle	$LN8@stbtt_Find
$LL7@stbtt_Find:

; 1572 :          stbtt_int32 mid = low + ((high-low) >> 1); // rounds down, so low <= mid < high

	mov	eax, r11d
	sub	eax, ebx
	sar	eax, 1
	add	eax, ebx

; 1573 :          stbtt_uint32 start_char = ttULONG(data+index_map+16+mid*12);

	lea	ecx, DWORD PTR [rax+rax*2]
	shl	ecx, 2
	movsxd	r8, ecx
	add	r8, rbp
	add	r8, rdi

; 1293 : static stbtt_uint32 ttULONG(stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }

	movzx	r10d, BYTE PTR [r8+17]
	movzx	ecx, BYTE PTR [r8+18]
	shl	ecx, 8
	shl	r10d, 16
	add	r10d, ecx
	movzx	ecx, BYTE PTR [r8+16]
	shl	ecx, 24
	add	r10d, ecx
	movzx	ecx, BYTE PTR [r8+19]
	add	r10d, ecx

; 1574 :          stbtt_uint32 end_char = ttULONG(data+index_map+16+mid*12+4);
; 1575 :          if ((stbtt_uint32) unicode_codepoint < start_char)

	cmp	r9d, r10d
	jae	SHORT $LN30@stbtt_Find

; 1576 :             high = mid;

	mov	r11d, eax
	jmp	SHORT $LN35@stbtt_Find
$LN30@stbtt_Find:

; 1293 : static stbtt_uint32 ttULONG(stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }

	movzx	edx, BYTE PTR [r8+21]
	movzx	ecx, BYTE PTR [r8+22]
	shl	ecx, 8
	shl	edx, 16
	add	edx, ecx
	movzx	ecx, BYTE PTR [r8+20]
	shl	ecx, 24
	add	edx, ecx
	movzx	ecx, BYTE PTR [r8+23]
	add	edx, ecx

; 1577 :          else if ((stbtt_uint32) unicode_codepoint > end_char)

	cmp	r9d, edx
	jbe	SHORT $LN32@stbtt_Find

; 1578 :             low = mid+1;

	lea	ebx, DWORD PTR [rax+1]
$LN35@stbtt_Find:

; 1570 :       // Binary search the right group.
; 1571 :       while (low < high) {

	cmp	ebx, r11d
	jl	SHORT $LL7@stbtt_Find
$LN8@stbtt_Find:

; 1585 :          }
; 1586 :       }
; 1587 :       return 0; // not found

	xor	eax, eax
$LN1@stbtt_Find:

; 1588 :    }
; 1589 :    // @TODO
; 1590 :    STBTT_assert(0);
; 1591 :    return 0;
; 1592 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	pop	r15
	pop	r13
	pop	r12
	pop	rdi
	ret	0
$LN32@stbtt_Find:

; 1293 : static stbtt_uint32 ttULONG(stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }

	movzx	ecx, BYTE PTR [r8+25]
	movzx	eax, BYTE PTR [r8+26]
	shl	eax, 8
	shl	ecx, 16
	add	ecx, eax
	movzx	eax, BYTE PTR [r8+24]
	shl	eax, 24
	add	ecx, eax
	movzx	eax, BYTE PTR [r8+27]
	add	ecx, eax

; 1579 :          else {
; 1580 :             stbtt_uint32 start_glyph = ttULONG(data+index_map+16+mid*12+8);
; 1581 :             if (format == 12)

	cmp	si, 12
	jne	SHORT $LN34@stbtt_Find

; 1582 :                return start_glyph + unicode_codepoint-start_char;

	sub	ecx, r10d
	lea	eax, DWORD PTR [r9+rcx]
	jmp	SHORT $LN1@stbtt_Find
$LN34@stbtt_Find:

; 1583 :             else // format == 13
; 1584 :                return start_glyph;

	mov	eax, ecx
	jmp	SHORT $LN1@stbtt_Find
stbtt_FindGlyphIndex ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt_setvertex@@YAXPEAUstbtt_vertex@@EHHHH@Z
_TEXT	SEGMENT
v$ = 8
type$ = 16
x$ = 24
y$ = 32
cx$ = 40
cy$ = 48
?stbtt_setvertex@@YAXPEAUstbtt_vertex@@EHHHH@Z PROC	; stbtt_setvertex, COMDAT

; 1601 :    v->type = type;
; 1602 :    v->x = (stbtt_int16) x;
; 1603 :    v->y = (stbtt_int16) y;
; 1604 :    v->cx = (stbtt_int16) cx;

	movzx	eax, WORD PTR cx$[rsp]
	mov	WORD PTR [rcx+4], ax

; 1605 :    v->cy = (stbtt_int16) cy;

	movzx	eax, WORD PTR cy$[rsp]
	mov	WORD PTR [rcx+6], ax
	mov	BYTE PTR [rcx+12], dl
	mov	WORD PTR [rcx], r8w
	mov	WORD PTR [rcx+2], r9w

; 1606 : }

	ret	0
?stbtt_setvertex@@YAXPEAUstbtt_vertex@@EHHHH@Z ENDP	; stbtt_setvertex
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__GetGlyfOffset@@YAHPEBUstbtt_fontinfo@@H@Z
_TEXT	SEGMENT
info$ = 8
glyph_index$ = 16
?stbtt__GetGlyfOffset@@YAHPEBUstbtt_fontinfo@@H@Z PROC	; stbtt__GetGlyfOffset, COMDAT

; 1609 : {

	mov	r8, rcx

; 1610 :    int g1,g2;
; 1611 : 
; 1612 :    STBTT_assert(!info->cff.size);
; 1613 : 
; 1614 :    if (glyph_index >= info->numGlyphs) return -1; // glyph index out of range

	cmp	edx, DWORD PTR [rcx+20]
	jge	$LN18@stbtt__Get

; 1615 :    if (info->indexToLocFormat >= 2)    return -1; // unknown index->glyph map format

	mov	eax, DWORD PTR [rcx+60]
	cmp	eax, 2
	jge	$LN18@stbtt__Get

; 1616 : 
; 1617 :    if (info->indexToLocFormat == 0) {

	movsxd	r9, DWORD PTR [rcx+24]
	mov	r10, QWORD PTR [rcx+8]
	test	eax, eax
	jne	SHORT $LN7@stbtt__Get

; 1618 :       g1 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2) * 2;

	mov	r8d, DWORD PTR [rcx+32]
	lea	eax, DWORD PTR [rdx+rdx]
	movsxd	rdx, eax
	add	rdx, r10
	add	rdx, r9
	movzx	eax, BYTE PTR [rdx+1]
	movzx	ecx, BYTE PTR [rdx]

; 1291 : static stbtt_uint16 ttUSHORT(stbtt_uint8 *p) { return p[0]*256 + p[1]; }

	shl	ecx, 8

; 1618 :       g1 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2) * 2;

	add	ecx, eax

; 1619 :       g2 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2 + 2) * 2;

	movzx	eax, BYTE PTR [rdx+3]
	lea	r10d, DWORD PTR [r8+rcx*2]
	movzx	ecx, BYTE PTR [rdx+2]

; 1291 : static stbtt_uint16 ttUSHORT(stbtt_uint8 *p) { return p[0]*256 + p[1]; }

	shl	ecx, 8

; 1619 :       g2 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2 + 2) * 2;

	add	ecx, eax

; 1623 :    }
; 1624 : 
; 1625 :    return g1==g2 ? -1 : g1; // if length is 0, return -1

	mov	eax, -1
	lea	r9d, DWORD PTR [r8+rcx*2]
	cmp	r10d, r9d
	cmove	r10d, eax
	mov	eax, r10d

; 1626 : }

	ret	0
$LN7@stbtt__Get:

; 1620 :    } else {
; 1621 :       g1 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4);

	lea	eax, DWORD PTR [rdx*4]
	movsxd	rcx, eax
	add	rcx, r10
	add	r9, rcx

; 1293 : static stbtt_uint32 ttULONG(stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }

	movzx	eax, BYTE PTR [r9+1]
	movzx	ecx, BYTE PTR [r9]
	movzx	r10d, BYTE PTR [r9+3]
	movzx	edx, BYTE PTR [r9+4]
	shl	ecx, 8

; 1620 :    } else {
; 1621 :       g1 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4);

	add	ecx, eax

; 1293 : static stbtt_uint32 ttULONG(stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }

	shl	edx, 8
	movzx	eax, BYTE PTR [r9+2]

; 1620 :    } else {
; 1621 :       g1 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4);

	shl	ecx, 8
	add	eax, ecx

; 1293 : static stbtt_uint32 ttULONG(stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }

	movzx	ecx, BYTE PTR [r9+6]

; 1620 :    } else {
; 1621 :       g1 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4);

	shl	eax, 8
	add	eax, DWORD PTR [r8+32]
	add	r10d, eax

; 1293 : static stbtt_uint32 ttULONG(stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }

	movzx	eax, BYTE PTR [r9+5]
	movzx	r9d, BYTE PTR [r9+7]

; 1622 :       g2 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4 + 4);

	add	edx, eax
	shl	edx, 8

; 1623 :    }
; 1624 : 
; 1625 :    return g1==g2 ? -1 : g1; // if length is 0, return -1

	mov	eax, -1
	add	ecx, edx
	shl	ecx, 8
	add	ecx, DWORD PTR [r8+32]
	add	r9d, ecx
	cmp	r10d, r9d
	cmove	r10d, eax
	mov	eax, r10d

; 1626 : }

	ret	0
$LN18@stbtt__Get:

; 1615 :    if (info->indexToLocFormat >= 2)    return -1; // unknown index->glyph map format

	mov	eax, -1

; 1626 : }

	ret	0
?stbtt__GetGlyfOffset@@YAHPEBUstbtt_fontinfo@@H@Z ENDP	; stbtt__GetGlyfOffset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT stbtt_GetGlyphBox
_TEXT	SEGMENT
c$1 = 32
__$ArrayPad$ = 88
info$ = 144
glyph_index$ = 152
x0$ = 160
y0$ = 168
x1$ = 176
y1$ = 184
stbtt_GetGlyphBox PROC					; COMDAT

; 1631 : {

	push	rbx
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1632 :    if (info->cff.size) {

	cmp	DWORD PTR [rcx+76], 0
	mov	r14, r9
	mov	rdi, QWORD PTR x1$[rsp]
	mov	r15, r8
	mov	rsi, QWORD PTR y1$[rsp]
	mov	r11, rcx
	je	SHORT $LN2@stbtt_GetG

; 2293 :    stbtt__csctx c = STBTT__CSCTX_INIT(1);

	xor	ebx, ebx
	mov	QWORD PTR c$1[rsp], 1
	xorps	xmm0, xmm0
	mov	QWORD PTR c$1[rsp+40], rbx
	xorps	xmm1, xmm1
	mov	DWORD PTR c$1[rsp+48], ebx

; 2294 :    int r = stbtt__run_charstring(info, glyph_index, &c);

	lea	r8, QWORD PTR c$1[rsp]
	movups	XMMWORD PTR c$1[rsp+8], xmm0
	movdqu	XMMWORD PTR c$1[rsp+24], xmm1
	call	?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z ; stbtt__run_charstring
	mov	ecx, eax

; 2295 :    if (x0)  *x0 = r ? c.min_x : 0;

	test	r15, r15
	je	SHORT $LN11@stbtt_GetG
	test	ecx, ecx
	mov	eax, ebx
	cmovne	eax, DWORD PTR c$1[rsp+24]
	mov	DWORD PTR [r15], eax
$LN11@stbtt_GetG:

; 2296 :    if (y0)  *y0 = r ? c.min_y : 0;

	test	r14, r14
	je	SHORT $LN12@stbtt_GetG
	test	ecx, ecx
	mov	eax, ebx
	cmovne	eax, DWORD PTR c$1[rsp+32]
	mov	DWORD PTR [r14], eax
$LN12@stbtt_GetG:

; 2297 :    if (x1)  *x1 = r ? c.max_x : 0;

	test	rdi, rdi
	je	SHORT $LN13@stbtt_GetG
	test	ecx, ecx
	mov	eax, ebx
	cmovne	eax, DWORD PTR c$1[rsp+28]
	mov	DWORD PTR [rdi], eax
$LN13@stbtt_GetG:

; 2298 :    if (y1)  *y1 = r ? c.max_y : 0;

	test	rsi, rsi
	je	$LN8@stbtt_GetG
	test	ecx, ecx
	cmovne	ebx, DWORD PTR c$1[rsp+36]
	mov	DWORD PTR [rsi], ebx

; 1633 :       stbtt__GetGlyphInfoT2(info, glyph_index, x0, y0, x1, y1);
; 1634 :    } else {

	jmp	$LN8@stbtt_GetG
$LN2@stbtt_GetG:

; 1635 :       int g = stbtt__GetGlyfOffset(info, glyph_index);

	call	?stbtt__GetGlyfOffset@@YAHPEBUstbtt_fontinfo@@H@Z ; stbtt__GetGlyfOffset

; 1636 :       if (g < 0) return 0;

	test	eax, eax
	jns	SHORT $LN4@stbtt_GetG
	xor	eax, eax
	jmp	$LN1@stbtt_GetG
$LN4@stbtt_GetG:

; 1637 : 
; 1638 :       if (x0) *x0 = ttSHORT(info->data + g + 2);

	movsxd	r10, eax
	mov	ebx, 256				; 00000100H
	test	r15, r15
	je	SHORT $LN24@stbtt_GetG
	mov	r8, QWORD PTR [r11+8]

; 1292 : static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }

	movsx	ecx, bx
	movzx	eax, BYTE PTR [r8+r10+3]
	movzx	edx, BYTE PTR [r8+r10+2]
	imul	edx, ecx
	add	ax, dx

; 1637 : 
; 1638 :       if (x0) *x0 = ttSHORT(info->data + g + 2);

	cwde
	mov	DWORD PTR [r15], eax
$LN24@stbtt_GetG:

; 1639 :       if (y0) *y0 = ttSHORT(info->data + g + 4);

	test	r14, r14
	je	SHORT $LN6@stbtt_GetG
	mov	r8, QWORD PTR [r11+8]

; 1292 : static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }

	movsx	ecx, bx
	movzx	eax, BYTE PTR [r10+r8+5]
	movzx	edx, BYTE PTR [r10+r8+4]
	imul	edx, ecx
	add	ax, dx

; 1639 :       if (y0) *y0 = ttSHORT(info->data + g + 4);

	cwde
	mov	DWORD PTR [r14], eax
$LN6@stbtt_GetG:

; 1640 :       if (x1) *x1 = ttSHORT(info->data + g + 6);

	test	rdi, rdi
	je	SHORT $LN7@stbtt_GetG
	mov	r8, QWORD PTR [r11+8]

; 1292 : static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }

	movsx	ecx, bx
	movzx	eax, BYTE PTR [r10+r8+7]
	movzx	edx, BYTE PTR [r10+r8+6]
	imul	edx, ecx
	add	ax, dx

; 1640 :       if (x1) *x1 = ttSHORT(info->data + g + 6);

	cwde
	mov	DWORD PTR [rdi], eax
$LN7@stbtt_GetG:

; 1641 :       if (y1) *y1 = ttSHORT(info->data + g + 8);

	test	rsi, rsi
	je	SHORT $LN8@stbtt_GetG
	mov	r9, QWORD PTR [r11+8]

; 1292 : static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }

	movsx	edx, bx
	movzx	ecx, BYTE PTR [r10+r9+9]
	movzx	r8d, BYTE PTR [r10+r9+8]
	imul	r8d, edx
	add	r8w, cx

; 1641 :       if (y1) *y1 = ttSHORT(info->data + g + 8);

	movsx	ecx, r8w
	mov	DWORD PTR [rsi], ecx
$LN8@stbtt_GetG:

; 1642 :    }
; 1643 :    return 1;

	mov	eax, 1
$LN1@stbtt_GetG:

; 1644 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 96					; 00000060H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
stbtt_GetGlyphBox ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z
_TEXT	SEGMENT
vertices$ = 16
num_vertices$ = 24
was_off$ = 32
start_off$ = 40
sx$ = 48
sy$ = 56
scx$ = 64
scy$ = 72
cx$ = 80
cy$ = 88
?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z PROC ; stbtt__close_shape, COMDAT

; 1665 : {

	sub	rsp, 8
	movsxd	r10, edx
	mov	r11, rcx

; 1666 :    if (start_off) {

	test	r9d, r9d
	je	$LN2@stbtt__clo

; 1667 :       if (was_off)

	mov	r9d, DWORD PTR scy$[rsp]
	mov	QWORD PTR [rsp], rbx
	mov	ebx, DWORD PTR scx$[rsp]
	test	r8d, r8d
	je	SHORT $LN4@stbtt__clo

; 1668 :          stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+scx)>>1, (cy+scy)>>1, cx,cy);

	mov	edx, DWORD PTR cx$[rsp]
	imul	r8, r10, 14
	lea	eax, DWORD PTR [rbx+rdx]
	inc	r10d
	sar	eax, 1

; 1602 :    v->x = (stbtt_int16) x;

	mov	WORD PTR [r8+rcx], ax
	mov	BYTE PTR [r8+rcx+12], 3

; 1668 :          stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+scx)>>1, (cy+scy)>>1, cx,cy);

	mov	ecx, DWORD PTR cy$[rsp]

; 1604 :    v->cx = (stbtt_int16) cx;

	mov	WORD PTR [r8+r11+4], dx

; 1605 :    v->cy = (stbtt_int16) cy;

	mov	WORD PTR [r8+r11+6], cx

; 1668 :          stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+scx)>>1, (cy+scy)>>1, cx,cy);

	lea	eax, DWORD PTR [r9+rcx]
	sar	eax, 1

; 1603 :    v->y = (stbtt_int16) y;

	mov	WORD PTR [r8+r11+2], ax
$LN4@stbtt__clo:

; 1669 :       stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, sx,sy,scx,scy);

	movsxd	rax, r10d
	imul	rcx, rax, 14

; 1602 :    v->x = (stbtt_int16) x;

	movzx	eax, WORD PTR sx$[rsp]
	mov	WORD PTR [rcx+r11], ax

; 1603 :    v->y = (stbtt_int16) y;

	movzx	eax, WORD PTR sy$[rsp]
	mov	WORD PTR [rcx+r11+2], ax

; 1677 : }

	lea	eax, DWORD PTR [r10+1]

; 1604 :    v->cx = (stbtt_int16) cx;

	mov	WORD PTR [rcx+r11+4], bx

; 1672 :          stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve,sx,sy,cx,cy);
; 1673 :       else
; 1674 :          stbtt_setvertex(&vertices[num_vertices++], STBTT_vline,sx,sy,0,0);
; 1675 :    }
; 1676 :    return num_vertices;

	mov	rbx, QWORD PTR [rsp]

; 1601 :    v->type = type;

	mov	BYTE PTR [rcx+r11+12], 3

; 1605 :    v->cy = (stbtt_int16) cy;

	mov	WORD PTR [rcx+r11+6], r9w

; 1677 : }

	add	rsp, 8
	ret	0
$LN2@stbtt__clo:

; 1670 :    } else {
; 1671 :       if (was_off)

	movzx	eax, WORD PTR sx$[rsp]
	movzx	ecx, WORD PTR sy$[rsp]
	imul	rdx, r10, 14
	add	rdx, r11
	mov	WORD PTR [rdx], ax
	mov	WORD PTR [rdx+2], cx
	test	r8d, r8d
	je	SHORT $LN5@stbtt__clo

; 1604 :    v->cx = (stbtt_int16) cx;

	movzx	eax, WORD PTR cx$[rsp]
	mov	WORD PTR [rdx+4], ax

; 1605 :    v->cy = (stbtt_int16) cy;

	movzx	eax, WORD PTR cy$[rsp]
	mov	WORD PTR [rdx+6], ax

; 1677 : }

	lea	eax, DWORD PTR [r10+1]

; 1601 :    v->type = type;

	mov	BYTE PTR [rdx+12], 3

; 1677 : }

	add	rsp, 8
	ret	0
$LN5@stbtt__clo:

; 1604 :    v->cx = (stbtt_int16) cx;

	xor	eax, eax
	mov	BYTE PTR [rdx+12], 2
	mov	DWORD PTR [rdx+4], eax

; 1677 : }

	lea	eax, DWORD PTR [r10+1]
	add	rsp, 8
	ret	0
?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z ENDP ; stbtt__close_shape
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__GetGlyphShapeTT@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z
_TEXT	SEGMENT
flags$4$ = 80
tv4488 = 82
tv4487 = 84
scy$1$ = 88
scx$1$ = 92
next_move$1$ = 96
cx$1$ = 100
i$1$ = 104
endPtsOfContours$1$ = 112
pvertices$GSCopy$1$ = 120
mtx$1 = 128
tv3674 = 152
comp_verts$2 = 152
__$ArrayPad$ = 160
info$ = 384
glyph_index$ = 392
pvertices$ = 400
?stbtt__GetGlyphShapeTT@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z PROC ; stbtt__GetGlyphShapeTT, COMDAT

; 1680 : {

	mov	rax, rsp
	mov	QWORD PTR [rax+32], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 320				; 00000140H
	movaps	XMMWORD PTR [rax-72], xmm6
	movaps	XMMWORD PTR [rax-88], xmm7
	movaps	XMMWORD PTR [rax-104], xmm8
	movaps	XMMWORD PTR [rax-120], xmm9
	movaps	XMMWORD PTR [rax-136], xmm10
	movaps	XMMWORD PTR [rax-152], xmm11
	movaps	XMMWORD PTR [rax-168], xmm12
	movaps	XMMWORD PTR [rax-184], xmm13
	movaps	XMMWORD PTR [rax-200], xmm14
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1681 :    stbtt_int16 numberOfContours;
; 1682 :    stbtt_uint8 *endPtsOfContours;
; 1683 :    stbtt_uint8 *data = info->data;

	mov	r11, QWORD PTR [rcx+8]

; 1684 :    stbtt_vertex *vertices=0;

	xor	r12d, r12d
	mov	edi, r12d
	mov	QWORD PTR pvertices$GSCopy$1$[rsp], r8

; 1685 :    int num_vertices=0;

	mov	r15d, r12d
	mov	r13, rcx

; 1686 :    int g = stbtt__GetGlyfOffset(info, glyph_index);

	call	?stbtt__GetGlyfOffset@@YAHPEBUstbtt_fontinfo@@H@Z ; stbtt__GetGlyfOffset

; 1687 : 
; 1688 :    *pvertices = NULL;

	mov	rcx, QWORD PTR pvertices$GSCopy$1$[rsp]
	mov	QWORD PTR [rcx], r12

; 1689 : 
; 1690 :    if (g < 0) return 0;

	test	eax, eax
	js	$LN116@stbtt__Get

; 1691 : 
; 1692 :    numberOfContours = ttSHORT(data + g);

	movsxd	r10, eax

; 1292 : static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }

	mov	r8d, 256				; 00000100H
	movsx	eax, r8w
	movzx	ecx, BYTE PTR [r10+r11]
	movzx	edx, BYTE PTR [r10+r11+1]
	imul	ecx, eax
	add	dx, cx

; 1693 : 
; 1694 :    if (numberOfContours > 0) {

	test	dx, dx
	jle	$LN252@stbtt__Get

; 1695 :       stbtt_uint8 flags=0,flagcount;
; 1696 :       stbtt_int32 ins, i,j=0,m,n, next_move, was_off=0, off, start_off=0;
; 1697 :       stbtt_int32 x,y,cx,cy,sx,sy, scx,scy;
; 1698 :       stbtt_uint8 *points;
; 1699 :       endPtsOfContours = (data + g + 10);
; 1700 :       ins = ttUSHORT(data + g + 10 + numberOfContours * 2);

	movsx	eax, dx
	lea	r9, QWORD PTR [r11+10]
	add	r9, r10
	xor	sil, sil
	mov	ebp, r12d
	mov	QWORD PTR endPtsOfContours$1$[rsp], r9
	lea	r8d, DWORD PTR [rax+rax]
	movsxd	r14, r8d
	lea	rcx, QWORD PTR [r10+r14]

; 1701 :       points = data + g + 10 + numberOfContours * 2 + 2 + ins;

	movzx	eax, BYTE PTR [rcx+r11+10]
	movzx	ebx, BYTE PTR [rcx+r11+11]

; 1703 :       n = 1+ttUSHORT(endPtsOfContours + numberOfContours*2-2);

	movzx	ecx, BYTE PTR [r14+r9-2]
	add	rbx, 12
	shl	rax, 8
	add	rax, r10
	shl	ecx, 8
	add	rbx, rax
	movzx	eax, BYTE PTR [r14+r9-1]
	add	rbx, r14
	add	rbx, r11

; 1704 : 
; 1705 :       m = n + 2*numberOfContours;  // a loose bound on how many vertices we might need

	lea	edx, DWORD PTR [rax+1]
	add	edx, ecx
	lea	r15d, DWORD PTR [rax+1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 1703 :       n = 1+ttUSHORT(endPtsOfContours + numberOfContours*2-2);

	add	r15d, ecx

; 1704 : 
; 1705 :       m = n + 2*numberOfContours;  // a loose bound on how many vertices we might need

	add	edx, r8d
	mov	DWORD PTR tv3674[rsp], r15d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN135@stbtt__Get

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN135@stbtt__Get:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 1706 :       vertices = (stbtt_vertex *) STBTT_malloc(m * sizeof(vertices[0]), info->userdata);

	movsxd	rax, edx
	imul	rcx, rax, 14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
	mov	rdi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 1707 :       if (vertices == 0)

	test	rax, rax
	je	$LN116@stbtt__Get

; 1708 :          return 0;
; 1709 : 
; 1710 :       next_move = 0;

	xor	r13d, r13d

; 1711 :       flagcount=0;
; 1712 : 
; 1713 :       // in first pass, we load uninterpreted data into the allocated array
; 1714 :       // above, shifted to the end of the array so we won't overwrite it when
; 1715 :       // we create our final data starting from the front
; 1716 : 
; 1717 :       off = m - n; // starting offset for uninterpreted data, regardless of how m ends up being calculated
; 1718 : 
; 1719 :       // first load flags
; 1720 : 
; 1721 :       for (i=0; i < n; ++i) {

	mov	r11d, r15d
	xor	cl, cl
	mov	DWORD PTR next_move$1$[rsp], r13d
	test	r15d, r15d
	je	$LN192@stbtt__Get
	imul	r10, r14, 14
	mov	r9d, r11d
	lea	r8, QWORD PTR [r10+12]
	add	r8, rax
	npad	5
$LL4@stbtt__Get:

; 1722 :          if (flagcount == 0) {

	test	cl, cl
	jne	SHORT $LN26@stbtt__Get

; 1723 :             flags = *points++;

	movzx	esi, BYTE PTR [rbx]

; 1724 :             if (flags & 8)

	movzx	edx, sil
	and	dl, 8
	je	SHORT $LN28@stbtt__Get

; 1725 :                flagcount = *points++;

	movzx	ecx, BYTE PTR [rbx+1]
$LN28@stbtt__Get:

; 1726 :          } else

	test	dl, dl
	mov	rax, r13
	setne	al
	inc	rax
	add	rbx, rax
	jmp	SHORT $LN27@stbtt__Get
$LN26@stbtt__Get:

; 1727 :             --flagcount;

	add	cl, 255					; 000000ffH
$LN27@stbtt__Get:

; 1728 :          vertices[off+i].type = flags;

	mov	BYTE PTR [r8], sil
	add	r8, 14
	sub	r9, 1
	jne	SHORT $LL4@stbtt__Get
	lea	rsi, QWORD PTR [r10+rdi]

; 1605 :    v->cy = (stbtt_int16) cy;

	mov	r8d, r13d
	mov	r9, rsi
	mov	r10, r11

; 1689 : 
; 1690 :    if (g < 0) return 0;

	mov	r14d, 256				; 00000100H
	npad	9
$LL7@stbtt__Get:

; 1729 :       }
; 1730 : 
; 1731 :       // now load x coordinates
; 1732 :       x=0;
; 1733 :       for (i=0; i < n; ++i) {
; 1734 :          flags = vertices[off+i].type;
; 1735 :          if (flags & 2) {

	movzx	edx, BYTE PTR [r9+12]
	and	dl, 16
	test	BYTE PTR [r9+12], 2
	je	SHORT $LN29@stbtt__Get

; 1736 :             stbtt_int16 dx = *points++;

	movzx	ecx, BYTE PTR [rbx]
	inc	rbx

; 1737 :             x += (flags & 16) ? dx : -dx; // ???

	mov	eax, ecx
	neg	eax
	test	dl, dl
	cmove	ecx, eax
	add	r8d, ecx

; 1738 :          } else {

	jmp	SHORT $LN31@stbtt__Get
$LN29@stbtt__Get:

; 1739 :             if (!(flags & 16)) {

	test	dl, dl
	jne	SHORT $LN31@stbtt__Get

; 1740 :                x = x + (stbtt_int16) (points[0]*256 + points[1]);

	movzx	eax, BYTE PTR [rbx+1]
	movzx	edx, BYTE PTR [rbx]
	movsx	ecx, r14w
	imul	edx, ecx
	add	ax, dx
	cwde
	add	r8d, eax

; 1741 :                points += 2;

	add	rbx, 2
$LN31@stbtt__Get:

; 1742 :             }
; 1743 :          }
; 1744 :          vertices[off+i].x = (stbtt_int16) x;

	mov	WORD PTR [r9], r8w
	add	r9, 14
	sub	r10, 1
	jne	SHORT $LL7@stbtt__Get

; 1605 :    v->cy = (stbtt_int16) cy;

	mov	r8d, r13d
	lea	r9, QWORD PTR [rsi+2]
	mov	r10, r11
	npad	8
$LL10@stbtt__Get:

; 1745 :       }
; 1746 : 
; 1747 :       // now load y coordinates
; 1748 :       y=0;
; 1749 :       for (i=0; i < n; ++i) {
; 1750 :          flags = vertices[off+i].type;
; 1751 :          if (flags & 4) {

	movzx	edx, BYTE PTR [r9+10]
	and	dl, 32					; 00000020H
	test	BYTE PTR [r9+10], 4
	je	SHORT $LN32@stbtt__Get

; 1752 :             stbtt_int16 dy = *points++;

	movzx	ecx, BYTE PTR [rbx]
	inc	rbx

; 1753 :             y += (flags & 32) ? dy : -dy; // ???

	mov	eax, ecx
	neg	eax
	test	dl, dl
	cmove	ecx, eax
	add	r8d, ecx

; 1754 :          } else {

	jmp	SHORT $LN34@stbtt__Get
$LN32@stbtt__Get:

; 1755 :             if (!(flags & 32)) {

	test	dl, dl
	jne	SHORT $LN34@stbtt__Get

; 1756 :                y = y + (stbtt_int16) (points[0]*256 + points[1]);

	movzx	eax, BYTE PTR [rbx+1]
	movzx	edx, BYTE PTR [rbx]
	movsx	ecx, r14w
	imul	edx, ecx
	add	ax, dx
	cwde
	add	r8d, eax

; 1757 :                points += 2;

	add	rbx, 2
$LN34@stbtt__Get:

; 1758 :             }
; 1759 :          }
; 1760 :          vertices[off+i].y = (stbtt_int16) y;

	mov	WORD PTR [r9], r8w
	add	r9, 14
	sub	r10, 1
	jne	SHORT $LL10@stbtt__Get

; 1605 :    v->cy = (stbtt_int16) cy;

	xor	eax, eax
	mov	DWORD PTR scy$1$[rsp], r13d
	mov	r8d, eax
	mov	DWORD PTR cx$1$[rsp], eax
	mov	r10d, eax
	mov	DWORD PTR i$1$[rsp], eax
	mov	r11d, eax
	mov	DWORD PTR scx$1$[rsp], r13d
	mov	r9d, eax
	mov	ebx, eax
	mov	edx, r13d
	npad	13
$LL13@stbtt__Get:

; 1767 :          flags = vertices[off+i].type;
; 1768 :          x     = (stbtt_int16) vertices[off+i].x;

	movsx	ecx, WORD PTR [rsi]
	mov	r14d, ecx
	movzx	eax, BYTE PTR [rsi+12]
	mov	WORD PTR tv4488[rsp], cx

; 1769 :          y     = (stbtt_int16) vertices[off+i].y;

	movsx	ecx, WORD PTR [rsi+2]
	mov	r15d, ecx
	mov	WORD PTR tv4487[rsp], cx
	mov	BYTE PTR flags$4$[rsp], al

; 1770 : 
; 1771 :          if (next_move == i) {

	cmp	DWORD PTR next_move$1$[rsp], r9d
	jne	$LN35@stbtt__Get

; 1772 :             if (i != 0)

	test	rbx, rbx
	je	SHORT $LN37@stbtt__Get

; 1773 :                num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);

	mov	eax, DWORD PTR scy$1$[rsp]
	mov	r9d, r12d
	mov	DWORD PTR [rsp+72], r13d
	mov	rcx, rdi
	mov	DWORD PTR [rsp+64], r8d
	mov	r8d, ebp
	mov	DWORD PTR [rsp+56], eax
	mov	eax, DWORD PTR scx$1$[rsp]
	mov	DWORD PTR [rsp+48], eax
	mov	DWORD PTR [rsp+40], r10d
	mov	DWORD PTR [rsp+32], r11d
	call	?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z ; stbtt__close_shape
	mov	r8d, DWORD PTR cx$1$[rsp]
	mov	edx, eax
	movzx	eax, BYTE PTR flags$4$[rsp]
	mov	r9d, DWORD PTR i$1$[rsp]
$LN37@stbtt__Get:

; 1774 : 
; 1775 :             // now start the new one
; 1776 :             start_off = !(flags & 1);

	movzx	r12d, al
	not	r12d
	and	r12d, 1

; 1777 :             if (start_off) {

	je	SHORT $LN38@stbtt__Get

; 1778 :                // if we start off with an off-curve point, then when we need to find a point on the curve
; 1779 :                // where we can start, and we need to save some state for when we wraparound.
; 1780 :                scx = x;
; 1781 :                scy = y;
; 1782 :                if (!(vertices[off+i+1].type & 1)) {

	test	BYTE PTR [rsi+26], 1
	movsx	r11d, WORD PTR [rsi+14]
	movsx	r10d, WORD PTR [rsi+16]
	mov	DWORD PTR scx$1$[rsp], r14d
	mov	DWORD PTR scy$1$[rsp], r15d
	jne	SHORT $LN40@stbtt__Get

; 1783 :                   // next point is also a curve point, so interpolate an on-point curve
; 1784 :                   sx = (x + (stbtt_int32) vertices[off+i+1].x) >> 1;

	add	r11d, r14d

; 1785 :                   sy = (y + (stbtt_int32) vertices[off+i+1].y) >> 1;

	add	r10d, r15d
	sar	r11d, 1
	sar	r10d, 1

; 1786 :                } else {

	jmp	SHORT $LN39@stbtt__Get
$LN40@stbtt__Get:

; 1787 :                   // otherwise just use the next point as our start point
; 1788 :                   sx = (stbtt_int32) vertices[off+i+1].x;
; 1789 :                   sy = (stbtt_int32) vertices[off+i+1].y;
; 1790 :                   ++i; // we're using point i+1 as the starting point, so skip it

	inc	r9d
	inc	rbx
	add	rsi, 14

; 1791 :                }
; 1792 :             } else {

	jmp	SHORT $LN39@stbtt__Get
$LN38@stbtt__Get:

; 1793 :                sx = x;

	mov	r11d, r14d

; 1794 :                sy = y;

	mov	r10d, r15d
$LN39@stbtt__Get:

; 1798 :             next_move = 1 + ttUSHORT(endPtsOfContours+j*2);

	mov	r14, QWORD PTR endPtsOfContours$1$[rsp]
	movsxd	rax, edx
	inc	edx
	imul	rcx, rax, 14

; 1604 :    v->cx = (stbtt_int16) cx;

	xor	eax, eax

; 1795 :             }
; 1796 :             stbtt_setvertex(&vertices[num_vertices++], STBTT_vmove,sx,sy,0,0);

	add	rcx, rdi

; 1797 :             was_off = 0;

	mov	ebp, eax

; 1604 :    v->cx = (stbtt_int16) cx;

	mov	DWORD PTR [rcx+4], eax
	mov	BYTE PTR [rcx+12], 1
	mov	WORD PTR [rcx], r11w
	mov	WORD PTR [rcx+2], r10w

; 1798 :             next_move = 1 + ttUSHORT(endPtsOfContours+j*2);

	movzx	ecx, BYTE PTR [r14]
	movzx	eax, BYTE PTR [r14+1]
	shl	ecx, 8
	inc	eax
	add	eax, ecx

; 1799 :             ++j;

	add	r14, 2
	mov	DWORD PTR next_move$1$[rsp], eax
	mov	QWORD PTR endPtsOfContours$1$[rsp], r14

; 1800 :          } else {

	jmp	$LN11@stbtt__Get
$LN35@stbtt__Get:

; 1801 :             if (!(flags & 1)) { // if it's a curve

	test	al, 1
	jne	SHORT $LN42@stbtt__Get

; 1802 :                if (was_off) // two off-curve control points in a row means interpolate an on-curve midpoint

	test	ebp, ebp
	je	SHORT $LN193@stbtt__Get

; 1803 :                   stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+x)>>1, (cy+y)>>1, cx, cy);

	movsxd	rax, edx
	inc	edx
	imul	rcx, rax, 14
	lea	eax, DWORD PTR [r8+r14]
	add	rcx, rdi
	sar	eax, 1

; 1602 :    v->x = (stbtt_int16) x;

	mov	WORD PTR [rcx], ax

; 1803 :                   stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+x)>>1, (cy+y)>>1, cx, cy);

	lea	eax, DWORD PTR [r15+r13]
	sar	eax, 1

; 1603 :    v->y = (stbtt_int16) y;

	mov	WORD PTR [rcx+2], ax
	mov	BYTE PTR [rcx+12], 3

; 1604 :    v->cx = (stbtt_int16) cx;

	mov	WORD PTR [rcx+4], r8w

; 1605 :    v->cy = (stbtt_int16) cy;

	mov	WORD PTR [rcx+6], r13w
$LN193@stbtt__Get:

; 1804 :                cx = x;

	mov	r8d, r14d
	mov	DWORD PTR cx$1$[rsp], r14d

; 1805 :                cy = y;

	mov	r13d, r15d

; 1806 :                was_off = 1;

	mov	ebp, 1

; 1807 :             } else {

	jmp	SHORT $LN11@stbtt__Get
$LN42@stbtt__Get:

; 1808 :                if (was_off)

	movsxd	rax, edx
	imul	rcx, rax, 14
	inc	edx
	test	ebp, ebp
	je	SHORT $LN45@stbtt__Get

; 1605 :    v->cy = (stbtt_int16) cy;

	movzx	r14d, r13w
	movzx	r15d, r8w

; 1809 :                   stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, x,y, cx, cy);

	jmp	SHORT $LN46@stbtt__Get
$LN45@stbtt__Get:

; 1605 :    v->cy = (stbtt_int16) cy;

	xor	eax, eax
	mov	r14d, eax
	mov	r15d, eax
$LN46@stbtt__Get:

; 1810 :                else
; 1811 :                   stbtt_setvertex(&vertices[num_vertices++], STBTT_vline, x,y,0,0);
; 1812 :                was_off = 0;

	test	ebp, ebp
	setne	al
	add	al, 2
	mov	BYTE PTR [rcx+rdi+12], al
	movzx	eax, WORD PTR tv4488[rsp]
	mov	WORD PTR [rcx+rdi], ax
	movzx	eax, WORD PTR tv4487[rsp]
	mov	WORD PTR [rcx+rdi+2], ax
	xor	eax, eax
	mov	WORD PTR [rcx+rdi+4], r15w
	mov	ebp, eax
	mov	WORD PTR [rcx+rdi+6], r14w
$LN11@stbtt__Get:

; 1761 :       }
; 1762 : 
; 1763 :       // now convert them to our format
; 1764 :       num_vertices=0;
; 1765 :       sx = sy = cx = cy = scx = scy = 0;
; 1766 :       for (i=0; i < n; ++i) {

	mov	ecx, DWORD PTR tv3674[rsp]
	inc	r9d
	inc	rbx
	mov	DWORD PTR i$1$[rsp], r9d
	add	rsi, 14
	cmp	rbx, rcx
	jl	$LL13@stbtt__Get
	mov	eax, DWORD PTR scy$1$[rsp]
	mov	ecx, DWORD PTR scx$1$[rsp]
	jmp	SHORT $LN12@stbtt__Get
$LN192@stbtt__Get:

; 1605 :    v->cy = (stbtt_int16) cy;

	xor	r9d, r9d
	mov	edx, r13d
	mov	r8d, r9d
	mov	r10d, r9d
	mov	r11d, r9d
	mov	eax, r13d
	mov	ecx, r13d
$LN12@stbtt__Get:

; 1813 :             }
; 1814 :          }
; 1815 :       }
; 1816 :       num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);

	mov	DWORD PTR [rsp+72], r13d
	mov	r9d, r12d
	mov	DWORD PTR [rsp+64], r8d
	mov	r8d, ebp
	mov	DWORD PTR [rsp+56], eax
	mov	DWORD PTR [rsp+48], ecx
	mov	rcx, rdi
	mov	DWORD PTR [rsp+40], r10d
	mov	DWORD PTR [rsp+32], r11d
	call	?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z ; stbtt__close_shape
	mov	r15d, eax
$LN199@stbtt__Get:

; 1893 :       }
; 1894 :    } else {
; 1895 :       // numberOfCounters == 0, do nothing
; 1896 :    }
; 1897 : 
; 1898 :    *pvertices = vertices;

	mov	rax, QWORD PTR pvertices$GSCopy$1$[rsp]
	mov	QWORD PTR [rax], rdi

; 1899 :    return num_vertices;

	mov	eax, r15d
	jmp	$LN1@stbtt__Get
$LN252@stbtt__Get:

; 1817 :    } else if (numberOfContours < 0) {

	jns	SHORT $LN199@stbtt__Get

; 1818 :       // Compound shapes.
; 1819 :       int more = 1;
; 1820 :       stbtt_uint8 *comp = data + g + 10;
; 1821 :       num_vertices = 0;
; 1822 :       vertices = 0;

	movss	xmm14, DWORD PTR __real@38800000
	lea	rbx, QWORD PTR [r11+10]
	add	rbx, r10
	npad	15
$LL14@stbtt__Get:

; 1292 : static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }

	movzx	ebp, BYTE PTR [rbx+1]
	xorps	xmm12, xmm12
	movzx	esi, BYTE PTR [rbx+2]
	xorps	xmm13, xmm13
	movzx	r14d, BYTE PTR [rbx+3]

; 1824 :          stbtt_uint16 flags, gidx;
; 1825 :          int comp_num_verts = 0, i;
; 1826 :          stbtt_vertex *comp_verts = 0, *tmp = 0;
; 1827 :          float mtx[6] = {1,0,0,1,0,0}, m, n;
; 1828 : 
; 1829 :          flags = ttSHORT(comp); comp+=2;
; 1830 :          gidx = ttSHORT(comp); comp+=2;

	add	rbx, 4
	movaps	xmm0, XMMWORD PTR __xmm@3f80000000000000000000003f800000
	mov	QWORD PTR comp_verts$2[rsp], r12
	movups	XMMWORD PTR mtx$1[rsp], xmm0

; 1831 : 
; 1832 :          if (flags & 2) { // XY values

	test	bpl, 2
	je	SHORT $LN18@stbtt__Get

; 1833 :             if (flags & 1) { // shorts

	lea	r10, QWORD PTR [rbx+1]
	test	bpl, 1
	je	SHORT $LN51@stbtt__Get

; 1292 : static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }

	movzx	edx, BYTE PTR [rbx+2]
	lea	r8, QWORD PTR [rbx+3]
	movzx	ecx, BYTE PTR [rbx]
	mov	r11d, 256				; 00000100H
	movsx	eax, r11w

; 1834 :                mtx[4] = ttSHORT(comp); comp+=2;
; 1835 :                mtx[5] = ttSHORT(comp); comp+=2;

	add	rbx, 4

; 1292 : static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }

	imul	edx, eax
	movzx	eax, BYTE PTR [r8]
	add	dx, ax
	movsx	eax, r11w
	imul	ecx, eax
	movzx	eax, BYTE PTR [r10]
	movsx	r8d, dx
	add	ax, cx
	cwde

; 1836 :             } else {

	jmp	SHORT $LN52@stbtt__Get
$LN51@stbtt__Get:

; 1837 :                mtx[4] = ttCHAR(comp); comp+=1;

	movsx	eax, BYTE PTR [rbx]

; 1838 :                mtx[5] = ttCHAR(comp); comp+=1;

	lea	rbx, QWORD PTR [r10+1]
	movsx	r8d, BYTE PTR [r10]
$LN52@stbtt__Get:

; 1839 :             }
; 1840 :          }

	movd	xmm13, r8d
	mov	r8d, 256				; 00000100H
	movd	xmm12, eax
	cvtdq2ps xmm13, xmm13
	cvtdq2ps xmm12, xmm12
$LN18@stbtt__Get:

; 1841 :          else {
; 1842 :             // @TODO handle matching point
; 1843 :             STBTT_assert(0);
; 1844 :          }
; 1845 :          if (flags & (1<<3)) { // WE_HAVE_A_SCALE

	test	bpl, 8
	je	SHORT $LN53@stbtt__Get

; 1292 : static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }

	movzx	eax, BYTE PTR [rbx+1]
	xorps	xmm9, xmm9
	movzx	edx, BYTE PTR [rbx]
	xorps	xmm8, xmm8
	movsx	ecx, r8w
	imul	edx, ecx
	add	ax, dx
	cwde

; 1846 :             mtx[0] = mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;

	add	rbx, 2
	movd	xmm6, eax
	cvtdq2ps xmm6, xmm6
	mulss	xmm6, xmm14
	movaps	xmm7, xmm6

; 1847 :             mtx[1] = mtx[2] = 0;

	jmp	$LN57@stbtt__Get
$LN53@stbtt__Get:

; 1848 :          } else if (flags & (1<<6)) { // WE_HAVE_AN_X_AND_YSCALE

	test	bpl, 64					; 00000040H
	je	SHORT $LN55@stbtt__Get

; 1292 : static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }

	movzx	eax, BYTE PTR [rbx+1]
	xorps	xmm9, xmm9
	movzx	edx, BYTE PTR [rbx]
	xorps	xmm8, xmm8
	movsx	ecx, r8w
	imul	edx, ecx
	movsx	ecx, r8w
	add	ax, dx
	movzx	edx, BYTE PTR [rbx+2]
	cwde
	imul	edx, ecx
	movd	xmm7, eax
	movzx	eax, BYTE PTR [rbx+3]
	add	ax, dx
	cwde

; 1849 :             mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;
; 1850 :             mtx[1] = mtx[2] = 0;
; 1851 :             mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;

	add	rbx, 4
	cvtdq2ps xmm7, xmm7
	movd	xmm6, eax
	cvtdq2ps xmm6, xmm6
	mulss	xmm7, xmm14
	mulss	xmm6, xmm14
	jmp	$LN57@stbtt__Get
$LN55@stbtt__Get:

; 1852 :          } else if (flags & (1<<7)) { // WE_HAVE_A_TWO_BY_TWO

	test	bpl, bpl
	jns	$LN204@stbtt__Get

; 1292 : static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }

	movzx	eax, BYTE PTR [rbx+1]
	movzx	edx, BYTE PTR [rbx]
	movsx	ecx, r8w
	imul	edx, ecx
	movsx	ecx, r8w
	add	ax, dx
	movzx	edx, BYTE PTR [rbx+2]
	cwde
	imul	edx, ecx
	movsx	ecx, r8w
	movd	xmm7, eax
	movzx	eax, BYTE PTR [rbx+3]
	add	ax, dx
	movzx	edx, BYTE PTR [rbx+4]
	cwde
	imul	edx, ecx
	movsx	ecx, r8w

; 1853 :             mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;

	cvtdq2ps xmm7, xmm7
	movd	xmm8, eax

; 1292 : static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }

	movzx	eax, BYTE PTR [rbx+5]
	add	ax, dx

; 1853 :             mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;

	mulss	xmm7, xmm14

; 1292 : static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }

	movzx	edx, BYTE PTR [rbx+6]
	cwde
	imul	edx, ecx

; 1854 :             mtx[1] = ttSHORT(comp)/16384.0f; comp+=2;

	cvtdq2ps xmm8, xmm8
	movd	xmm9, eax

; 1292 : static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }

	movzx	eax, BYTE PTR [rbx+7]
	add	ax, dx

; 1854 :             mtx[1] = ttSHORT(comp)/16384.0f; comp+=2;

	mulss	xmm8, xmm14

; 1292 : static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }

	cwde

; 1855 :             mtx[2] = ttSHORT(comp)/16384.0f; comp+=2;
; 1856 :             mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;

	add	rbx, 8
	cvtdq2ps xmm9, xmm9
	movd	xmm6, eax
	cvtdq2ps xmm6, xmm6
	mulss	xmm9, xmm14
	mulss	xmm6, xmm14
	jmp	SHORT $LN57@stbtt__Get
$LN204@stbtt__Get:

; 1852 :          } else if (flags & (1<<7)) { // WE_HAVE_A_TWO_BY_TWO

	movss	xmm6, DWORD PTR mtx$1[rsp+12]
	movss	xmm9, DWORD PTR mtx$1[rsp+8]
	movss	xmm8, DWORD PTR mtx$1[rsp+4]
	movss	xmm7, DWORD PTR mtx$1[rsp]
$LN57@stbtt__Get:

; 1857 :          }
; 1858 : 
; 1859 :          // Find transformation scales.
; 1860 :          m = (float) STBTT_sqrt(mtx[0]*mtx[0] + mtx[1]*mtx[1]);

	movaps	xmm0, xmm7
	movaps	xmm1, xmm8
	mulss	xmm0, xmm7
	mulss	xmm1, xmm8
	addss	xmm1, xmm0
	xorps	xmm0, xmm0
	ucomiss	xmm0, xmm1
	ja	SHORT $LN202@stbtt__Get
	xorps	xmm11, xmm11
	sqrtss	xmm11, xmm1
	jmp	SHORT $LN203@stbtt__Get
$LN202@stbtt__Get:
	movaps	xmm0, xmm1
	call	sqrtf
	movaps	xmm11, xmm0
$LN203@stbtt__Get:

; 1861 :          n = (float) STBTT_sqrt(mtx[2]*mtx[2] + mtx[3]*mtx[3]);

	movaps	xmm1, xmm9
	movaps	xmm0, xmm6
	mulss	xmm1, xmm9
	mulss	xmm0, xmm6
	addss	xmm0, xmm1
	xorps	xmm1, xmm1
	ucomiss	xmm1, xmm0
	ja	SHORT $LN200@stbtt__Get
	xorps	xmm10, xmm10
	sqrtss	xmm10, xmm0
	jmp	SHORT $LN201@stbtt__Get
$LN200@stbtt__Get:
	call	sqrtf
	movaps	xmm10, xmm0
$LN201@stbtt__Get:

; 1862 : 
; 1863 :          // Get indexed glyph.
; 1864 :          comp_num_verts = stbtt_GetGlyphShape(info, gidx, &comp_verts);

	mov	edx, esi

; 2304 :    if (!info->cff.size)

	lea	r8, QWORD PTR comp_verts$2[rsp]

; 1862 : 
; 1863 :          // Get indexed glyph.
; 1864 :          comp_num_verts = stbtt_GetGlyphShape(info, gidx, &comp_verts);

	shl	edx, 8

; 2304 :    if (!info->cff.size)

	mov	rcx, r13

; 1862 : 
; 1863 :          // Get indexed glyph.
; 1864 :          comp_num_verts = stbtt_GetGlyphShape(info, gidx, &comp_verts);

	add	edx, r14d

; 2304 :    if (!info->cff.size)

	cmp	DWORD PTR [r13+76], 0
	jne	SHORT $LN99@stbtt__Get

; 2305 :       return stbtt__GetGlyphShapeTT(info, glyph_index, pvertices);

	call	?stbtt__GetGlyphShapeTT@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z ; stbtt__GetGlyphShapeTT
	jmp	SHORT $LN253@stbtt__Get
$LN99@stbtt__Get:

; 2306 :    else
; 2307 :       return stbtt__GetGlyphShapeT2(info, glyph_index, pvertices);

	call	?stbtt__GetGlyphShapeT2@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z ; stbtt__GetGlyphShapeT2
$LN253@stbtt__Get:

; 1865 :          if (comp_num_verts > 0) {

	mov	r10d, eax
	test	eax, eax
	jle	$LN58@stbtt__Get

; 1866 :             // Transform vertices.
; 1867 :             for (i = 0; i < comp_num_verts; ++i) {

	movsxd	rsi, eax
	mov	r9, r12
	cmp	rsi, 4
	jl	$LC177@stbtt__Get

; 1605 :    v->cy = (stbtt_int16) cy;

	lea	rdx, QWORD PTR [rsi-4]
	mov	r8, r12
	shr	rdx, 2
	inc	rdx
	lea	r9, QWORD PTR [rdx*4]
	npad	11

; 1872 :                v->y = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));

$LL178@stbtt__Get:

; 1869 :                stbtt_vertex_type x,y;
; 1870 :                x=v->x; y=v->y;
; 1871 :                v->x = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));

	mov	rcx, QWORD PTR comp_verts$2[rsp]
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	movsx	eax, WORD PTR [r8+rcx+2]
	cvtsi2ss xmm2, eax
	movsx	eax, WORD PTR [r8+rcx]
	cvtsi2ss xmm3, eax
	movaps	xmm0, xmm2

; 1872 :                v->y = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));

	mulss	xmm2, xmm6
	movaps	xmm1, xmm3
	mulss	xmm0, xmm9
	mulss	xmm1, xmm7
	mulss	xmm3, xmm8
	addss	xmm1, xmm0
	addss	xmm3, xmm2
	xorps	xmm2, xmm2
	addss	xmm1, xmm12
	addss	xmm3, xmm13
	mulss	xmm1, xmm11
	mulss	xmm3, xmm10
	cvttss2si eax, xmm1
	mov	WORD PTR [r8+rcx], ax
	cvttss2si eax, xmm3
	xorps	xmm3, xmm3
	mov	WORD PTR [r8+rcx+2], ax

; 1873 :                x=v->cx; y=v->cy;
; 1874 :                v->cx = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));

	movsx	eax, WORD PTR [r8+rcx+6]
	cvtsi2ss xmm2, eax
	movsx	eax, WORD PTR [r8+rcx+4]
	cvtsi2ss xmm3, eax
	movaps	xmm0, xmm2

; 1875 :                v->cy = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));

	mulss	xmm2, xmm6
	movaps	xmm1, xmm3
	mulss	xmm0, xmm9
	mulss	xmm1, xmm7
	mulss	xmm3, xmm8
	addss	xmm1, xmm0
	addss	xmm3, xmm2
	xorps	xmm2, xmm2
	addss	xmm1, xmm12
	addss	xmm3, xmm13
	mulss	xmm1, xmm11
	mulss	xmm3, xmm10
	cvttss2si eax, xmm1
	mov	WORD PTR [r8+rcx+4], ax
	cvttss2si eax, xmm3
	xorps	xmm3, xmm3
	mov	WORD PTR [r8+rcx+6], ax
	mov	rcx, QWORD PTR comp_verts$2[rsp]
	movsx	eax, WORD PTR [r8+rcx+16]
	cvtsi2ss xmm2, eax
	movsx	eax, WORD PTR [r8+rcx+14]
	cvtsi2ss xmm3, eax
	movaps	xmm0, xmm2
	mulss	xmm2, xmm6
	movaps	xmm1, xmm3
	mulss	xmm0, xmm9
	mulss	xmm1, xmm7
	mulss	xmm3, xmm8
	addss	xmm1, xmm0
	addss	xmm3, xmm2
	xorps	xmm2, xmm2
	addss	xmm1, xmm12
	addss	xmm3, xmm13
	mulss	xmm1, xmm11
	mulss	xmm3, xmm10
	cvttss2si eax, xmm1
	mov	WORD PTR [r8+rcx+14], ax
	cvttss2si eax, xmm3
	xorps	xmm3, xmm3
	mov	WORD PTR [r8+rcx+16], ax
	movsx	eax, WORD PTR [r8+rcx+20]
	cvtsi2ss xmm2, eax
	movsx	eax, WORD PTR [r8+rcx+18]
	cvtsi2ss xmm3, eax
	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm9
	mulss	xmm1, xmm7
	addss	xmm1, xmm0
	addss	xmm1, xmm12
	mulss	xmm1, xmm11
	mulss	xmm3, xmm8
	cvttss2si eax, xmm1
	mulss	xmm2, xmm6
	mov	WORD PTR [r8+rcx+18], ax
	addss	xmm3, xmm2
	xorps	xmm2, xmm2
	addss	xmm3, xmm13
	mulss	xmm3, xmm10
	cvttss2si eax, xmm3
	xorps	xmm3, xmm3
	mov	WORD PTR [r8+rcx+20], ax
	mov	rcx, QWORD PTR comp_verts$2[rsp]
	movsx	eax, WORD PTR [rcx+r8+30]
	cvtsi2ss xmm2, eax
	movsx	eax, WORD PTR [rcx+r8+28]
	cvtsi2ss xmm3, eax
	movaps	xmm0, xmm2
	mulss	xmm2, xmm6
	movaps	xmm1, xmm3
	mulss	xmm0, xmm9
	mulss	xmm3, xmm8
	mulss	xmm1, xmm7
	addss	xmm3, xmm2
	xorps	xmm2, xmm2
	addss	xmm1, xmm0
	addss	xmm3, xmm13
	addss	xmm1, xmm12
	mulss	xmm3, xmm10
	mulss	xmm1, xmm11
	cvttss2si eax, xmm1
	mov	WORD PTR [rcx+r8+28], ax
	cvttss2si eax, xmm3
	xorps	xmm3, xmm3
	mov	WORD PTR [rcx+r8+30], ax
	movsx	eax, WORD PTR [rcx+r8+34]
	cvtsi2ss xmm2, eax
	movsx	eax, WORD PTR [rcx+r8+32]
	cvtsi2ss xmm3, eax
	movaps	xmm0, xmm2
	mulss	xmm2, xmm6
	movaps	xmm1, xmm3
	mulss	xmm0, xmm9
	mulss	xmm3, xmm8
	mulss	xmm1, xmm7
	addss	xmm3, xmm2
	xorps	xmm2, xmm2
	addss	xmm1, xmm0
	addss	xmm3, xmm13
	addss	xmm1, xmm12
	mulss	xmm3, xmm10
	mulss	xmm1, xmm11
	cvttss2si eax, xmm1
	mov	WORD PTR [rcx+r8+32], ax
	cvttss2si eax, xmm3
	xorps	xmm3, xmm3
	mov	WORD PTR [rcx+r8+34], ax
	mov	rcx, QWORD PTR comp_verts$2[rsp]
	movsx	eax, WORD PTR [rcx+r8+44]
	cvtsi2ss xmm2, eax
	movsx	eax, WORD PTR [rcx+r8+42]
	cvtsi2ss xmm3, eax
	movaps	xmm0, xmm2
	mulss	xmm2, xmm6
	movaps	xmm1, xmm3
	mulss	xmm0, xmm9
	mulss	xmm1, xmm7
	mulss	xmm3, xmm8
	addss	xmm1, xmm0
	addss	xmm3, xmm2
	xorps	xmm2, xmm2
	addss	xmm1, xmm12
	addss	xmm3, xmm13
	mulss	xmm1, xmm11
	mulss	xmm3, xmm10
	cvttss2si eax, xmm1
	mov	WORD PTR [rcx+r8+42], ax
	cvttss2si eax, xmm3
	mov	WORD PTR [rcx+r8+44], ax
	movsx	eax, WORD PTR [rcx+r8+48]
	cvtsi2ss xmm2, eax
	movsx	eax, WORD PTR [rcx+r8+46]

; 1873 :                x=v->cx; y=v->cy;
; 1874 :                v->cx = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));

	xorps	xmm3, xmm3
	movaps	xmm0, xmm2
	cvtsi2ss xmm3, eax
	mulss	xmm0, xmm9
	movaps	xmm1, xmm3

; 1875 :                v->cy = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));

	mulss	xmm2, xmm6
	mulss	xmm1, xmm7
	mulss	xmm3, xmm8
	addss	xmm1, xmm0
	addss	xmm3, xmm2
	addss	xmm1, xmm12
	addss	xmm3, xmm13
	mulss	xmm1, xmm11
	mulss	xmm3, xmm10
	cvttss2si eax, xmm1
	mov	WORD PTR [rcx+r8+46], ax
	cvttss2si eax, xmm3
	mov	WORD PTR [rcx+r8+48], ax
	add	r8, 56					; 00000038H
	sub	rdx, 1
	jne	$LL178@stbtt__Get

; 1866 :             // Transform vertices.
; 1867 :             for (i = 0; i < comp_num_verts; ++i) {

	cmp	r9, rsi
	jl	SHORT $LN190@stbtt__Get
	jmp	$LN176@stbtt__Get
$LC177@stbtt__Get:
	test	r10d, r10d
	jle	$LN176@stbtt__Get
$LN190@stbtt__Get:
	imul	rdx, r9, 14
	mov	r8, rsi
	sub	r8, r9
$LC189@stbtt__Get:

; 1868 :                stbtt_vertex* v = &comp_verts[i];

	mov	rcx, QWORD PTR comp_verts$2[rsp]
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2

; 1869 :                stbtt_vertex_type x,y;
; 1870 :                x=v->x; y=v->y;
; 1871 :                v->x = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));

	movsx	eax, WORD PTR [rcx+rdx+2]
	cvtsi2ss xmm2, eax
	movsx	eax, WORD PTR [rcx+rdx]
	cvtsi2ss xmm3, eax
	movaps	xmm0, xmm2

; 1872 :                v->y = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));

	mulss	xmm2, xmm6
	movaps	xmm1, xmm3
	mulss	xmm0, xmm9
	mulss	xmm3, xmm8
	mulss	xmm1, xmm7
	addss	xmm3, xmm2
	xorps	xmm2, xmm2
	addss	xmm1, xmm0
	addss	xmm3, xmm13
	addss	xmm1, xmm12
	mulss	xmm3, xmm10
	mulss	xmm1, xmm11
	cvttss2si eax, xmm1
	mov	WORD PTR [rcx+rdx], ax
	cvttss2si eax, xmm3
	xorps	xmm3, xmm3
	mov	WORD PTR [rcx+rdx+2], ax

; 1873 :                x=v->cx; y=v->cy;
; 1874 :                v->cx = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));

	movsx	eax, WORD PTR [rcx+rdx+6]
	cvtsi2ss xmm2, eax
	movsx	eax, WORD PTR [rcx+rdx+4]
	cvtsi2ss xmm3, eax
	movaps	xmm0, xmm2

; 1875 :                v->cy = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));

	mulss	xmm2, xmm6
	movaps	xmm1, xmm3
	mulss	xmm0, xmm9
	mulss	xmm1, xmm7
	mulss	xmm3, xmm8
	addss	xmm1, xmm0
	addss	xmm3, xmm2
	addss	xmm1, xmm12
	addss	xmm3, xmm13
	mulss	xmm1, xmm11
	mulss	xmm3, xmm10
	cvttss2si eax, xmm1
	mov	WORD PTR [rcx+rdx+4], ax
	cvttss2si eax, xmm3
	mov	WORD PTR [rcx+rdx+6], ax
	add	rdx, 14
	sub	r8, 1
	jne	$LC189@stbtt__Get
$LN176@stbtt__Get:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN80@stbtt__Get

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN80@stbtt__Get:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 1878 :             tmp = (stbtt_vertex*)STBTT_malloc((num_vertices+comp_num_verts)*sizeof(stbtt_vertex), info->userdata);

	lea	r12d, DWORD PTR [r10+r15]
	movsxd	rax, r12d
	imul	rcx, rax, 14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
	mov	r14, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 1879 :             if (!tmp) {

	test	rax, rax
	je	$LN163@stbtt__Get

; 1883 :             }
; 1884 :             if (num_vertices > 0 && vertices) STBTT_memcpy(tmp, vertices, num_vertices*sizeof(stbtt_vertex));

	test	r15d, r15d
	jle	SHORT $LN62@stbtt__Get
	test	rdi, rdi
	je	SHORT $LN62@stbtt__Get
	movsxd	rcx, r15d
	mov	rdx, rdi
	imul	r8, rcx, 14
	mov	rcx, rax
	call	memcpy
$LN62@stbtt__Get:

; 1885 :             STBTT_memcpy(tmp+num_vertices, comp_verts, comp_num_verts*sizeof(stbtt_vertex));

	mov	rdx, QWORD PTR comp_verts$2[rsp]
	movsxd	rax, r15d
	imul	rcx, rax, 14
	imul	r8, rsi, 14
	add	rcx, r14
	call	memcpy

; 1886 :             if (vertices) STBTT_free(vertices, info->userdata);

	test	rdi, rdi
	je	SHORT $LN124@stbtt__Get
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN122@stbtt__Get

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN122@stbtt__Get:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	mov	rcx, rdi
	call	QWORD PTR __imp_free
$LN124@stbtt__Get:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 1888 :             STBTT_free(comp_verts, info->userdata);

	mov	rcx, QWORD PTR comp_verts$2[rsp]
	mov	rdi, r14
	test	rcx, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	je	SHORT $LN88@stbtt__Get

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN88@stbtt__Get

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN88@stbtt__Get:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 1889 :             num_vertices += comp_num_verts;

	mov	r15d, r12d
	xor	r12d, r12d
$LN58@stbtt__Get:

; 1890 :          }
; 1891 :          // More components ?
; 1892 :          more = flags & (1<<5);

	test	bpl, 32					; 00000020H
	je	$LN199@stbtt__Get

; 1823 :       while (more) {

	mov	r8d, 256				; 00000100H
	jmp	$LL14@stbtt__Get
$LN163@stbtt__Get:

; 1880 :                if (vertices) STBTT_free(vertices, info->userdata);

	test	rdi, rdi
	je	SHORT $LN108@stbtt__Get
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN106@stbtt__Get

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN106@stbtt__Get:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	mov	rcx, rdi
	call	QWORD PTR __imp_free
$LN108@stbtt__Get:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 1881 :                if (comp_verts) STBTT_free(comp_verts, info->userdata);

	mov	rcx, QWORD PTR comp_verts$2[rsp]
	test	rcx, rcx
	je	SHORT $LN116@stbtt__Get
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN114@stbtt__Get

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN114@stbtt__Get:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
$LN116@stbtt__Get:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 1882 :                return 0;

	xor	eax, eax
$LN1@stbtt__Get:

; 1900 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+320]
	mov	rbx, QWORD PTR [r11+88]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	movaps	xmm14, XMMWORD PTR [r11-144]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?stbtt__GetGlyphShapeTT@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z ENDP ; stbtt__GetGlyphShapeTT
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__track_vertex@@YAXPEAUstbtt__csctx@@HH@Z
_TEXT	SEGMENT
c$ = 8
x$ = 16
y$ = 24
?stbtt__track_vertex@@YAXPEAUstbtt__csctx@@HH@Z PROC	; stbtt__track_vertex, COMDAT

; 1918 :    if (x > c->max_x || !c->started) c->max_x = x;

	lea	rax, QWORD PTR [rcx+4]
	cmp	edx, DWORD PTR [rcx+28]
	jg	SHORT $LN11@stbtt__tra
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN2@stbtt__tra
$LN11@stbtt__tra:
	mov	DWORD PTR [rcx+28], edx
$LN2@stbtt__tra:

; 1919 :    if (y > c->max_y || !c->started) c->max_y = y;

	cmp	r8d, DWORD PTR [rcx+36]
	jg	SHORT $LN15@stbtt__tra
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN4@stbtt__tra
$LN15@stbtt__tra:
	mov	DWORD PTR [rcx+36], r8d
$LN4@stbtt__tra:

; 1920 :    if (x < c->min_x || !c->started) c->min_x = x;

	cmp	edx, DWORD PTR [rcx+24]
	jl	SHORT $LN16@stbtt__tra
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN6@stbtt__tra
$LN16@stbtt__tra:
	mov	DWORD PTR [rcx+24], edx
$LN6@stbtt__tra:

; 1921 :    if (y < c->min_y || !c->started) c->min_y = y;

	cmp	r8d, DWORD PTR [rcx+32]
	jl	SHORT $LN9@stbtt__tra
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN18@stbtt__tra
$LN9@stbtt__tra:
	mov	DWORD PTR [rcx+32], r8d
$LN18@stbtt__tra:

; 1922 :    c->started = 1;
; 1923 : }

	mov	DWORD PTR [rax], 1
	ret	0
?stbtt__track_vertex@@YAXPEAUstbtt__csctx@@HH@Z ENDP	; stbtt__track_vertex
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z
_TEXT	SEGMENT
c$ = 16
type$ = 24
x$ = 32
y$ = 40
cx$ = 48
cy$ = 56
cx1$ = 64
cy1$ = 72
?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z PROC	; stbtt__csctx_v, COMDAT

; 1926 : {

	push	rsi

; 1927 :    if (c->bounds) {

	cmp	DWORD PTR [rcx], 0
	movzx	esi, dl
	mov	r10, rcx
	je	$LN2@stbtt__csc

; 1918 :    if (x > c->max_x || !c->started) c->max_x = x;

	mov	r11d, DWORD PTR [rcx+28]
	lea	rax, QWORD PTR [rcx+4]

; 1927 :    if (c->bounds) {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rdi

; 1918 :    if (x > c->max_x || !c->started) c->max_x = x;

	cmp	r8d, r11d
	jg	SHORT $LN38@stbtt__csc
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN7@stbtt__csc
$LN38@stbtt__csc:
	mov	DWORD PTR [rcx+28], r8d
	mov	r11d, r8d
$LN7@stbtt__csc:

; 1919 :    if (y > c->max_y || !c->started) c->max_y = y;

	mov	edi, DWORD PTR [rcx+36]
	cmp	r9d, edi
	jg	SHORT $LN42@stbtt__csc
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN9@stbtt__csc
$LN42@stbtt__csc:
	mov	DWORD PTR [rcx+36], r9d
	mov	edi, r9d
$LN9@stbtt__csc:

; 1920 :    if (x < c->min_x || !c->started) c->min_x = x;

	mov	ebx, DWORD PTR [rcx+24]
	cmp	r8d, ebx
	jl	SHORT $LN43@stbtt__csc
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN11@stbtt__csc
$LN43@stbtt__csc:
	mov	DWORD PTR [rcx+24], r8d
	mov	ebx, r8d
$LN11@stbtt__csc:

; 1921 :    if (y < c->min_y || !c->started) c->min_y = y;

	mov	edx, DWORD PTR [rcx+32]
	cmp	r9d, edx
	jl	SHORT $LN14@stbtt__csc
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN13@stbtt__csc
$LN14@stbtt__csc:
	mov	DWORD PTR [rcx+32], r9d
	mov	edx, r9d
$LN13@stbtt__csc:

; 1922 :    c->started = 1;

	mov	DWORD PTR [rax], 1

; 1928 :       stbtt__track_vertex(c, x, y);
; 1929 :       if (type == STBTT_vcubic) {

	cmp	sil, 4
	jne	SHORT $LN33@stbtt__csc

; 1918 :    if (x > c->max_x || !c->started) c->max_x = x;

	mov	eax, DWORD PTR cx$[rsp]
	cmp	eax, r11d
	jle	SHORT $LN17@stbtt__csc
	mov	DWORD PTR [rcx+28], eax
	mov	r11d, eax
$LN17@stbtt__csc:

; 1919 :    if (y > c->max_y || !c->started) c->max_y = y;

	mov	ecx, DWORD PTR cy$[rsp]
	cmp	ecx, edi
	jle	SHORT $LN19@stbtt__csc
	mov	DWORD PTR [r10+36], ecx
	mov	edi, ecx
$LN19@stbtt__csc:

; 1920 :    if (x < c->min_x || !c->started) c->min_x = x;

	cmp	eax, ebx
	jge	SHORT $LN21@stbtt__csc
	mov	DWORD PTR [r10+24], eax
	mov	ebx, eax
$LN21@stbtt__csc:

; 1921 :    if (y < c->min_y || !c->started) c->min_y = y;

	cmp	ecx, edx
	jge	SHORT $LN23@stbtt__csc
	mov	DWORD PTR [r10+32], ecx
	mov	edx, ecx
$LN23@stbtt__csc:

; 1918 :    if (x > c->max_x || !c->started) c->max_x = x;

	mov	ecx, DWORD PTR cx1$[rsp]
	cmp	ecx, r11d
	jle	SHORT $LN27@stbtt__csc
	mov	DWORD PTR [r10+28], ecx
$LN27@stbtt__csc:

; 1919 :    if (y > c->max_y || !c->started) c->max_y = y;

	mov	eax, DWORD PTR cy1$[rsp]
	cmp	eax, edi
	jle	SHORT $LN29@stbtt__csc
	mov	DWORD PTR [r10+36], eax
$LN29@stbtt__csc:

; 1920 :    if (x < c->min_x || !c->started) c->min_x = x;

	cmp	ecx, ebx
	jge	SHORT $LN31@stbtt__csc
	mov	DWORD PTR [r10+24], ecx
$LN31@stbtt__csc:

; 1921 :    if (y < c->min_y || !c->started) c->min_y = y;

	cmp	eax, edx
	jge	SHORT $LN33@stbtt__csc
	mov	DWORD PTR [r10+32], eax
$LN33@stbtt__csc:

; 1937 :    }
; 1938 :    c->num_vertices++;

	inc	DWORD PTR [r10+48]
	mov	rdi, QWORD PTR [rsp+24]
	mov	rbx, QWORD PTR [rsp+16]

; 1939 : }

	pop	rsi
	ret	0
$LN2@stbtt__csc:

; 1930 :          stbtt__track_vertex(c, cx, cy);
; 1931 :          stbtt__track_vertex(c, cx1, cy1);
; 1932 :       }
; 1933 :    } else {
; 1934 :       stbtt_setvertex(&c->pvertices[c->num_vertices], type, x, y, cx, cy);

	movsxd	rax, DWORD PTR [rcx+48]
	imul	rdx, rax, 14

; 1604 :    v->cx = (stbtt_int16) cx;

	movzx	eax, WORD PTR cx$[rsp]

; 1930 :          stbtt__track_vertex(c, cx, cy);
; 1931 :          stbtt__track_vertex(c, cx1, cy1);
; 1932 :       }
; 1933 :    } else {
; 1934 :       stbtt_setvertex(&c->pvertices[c->num_vertices], type, x, y, cx, cy);

	add	rdx, QWORD PTR [rcx+40]

; 1937 :    }
; 1938 :    c->num_vertices++;

	inc	DWORD PTR [rcx+48]

; 1604 :    v->cx = (stbtt_int16) cx;

	mov	WORD PTR [rdx+4], ax

; 1605 :    v->cy = (stbtt_int16) cy;

	movzx	eax, WORD PTR cy$[rsp]
	mov	WORD PTR [rdx+6], ax

; 1935 :       c->pvertices[c->num_vertices].cx1 = (stbtt_int16) cx1;

	movzx	eax, WORD PTR cx1$[rsp]

; 1601 :    v->type = type;

	mov	BYTE PTR [rdx+12], sil

; 1602 :    v->x = (stbtt_int16) x;

	mov	WORD PTR [rdx], r8w

; 1603 :    v->y = (stbtt_int16) y;

	mov	WORD PTR [rdx+2], r9w

; 1935 :       c->pvertices[c->num_vertices].cx1 = (stbtt_int16) cx1;

	mov	WORD PTR [rdx+8], ax

; 1936 :       c->pvertices[c->num_vertices].cy1 = (stbtt_int16) cy1;

	movzx	eax, WORD PTR cy1$[rsp]
	mov	WORD PTR [rdx+10], ax

; 1939 : }

	pop	rsi
	ret	0
?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z ENDP	; stbtt__csctx_v
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__csctx_close_shape@@YAXPEAUstbtt__csctx@@@Z
_TEXT	SEGMENT
ctx$ = 8
?stbtt__csctx_close_shape@@YAXPEAUstbtt__csctx@@@Z PROC	; stbtt__csctx_close_shape, COMDAT

; 1943 :    if (ctx->first_x != ctx->x || ctx->first_y != ctx->y)

	movss	xmm1, DWORD PTR [rcx+8]
	mov	rdx, rcx
	ucomiss	xmm1, DWORD PTR [rcx+16]
	jp	SHORT $LN42@stbtt__csc
	jne	SHORT $LN42@stbtt__csc
	movss	xmm0, DWORD PTR [rcx+12]
	ucomiss	xmm0, DWORD PTR [rcx+20]
	jp	SHORT $LN42@stbtt__csc
	je	$LN2@stbtt__csc
$LN42@stbtt__csc:

; 1927 :    if (c->bounds) {

	cmp	DWORD PTR [rcx], 0

; 1944 :       stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->first_x, (int)ctx->first_y, 0, 0, 0, 0);

	cvttss2si r8d, DWORD PTR [rcx+12]
	cvttss2si r9d, xmm1

; 1927 :    if (c->bounds) {

	je	SHORT $LN6@stbtt__csc

; 1918 :    if (x > c->max_x || !c->started) c->max_x = x;

	lea	rax, QWORD PTR [rcx+4]
	cmp	r9d, DWORD PTR [rcx+28]
	jg	SHORT $LN43@stbtt__csc
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN11@stbtt__csc
$LN43@stbtt__csc:
	mov	DWORD PTR [rcx+28], r9d
$LN11@stbtt__csc:

; 1919 :    if (y > c->max_y || !c->started) c->max_y = y;

	cmp	r8d, DWORD PTR [rcx+36]
	jg	SHORT $LN48@stbtt__csc
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN13@stbtt__csc
$LN48@stbtt__csc:
	mov	DWORD PTR [rcx+36], r8d
$LN13@stbtt__csc:

; 1920 :    if (x < c->min_x || !c->started) c->min_x = x;

	cmp	r9d, DWORD PTR [rcx+24]
	jl	SHORT $LN49@stbtt__csc
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN15@stbtt__csc
$LN49@stbtt__csc:
	mov	DWORD PTR [rcx+24], r9d
$LN15@stbtt__csc:

; 1921 :    if (y < c->min_y || !c->started) c->min_y = y;

	cmp	r8d, DWORD PTR [rcx+32]
	jl	SHORT $LN18@stbtt__csc
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN17@stbtt__csc
$LN18@stbtt__csc:
	mov	DWORD PTR [rcx+32], r8d
$LN17@stbtt__csc:

; 1938 :    c->num_vertices++;

	inc	DWORD PTR [rdx+48]

; 1922 :    c->started = 1;

	mov	DWORD PTR [rax], 1

; 1945 : }

	ret	0
$LN6@stbtt__csc:

; 1934 :       stbtt_setvertex(&c->pvertices[c->num_vertices], type, x, y, cx, cy);

	movsxd	rax, DWORD PTR [rcx+48]
	imul	rcx, rax, 14
	mov	rax, QWORD PTR [rdx+40]

; 1603 :    v->y = (stbtt_int16) y;

	mov	WORD PTR [rcx+rax+2], r8w

; 1604 :    v->cx = (stbtt_int16) cx;

	xor	r8d, r8d

; 1938 :    c->num_vertices++;

	inc	DWORD PTR [rdx+48]

; 1604 :    v->cx = (stbtt_int16) cx;

	mov	QWORD PTR [rcx+rax+4], r8
	mov	BYTE PTR [rcx+rax+12], 2
	mov	WORD PTR [rcx+rax], r9w
$LN2@stbtt__csc:

; 1945 : }

	ret	0
?stbtt__csctx_close_shape@@YAXPEAUstbtt__csctx@@@Z ENDP	; stbtt__csctx_close_shape
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__csctx_rmove_to@@YAXPEAUstbtt__csctx@@MM@Z
_TEXT	SEGMENT
ctx$ = 48
dx$ = 56
dy$ = 64
?stbtt__csctx_rmove_to@@YAXPEAUstbtt__csctx@@MM@Z PROC	; stbtt__csctx_rmove_to, COMDAT

; 1948 : {

	sub	rsp, 40					; 00000028H
	movaps	xmm3, xmm1
	mov	r10, rcx

; 1949 :    stbtt__csctx_close_shape(ctx);

	call	?stbtt__csctx_close_shape@@YAXPEAUstbtt__csctx@@@Z ; stbtt__csctx_close_shape

; 1927 :    if (c->bounds) {

	cmp	DWORD PTR [r10], 0

; 1950 :    ctx->first_x = ctx->x = ctx->x + dx;

	addss	xmm3, DWORD PTR [r10+16]

; 1951 :    ctx->first_y = ctx->y = ctx->y + dy;

	addss	xmm2, DWORD PTR [r10+20]
	movss	DWORD PTR [r10+16], xmm3
	movss	DWORD PTR [r10+8], xmm3
	movss	DWORD PTR [r10+20], xmm2
	movss	DWORD PTR [r10+12], xmm2

; 1952 :    stbtt__csctx_v(ctx, STBTT_vmove, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);

	cvttss2si edx, xmm2
	cvttss2si r8d, xmm3

; 1927 :    if (c->bounds) {

	je	SHORT $LN4@stbtt__csc

; 1918 :    if (x > c->max_x || !c->started) c->max_x = x;

	lea	rax, QWORD PTR [r10+4]
	cmp	r8d, DWORD PTR [r10+28]
	jg	SHORT $LN40@stbtt__csc
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN9@stbtt__csc
$LN40@stbtt__csc:
	mov	DWORD PTR [r10+28], r8d
$LN9@stbtt__csc:

; 1919 :    if (y > c->max_y || !c->started) c->max_y = y;

	cmp	edx, DWORD PTR [r10+36]
	jg	SHORT $LN44@stbtt__csc
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN11@stbtt__csc
$LN44@stbtt__csc:
	mov	DWORD PTR [r10+36], edx
$LN11@stbtt__csc:

; 1920 :    if (x < c->min_x || !c->started) c->min_x = x;

	cmp	r8d, DWORD PTR [r10+24]
	jl	SHORT $LN45@stbtt__csc
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN13@stbtt__csc
$LN45@stbtt__csc:
	mov	DWORD PTR [r10+24], r8d
$LN13@stbtt__csc:

; 1921 :    if (y < c->min_y || !c->started) c->min_y = y;

	cmp	edx, DWORD PTR [r10+32]
	jl	SHORT $LN16@stbtt__csc
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN15@stbtt__csc
$LN16@stbtt__csc:
	mov	DWORD PTR [r10+32], edx
$LN15@stbtt__csc:

; 1953 : }

	inc	DWORD PTR [r10+48]

; 1922 :    c->started = 1;

	mov	DWORD PTR [rax], 1

; 1953 : }

	add	rsp, 40					; 00000028H
	ret	0
$LN4@stbtt__csc:

; 1934 :       stbtt_setvertex(&c->pvertices[c->num_vertices], type, x, y, cx, cy);

	movsxd	rax, DWORD PTR [r10+48]
	imul	rcx, rax, 14
	mov	rax, QWORD PTR [r10+40]

; 1603 :    v->y = (stbtt_int16) y;

	mov	WORD PTR [rcx+rax+2], dx

; 1604 :    v->cx = (stbtt_int16) cx;

	xor	edx, edx

; 1953 : }

	inc	DWORD PTR [r10+48]

; 1604 :    v->cx = (stbtt_int16) cx;

	mov	QWORD PTR [rcx+rax+4], rdx
	mov	BYTE PTR [rcx+rax+12], 1
	mov	WORD PTR [rcx+rax], r8w

; 1953 : }

	add	rsp, 40					; 00000028H
	ret	0
?stbtt__csctx_rmove_to@@YAXPEAUstbtt__csctx@@MM@Z ENDP	; stbtt__csctx_rmove_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__csctx_rline_to@@YAXPEAUstbtt__csctx@@MM@Z
_TEXT	SEGMENT
ctx$ = 8
dx$ = 16
dy$ = 24
?stbtt__csctx_rline_to@@YAXPEAUstbtt__csctx@@MM@Z PROC	; stbtt__csctx_rline_to, COMDAT

; 1927 :    if (c->bounds) {

	cmp	DWORD PTR [rcx], 0

; 1956 : {

	mov	rdx, rcx

; 1957 :    ctx->x += dx;

	addss	xmm1, DWORD PTR [rcx+16]

; 1958 :    ctx->y += dy;

	addss	xmm2, DWORD PTR [rcx+20]
	movss	DWORD PTR [rcx+16], xmm1
	movss	DWORD PTR [rcx+20], xmm2

; 1959 :    stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);

	cvttss2si r8d, xmm2
	cvttss2si r9d, xmm1

; 1927 :    if (c->bounds) {

	je	SHORT $LN4@stbtt__csc

; 1918 :    if (x > c->max_x || !c->started) c->max_x = x;

	lea	rax, QWORD PTR [rcx+4]
	cmp	r9d, DWORD PTR [rcx+28]
	jg	SHORT $LN40@stbtt__csc
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN9@stbtt__csc
$LN40@stbtt__csc:
	mov	DWORD PTR [rcx+28], r9d
$LN9@stbtt__csc:

; 1919 :    if (y > c->max_y || !c->started) c->max_y = y;

	cmp	r8d, DWORD PTR [rcx+36]
	jg	SHORT $LN44@stbtt__csc
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN11@stbtt__csc
$LN44@stbtt__csc:
	mov	DWORD PTR [rcx+36], r8d
$LN11@stbtt__csc:

; 1920 :    if (x < c->min_x || !c->started) c->min_x = x;

	cmp	r9d, DWORD PTR [rcx+24]
	jl	SHORT $LN45@stbtt__csc
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN13@stbtt__csc
$LN45@stbtt__csc:
	mov	DWORD PTR [rcx+24], r9d
$LN13@stbtt__csc:

; 1921 :    if (y < c->min_y || !c->started) c->min_y = y;

	cmp	r8d, DWORD PTR [rcx+32]
	jl	SHORT $LN16@stbtt__csc
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN15@stbtt__csc
$LN16@stbtt__csc:
	mov	DWORD PTR [rcx+32], r8d
$LN15@stbtt__csc:

; 1938 :    c->num_vertices++;

	inc	DWORD PTR [rcx+48]

; 1922 :    c->started = 1;

	mov	DWORD PTR [rax], 1

; 1960 : }

	ret	0
$LN4@stbtt__csc:

; 1934 :       stbtt_setvertex(&c->pvertices[c->num_vertices], type, x, y, cx, cy);

	movsxd	rax, DWORD PTR [rcx+48]

; 1935 :       c->pvertices[c->num_vertices].cx1 = (stbtt_int16) cx1;
; 1936 :       c->pvertices[c->num_vertices].cy1 = (stbtt_int16) cy1;
; 1937 :    }
; 1938 :    c->num_vertices++;

	inc	DWORD PTR [rdx+48]
	imul	rcx, rax, 14
	mov	rax, QWORD PTR [rdx+40]

; 1603 :    v->y = (stbtt_int16) y;

	mov	WORD PTR [rcx+rax+2], r8w

; 1604 :    v->cx = (stbtt_int16) cx;

	xor	r8d, r8d
	mov	QWORD PTR [rcx+rax+4], r8
	mov	BYTE PTR [rcx+rax+12], 2
	mov	WORD PTR [rcx+rax], r9w

; 1960 : }

	ret	0
?stbtt__csctx_rline_to@@YAXPEAUstbtt__csctx@@MM@Z ENDP	; stbtt__csctx_rline_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z
_TEXT	SEGMENT
ctx$ = 96
dx1$ = 104
dy1$ = 112
dx2$ = 120
dy2$ = 128
dx3$ = 136
dy3$ = 144
?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z PROC ; stbtt__csctx_rccurve_to, COMDAT

; 1963 : {

	sub	rsp, 88					; 00000058H
	movaps	xmm5, xmm1
	movaps	XMMWORD PTR [rsp+64], xmm6

; 1964 :    float cx1 = ctx->x + dx1;

	addss	xmm5, DWORD PTR [rcx+16]
	movaps	xmm6, xmm2
	mov	r11, rcx

; 1965 :    float cy1 = ctx->y + dy1;

	addss	xmm6, DWORD PTR [rcx+20]

; 1966 :    float cx2 = cx1 + dx2;

	movaps	xmm4, xmm5
	addss	xmm4, xmm3

; 1967 :    float cy2 = cy1 + dy2;
; 1968 :    ctx->x = cx2 + dx3;
; 1969 :    ctx->y = cy2 + dy3;
; 1970 :    stbtt__csctx_v(ctx, STBTT_vcubic, (int)ctx->x, (int)ctx->y, (int)cx1, (int)cy1, (int)cx2, (int)cy2);

	cvttss2si edx, xmm6
	movaps	xmm2, xmm6
	movaps	xmm1, xmm4
	addss	xmm2, DWORD PTR dy2$[rsp]
	addss	xmm1, DWORD PTR dx3$[rsp]
	cvttss2si r10d, xmm5
	movss	DWORD PTR [rcx+16], xmm1
	movaps	xmm0, xmm2
	addss	xmm0, DWORD PTR dy3$[rsp]
	cvttss2si eax, xmm2
	movss	DWORD PTR [rcx+20], xmm0
	mov	DWORD PTR [rsp+56], eax
	cvttss2si ecx, xmm4
	cvttss2si r9d, xmm0
	mov	DWORD PTR [rsp+48], ecx
	mov	rcx, r11
	mov	DWORD PTR [rsp+40], edx
	mov	dl, 4
	mov	DWORD PTR [rsp+32], r10d
	cvttss2si r8d, xmm1
	call	?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z ; stbtt__csctx_v

; 1971 : }

	movaps	xmm6, XMMWORD PTR [rsp+64]
	add	rsp, 88					; 00000058H
	ret	0
?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ENDP ; stbtt__csctx_rccurve_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__get_subr@@YA?AUstbtt__buf@@U1@H@Z
_TEXT	SEGMENT
$T1 = 32
__$ReturnAddress$ = 64
idx$ = 72
n$ = 80
?stbtt__get_subr@@YA?AUstbtt__buf@@U1@H@Z PROC		; stbtt__get_subr, COMDAT

; 1974 : {

	push	rbx
	sub	rsp, 48					; 00000030H

; 1155 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

	mov	r11d, DWORD PTR [rdx+12]
	xor	r10d, r10d
	test	r11d, r11d

; 1974 : {

	mov	r9, rdx
	mov	rbx, rcx

; 1155 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

	cmovs	r10d, r11d
	mov	DWORD PTR [rdx+8], r10d

; 1140 :    if (b->cursor >= b->size)

	cmp	r10d, r11d
	jl	SHORT $LN26@stbtt__get

; 1141 :       return 0;

	xor	edx, edx
	xor	cl, cl
	jmp	SHORT $LN37@stbtt__get
$LN26@stbtt__get:

; 1142 :    return b->data[b->cursor++];

	mov	rax, QWORD PTR [rdx]
	movsxd	rcx, r10d
	inc	r10d
	mov	DWORD PTR [rdx+8], r10d

; 1169 :       v = (v << 8) | stbtt__buf_get8(b);

	movzx	edx, BYTE PTR [rcx+rax]

; 1140 :    if (b->cursor >= b->size)

	cmp	r10d, r11d
	jl	SHORT $LN36@stbtt__get

; 1141 :       return 0;

	xor	cl, cl
	jmp	SHORT $LN37@stbtt__get
$LN36@stbtt__get:

; 1142 :    return b->data[b->cursor++];

	movsxd	rcx, r10d
	movzx	ecx, BYTE PTR [rcx+rax]
	lea	eax, DWORD PTR [r10+1]
	mov	DWORD PTR [r9+8], eax
$LN37@stbtt__get:

; 1169 :       v = (v << 8) | stbtt__buf_get8(b);

	shl	edx, 8
	movzx	eax, cl
	or	edx, eax

; 1975 :    int count = stbtt__cff_index_count(&idx);
; 1976 :    int bias = 107;

	mov	eax, 107				; 0000006bH

; 1977 :    if (count >= 33900)

	cmp	edx, 33900				; 0000846cH
	jb	SHORT $LN2@stbtt__get

; 1978 :       bias = 32768;

	mov	eax, 32768				; 00008000H
	jmp	SHORT $LN4@stbtt__get
$LN2@stbtt__get:

; 1979 :    else if (count >= 1240)

	cmp	edx, 1240				; 000004d8H
	mov	ecx, 1131				; 0000046bH
	cmovae	eax, ecx
$LN4@stbtt__get:

; 1980 :       bias = 1131;
; 1981 :    n += bias;

	add	r8d, eax

; 1982 :    if (n < 0 || n >= count)

	js	SHORT $LN31@stbtt__get
	cmp	r8d, edx
	jge	SHORT $LN31@stbtt__get

; 1983 :       return stbtt__new_buf(NULL, 0);
; 1984 :    return stbtt__cff_index_get(idx, n);

	movaps	xmm0, XMMWORD PTR [r9]
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rbx
	movdqa	XMMWORD PTR $T1[rsp], xmm0
	call	?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z ; stbtt__cff_index_get

; 1985 : }

	mov	rax, rbx
	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
$LN31@stbtt__get:

; 1177 :    r.data = (stbtt_uint8*) p;

	mov	QWORD PTR [rbx], 0

; 1985 : }

	mov	rax, rbx

; 1179 :    r.cursor = 0;

	mov	QWORD PTR [rbx+8], 0

; 1985 : }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
?stbtt__get_subr@@YA?AUstbtt__buf@@U1@H@Z ENDP		; stbtt__get_subr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__cid_get_glyph_subrs@@YA?AUstbtt__buf@@PEBUstbtt_fontinfo@@H@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
fdselect$ = 32
$T3 = 48
$T4 = 64
__$ReturnAddress$ = 112
info$ = 120
glyph_index$ = 128
?stbtt__cid_get_glyph_subrs@@YA?AUstbtt__buf@@PEBUstbtt_fontinfo@@H@Z PROC ; stbtt__cid_get_glyph_subrs, COMDAT

; 1988 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H

; 1989 :    stbtt__buf fdselect = info->fdselect;

	movups	xmm1, XMMWORD PTR [rdx+144]

; 1155 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

	mov	rax, QWORD PTR [rdx+152]

; 1988 : {

	mov	r14d, r8d

; 1155 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

	shr	rax, 32					; 00000020H

; 1988 : {

	mov	rbp, rdx
	mov	r15, rcx

; 1155 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

	movq	r9, xmm1

; 1989 :    stbtt__buf fdselect = info->fdselect;

	movups	XMMWORD PTR fdselect$[rsp], xmm1

; 1155 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

	test	eax, eax
	js	$LN16@stbtt__cid

; 1140 :    if (b->cursor >= b->size)

	mov	edx, DWORD PTR fdselect$[rsp+12]

; 1155 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

	xor	edi, edi
	mov	DWORD PTR fdselect$[rsp+8], edi

; 1140 :    if (b->cursor >= b->size)

	test	edx, edx
	jle	$LN100@stbtt__cid

; 1142 :    return b->data[b->cursor++];

	movzx	ecx, BYTE PTR [r9]
	lea	eax, QWORD PTR [rdi+1]

; 1990 :    int nranges, start, end, v, fmt, fdselector = -1, i;
; 1991 : 
; 1992 :    stbtt__buf_seek(&fdselect, 0);
; 1993 :    fmt = stbtt__buf_get8(&fdselect);
; 1994 :    if (fmt == 0) {

	test	cl, cl
	je	$LN103@stbtt__cid

; 1998 :    } else if (fmt == 3) {

	cmp	cl, 3
	jne	$LN104@stbtt__cid

; 1140 :    if (b->cursor >= b->size)

	cmp	eax, edx
	jl	SHORT $LN42@stbtt__cid

; 1141 :       return 0;

	xor	cl, cl
	jmp	SHORT $LN41@stbtt__cid
$LN42@stbtt__cid:

; 1142 :    return b->data[b->cursor++];

	movsxd	rcx, eax
	inc	eax
	movzx	ecx, BYTE PTR [rcx+r9]
$LN41@stbtt__cid:

; 1169 :       v = (v << 8) | stbtt__buf_get8(b);

	movzx	esi, cl

; 1140 :    if (b->cursor >= b->size)

	cmp	eax, edx
	jl	SHORT $LN84@stbtt__cid

; 1141 :       return 0;

	xor	cl, cl
	jmp	SHORT $LN85@stbtt__cid
$LN84@stbtt__cid:

; 1142 :    return b->data[b->cursor++];

	movsxd	rcx, eax
	inc	eax
	movzx	ecx, BYTE PTR [rcx+r9]
$LN85@stbtt__cid:

; 1169 :       v = (v << 8) | stbtt__buf_get8(b);

	shl	esi, 8
	movzx	ecx, cl
	or	esi, ecx

; 1140 :    if (b->cursor >= b->size)

	cmp	eax, edx
	jl	SHORT $LN53@stbtt__cid

; 1141 :       return 0;

	xor	cl, cl
	jmp	SHORT $LN52@stbtt__cid
$LN53@stbtt__cid:

; 1142 :    return b->data[b->cursor++];

	movsxd	rcx, eax
	inc	eax
	movzx	ecx, BYTE PTR [rcx+r9]
$LN52@stbtt__cid:

; 1169 :       v = (v << 8) | stbtt__buf_get8(b);

	movzx	ebx, cl

; 1140 :    if (b->cursor >= b->size)

	cmp	eax, edx
	jl	SHORT $LN87@stbtt__cid

; 1141 :       return 0;

	xor	cl, cl
	jmp	SHORT $LN88@stbtt__cid
$LN87@stbtt__cid:

; 1142 :    return b->data[b->cursor++];

	movsxd	rcx, eax
	inc	eax
	movzx	ecx, BYTE PTR [rcx+r9]
$LN88@stbtt__cid:

; 1169 :       v = (v << 8) | stbtt__buf_get8(b);

	shl	ebx, 8

; 1999 :       nranges = stbtt__buf_get16(&fdselect);
; 2000 :       start = stbtt__buf_get16(&fdselect);
; 2001 :       for (i = 0; i < nranges; i++) {

	mov	r10d, edi

; 1169 :       v = (v << 8) | stbtt__buf_get8(b);

	movzx	ecx, cl
	or	ebx, ecx

; 1999 :       nranges = stbtt__buf_get16(&fdselect);
; 2000 :       start = stbtt__buf_get16(&fdselect);
; 2001 :       for (i = 0; i < nranges; i++) {

	test	esi, esi
	je	SHORT $LN104@stbtt__cid
$LL4@stbtt__cid:

; 1140 :    if (b->cursor >= b->size)

	cmp	eax, edx
	jl	SHORT $LN56@stbtt__cid

; 1141 :       return 0;

	xor	r11b, r11b
	jmp	SHORT $LN55@stbtt__cid
$LN56@stbtt__cid:

; 1142 :    return b->data[b->cursor++];

	movsxd	rcx, eax
	inc	eax
	movzx	r11d, BYTE PTR [rcx+r9]
$LN55@stbtt__cid:

; 1140 :    if (b->cursor >= b->size)

	cmp	eax, edx
	jl	SHORT $LN67@stbtt__cid

; 1141 :       return 0;

	xor	cl, cl
	jmp	SHORT $LN66@stbtt__cid
$LN67@stbtt__cid:

; 1142 :    return b->data[b->cursor++];

	movsxd	rcx, eax
	inc	eax
	movzx	ecx, BYTE PTR [rcx+r9]
$LN66@stbtt__cid:

; 1169 :       v = (v << 8) | stbtt__buf_get8(b);

	movzx	r8d, cl

; 1140 :    if (b->cursor >= b->size)

	cmp	eax, edx
	jl	SHORT $LN90@stbtt__cid

; 1141 :       return 0;

	xor	cl, cl
	jmp	SHORT $LN91@stbtt__cid
$LN90@stbtt__cid:

; 1142 :    return b->data[b->cursor++];

	movsxd	rcx, eax
	inc	eax
	movzx	ecx, BYTE PTR [rcx+r9]
$LN91@stbtt__cid:

; 1169 :       v = (v << 8) | stbtt__buf_get8(b);

	shl	r8d, 8
	movzx	ecx, cl
	or	r8d, ecx

; 2002 :          v = stbtt__buf_get8(&fdselect);
; 2003 :          end = stbtt__buf_get16(&fdselect);
; 2004 :          if (glyph_index >= start && glyph_index < end) {

	cmp	r14d, ebx
	jl	SHORT $LN8@stbtt__cid
	cmp	r14d, r8d
	jl	SHORT $LN78@stbtt__cid
$LN8@stbtt__cid:

; 1999 :       nranges = stbtt__buf_get16(&fdselect);
; 2000 :       start = stbtt__buf_get16(&fdselect);
; 2001 :       for (i = 0; i < nranges; i++) {

	inc	r10d

; 2006 :             break;
; 2007 :          }
; 2008 :          start = end;

	mov	ebx, r8d
	cmp	r10d, esi
	jl	SHORT $LL4@stbtt__cid
$LN104@stbtt__cid:

; 1177 :    r.data = (stbtt_uint8*) p;

	mov	QWORD PTR [r15], rdi

; 1178 :    r.size = (int) size;
; 1179 :    r.cursor = 0;

	mov	QWORD PTR [r15+8], rdi

; 2009 :       }
; 2010 :    }
; 2011 :    if (fdselector == -1) return stbtt__new_buf(NULL, 0); // [DEAR IMGUI] fixed, see #6007 and nothings/stb#1422

	jmp	SHORT $LN121@stbtt__cid
$LN78@stbtt__cid:

; 2005 :             fdselector = v;

	movzx	r8d, r11b
	jmp	SHORT $LN9@stbtt__cid
$LN16@stbtt__cid:

; 1155 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

	psrldq	xmm1, 12
	movd	edx, xmm1
	mov	DWORD PTR fdselect$[rsp+8], edx
	mov	edi, edx
$LN100@stbtt__cid:

; 1141 :       return 0;

	mov	eax, edi
$LN103@stbtt__cid:

; 1160 :    stbtt__buf_seek(b, b->cursor + o);

	lea	ecx, DWORD PTR [r8+rax]

; 1155 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

	cmp	ecx, edx
	jg	SHORT $LN101@stbtt__cid
	test	ecx, ecx
	js	SHORT $LN101@stbtt__cid

; 1140 :    if (b->cursor >= b->size)

	cmp	ecx, edx
	jge	SHORT $LN101@stbtt__cid

; 1142 :    return b->data[b->cursor++];

	movsxd	rax, ecx
	movzx	ecx, BYTE PTR [rax+r9]
	jmp	SHORT $LN30@stbtt__cid
$LN101@stbtt__cid:

; 1141 :       return 0;

	xor	cl, cl
$LN30@stbtt__cid:

; 1995 :       // untested
; 1996 :       stbtt__buf_skip(&fdselect, glyph_index);
; 1997 :       fdselector = stbtt__buf_get8(&fdselect);

	movzx	r8d, cl
$LN9@stbtt__cid:

; 2012 :    return stbtt__get_subrs(info->cff, stbtt__cff_index_get(info->fontdicts, fdselector));

	movups	xmm0, XMMWORD PTR [rbp+128]
	lea	rdx, QWORD PTR $T2[rsp]
	lea	rcx, QWORD PTR $T4[rsp]
	movaps	XMMWORD PTR $T2[rsp], xmm0
	call	?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z ; stbtt__cff_index_get
	movups	xmm1, XMMWORD PTR [rbp+64]
	lea	r8, QWORD PTR $T1[rsp]
	mov	rcx, r15
	lea	rdx, QWORD PTR $T3[rsp]
	movups	xmm0, XMMWORD PTR [rax]
	movaps	XMMWORD PTR $T3[rsp], xmm1
	movaps	XMMWORD PTR $T1[rsp], xmm0
	call	?stbtt__get_subrs@@YA?AUstbtt__buf@@U1@0@Z ; stbtt__get_subrs
$LN121@stbtt__cid:

; 2013 : }

	mov	rbx, QWORD PTR [rsp+112]
	mov	rax, r15
	mov	rbp, QWORD PTR [rsp+120]
	mov	rsi, QWORD PTR [rsp+128]
	add	rsp, 80					; 00000050H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
?stbtt__cid_get_glyph_subrs@@YA?AUstbtt__buf@@PEBUstbtt_fontinfo@@H@Z ENDP ; stbtt__cid_get_glyph_subrs
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z
_TEXT	SEGMENT
b$2$ = 64
b$3$ = 80
$T1 = 96
$T2 = 96
$T3 = 96
b$ = 96
maskbits$1$ = 112
in_header$1$ = 116
subr_stack_height$1$ = 120
has_subrs$1$ = 124
$T4 = 128
$T5 = 128
s$ = 144
subrs$ = 336
$T6 = 352
subr_stack$ = 368
info$ = 752
glyph_index$ = 760
c$ = 768
clear_stack$1$ = 776
?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z PROC ; stbtt__run_charstring, COMDAT

; 2016 : {

	mov	rax, rsp
	mov	QWORD PTR [rax+24], rbx
	mov	DWORD PTR [rax+16], edx
	mov	QWORD PTR [rax+8], rcx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-488]
	sub	rsp, 688				; 000002b0H
	movaps	XMMWORD PTR [rax-72], xmm6
	mov	r13, r8
	movaps	XMMWORD PTR [rax-104], xmm8

; 2017 :    int in_header = 1, maskbits = 0, subr_stack_height = 0, sp = 0, v, i, b0;
; 2018 :    int has_subrs = 0, clear_stack;
; 2019 :    float s[48];
; 2020 :    stbtt__buf subr_stack[10], subrs = info->subrs, b;
; 2021 :    float f;
; 2022 : 
; 2023 : #define STBTT__CSERR(s) (0)
; 2024 : 
; 2025 :    // this currently ignores the initial width value, which isn't needed if we have hmtx
; 2026 :    b = stbtt__cff_index_get(info->charstrings, glyph_index);

	mov	r8d, edx
	movaps	XMMWORD PTR [rax-120], xmm9
	lea	rdx, QWORD PTR $T4[rbp-256]
	movaps	XMMWORD PTR [rax-136], xmm10
	xor	r12d, r12d
	movaps	XMMWORD PTR [rax-152], xmm11
	xor	edi, edi
	movaps	XMMWORD PTR [rax-168], xmm12
	movaps	XMMWORD PTR [rax-184], xmm13
	movaps	XMMWORD PTR [rax-200], xmm14
	movaps	XMMWORD PTR [rax-216], xmm15
	movaps	XMMWORD PTR [rax-88], xmm7
	mov	rax, rcx
	xor	ecx, ecx
	mov	DWORD PTR in_header$1$[rsp], 1
	mov	DWORD PTR has_subrs$1$[rsp], ecx
	lea	rcx, QWORD PTR $T3[rsp]
	mov	DWORD PTR maskbits$1$[rsp], 0
	movups	xmm0, XMMWORD PTR [rax+112]
	mov	DWORD PTR subr_stack_height$1$[rsp], r12d
	movups	xmm1, XMMWORD PTR [rax+80]
	movups	XMMWORD PTR subrs$[rbp-256], xmm0
	movaps	XMMWORD PTR $T4[rbp-256], xmm1
	call	?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z ; stbtt__cff_index_get
	movss	xmm13, DWORD PTR s$[rbp-232]
	xorps	xmm8, xmm8
	movss	xmm14, DWORD PTR s$[rbp-236]
	xor	r11d, r11d
	movss	xmm15, DWORD PTR s$[rbp-240]
	movups	xmm2, XMMWORD PTR [rax]
	movss	xmm11, DWORD PTR s$[rbp-244]
	movss	xmm10, DWORD PTR s$[rbp-248]
	movdqa	xmm0, xmm2
	movss	xmm12, DWORD PTR s$[rbp-252]
	movdqa	xmm1, xmm2
	movss	xmm9, DWORD PTR s$[rbp-256]
	movq	rdx, xmm2
	movss	xmm6, DWORD PTR s$[rbp-224]
	psrldq	xmm0, 12
	movd	r8d, xmm0
	movdqa	xmm0, xmm2
	psrldq	xmm0, 8
	psrldq	xmm1, 8
	movaps	XMMWORD PTR b$[rsp], xmm2
	movq	QWORD PTR b$[rsp+8], xmm0
	mov	DWORD PTR b$2$[rsp], r8d
	movd	r14d, xmm1
	mov	QWORD PTR b$3$[rsp], rdx
$LN329@stbtt__run:

; 2027 :    while (b.cursor < b.size) {

	mov	rax, QWORD PTR b$[rsp+8]
	lea	r9, OFFSET FLAT:__ImageBase
	movss	xmm5, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
	movss	xmm4, DWORD PTR __xmm@80000000800000008000000080000000
	shr	rax, 32					; 00000020H
	cmp	r14d, eax
	jge	$LN3@stbtt__run

; 1142 :    return b->data[b->cursor++];

	movsxd	rax, r14d

; 2028 :       i = 0;

	mov	ebx, r11d

; 1142 :    return b->data[b->cursor++];

	inc	r14d

; 2029 :       clear_stack = 1;

	mov	DWORD PTR clear_stack$1$[rbp-256], 1

; 1142 :    return b->data[b->cursor++];

	mov	DWORD PTR b$[rsp+8], r14d
	movzx	r15d, BYTE PTR [rax+rdx]

; 2030 :       b0 = stbtt__buf_get8(&b);

	movzx	esi, r15b

; 2031 :       switch (b0) {

	lea	eax, DWORD PTR [rsi-1]
	cmp	eax, 30
	ja	$LN94@stbtt__run
	cdqe
	mov	ecx, DWORD PTR $LN255@stbtt__run[r9+rax*4]
	add	rcx, r9
	jmp	rcx
$LN29@stbtt__run:

; 2032 :       // @TODO implement hinting
; 2033 :       case 0x13: // hintmask
; 2034 :       case 0x14: // cntrmask
; 2035 :          if (in_header)

	cmp	DWORD PTR in_header$1$[rsp], 0
	mov	ebx, DWORD PTR maskbits$1$[rsp]
	je	SHORT $LN31@stbtt__run

; 2036 :             maskbits += (sp / 2); // implicit "vstem"

	mov	eax, edi
	cdq
	sub	eax, edx
	sar	eax, 1
	add	ebx, eax
	mov	DWORD PTR maskbits$1$[rsp], ebx
$LN31@stbtt__run:

; 2037 :          in_header = 0;
; 2038 :          stbtt__buf_skip(&b, (maskbits + 7) / 8);

	lea	eax, DWORD PTR [rbx+7]
	mov	DWORD PTR in_header$1$[rsp], r11d
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3

; 1160 :    stbtt__buf_seek(b, b->cursor + o);

	add	eax, r14d
	mov	r14d, eax

; 1155 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

	cmp	eax, r8d
	jg	SHORT $LN137@stbtt__run
	test	eax, eax
	js	SHORT $LN137@stbtt__run
	mov	DWORD PTR b$[rsp+8], eax
	jmp	$LN330@stbtt__run
$LN137@stbtt__run:
	mov	r14d, r8d
	mov	DWORD PTR b$[rsp+8], r8d

; 2039 :          break;

	jmp	$LN330@stbtt__run
$LN32@stbtt__run:

; 2040 : 
; 2041 :       case 0x01: // hstem
; 2042 :       case 0x03: // vstem
; 2043 :       case 0x12: // hstemhm
; 2044 :       case 0x17: // vstemhm
; 2045 :          maskbits += (sp / 2);

	mov	eax, edi
	cdq
	sub	eax, edx
	sar	eax, 1
	add	DWORD PTR maskbits$1$[rsp], eax

; 2046 :          break;

	jmp	$LN330@stbtt__run
$LN36@stbtt__run:

; 2047 : 
; 2048 :       case 0x15: // rmoveto
; 2049 :          in_header = 0;

	mov	DWORD PTR in_header$1$[rsp], r11d

; 2050 :          if (sp < 2) return STBTT__CSERR("rmoveto stack");

	cmp	edi, 2
	jl	$LN3@stbtt__run

; 2051 :          stbtt__csctx_rmove_to(c, s[sp-2], s[sp-1]);

	movsxd	rax, edi

; 2264 :          clear_stack = 0;
; 2265 :          break;
; 2266 :       }
; 2267 :       if (clear_stack) sp = 0;
; 2268 :    }

	mov	rcx, r13
	movss	xmm1, DWORD PTR s$[rbp+rax*4-264]
	movss	xmm2, DWORD PTR s$[rbp+rax*4-260]
	call	?stbtt__csctx_rmove_to@@YAXPEAUstbtt__csctx@@MM@Z ; stbtt__csctx_rmove_to
	jmp	$LN260@stbtt__run
$LN38@stbtt__run:

; 2052 :          break;
; 2053 :       case 0x04: // vmoveto
; 2054 :          in_header = 0;

	mov	DWORD PTR in_header$1$[rsp], r11d

; 2055 :          if (sp < 1) return STBTT__CSERR("vmoveto stack");

	cmp	edi, 1
	jl	$LN3@stbtt__run

; 2056 :          stbtt__csctx_rmove_to(c, 0, s[sp-1]);

	movsxd	rax, edi
	movaps	xmm1, xmm8

; 2264 :          clear_stack = 0;
; 2265 :          break;
; 2266 :       }
; 2267 :       if (clear_stack) sp = 0;
; 2268 :    }

	mov	rcx, r13
	movss	xmm2, DWORD PTR s$[rbp+rax*4-260]
	call	?stbtt__csctx_rmove_to@@YAXPEAUstbtt__csctx@@MM@Z ; stbtt__csctx_rmove_to
	jmp	SHORT $LN260@stbtt__run
$LN40@stbtt__run:

; 2057 :          break;
; 2058 :       case 0x16: // hmoveto
; 2059 :          in_header = 0;

	mov	DWORD PTR in_header$1$[rsp], r11d

; 2060 :          if (sp < 1) return STBTT__CSERR("hmoveto stack");

	cmp	edi, 1
	jl	SHORT $LN3@stbtt__run

; 2061 :          stbtt__csctx_rmove_to(c, s[sp-1], 0);

	movsxd	rax, edi
	movaps	xmm2, xmm8

; 2264 :          clear_stack = 0;
; 2265 :          break;
; 2266 :       }
; 2267 :       if (clear_stack) sp = 0;
; 2268 :    }

	mov	rcx, r13
	movss	xmm1, DWORD PTR s$[rbp+rax*4-260]
	call	?stbtt__csctx_rmove_to@@YAXPEAUstbtt__csctx@@MM@Z ; stbtt__csctx_rmove_to
	jmp	SHORT $LN260@stbtt__run
$LN42@stbtt__run:

; 2062 :          break;
; 2063 : 
; 2064 :       case 0x05: // rlineto
; 2065 :          if (sp < 2) return STBTT__CSERR("rlineto stack");

	cmp	edi, 2
	jl	SHORT $LN3@stbtt__run
	mov	r11d, 1
	lea	r10, QWORD PTR s$[rbp-256]
	npad	6
$LL8@stbtt__run:

; 2066 :          for (; i + 1 < sp; i += 2)
; 2067 :             stbtt__csctx_rline_to(c, s[i], s[i+1]);

	movss	xmm2, DWORD PTR [r10+4]
	mov	rcx, r13
	movss	xmm1, DWORD PTR [r10]
	call	?stbtt__csctx_rline_to@@YAXPEAUstbtt__csctx@@MM@Z ; stbtt__csctx_rline_to
	add	r11d, 2
	lea	r10, QWORD PTR [r10+8]
	cmp	r11d, edi
	jl	SHORT $LL8@stbtt__run
$LN257@stbtt__run:

; 2264 :          clear_stack = 0;
; 2265 :          break;
; 2266 :       }
; 2267 :       if (clear_stack) sp = 0;
; 2268 :    }

	xor	r11d, r11d
$LN260@stbtt__run:
	mov	r8d, DWORD PTR b$2$[rsp]
$LN330@stbtt__run:
	mov	rdx, QWORD PTR b$3$[rsp]
$LN261@stbtt__run:
	mov	ecx, DWORD PTR clear_stack$1$[rbp-256]
	mov	eax, r11d
	test	ecx, ecx
	cmove	eax, edi
	mov	edi, eax
	jmp	$LN329@stbtt__run
$LN44@stbtt__run:

; 2068 :          break;
; 2069 : 
; 2070 :       // hlineto/vlineto and vhcurveto/hvcurveto alternate horizontal and vertical
; 2071 :       // starting from a different place.
; 2072 : 
; 2073 :       case 0x07: // vlineto
; 2074 :          if (sp < 1) return STBTT__CSERR("vlineto stack");

	cmp	edi, 1
	jge	SHORT $vlineto$335
$LN3@stbtt__run:

; 2269 :    return STBTT__CSERR("no endchar");

	xor	eax, eax
$LN1@stbtt__run:
	movaps	xmm7, XMMWORD PTR [rsp+656]

; 2270 : 
; 2271 : #undef STBTT__CSERR
; 2272 : }

	lea	r11, QWORD PTR [rsp+688]
	mov	rbx, QWORD PTR [r11+80]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	movaps	xmm14, XMMWORD PTR [r11-144]
	movaps	xmm15, XMMWORD PTR [r11-160]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN47@stbtt__run:

; 2075 :          goto vlineto;
; 2076 :       case 0x06: // hlineto
; 2077 :          if (sp < 1) return STBTT__CSERR("hlineto stack");

	cmp	edi, 1
	jl	SHORT $LN3@stbtt__run
$LN253@stbtt__run:

; 2080 :             stbtt__csctx_rline_to(c, s[i], 0);

	movsxd	rax, ebx
	movaps	xmm2, xmm8
	mov	rcx, r13
	movss	xmm1, DWORD PTR s$[rbp+rax*4-256]
	call	?stbtt__csctx_rline_to@@YAXPEAUstbtt__csctx@@MM@Z ; stbtt__csctx_rline_to

; 2081 :             i++;

	inc	ebx
$vlineto$335:

; 2082 :       vlineto:
; 2083 :             if (i >= sp) break;

	cmp	ebx, edi
	jge	$LN260@stbtt__run

; 2084 :             stbtt__csctx_rline_to(c, 0, s[i]);

	movsxd	rax, ebx
	movaps	xmm1, xmm8
	mov	rcx, r13
	movss	xmm2, DWORD PTR s$[rbp+rax*4-256]
	call	?stbtt__csctx_rline_to@@YAXPEAUstbtt__csctx@@MM@Z ; stbtt__csctx_rline_to

; 2085 :             i++;

	inc	ebx
	cmp	ebx, edi
	jl	SHORT $LN253@stbtt__run

; 2078 :          for (;;) {
; 2079 :             if (i >= sp) break;

	jmp	$LN260@stbtt__run
$LN51@stbtt__run:

; 2086 :          }
; 2087 :          break;
; 2088 : 
; 2089 :       case 0x1F: // hvcurveto
; 2090 :          if (sp < 4) return STBTT__CSERR("hvcurveto stack");

	cmp	edi, 4
	jl	$LN3@stbtt__run

; 2091 :          goto hvcurveto;

	jmp	SHORT $hvcurveto$336
$LN54@stbtt__run:

; 2092 :       case 0x1E: // vhcurveto
; 2093 :          if (sp < 4) return STBTT__CSERR("vhcurveto stack");

	cmp	edi, 4
	jl	$LN3@stbtt__run
	mov	esi, ebx
$LN252@stbtt__run:

; 2096 :             stbtt__csctx_rccurve_to(c, 0, s[i], s[i+1], s[i+2], s[i+3], (sp - i == 5) ? s[i + 4] : 0.0f);

	mov	eax, edi
	add	esi, 4
	sub	eax, ebx
	cmp	eax, 5
	jne	SHORT $LN101@stbtt__run
	movsxd	rax, esi
	movss	xmm0, DWORD PTR s$[rbp+rax*4-256]
	jmp	SHORT $LN102@stbtt__run
$LN101@stbtt__run:
	movaps	xmm0, xmm8
$LN102@stbtt__run:
	movsxd	rax, ebx
	mov	rcx, r13
	movss	DWORD PTR [rsp+48], xmm0
	movss	xmm1, DWORD PTR s$[rbp+rax*4-248]
	movss	xmm0, DWORD PTR s$[rbp+rax*4-244]
	movss	xmm3, DWORD PTR s$[rbp+rax*4-252]
	movss	xmm2, DWORD PTR s$[rbp+rax*4-256]
	movss	DWORD PTR [rsp+40], xmm0
	movss	DWORD PTR [rsp+32], xmm1
	movaps	xmm1, xmm8
	call	?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to

; 2097 :             i += 4;

	mov	ebx, esi
$hvcurveto$336:

; 2098 :       hvcurveto:
; 2099 :             if (i + 3 >= sp) break;

	lea	eax, DWORD PTR [rbx+3]
	cmp	eax, edi
	jge	$LN257@stbtt__run

; 2100 :             stbtt__csctx_rccurve_to(c, s[i], 0, s[i+1], s[i+2], (sp - i == 5) ? s[i+4] : 0.0f, s[i+3]);

	movsxd	rcx, ebx
	lea	esi, DWORD PTR [rbx+4]
	mov	eax, edi
	sub	eax, ebx
	movss	xmm1, DWORD PTR s$[rbp+rcx*4-244]
	cmp	eax, 5
	jne	SHORT $LN103@stbtt__run
	movsxd	rax, esi
	movss	xmm0, DWORD PTR s$[rbp+rax*4-256]
	jmp	SHORT $LN104@stbtt__run
$LN103@stbtt__run:
	movaps	xmm0, xmm8
$LN104@stbtt__run:
	movss	xmm3, DWORD PTR s$[rbp+rcx*4-252]
	movaps	xmm2, xmm8
	movss	DWORD PTR [rsp+48], xmm1
	movss	xmm1, DWORD PTR s$[rbp+rcx*4-256]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR s$[rbp+rcx*4-248]
	mov	rcx, r13
	movss	DWORD PTR [rsp+32], xmm0
	call	?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
	lea	eax, DWORD PTR [rsi+3]

; 2101 :             i += 4;

	mov	ebx, esi
	cmp	eax, edi
	jl	$LN252@stbtt__run

; 2094 :          for (;;) {
; 2095 :             if (i + 3 >= sp) break;

	jmp	$LN257@stbtt__run
$LN58@stbtt__run:

; 2102 :          }
; 2103 :          break;
; 2104 : 
; 2105 :       case 0x08: // rrcurveto
; 2106 :          if (sp < 6) return STBTT__CSERR("rcurveline stack");

	cmp	edi, 6
	jl	$LN3@stbtt__run
	mov	esi, 5
	lea	rbx, QWORD PTR s$[rbp-240]
$LL17@stbtt__run:

; 2107 :          for (; i + 5 < sp; i += 6)
; 2108 :             stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);

	movss	xmm0, DWORD PTR [rbx+4]
	mov	rcx, r13
	movss	xmm1, DWORD PTR [rbx]
	movss	xmm3, DWORD PTR [rbx-8]
	movss	xmm2, DWORD PTR [rbx-12]
	movss	DWORD PTR [rsp+48], xmm0
	movss	xmm0, DWORD PTR [rbx-4]
	movss	DWORD PTR [rsp+40], xmm1
	movss	xmm1, DWORD PTR [rbx-16]
	movss	DWORD PTR [rsp+32], xmm0
	call	?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
	add	esi, 6
	lea	rbx, QWORD PTR [rbx+24]
	cmp	esi, edi
	jl	SHORT $LL17@stbtt__run

; 2109 :          break;

	jmp	$LN257@stbtt__run
$LN60@stbtt__run:

; 2110 : 
; 2111 :       case 0x18: // rcurveline
; 2112 :          if (sp < 8) return STBTT__CSERR("rcurveline stack");

	cmp	edi, 8
	jl	$LN3@stbtt__run

; 2113 :          for (; i + 5 < sp - 2; i += 6)

	lea	r12d, DWORD PTR [rdi-2]
	cmp	r12d, 5
	jle	SHORT $LN251@stbtt__run
	mov	r15d, 5
	lea	rsi, QWORD PTR s$[rbp-240]
	npad	10
$LL20@stbtt__run:

; 2114 :             stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);

	movss	xmm0, DWORD PTR [rsi+4]
	mov	rcx, r13
	movss	xmm1, DWORD PTR [rsi]
	movss	xmm3, DWORD PTR [rsi-8]
	movss	xmm2, DWORD PTR [rsi-12]
	movss	DWORD PTR [rsp+48], xmm0
	movss	xmm0, DWORD PTR [rsi-4]
	movss	DWORD PTR [rsp+40], xmm1
	movss	xmm1, DWORD PTR [rsi-16]
	movss	DWORD PTR [rsp+32], xmm0
	call	?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
	add	ebx, 6
	lea	rsi, QWORD PTR [rsi+24]
	add	r15d, 6
	mov	eax, ebx
	cmp	r15d, r12d
	jl	SHORT $LL20@stbtt__run

; 2115 :          if (i + 1 >= sp) return STBTT__CSERR("rcurveline stack");

	inc	eax
	cmp	eax, edi
	jge	$LN3@stbtt__run
	xor	r11d, r11d
$LN251@stbtt__run:

; 2116 :          stbtt__csctx_rline_to(c, s[i], s[i+1]);

	movsxd	rax, ebx
	mov	rcx, r13
	movss	xmm2, DWORD PTR s$[rbp+rax*4-252]
	movss	xmm1, DWORD PTR s$[rbp+rax*4-256]
	call	?stbtt__csctx_rline_to@@YAXPEAUstbtt__csctx@@MM@Z ; stbtt__csctx_rline_to

; 2117 :          break;

	mov	r12d, DWORD PTR subr_stack_height$1$[rsp]
	jmp	$LN260@stbtt__run
$LN63@stbtt__run:

; 2118 : 
; 2119 :       case 0x19: // rlinecurve
; 2120 :          if (sp < 8) return STBTT__CSERR("rlinecurve stack");

	cmp	edi, 8
	jl	$LN3@stbtt__run

; 2121 :          for (; i + 1 < sp - 6; i += 2)

	lea	esi, DWORD PTR [rdi-6]
	cmp	esi, 1
	jle	SHORT $LN250@stbtt__run
	mov	r11d, 1
	lea	r10, QWORD PTR s$[rbp-256]
$LL23@stbtt__run:

; 2122 :             stbtt__csctx_rline_to(c, s[i], s[i+1]);

	movss	xmm2, DWORD PTR [r10+4]
	mov	rcx, r13
	movss	xmm1, DWORD PTR [r10]
	call	?stbtt__csctx_rline_to@@YAXPEAUstbtt__csctx@@MM@Z ; stbtt__csctx_rline_to
	add	ebx, 2
	lea	r10, QWORD PTR [r10+8]
	add	r11d, 2
	mov	eax, ebx
	cmp	r11d, esi
	jl	SHORT $LL23@stbtt__run

; 2123 :          if (i + 5 >= sp) return STBTT__CSERR("rlinecurve stack");

	add	eax, 5
	cmp	eax, edi
	jge	$LN3@stbtt__run
$LN250@stbtt__run:

; 2124 :          stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);

	movsxd	rax, ebx

; 2264 :          clear_stack = 0;
; 2265 :          break;
; 2266 :       }
; 2267 :       if (clear_stack) sp = 0;
; 2268 :    }

	mov	rcx, r13
	movss	xmm0, DWORD PTR s$[rbp+rax*4-236]
	movss	xmm2, DWORD PTR s$[rbp+rax*4-240]
	movss	xmm3, DWORD PTR s$[rbp+rax*4-248]
	movss	xmm1, DWORD PTR s$[rbp+rax*4-256]
	movss	DWORD PTR [rsp+48], xmm0
	movss	xmm0, DWORD PTR s$[rbp+rax*4-244]
	movss	DWORD PTR [rsp+40], xmm2
	movss	xmm2, DWORD PTR s$[rbp+rax*4-252]
	movss	DWORD PTR [rsp+32], xmm0
	call	?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
	jmp	$LN257@stbtt__run
$LN66@stbtt__run:

; 2125 :          break;
; 2126 : 
; 2127 :       case 0x1A: // vvcurveto
; 2128 :       case 0x1B: // hhcurveto
; 2129 :          if (sp < 4) return STBTT__CSERR("(vv|hh)curveto stack");

	cmp	edi, 4
	jl	$LN3@stbtt__run

; 2130 :          f = 0.0;
; 2131 :          if (sp & 1) { f = s[i]; i++; }

	mov	eax, edi
	movaps	xmm5, xmm8
	and	eax, 1
	je	SHORT $LN69@stbtt__run
	movaps	xmm5, xmm9
$LN69@stbtt__run:

; 2132 :          for (; i + 3 < sp; i += 4) {

	lea	esi, DWORD PTR [rax+3]
	cmp	esi, edi
	jge	$LN261@stbtt__run

; 2133 :             if (b0 == 0x1B)

	lea	rbx, QWORD PTR s$[rbp-244]
	lea	rbx, QWORD PTR [rbx+rax*4]
	npad	13
$LL26@stbtt__run:
	movss	xmm0, DWORD PTR [rbx]
	movss	xmm1, DWORD PTR [rbx-12]
	cmp	r15b, 27
	jne	SHORT $LN70@stbtt__run

; 2134 :                stbtt__csctx_rccurve_to(c, s[i], f, s[i+1], s[i+2], s[i+3], 0.0);

	movaps	xmm2, xmm0
	movaps	xmm4, xmm1
	movaps	xmm0, xmm8
	jmp	SHORT $LN71@stbtt__run
$LN70@stbtt__run:

; 2135 :             else
; 2136 :                stbtt__csctx_rccurve_to(c, f, s[i], s[i+1], s[i+2], 0.0, s[i+3]);

	movaps	xmm4, xmm5
	movaps	xmm2, xmm8
	movaps	xmm5, xmm1
$LN71@stbtt__run:

; 2137 :             f = 0.0;

	movss	xmm3, DWORD PTR [rbx-8]
	movaps	xmm1, xmm4
	movss	DWORD PTR [rsp+48], xmm0
	mov	rcx, r13
	movss	xmm0, DWORD PTR [rbx-4]
	movss	DWORD PTR [rsp+40], xmm2
	movaps	xmm2, xmm5
	movss	DWORD PTR [rsp+32], xmm0
	call	?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
	add	esi, 4
	add	rbx, 16
	movaps	xmm5, xmm8
	cmp	esi, edi
	jl	SHORT $LL26@stbtt__run

; 2138 :          }
; 2139 :          break;

	jmp	$LN257@stbtt__run
$LN72@stbtt__run:

; 2140 : 
; 2141 :       case 0x0A: // callsubr
; 2142 :          if (!has_subrs) {

	cmp	DWORD PTR has_subrs$1$[rsp], 0
	mov	rbx, QWORD PTR info$[rbp-256]
	jne	SHORT $LN73@stbtt__run

; 2143 :             if (info->fdselect.size)

	cmp	DWORD PTR [rbx+156], 0
	je	SHORT $LN74@stbtt__run

; 2144 :                subrs = stbtt__cid_get_glyph_subrs(info, glyph_index);

	mov	r8d, DWORD PTR glyph_index$[rbp-256]
	lea	rcx, QWORD PTR $T6[rbp-256]
	mov	rdx, rbx
	call	?stbtt__cid_get_glyph_subrs@@YA?AUstbtt__buf@@PEBUstbtt_fontinfo@@H@Z ; stbtt__cid_get_glyph_subrs
	xor	r11d, r11d
	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR subrs$[rbp-256], xmm0
$LN74@stbtt__run:

; 2145 :             has_subrs = 1;

	mov	DWORD PTR has_subrs$1$[rsp], 1
	jmp	SHORT $LN73@stbtt__run
$LN263@stbtt__run:

; 2031 :       switch (b0) {

	mov	rbx, QWORD PTR info$[rbp-256]
$LN73@stbtt__run:

; 2146 :          }
; 2147 :          // FALLTHROUGH
; 2148 :       case 0x1D: // callgsubr
; 2149 :          if (sp < 1) return STBTT__CSERR("call(g|)subr stack");

	cmp	edi, 1
	jl	$LN3@stbtt__run

; 2150 :          v = (int) s[--sp];

	dec	edi

; 2151 :          if (subr_stack_height >= 10) return STBTT__CSERR("recursion limit");

	cmp	r12d, 10
	jge	$LN3@stbtt__run

; 2152 :          subr_stack[subr_stack_height++] = b;

	movaps	xmm0, XMMWORD PTR b$[rsp]
	movsxd	rax, r12d
	inc	r12d
	add	rax, rax
	mov	DWORD PTR subr_stack_height$1$[rsp], r12d
	movups	XMMWORD PTR subr_stack$[rbp+rax*8-256], xmm0
	movsxd	rax, edi
	cvttss2si r8d, DWORD PTR s$[rbp+rax*4-256]

; 2153 :          b = stbtt__get_subr(b0 == 0x0A ? subrs : info->gsubrs, v);

	lea	rax, QWORD PTR subrs$[rbp-256]
	cmp	esi, 10
	je	SHORT $LN106@stbtt__run
	lea	rax, QWORD PTR [rbx+96]
$LN106@stbtt__run:
	movups	xmm1, XMMWORD PTR [rax]

; 1155 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

	mov	rax, QWORD PTR [rax+8]
	shr	rax, 32					; 00000020H

; 2153 :          b = stbtt__get_subr(b0 == 0x0A ? subrs : info->gsubrs, v);

	movaps	XMMWORD PTR $T2[rsp], xmm1

; 1155 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

	test	eax, eax

; 1140 :    if (b->cursor >= b->size)

	mov	r10, QWORD PTR $T2[rsp]

; 1155 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

	psrldq	xmm1, 12
	movd	r9d, xmm1
	mov	ecx, r9d
	cmovns	ecx, r11d
	mov	DWORD PTR $T2[rsp+8], ecx

; 1140 :    if (b->cursor >= b->size)

	cmp	ecx, r9d
	jl	SHORT $LN167@stbtt__run

; 1141 :       return 0;

	xor	al, al
	jmp	SHORT $LN166@stbtt__run
$LN167@stbtt__run:

; 1142 :    return b->data[b->cursor++];

	movsxd	rax, ecx
	inc	ecx
	mov	DWORD PTR $T2[rsp+8], ecx
	movzx	eax, BYTE PTR [rax+r10]
$LN166@stbtt__run:

; 1169 :       v = (v << 8) | stbtt__buf_get8(b);

	movzx	edx, al

; 1140 :    if (b->cursor >= b->size)

	cmp	ecx, r9d
	jl	SHORT $LN222@stbtt__run

; 1141 :       return 0;

	xor	al, al
	jmp	SHORT $LN223@stbtt__run
$LN222@stbtt__run:

; 1142 :    return b->data[b->cursor++];

	movsxd	rax, ecx
	inc	ecx
	mov	DWORD PTR $T2[rsp+8], ecx
	movzx	eax, BYTE PTR [rax+r10]
$LN223@stbtt__run:

; 1169 :       v = (v << 8) | stbtt__buf_get8(b);

	shl	edx, 8
	movzx	eax, al
	or	edx, eax

; 1977 :    if (count >= 33900)

	cmp	edx, 33900				; 0000846cH
	jb	SHORT $LN143@stbtt__run

; 1978 :       bias = 32768;

	mov	eax, 32768				; 00008000H
	jmp	SHORT $LN145@stbtt__run
$LN143@stbtt__run:

; 1979 :    else if (count >= 1240)

	cmp	edx, 1240				; 000004d8H
	mov	eax, 107				; 0000006bH
	mov	ecx, 1131				; 0000046bH
	cmovae	eax, ecx
$LN145@stbtt__run:

; 1980 :       bias = 1131;
; 1981 :    n += bias;

	add	r8d, eax

; 1982 :    if (n < 0 || n >= count)

	js	SHORT $LN172@stbtt__run
	cmp	r8d, edx
	jge	SHORT $LN172@stbtt__run

; 1983 :       return stbtt__new_buf(NULL, 0);
; 1984 :    return stbtt__cff_index_get(idx, n);

	movaps	xmm0, XMMWORD PTR $T2[rsp]
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR $T5[rbp-256]
	movdqa	XMMWORD PTR $T1[rsp], xmm0
	call	?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z ; stbtt__cff_index_get
	xor	r11d, r11d
	jmp	SHORT $LN142@stbtt__run
$LN172@stbtt__run:

; 1177 :    r.data = (stbtt_uint8*) p;

	mov	QWORD PTR $T5[rbp-256], r11

; 1178 :    r.size = (int) size;
; 1179 :    r.cursor = 0;

	mov	QWORD PTR $T5[rbp-248], 0
$LN142@stbtt__run:

; 2153 :          b = stbtt__get_subr(b0 == 0x0A ? subrs : info->gsubrs, v);

	movaps	xmm0, XMMWORD PTR $T5[rbp-256]
	movdqa	XMMWORD PTR b$[rsp], xmm0

; 2154 :          if (b.size == 0) return STBTT__CSERR("subr not found");

	psrldq	xmm0, 8
	movq	rax, xmm0
	shr	rax, 32					; 00000020H
	test	eax, eax
	je	$LN3@stbtt__run

; 2155 :          b.cursor = 0;
; 2156 :          clear_stack = 0;
; 2157 :          break;

	mov	rdx, QWORD PTR b$[rsp]
	mov	ecx, r11d
	mov	r8d, DWORD PTR b$[rsp+12]

; 2264 :          clear_stack = 0;
; 2265 :          break;
; 2266 :       }
; 2267 :       if (clear_stack) sp = 0;
; 2268 :    }

	test	ecx, ecx
	mov	eax, r11d
	mov	DWORD PTR b$[rsp+8], r11d
	cmove	eax, edi
	mov	DWORD PTR b$2$[rsp], r8d
	mov	edi, eax
	mov	QWORD PTR b$3$[rsp], rdx
	mov	r14d, r11d
	jmp	$LN329@stbtt__run
$LN79@stbtt__run:

; 2158 : 
; 2159 :       case 0x0B: // return
; 2160 :          if (subr_stack_height <= 0) return STBTT__CSERR("return outside subr");

	test	r12d, r12d
	jle	$LN3@stbtt__run

; 2161 :          b = subr_stack[--subr_stack_height];

	dec	r12d

; 2162 :          clear_stack = 0;

	mov	ecx, r11d
	movsxd	rax, r12d
	add	rax, rax
	mov	DWORD PTR subr_stack_height$1$[rsp], r12d

; 2264 :          clear_stack = 0;
; 2265 :          break;
; 2266 :       }
; 2267 :       if (clear_stack) sp = 0;
; 2268 :    }

	test	ecx, ecx
	movups	xmm2, XMMWORD PTR subr_stack$[rbp+rax*8-256]
	mov	eax, r11d
	cmove	eax, edi
	movdqa	xmm0, xmm2
	movaps	XMMWORD PTR b$[rsp], xmm2
	psrldq	xmm0, 12
	movdqa	xmm1, xmm2
	movd	r8d, xmm0
	movq	rdx, xmm2
	movdqa	xmm0, xmm2
	psrldq	xmm1, 8
	psrldq	xmm0, 8
	mov	edi, eax
	movq	QWORD PTR b$[rsp+8], xmm0
	mov	DWORD PTR b$2$[rsp], r8d
	movd	r14d, xmm1
	mov	QWORD PTR b$3$[rsp], rdx
	jmp	$LN329@stbtt__run
$LN82@stbtt__run:

; 1140 :    if (b->cursor >= b->size)

	mov	rax, QWORD PTR b$[rsp+8]
	shr	rax, 32					; 00000020H
	cmp	r14d, eax
	jl	SHORT $LN140@stbtt__run

; 1141 :       return 0;

	xor	al, al
	jmp	SHORT $LN139@stbtt__run
$LN140@stbtt__run:

; 1142 :    return b->data[b->cursor++];

	movsxd	rax, r14d
	inc	r14d
	mov	DWORD PTR b$[rsp+8], r14d
	movzx	eax, BYTE PTR [rax+rdx]
$LN139@stbtt__run:

; 2168 : 
; 2169 :       case 0x0C: { // two-byte escape
; 2170 :          float dx1, dx2, dx3, dx4, dx5, dx6, dy1, dy2, dy3, dy4, dy5, dy6;
; 2171 :          float dx, dy;
; 2172 :          int b1 = stbtt__buf_get8(&b);

	movzx	ecx, al

; 2173 :          switch (b1) {

	sub	ecx, 34					; 00000022H
	je	$LN83@stbtt__run
	sub	ecx, 1
	je	$LN85@stbtt__run
	sub	ecx, 1
	je	$LN87@stbtt__run
	cmp	ecx, 1
	jne	$LN3@stbtt__run

; 2221 :             break;
; 2222 : 
; 2223 :          case 0x25: // flex1
; 2224 :             if (sp < 11) return STBTT__CSERR("flex1 stack");

	cmp	edi, 11
	jl	$LN3@stbtt__run

; 2225 :             dx1 = s[0];
; 2226 :             dy1 = s[1];
; 2227 :             dx2 = s[2];
; 2228 :             dy2 = s[3];
; 2229 :             dx3 = s[4];
; 2230 :             dy3 = s[5];
; 2231 :             dx4 = s[6];
; 2232 :             dy4 = s[7];
; 2233 :             dx5 = s[8];
; 2234 :             dy5 = s[9];
; 2235 :             dx6 = dy6 = s[10];

	movss	xmm6, DWORD PTR s$[rbp-216]

; 2236 :             dx = dx1+dx2+dx3+dx4+dx5;

	movaps	xmm2, xmm10
	addss	xmm2, xmm9

; 2237 :             dy = dy1+dy2+dy3+dy4+dy5;

	movaps	xmm3, xmm11
	addss	xmm3, xmm12
	movaps	xmm7, xmm6
	addss	xmm2, xmm15
	addss	xmm3, xmm14
	addss	xmm2, xmm13
	addss	xmm3, DWORD PTR s$[rbp-228]
	addss	xmm2, DWORD PTR s$[rbp-224]
	addss	xmm3, DWORD PTR s$[rbp-220]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	movaps	xmm1, xmm2
	movaps	xmm0, xmm3
	andps	xmm1, xmm5
	andps	xmm0, xmm5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 2238 :             if (STBTT_fabs(dx) > STBTT_fabs(dy))

	comiss	xmm1, xmm0
	jbe	SHORT $LN91@stbtt__run

; 2239 :                dy6 = -dy;

	movaps	xmm6, xmm3
	xorps	xmm6, xmm4
	jmp	SHORT $LN92@stbtt__run
$LN91@stbtt__run:

; 2240 :             else
; 2241 :                dx6 = -dx;

	movaps	xmm7, xmm2
	xorps	xmm7, xmm4
$LN92@stbtt__run:

; 2242 :             stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);

	movss	DWORD PTR [rsp+48], xmm14
	movaps	xmm3, xmm10
	movss	DWORD PTR [rsp+40], xmm15
	movaps	xmm2, xmm12
	movaps	xmm1, xmm9
	movss	DWORD PTR [rsp+32], xmm11
	mov	rcx, r13
	call	?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to

; 2243 :             stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);

	movss	DWORD PTR [rsp+48], xmm6
	movss	DWORD PTR [rsp+40], xmm7

; 2244 :             break;

	jmp	$LN333@stbtt__run
$LN87@stbtt__run:

; 2206 :             break;
; 2207 : 
; 2208 :          case 0x24: // hflex1
; 2209 :             if (sp < 9) return STBTT__CSERR("hflex1 stack");

	cmp	edi, 9
	jl	$LN3@stbtt__run

; 2210 :             dx1 = s[0];
; 2211 :             dy1 = s[1];
; 2212 :             dx2 = s[2];
; 2213 :             dy2 = s[3];
; 2214 :             dx3 = s[4];
; 2215 :             dx4 = s[5];
; 2216 :             dx5 = s[6];
; 2217 :             dy5 = s[7];
; 2218 :             dx6 = s[8];
; 2219 :             stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, 0);

	movss	DWORD PTR [rsp+48], xmm8
	movaps	xmm3, xmm10
	movss	DWORD PTR [rsp+40], xmm15
	movaps	xmm2, xmm12
	movaps	xmm1, xmm9
	movss	DWORD PTR [rsp+32], xmm11
	mov	rcx, r13
	call	?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to

; 2220 :             stbtt__csctx_rccurve_to(c, dx4, 0, dx5, dy5, dx6, -(dy1+dy2+dy5));

	movss	xmm0, DWORD PTR s$[rbp-228]
	movaps	xmm3, xmm11
	addss	xmm3, xmm12
	movaps	xmm2, xmm8
	movaps	xmm1, xmm14

; 2264 :          clear_stack = 0;
; 2265 :          break;
; 2266 :       }
; 2267 :       if (clear_stack) sp = 0;
; 2268 :    }

	mov	rcx, r13
	addss	xmm3, xmm0
	xorps	xmm3, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [rsp+48], xmm3
	movaps	xmm3, xmm13
	movss	DWORD PTR [rsp+40], xmm6
	movss	DWORD PTR [rsp+32], xmm0
	call	?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
	jmp	$LN257@stbtt__run
$LN85@stbtt__run:

; 2187 :             break;
; 2188 : 
; 2189 :          case 0x23: // flex
; 2190 :             if (sp < 13) return STBTT__CSERR("flex stack");

	cmp	edi, 13
	jl	$LN3@stbtt__run

; 2191 :             dx1 = s[0];
; 2192 :             dy1 = s[1];
; 2193 :             dx2 = s[2];
; 2194 :             dy2 = s[3];
; 2195 :             dx3 = s[4];
; 2196 :             dy3 = s[5];
; 2197 :             dx4 = s[6];
; 2198 :             dy4 = s[7];
; 2199 :             dx5 = s[8];
; 2200 :             dy5 = s[9];
; 2201 :             dx6 = s[10];
; 2202 :             dy6 = s[11];
; 2203 :             //fd is s[12]
; 2204 :             stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);

	movss	DWORD PTR [rsp+48], xmm14
	movaps	xmm3, xmm10
	movss	DWORD PTR [rsp+40], xmm15
	movaps	xmm2, xmm12
	movaps	xmm1, xmm9
	movss	DWORD PTR [rsp+32], xmm11
	mov	rcx, r13
	call	?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to

; 2205 :             stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);

	movss	xmm3, DWORD PTR s$[rbp-212]
	movss	xmm0, DWORD PTR s$[rbp-216]
	movss	DWORD PTR [rsp+48], xmm3
	movss	DWORD PTR [rsp+40], xmm0
$LN333@stbtt__run:

; 2264 :          clear_stack = 0;
; 2265 :          break;
; 2266 :       }
; 2267 :       if (clear_stack) sp = 0;
; 2268 :    }

	movss	xmm0, DWORD PTR s$[rbp-220]
	movaps	xmm1, xmm13
	movss	xmm3, DWORD PTR s$[rbp-224]
	mov	rcx, r13
	movss	xmm2, DWORD PTR s$[rbp-228]
	movss	DWORD PTR [rsp+32], xmm0
	call	?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
	movaps	xmm6, xmm3
	jmp	$LN257@stbtt__run
$LN83@stbtt__run:

; 2174 :          // @TODO These "flex" implementations ignore the flex-depth and resolution,
; 2175 :          // and always draw beziers.
; 2176 :          case 0x22: // hflex
; 2177 :             if (sp < 7) return STBTT__CSERR("hflex stack");

	cmp	edi, 7
	jl	$LN3@stbtt__run

; 2178 :             dx1 = s[0];
; 2179 :             dx2 = s[1];
; 2180 :             dy2 = s[2];
; 2181 :             dx3 = s[3];
; 2182 :             dx4 = s[4];
; 2183 :             dx5 = s[5];
; 2184 :             dx6 = s[6];
; 2185 :             stbtt__csctx_rccurve_to(c, dx1, 0, dx2, dy2, dx3, 0);

	movss	DWORD PTR [rsp+48], xmm8
	movaps	xmm3, xmm12
	movss	DWORD PTR [rsp+40], xmm11
	movaps	xmm2, xmm8
	movaps	xmm1, xmm9
	movss	DWORD PTR [rsp+32], xmm10
	mov	rcx, r13
	call	?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to

; 2186 :             stbtt__csctx_rccurve_to(c, dx4, 0, dx5, -dy2, dx6, 0);

	movaps	xmm3, xmm10
	movss	DWORD PTR [rsp+48], xmm8
	xorps	xmm3, DWORD PTR __xmm@80000000800000008000000080000000
	movaps	xmm2, xmm8
	movss	DWORD PTR [rsp+40], xmm13
	movaps	xmm1, xmm15
	movss	DWORD PTR [rsp+32], xmm3

; 2264 :          clear_stack = 0;
; 2265 :          break;
; 2266 :       }
; 2267 :       if (clear_stack) sp = 0;
; 2268 :    }

	mov	rcx, r13
	movaps	xmm3, xmm14
	call	?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
	jmp	$LN257@stbtt__run
$LN94@stbtt__run:

; 2245 : 
; 2246 :          default:
; 2247 :             return STBTT__CSERR("unimplemented");
; 2248 :          }
; 2249 :       } break;
; 2250 : 
; 2251 :       default:
; 2252 :          if (b0 != 255 && b0 != 28 && b0 < 32)

	cmp	esi, 255				; 000000ffH
	je	SHORT $LL249@stbtt__run
	test	esi, -32				; ffffffe0H
	jne	SHORT $LN96@stbtt__run
	cmp	esi, 28
	jne	$LN3@stbtt__run
$LN96@stbtt__run:

; 1160 :    stbtt__buf_seek(b, b->cursor + o);

	dec	r14d

; 1155 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

	cmp	r14d, r8d
	jg	SHORT $LN128@stbtt__run
	mov	DWORD PTR b$[rsp+8], r14d
	test	r14d, r14d
	jns	SHORT $LN129@stbtt__run
$LN128@stbtt__run:
	mov	DWORD PTR b$[rsp+8], r8d
$LN129@stbtt__run:

; 2258 :          } else {
; 2259 :             stbtt__buf_skip(&b, -1);
; 2260 :             f = (float)(stbtt_int16)stbtt__cff_int(&b);

	lea	rcx, QWORD PTR b$[rsp]
	call	?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z	; stbtt__cff_int
	mov	rdx, QWORD PTR b$[rsp]
	xor	r11d, r11d
	mov	r8d, DWORD PTR b$[rsp+12]
	mov	r14d, DWORD PTR b$[rsp+8]
	movsx	ecx, ax
	mov	DWORD PTR b$2$[rsp], r8d
	mov	QWORD PTR b$3$[rsp], rdx
	movd	xmm0, ecx
	cvtdq2ps xmm0, xmm0
	jmp	$LN97@stbtt__run
	npad	6
$LL249@stbtt__run:

; 1140 :    if (b->cursor >= b->size)

	cmp	r14d, r8d
	jl	SHORT $LN119@stbtt__run

; 1141 :       return 0;

	xor	al, al
	jmp	SHORT $LN118@stbtt__run
$LN119@stbtt__run:

; 1142 :    return b->data[b->cursor++];

	movsxd	rax, r14d
	inc	r14d
	mov	DWORD PTR b$[rsp+8], r14d
	movzx	eax, BYTE PTR [rax+rdx]
$LN118@stbtt__run:

; 1169 :       v = (v << 8) | stbtt__buf_get8(b);

	movzx	ecx, al

; 1140 :    if (b->cursor >= b->size)

	cmp	r14d, r8d
	jl	SHORT $LN225@stbtt__run

; 1141 :       return 0;

	xor	al, al
	jmp	SHORT $LN226@stbtt__run
$LN225@stbtt__run:

; 1142 :    return b->data[b->cursor++];

	movsxd	rax, r14d
	inc	r14d
	mov	DWORD PTR b$[rsp+8], r14d
	movzx	eax, BYTE PTR [rax+rdx]
$LN226@stbtt__run:

; 1169 :       v = (v << 8) | stbtt__buf_get8(b);

	shl	ecx, 8
	movzx	eax, al
	or	ecx, eax

; 1140 :    if (b->cursor >= b->size)

	cmp	r14d, r8d
	jl	SHORT $LN228@stbtt__run

; 1141 :       return 0;

	xor	al, al
	jmp	SHORT $LN229@stbtt__run
$LN228@stbtt__run:

; 1142 :    return b->data[b->cursor++];

	movsxd	rax, r14d
	inc	r14d
	mov	DWORD PTR b$[rsp+8], r14d
	movzx	eax, BYTE PTR [rax+rdx]
$LN229@stbtt__run:

; 1169 :       v = (v << 8) | stbtt__buf_get8(b);

	shl	ecx, 8
	movzx	eax, al
	or	ecx, eax

; 1140 :    if (b->cursor >= b->size)

	cmp	r14d, r8d
	jl	SHORT $LN231@stbtt__run

; 1141 :       return 0;

	xor	al, al
	jmp	SHORT $LN232@stbtt__run
$LN231@stbtt__run:

; 1142 :    return b->data[b->cursor++];

	movsxd	rax, r14d
	inc	r14d
	mov	DWORD PTR b$[rsp+8], r14d
	movzx	eax, BYTE PTR [rax+rdx]
$LN232@stbtt__run:

; 1169 :       v = (v << 8) | stbtt__buf_get8(b);

	shl	ecx, 8
	movzx	eax, al
	or	ecx, eax
	movd	xmm0, ecx

; 2253 :             return STBTT__CSERR("reserved operator");
; 2254 : 
; 2255 :          // push immediate
; 2256 :          if (b0 == 255) {
; 2257 :             f = (float)(stbtt_int32)stbtt__buf_get32(&b) / 0x10000;

	cvtdq2ps xmm0, xmm0
	mulss	xmm0, DWORD PTR __real@37800000
$LN97@stbtt__run:

; 2261 :          }
; 2262 :          if (sp >= 48) return STBTT__CSERR("push stack overflow");

	cmp	edi, 48					; 00000030H
	jge	$LN3@stbtt__run

; 2263 :          s[sp++] = f;

	movsxd	rax, edi
	mov	ecx, r11d
	inc	edi

; 2264 :          clear_stack = 0;
; 2265 :          break;
; 2266 :       }
; 2267 :       if (clear_stack) sp = 0;
; 2268 :    }

	test	ecx, ecx
	movss	DWORD PTR s$[rbp+rax*4-256], xmm0
	mov	eax, r11d
	movss	xmm13, DWORD PTR s$[rbp-232]
	cmove	eax, edi
	movss	xmm14, DWORD PTR s$[rbp-236]
	mov	edi, eax
	movss	xmm15, DWORD PTR s$[rbp-240]
	movss	xmm11, DWORD PTR s$[rbp-244]
	movss	xmm10, DWORD PTR s$[rbp-248]
	movss	xmm12, DWORD PTR s$[rbp-252]
	movss	xmm9, DWORD PTR s$[rbp-256]
	movss	xmm6, DWORD PTR s$[rbp-224]
	jmp	$LN329@stbtt__run
$LN81@stbtt__run:

; 2163 :          break;
; 2164 : 
; 2165 :       case 0x0E: // endchar
; 2166 :          stbtt__csctx_close_shape(c);

	mov	rcx, r13
	call	?stbtt__csctx_close_shape@@YAXPEAUstbtt__csctx@@@Z ; stbtt__csctx_close_shape

; 2167 :          return 1;

	mov	eax, 1
	jmp	$LN1@stbtt__run
	npad	3
$LN255@stbtt__run:

; 2270 : 
; 2271 : #undef STBTT__CSERR
; 2272 : }

	DD	$LN32@stbtt__run
	DD	$LN94@stbtt__run
	DD	$LN32@stbtt__run
	DD	$LN38@stbtt__run
	DD	$LN42@stbtt__run
	DD	$LN47@stbtt__run
	DD	$LN44@stbtt__run
	DD	$LN58@stbtt__run
	DD	$LN94@stbtt__run
	DD	$LN72@stbtt__run
	DD	$LN79@stbtt__run
	DD	$LN82@stbtt__run
	DD	$LN94@stbtt__run
	DD	$LN81@stbtt__run
	DD	$LN94@stbtt__run
	DD	$LN94@stbtt__run
	DD	$LN94@stbtt__run
	DD	$LN32@stbtt__run
	DD	$LN29@stbtt__run
	DD	$LN29@stbtt__run
	DD	$LN36@stbtt__run
	DD	$LN40@stbtt__run
	DD	$LN32@stbtt__run
	DD	$LN60@stbtt__run
	DD	$LN63@stbtt__run
	DD	$LN66@stbtt__run
	DD	$LN66@stbtt__run
	DD	$LN94@stbtt__run
	DD	$LN263@stbtt__run
	DD	$LN54@stbtt__run
	DD	$LN51@stbtt__run
?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z ENDP ; stbtt__run_charstring
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__GetGlyphShapeT2@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z
_TEXT	SEGMENT
count_ctx$ = 32
output_ctx$ = 88
__$ArrayPad$ = 144
info$ = 192
glyph_index$ = 200
pvertices$ = 208
?stbtt__GetGlyphShapeT2@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z PROC ; stbtt__GetGlyphShapeT2, COMDAT

; 2275 : {

	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 160				; 000000a0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 2276 :    // runs the charstring twice, once to count and once to output (to avoid realloc)
; 2277 :    stbtt__csctx count_ctx = STBTT__CSCTX_INIT(1);

	xor	ebp, ebp
	mov	QWORD PTR count_ctx$[rsp], 1
	xorps	xmm0, xmm0
	mov	QWORD PTR count_ctx$[rsp+40], rbp
	xorps	xmm1, xmm1
	mov	DWORD PTR count_ctx$[rsp+48], ebp
	mov	rbx, r8

; 2278 :    stbtt__csctx output_ctx = STBTT__CSCTX_INIT(0);

	mov	QWORD PTR output_ctx$[rsp], rbp

; 2279 :    if (stbtt__run_charstring(info, glyph_index, &count_ctx)) {

	lea	r8, QWORD PTR count_ctx$[rsp]
	mov	DWORD PTR output_ctx$[rsp+48], ebp
	movups	XMMWORD PTR count_ctx$[rsp+8], xmm0
	mov	esi, edx
	mov	rdi, rcx
	movdqu	XMMWORD PTR count_ctx$[rsp+24], xmm1
	movups	XMMWORD PTR output_ctx$[rsp+8], xmm0
	movdqu	XMMWORD PTR output_ctx$[rsp+24], xmm1
	call	?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z ; stbtt__run_charstring
	test	eax, eax
	je	SHORT $LN6@stbtt__Get

; 2280 :       *pvertices = (stbtt_vertex*)STBTT_malloc(count_ctx.num_vertices*sizeof(stbtt_vertex), info->userdata);

	movsxd	rax, DWORD PTR count_ctx$[rsp+48]
	imul	rcx, rax, 14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN9@stbtt__Get

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN9@stbtt__Get:

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 2282 :       if (stbtt__run_charstring(info, glyph_index, &output_ctx)) {

	lea	r8, QWORD PTR output_ctx$[rsp]
	mov	edx, esi
	mov	rcx, rdi
	mov	QWORD PTR [rbx], rax
	mov	QWORD PTR output_ctx$[rsp+40], rax
	call	?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z ; stbtt__run_charstring
	test	eax, eax
	je	SHORT $LN6@stbtt__Get

; 2283 :          STBTT_assert(output_ctx.num_vertices == count_ctx.num_vertices);
; 2284 :          return output_ctx.num_vertices;

	mov	eax, DWORD PTR output_ctx$[rsp+48]
	jmp	SHORT $LN1@stbtt__Get
$LN6@stbtt__Get:

; 2285 :       }
; 2286 :    }
; 2287 :    *pvertices = NULL;

	mov	QWORD PTR [rbx], rbp

; 2288 :    return 0;

	xor	eax, eax
$LN1@stbtt__Get:

; 2289 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+216]
	add	rsp, 160				; 000000a0H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?stbtt__GetGlyphShapeT2@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z ENDP ; stbtt__GetGlyphShapeT2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__GetGlyphInfoT2@@YAHPEBUstbtt_fontinfo@@HPEAH111@Z
_TEXT	SEGMENT
c$ = 32
__$ArrayPad$ = 88
info$ = 144
glyph_index$ = 152
x0$ = 160
y0$ = 168
x1$ = 176
y1$ = 184
?stbtt__GetGlyphInfoT2@@YAHPEBUstbtt_fontinfo@@HPEAH111@Z PROC ; stbtt__GetGlyphInfoT2, COMDAT

; 2292 : {

	push	rbx
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rsi, QWORD PTR x1$[rsp]
	mov	r15, r8
	mov	rdi, QWORD PTR y1$[rsp]

; 2293 :    stbtt__csctx c = STBTT__CSCTX_INIT(1);
; 2294 :    int r = stbtt__run_charstring(info, glyph_index, &c);

	lea	r8, QWORD PTR c$[rsp]
	xor	ebx, ebx
	mov	QWORD PTR c$[rsp], 1
	xorps	xmm0, xmm0
	mov	QWORD PTR c$[rsp+40], rbx
	xorps	xmm1, xmm1
	mov	DWORD PTR c$[rsp+48], ebx
	movups	XMMWORD PTR c$[rsp+8], xmm0
	mov	r14, r9
	movdqu	XMMWORD PTR c$[rsp+24], xmm1
	call	?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z ; stbtt__run_charstring
	mov	edx, eax

; 2295 :    if (x0)  *x0 = r ? c.min_x : 0;

	test	r15, r15
	je	SHORT $LN2@stbtt__Get
	test	edx, edx
	mov	eax, ebx
	cmovne	eax, DWORD PTR c$[rsp+24]
	mov	DWORD PTR [r15], eax
$LN2@stbtt__Get:

; 2296 :    if (y0)  *y0 = r ? c.min_y : 0;

	test	r14, r14
	je	SHORT $LN3@stbtt__Get
	test	edx, edx
	mov	eax, ebx
	cmovne	eax, DWORD PTR c$[rsp+32]
	mov	DWORD PTR [r14], eax
$LN3@stbtt__Get:

; 2297 :    if (x1)  *x1 = r ? c.max_x : 0;

	test	rsi, rsi
	je	SHORT $LN4@stbtt__Get
	test	edx, edx
	mov	eax, ebx
	cmovne	eax, DWORD PTR c$[rsp+28]
	mov	DWORD PTR [rsi], eax
$LN4@stbtt__Get:

; 2298 :    if (y1)  *y1 = r ? c.max_y : 0;

	test	rdi, rdi
	je	SHORT $LN5@stbtt__Get
	test	edx, edx
	mov	ecx, ebx
	cmovne	ecx, DWORD PTR c$[rsp+36]
	mov	DWORD PTR [rdi], ecx
$LN5@stbtt__Get:

; 2299 :    return r ? c.num_vertices : 0;

	test	edx, edx
	cmovne	ebx, DWORD PTR c$[rsp+48]
	mov	eax, ebx

; 2300 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 96					; 00000060H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?stbtt__GetGlyphInfoT2@@YAHPEBUstbtt_fontinfo@@HPEAH111@Z ENDP ; stbtt__GetGlyphInfoT2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT stbtt_GetGlyphShape
_TEXT	SEGMENT
count_ctx$1 = 32
output_ctx$2 = 88
__$ArrayPad$ = 144
info$ = 192
glyph_index$ = 200
pvertices$ = 208
stbtt_GetGlyphShape PROC				; COMDAT

; 2303 : {

	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 160				; 000000a0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 2304 :    if (!info->cff.size)

	cmp	DWORD PTR [rcx+76], 0
	mov	rsi, r8
	mov	ebp, edx
	mov	rdi, rcx
	jne	SHORT $LN2@stbtt_GetG

; 2305 :       return stbtt__GetGlyphShapeTT(info, glyph_index, pvertices);

	call	?stbtt__GetGlyphShapeTT@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z ; stbtt__GetGlyphShapeTT
	jmp	$LN3@stbtt_GetG
$LN2@stbtt_GetG:
	xorps	xmm0, xmm0
	mov	QWORD PTR [rsp+216], rbx

; 2277 :    stbtt__csctx count_ctx = STBTT__CSCTX_INIT(1);

	xor	ebx, ebx
	mov	QWORD PTR count_ctx$1[rsp], 1
	xorps	xmm1, xmm1
	mov	QWORD PTR count_ctx$1[rsp+40], rbx

; 2278 :    stbtt__csctx output_ctx = STBTT__CSCTX_INIT(0);
; 2279 :    if (stbtt__run_charstring(info, glyph_index, &count_ctx)) {

	lea	r8, QWORD PTR count_ctx$1[rsp]
	mov	DWORD PTR count_ctx$1[rsp+48], ebx
	mov	QWORD PTR output_ctx$2[rsp], rbx
	mov	DWORD PTR output_ctx$2[rsp+48], ebx
	movups	XMMWORD PTR count_ctx$1[rsp+8], xmm0
	movdqu	XMMWORD PTR count_ctx$1[rsp+24], xmm1
	movups	XMMWORD PTR output_ctx$2[rsp+8], xmm0
	movdqu	XMMWORD PTR output_ctx$2[rsp+24], xmm1
	call	?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z ; stbtt__run_charstring
	test	eax, eax
	je	SHORT $LN10@stbtt_GetG

; 2280 :       *pvertices = (stbtt_vertex*)STBTT_malloc(count_ctx.num_vertices*sizeof(stbtt_vertex), info->userdata);

	movsxd	rax, DWORD PTR count_ctx$1[rsp+48]
	imul	rcx, rax, 14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN13@stbtt_GetG

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN13@stbtt_GetG:

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 2282 :       if (stbtt__run_charstring(info, glyph_index, &output_ctx)) {

	lea	r8, QWORD PTR output_ctx$2[rsp]
	mov	edx, ebp
	mov	rcx, rdi
	mov	QWORD PTR [rsi], rax
	mov	QWORD PTR output_ctx$2[rsp+40], rax
	call	?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z ; stbtt__run_charstring
	test	eax, eax
	je	SHORT $LN10@stbtt_GetG

; 2283 :          STBTT_assert(output_ctx.num_vertices == count_ctx.num_vertices);
; 2284 :          return output_ctx.num_vertices;

	mov	ebx, DWORD PTR output_ctx$2[rsp+48]
	jmp	SHORT $LN5@stbtt_GetG
$LN10@stbtt_GetG:

; 2285 :       }
; 2286 :    }
; 2287 :    *pvertices = NULL;

	mov	QWORD PTR [rsi], rbx
$LN5@stbtt_GetG:

; 2306 :    else
; 2307 :       return stbtt__GetGlyphShapeT2(info, glyph_index, pvertices);

	mov	eax, ebx
	mov	rbx, QWORD PTR [rsp+216]
$LN3@stbtt_GetG:

; 2308 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 160				; 000000a0H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
stbtt_GetGlyphShape ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT stbtt_GetGlyphHMetrics
_TEXT	SEGMENT
info$ = 16
glyph_index$ = 24
advanceWidth$ = 32
leftSideBearing$ = 40
stbtt_GetGlyphHMetrics PROC				; COMDAT

; 2311 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	mov	QWORD PTR [rsp+32], r14
	push	r15

; 2312 :    stbtt_uint16 numOfLongHorMetrics = ttUSHORT(info->data+info->hhea + 34);

	mov	r15, QWORD PTR [rcx+8]
	mov	r14, r9
	movsxd	rax, DWORD PTR [rcx+36]

; 2313 :    if (glyph_index < numOfLongHorMetrics) {

	lea	r9, QWORD PTR [rcx+40]
	mov	rbx, r8
	mov	esi, edx
	mov	edi, 256				; 00000100H
	movzx	r10d, BYTE PTR [rax+r15+34]
	movzx	eax, BYTE PTR [rax+r15+35]
	shl	r10d, 8
	add	r10d, eax
	cmp	edx, r10d
	jge	SHORT $LN2@stbtt_GetG

; 2314 :       if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*glyph_index);

	lea	r10d, DWORD PTR [rdx*4]
	test	rbx, rbx
	je	SHORT $LN21@stbtt_GetG
	movsxd	r8, DWORD PTR [r9]
	movsxd	rax, r10d
	add	rax, r15

; 1292 : static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }

	movsx	ecx, di
	movzx	edx, BYTE PTR [r8+rax]
	movzx	eax, BYTE PTR [r8+rax+1]
	imul	edx, ecx
	add	ax, dx

; 2314 :       if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*glyph_index);

	cwde
	mov	DWORD PTR [rbx], eax
$LN21@stbtt_GetG:

; 2315 :       if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*glyph_index + 2);

	test	r14, r14
	je	SHORT $LN7@stbtt_GetG
	movsxd	rax, DWORD PTR [r9]
	add	rax, r15
	movsxd	r8, r10d

; 1292 : static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }

	movzx	edx, BYTE PTR [r8+rax+2]
	movzx	eax, BYTE PTR [r8+rax+3]

; 2316 :    } else {

	jmp	SHORT $LN28@stbtt_GetG
$LN2@stbtt_GetG:

; 2317 :       if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*(numOfLongHorMetrics-1));

	lea	r11d, DWORD PTR [r10*4]
	test	rbx, rbx
	je	SHORT $LN22@stbtt_GetG
	movsxd	rax, DWORD PTR [r9]
	add	rax, r15

; 1292 : static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }

	movsx	ecx, di
	movzx	edx, BYTE PTR [r11+rax-4]
	movzx	eax, BYTE PTR [r11+rax-3]
	imul	edx, ecx
	add	ax, dx

; 2317 :       if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*(numOfLongHorMetrics-1));

	cwde
	mov	DWORD PTR [r8], eax
$LN22@stbtt_GetG:

; 2318 :       if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*numOfLongHorMetrics + 2*(glyph_index - numOfLongHorMetrics));

	test	r14, r14
	je	SHORT $LN7@stbtt_GetG
	movsxd	rcx, DWORD PTR [r9]
	sub	esi, r10d
	add	rcx, r15
	mov	r8d, r11d
	lea	eax, DWORD PTR [rsi+rsi]
	cdqe
	add	rcx, rax
	add	r8, rcx

; 1292 : static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }

	movzx	edx, BYTE PTR [r8]
	movzx	eax, BYTE PTR [r8+1]
$LN28@stbtt_GetG:

; 2319 :    }
; 2320 : }

	movsx	ecx, di
	imul	edx, ecx
	add	ax, dx
	cwde
	mov	DWORD PTR [r14], eax
$LN7@stbtt_GetG:
	mov	rbx, QWORD PTR [rsp+16]
	mov	rsi, QWORD PTR [rsp+24]
	mov	rdi, QWORD PTR [rsp+32]
	mov	r14, QWORD PTR [rsp+40]
	pop	r15
	ret	0
stbtt_GetGlyphHMetrics ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT stbtt_GetFontVMetrics
_TEXT	SEGMENT
info$ = 8
ascent$ = 16
descent$ = 24
lineGap$ = 32
stbtt_GetFontVMetrics PROC				; COMDAT

; 2640 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	lea	r11, QWORD PTR [rcx+36]
	mov	rdi, r8
	lea	rbx, QWORD PTR [rcx+8]
	mov	r8, rdx

; 2641 :    if (ascent ) *ascent  = ttSHORT(info->data+info->hhea + 4);

	mov	esi, 256				; 00000100H
	test	rdx, rdx
	je	SHORT $LN12@stbtt_GetF
	movsxd	r10, DWORD PTR [r11]
	mov	rax, QWORD PTR [rbx]

; 1292 : static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }

	movsx	ecx, si
	movzx	edx, BYTE PTR [r10+rax+4]
	movzx	eax, BYTE PTR [r10+rax+5]
	imul	edx, ecx
	add	ax, dx

; 2641 :    if (ascent ) *ascent  = ttSHORT(info->data+info->hhea + 4);

	cwde
	mov	DWORD PTR [r8], eax
$LN12@stbtt_GetF:

; 2642 :    if (descent) *descent = ttSHORT(info->data+info->hhea + 6);

	test	rdi, rdi
	je	SHORT $LN3@stbtt_GetF
	movsxd	r8, DWORD PTR [r11]
	mov	rax, QWORD PTR [rbx]

; 1292 : static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }

	movsx	ecx, si
	movzx	edx, BYTE PTR [r8+rax+6]
	movzx	eax, BYTE PTR [r8+rax+7]
	imul	edx, ecx
	add	ax, dx

; 2642 :    if (descent) *descent = ttSHORT(info->data+info->hhea + 6);

	cwde
	mov	DWORD PTR [rdi], eax
$LN3@stbtt_GetF:

; 2643 :    if (lineGap) *lineGap = ttSHORT(info->data+info->hhea + 8);

	test	r9, r9
	je	SHORT $LN4@stbtt_GetF
	movsxd	r8, DWORD PTR [r11]
	mov	rax, QWORD PTR [rbx]

; 1292 : static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }

	movsx	ecx, si
	movzx	edx, BYTE PTR [r8+rax+8]
	movzx	eax, BYTE PTR [r8+rax+9]
	imul	edx, ecx
	add	ax, dx

; 2643 :    if (lineGap) *lineGap = ttSHORT(info->data+info->hhea + 8);

	cwde
	mov	DWORD PTR [r9], eax
$LN4@stbtt_GetF:

; 2644 : }

	mov	rbx, QWORD PTR [rsp+8]
	mov	rsi, QWORD PTR [rsp+16]
	mov	rdi, QWORD PTR [rsp+24]
	ret	0
stbtt_GetFontVMetrics ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT stbtt_ScaleForPixelHeight
_TEXT	SEGMENT
info$ = 8
height$ = 16
stbtt_ScaleForPixelHeight PROC				; COMDAT

; 2667 :    int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);

	movsxd	r10, DWORD PTR [rcx+36]

; 1292 : static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }

	mov	r11d, 256				; 00000100H

; 2667 :    int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);

	mov	r9, QWORD PTR [rcx+8]

; 1292 : static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }

	movsx	eax, r11w
	movsx	ecx, r11w
	movzx	edx, BYTE PTR [r10+r9+6]
	imul	edx, eax
	movzx	eax, BYTE PTR [r10+r9+7]
	add	dx, ax
	movzx	eax, BYTE PTR [r10+r9+5]

; 2667 :    int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);

	movsx	r8d, dx

; 1292 : static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }

	movzx	edx, BYTE PTR [r10+r9+4]
	imul	edx, ecx
	add	ax, dx

; 2667 :    int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);

	cwde
	sub	eax, r8d
	movd	xmm0, eax

; 2668 :    return (float) height / fheight;

	cvtdq2ps xmm0, xmm0
	divss	xmm1, xmm0
	movaps	xmm0, xmm1

; 2669 : }

	ret	0
stbtt_ScaleForPixelHeight ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT stbtt_ScaleForMappingEmToPixels
_TEXT	SEGMENT
info$ = 8
pixels$ = 16
stbtt_ScaleForMappingEmToPixels PROC			; COMDAT

; 2673 :    int unitsPerEm = ttUSHORT(info->data + info->head + 18);

	movsxd	rdx, DWORD PTR [rcx+28]
	mov	rax, QWORD PTR [rcx+8]

; 1291 : static stbtt_uint16 ttUSHORT(stbtt_uint8 *p) { return p[0]*256 + p[1]; }

	movzx	ecx, BYTE PTR [rdx+rax+18]
	movzx	eax, BYTE PTR [rdx+rax+19]
	shl	ecx, 8
	add	ecx, eax
	movd	xmm0, ecx

; 2674 :    return pixels / unitsPerEm;

	cvtdq2ps xmm0, xmm0
	divss	xmm1, xmm0
	movaps	xmm0, xmm1

; 2675 : }

	ret	0
stbtt_ScaleForMappingEmToPixels ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT stbtt_GetGlyphBitmapBoxSubpixel
_TEXT	SEGMENT
c$1 = 32
__$ArrayPad$ = 88
font$ = 192
glyph$ = 200
scale_x$ = 208
scale_y$ = 216
shift_x$ = 224
shift_y$ = 232
ix0$ = 240
iy0$ = 248
ix1$ = 256
iy1$ = 264
stbtt_GetGlyphBitmapBoxSubpixel PROC			; COMDAT

; 2727 : {

	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 144				; 00000090H
	movaps	XMMWORD PTR [rsp+112], xmm7
	movaps	XMMWORD PTR [rsp+96], xmm8
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1632 :    if (info->cff.size) {

	cmp	DWORD PTR [rcx+76], 0

; 2727 : {

	movaps	xmm7, xmm3
	mov	rsi, QWORD PTR ix0$[rsp]
	movaps	xmm8, xmm2
	mov	r14, QWORD PTR iy0$[rsp]
	mov	r11, rcx
	mov	r15, QWORD PTR ix1$[rsp]
	mov	rdi, QWORD PTR iy1$[rsp]

; 1632 :    if (info->cff.size) {

	je	SHORT $LN14@stbtt_GetG

; 2293 :    stbtt__csctx c = STBTT__CSCTX_INIT(1);

	xor	ebx, ebx
	mov	QWORD PTR c$1[rsp], 1
	xorps	xmm0, xmm0
	mov	QWORD PTR c$1[rsp+40], rbx
	xorps	xmm1, xmm1
	mov	DWORD PTR c$1[rsp+48], ebx

; 2294 :    int r = stbtt__run_charstring(info, glyph_index, &c);

	lea	r8, QWORD PTR c$1[rsp]
	movups	XMMWORD PTR c$1[rsp+8], xmm0
	movdqu	XMMWORD PTR c$1[rsp+24], xmm1
	call	?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z ; stbtt__run_charstring

; 2295 :    if (x0)  *x0 = r ? c.min_x : 0;

	test	eax, eax
	mov	r11d, ebx

; 2296 :    if (y0)  *y0 = r ? c.min_y : 0;

	mov	ebp, ebx

; 2297 :    if (x1)  *x1 = r ? c.max_x : 0;

	mov	r8d, ebx
	cmovne	r11d, DWORD PTR c$1[rsp+24]
	cmovne	ebp, DWORD PTR c$1[rsp+32]
	cmovne	r8d, DWORD PTR c$1[rsp+28]

; 2298 :    if (y1)  *y1 = r ? c.max_y : 0;

	cmovne	ebx, DWORD PTR c$1[rsp+36]

; 1634 :    } else {

	jmp	SHORT $LN20@stbtt_GetG
$LN14@stbtt_GetG:

; 1635 :       int g = stbtt__GetGlyfOffset(info, glyph_index);

	call	?stbtt__GetGlyfOffset@@YAHPEBUstbtt_fontinfo@@H@Z ; stbtt__GetGlyfOffset

; 1636 :       if (g < 0) return 0;

	test	eax, eax
	js	$LN49@stbtt_GetG

; 1637 : 
; 1638 :       if (x0) *x0 = ttSHORT(info->data + g + 2);

	mov	r9, QWORD PTR [r11+8]

; 1292 : static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }

	mov	ebx, 256				; 00000100H

; 1638 :       if (x0) *x0 = ttSHORT(info->data + g + 2);

	movsxd	r10, eax

; 1292 : static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }

	movsx	eax, bx
	movsx	ecx, bx
	movzx	r8d, BYTE PTR [r9+r10+5]
	movzx	edx, BYTE PTR [r9+r10+2]
	imul	edx, eax
	movzx	eax, BYTE PTR [r9+r10+3]
	add	dx, ax
	movzx	eax, BYTE PTR [r9+r10+7]

; 1638 :       if (x0) *x0 = ttSHORT(info->data + g + 2);

	movsx	r11d, dx

; 1292 : static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }

	movzx	edx, BYTE PTR [r9+r10+4]
	imul	edx, ecx
	movsx	ecx, bx
	add	r8w, dx
	movzx	edx, BYTE PTR [r9+r10+6]
	imul	edx, ecx
	movsx	ecx, bx

; 1639 :       if (y0) *y0 = ttSHORT(info->data + g + 4);

	movsx	ebp, r8w

; 1292 : static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }

	add	dx, ax
	movzx	eax, BYTE PTR [r9+r10+9]

; 1640 :       if (x1) *x1 = ttSHORT(info->data + g + 6);

	movsx	r8d, dx

; 1292 : static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }

	movzx	edx, BYTE PTR [r9+r10+8]
	imul	edx, ecx
	add	dx, ax

; 1641 :       if (y1) *y1 = ttSHORT(info->data + g + 8);

	movsx	ebx, dx
$LN20@stbtt_GetG:

; 2737 :       if (ix0) *ix0 = STBTT_ifloor( x0 * scale_x + shift_x);

	movss	xmm3, DWORD PTR shift_x$[rsp]
	xorps	xmm2, xmm2
	movaps	XMMWORD PTR [rsp+128], xmm6
	test	rsi, rsi
	je	SHORT $LN8@stbtt_GetG
	movd	xmm1, r11d
	cvtdq2ps xmm1, xmm1
	mulss	xmm1, xmm8
	addss	xmm1, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 473  : static inline float  ImFloorSigned(float f)                                     { return (float)((f >= 0 || (float)(int)f == f) ? (int)f : (int)f - 1); } // Decent replacement for floorf()

	comiss	xmm1, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 2737 :       if (ix0) *ix0 = STBTT_ifloor( x0 * scale_x + shift_x);

	cvttss2si eax, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 473  : static inline float  ImFloorSigned(float f)                                     { return (float)((f >= 0 || (float)(int)f == f) ? (int)f : (int)f - 1); } // Decent replacement for floorf()

	jae	SHORT $LN47@stbtt_GetG
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	ucomiss	xmm0, xmm1
	jp	SHORT $LN51@stbtt_GetG
	je	SHORT $LN47@stbtt_GetG
$LN51@stbtt_GetG:
	dec	eax
$LN47@stbtt_GetG:
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 2737 :       if (ix0) *ix0 = STBTT_ifloor( x0 * scale_x + shift_x);

	cvttss2si eax, xmm0
	mov	DWORD PTR [rsi], eax
$LN8@stbtt_GetG:

; 2738 :       if (iy0) *iy0 = STBTT_ifloor(-y1 * scale_y + shift_y);

	movss	xmm6, DWORD PTR shift_y$[rsp]
	test	r14, r14
	je	SHORT $LN9@stbtt_GetG
	movd	xmm0, ebx
	movaps	xmm1, xmm6
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm7
	subss	xmm1, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 473  : static inline float  ImFloorSigned(float f)                                     { return (float)((f >= 0 || (float)(int)f == f) ? (int)f : (int)f - 1); } // Decent replacement for floorf()

	comiss	xmm1, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 2738 :       if (iy0) *iy0 = STBTT_ifloor(-y1 * scale_y + shift_y);

	cvttss2si eax, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 473  : static inline float  ImFloorSigned(float f)                                     { return (float)((f >= 0 || (float)(int)f == f) ? (int)f : (int)f - 1); } // Decent replacement for floorf()

	jae	SHORT $LN48@stbtt_GetG
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	ucomiss	xmm0, xmm1
	jp	SHORT $LN50@stbtt_GetG
	je	SHORT $LN48@stbtt_GetG
$LN50@stbtt_GetG:
	dec	eax
$LN48@stbtt_GetG:
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 2738 :       if (iy0) *iy0 = STBTT_ifloor(-y1 * scale_y + shift_y);

	cvttss2si eax, xmm0
	mov	DWORD PTR [r14], eax
$LN9@stbtt_GetG:

; 2739 :       if (ix1) *ix1 = STBTT_iceil ( x1 * scale_x + shift_x);

	test	r15, r15
	je	SHORT $LN10@stbtt_GetG
	movd	xmm0, r8d
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm8
	addss	xmm0, xmm3
	call	ceilf
	cvttss2si eax, xmm0
	mov	DWORD PTR [r15], eax
$LN10@stbtt_GetG:

; 2740 :       if (iy1) *iy1 = STBTT_iceil (-y0 * scale_y + shift_y);

	test	rdi, rdi
	je	SHORT $LN66@stbtt_GetG
	movd	xmm1, ebp
	cvtdq2ps xmm1, xmm1
	mulss	xmm1, xmm7
	subss	xmm6, xmm1
	movaps	xmm0, xmm6
	call	ceilf
	cvttss2si eax, xmm0
	mov	DWORD PTR [rdi], eax
$LN66@stbtt_GetG:
	movaps	xmm6, XMMWORD PTR [rsp+128]
$LN11@stbtt_GetG:

; 2741 :    }
; 2742 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+208]
	movaps	xmm7, XMMWORD PTR [rsp+112]
	movaps	xmm8, XMMWORD PTR [rsp+96]
	add	rsp, 144				; 00000090H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN49@stbtt_GetG:

; 2728 :    int x0=0,y0=0,x1,y1; // =0 suppresses compiler warning
; 2729 :    if (!stbtt_GetGlyphBox(font, glyph, &x0,&y0,&x1,&y1)) {
; 2730 :       // e.g. space character
; 2731 :       if (ix0) *ix0 = 0;

	xor	ebx, ebx
	test	rsi, rsi
	je	SHORT $LN4@stbtt_GetG
	mov	DWORD PTR [rsi], ebx
$LN4@stbtt_GetG:

; 2732 :       if (iy0) *iy0 = 0;

	test	r14, r14
	je	SHORT $LN5@stbtt_GetG
	mov	DWORD PTR [r14], ebx
$LN5@stbtt_GetG:

; 2733 :       if (ix1) *ix1 = 0;

	test	r15, r15
	je	SHORT $LN6@stbtt_GetG
	mov	DWORD PTR [r15], ebx
$LN6@stbtt_GetG:

; 2734 :       if (iy1) *iy1 = 0;

	test	rdi, rdi
	je	SHORT $LN11@stbtt_GetG
	mov	DWORD PTR [rdi], ebx
	jmp	SHORT $LN11@stbtt_GetG
stbtt_GetGlyphBitmapBoxSubpixel ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT stbtt_GetGlyphBitmapBox
_TEXT	SEGMENT
font$ = 96
glyph$ = 104
scale_x$ = 112
scale_y$ = 120
ix0$ = 128
iy0$ = 136
ix1$ = 144
iy1$ = 152
stbtt_GetGlyphBitmapBox PROC				; COMDAT

; 2745 : {

	sub	rsp, 88					; 00000058H

; 2746 :    stbtt_GetGlyphBitmapBoxSubpixel(font, glyph, scale_x, scale_y,0.0f,0.0f, ix0, iy0, ix1, iy1);

	mov	rax, QWORD PTR iy1$[rsp]
	xorps	xmm0, xmm0
	mov	QWORD PTR [rsp+72], rax
	mov	rax, QWORD PTR ix1$[rsp]
	mov	QWORD PTR [rsp+64], rax
	mov	rax, QWORD PTR iy0$[rsp]
	mov	QWORD PTR [rsp+56], rax
	mov	rax, QWORD PTR ix0$[rsp]
	mov	QWORD PTR [rsp+48], rax
	movss	DWORD PTR [rsp+40], xmm0
	movss	DWORD PTR [rsp+32], xmm0
	call	stbtt_GetGlyphBitmapBoxSubpixel

; 2747 : }

	add	rsp, 88					; 00000058H
	ret	0
stbtt_GetGlyphBitmapBox ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__hheap_alloc@@YAPEAXPEAUstbtt__hheap@@_KPEAX@Z
_TEXT	SEGMENT
hh$ = 48
size$dead$ = 56
userdata$dead$ = 64
?stbtt__hheap_alloc@@YAPEAXPEAUstbtt__hheap@@_KPEAX@Z PROC ; stbtt__hheap_alloc, COMDAT

; 2776 : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 2777 :    if (hh->first_free) {

	mov	rax, QWORD PTR [rcx+8]
	mov	rbx, rcx
	test	rax, rax
	je	SHORT $LN2@stbtt__hhe

; 2778 :       void *p = hh->first_free;
; 2779 :       hh->first_free = * (void **) p;

	mov	rdx, QWORD PTR [rax]
	mov	QWORD PTR [rcx+8], rdx

; 2793 :    }
; 2794 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN2@stbtt__hhe:

; 2780 :       return p;
; 2781 :    } else {
; 2782 :       if (hh->num_remaining_in_head_chunk == 0) {

	mov	eax, DWORD PTR [rcx+16]
	test	eax, eax
	jne	SHORT $LN17@stbtt__hhe
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN10@stbtt__hhe

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN10@stbtt__hhe:

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	mov	ecx, 25608				; 00006408H
	call	QWORD PTR __imp_malloc
	mov	rcx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 2785 :          if (c == NULL)

	test	rax, rax
	jne	SHORT $LN5@stbtt__hhe

; 2793 :    }
; 2794 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN5@stbtt__hhe:

; 2786 :             return NULL;
; 2787 :          c->next = hh->head;

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rcx], rax

; 2788 :          hh->head = c;
; 2789 :          hh->num_remaining_in_head_chunk = count;

	mov	eax, 800				; 00000320H
	mov	QWORD PTR [rbx], rcx
$LN17@stbtt__hhe:

; 2790 :       }
; 2791 :       --hh->num_remaining_in_head_chunk;

	dec	eax

; 2792 :       return (char *) (hh->head) + sizeof(stbtt__hheap_chunk) + size * hh->num_remaining_in_head_chunk;

	movsxd	rcx, eax
	mov	DWORD PTR [rbx+16], eax
	mov	rax, QWORD PTR [rbx]
	add	rax, 8
	shl	rcx, 5
	add	rax, rcx

; 2793 :    }
; 2794 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?stbtt__hheap_alloc@@YAPEAXPEAUstbtt__hheap@@_KPEAX@Z ENDP ; stbtt__hheap_alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__hheap_free@@YAXPEAUstbtt__hheap@@PEAX@Z
_TEXT	SEGMENT
hh$ = 8
p$ = 16
?stbtt__hheap_free@@YAXPEAUstbtt__hheap@@PEAX@Z PROC	; stbtt__hheap_free, COMDAT

; 2798 :    *(void **) p = hh->first_free;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rdx], rax

; 2799 :    hh->first_free = p;

	mov	QWORD PTR [rcx+8], rdx

; 2800 : }

	ret	0
?stbtt__hheap_free@@YAXPEAUstbtt__hheap@@PEAX@Z ENDP	; stbtt__hheap_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z
_TEXT	SEGMENT
hh$ = 48
userdata$dead$ = 56
?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z PROC	; stbtt__hheap_cleanup, COMDAT

; 2803 : {

	sub	rsp, 40					; 00000028H

; 2804 :    stbtt__hheap_chunk *c = hh->head;

	mov	rcx, QWORD PTR [rcx]

; 2805 :    while (c) {

	test	rcx, rcx
	je	SHORT $LN3@stbtt__hhe
	mov	QWORD PTR [rsp+32], rbx
$LL2@stbtt__hhe:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 2806 :       stbtt__hheap_chunk *n = c->next;

	mov	rbx, QWORD PTR [rcx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN7@stbtt__hhe

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN7@stbtt__hhe:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 2808 :       c = n;

	mov	rcx, rbx
	test	rbx, rbx
	jne	SHORT $LL2@stbtt__hhe

; 2805 :    while (c) {

	mov	rbx, QWORD PTR [rsp+32]
$LN3@stbtt__hhe:

; 2809 :    }
; 2810 : }

	add	rsp, 40					; 00000028H
	ret	0
?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z ENDP	; stbtt__hheap_cleanup
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__new_active@@YAPEAUstbtt__active_edge@@PEAUstbtt__hheap@@PEAUstbtt__edge@@HMPEAX@Z
_TEXT	SEGMENT
hh$ = 64
e$ = 72
off_x$ = 80
start_point$ = 88
userdata$dead$ = 96
?stbtt__new_active@@YAPEAUstbtt__active_edge@@PEAUstbtt__hheap@@PEAUstbtt__edge@@HMPEAX@Z PROC ; stbtt__new_active, COMDAT

; 2863 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 48					; 00000030H

; 2777 :    if (hh->first_free) {

	mov	r9, QWORD PTR [rcx+8]

; 2863 : {

	mov	esi, r8d
	movaps	XMMWORD PTR [rsp+32], xmm6
	movaps	xmm6, xmm3
	mov	rdi, rdx
	mov	rbx, rcx

; 2777 :    if (hh->first_free) {

	test	r9, r9
	je	SHORT $LN12@stbtt__new

; 2778 :       void *p = hh->first_free;
; 2779 :       hh->first_free = * (void **) p;

	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [rcx+8], rax

; 2780 :       return p;

	jmp	SHORT $LN13@stbtt__new
$LN12@stbtt__new:

; 2781 :    } else {
; 2782 :       if (hh->num_remaining_in_head_chunk == 0) {

	mov	eax, DWORD PTR [rcx+16]
	test	eax, eax
	jne	SHORT $LN27@stbtt__new
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN20@stbtt__new

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN20@stbtt__new:

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	mov	ecx, 25608				; 00006408H
	call	QWORD PTR __imp_malloc
	mov	rcx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 2785 :          if (c == NULL)

	test	rax, rax
	jne	SHORT $LN15@stbtt__new

; 2786 :             return NULL;

	xor	r9d, r9d
	jmp	SHORT $LN13@stbtt__new
$LN15@stbtt__new:

; 2787 :          c->next = hh->head;

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rcx], rax

; 2788 :          hh->head = c;
; 2789 :          hh->num_remaining_in_head_chunk = count;

	mov	eax, 800				; 00000320H
	mov	QWORD PTR [rbx], rcx
$LN27@stbtt__new:

; 2790 :       }
; 2791 :       --hh->num_remaining_in_head_chunk;
; 2792 :       return (char *) (hh->head) + sizeof(stbtt__hheap_chunk) + size * hh->num_remaining_in_head_chunk;

	mov	r9, QWORD PTR [rbx]
	dec	eax
	movsxd	rcx, eax
	add	r9, 8
	shl	rcx, 5
	add	r9, rcx
	mov	DWORD PTR [rbx+16], eax
$LN13@stbtt__new:

; 2864 :    stbtt__active_edge *z = (stbtt__active_edge *) stbtt__hheap_alloc(hh, sizeof(*z), userdata);
; 2865 :    float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);

	movss	xmm1, DWORD PTR [rdi+8]
	movss	xmm0, DWORD PTR [rdi+12]
	subss	xmm1, DWORD PTR [rdi]
	subss	xmm0, DWORD PTR [rdi+4]
	divss	xmm1, xmm0

; 2866 :    STBTT_assert(z != NULL);
; 2867 :    //STBTT_assert(e->y0 <= start_point);
; 2868 :    if (!z) return z;

	test	r9, r9
	jne	SHORT $LN5@stbtt__new
	xor	eax, eax
	jmp	SHORT $LN1@stbtt__new
$LN5@stbtt__new:

; 2869 :    z->fdx = dxdy;
; 2870 :    z->fdy = dxdy != 0.0f ? (1.0f/dxdy) : 0.0f;

	movss	xmm2, DWORD PTR __real@3f800000
	xorps	xmm0, xmm0
	ucomiss	xmm1, xmm0
	movss	DWORD PTR [r9+12], xmm1
	jp	SHORT $LN28@stbtt__new
	je	SHORT $LN8@stbtt__new
$LN28@stbtt__new:
	movaps	xmm0, xmm2
	divss	xmm0, xmm1
$LN8@stbtt__new:
	movss	DWORD PTR [r9+16], xmm0

; 2871 :    z->fx = e->x0 + dxdy * (start_point - e->y0);

	subss	xmm6, DWORD PTR [rdi+4]
	movd	xmm0, esi

; 2872 :    z->fx -= off_x;

	cvtdq2ps xmm0, xmm0
	mulss	xmm6, xmm1
	addss	xmm6, DWORD PTR [rdi]
	subss	xmm6, xmm0
	movss	DWORD PTR [r9+8], xmm6

; 2873 :    z->direction = e->invert ? 1.0f : -1.0f;

	cmp	DWORD PTR [rdi+16], 0
	jne	SHORT $LN10@stbtt__new
	movss	xmm2, DWORD PTR __real@bf800000
$LN10@stbtt__new:
	movss	DWORD PTR [r9+20], xmm2

; 2874 :    z->sy = e->y0;
; 2875 :    z->ey = e->y1;
; 2876 :    z->next = 0;
; 2877 :    return z;

	mov	rax, r9
	mov	ecx, DWORD PTR [rdi+4]
	mov	DWORD PTR [r9+24], ecx
	mov	ecx, DWORD PTR [rdi+12]
	mov	DWORD PTR [r9+28], ecx
	mov	QWORD PTR [r9], 0
$LN1@stbtt__new:

; 2878 : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	movaps	xmm6, XMMWORD PTR [rsp+32]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?stbtt__new_active@@YAPEAUstbtt__active_edge@@PEAUstbtt__hheap@@PEAUstbtt__edge@@HMPEAX@Z ENDP ; stbtt__new_active
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z
_TEXT	SEGMENT
scanline$ = 64
x$ = 72
e$ = 80
x0$ = 88
y0$ = 96
x1$ = 104
y1$ = 112
?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z PROC ; stbtt__handle_clipped_edge, COMDAT

; 3034 : {

	sub	rsp, 56					; 00000038H

; 3035 :    if (y0 == y1) return;

	movss	xmm5, DWORD PTR y0$[rsp]
	movss	xmm4, DWORD PTR y1$[rsp]
	ucomiss	xmm5, xmm4
	jp	SHORT $LN44@stbtt__han
	je	$LN42@stbtt__han
$LN44@stbtt__han:
	movaps	XMMWORD PTR [rsp+16], xmm7

; 3036 :    STBTT_assert(y0 < y1);
; 3037 :    STBTT_assert(e->sy <= e->ey);
; 3038 :    if (y0 > e->ey) return;

	movss	xmm7, DWORD PTR [r8+28]
	comiss	xmm5, xmm7
	ja	$LN53@stbtt__han
	movaps	XMMWORD PTR [rsp], xmm8

; 3039 :    if (y1 < e->sy) return;

	movss	xmm8, DWORD PTR [r8+24]
	comiss	xmm8, xmm4
	ja	$LN54@stbtt__han

; 3040 :    if (y0 < e->sy) {

	comiss	xmm8, xmm5
	movaps	XMMWORD PTR [rsp+32], xmm6
	movss	xmm6, DWORD PTR x1$[rsp]
	jbe	SHORT $LN29@stbtt__han

; 3041 :       x0 += (x1-x0) * (e->sy - y0) / (y1-y0);

	movaps	xmm2, xmm8
	movaps	xmm0, xmm6
	subss	xmm2, xmm5
	movaps	xmm1, xmm4
	subss	xmm0, xmm3
	subss	xmm1, xmm5

; 3042 :       y0 = e->sy;

	movaps	xmm5, xmm8
	mulss	xmm2, xmm0
	divss	xmm2, xmm1
	addss	xmm3, xmm2
$LN29@stbtt__han:

; 3043 :    }
; 3044 :    if (y1 > e->ey) {

	comiss	xmm4, xmm7
	jbe	SHORT $LN21@stbtt__han

; 3045 :       x1 += (x1-x0) * (e->ey - y1) / (y1-y0);

	movaps	xmm0, xmm6
	movaps	xmm1, xmm7
	subss	xmm1, xmm4
	subss	xmm4, xmm5
	subss	xmm0, xmm3
	mulss	xmm1, xmm0
	divss	xmm1, xmm4

; 3046 :       y1 = e->ey;

	movaps	xmm4, xmm7
	addss	xmm6, xmm1
$LN21@stbtt__han:

; 3047 :    }
; 3048 : 
; 3049 :    if (x0 == x)
; 3050 :       STBTT_assert(x1 <= x+1);
; 3051 :    else if (x0 == x+1)
; 3052 :       STBTT_assert(x1 >= x);
; 3053 :    else if (x0 <= x)
; 3054 :       STBTT_assert(x1 <= x);
; 3055 :    else if (x0 >= x+1)
; 3056 :       STBTT_assert(x1 >= x+1);
; 3057 :    else
; 3058 :       STBTT_assert(x1 >= x && x1 <= x+1);
; 3059 : 
; 3060 :    if (x0 <= x && x1 <= x)

	movd	xmm0, edx
	cvtdq2ps xmm0, xmm0
	comiss	xmm0, xmm3
	jb	SHORT $LN39@stbtt__han
	comiss	xmm0, xmm6
	jb	SHORT $LN39@stbtt__han

; 3061 :       scanline[x] += e->direction * (y1-y0);

	movaps	xmm6, XMMWORD PTR [rsp+32]
	subss	xmm4, xmm5
	movaps	xmm8, XMMWORD PTR [rsp]
	movaps	xmm7, XMMWORD PTR [rsp+16]
	movsxd	rax, edx
	mulss	xmm4, DWORD PTR [r8+20]
	addss	xmm4, DWORD PTR [rcx+rax*4]
	movss	DWORD PTR [rcx+rax*4], xmm4

; 3067 :    }
; 3068 : }

	add	rsp, 56					; 00000038H
	ret	0
$LN39@stbtt__han:

; 3062 :    else if (x0 >= x+1 && x1 >= x+1)

	lea	eax, DWORD PTR [rdx+1]
	movd	xmm1, eax
	cvtdq2ps xmm1, xmm1
	comiss	xmm3, xmm1
	jb	SHORT $LN25@stbtt__han
	comiss	xmm6, xmm1
	jae	SHORT $LN55@stbtt__han
$LN25@stbtt__han:

; 3063 :       ;
; 3064 :    else {
; 3065 :       STBTT_assert(x0 >= x && x0 <= x+1 && x1 >= x && x1 <= x+1);
; 3066 :       scanline[x] += e->direction * (y1-y0) * (1-((x0-x)+(x1-x))/2); // coverage = 1 - average x position

	subss	xmm3, xmm0
	movsxd	rax, edx
	subss	xmm6, xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm4, xmm5
	addss	xmm3, xmm6
	mulss	xmm4, DWORD PTR [r8+20]
	mulss	xmm3, DWORD PTR __real@3f000000
	subss	xmm0, xmm3
	mulss	xmm0, xmm4
	addss	xmm0, DWORD PTR [rcx+rax*4]
	movss	DWORD PTR [rcx+rax*4], xmm0
$LN55@stbtt__han:
	movaps	xmm6, XMMWORD PTR [rsp+32]
$LN54@stbtt__han:
	movaps	xmm8, XMMWORD PTR [rsp]
$LN53@stbtt__han:
	movaps	xmm7, XMMWORD PTR [rsp+16]
$LN42@stbtt__han:

; 3067 :    }
; 3068 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ENDP ; stbtt__handle_clipped_edge
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__sized_trapezoid_area@@YAMMMM@Z
_TEXT	SEGMENT
height$ = 8
top_width$ = 16
bottom_width$ = 24
?stbtt__sized_trapezoid_area@@YAMMMM@Z PROC		; stbtt__sized_trapezoid_area, COMDAT

; 3072 :    STBTT_assert(top_width >= 0);
; 3073 :    STBTT_assert(bottom_width >= 0);
; 3074 :    return (top_width + bottom_width) / 2.0f * height;

	addss	xmm1, xmm2
	mulss	xmm1, DWORD PTR __real@3f000000
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1

; 3075 : }

	ret	0
?stbtt__sized_trapezoid_area@@YAMMMM@Z ENDP		; stbtt__sized_trapezoid_area
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__position_trapezoid_area@@YAMMMMMM@Z
_TEXT	SEGMENT
height$ = 8
tx0$ = 16
tx1$ = 24
bx0$ = 32
bx1$ = 40
?stbtt__position_trapezoid_area@@YAMMMMMM@Z PROC	; stbtt__position_trapezoid_area, COMDAT

; 3079 :    return stbtt__sized_trapezoid_area(height, tx1 - tx0, bx1 - bx0);

	subss	xmm2, xmm1
	movss	xmm1, DWORD PTR bx1$[rsp]
	subss	xmm1, xmm3

; 3074 :    return (top_width + bottom_width) / 2.0f * height;

	addss	xmm2, xmm1
	mulss	xmm2, DWORD PTR __real@3f000000
	mulss	xmm2, xmm0

; 3079 :    return stbtt__sized_trapezoid_area(height, tx1 - tx0, bx1 - bx0);

	movaps	xmm0, xmm2

; 3080 : }

	ret	0
?stbtt__position_trapezoid_area@@YAMMMMMM@Z ENDP	; stbtt__position_trapezoid_area
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__sized_triangle_area@@YAMMM@Z
_TEXT	SEGMENT
height$ = 8
width$ = 16
?stbtt__sized_triangle_area@@YAMMM@Z PROC		; stbtt__sized_triangle_area, COMDAT

; 3084 :    return height * width / 2;

	mulss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@3f000000

; 3085 : }

	ret	0
?stbtt__sized_triangle_area@@YAMMM@Z ENDP		; stbtt__sized_triangle_area
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z
_TEXT	SEGMENT
scanline$ = 240
scanline_fill$ = 248
len$ = 256
e$ = 264
y_top$ = 272
?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z PROC ; stbtt__fill_active_edges_new, COMDAT

; 3090 : 
; 3091 :    while (e) {

	test	r9, r9
	je	$LN146@stbtt__fil
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	push	rdi
	sub	rsp, 224				; 000000e0H

; 3089 :    float y_bottom = y_top+1;

	movss	xmm1, DWORD PTR __real@3f800000
	mov	ebx, r8d
	movaps	XMMWORD PTR [rax-104], xmm11
	mov	rdi, rdx
	movss	xmm11, DWORD PTR y_top$[rsp]
	mov	r10, rcx
	movaps	XMMWORD PTR [rsp+80], xmm14
	movaps	xmm14, xmm11

; 3090 : 
; 3091 :    while (e) {

	movaps	XMMWORD PTR [rax-24], xmm6
	addss	xmm14, xmm1
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	XMMWORD PTR [rax-56], xmm8
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-120], xmm12
	movaps	XMMWORD PTR [rsp+96], xmm13
	movaps	XMMWORD PTR [rsp+64], xmm15
	xorps	xmm15, xmm15
	npad	13
$LL2@stbtt__fil:

; 3092 :       // brute force every pixel
; 3093 : 
; 3094 :       // compute intersection points with top & bottom
; 3095 :       STBTT_assert(e->ey >= y_top);
; 3096 : 
; 3097 :       if (e->fdx == 0) {

	movss	xmm13, DWORD PTR [r9+12]
	ucomiss	xmm13, xmm15
	movss	xmm7, DWORD PTR [r9+8]
	jp	SHORT $LN31@stbtt__fil
	jne	SHORT $LN31@stbtt__fil

; 3098 :          float x0 = e->fx;
; 3099 :          if (x0 < len) {

	movd	xmm0, ebx
	cvtdq2ps xmm0, xmm0
	comiss	xmm0, xmm7
	jbe	$LN29@stbtt__fil

; 3100 :             if (x0 >= 0) {

	comiss	xmm7, xmm15
	mov	r8, r9
	movss	DWORD PTR [rsp+48], xmm14
	movaps	xmm3, xmm7
	movss	DWORD PTR [rsp+40], xmm7
	movss	DWORD PTR [rsp+32], xmm11
	jb	SHORT $LN34@stbtt__fil

; 3101 :                stbtt__handle_clipped_edge(scanline,(int) x0,e, x0,y_top, x0,y_bottom);

	cvttss2si edx, xmm7
	mov	rcx, r10
	call	?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge

; 3102 :                stbtt__handle_clipped_edge(scanline_fill-1,(int) x0+1,e, x0,y_top, x0,y_bottom);

	movss	DWORD PTR [rsp+48], xmm14
	lea	rcx, QWORD PTR [rdi-4]
	movss	DWORD PTR [rsp+40], xmm7
	inc	edx
	movaps	xmm3, xmm7
	movss	DWORD PTR [rsp+32], xmm11
	call	?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge

; 3103 :             } else {

	jmp	$LN147@stbtt__fil
$LN34@stbtt__fil:

; 3104 :                stbtt__handle_clipped_edge(scanline_fill-1,0,e, x0,y_top, x0,y_bottom);

	lea	rcx, QWORD PTR [rdi-4]
	xor	edx, edx
	call	?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge

; 3105 :             }
; 3106 :          }
; 3107 :       } else {

	jmp	$LN147@stbtt__fil
$LN31@stbtt__fil:

; 3108 :          float x0 = e->fx;
; 3109 :          float dx = e->fdx;
; 3110 :          float xb = x0 + dx;
; 3111 :          float x_top, x_bottom;
; 3112 :          float sy0,sy1;
; 3113 :          float dy = e->fdy;
; 3114 :          STBTT_assert(e->sy <= y_bottom && e->ey >= y_top);
; 3115 : 
; 3116 :          // compute endpoints of line segment clipped to this scanline (if the
; 3117 :          // line segment starts on this scanline. x0 is the intersection of the
; 3118 :          // line with y_top, but that may be off the line segment.
; 3119 :          if (e->sy > y_top) {

	movss	xmm9, DWORD PTR [r9+24]
	movaps	xmm12, xmm13
	comiss	xmm9, xmm11
	movss	xmm8, DWORD PTR [r9+16]
	addss	xmm12, xmm7
	jbe	SHORT $LN36@stbtt__fil

; 3120 :             x_top = x0 + dx * (e->sy - y_top);

	movaps	xmm3, xmm9
	subss	xmm3, xmm11
	mulss	xmm3, xmm13
	addss	xmm3, xmm7

; 3121 :             sy0 = e->sy;
; 3122 :          } else {

	jmp	SHORT $LN37@stbtt__fil
$LN36@stbtt__fil:

; 3123 :             x_top = x0;

	movaps	xmm3, xmm7

; 3124 :             sy0 = y_top;

	movaps	xmm9, xmm11
$LN37@stbtt__fil:

; 3125 :          }
; 3126 :          if (e->ey < y_bottom) {

	movss	xmm6, DWORD PTR [r9+28]
	comiss	xmm14, xmm6
	jbe	SHORT $LN38@stbtt__fil

; 3127 :             x_bottom = x0 + dx * (e->ey - y_top);

	movaps	xmm5, xmm6
	subss	xmm5, xmm11
	mulss	xmm5, xmm13
	addss	xmm5, xmm7

; 3128 :             sy1 = e->ey;
; 3129 :          } else {

	jmp	SHORT $LN39@stbtt__fil
$LN38@stbtt__fil:

; 3130 :             x_bottom = xb;

	movaps	xmm5, xmm12

; 3131 :             sy1 = y_bottom;

	movaps	xmm6, xmm14
$LN39@stbtt__fil:

; 3132 :          }
; 3133 : 
; 3134 :          if (x_top >= 0 && x_bottom >= 0 && x_top < len && x_bottom < len) {

	comiss	xmm3, xmm15
	jb	$LN40@stbtt__fil
	comiss	xmm5, xmm15
	jb	$LN40@stbtt__fil
	movd	xmm0, ebx
	cvtdq2ps xmm0, xmm0
	comiss	xmm0, xmm3
	jbe	$LN40@stbtt__fil
	comiss	xmm0, xmm5
	jbe	$LN40@stbtt__fil

; 3135 :             // from here on, we don't have to range check x values
; 3136 : 
; 3137 :             if ((int) x_top == (int) x_bottom) {

	cvttss2si ecx, xmm3
	cvttss2si eax, xmm5
	cmp	ecx, eax
	jne	SHORT $LN42@stbtt__fil

; 3138 :                float height;
; 3139 :                // simple case, only spans one pixel
; 3140 :                int x = (int) x_top;
; 3141 :                height = (sy1 - sy0) * e->direction;
; 3142 :                STBTT_assert(x >= 0 && x < len);
; 3143 :                scanline[x]      += stbtt__position_trapezoid_area(height, x_top, x+1.0f, x_bottom, x+1.0f);

	xorps	xmm0, xmm0
	movsxd	rax, ecx
	cvtsi2ss xmm0, ecx
	subss	xmm6, xmm9
	addss	xmm0, xmm1
	mulss	xmm6, DWORD PTR [r9+20]

; 3079 :    return stbtt__sized_trapezoid_area(height, tx1 - tx0, bx1 - bx0);

	movaps	xmm1, xmm0
	subss	xmm0, xmm3
	subss	xmm1, xmm5

; 3074 :    return (top_width + bottom_width) / 2.0f * height;

	addss	xmm1, xmm0
	mulss	xmm1, DWORD PTR __real@3f000000
	mulss	xmm1, xmm6

; 3138 :                float height;
; 3139 :                // simple case, only spans one pixel
; 3140 :                int x = (int) x_top;
; 3141 :                height = (sy1 - sy0) * e->direction;
; 3142 :                STBTT_assert(x >= 0 && x < len);
; 3143 :                scanline[x]      += stbtt__position_trapezoid_area(height, x_top, x+1.0f, x_bottom, x+1.0f);

	addss	xmm1, DWORD PTR [r10+rax*4]
	movss	DWORD PTR [r10+rax*4], xmm1

; 3144 :                scanline_fill[x] += height; // everything right of this pixel is filled

	addss	xmm6, DWORD PTR [rdi+rax*4]
	movss	DWORD PTR [rdi+rax*4], xmm6

; 3145 :             } else {

	jmp	$LN147@stbtt__fil
$LN42@stbtt__fil:

; 3146 :                int x,x1,x2;
; 3147 :                float y_crossing, y_final, step, sign, area;
; 3148 :                // covers 2+ pixels
; 3149 :                if (x_top > x_bottom) {

	comiss	xmm3, xmm5
	jbe	SHORT $LN15@stbtt__fil

; 3150 :                   // flip scanline vertically; signed area is the same
; 3151 :                   float t;
; 3152 :                   sy0 = y_bottom - (sy0 - y_top);
; 3153 :                   sy1 = y_bottom - (sy1 - y_top);
; 3154 :                   t = sy0, sy0 = sy1, sy1 = t;
; 3155 :                   t = x_bottom, x_bottom = x_top, x_top = t;
; 3156 :                   dx = -dx;
; 3157 :                   dy = -dy;

	xorps	xmm8, DWORD PTR __xmm@80000000800000008000000080000000
	subss	xmm9, xmm11
	movaps	xmm0, xmm14
	subss	xmm6, xmm11

; 3158 :                   t = x0, x0 = xb, xb = t;

	movaps	xmm7, xmm12
	subss	xmm0, xmm9
	movaps	xmm9, xmm14
	subss	xmm9, xmm6
	movaps	xmm6, xmm0
	movaps	xmm0, xmm5
	movaps	xmm5, xmm3
	movaps	xmm3, xmm0
$LN15@stbtt__fil:

; 3084 :    return height * width / 2;

	movss	xmm13, DWORD PTR __real@3f000000
	xorps	xmm1, xmm1

; 3159 :                }
; 3160 :                STBTT_assert(dy >= 0);
; 3161 :                STBTT_assert(dx >= 0);
; 3162 : 
; 3163 :                x1 = (int) x_top;

	cvttss2si ecx, xmm3

; 3164 :                x2 = (int) x_bottom;
; 3165 :                // compute intersection with y axis at x1+1
; 3166 :                y_crossing = y_top + dy * (x1+1 - x0);
; 3167 : 
; 3168 :                // compute intersection with y axis at x2
; 3169 :                y_final = y_top + dy * (x2 - x0);
; 3170 : 
; 3171 :                //           x1    x_top                            x2    x_bottom
; 3172 :                //     y_top  +------|-----+------------+------------+--------|---+------------+
; 3173 :                //            |            |            |            |            |            |
; 3174 :                //            |            |            |            |            |            |
; 3175 :                //       sy0  |      Txxxxx|............|............|............|............|
; 3176 :                // y_crossing |            *xxxxx.......|............|............|............|
; 3177 :                //            |            |     xxxxx..|............|............|............|
; 3178 :                //            |            |     /-   xx*xxxx........|............|............|
; 3179 :                //            |            | dy <       |    xxxxxx..|............|............|
; 3180 :                //   y_final  |            |     \-     |          xx*xxx.........|............|
; 3181 :                //       sy1  |            |            |            |   xxxxxB...|............|
; 3182 :                //            |            |            |            |            |            |
; 3183 :                //            |            |            |            |            |            |
; 3184 :                //  y_bottom  +------------+------------+------------+------------+------------+
; 3185 :                //
; 3186 :                // goal is to measure the area covered by '.' in each pixel
; 3187 : 
; 3188 :                // if x2 is right at the right edge of x1, y_crossing can blow up, github #1057
; 3189 :                // @TODO: maybe test against sy1 rather than y_bottom?
; 3190 :                if (y_crossing > y_bottom)

	movaps	xmm4, xmm14
	xorps	xmm12, xmm12
	cvttss2si edx, xmm5

; 3191 :                   y_crossing = y_bottom;
; 3192 : 
; 3193 :                sign = e->direction;
; 3194 : 
; 3195 :                // area of the rectangle covered from sy0..y_crossing
; 3196 :                area = sign * (y_crossing-sy0);
; 3197 : 
; 3198 :                // area of the triangle (x_top,sy0), (x1+1,sy0), (x1+1,y_crossing)
; 3199 :                scanline[x1] += stbtt__sized_triangle_area(area, x1+1 - x_top);

	movsxd	rax, ecx
	lea	r8d, DWORD PTR [rcx+1]
	cvtsi2ss xmm1, r8d
	cvtsi2ss xmm12, edx
	movaps	xmm0, xmm1
	subss	xmm1, xmm3
	subss	xmm0, xmm7
	movaps	xmm10, xmm12
	subss	xmm10, xmm7
	movss	xmm7, DWORD PTR [r9+20]
	mulss	xmm0, xmm8
	mulss	xmm10, xmm8
	addss	xmm0, xmm11
	addss	xmm10, xmm11
	minss	xmm4, xmm0

; 3200 : 
; 3201 :                // check if final y_crossing is blown up; no test case for this
; 3202 :                if (y_final > y_bottom) {

	comiss	xmm10, xmm14
	movaps	xmm2, xmm4
	subss	xmm2, xmm9
	mulss	xmm2, xmm7

; 3084 :    return height * width / 2;

	mulss	xmm1, xmm2
	mulss	xmm1, xmm13

; 3191 :                   y_crossing = y_bottom;
; 3192 : 
; 3193 :                sign = e->direction;
; 3194 : 
; 3195 :                // area of the rectangle covered from sy0..y_crossing
; 3196 :                area = sign * (y_crossing-sy0);
; 3197 : 
; 3198 :                // area of the triangle (x_top,sy0), (x1+1,sy0), (x1+1,y_crossing)
; 3199 :                scanline[x1] += stbtt__sized_triangle_area(area, x1+1 - x_top);

	addss	xmm1, DWORD PTR [r10+rax*4]
	movss	DWORD PTR [r10+rax*4], xmm1

; 3200 : 
; 3201 :                // check if final y_crossing is blown up; no test case for this
; 3202 :                if (y_final > y_bottom) {

	jbe	SHORT $LN47@stbtt__fil

; 3203 :                   int denom = (x2 - (x1+1));

	mov	eax, edx

; 3204 :                   y_final = y_bottom;

	movaps	xmm10, xmm14
	sub	eax, ecx
	sub	eax, 1

; 3205 :                   if (denom != 0) { // [DEAR IMGUI] Avoid div by zero (https://github.com/nothings/stb/issues/1316)

	je	SHORT $LN47@stbtt__fil

; 3206 :                      dy = (y_final - y_crossing ) / denom; // if denom=0, y_final = y_crossing, so y_final <= y_bottom

	movd	xmm0, eax
	movaps	xmm8, xmm14
	cvtdq2ps xmm0, xmm0
	subss	xmm8, xmm4
	divss	xmm8, xmm0
$LN47@stbtt__fil:

; 3207 :                   }
; 3208 :                }
; 3209 : 
; 3210 :                // in second pixel, area covered by line segment found in first pixel
; 3211 :                // is always a rectangle 1 wide * the height of that line segment; this
; 3212 :                // is exactly what the variable 'area' stores. it also gets a contribution
; 3213 :                // from the line segment within it. the THIRD pixel will get the first
; 3214 :                // pixel's rectangle contribution, the second pixel's rectangle contribution,
; 3215 :                // and its own contribution. the 'own contribution' is the same in every pixel except
; 3216 :                // the leftmost and rightmost, a trapezoid that slides down in each pixel.
; 3217 :                // the second pixel's contribution to the third pixel will be the
; 3218 :                // rectangle 1 wide times the height change in the second pixel, which is dy.
; 3219 : 
; 3220 :                step = sign * dy * 1; // dy is dy/dx, change in y for every 1 change in x,

	movsxd	rcx, r8d
	movaps	xmm4, xmm7

; 3221 :                // which multiplied by 1-pixel-width is how much pixel area changes for each step in x
; 3222 :                // so the area advances by 'step' every time
; 3223 : 
; 3224 :                for (x = x1+1; x < x2; ++x) {

	movsxd	r8, edx
	mulss	xmm4, xmm8
	cmp	rcx, r8
	jge	$LN24@stbtt__fil
	mov	rax, r8
	movaps	xmm3, xmm4
	sub	rax, rcx
	mulss	xmm3, xmm13
	cmp	rax, 4
	jl	$LL97@stbtt__fil
	mov	rdx, r8
	lea	rax, QWORD PTR [r10+8]
	sub	rdx, rcx
	lea	rax, QWORD PTR [rax+rcx*4]
	sub	rdx, 4
	shr	rdx, 2
	inc	rdx
	lea	rcx, QWORD PTR [rcx+rdx*4]
	npad	7
$LL96@stbtt__fil:

; 3225 :                   scanline[x] += area + step/2; // area of trapezoid is 1*step/2

	movaps	xmm0, xmm3
	movaps	xmm1, xmm3
	addss	xmm0, xmm2

; 3226 :                   area += step;

	addss	xmm2, xmm4
	addss	xmm0, DWORD PTR [rax-8]
	movss	DWORD PTR [rax-8], xmm0
	movaps	xmm0, xmm3
	addss	xmm0, xmm2
	addss	xmm2, xmm4
	addss	xmm0, DWORD PTR [rax-4]
	addss	xmm1, xmm2
	addss	xmm2, xmm4
	movss	DWORD PTR [rax-4], xmm0
	movaps	xmm0, xmm3
	addss	xmm1, DWORD PTR [rax]
	addss	xmm0, xmm2
	addss	xmm2, xmm4
	movss	DWORD PTR [rax], xmm1
	addss	xmm0, DWORD PTR [rax+4]
	movss	DWORD PTR [rax+4], xmm0
	add	rax, 16
	sub	rdx, 1
	jne	SHORT $LL96@stbtt__fil

; 3221 :                // which multiplied by 1-pixel-width is how much pixel area changes for each step in x
; 3222 :                // so the area advances by 'step' every time
; 3223 : 
; 3224 :                for (x = x1+1; x < x2; ++x) {

	cmp	rcx, r8
	jge	SHORT $LN24@stbtt__fil
$LL97@stbtt__fil:

; 3225 :                   scanline[x] += area + step/2; // area of trapezoid is 1*step/2

	movaps	xmm0, xmm3
	addss	xmm0, xmm2

; 3226 :                   area += step;

	addss	xmm2, xmm4
	addss	xmm0, DWORD PTR [r10+rcx*4]
	movss	DWORD PTR [r10+rcx*4], xmm0
	inc	rcx
	cmp	rcx, r8
	jl	SHORT $LL97@stbtt__fil
$LN24@stbtt__fil:

; 3227 :                }
; 3228 :                STBTT_assert(STBTT_fabs(area) <= 1.01f); // accumulated error from area += step unless we round step down
; 3229 :                STBTT_assert(sy1 > y_final-0.01f);
; 3230 : 
; 3231 :                // area covered in the last pixel is the rectangle from all the pixels to the left,
; 3232 :                // plus the trapezoid filled by the line segment in this pixel all the way to the right edge
; 3233 :                scanline[x2] += area + sign * stbtt__position_trapezoid_area(sy1-y_final, (float) x2, x2+1.0f, x_bottom, x2+1.0f);

	movaps	xmm0, xmm12
	addss	xmm0, DWORD PTR __real@3f800000

; 3079 :    return stbtt__sized_trapezoid_area(height, tx1 - tx0, bx1 - bx0);

	movaps	xmm1, xmm0
	subss	xmm0, xmm5
	subss	xmm1, xmm12

; 3074 :    return (top_width + bottom_width) / 2.0f * height;

	addss	xmm1, xmm0

; 3227 :                }
; 3228 :                STBTT_assert(STBTT_fabs(area) <= 1.01f); // accumulated error from area += step unless we round step down
; 3229 :                STBTT_assert(sy1 > y_final-0.01f);
; 3230 : 
; 3231 :                // area covered in the last pixel is the rectangle from all the pixels to the left,
; 3232 :                // plus the trapezoid filled by the line segment in this pixel all the way to the right edge
; 3233 :                scanline[x2] += area + sign * stbtt__position_trapezoid_area(sy1-y_final, (float) x2, x2+1.0f, x_bottom, x2+1.0f);

	movaps	xmm0, xmm6

; 3234 : 
; 3235 :                // the rest of the line is filled based on the total height of the line segment in this pixel
; 3236 :                scanline_fill[x2] += sign * (sy1-sy0);

	subss	xmm6, xmm9
	subss	xmm0, xmm10

; 3074 :    return (top_width + bottom_width) / 2.0f * height;

	mulss	xmm1, xmm13

; 3234 : 
; 3235 :                // the rest of the line is filled based on the total height of the line segment in this pixel
; 3236 :                scanline_fill[x2] += sign * (sy1-sy0);

	mulss	xmm6, xmm7

; 3074 :    return (top_width + bottom_width) / 2.0f * height;

	mulss	xmm1, xmm0

; 3227 :                }
; 3228 :                STBTT_assert(STBTT_fabs(area) <= 1.01f); // accumulated error from area += step unless we round step down
; 3229 :                STBTT_assert(sy1 > y_final-0.01f);
; 3230 : 
; 3231 :                // area covered in the last pixel is the rectangle from all the pixels to the left,
; 3232 :                // plus the trapezoid filled by the line segment in this pixel all the way to the right edge
; 3233 :                scanline[x2] += area + sign * stbtt__position_trapezoid_area(sy1-y_final, (float) x2, x2+1.0f, x_bottom, x2+1.0f);

	mulss	xmm1, xmm7
	addss	xmm1, xmm2
	addss	xmm1, DWORD PTR [r10+r8*4]
	movss	DWORD PTR [r10+r8*4], xmm1

; 3234 : 
; 3235 :                // the rest of the line is filled based on the total height of the line segment in this pixel
; 3236 :                scanline_fill[x2] += sign * (sy1-sy0);

	addss	xmm6, DWORD PTR [rdi+r8*4]
	movss	DWORD PTR [rdi+r8*4], xmm6

; 3237 :             }
; 3238 :          } else {

	jmp	$LN147@stbtt__fil
$LN40@stbtt__fil:

; 3239 :             // if edge goes outside of box we're drawing, we require
; 3240 :             // clipping logic. since this does not match the intended use
; 3241 :             // of this library, we use a different, very slow brute
; 3242 :             // force implementation
; 3243 :             // note though that this does happen some of the time because
; 3244 :             // x_top and x_bottom can be extrapolated at the top & bottom of
; 3245 :             // the shape and actually lie outside the bounding box
; 3246 :             int x;
; 3247 :             for (x=0; x < len; ++x) {

	xor	edx, edx
	test	ebx, ebx
	jle	$LN29@stbtt__fil
	npad	11
$LL30@stbtt__fil:
	xorps	xmm9, xmm9

; 3248 :                // cases:
; 3249 :                //
; 3250 :                // there can be up to two intersections with the pixel. any intersection
; 3251 :                // with left or right edges can be handled by splitting into two (or three)
; 3252 :                // regions. intersections with top & bottom do not necessitate case-wise logic.
; 3253 :                //
; 3254 :                // the old way of doing this found the intersections with the left & right edges,
; 3255 :                // then used some simple logic to produce up to three segments in sorted order
; 3256 :                // from top-to-bottom. however, this had a problem: if an x edge was epsilon
; 3257 :                // across the x border, then the corresponding y position might not be distinct
; 3258 :                // from the other y segment, and it might ignored as an empty segment. to avoid
; 3259 :                // that, we need to explicitly produce segments based on x positions.
; 3260 : 
; 3261 :                // rename variables to clearly-defined pairs
; 3262 :                float y0 = y_top;
; 3263 :                float x1 = (float) (x);
; 3264 :                float x2 = (float) (x+1);

	lea	r11d, DWORD PTR [rdx+1]
	xorps	xmm6, xmm6
	cvtsi2ss xmm9, edx
	cvtsi2ss xmm6, r11d

; 3265 :                float x3 = xb;
; 3266 :                float y3 = y_bottom;
; 3267 : 
; 3268 :                // x = e->x + e->dx * (y-y_top)
; 3269 :                // (y-y_top) = (x - e->x) / e->dx
; 3270 :                // y = (x - e->x) / e->dx + y_top
; 3271 :                float y1 = (x - x0) / dx + y_top;
; 3272 :                float y2 = (x+1 - x0) / dx + y_top;
; 3273 : 
; 3274 :                if (x0 < x1 && x3 > x2) {         // three segments descending down-right

	comiss	xmm9, xmm7
	movaps	xmm10, xmm9
	movaps	xmm8, xmm6
	subss	xmm10, xmm7
	subss	xmm8, xmm7
	divss	xmm10, xmm13
	divss	xmm8, xmm13
	addss	xmm10, xmm11
	addss	xmm8, xmm11
	jbe	SHORT $LN48@stbtt__fil
	comiss	xmm12, xmm6
	jbe	SHORT $LN48@stbtt__fil

; 3275 :                   stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);

	movss	DWORD PTR [rsp+48], xmm10
	movaps	xmm3, xmm7
	movss	DWORD PTR [rsp+40], xmm9
	mov	r8, r9
	mov	rcx, r10
	movss	DWORD PTR [rsp+32], xmm11
	call	?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge

; 3276 :                   stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x2,y2);

	movss	DWORD PTR [rsp+48], xmm8
	movaps	xmm3, xmm9
	movss	DWORD PTR [rsp+40], xmm6
	movss	DWORD PTR [rsp+32], xmm10
	call	?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge

; 3277 :                   stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);

	jmp	$LN28@stbtt__fil
$LN48@stbtt__fil:

; 3278 :                } else if (x3 < x1 && x0 > x2) {  // three segments descending down-left

	comiss	xmm9, xmm12
	jbe	SHORT $LN50@stbtt__fil
	comiss	xmm7, xmm6
	jbe	SHORT $LN50@stbtt__fil

; 3279 :                   stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);

	movss	DWORD PTR [rsp+48], xmm8
	movaps	xmm3, xmm7
	movss	DWORD PTR [rsp+40], xmm6
	mov	r8, r9
	mov	rcx, r10
	movss	DWORD PTR [rsp+32], xmm11
	call	?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge

; 3280 :                   stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x1,y1);

	movss	DWORD PTR [rsp+48], xmm10
	movaps	xmm3, xmm6
	movss	DWORD PTR [rsp+40], xmm9
	movss	DWORD PTR [rsp+32], xmm8
	call	?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge
	movaps	xmm6, xmm9
	movaps	xmm8, xmm10
	jmp	$LN28@stbtt__fil
$LN50@stbtt__fil:

; 3281 :                   stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
; 3282 :                } else if (x0 < x1 && x3 > x1) {  // two segments across x, down-right

	comiss	xmm9, xmm7
	jbe	SHORT $LN52@stbtt__fil
	comiss	xmm12, xmm9
	ja	SHORT $LN148@stbtt__fil
$LN52@stbtt__fil:

; 3283 :                   stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
; 3284 :                   stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
; 3285 :                } else if (x3 < x1 && x0 > x1) {  // two segments across x, down-left

	comiss	xmm9, xmm12
	jbe	SHORT $LN54@stbtt__fil
	comiss	xmm7, xmm9
	jbe	SHORT $LN54@stbtt__fil
$LN148@stbtt__fil:

; 3239 :             // if edge goes outside of box we're drawing, we require
; 3240 :             // clipping logic. since this does not match the intended use
; 3241 :             // of this library, we use a different, very slow brute
; 3242 :             // force implementation
; 3243 :             // note though that this does happen some of the time because
; 3244 :             // x_top and x_bottom can be extrapolated at the top & bottom of
; 3245 :             // the shape and actually lie outside the bounding box
; 3246 :             int x;
; 3247 :             for (x=0; x < len; ++x) {

	movss	DWORD PTR [rsp+48], xmm10
	movaps	xmm3, xmm7
	movss	DWORD PTR [rsp+40], xmm9
	mov	r8, r9
	mov	rcx, r10
	movss	DWORD PTR [rsp+32], xmm11
	call	?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge
	movaps	xmm6, xmm9
	movaps	xmm8, xmm10
	jmp	SHORT $LN28@stbtt__fil
$LN54@stbtt__fil:

; 3286 :                   stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
; 3287 :                   stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
; 3288 :                } else if (x0 < x2 && x3 > x2) {  // two segments across x+1, down-right

	comiss	xmm6, xmm7
	jbe	SHORT $LN56@stbtt__fil
	comiss	xmm12, xmm6
	jbe	SHORT $LN56@stbtt__fil

; 3289 :                   stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);

	movss	DWORD PTR [rsp+48], xmm8
	movaps	xmm3, xmm7
	movss	DWORD PTR [rsp+40], xmm6
	mov	r8, r9
	mov	rcx, r10
	movss	DWORD PTR [rsp+32], xmm11
	call	?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge

; 3290 :                   stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);

	jmp	SHORT $LN28@stbtt__fil
$LN56@stbtt__fil:

; 3291 :                } else if (x3 < x2 && x0 > x2) {  // two segments across x+1, down-left

	comiss	xmm6, xmm12
	jbe	SHORT $LN58@stbtt__fil
	comiss	xmm7, xmm6
	jbe	SHORT $LN58@stbtt__fil

; 3292 :                   stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);

	movss	DWORD PTR [rsp+48], xmm8
	movaps	xmm3, xmm7
	movss	DWORD PTR [rsp+40], xmm6
	mov	r8, r9
	mov	rcx, r10
	movss	DWORD PTR [rsp+32], xmm11
	call	?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge

; 3293 :                   stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
; 3294 :                } else {  // one segment

	jmp	SHORT $LN28@stbtt__fil
$LN58@stbtt__fil:

; 3295 :                   stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x3,y3);

	movaps	xmm6, xmm7
	movaps	xmm8, xmm11
$LN28@stbtt__fil:

; 3239 :             // if edge goes outside of box we're drawing, we require
; 3240 :             // clipping logic. since this does not match the intended use
; 3241 :             // of this library, we use a different, very slow brute
; 3242 :             // force implementation
; 3243 :             // note though that this does happen some of the time because
; 3244 :             // x_top and x_bottom can be extrapolated at the top & bottom of
; 3245 :             // the shape and actually lie outside the bounding box
; 3246 :             int x;
; 3247 :             for (x=0; x < len; ++x) {

	movss	DWORD PTR [rsp+48], xmm14
	movaps	xmm3, xmm6
	movss	DWORD PTR [rsp+40], xmm12
	mov	r8, r9
	mov	rcx, r10
	movss	DWORD PTR [rsp+32], xmm8
	call	?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge
	mov	edx, r11d
	cmp	r11d, ebx
	jl	$LL30@stbtt__fil
$LN147@stbtt__fil:

; 3296 :                }
; 3297 :             }
; 3298 :          }
; 3299 :       }
; 3300 :       e = e->next;

	movss	xmm1, DWORD PTR __real@3f800000
$LN29@stbtt__fil:
	mov	r9, QWORD PTR [r9]
	test	r9, r9
	jne	$LL2@stbtt__fil

; 3301 :    }
; 3302 : }

	movaps	xmm15, XMMWORD PTR [rsp+64]
	lea	r11, QWORD PTR [rsp+224]
	mov	rbx, QWORD PTR [r11+16]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm13, XMMWORD PTR [rsp+96]
	movaps	xmm12, XMMWORD PTR [rsp+112]
	movaps	xmm10, XMMWORD PTR [rsp+144]
	movaps	xmm9, XMMWORD PTR [rsp+160]
	movaps	xmm8, XMMWORD PTR [rsp+176]
	movaps	xmm7, XMMWORD PTR [rsp+192]
	movaps	xmm6, XMMWORD PTR [rsp+208]
	movaps	xmm14, XMMWORD PTR [rsp+80]
	mov	rsp, r11
	pop	rdi
$LN146@stbtt__fil:
	ret	0
?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z ENDP ; stbtt__fill_active_edges_new
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z
_TEXT	SEGMENT
scanline$1$ = 48
y$1$ = 56
scanline2$1$ = 64
c$1$ = 72
result$GSCopy$1$ = 80
tv1294 = 88
active$ = 96
scanline_data$ = 112
__$ArrayPad$ = 640
result$ = 848
e$ = 856
n$ = 864
vsubsample$dead$ = 872
off_x$ = 880
off_y$ = 888
userdata$dead$ = 896
?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z PROC ; stbtt__rasterize_sorted_edges, COMDAT

; 3306 : {

	mov	r11, rsp
	push	rsi
	sub	rsp, 832				; 00000340H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 3307 :    stbtt__hheap hh = { 0, 0, 0 };
; 3308 :    stbtt__active_edge *active = NULL;
; 3309 :    int y,j=0, i;
; 3310 :    float scanline_data[129], *scanline, *scanline2;
; 3311 : 
; 3312 :    STBTT__NOTUSED(vsubsample);
; 3313 : 
; 3314 :    if (result->w > 64)

	mov	eax, DWORD PTR [rcx]
	mov	QWORD PTR [r11+32], rbx
	xor	ebx, ebx
	mov	QWORD PTR [r11-16], rbp
	xor	ebp, ebp
	mov	QWORD PTR [r11-24], rdi
	mov	rdi, rdx
	mov	QWORD PTR [r11-32], r12
	mov	r12, rcx
	mov	QWORD PTR [r11-40], r13
	xor	r13d, r13d
	mov	QWORD PTR [r11-48], r14
	xor	r14d, r14d
	mov	QWORD PTR [r11-56], r15
	xor	r15d, r15d
	movaps	XMMWORD PTR [r11-120], xmm9
	movsxd	rsi, r8d
	mov	QWORD PTR result$GSCopy$1$[rsp], rcx
	mov	QWORD PTR c$1$[rsp], r15
	mov	QWORD PTR active$[rsp], rbx
	cmp	eax, 64					; 00000040H
	jle	SHORT $LN19@stbtt__ras

; 3315 :       scanline = (float *) STBTT_malloc((result->w*2+1) * sizeof(float), userdata);

	lea	eax, DWORD PTR [rax*2+1]
	movsxd	rcx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 3315 :       scanline = (float *) STBTT_malloc((result->w*2+1) * sizeof(float), userdata);

	shl	rcx, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN32@stbtt__ras

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN32@stbtt__ras:

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
	mov	r9, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 3315 :       scanline = (float *) STBTT_malloc((result->w*2+1) * sizeof(float), userdata);

	jmp	SHORT $LN144@stbtt__ras
$LN19@stbtt__ras:

; 3316 :    else
; 3317 :       scanline = scanline_data;

	lea	r9, QWORD PTR scanline_data$[rsp]
$LN144@stbtt__ras:

; 3318 : 
; 3319 :    scanline2 = scanline + result->w;
; 3320 : 
; 3321 :    y = off_y;

	mov	ecx, DWORD PTR off_y$[rsp]
	mov	edx, ecx
	movsxd	rax, DWORD PTR [r12]

; 3322 :    e[n].y0 = (float) (off_y + result->h) + 1;

	movss	xmm9, DWORD PTR __real@3f800000
	mov	DWORD PTR y$1$[rsp], ecx
	add	ecx, DWORD PTR [r12+4]
	mov	QWORD PTR tv1294[rsp], rax
	lea	rax, QWORD PTR [r9+rax*4]
	mov	QWORD PTR scanline$1$[rsp], r9
	mov	QWORD PTR scanline2$1$[rsp], rax
	movd	xmm0, ecx
	lea	rcx, QWORD PTR [rsi+rsi*4]
	cvtdq2ps xmm0, xmm0
	addss	xmm0, xmm9
	movss	DWORD PTR [rdi+rcx*4+4], xmm0

; 3323 : 
; 3324 :    while (j < result->h) {

	cmp	DWORD PTR [r12+4], ebx
	jle	$LN112@stbtt__ras
	movaps	XMMWORD PTR [rsp+768], xmm6
	movaps	XMMWORD PTR [rsp+752], xmm7
	movaps	XMMWORD PTR [rsp+736], xmm8
	xorps	xmm8, xmm8
	movaps	XMMWORD PTR [rsp+704], xmm10
	movss	xmm10, DWORD PTR __real@bf800000
	movaps	XMMWORD PTR [rsp+688], xmm11
	movss	xmm11, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
	movaps	XMMWORD PTR [rsp+672], xmm12
	movss	xmm12, DWORD PTR __real@437f0000
	movaps	XMMWORD PTR [rsp+656], xmm13
	movss	xmm13, DWORD PTR __real@3f000000
	jmp	SHORT $LN2@stbtt__ras
	npad	12
$LL114@stbtt__ras:
	mov	r9, QWORD PTR scanline$1$[rsp]
$LN2@stbtt__ras:

; 3325 :       // find center of pixel for this scanline
; 3326 :       float scan_y_top    = y + 0.0f;
; 3327 :       float scan_y_bottom = y + 1.0f;
; 3328 :       stbtt__active_edge **step = &active;
; 3329 : 
; 3330 :       STBTT_memset(scanline , 0, result->w*sizeof(scanline[0]));

	movsxd	r8, DWORD PTR [r12]
	lea	rsi, QWORD PTR active$[rsp]
	movd	xmm7, edx
	mov	rcx, r9
	cvtdq2ps xmm7, xmm7
	shl	r8, 2
	xor	edx, edx
	movaps	xmm6, xmm7
	addss	xmm7, xmm9
	addss	xmm6, xmm8
	call	memset

; 3331 :       STBTT_memset(scanline2, 0, (result->w+1)*sizeof(scanline[0]));

	mov	eax, DWORD PTR [r12]
	xor	edx, edx
	mov	rcx, QWORD PTR scanline2$1$[rsp]
	inc	eax
	movsxd	r8, eax
	shl	r8, 2
	call	memset

; 3332 : 
; 3333 :       // update all active edges;
; 3334 :       // remove all active edges that terminate before the top of this scanline
; 3335 :       while (*step) {

	test	rbx, rbx
	je	SHORT $LN89@stbtt__ras
	xor	ecx, ecx
$LL4@stbtt__ras:

; 3336 :          stbtt__active_edge * z = *step;
; 3337 :          if (z->ey <= scan_y_top) {

	comiss	xmm6, DWORD PTR [rbx+28]
	jb	SHORT $LN21@stbtt__ras

; 3338 :             *step = z->next; // delete from list

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rsi], rax

; 2798 :    *(void **) p = hh->first_free;

	mov	QWORD PTR [rbx], r14

; 2799 :    hh->first_free = p;

	mov	r14, rbx

; 3339 :             STBTT_assert(z->direction);
; 3340 :             z->direction = 0;

	mov	DWORD PTR [rbx+20], ecx

; 3341 :             stbtt__hheap_free(&hh, z);
; 3342 :          } else {

	jmp	SHORT $LN22@stbtt__ras
$LN21@stbtt__ras:

; 3343 :             step = &((*step)->next); // advance through list

	mov	rsi, rbx
$LN22@stbtt__ras:

; 3332 : 
; 3333 :       // update all active edges;
; 3334 :       // remove all active edges that terminate before the top of this scanline
; 3335 :       while (*step) {

	mov	rbx, QWORD PTR [rsi]
	test	rbx, rbx
	jne	SHORT $LL4@stbtt__ras
	mov	rbx, QWORD PTR active$[rsp]
$LN89@stbtt__ras:

; 3344 :          }
; 3345 :       }
; 3346 : 
; 3347 :       // insert all edges that start before the bottom of this scanline
; 3348 :       while (e->y0 <= scan_y_bottom) {

	movss	xmm0, DWORD PTR [rdi+4]
	comiss	xmm7, xmm0
	jb	$LN10@stbtt__ras
	mov	r12d, DWORD PTR off_y$[rsp]
	npad	3
$LL9@stbtt__ras:

; 3349 :          if (e->y0 != e->y1) {

	ucomiss	xmm0, DWORD PTR [rdi+12]
	jp	SHORT $LN111@stbtt__ras
	je	$LN24@stbtt__ras
$LN111@stbtt__ras:

; 2777 :    if (hh->first_free) {

	test	r14, r14
	je	SHORT $LN51@stbtt__ras

; 2778 :       void *p = hh->first_free;

	mov	rcx, r14

; 2779 :       hh->first_free = * (void **) p;

	mov	r14, QWORD PTR [r14]

; 2780 :       return p;

	jmp	SHORT $LN52@stbtt__ras
$LN51@stbtt__ras:

; 2781 :    } else {
; 2782 :       if (hh->num_remaining_in_head_chunk == 0) {

	test	ebp, ebp
	jne	SHORT $LN53@stbtt__ras
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN59@stbtt__ras

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN59@stbtt__ras:

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	mov	ecx, 25608				; 00006408H
	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 2785 :          if (c == NULL)

	test	rax, rax
	jne	SHORT $LN54@stbtt__ras

; 2786 :             return NULL;

	xor	ecx, ecx
	jmp	SHORT $LN52@stbtt__ras
$LN54@stbtt__ras:

; 2787 :          c->next = hh->head;

	mov	QWORD PTR [rax], r15

; 2788 :          hh->head = c;
; 2789 :          hh->num_remaining_in_head_chunk = count;

	mov	ebp, 800				; 00000320H
	mov	r15, rax
$LN53@stbtt__ras:

; 2790 :       }
; 2791 :       --hh->num_remaining_in_head_chunk;

	dec	ebp

; 2792 :       return (char *) (hh->head) + sizeof(stbtt__hheap_chunk) + size * hh->num_remaining_in_head_chunk;

	lea	rcx, QWORD PTR [r15+8]
	movsxd	rax, ebp
	shl	rax, 5
	add	rcx, rax
$LN52@stbtt__ras:

; 2865 :    float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);

	movss	xmm2, DWORD PTR [rdi+8]
	movss	xmm0, DWORD PTR [rdi+12]
	subss	xmm2, DWORD PTR [rdi]
	subss	xmm0, DWORD PTR [rdi+4]
	divss	xmm2, xmm0

; 2866 :    STBTT_assert(z != NULL);
; 2867 :    //STBTT_assert(e->y0 <= start_point);
; 2868 :    if (!z) return z;

	test	rcx, rcx
	je	$LN24@stbtt__ras

; 2869 :    z->fdx = dxdy;
; 2870 :    z->fdy = dxdy != 0.0f ? (1.0f/dxdy) : 0.0f;

	ucomiss	xmm2, xmm8
	movss	DWORD PTR [rcx+12], xmm2
	jp	SHORT $LN110@stbtt__ras
	jne	SHORT $LN110@stbtt__ras
	movaps	xmm0, xmm8
	jmp	SHORT $LN47@stbtt__ras
$LN110@stbtt__ras:
	movaps	xmm0, xmm9
	divss	xmm0, xmm2
$LN47@stbtt__ras:
	movss	DWORD PTR [rcx+16], xmm0

; 2871 :    z->fx = e->x0 + dxdy * (start_point - e->y0);

	movaps	xmm1, xmm6
	subss	xmm1, DWORD PTR [rdi+4]
	movd	xmm0, DWORD PTR off_x$[rsp]

; 2872 :    z->fx -= off_x;

	cvtdq2ps xmm0, xmm0
	mulss	xmm1, xmm2
	addss	xmm1, DWORD PTR [rdi]
	subss	xmm1, xmm0
	movss	DWORD PTR [rcx+8], xmm1

; 2873 :    z->direction = e->invert ? 1.0f : -1.0f;

	cmp	DWORD PTR [rdi+16], 0
	je	SHORT $LN48@stbtt__ras
	movaps	xmm0, xmm9
	jmp	SHORT $LN49@stbtt__ras
$LN48@stbtt__ras:
	movaps	xmm0, xmm10
$LN49@stbtt__ras:
	movss	DWORD PTR [rcx+20], xmm0

; 2874 :    z->sy = e->y0;

	mov	eax, DWORD PTR [rdi+4]
	mov	DWORD PTR [rcx+24], eax

; 2875 :    z->ey = e->y1;

	movss	xmm0, DWORD PTR [rdi+12]
	movss	DWORD PTR [rcx+28], xmm0

; 3350 :             stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y_top, userdata);
; 3351 :             if (z != NULL) {
; 3352 :                if (j == 0 && off_y != 0) {

	test	r13d, r13d
	jne	SHORT $LN13@stbtt__ras
	test	r12d, r12d
	je	SHORT $LN13@stbtt__ras

; 3353 :                   if (z->ey < scan_y_top) {

	comiss	xmm6, xmm0
	jbe	SHORT $LN13@stbtt__ras

; 3354 :                      // this can happen due to subpixel positioning and some kind of fp rounding error i think
; 3355 :                      z->ey = scan_y_top;

	movss	DWORD PTR [rcx+28], xmm6
$LN13@stbtt__ras:

; 3356 :                   }
; 3357 :                }
; 3358 :                STBTT_assert(z->ey >= scan_y_top); // if we get really unlucky a tiny bit of an edge can be out of bounds
; 3359 :                // insert at front
; 3360 :                z->next = active;

	mov	QWORD PTR [rcx], rbx

; 3361 :                active = z;

	mov	rbx, rcx
	mov	QWORD PTR active$[rsp], rcx
$LN24@stbtt__ras:

; 3362 :             }
; 3363 :          }
; 3364 :          ++e;

	movss	xmm0, DWORD PTR [rdi+24]
	add	rdi, 20
	comiss	xmm7, xmm0
	jae	$LL9@stbtt__ras
	mov	r12, QWORD PTR result$GSCopy$1$[rsp]
	mov	QWORD PTR c$1$[rsp], r15
$LN10@stbtt__ras:

; 3365 :       }
; 3366 : 
; 3367 :       // now process all active edges
; 3368 :       if (active)

	mov	rsi, QWORD PTR scanline$1$[rsp]
	test	rbx, rbx
	je	SHORT $LN27@stbtt__ras

; 3369 :          stbtt__fill_active_edges_new(scanline, scanline2+1, result->w, active, scan_y_top);

	mov	rdx, QWORD PTR scanline2$1$[rsp]
	mov	r9, rbx
	mov	r8d, DWORD PTR [r12]
	add	rdx, 4
	mov	rcx, rsi
	movss	DWORD PTR [rsp+32], xmm6
	call	?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z ; stbtt__fill_active_edges_new
$LN27@stbtt__ras:

; 3373 :          for (i=0; i < result->w; ++i) {

	xor	r9d, r9d
	movaps	xmm1, xmm8
	cmp	DWORD PTR [r12], r9d
	jle	SHORT $LN15@stbtt__ras

; 3370 : 
; 3371 :       {
; 3372 :          float sum = 0;

	mov	r8, rsi
	mov	r15d, 255				; 000000ffH
	mov	rsi, QWORD PTR tv1294[rsp]
	npad	10
$LL16@stbtt__ras:

; 3374 :             float k;
; 3375 :             int m;
; 3376 :             sum += scanline2[i];

	addss	xmm1, DWORD PTR [r8+rsi*4]

; 3381 :             result->pixels[j*result->stride + i] = (unsigned char) m;

	mov	eax, r13d
	movaps	xmm0, xmm1
	addss	xmm0, DWORD PTR [r8]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	andps	xmm0, xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 3378 :             k = (float) STBTT_fabs(k)*255 + 0.5f;

	mulss	xmm0, xmm12
	addss	xmm0, xmm13

; 3379 :             m = (int) k;

	cvttss2si edx, xmm0

; 3380 :             if (m > 255) m = 255;

	cmp	edx, r15d
	cmovg	edx, r15d

; 3381 :             result->pixels[j*result->stride + i] = (unsigned char) m;

	imul	eax, DWORD PTR [r12+8]
	add	r8, 4
	add	eax, r9d
	inc	r9d
	movsxd	rcx, eax
	mov	rax, QWORD PTR [r12+16]
	mov	BYTE PTR [rcx+rax], dl
	cmp	r9d, DWORD PTR [r12]
	jl	SHORT $LL16@stbtt__ras
	mov	r15, QWORD PTR c$1$[rsp]
	mov	rsi, QWORD PTR scanline$1$[rsp]
$LN15@stbtt__ras:

; 3382 :          }
; 3383 :       }
; 3384 :       // advance all the edges
; 3385 :       step = &active;

	lea	rcx, QWORD PTR active$[rsp]

; 3386 :       while (*step) {

	test	rbx, rbx
	je	SHORT $LN18@stbtt__ras
	mov	rax, rbx
	npad	14
$LL17@stbtt__ras:

; 3387 :          stbtt__active_edge *z = *step;
; 3388 :          z->fx += z->fdx; // advance to position for current scanline

	movss	xmm0, DWORD PTR [rax+12]
	addss	xmm0, DWORD PTR [rax+8]
	movss	DWORD PTR [rax+8], xmm0

; 3389 :          step = &((*step)->next); // advance through list

	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rcx]
	test	rax, rax
	jne	SHORT $LL17@stbtt__ras
$LN18@stbtt__ras:

; 3390 :       }
; 3391 : 
; 3392 :       ++y;

	mov	edx, DWORD PTR y$1$[rsp]

; 3393 :       ++j;

	inc	r13d
	inc	edx
	mov	DWORD PTR y$1$[rsp], edx
	cmp	r13d, DWORD PTR [r12+4]
	jl	$LL114@stbtt__ras

; 3323 : 
; 3324 :    while (j < result->h) {

	movaps	xmm13, XMMWORD PTR [rsp+656]
	movaps	xmm12, XMMWORD PTR [rsp+672]
	movaps	xmm11, XMMWORD PTR [rsp+688]
	movaps	xmm10, XMMWORD PTR [rsp+704]
	movaps	xmm8, XMMWORD PTR [rsp+736]
	movaps	xmm7, XMMWORD PTR [rsp+752]
	movaps	xmm6, XMMWORD PTR [rsp+768]
	jmp	SHORT $LN3@stbtt__ras
$LN112@stbtt__ras:
	mov	rsi, QWORD PTR scanline$1$[rsp]
$LN3@stbtt__ras:
	movaps	xmm9, XMMWORD PTR [rsp+720]

; 2805 :    while (c) {

	mov	r14, QWORD PTR [rsp+792]
	mov	r13, QWORD PTR [rsp+800]
	mov	r12, QWORD PTR [rsp+808]
	mov	rdi, QWORD PTR [rsp+816]
	mov	rbp, QWORD PTR [rsp+824]
	test	r15, r15
	je	SHORT $LN69@stbtt__ras
	npad	4
$LL68@stbtt__ras:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 2806 :       stbtt__hheap_chunk *n = c->next;

	mov	rbx, QWORD PTR [r15]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN73@stbtt__ras

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN73@stbtt__ras:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	mov	rcx, r15
	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 2808 :       c = n;

	mov	r15, rbx
	test	rbx, rbx
	jne	SHORT $LL68@stbtt__ras
$LN69@stbtt__ras:

; 3394 :    }
; 3395 : 
; 3396 :    stbtt__hheap_cleanup(&hh, userdata);
; 3397 : 
; 3398 :    if (scanline != scanline_data)

	mov	r15, QWORD PTR [rsp+784]
	lea	rax, QWORD PTR scanline_data$[rsp]
	mov	rbx, QWORD PTR [rsp+872]
	cmp	rsi, rax
	je	SHORT $LN83@stbtt__ras
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	test	rsi, rsi
	je	SHORT $LN81@stbtt__ras

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN81@stbtt__ras

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN81@stbtt__ras:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	mov	rcx, rsi
	call	QWORD PTR __imp_free
$LN83@stbtt__ras:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 3400 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 832				; 00000340H
	pop	rsi
	ret	0
?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z ENDP ; stbtt__rasterize_sorted_edges
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z
_TEXT	SEGMENT
p$ = 16
n$ = 24
?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z PROC ; stbtt__sort_edges_ins_sort, COMDAT

; 3408 : {

	sub	rsp, 8
	mov	r11, rcx

; 3409 :    int i,j;
; 3410 :    for (i=1; i < n; ++i) {

	cmp	edx, 1
	jle	$LN3@stbtt__sor
	mov	QWORD PTR [rsp], rbx
	lea	r9, QWORD PTR [rcx+20]
	mov	r8d, 1
	lea	r10d, DWORD PTR [rdx-1]
	npad	14
$LL4@stbtt__sor:

; 3411 :       stbtt__edge t = p[i], *a = &t;

	mov	ebx, DWORD PTR [r9+16]

; 3412 :       j = i;

	mov	rdx, r8
	movups	xmm2, XMMWORD PTR [r9]

; 3413 :       while (j > 0) {

	test	r8, r8
	jle	SHORT $LN2@stbtt__sor
	movaps	xmm1, xmm2
	lea	rcx, QWORD PTR [r9-20]
	shufps	xmm1, xmm2, 85				; 00000055H
	npad	5
$LL5@stbtt__sor:

; 3414 :          stbtt__edge *b = &p[j-1];
; 3415 :          int c = STBTT__COMPARE(a,b);

	movss	xmm0, DWORD PTR [rcx+4]
	xor	eax, eax
	comiss	xmm0, xmm1
	seta	al

; 3416 :          if (!c) break;

	test	eax, eax
	je	SHORT $LN12@stbtt__sor

; 3417 :          p[j] = p[j-1];

	movups	xmm0, XMMWORD PTR [rcx]
	mov	eax, DWORD PTR [rcx+16]

; 3418 :          --j;

	dec	rdx
	movups	XMMWORD PTR [rcx+20], xmm0
	mov	DWORD PTR [rcx+36], eax
	sub	rcx, 20
	test	rdx, rdx
	jg	SHORT $LL5@stbtt__sor
$LN12@stbtt__sor:

; 3419 :       }
; 3420 :       if (i != j)

	cmp	r8, rdx
	je	SHORT $LN2@stbtt__sor

; 3421 :          p[j] = t;

	lea	rax, QWORD PTR [rdx+rdx*4]
	movups	XMMWORD PTR [r11+rax*4], xmm2
	mov	DWORD PTR [r11+rax*4+16], ebx
$LN2@stbtt__sor:

; 3409 :    int i,j;
; 3410 :    for (i=1; i < n; ++i) {

	inc	r8
	add	r9, 20
	sub	r10, 1
	jne	SHORT $LL4@stbtt__sor
	mov	rbx, QWORD PTR [rsp]
$LN3@stbtt__sor:

; 3422 :    }
; 3423 : }

	add	rsp, 8
	ret	0
?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z ENDP ; stbtt__sort_edges_ins_sort
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z
_TEXT	SEGMENT
p$ = 64
n$ = 72
?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z PROC ; stbtt__sort_edges_quicksort, COMDAT

; 3427 :    /* threshold for transitioning to insertion sort */
; 3428 :    while (n > 12) {

	cmp	edx, 12
	jle	$LN47@stbtt__sor
	push	rbp
	push	rsi
	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+64], rbx
	mov	ebp, edx
	mov	QWORD PTR [rsp+72], rdi
	mov	rsi, rcx
	mov	QWORD PTR [rsp+80], r14
	mov	QWORD PTR [rsp+32], r15
	npad	8
$LL2@stbtt__sor:

; 3429 :       stbtt__edge t;
; 3430 :       int c01,c12,c,m,i,j;
; 3431 : 
; 3432 :       /* compute median of three */
; 3433 :       m = n >> 1;
; 3434 :       c01 = STBTT__COMPARE(&p[0],&p[m]);

	movss	xmm2, DWORD PTR [rsi+4]

; 3435 :       c12 = STBTT__COMPARE(&p[m],&p[n-1]);

	lea	edi, DWORD PTR [rbp-1]
	xor	edx, edx
	mov	eax, ebp
	shr	rax, 1
	mov	r15, rsi
	mov	r9d, ebp
	mov	r14, rsi
	dec	r9
	lea	r8, QWORD PTR [rax+rax*4]
	movss	xmm0, DWORD PTR [rsi+r8*4+4]
	lea	rax, QWORD PTR [r9+r9*4]
	movss	xmm1, DWORD PTR [rsi+rax*4+4]
	comiss	xmm1, xmm0
	seta	dl
	xor	eax, eax
	comiss	xmm0, xmm2
	seta	al

; 3436 :       /* if 0 >= mid >= end, or 0 < mid < end, then use mid */
; 3437 :       if (c01 != c12) {

	cmp	eax, edx
	je	SHORT $LN13@stbtt__sor

; 3438 :          /* otherwise, we'll need to swap something else to middle */
; 3439 :          int z;
; 3440 :          c = STBTT__COMPARE(&p[0],&p[n-1]);
; 3441 :          /* 0>mid && mid<n:  0>n => n; 0<n => 0 */
; 3442 :          /* 0<mid && mid>n:  0>n => 0; 0<n => n */
; 3443 :          z = (c == c12) ? 0 : n-1;
; 3444 :          t = p[z];
; 3445 :          p[z] = p[m];

	movups	xmm0, XMMWORD PTR [rsi+r8*4]
	xor	ecx, ecx
	comiss	xmm1, xmm2
	seta	cl
	xor	eax, eax
	cmp	ecx, edx
	cmovne	eax, edi
	cdqe
	lea	rcx, QWORD PTR [rax+rax*4]
	movups	xmm1, XMMWORD PTR [rsi+rcx*4]
	mov	edx, DWORD PTR [rsi+rcx*4+16]
	movups	XMMWORD PTR [rsi+rcx*4], xmm0
	mov	eax, DWORD PTR [rsi+r8*4+16]
	mov	DWORD PTR [rsi+rcx*4+16], eax

; 3446 :          p[m] = t;

	movups	XMMWORD PTR [rsi+r8*4], xmm1
	mov	DWORD PTR [rsi+r8*4+16], edx
$LN13@stbtt__sor:

; 3447 :       }
; 3448 :       /* now p[m] is the median-of-three */
; 3449 :       /* swap it to the beginning so it won't move around */
; 3450 :       t = p[0];
; 3451 :       p[0] = p[m];

	movups	xmm0, XMMWORD PTR [rsi+r8*4]
	mov	ecx, DWORD PTR [rsi+16]

; 3452 :       p[m] = t;
; 3453 : 
; 3454 :       /* partition loop */
; 3455 :       i=1;

	mov	r11d, 1
	movups	xmm1, XMMWORD PTR [rsi]
	mov	r10d, r11d
	movups	XMMWORD PTR [rsi], xmm0
	mov	eax, DWORD PTR [rsi+r8*4+16]
	mov	DWORD PTR [rsi+16], eax
	movups	XMMWORD PTR [rsi+r8*4], xmm1
	mov	DWORD PTR [rsi+r8*4+16], ecx
	npad	12
$LL4@stbtt__sor:

; 3461 :             if (!STBTT__COMPARE(&p[i], &p[0])) break;

	movss	xmm1, DWORD PTR [rsi+4]
	lea	rcx, QWORD PTR [r10*4+1]
	add	rcx, r10
	comiss	xmm1, DWORD PTR [rsi+rcx*4]
	lea	rcx, QWORD PTR [rsi+rcx*4]
	jbe	SHORT $LN28@stbtt__sor
	npad	6
$LL9@stbtt__sor:

; 3456 :       j=n-1;
; 3457 :       for(;;) {
; 3458 :          /* handling of equality is crucial here */
; 3459 :          /* for sentinels & efficiency with duplicates */
; 3460 :          for (;;++i) {

	inc	r11d
	lea	rcx, QWORD PTR [rcx+20]
	inc	r10

; 3461 :             if (!STBTT__COMPARE(&p[i], &p[0])) break;

	comiss	xmm1, DWORD PTR [rcx]
	ja	SHORT $LL9@stbtt__sor
$LN28@stbtt__sor:

; 3462 :          }
; 3463 :          for (;;--j) {
; 3464 :             if (!STBTT__COMPARE(&p[0], &p[j])) break;

	lea	rcx, QWORD PTR [r9*4+1]
	add	rcx, r9
	movss	xmm0, DWORD PTR [rsi+rcx*4]
	lea	rcx, QWORD PTR [rsi+rcx*4]
	comiss	xmm0, xmm1
	jbe	SHORT $LN29@stbtt__sor
	npad	8
$LL12@stbtt__sor:
	movss	xmm0, DWORD PTR [rcx-20]
	lea	rcx, QWORD PTR [rcx-20]
	dec	edi
	dec	r9
	comiss	xmm0, xmm1
	ja	SHORT $LL12@stbtt__sor
$LN29@stbtt__sor:

; 3465 :          }
; 3466 :          /* make sure we haven't crossed */
; 3467 :          if (i >= j) break;

	cmp	r10, r9
	jge	SHORT $LN30@stbtt__sor

; 3468 :          t = p[i];
; 3469 :          p[i] = p[j];

	lea	rcx, QWORD PTR [r9+r9*4]

; 3470 :          p[j] = t;
; 3471 : 
; 3472 :          ++i;

	inc	r11d
	movups	xmm0, XMMWORD PTR [rsi+rcx*4]
	lea	rdx, QWORD PTR [r10+r10*4]

; 3473 :          --j;

	dec	edi
	movups	xmm1, XMMWORD PTR [rsi+rdx*4]
	mov	r8d, DWORD PTR [rsi+rdx*4+16]
	inc	r10
	movups	XMMWORD PTR [rsi+rdx*4], xmm0
	mov	eax, DWORD PTR [rsi+rcx*4+16]
	dec	r9
	mov	DWORD PTR [rsi+rdx*4+16], eax
	movups	XMMWORD PTR [rsi+rcx*4], xmm1
	mov	DWORD PTR [rsi+rcx*4+16], r8d
	jmp	$LL4@stbtt__sor
$LN30@stbtt__sor:

; 3474 :       }
; 3475 :       /* recurse on smaller side, iterate on larger */
; 3476 :       if (j < (n-i)) {

	sub	ebp, r11d
	movsxd	rax, r11d
	cmp	edi, ebp
	mov	ebx, ebp
	mov	edx, edi
	cmovge	edx, ebx
	cmovge	ebp, edi
	lea	rcx, QWORD PTR [rax+rax*4]
	lea	rsi, QWORD PTR [rsi+rcx*4]
	cmovge	r14, rsi
	mov	rcx, r14
	call	?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z ; stbtt__sort_edges_quicksort
	cmp	edi, ebx
	cmovge	rsi, r15
	cmp	ebp, 12
	jg	$LL2@stbtt__sor

; 3427 :    /* threshold for transitioning to insertion sort */
; 3428 :    while (n > 12) {

	mov	r15, QWORD PTR [rsp+32]
	mov	r14, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 3477 :          stbtt__sort_edges_quicksort(p,j);
; 3478 :          p = p+i;
; 3479 :          n = n-i;
; 3480 :       } else {
; 3481 :          stbtt__sort_edges_quicksort(p+i, n-i);
; 3482 :          n = j;
; 3483 :       }
; 3484 :    }
; 3485 : }

	add	rsp, 40					; 00000028H
	pop	rsi
	pop	rbp
$LN47@stbtt__sor:
	ret	0
?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z ENDP ; stbtt__sort_edges_quicksort
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__sort_edges@@YAXPEAUstbtt__edge@@H@Z
_TEXT	SEGMENT
p$ = 48
n$ = 56
?stbtt__sort_edges@@YAXPEAUstbtt__edge@@H@Z PROC	; stbtt__sort_edges, COMDAT

; 3488 : {

	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	movsxd	rbx, edx
	mov	rdi, rcx

; 3489 :    stbtt__sort_edges_quicksort(p, n);

	mov	edx, ebx
	call	?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z ; stbtt__sort_edges_quicksort

; 3410 :    for (i=1; i < n; ++i) {

	cmp	rbx, 1
	jle	SHORT $LN5@stbtt__sor
	mov	r8d, 1
	lea	r9, QWORD PTR [rdi+20]
	npad	9
$LL6@stbtt__sor:

; 3411 :       stbtt__edge t = p[i], *a = &t;

	movups	xmm2, XMMWORD PTR [r9]
	mov	r11d, DWORD PTR [r9+16]
	lea	rcx, QWORD PTR [r9-20]

; 3412 :       j = i;

	mov	rdx, r8
	movaps	xmm1, xmm2
	shufps	xmm1, xmm2, 85				; 00000055H
	npad	10
$LL7@stbtt__sor:

; 3413 :       while (j > 0) {
; 3414 :          stbtt__edge *b = &p[j-1];
; 3415 :          int c = STBTT__COMPARE(a,b);

	movss	xmm0, DWORD PTR [rcx+4]
	xor	eax, eax
	comiss	xmm0, xmm1
	seta	al

; 3416 :          if (!c) break;

	test	eax, eax
	je	SHORT $LN14@stbtt__sor

; 3417 :          p[j] = p[j-1];

	movups	xmm0, XMMWORD PTR [rcx]
	mov	eax, DWORD PTR [rcx+16]

; 3418 :          --j;

	dec	rdx
	movups	XMMWORD PTR [rcx+20], xmm0
	mov	DWORD PTR [rcx+36], eax
	sub	rcx, 20
	test	rdx, rdx
	jg	SHORT $LL7@stbtt__sor
$LN14@stbtt__sor:

; 3419 :       }
; 3420 :       if (i != j)

	cmp	r8, rdx
	je	SHORT $LN4@stbtt__sor

; 3421 :          p[j] = t;

	lea	rax, QWORD PTR [rdx+rdx*4]
	movups	XMMWORD PTR [rdi+rax*4], xmm2
	mov	DWORD PTR [rdi+rax*4+16], r11d
$LN4@stbtt__sor:

; 3410 :    for (i=1; i < n; ++i) {

	inc	r8
	add	r9, 20
	cmp	r8, rbx
	jl	SHORT $LL6@stbtt__sor
$LN5@stbtt__sor:

; 3490 :    stbtt__sort_edges_ins_sort(p, n);
; 3491 : }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?stbtt__sort_edges@@YAXPEAUstbtt__edge@@H@Z ENDP	; stbtt__sort_edges
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z
_TEXT	SEGMENT
pts$1$ = 72
result$GSCopy$1$ = 80
result$ = 176
pts$ = 184
wcount$ = 192
windings$ = 200
scale_x$ = 208
scale_y$ = 216
shift_x$ = 224
shift_y$ = 232
off_x$ = 240
off_y$ = 248
invert$dead$ = 256
userdata$dead$ = 264
?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z PROC ; stbtt__rasterize, COMDAT

; 3499 : {

	push	rbx
	push	rbp
	push	rdi
	push	r14
	sub	rsp, 136				; 00000088H
	movaps	XMMWORD PTR [rsp+96], xmm6
	mov	r14, rcx

; 3500 :    float y_scale_inv = invert ? -scale_y : scale_y;

	movss	xmm6, DWORD PTR scale_y$[rsp]

; 3507 : #else
; 3508 :    #error "Unrecognized value of STBTT_RASTERIZER_VERSION"
; 3509 : #endif
; 3510 :    // vsubsample should divide 255 evenly; otherwise we won't reach full opacity
; 3511 : 
; 3512 :    // now we have to blow out the windings into explicit edge lists
; 3513 :    n = 0;

	xor	r10d, r10d
	xorps	xmm6, DWORD PTR __xmm@80000000800000008000000080000000
	mov	rbx, r8
	mov	QWORD PTR result$GSCopy$1$[rsp], rcx
	xor	ecx, ecx
	mov	edi, r9d
	mov	QWORD PTR pts$1$[rsp], rdx

; 3514 :    for (i=0; i < windings; ++i)

	test	r9d, r9d
	jle	SHORT $LN57@stbtt__ras
	cmp	edi, 8
	jb	SHORT $LN57@stbtt__ras

; 3515 :       n += wcount[i];

	movsxd	rdx, edi
	xorps	xmm2, xmm2
	and	rdx, -8
	xorps	xmm1, xmm1
	xor	eax, eax
$LL4@stbtt__ras:
	movdqu	xmm0, XMMWORD PTR [r8+rax*4]
	add	ecx, 8
	paddd	xmm2, xmm0
	movdqu	xmm0, XMMWORD PTR [r8+rax*4+16]
	add	rax, 8
	paddd	xmm1, xmm0
	cmp	rax, rdx
	jl	SHORT $LL4@stbtt__ras

; 3501 :    stbtt__edge *e;
; 3502 :    int n,i,j,k,m;
; 3503 : #if STBTT_RASTERIZER_VERSION == 1
; 3504 :    int vsubsample = result->h < 8 ? 15 : 5;
; 3505 : #elif STBTT_RASTERIZER_VERSION == 2
; 3506 :    int vsubsample = 1;

	paddd	xmm1, xmm2
	movdqa	xmm0, xmm1
	psrldq	xmm0, 8
	paddd	xmm1, xmm0
	movdqa	xmm0, xmm1
	psrldq	xmm0, 4
	paddd	xmm1, xmm0
	movd	r10d, xmm1
$LN57@stbtt__ras:
	xor	edx, edx
	movsxd	rcx, ecx
	xor	r8d, r8d

; 3514 :    for (i=0; i < windings; ++i)

	movsxd	r9, edi
	cmp	rcx, r9
	jge	SHORT $LN65@stbtt__ras
	mov	rax, r9
	sub	rax, rcx
	cmp	rax, 2
	jl	SHORT $LN75@stbtt__ras
	lea	r11, QWORD PTR [r9-1]
	npad	9
$LL68@stbtt__ras:

; 3515 :       n += wcount[i];

	add	edx, DWORD PTR [rbx+rcx*4]
	add	r8d, DWORD PTR [rbx+rcx*4+4]
	add	rcx, 2
	cmp	rcx, r11
	jl	SHORT $LL68@stbtt__ras

; 3514 :    for (i=0; i < windings; ++i)

	cmp	rcx, r9
	jge	SHORT $LN67@stbtt__ras
$LN75@stbtt__ras:

; 3515 :       n += wcount[i];

	add	r10d, DWORD PTR [rbx+rcx*4]
$LN67@stbtt__ras:
	lea	eax, DWORD PTR [r8+rdx]
	add	r10d, eax
$LN65@stbtt__ras:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN20@stbtt__ras

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN20@stbtt__ras:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 3517 :    e = (stbtt__edge *) STBTT_malloc(sizeof(*e) * (n+1), userdata); // add an extra one as a sentinel

	lea	eax, DWORD PTR [r10+1]
	movsxd	rcx, eax
	lea	rcx, QWORD PTR [rcx+rcx*4]
	shl	rcx, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
	mov	rbp, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 3518 :    if (e == 0) return;

	test	rax, rax
	je	$LN41@stbtt__ras
	mov	QWORD PTR [rsp+184], rsi
	mov	QWORD PTR [rsp+128], r12

; 3519 :    n = 0;

	xor	r12d, r12d
	mov	QWORD PTR [rsp+112], r15

; 3520 : 
; 3521 :    m=0;

	xor	r15d, r15d

; 3522 :    for (i=0; i < windings; ++i) {

	lea	esi, QWORD PTR [r12+1]
	test	edi, edi
	jle	$LN6@stbtt__ras
	movss	xmm2, DWORD PTR shift_y$[rsp]
	xor	r14d, r14d
	movss	xmm3, DWORD PTR shift_x$[rsp]
	movss	xmm4, DWORD PTR scale_x$[rsp]
	mov	rcx, QWORD PTR pts$1$[rsp]
	mov	QWORD PTR [rsp+120], r13
	mov	r13, rdi
	npad	9
$LL7@stbtt__ras:

; 3523 :       stbtt__point *p = pts + m;

	movsxd	rax, r15d

; 3526 :       for (k=0; k < wcount[i]; j=k++) {

	xor	r11d, r11d
	xor	edx, edx
	lea	r10, QWORD PTR [rcx+rax*8]
	mov	eax, DWORD PTR [rbx]
	add	r15d, eax
	test	eax, eax
	jle	$LN5@stbtt__ras

; 3524 :       m += wcount[i];
; 3525 :       j = wcount[i]-1;

	dec	eax
	lea	r8, QWORD PTR [r10+4]
	movsxd	rcx, eax
	lea	rax, QWORD PTR [r14+r14*4]
	lea	r9, QWORD PTR [rax*4+16]
	add	r9, rbp
	npad	15
$LL10@stbtt__ras:

; 3527 :          int a=k,b=j;
; 3528 :          // skip the edge if horizontal
; 3529 :          if (p[j].y == p[k].y)

	movss	xmm0, DWORD PTR [r10+rcx*8+4]
	mov	rdi, rdx
	ucomiss	xmm0, DWORD PTR [r8]
	jp	SHORT $LN76@stbtt__ras
	je	SHORT $LN8@stbtt__ras
$LN76@stbtt__ras:

; 3530 :             continue;
; 3531 :          // add edge from j to k to the list
; 3532 :          e[n].invert = 0;
; 3533 :          if (invert ? p[j].y > p[k].y : p[j].y < p[k].y) {

	xor	eax, eax
	mov	DWORD PTR [r9], 0
	movss	xmm0, DWORD PTR [r10+rcx*8+4]
	comiss	xmm0, DWORD PTR [r8]
	seta	al
	test	eax, eax
	je	SHORT $LN13@stbtt__ras

; 3534 :             e[n].invert = 1;
; 3535 :             a=j,b=k;

	mov	rdi, rcx
	mov	DWORD PTR [r9], esi
	mov	rcx, rdx
$LN13@stbtt__ras:

; 3536 :          }
; 3537 :          e[n].x0 = p[a].x * scale_x + shift_x;

	movaps	xmm0, xmm4

; 3538 :          e[n].y0 = (p[a].y * y_scale_inv + shift_y) * vsubsample;

	movaps	xmm1, xmm6
	mulss	xmm0, DWORD PTR [r10+rdi*8]

; 3539 :          e[n].x1 = p[b].x * scale_x + shift_x;
; 3540 :          e[n].y1 = (p[b].y * y_scale_inv + shift_y) * vsubsample;
; 3541 :          ++n;

	inc	r12d
	inc	r14
	addss	xmm0, xmm3
	movss	DWORD PTR [r9-16], xmm0
	movaps	xmm0, xmm4
	mulss	xmm1, DWORD PTR [r10+rdi*8+4]
	addss	xmm1, xmm2
	movss	DWORD PTR [r9-12], xmm1
	movaps	xmm1, xmm6
	mulss	xmm0, DWORD PTR [r10+rcx*8]
	addss	xmm0, xmm3
	movss	DWORD PTR [r9-8], xmm0
	mulss	xmm1, DWORD PTR [r10+rcx*8+4]
	addss	xmm1, xmm2
	movss	DWORD PTR [r9-4], xmm1
	add	r9, 20
$LN8@stbtt__ras:

; 3526 :       for (k=0; k < wcount[i]; j=k++) {

	mov	rcx, rdx
	inc	r11d
	inc	rdx
	add	r8, 8
	cmp	r11d, DWORD PTR [rbx]
	jl	$LL10@stbtt__ras
	mov	rcx, QWORD PTR pts$1$[rsp]
$LN5@stbtt__ras:

; 3522 :    for (i=0; i < windings; ++i) {

	add	rbx, 4
	sub	r13, rsi
	jne	$LL7@stbtt__ras
	mov	r13, QWORD PTR [rsp+120]
	mov	r14, QWORD PTR result$GSCopy$1$[rsp]
$LN6@stbtt__ras:

; 3489 :    stbtt__sort_edges_quicksort(p, n);

	mov	edx, r12d
	mov	rcx, rbp
	call	?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z ; stbtt__sort_edges_quicksort

; 3410 :    for (i=1; i < n; ++i) {

	mov	r15, QWORD PTR [rsp+112]
	movsxd	r10, r12d
	cmp	r10, rsi
	jle	SHORT $LN30@stbtt__ras
	lea	r9, QWORD PTR [rbp+20]
	npad	4
$LL31@stbtt__ras:

; 3411 :       stbtt__edge t = p[i], *a = &t;

	movups	xmm2, XMMWORD PTR [r9]
	mov	r8d, DWORD PTR [r9+16]
	lea	rcx, QWORD PTR [r9-20]

; 3412 :       j = i;

	mov	rdx, rsi
	movaps	xmm1, xmm2
	shufps	xmm1, xmm2, 85				; 00000055H
	npad	10
$LL32@stbtt__ras:

; 3413 :       while (j > 0) {
; 3414 :          stbtt__edge *b = &p[j-1];
; 3415 :          int c = STBTT__COMPARE(a,b);

	movss	xmm0, DWORD PTR [rcx+4]
	xor	eax, eax
	comiss	xmm0, xmm1
	seta	al

; 3416 :          if (!c) break;

	test	eax, eax
	je	SHORT $LN50@stbtt__ras

; 3417 :          p[j] = p[j-1];

	movups	xmm0, XMMWORD PTR [rcx]
	mov	eax, DWORD PTR [rcx+16]

; 3418 :          --j;

	dec	rdx
	movups	XMMWORD PTR [rcx+20], xmm0
	mov	DWORD PTR [rcx+36], eax
	sub	rcx, 20
	test	rdx, rdx
	jg	SHORT $LL32@stbtt__ras
$LN50@stbtt__ras:

; 3419 :       }
; 3420 :       if (i != j)

	cmp	rsi, rdx
	je	SHORT $LN29@stbtt__ras

; 3421 :          p[j] = t;

	lea	rax, QWORD PTR [rdx+rdx*4]
	movups	XMMWORD PTR [rbp+rax*4], xmm2
	mov	DWORD PTR [rbp+rax*4+16], r8d
$LN29@stbtt__ras:

; 3410 :    for (i=1; i < n; ++i) {

	inc	rsi
	add	r9, 20
	cmp	rsi, r10
	jl	SHORT $LL31@stbtt__ras
$LN30@stbtt__ras:

; 3542 :       }
; 3543 :    }
; 3544 : 
; 3545 :    // now sort the edges by their highest point (should snap to integer, and then by x)
; 3546 :    //STBTT_sort(e, n, sizeof(e[0]), stbtt__edge_compare);
; 3547 :    stbtt__sort_edges(e, n);
; 3548 : 
; 3549 :    // now, traverse the scanlines and find the intersections on each scanline, use xor winding rule
; 3550 :    stbtt__rasterize_sorted_edges(result, e, n, vsubsample, off_x, off_y, userdata);

	mov	eax, DWORD PTR off_y$[rsp]
	mov	r8d, r12d
	mov	DWORD PTR [rsp+40], eax
	mov	rdx, rbp
	mov	eax, DWORD PTR off_x$[rsp]
	mov	rcx, r14
	mov	DWORD PTR [rsp+32], eax
	call	?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z ; stbtt__rasterize_sorted_edges
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	r12, QWORD PTR [rsp+128]
	mov	rsi, QWORD PTR [rsp+184]
	test	rax, rax
	je	SHORT $LN39@stbtt__ras

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN39@stbtt__ras:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	mov	rcx, rbp
	call	QWORD PTR __imp_free
$LN41@stbtt__ras:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 3553 : }

	movaps	xmm6, XMMWORD PTR [rsp+96]
	add	rsp, 136				; 00000088H
	pop	r14
	pop	rdi
	pop	rbp
	pop	rbx
	ret	0
?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z ENDP ; stbtt__rasterize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__add_point@@YAXPEAUstbtt__point@@HMM@Z
_TEXT	SEGMENT
points$ = 8
n$ = 16
x$ = 24
y$ = 32
?stbtt__add_point@@YAXPEAUstbtt__point@@HMM@Z PROC	; stbtt__add_point, COMDAT

; 3557 :    if (!points) return; // during first pass, it's unallocated

	test	rcx, rcx
	je	SHORT $LN1@stbtt__add

; 3558 :    points[n].x = x;

	movsxd	rax, edx
	movss	DWORD PTR [rcx+rax*8], xmm2

; 3559 :    points[n].y = y;

	movss	DWORD PTR [rcx+rax*8+4], xmm3
$LN1@stbtt__add:

; 3560 : }

	ret	0
?stbtt__add_point@@YAXPEAUstbtt__point@@HMM@Z ENDP	; stbtt__add_point
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z
_TEXT	SEGMENT
points$ = 224
num_points$ = 232
x0$ = 240
y0$ = 248
x1$ = 256
y1$ = 264
x2$ = 272
y2$ = 280
objspace_flatness_squared$ = 288
n$ = 296
?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z PROC ; stbtt__tesselate_curve, COMDAT

; 3564 : {

	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rsi
	push	rdi
	sub	rsp, 208				; 000000d0H

; 3565 :    // midpoint
; 3566 :    float mx = (x0 + 2*x1 + x2)/4;
; 3567 :    float my = (y0 + 2*y1 + y2)/4;
; 3568 :    // versus directly drawn line
; 3569 :    float dx = (x0+x2)/2 - mx;
; 3570 :    float dy = (y0+y2)/2 - my;
; 3571 :    if (n > 16) // 65536 segments on one curve better be enough!

	mov	ebx, DWORD PTR n$[rsp]
	movaps	xmm1, xmm2
	movaps	XMMWORD PTR [rax-24], xmm6
	movaps	xmm0, xmm3
	movss	xmm6, DWORD PTR x2$[rsp]
	mov	rsi, rdx
	movaps	XMMWORD PTR [rax-40], xmm7
	addss	xmm1, xmm6
	movss	xmm7, DWORD PTR y2$[rsp]
	mov	rdi, rcx
	movaps	XMMWORD PTR [rax-72], xmm9
	addss	xmm0, xmm7
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-104], xmm11
	movss	xmm11, DWORD PTR x1$[rsp]
	movaps	XMMWORD PTR [rax-120], xmm12
	movaps	xmm9, xmm11
	movss	xmm12, DWORD PTR y1$[rsp]
	addss	xmm9, xmm11
	movaps	XMMWORD PTR [rsp+80], xmm13
	movaps	xmm10, xmm12
	movss	xmm13, DWORD PTR __real@3f000000
	addss	xmm10, xmm12
	mulss	xmm1, xmm13
	mulss	xmm0, xmm13
	addss	xmm9, xmm2
	addss	xmm10, xmm3
	addss	xmm9, xmm6
	addss	xmm10, xmm7
	mulss	xmm9, DWORD PTR __real@3e800000
	mulss	xmm10, DWORD PTR __real@3e800000
	subss	xmm1, xmm9
	subss	xmm0, xmm10
	cmp	ebx, 16
	jg	$LN10@stbtt__tes

; 3572 :       return 1;
; 3573 :    if (dx*dx+dy*dy > objspace_flatness_squared) { // half-pixel error allowed... need to be smaller if AA

	mulss	xmm0, xmm0
	mulss	xmm1, xmm1
	movaps	XMMWORD PTR [rax-56], xmm8
	movss	xmm8, DWORD PTR objspace_flatness_squared$[rsp]
	addss	xmm0, xmm1
	comiss	xmm0, xmm8
	jbe	$LN3@stbtt__tes

; 3574 :       stbtt__tesselate_curve(points, num_points, x0,y0, (x0+x1)/2.0f,(y0+y1)/2.0f, mx,my, objspace_flatness_squared,n+1);

	movaps	xmm1, xmm3
	movaps	xmm0, xmm2
	addss	xmm1, xmm12
	inc	ebx
	mov	DWORD PTR [rsp+72], ebx
	addss	xmm0, xmm11
	movss	DWORD PTR [rsp+64], xmm8
	movss	DWORD PTR [rsp+56], xmm10
	movss	DWORD PTR [rsp+48], xmm9
	mulss	xmm1, xmm13
	mulss	xmm0, xmm13
	movss	DWORD PTR [rsp+40], xmm1
	movss	DWORD PTR [rsp+32], xmm0
	call	?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z ; stbtt__tesselate_curve

; 3575 :       stbtt__tesselate_curve(points, num_points, mx,my, (x1+x2)/2.0f,(y1+y2)/2.0f, x2,y2, objspace_flatness_squared,n+1);

	mov	DWORD PTR [rsp+72], ebx
	addss	xmm12, xmm7
	movss	DWORD PTR [rsp+64], xmm8
	addss	xmm11, xmm6
	movss	DWORD PTR [rsp+56], xmm7
	movaps	xmm3, xmm10
	movss	DWORD PTR [rsp+48], xmm6
	movaps	xmm2, xmm9
	mov	rdx, rsi
	mov	rcx, rdi
	mulss	xmm12, xmm13
	mulss	xmm11, xmm13
	movss	DWORD PTR [rsp+40], xmm12
	movss	DWORD PTR [rsp+32], xmm11
	call	?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z ; stbtt__tesselate_curve

; 3576 :    } else {

	jmp	SHORT $LN15@stbtt__tes
$LN3@stbtt__tes:

; 3577 :       stbtt__add_point(points, *num_points,x2,y2);

	movsxd	rcx, DWORD PTR [rdx]

; 3557 :    if (!points) return; // during first pass, it's unallocated

	test	rdi, rdi
	je	SHORT $LN6@stbtt__tes

; 3558 :    points[n].x = x;

	movss	DWORD PTR [rdi+rcx*8], xmm6

; 3559 :    points[n].y = y;

	movss	DWORD PTR [rdi+rcx*8+4], xmm7
$LN6@stbtt__tes:

; 3578 :       *num_points = *num_points+1;

	lea	eax, DWORD PTR [rcx+1]
	mov	DWORD PTR [rdx], eax
$LN15@stbtt__tes:
	movaps	xmm8, XMMWORD PTR [rsp+160]
$LN10@stbtt__tes:

; 3579 :    }
; 3580 :    return 1;
; 3581 : }

	lea	r11, QWORD PTR [rsp+208]
	mov	eax, 1
	mov	rbx, QWORD PTR [r11+16]
	mov	rsi, QWORD PTR [r11+24]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	mov	rsp, r11
	pop	rdi
	ret	0
?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z ENDP ; stbtt__tesselate_curve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z
_TEXT	SEGMENT
points$ = 272
num_points$ = 280
x0$ = 288
y0$ = 296
x1$ = 304
y1$ = 312
x2$ = 320
y2$ = 328
x3$ = 336
y3$ = 344
objspace_flatness_squared$ = 352
n$ = 360
?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z PROC ; stbtt__tesselate_cubic, COMDAT

; 3584 : {

	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rsi
	movss	DWORD PTR [rax+32], xmm3
	movss	DWORD PTR [rax+24], xmm2
	push	rdi
	sub	rsp, 256				; 00000100H

; 3585 :    // @TODO this "flatness" calculation is just made-up nonsense that seems to work well enough
; 3586 :    float dx0 = x1-x0;
; 3587 :    float dy0 = y1-y0;
; 3588 :    float dx1 = x2-x1;

	movss	xmm4, DWORD PTR x2$[rsp]
	movaps	xmm5, xmm3

; 3589 :    float dy1 = y2-y1;
; 3590 :    float dx2 = x3-x2;

	movss	xmm3, DWORD PTR x3$[rsp]
	movaps	xmm0, xmm4
	movaps	XMMWORD PTR [rax-24], xmm6
	mov	rsi, rdx
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	xmm6, xmm2
	movss	xmm2, DWORD PTR y2$[rsp]
	mov	rdi, rcx
	movaps	XMMWORD PTR [rax-56], xmm8
	movaps	xmm1, xmm2
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-104], xmm11

; 3591 :    float dy2 = y3-y2;
; 3592 :    float dx = x3-x0;

	movaps	xmm11, xmm3
	movaps	XMMWORD PTR [rax-120], xmm12
	subss	xmm11, xmm6
	movaps	XMMWORD PTR [rsp+112], xmm14
	movaps	xmm12, xmm3
	movss	xmm14, DWORD PTR x1$[rsp]
	subss	xmm12, xmm4
	movss	xmm4, DWORD PTR y3$[rsp]
	subss	xmm0, xmm14
	movaps	XMMWORD PTR [rsp+96], xmm15
	movaps	xmm10, xmm14
	movss	xmm15, DWORD PTR y1$[rsp]
	subss	xmm10, xmm6
	subss	xmm1, xmm15
	movaps	xmm7, xmm15
	movaps	xmm9, xmm4
	subss	xmm7, xmm5

; 3593 :    float dy = y3-y0;
; 3594 :    float longlen = (float) (STBTT_sqrt(dx0*dx0+dy0*dy0)+STBTT_sqrt(dx1*dx1+dy1*dy1)+STBTT_sqrt(dx2*dx2+dy2*dy2));

	mulss	xmm0, xmm0
	subss	xmm9, xmm2
	movaps	xmm8, xmm4
	mulss	xmm1, xmm1
	subss	xmm8, xmm5
	addss	xmm1, xmm0
	xorps	xmm0, xmm0
	ucomiss	xmm0, xmm1
	ja	SHORT $LN29@stbtt__tes
	xorps	xmm6, xmm6
	sqrtss	xmm6, xmm1
	jmp	SHORT $LN30@stbtt__tes
$LN29@stbtt__tes:
	movaps	xmm0, xmm1
	call	sqrtf
	movaps	xmm6, xmm0
$LN30@stbtt__tes:
	mulss	xmm7, xmm7
	xorps	xmm0, xmm0
	mulss	xmm10, xmm10
	addss	xmm7, xmm10
	ucomiss	xmm0, xmm7
	ja	SHORT $LN27@stbtt__tes
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm7
	jmp	SHORT $LN28@stbtt__tes
$LN27@stbtt__tes:
	movaps	xmm0, xmm7
	call	sqrtf
$LN28@stbtt__tes:
	mulss	xmm9, xmm9
	addss	xmm6, xmm0
	mulss	xmm12, xmm12
	xorps	xmm0, xmm0
	addss	xmm9, xmm12
	ucomiss	xmm0, xmm9
	ja	SHORT $LN25@stbtt__tes
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm9
	jmp	SHORT $LN26@stbtt__tes
$LN25@stbtt__tes:
	movaps	xmm0, xmm9
	call	sqrtf
$LN26@stbtt__tes:

; 3595 :    float shortlen = (float) STBTT_sqrt(dx*dx+dy*dy);

	mulss	xmm8, xmm8
	addss	xmm6, xmm0
	mulss	xmm11, xmm11
	xorps	xmm0, xmm0
	addss	xmm8, xmm11
	ucomiss	xmm0, xmm8
	ja	SHORT $LN23@stbtt__tes
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm8
	jmp	SHORT $LN24@stbtt__tes
$LN23@stbtt__tes:
	movaps	xmm0, xmm8
	call	sqrtf
$LN24@stbtt__tes:

; 3596 :    float flatness_squared = longlen*longlen-shortlen*shortlen;
; 3597 : 
; 3598 :    if (n > 16) // 65536 segments on one curve better be enough!

	mov	ebx, DWORD PTR n$[rsp]
	mulss	xmm6, xmm6
	mulss	xmm0, xmm0
	subss	xmm6, xmm0
	cmp	ebx, 16
	jg	$LN4@stbtt__tes
	movss	xmm8, DWORD PTR __real@3f000000
	movaps	XMMWORD PTR [rsp+128], xmm13
	movss	xmm13, DWORD PTR objspace_flatness_squared$[rsp]
	npad	8
$LL9@stbtt__tes:

; 3600 : 
; 3601 :    if (flatness_squared > objspace_flatness_squared) {

	comiss	xmm6, xmm13
	jbe	$LN3@stbtt__tes

; 3602 :       float x01 = (x0+x1)/2;
; 3603 :       float y01 = (y0+y1)/2;
; 3604 :       float x12 = (x1+x2)/2;
; 3605 :       float y12 = (y1+y2)/2;

	movss	xmm12, DWORD PTR y2$[rsp]

; 3606 :       float x23 = (x2+x3)/2;
; 3607 :       float y23 = (y2+y3)/2;
; 3608 : 
; 3609 :       float xa = (x01+x12)/2;
; 3610 :       float ya = (y01+y12)/2;
; 3611 :       float xb = (x12+x23)/2;
; 3612 :       float yb = (y12+y23)/2;
; 3613 : 
; 3614 :       float mx = (xa+xb)/2;
; 3615 :       float my = (ya+yb)/2;
; 3616 : 
; 3617 :       stbtt__tesselate_cubic(points, num_points, x0,y0, x01,y01, xa,ya, mx,my, objspace_flatness_squared,n+1);

	inc	ebx
	movss	xmm9, DWORD PTR x2$[rsp]
	mov	rdx, rsi
	movss	xmm10, DWORD PTR y0$[rsp]
	mov	rcx, rdi
	movss	xmm11, DWORD PTR x0$[rsp]
	movaps	xmm4, xmm10
	addss	xmm4, xmm15
	mov	DWORD PTR [rsp+88], ebx
	addss	xmm15, xmm12
	movss	DWORD PTR [rsp+80], xmm13
	addss	xmm12, DWORD PTR y3$[rsp]
	movaps	xmm5, xmm11
	addss	xmm5, xmm14
	addss	xmm14, xmm9
	mulss	xmm4, xmm8
	addss	xmm9, DWORD PTR x3$[rsp]
	mulss	xmm15, xmm8
	mulss	xmm14, xmm8
	movaps	xmm1, xmm15
	mulss	xmm12, xmm8
	mulss	xmm9, xmm8
	movaps	xmm2, xmm1
	movaps	xmm0, xmm14
	mulss	xmm5, xmm8
	movaps	xmm15, xmm12
	movss	DWORD PTR y2$[rsp], xmm12
	movaps	xmm14, xmm9
	movss	DWORD PTR x2$[rsp], xmm9
	addss	xmm15, xmm1
	movaps	xmm3, xmm0
	addss	xmm14, xmm0
	addss	xmm2, xmm4
	addss	xmm3, xmm5
	mulss	xmm15, xmm8
	mulss	xmm2, xmm8
	mulss	xmm3, xmm8
	movaps	xmm6, xmm15
	addss	xmm6, xmm2
	mulss	xmm14, xmm8
	movaps	xmm7, xmm14
	addss	xmm7, xmm3
	mulss	xmm6, xmm8
	movss	DWORD PTR [rsp+72], xmm6
	mulss	xmm7, xmm8
	movss	DWORD PTR [rsp+64], xmm7
	movss	DWORD PTR [rsp+56], xmm2
	movaps	xmm2, xmm11
	movss	DWORD PTR [rsp+48], xmm3
	movaps	xmm3, xmm10
	movss	DWORD PTR [rsp+40], xmm4
	movss	DWORD PTR [rsp+32], xmm5
	call	?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z ; stbtt__tesselate_cubic
	movss	xmm2, DWORD PTR x3$[rsp]
	movaps	xmm0, xmm9
	movss	xmm3, DWORD PTR y3$[rsp]
	subss	xmm0, xmm14
	movaps	xmm1, xmm12

; 3618 :       stbtt__tesselate_cubic(points, num_points, mx,my, xb,yb, x23,y23, x3,y3, objspace_flatness_squared,n+1);

	movss	DWORD PTR x0$[rsp], xmm7
	subss	xmm1, xmm15
	movss	DWORD PTR y0$[rsp], xmm6
	movaps	xmm11, xmm2
	movaps	xmm10, xmm14
	subss	xmm11, xmm9
	movaps	xmm8, xmm15
	mulss	xmm0, xmm0
	subss	xmm10, xmm7
	mulss	xmm1, xmm1
	movaps	xmm9, xmm3
	subss	xmm8, xmm6
	subss	xmm9, xmm12
	movaps	xmm12, xmm2
	addss	xmm1, xmm0
	xorps	xmm0, xmm0
	subss	xmm12, xmm7
	movaps	xmm7, xmm3
	subss	xmm7, xmm6
	ucomiss	xmm0, xmm1
	ja	SHORT $LN21@stbtt__tes

; 3593 :    float dy = y3-y0;
; 3594 :    float longlen = (float) (STBTT_sqrt(dx0*dx0+dy0*dy0)+STBTT_sqrt(dx1*dx1+dy1*dy1)+STBTT_sqrt(dx2*dx2+dy2*dy2));

	xorps	xmm6, xmm6
	sqrtss	xmm6, xmm1
	jmp	SHORT $LN22@stbtt__tes
$LN21@stbtt__tes:
	movaps	xmm0, xmm1
	call	sqrtf
	movaps	xmm6, xmm0
$LN22@stbtt__tes:
	mulss	xmm8, xmm8
	xorps	xmm0, xmm0
	mulss	xmm10, xmm10
	addss	xmm8, xmm10
	ucomiss	xmm0, xmm8
	ja	SHORT $LN19@stbtt__tes
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm8
	jmp	SHORT $LN20@stbtt__tes
$LN19@stbtt__tes:
	movaps	xmm0, xmm8
	call	sqrtf
$LN20@stbtt__tes:
	mulss	xmm9, xmm9
	addss	xmm6, xmm0
	mulss	xmm11, xmm11
	xorps	xmm0, xmm0
	addss	xmm9, xmm11
	ucomiss	xmm0, xmm9
	ja	SHORT $LN17@stbtt__tes
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm9
	jmp	SHORT $LN18@stbtt__tes
$LN17@stbtt__tes:
	movaps	xmm0, xmm9
	call	sqrtf
$LN18@stbtt__tes:

; 3595 :    float shortlen = (float) STBTT_sqrt(dx*dx+dy*dy);

	mulss	xmm7, xmm7
	addss	xmm6, xmm0
	mulss	xmm12, xmm12
	xorps	xmm0, xmm0
	addss	xmm7, xmm12
	ucomiss	xmm0, xmm7
	ja	SHORT $LN15@stbtt__tes
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm7
	jmp	SHORT $LN16@stbtt__tes
$LN15@stbtt__tes:
	movaps	xmm0, xmm7
	call	sqrtf
$LN16@stbtt__tes:

; 3596 :    float flatness_squared = longlen*longlen-shortlen*shortlen;
; 3597 : 
; 3598 :    if (n > 16) // 65536 segments on one curve better be enough!

	movss	xmm8, DWORD PTR __real@3f000000
	mulss	xmm6, xmm6
	mulss	xmm0, xmm0
	subss	xmm6, xmm0
	cmp	ebx, 16
	jle	$LL9@stbtt__tes

; 3599 :       return;

	jmp	SHORT $LN42@stbtt__tes
$LN3@stbtt__tes:

; 3619 :    } else {
; 3620 :       stbtt__add_point(points, *num_points,x3,y3);

	movsxd	rcx, DWORD PTR [rsi]

; 3557 :    if (!points) return; // during first pass, it's unallocated

	test	rdi, rdi
	je	SHORT $LN6@stbtt__tes

; 3558 :    points[n].x = x;

	movss	xmm2, DWORD PTR x3$[rsp]
	movss	DWORD PTR [rdi+rcx*8], xmm2

; 3559 :    points[n].y = y;

	movss	xmm2, DWORD PTR y3$[rsp]
	movss	DWORD PTR [rdi+rcx*8+4], xmm2
$LN6@stbtt__tes:

; 3621 :       *num_points = *num_points+1;

	lea	eax, DWORD PTR [rcx+1]
	mov	DWORD PTR [rsi], eax
$LN42@stbtt__tes:
	movaps	xmm13, XMMWORD PTR [rsp+128]
$LN4@stbtt__tes:

; 3622 :    }
; 3623 : }

	movaps	xmm14, XMMWORD PTR [rsp+112]
	lea	r11, QWORD PTR [rsp+256]
	mov	rbx, QWORD PTR [r11+16]
	mov	rsi, QWORD PTR [r11+24]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm15, XMMWORD PTR [rsp+96]
	mov	rsp, r11
	pop	rdi
	ret	0
?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z ENDP ; stbtt__tesselate_cubic
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z
_TEXT	SEGMENT
tv1063 = 96
vertices$GSCopy$1$ = 104
num_contours$GSCopy$1$ = 112
num_points$ = 120
__$ArrayPad$ = 128
vertices$ = 288
num_verts$ = 296
objspace_flatness$ = 304
contour_lengths$ = 312
num_contours$ = 320
userdata$dead$ = 328
?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z PROC ; stbtt_FlattenCurves, COMDAT

; 3627 : {

	mov	QWORD PTR [rsp+16], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 224				; 000000e0H
	movaps	XMMWORD PTR [rsp+144], xmm10
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbp, QWORD PTR num_contours$[rsp]

; 3628 :    stbtt__point *points=0;

	xor	r13d, r13d

; 3629 :    int num_points=0;
; 3630 : 
; 3631 :    float objspace_flatness_squared = objspace_flatness * objspace_flatness;
; 3632 :    int i,n=0,start=0, pass;
; 3633 : 
; 3634 :    // count how many "moves" there are to get the contour count
; 3635 :    for (i=0; i < num_verts; ++i)

	movsxd	r15, edx
	movaps	xmm10, xmm2
	mov	QWORD PTR vertices$GSCopy$1$[rsp], rcx
	mov	r12, r9
	mov	QWORD PTR num_contours$GSCopy$1$[rsp], rbp
	mov	rbx, rcx
	mulss	xmm10, xmm10
	mov	esi, r13d
	mov	QWORD PTR tv1063[rsp], r15
	mov	edi, r13d
	mov	r8d, r13d
	mov	r14d, r13d
	test	edx, edx
	jle	SHORT $LN3@stbtt_Flat
	add	rcx, 12
	mov	rdx, r15
	npad	11
$LL68@stbtt_Flat:
	cmp	BYTE PTR [rcx], 1
	lea	eax, DWORD PTR [r8+1]
	lea	rcx, QWORD PTR [rcx+14]
	cmovne	eax, r8d
	mov	r8d, eax
	sub	rdx, 1
	jne	SHORT $LL68@stbtt_Flat
$LN3@stbtt_Flat:

; 3636 :       if (vertices[i].type == STBTT_vmove)
; 3637 :          ++n;
; 3638 : 
; 3639 :    *num_contours = n;

	mov	DWORD PTR [rbp], r8d

; 3640 :    if (n == 0) return 0;

	test	r8d, r8d
	je	SHORT $LN100@stbtt_Flat
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN26@stbtt_Flat

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN26@stbtt_Flat:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 3642 :    *contour_lengths = (int *) STBTT_malloc(sizeof(**contour_lengths) * n, userdata);

	movsxd	rcx, r8d
	shl	rcx, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 3642 :    *contour_lengths = (int *) STBTT_malloc(sizeof(**contour_lengths) * n, userdata);

	mov	QWORD PTR [r12], rax

; 3643 : 
; 3644 :    if (*contour_lengths == 0) {

	test	rax, rax
	jne	SHORT $LN15@stbtt_Flat

; 3645 :       *num_contours = 0;

	mov	DWORD PTR [rbp], r13d
$LN100@stbtt_Flat:

; 3701 : }

	xor	eax, eax
	jmp	$LN1@stbtt_Flat
$LN15@stbtt_Flat:
	movaps	XMMWORD PTR [rsp+208], xmm6
	movaps	XMMWORD PTR [rsp+192], xmm7
	movaps	XMMWORD PTR [rsp+176], xmm8
	movaps	XMMWORD PTR [rsp+160], xmm9
	npad	10
$LL7@stbtt_Flat:
	xorps	xmm8, xmm8
	xorps	xmm9, xmm9

; 3646 :       return 0;
; 3647 :    }
; 3648 : 
; 3649 :    // make two passes through the points so we don't need to realloc
; 3650 :    for (pass=0; pass < 2; ++pass) {
; 3651 :       float x=0,y=0;
; 3652 :       if (pass == 1) {

	cmp	r13d, 1
	jne	SHORT $LN17@stbtt_Flat
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 3653 :          points = (stbtt__point *) STBTT_malloc(num_points * sizeof(points[0]), userdata);

	movsxd	rcx, edi
	shl	rcx, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN33@stbtt_Flat

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN33@stbtt_Flat:

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
	mov	rsi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 3654 :          if (points == NULL) goto error;

	test	rax, rax
	je	$error$102
$LN17@stbtt_Flat:

; 3655 :       }
; 3656 :       num_points = 0;

	xor	edi, edi
	mov	DWORD PTR num_points$[rsp], edi

; 3657 :       n= -1;

	lea	rbp, QWORD PTR [rdi-1]

; 3658 :       for (i=0; i < num_verts; ++i) {

	test	r15, r15
	jle	$LN9@stbtt_Flat

; 3655 :       }
; 3656 :       num_points = 0;

	add	rbx, 10
$LL10@stbtt_Flat:

; 3659 :          switch (vertices[i].type) {

	movzx	ecx, BYTE PTR [rbx+2]
	sub	ecx, 1
	je	$LN19@stbtt_Flat
	sub	ecx, 1
	je	$LN21@stbtt_Flat
	sub	ecx, 1
	je	$LN22@stbtt_Flat
	cmp	ecx, 1
	jne	$LN8@stbtt_Flat

; 3681 :             case STBTT_vcubic:
; 3682 :                stbtt__tesselate_cubic(points, &num_points, x,y,

	movsx	eax, WORD PTR [rbx-8]
	lea	rdx, QWORD PTR num_points$[rsp]
	mov	DWORD PTR [rsp+88], 0
	movaps	xmm3, xmm9
	movss	DWORD PTR [rsp+80], xmm10
	movaps	xmm2, xmm8
	mov	rcx, rsi
	movd	xmm7, eax
	movsx	eax, WORD PTR [rbx-10]
	cvtdq2ps xmm7, xmm7
	movd	xmm6, eax
	movsx	eax, WORD PTR [rbx]
	movss	DWORD PTR [rsp+72], xmm7
	cvtdq2ps xmm6, xmm6
	movd	xmm5, eax
	movsx	eax, WORD PTR [rbx-2]
	movss	DWORD PTR [rsp+64], xmm6
	cvtdq2ps xmm5, xmm5
	movd	xmm4, eax
	movsx	eax, WORD PTR [rbx-4]
	movss	DWORD PTR [rsp+56], xmm5
	cvtdq2ps xmm4, xmm4
	movd	xmm1, eax
	movsx	eax, WORD PTR [rbx-6]
	movss	DWORD PTR [rsp+48], xmm4
	cvtdq2ps xmm1, xmm1
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [rsp+40], xmm1
	movss	DWORD PTR [rsp+32], xmm0
	call	?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z ; stbtt__tesselate_cubic

; 3683 :                                         vertices[i].cx, vertices[i].cy,
; 3684 :                                         vertices[i].cx1, vertices[i].cy1,
; 3685 :                                         vertices[i].x,  vertices[i].y,
; 3686 :                                         objspace_flatness_squared, 0);
; 3687 :                x = vertices[i].x, y = vertices[i].y;

	movsx	eax, WORD PTR [rbx-10]
	mov	edi, DWORD PTR num_points$[rsp]
	movd	xmm8, eax
	movsx	eax, WORD PTR [rbx-8]
	cvtdq2ps xmm8, xmm8
	movd	xmm9, eax
	cvtdq2ps xmm9, xmm9
	jmp	$LN8@stbtt_Flat
$LN22@stbtt_Flat:

; 3674 :             case STBTT_vcurve:
; 3675 :                stbtt__tesselate_curve(points, &num_points, x,y,

	movsx	eax, WORD PTR [rbx-8]
	lea	rdx, QWORD PTR num_points$[rsp]
	mov	DWORD PTR [rsp+72], 0
	mov	rcx, rsi
	movss	DWORD PTR [rsp+64], xmm10
	movd	xmm3, eax
	movsx	eax, WORD PTR [rbx-10]
	cvtdq2ps xmm3, xmm3
	movd	xmm2, eax
	movsx	eax, WORD PTR [rbx-4]
	movss	DWORD PTR [rsp+56], xmm3
	movaps	xmm3, xmm9
	cvtdq2ps xmm2, xmm2
	movd	xmm1, eax
	movsx	eax, WORD PTR [rbx-6]
	movss	DWORD PTR [rsp+48], xmm2
	movaps	xmm2, xmm8
	cvtdq2ps xmm1, xmm1
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [rsp+40], xmm1
	movss	DWORD PTR [rsp+32], xmm0
	call	?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z ; stbtt__tesselate_curve

; 3676 :                                         vertices[i].cx, vertices[i].cy,
; 3677 :                                         vertices[i].x,  vertices[i].y,
; 3678 :                                         objspace_flatness_squared, 0);
; 3679 :                x = vertices[i].x, y = vertices[i].y;

	movsx	eax, WORD PTR [rbx-8]
	movsx	r8d, WORD PTR [rbx-10]

; 3680 :                break;

	mov	edi, DWORD PTR num_points$[rsp]
	movd	xmm9, eax
	movd	xmm8, r8d
	cvtdq2ps xmm9, xmm9
	cvtdq2ps xmm8, xmm8
	jmp	$LN8@stbtt_Flat
$LN21@stbtt_Flat:

; 3668 :                stbtt__add_point(points, num_points++, x,y);
; 3669 :                break;
; 3670 :             case STBTT_vline:
; 3671 :                x = vertices[i].x, y = vertices[i].y;

	movsx	eax, WORD PTR [rbx-10]
	movd	xmm8, eax
	movsx	eax, WORD PTR [rbx-8]
	cvtdq2ps xmm8, xmm8
	movd	xmm9, eax

; 3672 :                stbtt__add_point(points, num_points++, x, y);

	movsxd	rax, edi
	cvtdq2ps xmm9, xmm9
	lea	edi, DWORD PTR [rax+1]
	mov	DWORD PTR num_points$[rsp], edi

; 3557 :    if (!points) return; // during first pass, it's unallocated

	test	rsi, rsi
	je	SHORT $LN8@stbtt_Flat

; 3558 :    points[n].x = x;

	movss	DWORD PTR [rsi+rax*8], xmm8

; 3559 :    points[n].y = y;

	movss	DWORD PTR [rsi+rax*8+4], xmm9

; 3673 :                break;

	jmp	SHORT $LN8@stbtt_Flat
$LN19@stbtt_Flat:

; 3660 :             case STBTT_vmove:
; 3661 :                // start the next contour
; 3662 :                if (n >= 0)

	test	rbp, rbp
	js	SHORT $LN20@stbtt_Flat

; 3663 :                   (*contour_lengths)[n] = num_points - start;

	mov	rax, QWORD PTR [r12]
	mov	ecx, edi
	sub	ecx, r14d
	mov	DWORD PTR [rax+rbp*4], ecx
$LN20@stbtt_Flat:

; 3664 :                ++n;
; 3665 :                start = num_points;
; 3666 : 
; 3667 :                x = vertices[i].x, y = vertices[i].y;

	movsx	eax, WORD PTR [rbx-10]
	inc	rbp
	movsxd	r14, edi
	movd	xmm8, eax
	movsx	eax, WORD PTR [rbx-8]
	lea	edi, DWORD PTR [r14+1]
	mov	DWORD PTR num_points$[rsp], edi
	cvtdq2ps xmm8, xmm8
	movd	xmm9, eax
	cvtdq2ps xmm9, xmm9

; 3557 :    if (!points) return; // during first pass, it's unallocated

	test	rsi, rsi
	je	SHORT $LN8@stbtt_Flat

; 3558 :    points[n].x = x;

	movss	DWORD PTR [rsi+r14*8], xmm8

; 3559 :    points[n].y = y;

	movss	DWORD PTR [rsi+r14*8+4], xmm9
$LN8@stbtt_Flat:

; 3658 :       for (i=0; i < num_verts; ++i) {

	add	rbx, 14
	sub	r15, 1
	jne	$LL10@stbtt_Flat
	mov	r15, QWORD PTR tv1063[rsp]
	mov	rbx, QWORD PTR vertices$GSCopy$1$[rsp]
$LN9@stbtt_Flat:

; 3688 :                break;
; 3689 :          }
; 3690 :       }
; 3691 :       (*contour_lengths)[n] = num_points - start;

	mov	rax, QWORD PTR [r12]
	mov	ecx, edi
	sub	ecx, r14d
	inc	r13d
	mov	DWORD PTR [rax+rbp*4], ecx
	cmp	r13d, 2
	jl	$LL7@stbtt_Flat

; 3692 :    }
; 3693 : 
; 3694 :    return points;

	mov	rax, rsi
$LN99@stbtt_Flat:
	movaps	xmm8, XMMWORD PTR [rsp+176]
	movaps	xmm7, XMMWORD PTR [rsp+192]
	movaps	xmm6, XMMWORD PTR [rsp+208]
	movaps	xmm9, XMMWORD PTR [rsp+160]
$LN1@stbtt_Flat:

; 3701 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+224]
	mov	rbx, QWORD PTR [r11+72]
	movaps	xmm10, XMMWORD PTR [r11-80]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$error$102:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	xor	ecx, ecx
	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 3697 :    STBTT_free(*contour_lengths, userdata);

	mov	rcx, QWORD PTR [r12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	test	rcx, rcx
	je	SHORT $LN55@stbtt_Flat

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN55@stbtt_Flat

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN55@stbtt_Flat:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 3699 :    *num_contours = 0;

	mov	rax, QWORD PTR num_contours$GSCopy$1$[rsp]
	xor	r13d, r13d
	mov	QWORD PTR [r12], r13
	mov	DWORD PTR [rax], r13d

; 3700 :    return NULL;

	xor	eax, eax
	jmp	$LN99@stbtt_Flat
?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z ENDP ; stbtt_FlattenCurves
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT stbtt_Rasterize
_TEXT	SEGMENT
result$ = 144
winding_count$ = 152
flatness_in_pixels$ = 152
vertices$ = 160
num_verts$ = 168
scale_x$ = 176
scale_y$ = 184
shift_x$ = 192
shift_y$ = 200
x_off$ = 208
y_off$ = 216
invert$dead$ = 224
userdata$dead$ = 232
winding_lengths$ = 232
stbtt_Rasterize PROC					; COMDAT

; 3704 : {

	mov	r11, rsp
	mov	QWORD PTR [r11+8], rsi
	push	rdi
	sub	rsp, 128				; 00000080H
	movaps	XMMWORD PTR [rsp+112], xmm6

; 3705 :    float scale            = scale_x > scale_y ? scale_y : scale_x;
; 3706 :    int winding_count      = 0;

	xor	eax, eax
	movss	xmm6, DWORD PTR scale_y$[rsp]
	mov	edx, r9d
	movaps	XMMWORD PTR [rsp+96], xmm7

; 3707 :    int *winding_lengths   = NULL;
; 3708 :    stbtt__point *windings = stbtt_FlattenCurves(vertices, num_verts, flatness_in_pixels / scale, &winding_lengths, &winding_count, userdata);

	lea	r9, QWORD PTR [r11+96]
	movss	xmm7, DWORD PTR scale_x$[rsp]
	movaps	xmm0, xmm6
	minss	xmm0, xmm7
	mov	DWORD PTR [r11+16], eax
	mov	QWORD PTR [r11+96], rax
	mov	rsi, rcx
	lea	rax, QWORD PTR [r11+16]
	mov	rcx, r8
	mov	QWORD PTR [r11-104], rax
	divss	xmm1, xmm0
	movaps	xmm2, xmm1
	call	?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z ; stbtt_FlattenCurves
	mov	rdi, rax

; 3709 :    if (windings) {

	test	rax, rax
	je	$LN18@stbtt_Rast

; 3710 :       stbtt__rasterize(result, windings, winding_lengths, winding_count, scale_x, scale_y, shift_x, shift_y, x_off, y_off, invert, userdata);

	mov	ecx, DWORD PTR y_off$[rsp]
	mov	rdx, rax
	movss	xmm0, DWORD PTR shift_y$[rsp]
	movss	xmm1, DWORD PTR shift_x$[rsp]
	mov	r9d, DWORD PTR winding_count$[rsp]
	mov	r8, QWORD PTR winding_lengths$[rsp]
	mov	DWORD PTR [rsp+72], ecx
	mov	ecx, DWORD PTR x_off$[rsp]
	mov	DWORD PTR [rsp+64], ecx
	mov	rcx, rsi
	movss	DWORD PTR [rsp+56], xmm0
	movss	DWORD PTR [rsp+48], xmm1
	movss	DWORD PTR [rsp+40], xmm6
	movss	DWORD PTR [rsp+32], xmm7
	call	?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z ; stbtt__rasterize
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	cmp	QWORD PTR winding_lengths$[rsp], 0
	je	SHORT $LN8@stbtt_Rast

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN8@stbtt_Rast

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN8@stbtt_Rast:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	mov	rcx, QWORD PTR winding_lengths$[rsp]
	call	QWORD PTR __imp_free

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN16@stbtt_Rast

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN16@stbtt_Rast:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	mov	rcx, rdi
	call	QWORD PTR __imp_free
$LN18@stbtt_Rast:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 3714 : }

	mov	rsi, QWORD PTR [rsp+144]
	movaps	xmm6, XMMWORD PTR [rsp+112]
	movaps	xmm7, XMMWORD PTR [rsp+96]
	add	rsp, 128				; 00000080H
	pop	rdi
	ret	0
stbtt_Rasterize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT stbtt_MakeGlyphBitmapSubpixel
_TEXT	SEGMENT
winding_count$1 = 96
iy0$ = 100
ix0$ = 104
winding_lengths$2 = 112
gbm$ = 120
vertices$ = 144
__$ArrayPad$ = 152
info$ = 288
output$ = 296
out_w$ = 304
out_h$ = 312
out_stride$ = 320
scale_x$ = 328
scale_y$ = 336
shift_x$ = 344
shift_y$ = 352
glyph$ = 360
stbtt_MakeGlyphBitmapSubpixel PROC			; COMDAT

; 3767 : {

	mov	rax, rsp
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 224				; 000000e0H
	movaps	XMMWORD PTR [rax-72], xmm6
	movaps	XMMWORD PTR [rax-88], xmm7
	movaps	XMMWORD PTR [rax-104], xmm8
	movaps	XMMWORD PTR [rax-120], xmm9
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	ebp, r8d
	mov	rsi, rdx

; 3768 :    int ix0,iy0;
; 3769 :    stbtt_vertex *vertices;
; 3770 :    int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);

	mov	edx, DWORD PTR glyph$[rsp]
	lea	r8, QWORD PTR vertices$[rsp]
	mov	r14d, r9d
	mov	rdi, rcx
	call	stbtt_GetGlyphShape

; 3771 :    stbtt__bitmap gbm;
; 3772 : 
; 3773 :    stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,0,0);

	movss	xmm8, DWORD PTR shift_y$[rsp]
	mov	r15d, eax
	movss	xmm6, DWORD PTR scale_y$[rsp]
	lea	rax, QWORD PTR iy0$[rsp]
	movss	xmm7, DWORD PTR scale_x$[rsp]
	xor	r12d, r12d
	movss	xmm9, DWORD PTR shift_x$[rsp]
	movaps	xmm3, xmm6
	mov	edx, DWORD PTR glyph$[rsp]
	movaps	xmm2, xmm7
	mov	QWORD PTR [rsp+72], r12
	mov	rcx, rdi
	mov	QWORD PTR [rsp+64], r12
	mov	QWORD PTR [rsp+56], rax
	lea	rax, QWORD PTR ix0$[rsp]
	mov	QWORD PTR [rsp+48], rax
	movss	DWORD PTR [rsp+40], xmm8
	movss	DWORD PTR [rsp+32], xmm9
	call	stbtt_GetGlyphBitmapBoxSubpixel

; 3774 :    gbm.pixels = output;
; 3775 :    gbm.w = out_w;
; 3776 :    gbm.h = out_h;
; 3777 :    gbm.stride = out_stride;

	mov	eax, DWORD PTR out_stride$[rsp]
	mov	DWORD PTR gbm$[rsp+8], eax
	mov	QWORD PTR gbm$[rsp+16], rsi
	mov	DWORD PTR gbm$[rsp], ebp
	mov	DWORD PTR gbm$[rsp+4], r14d
	test	ebp, ebp

; 3778 : 
; 3779 :    if (gbm.w && gbm.h)

	je	$LN21@stbtt_Make
	test	r14d, r14d
	je	$LN21@stbtt_Make

; 3708 :    stbtt__point *windings = stbtt_FlattenCurves(vertices, num_verts, flatness_in_pixels / scale, &winding_lengths, &winding_count, userdata);

	movss	xmm2, DWORD PTR __real@3eb33333
	lea	rax, QWORD PTR winding_count$1[rsp]
	mov	rcx, QWORD PTR vertices$[rsp]
	lea	r9, QWORD PTR winding_lengths$2[rsp]
	movaps	xmm0, xmm6
	mov	DWORD PTR winding_count$1[rsp], r12d
	minss	xmm0, xmm7
	mov	QWORD PTR winding_lengths$2[rsp], r12
	mov	edx, r15d
	mov	QWORD PTR [rsp+32], rax
	divss	xmm2, xmm0
	call	?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z ; stbtt_FlattenCurves
	mov	rdi, rax

; 3709 :    if (windings) {

	test	rax, rax
	je	SHORT $LN21@stbtt_Make

; 3710 :       stbtt__rasterize(result, windings, winding_lengths, winding_count, scale_x, scale_y, shift_x, shift_y, x_off, y_off, invert, userdata);

	mov	ecx, DWORD PTR iy0$[rsp]
	mov	rdx, rax
	mov	rbx, QWORD PTR winding_lengths$2[rsp]
	mov	r9d, DWORD PTR winding_count$1[rsp]
	mov	r8, rbx
	mov	DWORD PTR [rsp+72], ecx
	mov	ecx, DWORD PTR ix0$[rsp]
	mov	DWORD PTR [rsp+64], ecx
	lea	rcx, QWORD PTR gbm$[rsp]
	movss	DWORD PTR [rsp+56], xmm8
	movss	DWORD PTR [rsp+48], xmm9
	movss	DWORD PTR [rsp+40], xmm6
	movss	DWORD PTR [rsp+32], xmm7
	call	?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z ; stbtt__rasterize
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	test	rbx, rbx
	je	SHORT $LN11@stbtt_Make

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN11@stbtt_Make

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN11@stbtt_Make:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	mov	rcx, rbx
	call	QWORD PTR __imp_free

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN19@stbtt_Make

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN19@stbtt_Make:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	mov	rcx, rdi
	call	QWORD PTR __imp_free
$LN21@stbtt_Make:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 3782 :    STBTT_free(vertices, info->userdata);

	mov	rcx, QWORD PTR vertices$[rsp]
	test	rcx, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	je	SHORT $LN27@stbtt_Make

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN27@stbtt_Make

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN27@stbtt_Make:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 3783 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+224]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
stbtt_MakeGlyphBitmapSubpixel ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT stbtt_PackBegin
_TEXT	SEGMENT
spc$ = 64
pixels$dead$ = 72
pw$ = 80
ph$dead$ = 88
stride_in_bytes$dead$ = 96
padding$ = 104
alloc_context$dead$ = 112
stbtt_PackBegin PROC					; COMDAT

; 3966 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 48					; 00000030H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 3966 : {

	mov	ebp, r8d
	mov	rbx, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN9@stbtt_Pack

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN9@stbtt_Pack:

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	mov	ecx, 72					; 00000048H
	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 3968 :    int            num_nodes = pw - padding;

	mov	r14d, DWORD PTR padding$[rsp]
	mov	edi, ebp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 3968 :    int            num_nodes = pw - padding;

	sub	edi, r14d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	mov	rsi, rax

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	rcx, rcx
	je	SHORT $LN16@stbtt_Pack

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rcx+244]
$LN16@stbtt_Pack:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 3969 :    stbrp_node    *nodes   = (stbrp_node    *) STBTT_malloc(sizeof(*nodes  ) * num_nodes,alloc_context);

	movsxd	rcx, edi
	shl	rcx, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
	mov	r9, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 3971 :    if (context == NULL || nodes == NULL) {

	test	rsi, rsi
	je	SHORT $LN26@stbtt_Pack
	test	rax, rax
	je	SHORT $LN3@stbtt_Pack

; 3975 :    }
; 3976 : 
; 3977 :    spc->user_allocator_context = alloc_context;

	xor	eax, eax

; 3978 :    spc->width = pw;

	mov	DWORD PTR [rbx+16], ebp

; 3979 :    spc->height = ph;

	mov	r8d, 32768				; 00008000H
	mov	QWORD PTR [rbx], rax
	mov	DWORD PTR [rbx+20], r8d

; 3980 :    spc->pixels = pixels;
; 3981 :    spc->pack_info = context;
; 3982 :    spc->nodes = nodes;
; 3983 :    spc->padding = padding;
; 3984 :    spc->stride_in_bytes = stride_in_bytes != 0 ? stride_in_bytes : pw;
; 3985 :    spc->h_oversample = 1;
; 3986 :    spc->v_oversample = 1;
; 3987 :    spc->skip_missing = 0;
; 3988 : 
; 3989 :    stbrp_init_target(context, pw-padding, ph-padding, nodes, num_nodes);

	mov	edx, edi
	sub	r8d, r14d
	mov	QWORD PTR [rbx+48], rax
	mov	rcx, rsi
	mov	QWORD PTR [rbx+8], rsi
	mov	QWORD PTR [rbx+56], r9
	mov	DWORD PTR [rbx+28], r14d
	mov	DWORD PTR [rbx+24], ebp
	mov	DWORD PTR [rbx+36], 1
	mov	DWORD PTR [rbx+40], 1
	mov	DWORD PTR [rbx+32], eax
	mov	DWORD PTR [rsp+32], edi
	call	stbrp_init_target

; 3990 : 
; 3991 :    if (pixels)
; 3992 :       STBTT_memset(pixels, 0, pw*ph); // background of 0 around pixels
; 3993 : 
; 3994 :    return 1;

	mov	eax, 1
	jmp	SHORT $LN1@stbtt_Pack
$LN3@stbtt_Pack:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN24@stbtt_Pack

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN24@stbtt_Pack:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	mov	rcx, rsi
	jmp	SHORT $LN45@stbtt_Pack
$LN26@stbtt_Pack:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 3973 :       if (nodes   != NULL) STBTT_free(nodes  , alloc_context);

	test	r9, r9
	je	SHORT $LN34@stbtt_Pack
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN32@stbtt_Pack

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN32@stbtt_Pack:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	mov	rcx, r9
$LN45@stbtt_Pack:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 3974 :       return 0;

	call	QWORD PTR __imp_free
$LN34@stbtt_Pack:
	xor	eax, eax
$LN1@stbtt_Pack:

; 3995 : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	r14
	ret	0
stbtt_PackBegin ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT stbtt_PackEnd
_TEXT	SEGMENT
spc$ = 48
stbtt_PackEnd PROC					; COMDAT

; 3998 : {

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 3999 :    STBTT_free(spc->nodes    , spc->user_allocator_context);

	mov	rcx, QWORD PTR [rcx+56]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	test	rcx, rcx
	je	SHORT $LN5@stbtt_Pack

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN5@stbtt_Pack

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN5@stbtt_Pack:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 4000 :    STBTT_free(spc->pack_info, spc->user_allocator_context);

	mov	rcx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	test	rcx, rcx
	je	SHORT $LN13@stbtt_Pack

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN13@stbtt_Pack

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN13@stbtt_Pack:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 4001 : }

	add	rsp, 32					; 00000020H
	pop	rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	rex_jmp	QWORD PTR __imp_free
stbtt_PackEnd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__h_prefilter@@YAXPEAEHHHI@Z
_TEXT	SEGMENT
buffer$ = 32
__$ArrayPad$ = 40
pixels$ = 96
w$ = 104
h$ = 112
stride_in_bytes$ = 120
kernel_width$ = 128
?stbtt__h_prefilter@@YAXPEAEHHHI@Z PROC			; stbtt__h_prefilter, COMDAT

; 4024 :    int j;
; 4025 :    STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze
; 4026 :    for (j=0; j < h; ++j) {

	test	r8d, r8d
	jle	$LN73@stbtt__h_p
	push	rbx
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 4021 : {

	mov	esi, DWORD PTR kernel_width$[rsp]

; 4022 :    unsigned char buffer[STBTT_MAX_OVERSAMPLE];
; 4023 :    int safe_w = w - kernel_width;

	mov	eax, edx

; 4024 :    int j;
; 4025 :    STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze
; 4026 :    for (j=0; j < h; ++j) {

	mov	QWORD PTR [rsp+104], rbp
	sub	eax, esi
	mov	QWORD PTR [rsp+112], r12
	mov	r14d, edx
	mov	QWORD PTR [rsp+48], r15
	mov	rdi, rcx

; 4063 :          default:
; 4064 :             for (i=0; i <= safe_w; ++i) {

	movsxd	rbx, eax
	mov	QWORD PTR buffer$[rsp], 0
	movsxd	r15, r9d
	mov	ebp, r8d
	npad	13
$LL4@stbtt__h_p:

; 4027 :       int i;
; 4028 :       unsigned int total;
; 4029 :       STBTT_memset(buffer, 0, kernel_width);

	mov	r8, rsi
	lea	rcx, QWORD PTR buffer$[rsp]
	xor	edx, edx
	call	memset

; 4030 : 
; 4031 :       total = 0;

	xor	r9d, r9d

; 4032 : 
; 4033 :       // make kernel_width a constant in common cases so compiler can optimize out the divide
; 4034 :       switch (kernel_width) {

	mov	eax, esi
	sub	eax, 2
	je	$LN28@stbtt__h_p
	sub	eax, 1
	je	$LN29@stbtt__h_p
	sub	eax, 1
	je	$LN30@stbtt__h_p
	xor	ecx, ecx
	cmp	eax, 1
	je	SHORT $LN31@stbtt__h_p

; 4063 :          default:
; 4064 :             for (i=0; i <= safe_w; ++i) {

	test	rbx, rbx
	js	$LN8@stbtt__h_p
	mov	r10, rdi
	lea	r11, QWORD PTR [rbx+1]
	npad	10
$LL21@stbtt__h_p:

; 4065 :                total += pixels[i] - buffer[i & STBTT__OVER_MASK];

	movzx	r8d, BYTE PTR [r10]
	lea	r10, QWORD PTR [r10+1]
	movsxd	rax, ecx
	mov	edx, r8d
	and	eax, 7
	movzx	eax, BYTE PTR buffer$[rsp+rax]
	sub	edx, eax

; 4066 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];

	lea	eax, DWORD PTR [rsi+rcx]
	and	eax, 7
	add	r9d, edx

; 4067 :                pixels[i] = (unsigned char) (total / kernel_width);

	xor	edx, edx
	inc	ecx
	mov	BYTE PTR buffer$[rsp+rax], r8b
	mov	eax, r9d
	div	esi
	mov	BYTE PTR [r10-1], al
	sub	r11, 1
	jne	SHORT $LL21@stbtt__h_p

; 4063 :          default:
; 4064 :             for (i=0; i <= safe_w; ++i) {

	jmp	$LN8@stbtt__h_p
$LN31@stbtt__h_p:

; 4056 :          case 5:
; 4057 :             for (i=0; i <= safe_w; ++i) {

	test	rbx, rbx
	js	$LN8@stbtt__h_p
	mov	r10, rdi
	lea	r11, QWORD PTR [rbx+1]
	npad	2
$LL18@stbtt__h_p:

; 4058 :                total += pixels[i] - buffer[i & STBTT__OVER_MASK];

	movzx	r8d, BYTE PTR [r10]
	lea	r10, QWORD PTR [r10+1]
	movsxd	rax, ecx
	mov	edx, r8d
	and	eax, 7
	movzx	eax, BYTE PTR buffer$[rsp+rax]
	sub	edx, eax

; 4059 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];

	lea	eax, DWORD PTR [rcx-3]
	and	eax, 7
	add	r9d, edx
	inc	ecx
	mov	BYTE PTR buffer$[rsp+rax], r8b

; 4060 :                pixels[i] = (unsigned char) (total / 5);

	mov	eax, -858993459				; cccccccdH
	mul	r9d
	shr	edx, 2
	mov	BYTE PTR [r10-1], dl
	sub	r11, 1
	jne	SHORT $LL18@stbtt__h_p

; 4061 :             }
; 4062 :             break;

	jmp	$LN8@stbtt__h_p
$LN30@stbtt__h_p:

; 4049 :          case 4:
; 4050 :             for (i=0; i <= safe_w; ++i) {

	xor	ecx, ecx
	test	rbx, rbx
	js	$LN8@stbtt__h_p
	mov	r10, rdi
	lea	r11, QWORD PTR [rbx+1]
	npad	12
$LL15@stbtt__h_p:

; 4051 :                total += pixels[i] - buffer[i & STBTT__OVER_MASK];

	movzx	r8d, BYTE PTR [r10]
	lea	r10, QWORD PTR [r10+1]
	movsxd	rax, ecx
	mov	edx, r8d
	and	eax, 7
	movzx	eax, BYTE PTR buffer$[rsp+rax]
	sub	edx, eax

; 4052 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];

	lea	eax, DWORD PTR [rcx-4]
	and	eax, 7
	add	r9d, edx
	inc	ecx
	mov	BYTE PTR buffer$[rsp+rax], r8b

; 4053 :                pixels[i] = (unsigned char) (total / 4);

	mov	eax, r9d
	shr	eax, 2
	mov	BYTE PTR [r10-1], al
	sub	r11, 1
	jne	SHORT $LL15@stbtt__h_p

; 4054 :             }
; 4055 :             break;

	jmp	$LN8@stbtt__h_p
$LN29@stbtt__h_p:

; 4040 :             }
; 4041 :             break;
; 4042 :          case 3:
; 4043 :             for (i=0; i <= safe_w; ++i) {

	xor	ecx, ecx
	test	rbx, rbx
	js	$LN8@stbtt__h_p
	mov	r10, rdi
	lea	r11, QWORD PTR [rbx+1]
	npad	1
$LL12@stbtt__h_p:

; 4044 :                total += pixels[i] - buffer[i & STBTT__OVER_MASK];

	movzx	r8d, BYTE PTR [r10]
	lea	r10, QWORD PTR [r10+1]
	movsxd	rax, ecx
	mov	edx, r8d
	and	eax, 7
	movzx	eax, BYTE PTR buffer$[rsp+rax]
	sub	edx, eax

; 4045 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];

	lea	eax, DWORD PTR [rcx+3]
	and	eax, 7
	add	r9d, edx
	inc	ecx
	mov	BYTE PTR buffer$[rsp+rax], r8b

; 4046 :                pixels[i] = (unsigned char) (total / 3);

	mov	eax, -1431655765			; aaaaaaabH
	mul	r9d
	shr	edx, 1
	mov	BYTE PTR [r10-1], dl
	sub	r11, 1
	jne	SHORT $LL12@stbtt__h_p

; 4047 :             }
; 4048 :             break;

	jmp	SHORT $LN8@stbtt__h_p
$LN28@stbtt__h_p:

; 4035 :          case 2:
; 4036 :             for (i=0; i <= safe_w; ++i) {

	xor	ecx, ecx
	test	rbx, rbx
	js	SHORT $LN8@stbtt__h_p
	mov	r10, rdi
	lea	r11, QWORD PTR [rbx+1]
	npad	4
$LL9@stbtt__h_p:

; 4037 :                total += pixels[i] - buffer[i & STBTT__OVER_MASK];

	movzx	r8d, BYTE PTR [r10]
	lea	r10, QWORD PTR [r10+1]
	movsxd	rax, ecx
	mov	edx, r8d
	and	eax, 7
	movzx	eax, BYTE PTR buffer$[rsp+rax]
	sub	edx, eax

; 4038 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];

	lea	eax, DWORD PTR [rcx+2]
	and	eax, 7
	add	r9d, edx
	inc	ecx
	mov	BYTE PTR buffer$[rsp+rax], r8b

; 4039 :                pixels[i] = (unsigned char) (total / 2);

	mov	eax, r9d
	shr	eax, 1
	mov	BYTE PTR [r10-1], al
	sub	r11, 1
	jne	SHORT $LL9@stbtt__h_p
$LN8@stbtt__h_p:

; 4068 :             }
; 4069 :             break;
; 4070 :       }
; 4071 : 
; 4072 :       for (; i < w; ++i) {

	cmp	ecx, r14d
	jge	SHORT $LN23@stbtt__h_p
	movsxd	r8, ecx
	mov	eax, r14d
	sub	eax, ecx
	mov	ecx, eax
	lea	r10, QWORD PTR [r8+rdi]
	npad	6
$LL24@stbtt__h_p:

; 4073 :          STBTT_assert(pixels[i] == 0);
; 4074 :          total -= buffer[i & STBTT__OVER_MASK];

	mov	rax, r8
	lea	r10, QWORD PTR [r10+1]
	and	eax, 7

; 4075 :          pixels[i] = (unsigned char) (total / kernel_width);

	xor	edx, edx
	inc	r8
	movzx	eax, BYTE PTR buffer$[rsp+rax]
	sub	r9d, eax
	mov	eax, r9d
	div	esi
	mov	BYTE PTR [r10-1], al
	sub	rcx, 1
	jne	SHORT $LL24@stbtt__h_p
$LN23@stbtt__h_p:

; 4076 :       }
; 4077 : 
; 4078 :       pixels += stride_in_bytes;

	add	rdi, r15
	sub	rbp, 1
	jne	$LL4@stbtt__h_p

; 4024 :    int j;
; 4025 :    STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze
; 4026 :    for (j=0; j < h; ++j) {

	mov	r15, QWORD PTR [rsp+48]
	mov	r12, QWORD PTR [rsp+112]
	mov	rbp, QWORD PTR [rsp+104]

; 4079 :    }
; 4080 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 56					; 00000038H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbx
$LN73@stbtt__h_p:
	ret	0
?stbtt__h_prefilter@@YAXPEAEHHHI@Z ENDP			; stbtt__h_prefilter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__v_prefilter@@YAXPEAEHHHI@Z
_TEXT	SEGMENT
buffer$ = 32
__$ArrayPad$ = 40
pixels$ = 96
w$ = 104
h$ = 112
stride_in_bytes$ = 120
kernel_width$ = 128
?stbtt__v_prefilter@@YAXPEAEHHHI@Z PROC			; stbtt__v_prefilter, COMDAT

; 4086 :    int j;
; 4087 :    STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze
; 4088 :    for (j=0; j < w; ++j) {

	test	edx, edx
	jle	$LN73@stbtt__v_p
	push	rbx
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 4083 : {

	mov	r14d, DWORD PTR kernel_width$[rsp]

; 4084 :    unsigned char buffer[STBTT_MAX_OVERSAMPLE];
; 4085 :    int safe_h = h - kernel_width;

	mov	ebx, r8d

; 4086 :    int j;
; 4087 :    STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze
; 4088 :    for (j=0; j < w; ++j) {

	mov	QWORD PTR [rsp+104], rbp
	sub	ebx, r14d
	movsxd	rsi, r9d
	mov	r15d, r8d
	mov	rdi, rcx
	mov	QWORD PTR buffer$[rsp], 0
	mov	QWORD PTR [rsp+112], r12
	mov	ebp, edx
	npad	2
$LL4@stbtt__v_p:

; 4089 :       int i;
; 4090 :       unsigned int total;
; 4091 :       STBTT_memset(buffer, 0, kernel_width);

	mov	r8, r14
	lea	rcx, QWORD PTR buffer$[rsp]
	xor	edx, edx
	call	memset

; 4092 : 
; 4093 :       total = 0;

	xor	r10d, r10d

; 4094 : 
; 4095 :       // make kernel_width a constant in common cases so compiler can optimize out the divide
; 4096 :       switch (kernel_width) {

	mov	eax, r14d
	sub	eax, 2
	je	$LN28@stbtt__v_p
	sub	eax, 1
	je	$LN29@stbtt__v_p
	sub	eax, 1
	je	$LN30@stbtt__v_p
	xor	ecx, ecx
	cmp	eax, 1
	je	SHORT $LN31@stbtt__v_p

; 4125 :          default:
; 4126 :             for (i=0; i <= safe_h; ++i) {

	test	ebx, ebx
	js	$LN8@stbtt__v_p
	xor	r11d, r11d
	npad	14
$LL21@stbtt__v_p:

; 4127 :                total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];

	mov	eax, ecx
	movsxd	r9, r11d
	and	eax, 7
	add	r11d, esi
	movzx	r8d, BYTE PTR [r9+rdi]
	movzx	edx, BYTE PTR buffer$[rsp+rax]
	mov	eax, r8d
	sub	eax, edx

; 4128 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
; 4129 :                pixels[i*stride_in_bytes] = (unsigned char) (total / kernel_width);

	xor	edx, edx
	add	r10d, eax
	lea	eax, DWORD PTR [r14+rcx]
	and	eax, 7
	inc	ecx
	mov	BYTE PTR buffer$[rsp+rax], r8b
	mov	eax, r10d
	div	r14d
	mov	BYTE PTR [r9+rdi], al
	cmp	ecx, ebx
	jle	SHORT $LL21@stbtt__v_p

; 4125 :          default:
; 4126 :             for (i=0; i <= safe_h; ++i) {

	jmp	$LN8@stbtt__v_p
$LN31@stbtt__v_p:

; 4118 :          case 5:
; 4119 :             for (i=0; i <= safe_h; ++i) {

	test	ebx, ebx
	js	$LN8@stbtt__v_p
	xor	r11d, r11d
	npad	5
$LL18@stbtt__v_p:

; 4120 :                total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];

	mov	eax, ecx
	movsxd	r9, r11d
	and	eax, 7
	add	r11d, esi
	movzx	r8d, BYTE PTR [r9+rdi]
	movzx	edx, BYTE PTR buffer$[rsp+rax]
	mov	eax, r8d
	sub	eax, edx
	add	r10d, eax

; 4121 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];

	lea	eax, DWORD PTR [rcx-3]
	and	eax, 7
	inc	ecx
	mov	BYTE PTR buffer$[rsp+rax], r8b

; 4122 :                pixels[i*stride_in_bytes] = (unsigned char) (total / 5);

	mov	eax, -858993459				; cccccccdH
	mul	r10d
	shr	edx, 2
	mov	BYTE PTR [r9+rdi], dl
	cmp	ecx, ebx
	jle	SHORT $LL18@stbtt__v_p

; 4123 :             }
; 4124 :             break;

	jmp	$LN8@stbtt__v_p
$LN30@stbtt__v_p:

; 4111 :          case 4:
; 4112 :             for (i=0; i <= safe_h; ++i) {

	xor	ecx, ecx
	test	ebx, ebx
	js	$LN8@stbtt__v_p
	xor	r11d, r11d
	npad	1
$LL15@stbtt__v_p:

; 4113 :                total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];

	mov	eax, ecx
	movsxd	r9, r11d
	and	eax, 7
	add	r11d, esi
	movzx	r8d, BYTE PTR [r9+rdi]
	movzx	edx, BYTE PTR buffer$[rsp+rax]
	mov	eax, r8d
	sub	eax, edx
	add	r10d, eax

; 4114 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];

	lea	eax, DWORD PTR [rcx-4]
	and	eax, 7
	inc	ecx
	mov	BYTE PTR buffer$[rsp+rax], r8b

; 4115 :                pixels[i*stride_in_bytes] = (unsigned char) (total / 4);

	mov	eax, r10d
	shr	eax, 2
	mov	BYTE PTR [r9+rdi], al
	cmp	ecx, ebx
	jle	SHORT $LL15@stbtt__v_p

; 4116 :             }
; 4117 :             break;

	jmp	$LN8@stbtt__v_p
$LN29@stbtt__v_p:

; 4102 :             }
; 4103 :             break;
; 4104 :          case 3:
; 4105 :             for (i=0; i <= safe_h; ++i) {

	xor	ecx, ecx
	test	ebx, ebx
	js	$LN8@stbtt__v_p
	xor	r11d, r11d
	npad	6
$LL12@stbtt__v_p:

; 4106 :                total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];

	mov	eax, ecx
	movsxd	r9, r11d
	and	eax, 7
	add	r11d, esi
	movzx	r8d, BYTE PTR [r9+rdi]
	movzx	edx, BYTE PTR buffer$[rsp+rax]
	mov	eax, r8d
	sub	eax, edx
	add	r10d, eax

; 4107 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];

	lea	eax, DWORD PTR [rcx+3]
	and	eax, 7
	inc	ecx
	mov	BYTE PTR buffer$[rsp+rax], r8b

; 4108 :                pixels[i*stride_in_bytes] = (unsigned char) (total / 3);

	mov	eax, -1431655765			; aaaaaaabH
	mul	r10d
	shr	edx, 1
	mov	BYTE PTR [r9+rdi], dl
	cmp	ecx, ebx
	jle	SHORT $LL12@stbtt__v_p

; 4109 :             }
; 4110 :             break;

	jmp	SHORT $LN8@stbtt__v_p
$LN28@stbtt__v_p:

; 4097 :          case 2:
; 4098 :             for (i=0; i <= safe_h; ++i) {

	xor	ecx, ecx
	test	ebx, ebx
	js	SHORT $LN8@stbtt__v_p
	xor	r11d, r11d
	npad	9
$LL9@stbtt__v_p:

; 4099 :                total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];

	mov	eax, ecx
	movsxd	r9, r11d
	and	eax, 7
	add	r11d, esi
	movzx	r8d, BYTE PTR [r9+rdi]
	movzx	edx, BYTE PTR buffer$[rsp+rax]
	mov	eax, r8d
	sub	eax, edx
	add	r10d, eax

; 4100 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];

	lea	eax, DWORD PTR [rcx+2]
	and	eax, 7
	inc	ecx
	mov	BYTE PTR buffer$[rsp+rax], r8b

; 4101 :                pixels[i*stride_in_bytes] = (unsigned char) (total / 2);

	mov	eax, r10d
	shr	eax, 1
	mov	BYTE PTR [r9+rdi], al
	cmp	ecx, ebx
	jle	SHORT $LL9@stbtt__v_p
$LN8@stbtt__v_p:

; 4130 :             }
; 4131 :             break;
; 4132 :       }
; 4133 : 
; 4134 :       for (; i < h; ++i) {

	cmp	ecx, r15d
	jge	SHORT $LN23@stbtt__v_p
	mov	eax, esi
	movsxd	r9, ecx
	imul	eax, ecx
	movsxd	r8, eax
	mov	eax, r15d
	add	r8, rdi
	sub	eax, ecx
	mov	ecx, eax
	npad	15
$LL24@stbtt__v_p:

; 4135 :          STBTT_assert(pixels[i*stride_in_bytes] == 0);
; 4136 :          total -= buffer[i & STBTT__OVER_MASK];

	mov	rax, r9

; 4137 :          pixels[i*stride_in_bytes] = (unsigned char) (total / kernel_width);

	xor	edx, edx
	and	eax, 7
	inc	r9
	movzx	eax, BYTE PTR buffer$[rsp+rax]
	sub	r10d, eax
	mov	eax, r10d
	div	r14d
	mov	BYTE PTR [r8], al
	add	r8, rsi
	sub	rcx, 1
	jne	SHORT $LL24@stbtt__v_p
$LN23@stbtt__v_p:

; 4138 :       }
; 4139 : 
; 4140 :       pixels += 1;

	inc	rdi
	sub	rbp, 1
	jne	$LL4@stbtt__v_p

; 4086 :    int j;
; 4087 :    STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze
; 4088 :    for (j=0; j < w; ++j) {

	mov	r12, QWORD PTR [rsp+112]
	mov	rbp, QWORD PTR [rsp+104]

; 4141 :    }
; 4142 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbx
$LN73@stbtt__v_p:
	ret	0
?stbtt__v_prefilter@@YAXPEAEHHHI@Z ENDP			; stbtt__v_prefilter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT ?stbtt__oversample_shift@@YAMH@Z
_TEXT	SEGMENT
oversample$ = 8
?stbtt__oversample_shift@@YAMH@Z PROC			; stbtt__oversample_shift, COMDAT

; 4146 :    if (!oversample)

	test	ecx, ecx
	jne	SHORT $LN2@stbtt__ove
	xorps	xmm0, xmm0

; 4154 : }

	ret	0
$LN2@stbtt__ove:

; 4147 :       return 0.0f;
; 4148 : 
; 4149 :    // The prefilter is a box filter of width "oversample",
; 4150 :    // which shifts phase by (oversample - 1)/2 pixels in
; 4151 :    // oversampled space. We want to shift in the opposite
; 4152 :    // direction to counter this.
; 4153 :    return (float)-(oversample - 1) / (2.0f * (float)oversample);

	mov	eax, 1
	movd	xmm1, ecx
	sub	eax, ecx
	cvtdq2ps xmm1, xmm1
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	addss	xmm1, xmm1
	divss	xmm0, xmm1

; 4154 : }

	ret	0
?stbtt__oversample_shift@@YAMH@Z ENDP			; stbtt__oversample_shift
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT stbtt_PackFontRangesRenderIntoRects
_TEXT	SEGMENT
out_h$1$ = 96
winding_count$1 = 96
glyph$1$ = 100
return_value$1$ = 104
j$1$ = 108
num_verts$1$ = 112
iy0$2 = 116
ix0$3 = 120
tv1999 = 124
x0$4 = 128
y0$5 = 132
old_h_over$1$ = 136
old_v_over$1$ = 140
info$GSCopy$1$ = 144
winding_lengths$6 = 152
$T7 = 160
$T8 = 168
y1$9 = 176
x1$10 = 180
gbm$11 = 184
vertices$12 = 208
__$ArrayPad$ = 216
spc$ = 432
info$ = 440
ranges$ = 448
num_ranges$dead$ = 456
rects$ = 464
stbtt_PackFontRangesRenderIntoRects PROC		; COMDAT

; 4217 : {

	mov	rax, rsp
	push	rbp
	push	rbx
	push	rsi
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-120]
	sub	rsp, 376				; 00000178H
	movaps	XMMWORD PTR [rax-104], xmm8
	movaps	XMMWORD PTR [rax-120], xmm9
	movaps	XMMWORD PTR [rax-168], xmm12
	movaps	XMMWORD PTR [rax-184], xmm13
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax

; 4218 :    int i,j,k, missing_glyph = -1, return_value = 1;
; 4219 : 
; 4220 :    // save current values
; 4221 :    int old_h_over = spc->h_oversample;

	mov	eax, DWORD PTR [rcx+36]
	xorps	xmm9, xmm9

; 4222 :    int old_v_over = spc->v_oversample;
; 4223 : 
; 4224 :    k = 0;
; 4225 :    for (i=0; i < num_ranges; ++i) {
; 4226 :       float fh = ranges[i].font_size;

	movss	xmm8, DWORD PTR [r8]
	mov	r11d, 1

; 4227 :       float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);

	comiss	xmm8, xmm9
	mov	r14, QWORD PTR rects$[rbp-256]
	mov	r10, -1
	mov	DWORD PTR old_h_over$1$[rbp-256], eax
	mov	r13, r8
	mov	eax, DWORD PTR [rcx+40]
	mov	rsi, rdx
	mov	DWORD PTR old_v_over$1$[rbp-256], eax
	mov	r15, rcx
	mov	QWORD PTR info$GSCopy$1$[rbp-256], rdx
	mov	ebx, 256				; 00000100H
	mov	DWORD PTR return_value$1$[rsp], r11d
	mov	QWORD PTR $T7[rbp-256], r10
	jbe	SHORT $LN18@stbtt_Pack

; 2667 :    int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);

	movsxd	r11, DWORD PTR [rdx+36]
	mov	r10, QWORD PTR [rdx+8]

; 1292 : static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }

	movsx	ecx, bx
	movzx	eax, BYTE PTR [r11+r10+7]
	movzx	edx, BYTE PTR [r11+r10+6]
	movzx	r8d, BYTE PTR [r11+r10+5]
	imul	edx, ecx
	movsx	ecx, bx
	add	dx, ax
	movzx	eax, BYTE PTR [r11+r10+4]
	imul	eax, ecx

; 4227 :       float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);

	mov	r10, -1

; 2667 :    int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);

	movsx	r9d, dx

; 4227 :       float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);

	lea	r11d, QWORD PTR [r10+2]

; 1292 : static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }

	add	ax, r8w

; 2667 :    int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);

	cwde
	sub	eax, r9d
	movd	xmm0, eax

; 4227 :       float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);

	jmp	SHORT $LN124@stbtt_Pack
$LN18@stbtt_Pack:

; 2673 :    int unitsPerEm = ttUSHORT(info->data + info->head + 18);

	movsxd	rdx, DWORD PTR [rdx+28]
	mov	rax, QWORD PTR [rsi+8]

; 4227 :       float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);

	xorps	xmm8, DWORD PTR __xmm@80000000800000008000000080000000

; 1291 : static stbtt_uint16 ttUSHORT(stbtt_uint8 *p) { return p[0]*256 + p[1]; }

	movzx	ecx, BYTE PTR [rdx+rax+18]
	movzx	eax, BYTE PTR [rdx+rax+19]
	shl	ecx, 8
	add	ecx, eax
	movd	xmm0, ecx
$LN124@stbtt_Pack:

; 4228 :       float recip_h,recip_v,sub_x,sub_y;
; 4229 :       spc->h_oversample = ranges[i].h_oversample;

	movzx	edx, BYTE PTR [r13+32]

; 4230 :       spc->v_oversample = ranges[i].v_oversample;
; 4231 :       recip_h = 1.0f / spc->h_oversample;

	movss	xmm12, DWORD PTR __real@3f800000
	mov	DWORD PTR [r15+36], edx
	movaps	xmm13, xmm12
	movzx	ecx, BYTE PTR [r13+33]
	movaps	XMMWORD PTR [rsp+272], xmm11
	mov	DWORD PTR [r15+40], ecx
	cvtdq2ps xmm0, xmm0
	divss	xmm8, xmm0
	xorps	xmm0, xmm0
	cvtsi2ss xmm0, rdx
	divss	xmm13, xmm0
	xorps	xmm0, xmm0

; 4232 :       recip_v = 1.0f / spc->v_oversample;

	cvtsi2ss xmm0, rcx
	divss	xmm12, xmm0

; 4146 :    if (!oversample)

	test	edx, edx
	jne	SHORT $LN33@stbtt_Pack
	xorps	xmm11, xmm11

; 4147 :       return 0.0f;

	jmp	SHORT $LN32@stbtt_Pack
$LN33@stbtt_Pack:

; 4148 : 
; 4149 :    // The prefilter is a box filter of width "oversample",
; 4150 :    // which shifts phase by (oversample - 1)/2 pixels in
; 4151 :    // oversampled space. We want to shift in the opposite
; 4152 :    // direction to counter this.
; 4153 :    return (float)-(oversample - 1) / (2.0f * (float)oversample);

	mov	eax, r11d
	movd	xmm0, edx
	sub	eax, edx
	cvtdq2ps xmm0, xmm0
	movd	xmm11, eax
	cvtdq2ps xmm11, xmm11
	addss	xmm0, xmm0
	divss	xmm11, xmm0
$LN32@stbtt_Pack:
	movaps	XMMWORD PTR [rsp+288], xmm10

; 4146 :    if (!oversample)

	test	ecx, ecx
	jne	SHORT $LN36@stbtt_Pack
	xorps	xmm10, xmm10

; 4147 :       return 0.0f;

	jmp	SHORT $LN35@stbtt_Pack
$LN36@stbtt_Pack:

; 4148 : 
; 4149 :    // The prefilter is a box filter of width "oversample",
; 4150 :    // which shifts phase by (oversample - 1)/2 pixels in
; 4151 :    // oversampled space. We want to shift in the opposite
; 4152 :    // direction to counter this.
; 4153 :    return (float)-(oversample - 1) / (2.0f * (float)oversample);

	mov	eax, r11d
	movd	xmm0, ecx
	sub	eax, ecx
	cvtdq2ps xmm0, xmm0
	movd	xmm10, eax
	cvtdq2ps xmm10, xmm10
	addss	xmm0, xmm0
	divss	xmm10, xmm0
$LN35@stbtt_Pack:

; 4233 :       sub_x = stbtt__oversample_shift(spc->h_oversample);
; 4234 :       sub_y = stbtt__oversample_shift(spc->v_oversample);
; 4235 :       for (j=0; j < ranges[i].num_chars; ++j) {

	xor	r9d, r9d
	xor	r8d, r8d
	mov	DWORD PTR j$1$[rsp], r9d
	mov	QWORD PTR $T8[rbp-256], r8
	cmp	DWORD PTR [r13+16], r8d
	jle	$LN2@stbtt_Pack
	movaps	XMMWORD PTR [rsp+224], xmm14
	add	r14, 12
	movss	xmm14, DWORD PTR __real@3eb33333
	mov	QWORD PTR [rsp+456], rdi
	mov	QWORD PTR [rsp+368], r12
	movaps	XMMWORD PTR [rsp+352], xmm6
	movaps	XMMWORD PTR [rsp+336], xmm7
	npad	5
$LL7@stbtt_Pack:

; 4236 :          stbrp_rect *r = &rects[k];
; 4237 :          if (r->was_packed && r->w != 0 && r->h != 0) {

	mov	eax, DWORD PTR [r14+8]
	test	eax, eax
	je	$LN8@stbtt_Pack
	mov	ebx, DWORD PTR [r14-8]
	test	ebx, ebx
	je	$LN8@stbtt_Pack
	mov	edi, DWORD PTR [r14-4]
	test	edi, edi
	je	$LN8@stbtt_Pack

; 4238 :             stbtt_packedchar *bc = &ranges[i].chardata_for_range[j];
; 4239 :             int advance, lsb, x0,y0,x1,y1;
; 4240 :             int codepoint = ranges[i].array_of_unicode_codepoints == NULL ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];

	mov	rax, QWORD PTR [r13+8]
	imul	r12, r8, 28
	add	r12, QWORD PTR [r13+24]
	test	rax, rax
	jne	SHORT $LN20@stbtt_Pack
	mov	edx, DWORD PTR [r13+4]
	add	edx, r9d
	jmp	SHORT $LN21@stbtt_Pack
$LN20@stbtt_Pack:
	mov	edx, DWORD PTR [rax+r8*4]
$LN21@stbtt_Pack:

; 4241 :             int glyph = stbtt_FindGlyphIndex(info, codepoint);

	mov	rcx, rsi
	call	stbtt_FindGlyphIndex

; 4242 :             stbrp_coord pad = (stbrp_coord) spc->padding;

	mov	edx, DWORD PTR [r15+28]
	mov	r10d, eax

; 4243 : 
; 4244 :             // pad on left and top
; 4245 :             r->x += pad;

	add	DWORD PTR [r14], edx

; 4246 :             r->y += pad;
; 4247 :             r->w -= pad;

	sub	ebx, edx
	add	DWORD PTR [r14+4], edx

; 4248 :             r->h -= pad;

	sub	edi, edx
	mov	DWORD PTR [r14-8], ebx
	mov	DWORD PTR [r14-4], edi

; 2312 :    stbtt_uint16 numOfLongHorMetrics = ttUSHORT(info->data+info->hhea + 34);

	mov	r8, QWORD PTR [rsi+8]

; 2313 :    if (glyph_index < numOfLongHorMetrics) {

	movsxd	r9, DWORD PTR [rsi+40]

; 4241 :             int glyph = stbtt_FindGlyphIndex(info, codepoint);

	mov	DWORD PTR glyph$1$[rsp], eax

; 2312 :    stbtt_uint16 numOfLongHorMetrics = ttUSHORT(info->data+info->hhea + 34);

	movsxd	rax, DWORD PTR [rsi+36]

; 1291 : static stbtt_uint16 ttUSHORT(stbtt_uint8 *p) { return p[0]*256 + p[1]; }

	movzx	ecx, BYTE PTR [rax+r8+34]
	movzx	edx, BYTE PTR [rax+r8+35]

; 2313 :    if (glyph_index < numOfLongHorMetrics) {

	mov	eax, ecx
	shl	eax, 8
	add	eax, edx
	cmp	r10d, eax
	jge	SHORT $LN39@stbtt_Pack

; 2314 :       if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*glyph_index);

	lea	eax, DWORD PTR [r10*4]

; 1292 : static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }

	mov	ecx, 256				; 00000100H

; 2314 :       if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*glyph_index);

	movsxd	rdx, eax
	add	rdx, r8

; 1292 : static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }

	movsx	ecx, cx
	movzx	r8d, BYTE PTR [rdx+r9]
	movzx	eax, BYTE PTR [rdx+r9+1]
	imul	r8d, ecx
	add	r8w, ax

; 2316 :    } else {

	jmp	SHORT $LN97@stbtt_Pack
$LN39@stbtt_Pack:

; 2317 :       if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*(numOfLongHorMetrics-1));

	shl	rcx, 8
	add	rcx, rdx
	lea	r8, QWORD PTR [r8+rcx*4]

; 1292 : static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }

	mov	ecx, 256				; 00000100H
	movzx	edx, BYTE PTR [r8+r9-4]
	movzx	r8d, BYTE PTR [r8+r9-3]
	movsx	ecx, cx
	imul	edx, ecx
	add	r8w, dx
$LN97@stbtt_Pack:

; 2746 :    stbtt_GetGlyphBitmapBoxSubpixel(font, glyph, scale_x, scale_y,0.0f,0.0f, ix0, iy0, ix1, iy1);

	movsx	eax, r8w
	xorps	xmm3, xmm3
	mov	DWORD PTR tv1999[rsp], eax
	xorps	xmm2, xmm2

; 4249 :             stbtt_GetGlyphHMetrics(info, glyph, &advance, &lsb);
; 4250 :             stbtt_GetGlyphBitmapBox(info, glyph,

	mov	eax, DWORD PTR [r15+40]

; 2746 :    stbtt_GetGlyphBitmapBoxSubpixel(font, glyph, scale_x, scale_y,0.0f,0.0f, ix0, iy0, ix1, iy1);

	mov	edx, r10d
	mov	rcx, rsi

; 4249 :             stbtt_GetGlyphHMetrics(info, glyph, &advance, &lsb);
; 4250 :             stbtt_GetGlyphBitmapBox(info, glyph,

	cvtsi2ss xmm3, rax
	mov	eax, DWORD PTR [r15+36]
	cvtsi2ss xmm2, rax

; 2746 :    stbtt_GetGlyphBitmapBoxSubpixel(font, glyph, scale_x, scale_y,0.0f,0.0f, ix0, iy0, ix1, iy1);

	lea	rax, QWORD PTR y1$9[rbp-256]
	mov	QWORD PTR [rsp+72], rax
	lea	rax, QWORD PTR x1$10[rbp-256]
	mov	QWORD PTR [rsp+64], rax
	lea	rax, QWORD PTR y0$5[rbp-256]
	mov	QWORD PTR [rsp+56], rax
	lea	rax, QWORD PTR x0$4[rbp-256]
	mov	QWORD PTR [rsp+48], rax
	movss	DWORD PTR [rsp+40], xmm9

; 4249 :             stbtt_GetGlyphHMetrics(info, glyph, &advance, &lsb);
; 4250 :             stbtt_GetGlyphBitmapBox(info, glyph,

	mulss	xmm3, xmm8
	mulss	xmm2, xmm8

; 2746 :    stbtt_GetGlyphBitmapBoxSubpixel(font, glyph, scale_x, scale_y,0.0f,0.0f, ix0, iy0, ix1, iy1);

	movss	DWORD PTR [rsp+32], xmm9
	call	stbtt_GetGlyphBitmapBoxSubpixel

; 4251 :                                     scale * spc->h_oversample,
; 4252 :                                     scale * spc->v_oversample,
; 4253 :                                     &x0,&y0,&x1,&y1);
; 4254 :             stbtt_MakeGlyphBitmapSubpixel(info,

	mov	eax, DWORD PTR [r15+40]

; 3770 :    int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);

	lea	r8, QWORD PTR vertices$12[rbp-256]

; 4251 :                                     scale * spc->h_oversample,
; 4252 :                                     scale * spc->v_oversample,
; 4253 :                                     &x0,&y0,&x1,&y1);
; 4254 :             stbtt_MakeGlyphBitmapSubpixel(info,

	mov	ecx, DWORD PTR [r15+36]
	xorps	xmm6, xmm6
	mov	edx, DWORD PTR [r14-4]
	xorps	xmm7, xmm7
	mov	esi, DWORD PTR [r15+24]
	sub	edx, eax
	mov	edi, DWORD PTR [r14-8]
	inc	edx
	cvtsi2ss xmm6, rax
	sub	edi, ecx
	mov	eax, esi
	inc	edi
	mov	DWORD PTR out_h$1$[rsp], edx

; 3770 :    int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);

	mov	edx, DWORD PTR glyph$1$[rsp]

; 4251 :                                     scale * spc->h_oversample,
; 4252 :                                     scale * spc->v_oversample,
; 4253 :                                     &x0,&y0,&x1,&y1);
; 4254 :             stbtt_MakeGlyphBitmapSubpixel(info,

	imul	eax, DWORD PTR [r14+4]
	cvtsi2ss xmm7, rcx

; 3770 :    int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);

	mov	rcx, QWORD PTR info$GSCopy$1$[rbp-256]

; 4251 :                                     scale * spc->h_oversample,
; 4252 :                                     scale * spc->v_oversample,
; 4253 :                                     &x0,&y0,&x1,&y1);
; 4254 :             stbtt_MakeGlyphBitmapSubpixel(info,

	movsxd	rbx, eax
	movsxd	rax, DWORD PTR [r14]
	add	rbx, rax
	mulss	xmm6, xmm8
	add	rbx, QWORD PTR [r15+48]
	mulss	xmm7, xmm8

; 3770 :    int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);

	call	stbtt_GetGlyphShape

; 3771 :    stbtt__bitmap gbm;
; 3772 : 
; 3773 :    stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,0,0);

	mov	edx, DWORD PTR glyph$1$[rsp]
	movaps	xmm3, xmm6
	mov	rcx, QWORD PTR info$GSCopy$1$[rbp-256]
	movaps	xmm2, xmm7
	mov	DWORD PTR num_verts$1$[rsp], eax
	xor	eax, eax
	mov	QWORD PTR [rsp+72], rax
	mov	QWORD PTR [rsp+64], rax
	lea	rax, QWORD PTR iy0$2[rsp]
	mov	QWORD PTR [rsp+56], rax
	lea	rax, QWORD PTR ix0$3[rsp]
	mov	QWORD PTR [rsp+48], rax
	movss	DWORD PTR [rsp+40], xmm9
	movss	DWORD PTR [rsp+32], xmm9
	call	stbtt_GetGlyphBitmapBoxSubpixel

; 3774 :    gbm.pixels = output;
; 3775 :    gbm.w = out_w;
; 3776 :    gbm.h = out_h;

	mov	eax, DWORD PTR out_h$1$[rsp]
	mov	DWORD PTR gbm$11[rbp-252], eax
	mov	QWORD PTR gbm$11[rbp-240], rbx
	mov	DWORD PTR gbm$11[rbp-256], edi

; 3777 :    gbm.stride = out_stride;

	mov	DWORD PTR gbm$11[rbp-248], esi
	test	edi, edi

; 3778 : 
; 3779 :    if (gbm.w && gbm.h)

	je	$LN78@stbtt_Pack
	test	eax, eax
	je	$LN78@stbtt_Pack

; 3708 :    stbtt__point *windings = stbtt_FlattenCurves(vertices, num_verts, flatness_in_pixels / scale, &winding_lengths, &winding_count, userdata);

	mov	edx, DWORD PTR num_verts$1$[rsp]
	lea	r9, QWORD PTR winding_lengths$6[rbp-256]
	mov	rcx, QWORD PTR vertices$12[rbp-256]
	xor	eax, eax
	movaps	xmm0, xmm6
	mov	DWORD PTR winding_count$1[rsp], eax
	minss	xmm0, xmm7
	mov	QWORD PTR winding_lengths$6[rbp-256], rax
	movaps	xmm2, xmm14
	lea	rax, QWORD PTR winding_count$1[rsp]
	mov	QWORD PTR [rsp+32], rax
	divss	xmm2, xmm0
	call	?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z ; stbtt_FlattenCurves
	mov	rdi, rax

; 3709 :    if (windings) {

	test	rax, rax
	je	SHORT $LN78@stbtt_Pack

; 3710 :       stbtt__rasterize(result, windings, winding_lengths, winding_count, scale_x, scale_y, shift_x, shift_y, x_off, y_off, invert, userdata);

	mov	eax, DWORD PTR iy0$2[rsp]
	lea	rcx, QWORD PTR gbm$11[rbp-256]
	mov	rbx, QWORD PTR winding_lengths$6[rbp-256]
	mov	rdx, rdi
	mov	r9d, DWORD PTR winding_count$1[rsp]
	mov	r8, rbx
	mov	DWORD PTR [rsp+72], eax
	mov	eax, DWORD PTR ix0$3[rsp]
	mov	DWORD PTR [rsp+64], eax
	movss	DWORD PTR [rsp+56], xmm9
	movss	DWORD PTR [rsp+48], xmm9
	movss	DWORD PTR [rsp+40], xmm6
	movss	DWORD PTR [rsp+32], xmm7
	call	?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z ; stbtt__rasterize
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	test	rbx, rbx
	je	SHORT $LN68@stbtt_Pack

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN68@stbtt_Pack

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN68@stbtt_Pack:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	mov	rcx, rbx
	call	QWORD PTR __imp_free

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN76@stbtt_Pack

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN76@stbtt_Pack:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	mov	rcx, rdi
	call	QWORD PTR __imp_free
$LN78@stbtt_Pack:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 3782 :    STBTT_free(vertices, info->userdata);

	mov	rcx, QWORD PTR vertices$12[rbp-256]
	test	rcx, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	je	SHORT $LN84@stbtt_Pack

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN84@stbtt_Pack

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN84@stbtt_Pack:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 4264 :             if (spc->h_oversample > 1)

	mov	edx, DWORD PTR [r15+36]
	cmp	edx, 1
	jbe	SHORT $LN10@stbtt_Pack

; 4265 :                stbtt__h_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,

	mov	r9d, DWORD PTR [r15+24]
	mov	eax, r9d
	imul	eax, DWORD PTR [r14+4]
	mov	r8d, DWORD PTR [r14-4]
	mov	DWORD PTR [rsp+32], edx
	mov	edx, DWORD PTR [r14-8]
	movsxd	rcx, eax
	movsxd	rax, DWORD PTR [r14]
	add	rcx, rax
	add	rcx, QWORD PTR [r15+48]
	call	?stbtt__h_prefilter@@YAXPEAEHHHI@Z	; stbtt__h_prefilter
$LN10@stbtt_Pack:

; 4266 :                                   r->w, r->h, spc->stride_in_bytes,
; 4267 :                                   spc->h_oversample);
; 4268 : 
; 4269 :             if (spc->v_oversample > 1)

	mov	edx, DWORD PTR [r15+40]
	cmp	edx, 1
	jbe	SHORT $LN11@stbtt_Pack

; 4270 :                stbtt__v_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,

	mov	r9d, DWORD PTR [r15+24]
	mov	eax, r9d
	imul	eax, DWORD PTR [r14+4]
	mov	r8d, DWORD PTR [r14-4]
	mov	DWORD PTR [rsp+32], edx
	mov	edx, DWORD PTR [r14-8]
	movsxd	rcx, eax
	movsxd	rax, DWORD PTR [r14]
	add	rcx, rax
	add	rcx, QWORD PTR [r15+48]
	call	?stbtt__v_prefilter@@YAXPEAEHHHI@Z	; stbtt__v_prefilter
$LN11@stbtt_Pack:

; 4271 :                                   r->w, r->h, spc->stride_in_bytes,
; 4272 :                                   spc->v_oversample);
; 4273 : 
; 4274 :             bc->x0       = (stbtt_int16)  r->x;

	movzx	eax, WORD PTR [r14]

; 4275 :             bc->y0       = (stbtt_int16)  r->y;
; 4276 :             bc->x1       = (stbtt_int16) (r->x + r->w);
; 4277 :             bc->y1       = (stbtt_int16) (r->y + r->h);
; 4278 :             bc->xadvance =                scale * advance;
; 4279 :             bc->xoff     =       (float)  x0 * recip_h + sub_x;

	mov	ecx, DWORD PTR x0$4[rbp-256]

; 4280 :             bc->yoff     =       (float)  y0 * recip_v + sub_y;

	mov	edx, DWORD PTR y0$5[rbp-256]
	movd	xmm0, DWORD PTR tv1999[rsp]

; 4281 :             bc->xoff2    =                (x0 + r->w) * recip_h + sub_x;
; 4282 :             bc->yoff2    =                (y0 + r->h) * recip_v + sub_y;
; 4283 : 
; 4284 :             if (glyph == 0)
; 4285 :                missing_glyph = j;

	mov	r8, QWORD PTR $T8[rbp-256]
	mov	r9d, DWORD PTR j$1$[rsp]
	mov	rsi, QWORD PTR info$GSCopy$1$[rbp-256]
	mov	r11d, DWORD PTR return_value$1$[rsp]
	cvtdq2ps xmm0, xmm0
	mov	WORD PTR [r12], ax
	movzx	eax, WORD PTR [r14+4]
	mov	WORD PTR [r12+2], ax
	movzx	eax, WORD PTR [r14]
	add	ax, WORD PTR [r14-8]
	mulss	xmm0, xmm8
	mov	WORD PTR [r12+4], ax
	movzx	eax, WORD PTR [r14+4]
	add	ax, WORD PTR [r14-4]
	movss	DWORD PTR [r12+16], xmm0
	mov	WORD PTR [r12+6], ax
	movd	xmm1, ecx
	cvtdq2ps xmm1, xmm1
	movd	xmm0, edx
	cvtdq2ps xmm0, xmm0
	mulss	xmm1, xmm13
	mulss	xmm0, xmm12
	addss	xmm1, xmm11
	addss	xmm0, xmm10
	movss	DWORD PTR [r12+8], xmm1
	movss	DWORD PTR [r12+12], xmm0
	mov	eax, DWORD PTR [r14-8]
	add	eax, ecx
	movd	xmm0, eax
	mov	rax, r8
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm13
	addss	xmm0, xmm11
	movss	DWORD PTR [r12+20], xmm0
	mov	ecx, DWORD PTR [r14-4]
	add	ecx, edx
	cmp	DWORD PTR glyph$1$[rsp], 0
	cmovne	rax, QWORD PTR $T7[rbp-256]
	movd	xmm0, ecx
	mov	r10, rax
	cvtdq2ps xmm0, xmm0
	mov	QWORD PTR $T7[rbp-256], rax
	mulss	xmm0, xmm12
	addss	xmm0, xmm10
	movss	DWORD PTR [r12+24], xmm0
	jmp	SHORT $LN16@stbtt_Pack
$LN8@stbtt_Pack:

; 4286 :          } else if (spc->skip_missing) {

	cmp	DWORD PTR [r15+32], 0
	jne	SHORT $LN15@stbtt_Pack

; 4287 :             return_value = 0;
; 4288 :          } else if (r->was_packed && r->w == 0 && r->h == 0 && missing_glyph >= 0) {

	test	eax, eax
	je	SHORT $LN15@stbtt_Pack
	cmp	DWORD PTR [r14-8], 0
	jne	SHORT $LN15@stbtt_Pack
	cmp	DWORD PTR [r14-4], 0
	jne	SHORT $LN15@stbtt_Pack
	test	r10, r10
	js	SHORT $LN15@stbtt_Pack

; 4289 :             ranges[i].chardata_for_range[j] = ranges[i].chardata_for_range[missing_glyph];

	mov	rdx, QWORD PTR [r13+24]
	imul	rax, r10, 28
	imul	rcx, r8, 28
	movups	xmm0, XMMWORD PTR [rax+rdx]
	movups	XMMWORD PTR [rcx+rdx], xmm0
	movsd	xmm1, QWORD PTR [rax+rdx+16]
	movsd	QWORD PTR [rcx+rdx+16], xmm1
	mov	eax, DWORD PTR [rax+rdx+24]
	mov	DWORD PTR [rcx+rdx+24], eax

; 4290 :          } else {

	jmp	SHORT $LN16@stbtt_Pack
$LN15@stbtt_Pack:

; 4291 :             return_value = 0; // if any fail, report failure
; 4292 :          }
; 4293 : 
; 4294 :          ++k;

	xor	r11d, r11d
	mov	DWORD PTR return_value$1$[rsp], r11d
$LN16@stbtt_Pack:

; 4233 :       sub_x = stbtt__oversample_shift(spc->h_oversample);
; 4234 :       sub_y = stbtt__oversample_shift(spc->v_oversample);
; 4235 :       for (j=0; j < ranges[i].num_chars; ++j) {

	inc	r9d
	inc	r8

; 4291 :             return_value = 0; // if any fail, report failure
; 4292 :          }
; 4293 : 
; 4294 :          ++k;

	add	r14, 24
	mov	DWORD PTR j$1$[rsp], r9d
	mov	QWORD PTR $T8[rbp-256], r8
	cmp	r9d, DWORD PTR [r13+16]
	jl	$LL7@stbtt_Pack

; 4233 :       sub_x = stbtt__oversample_shift(spc->h_oversample);
; 4234 :       sub_y = stbtt__oversample_shift(spc->v_oversample);
; 4235 :       for (j=0; j < ranges[i].num_chars; ++j) {

	movaps	xmm14, XMMWORD PTR [rsp+224]
	movaps	xmm7, XMMWORD PTR [rsp+336]
	movaps	xmm6, XMMWORD PTR [rsp+352]
	mov	r12, QWORD PTR [rsp+368]
	mov	rdi, QWORD PTR [rsp+456]
$LN2@stbtt_Pack:

; 4295 :       }
; 4296 :    }
; 4297 : 
; 4298 :    // restore original values
; 4299 :    spc->h_oversample = old_h_over;

	mov	eax, DWORD PTR old_h_over$1$[rbp-256]

; 4300 :    spc->v_oversample = old_v_over;
; 4301 : 
; 4302 :    return return_value;

	movaps	xmm11, XMMWORD PTR [rsp+272]
	movaps	xmm10, XMMWORD PTR [rsp+288]
	mov	DWORD PTR [r15+36], eax
	mov	eax, DWORD PTR old_v_over$1$[rbp-256]
	mov	DWORD PTR [r15+40], eax
	mov	eax, r11d

; 4303 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+376]
	movaps	xmm8, XMMWORD PTR [r11-56]
	movaps	xmm9, XMMWORD PTR [r11-72]
	movaps	xmm12, XMMWORD PTR [r11-120]
	movaps	xmm13, XMMWORD PTR [r11-136]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
stbtt_PackFontRangesRenderIntoRects ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT stbtt_GetPackedQuad
_TEXT	SEGMENT
chardata$ = 8
pw$ = 16
ph$ = 24
char_index$ = 32
xpos$ = 40
ypos$ = 48
q$ = 56
align_to_integer$dead$ = 64
stbtt_GetPackedQuad PROC				; COMDAT

; 4373 :    float ipw = 1.0f / pw, iph = 1.0f / ph;

	movss	xmm3, DWORD PTR __real@3f800000
	movd	xmm0, edx
	movaps	xmm2, xmm3

; 4374 :    const stbtt_packedchar *b = chardata + char_index;
; 4375 : 
; 4376 :    if (align_to_integer) {
; 4377 :       float x = (float) STBTT_ifloor((*xpos + b->xoff) + 0.5f);
; 4378 :       float y = (float) STBTT_ifloor((*ypos + b->yoff) + 0.5f);
; 4379 :       q->x0 = x;
; 4380 :       q->y0 = y;
; 4381 :       q->x1 = x + b->xoff2 - b->xoff;
; 4382 :       q->y1 = y + b->yoff2 - b->yoff;
; 4383 :    } else {
; 4384 :       q->x0 = *xpos + b->xoff;

	mov	rdx, QWORD PTR xpos$[rsp]
	cvtdq2ps xmm0, xmm0
	movsxd	rax, r9d
	divss	xmm2, xmm0
	movd	xmm0, r8d
	cvtdq2ps xmm0, xmm0
	imul	r8, rax, 28
	divss	xmm3, xmm0

; 4385 :       q->y0 = *ypos + b->yoff;

	mov	rax, QWORD PTR ypos$[rsp]
	add	r8, rcx
	mov	rcx, QWORD PTR q$[rsp]
	movss	xmm0, DWORD PTR [r8+8]
	addss	xmm0, DWORD PTR [rdx]
	movss	DWORD PTR [rcx], xmm0
	movss	xmm0, DWORD PTR [r8+12]
	addss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR [rcx+4], xmm0

; 4386 :       q->x1 = *xpos + b->xoff2;

	movss	xmm0, DWORD PTR [r8+20]
	addss	xmm0, DWORD PTR [rdx]
	movss	DWORD PTR [rcx+16], xmm0

; 4387 :       q->y1 = *ypos + b->yoff2;

	movss	xmm1, DWORD PTR [r8+24]
	addss	xmm1, DWORD PTR [rax]

; 4388 :    }
; 4389 : 
; 4390 :    q->s0 = b->x0 * ipw;

	movss	DWORD PTR [rcx+20], xmm1
	movzx	eax, WORD PTR [r8]
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm2
	movss	DWORD PTR [rcx+8], xmm0

; 4391 :    q->t0 = b->y0 * iph;

	movzx	eax, WORD PTR [r8+2]
	movd	xmm1, eax
	cvtdq2ps xmm1, xmm1
	mulss	xmm1, xmm3
	movss	DWORD PTR [rcx+12], xmm1

; 4392 :    q->s1 = b->x1 * ipw;

	movzx	eax, WORD PTR [r8+4]
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm2
	movss	DWORD PTR [rcx+24], xmm0

; 4393 :    q->t1 = b->y1 * iph;

	movzx	eax, WORD PTR [r8+6]
	movd	xmm1, eax
	cvtdq2ps xmm1, xmm1
	mulss	xmm1, xmm3
	movss	DWORD PTR [rcx+28], xmm1

; 4394 : 
; 4395 :    *xpos += b->xadvance;

	movss	xmm0, DWORD PTR [r8+16]
	addss	xmm0, DWORD PTR [rdx]
	movss	DWORD PTR [rdx], xmm0

; 4396 : }

	ret	0
stbtt_GetPackedQuad ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT stbtt_GetFontOffsetForIndex
_TEXT	SEGMENT
data$ = 8
index$ = 16
stbtt_GetFontOffsetForIndex PROC			; COMDAT

; 4952 :    return stbtt_GetFontOffsetForIndex_internal((unsigned char *) data, index);

	jmp	?stbtt_GetFontOffsetForIndex_internal@@YAHPEAEH@Z ; stbtt_GetFontOffsetForIndex_internal
stbtt_GetFontOffsetForIndex ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
;	COMDAT stbtt_InitFont
_TEXT	SEGMENT
info$ = 8
data$ = 16
offset$ = 24
stbtt_InitFont PROC					; COMDAT

; 4962 :    return stbtt_InitFont_internal(info, (unsigned char *) data, offset);

	jmp	?stbtt_InitFont_internal@@YAHPEAUstbtt_fontinfo@@PEAEH@Z ; stbtt_InitFont_internal
stbtt_InitFont ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?AddCallback@ImDrawList@@QEAAXP6AXPEBU1@PEBUImDrawCmd@@@ZPEAX@Z
_TEXT	SEGMENT
this$ = 48
callback$dead$ = 56
callback_data$dead$ = 64
?AddCallback@ImDrawList@@QEAAXP6AXPEBU1@PEBUImDrawCmd@@@ZPEAX@Z PROC ; ImDrawList::AddCallback, COMDAT

; 468  : {

$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H

; 469  :     IM_ASSERT_PARANOID(CmdBuffer.Size > 0);
; 470  :     ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];

	mov	eax, DWORD PTR [rcx]
	mov	rbx, rcx
	dec	eax
	cdqe
	imul	rdx, rax, 56				; 00000038H
	add	rdx, QWORD PTR [rcx+8]

; 471  :     IM_ASSERT(curr_cmd->UserCallback == NULL);
; 472  :     if (curr_cmd->ElemCount != 0)

	cmp	DWORD PTR [rdx+32], 0
	je	SHORT $LN2@AddCallbac

; 473  :     {
; 474  :         AddDrawCmd();

	call	?AddDrawCmd@ImDrawList@@QEAAXXZ		; ImDrawList::AddDrawCmd

; 475  :         curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];

	mov	eax, DWORD PTR [rbx]
	dec	eax
	cdqe
	imul	rdx, rax, 56				; 00000038H
	add	rdx, QWORD PTR [rbx+8]
$LN2@AddCallbac:

; 476  :     }
; 477  :     curr_cmd->UserCallback = callback;
; 478  :     curr_cmd->UserCallbackData = callback_data;
; 479  : 
; 480  :     AddDrawCmd(); // Force a new command after us (see comment below)

	mov	rcx, rbx
	mov	QWORD PTR [rdx+40], -2
	mov	QWORD PTR [rdx+48], 0

; 481  : }

	add	rsp, 32					; 00000020H
	pop	rbx

; 476  :     }
; 477  :     curr_cmd->UserCallback = callback;
; 478  :     curr_cmd->UserCallbackData = callback_data;
; 479  : 
; 480  :     AddDrawCmd(); // Force a new command after us (see comment below)

	jmp	?AddDrawCmd@ImDrawList@@QEAAXXZ		; ImDrawList::AddDrawCmd
?AddCallback@ImDrawList@@QEAAXP6AXPEBU1@PEBUImDrawCmd@@@ZPEAX@Z ENDP ; ImDrawList::AddCallback
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?_OnChangedClipRect@ImDrawList@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_OnChangedClipRect@ImDrawList@@QEAAXXZ PROC		; ImDrawList::_OnChangedClipRect, COMDAT

; 505  : {

$LN17:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 506  :     // If current command is used with different settings we need to add a new command
; 507  :     IM_ASSERT_PARANOID(CmdBuffer.Size > 0);
; 508  :     ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];

	movsxd	r14, DWORD PTR [rcx]
	mov	rdi, rcx
	imul	rbx, r14, 56				; 00000038H
	add	rbx, QWORD PTR [rcx+8]

; 509  :     if (curr_cmd->ElemCount != 0 && memcmp(&curr_cmd->ClipRect, &_CmdHeader.ClipRect, sizeof(ImVec4)) != 0)

	cmp	DWORD PTR [rbx-24], 0
	je	SHORT $LN7@OnChangedC
	mov	rax, QWORD PTR [rbx-56]
	cmp	rax, QWORD PTR [rcx+136]
	jne	SHORT $LN9@OnChangedC
	mov	rax, QWORD PTR [rbx-48]
	cmp	rax, QWORD PTR [rcx+144]
	je	SHORT $LN3@OnChangedC
$LN9@OnChangedC:

; 510  :     {
; 511  :         AddDrawCmd();

	call	?AddDrawCmd@ImDrawList@@QEAAXXZ		; ImDrawList::AddDrawCmd

; 512  :         return;

	jmp	SHORT $LN1@OnChangedC
$LN7@OnChangedC:

; 513  :     }
; 514  :     IM_ASSERT(curr_cmd->UserCallback == NULL);
; 515  : 
; 516  :     // Try to merge with previous command if it matches, else use current command
; 517  :     ImDrawCmd* prev_cmd = curr_cmd - 1;
; 518  :     if (curr_cmd->ElemCount == 0 && CmdBuffer.Size > 1 && ImDrawCmd_HeaderCompare(&_CmdHeader, prev_cmd) == 0 && ImDrawCmd_AreSequentialIdxOffset(prev_cmd, curr_cmd) && prev_cmd->UserCallback == NULL)

	cmp	r14d, 1
	jle	SHORT $LN3@OnChangedC
	mov	r8d, 28
	lea	rdx, QWORD PTR [rbx-112]
	add	rcx, 136				; 00000088H
	call	memcmp
	test	eax, eax
	jne	SHORT $LN3@OnChangedC
	mov	eax, DWORD PTR [rbx-80]
	add	eax, DWORD PTR [rbx-84]
	cmp	eax, DWORD PTR [rbx-28]
	jne	SHORT $LN3@OnChangedC
	cmp	QWORD PTR [rbx-72], 0
	jne	SHORT $LN3@OnChangedC
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	lea	eax, DWORD PTR [r14-1]
	mov	DWORD PTR [rdi], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 521  :         return;

	jmp	SHORT $LN1@OnChangedC
$LN3@OnChangedC:

; 522  :     }
; 523  : 
; 524  :     curr_cmd->ClipRect = _CmdHeader.ClipRect;

	movups	xmm0, XMMWORD PTR [rdi+136]
	movups	XMMWORD PTR [rbx-56], xmm0
$LN1@OnChangedC:

; 525  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
?_OnChangedClipRect@ImDrawList@@QEAAXXZ ENDP		; ImDrawList::_OnChangedClipRect
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?_OnChangedTextureID@ImDrawList@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_OnChangedTextureID@ImDrawList@@QEAAXXZ PROC		; ImDrawList::_OnChangedTextureID, COMDAT

; 528  : {

$LN18:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rdi
	sub	rsp, 32					; 00000020H

; 529  :     // If current command is used with different settings we need to add a new command
; 530  :     IM_ASSERT_PARANOID(CmdBuffer.Size > 0);
; 531  :     ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];

	movsxd	rbp, DWORD PTR [rcx]
	mov	rbx, rcx
	imul	rdi, rbp, 56				; 00000038H
	add	rdi, QWORD PTR [rcx+8]

; 532  :     if (curr_cmd->ElemCount != 0 && curr_cmd->TextureId != _CmdHeader.TextureId)

	mov	ecx, DWORD PTR [rdi-24]
	test	ecx, ecx
	je	SHORT $LN8@OnChangedT
	mov	rax, QWORD PTR [rbx+152]
	cmp	QWORD PTR [rdi-40], rax
	je	SHORT $LN8@OnChangedT

; 533  :     {
; 534  :         AddDrawCmd();

	mov	rcx, rbx

; 548  : }

	mov	rbx, QWORD PTR [rsp+56]
	mov	rbp, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi

; 533  :     {
; 534  :         AddDrawCmd();

	jmp	?AddDrawCmd@ImDrawList@@QEAAXXZ		; ImDrawList::AddDrawCmd
$LN8@OnChangedT:
	mov	QWORD PTR [rsp+48], rsi

; 535  :         return;
; 536  :     }
; 537  :     IM_ASSERT(curr_cmd->UserCallback == NULL);
; 538  : 
; 539  :     // Try to merge with previous command if it matches, else use current command
; 540  :     ImDrawCmd* prev_cmd = curr_cmd - 1;
; 541  :     if (curr_cmd->ElemCount == 0 && CmdBuffer.Size > 1 && ImDrawCmd_HeaderCompare(&_CmdHeader, prev_cmd) == 0 && ImDrawCmd_AreSequentialIdxOffset(prev_cmd, curr_cmd) && prev_cmd->UserCallback == NULL)

	test	ecx, ecx
	jne	SHORT $LN3@OnChangedT
	cmp	ebp, 1
	jle	SHORT $LN3@OnChangedT
	lea	rcx, QWORD PTR [rbx+136]
	mov	r8d, 28
	lea	rdx, QWORD PTR [rdi-112]
	call	memcmp
	test	eax, eax
	jne	SHORT $LN3@OnChangedT
	mov	eax, DWORD PTR [rdi-80]
	add	eax, DWORD PTR [rdi-84]
	cmp	eax, DWORD PTR [rdi-28]
	jne	SHORT $LN3@OnChangedT
	cmp	QWORD PTR [rdi-72], 0
	jne	SHORT $LN3@OnChangedT
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	lea	eax, DWORD PTR [rbp-1]
	mov	DWORD PTR [rbx], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 544  :         return;

	jmp	SHORT $LN16@OnChangedT
$LN3@OnChangedT:

; 545  :     }
; 546  : 
; 547  :     curr_cmd->TextureId = _CmdHeader.TextureId;

	mov	rax, QWORD PTR [rbx+152]
	mov	QWORD PTR [rdi-40], rax
$LN16@OnChangedT:

; 548  : }

	mov	rsi, QWORD PTR [rsp+48]
	mov	rbx, QWORD PTR [rsp+56]
	mov	rbp, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_OnChangedTextureID@ImDrawList@@QEAAXXZ ENDP		; ImDrawList::_OnChangedTextureID
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?_OnChangedVtxOffset@ImDrawList@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_OnChangedVtxOffset@ImDrawList@@QEAAXXZ PROC		; ImDrawList::_OnChangedVtxOffset, COMDAT

; 552  :     // We don't need to compare curr_cmd->VtxOffset != _CmdHeader.VtxOffset because we know it'll be different at the time we call this.
; 553  :     _VtxCurrentIdx = 0;
; 554  :     IM_ASSERT_PARANOID(CmdBuffer.Size > 0);
; 555  :     ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];

	movsxd	rax, DWORD PTR [rcx]
	imul	r8, rax, 56				; 00000038H
	mov	DWORD PTR [rcx+52], 0
	add	r8, QWORD PTR [rcx+8]

; 556  :     //IM_ASSERT(curr_cmd->VtxOffset != _CmdHeader.VtxOffset); // See #3349
; 557  :     if (curr_cmd->ElemCount != 0)

	cmp	DWORD PTR [r8-24], 0
	jne	?AddDrawCmd@ImDrawList@@QEAAXXZ		; ImDrawList::AddDrawCmd
$LN2@OnChangedV:

; 558  :     {
; 559  :         AddDrawCmd();
; 560  :         return;
; 561  :     }
; 562  :     IM_ASSERT(curr_cmd->UserCallback == NULL);
; 563  :     curr_cmd->VtxOffset = _CmdHeader.VtxOffset;

	mov	eax, DWORD PTR [rcx+160]
	mov	DWORD PTR [r8-32], eax

; 564  : }

	ret	0
?_OnChangedVtxOffset@ImDrawList@@QEAAXXZ ENDP		; ImDrawList::_OnChangedVtxOffset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?PrimReserve@ImDrawList@@QEAAXHH@Z
_TEXT	SEGMENT
this$ = 64
idx_count$ = 72
vtx_count$ = 80
?PrimReserve@ImDrawList@@QEAAXHH@Z PROC			; ImDrawList::PrimReserve, COMDAT

; 626  : {

$LN29:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 627  :     // Large mesh support (when enabled)
; 628  :     IM_ASSERT_PARANOID(idx_count >= 0 && vtx_count >= 0);
; 629  :     if (sizeof(ImDrawIdx) == 2 && (_VtxCurrentIdx + vtx_count >= (1 << 16)) && (Flags & ImDrawListFlags_AllowVtxOffset))

	mov	r9d, DWORD PTR [rcx+52]
	mov	edi, r8d
	add	r9d, r8d
	mov	ebp, edx
	mov	rbx, rcx
	cmp	r9d, 65536				; 00010000H
	jb	SHORT $LN4@PrimReserv
	test	BYTE PTR [rcx+48], 8
	je	SHORT $LN4@PrimReserv

; 555  :     ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];

	movsxd	rax, DWORD PTR [rcx]

; 630  :     {
; 631  :         // FIXME: In theory we should be testing that vtx_count <64k here.
; 632  :         // In practice, RenderText() relies on reserving ahead for a worst case scenario so it is currently useful for us
; 633  :         // to not make that check until we rework the text functions to handle clipping and large horizontal lines better.
; 634  :         _CmdHeader.VtxOffset = VtxBuffer.Size;

	mov	edx, DWORD PTR [rcx+32]

; 555  :     ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];

	imul	r8, rax, 56				; 00000038H
	mov	rax, QWORD PTR [rcx+8]

; 630  :     {
; 631  :         // FIXME: In theory we should be testing that vtx_count <64k here.
; 632  :         // In practice, RenderText() relies on reserving ahead for a worst case scenario so it is currently useful for us
; 633  :         // to not make that check until we rework the text functions to handle clipping and large horizontal lines better.
; 634  :         _CmdHeader.VtxOffset = VtxBuffer.Size;

	mov	DWORD PTR [rcx+160], edx

; 553  :     _VtxCurrentIdx = 0;

	mov	DWORD PTR [rcx+52], 0

; 556  :     //IM_ASSERT(curr_cmd->VtxOffset != _CmdHeader.VtxOffset); // See #3349
; 557  :     if (curr_cmd->ElemCount != 0)

	cmp	DWORD PTR [r8+rax-24], 0
	je	SHORT $LN5@PrimReserv

; 558  :     {
; 559  :         AddDrawCmd();

	call	?AddDrawCmd@ImDrawList@@QEAAXXZ		; ImDrawList::AddDrawCmd

; 560  :         return;

	jmp	SHORT $LN4@PrimReserv
$LN5@PrimReserv:

; 561  :     }
; 562  :     IM_ASSERT(curr_cmd->UserCallback == NULL);
; 563  :     curr_cmd->VtxOffset = _CmdHeader.VtxOffset;

	mov	DWORD PTR [r8+rax-32], edx
$LN4@PrimReserv:

; 635  :         _OnChangedVtxOffset();
; 636  :     }
; 637  : 
; 638  :     ImDrawCmd* draw_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];

	movsxd	rax, DWORD PTR [rbx]
	imul	rcx, rax, 56				; 00000038H
	mov	rax, QWORD PTR [rbx+8]

; 639  :     draw_cmd->ElemCount += idx_count;

	add	DWORD PTR [rcx+rax-24], ebp

; 640  : 
; 641  :     int vtx_buffer_old_size = VtxBuffer.Size;

	movsxd	r15, DWORD PTR [rbx+32]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	ecx, DWORD PTR [rbx+36]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 642  :     VtxBuffer.resize(vtx_buffer_old_size + vtx_count);

	lea	esi, DWORD PTR [r15+rdi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	edi, 8
	cmp	esi, ecx
	jle	SHORT $LN8@PrimReserv

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN12@PrimReserv
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN13@PrimReserv
$LN12@PrimReserv:
	mov	eax, edi
$LN13@PrimReserv:
	cmp	eax, esi

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	lea	rcx, QWORD PTR [rbx+32]

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	edx, esi
	cmovg	edx, eax

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	call	?reserve@?$ImVector@UImDrawVert@@@@QEAAXH@Z ; ImVector<ImDrawVert>::reserve
$LN8@PrimReserv:
	mov	DWORD PTR [rbx+32], esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 643  :     _VtxWritePtr = VtxBuffer.Data + vtx_buffer_old_size;

	lea	rcx, QWORD PTR [r15+r15*4]
	mov	rax, QWORD PTR [rbx+40]

; 644  : 
; 645  :     int idx_buffer_old_size = IdxBuffer.Size;

	movsxd	r15, DWORD PTR [rbx+16]
	lea	rcx, QWORD PTR [rax+rcx*4]
	mov	QWORD PTR [rbx+72], rcx

; 646  :     IdxBuffer.resize(idx_buffer_old_size + idx_count);

	lea	esi, DWORD PTR [r15+rbp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	ecx, DWORD PTR [rbx+20]
	cmp	esi, ecx
	jle	SHORT $LN15@PrimReserv

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN19@PrimReserv
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	lea	edi, DWORD PTR [rcx+rax]
$LN19@PrimReserv:
	cmp	edi, esi

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	lea	rcx, QWORD PTR [rbx+16]

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	edx, esi
	cmovg	edx, edi

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	call	?reserve@?$ImVector@G@@QEAAXH@Z		; ImVector<unsigned short>::reserve
$LN15@PrimReserv:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 648  : }

	mov	rbp, QWORD PTR [rsp+72]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [rbx+16], esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 647  :     _IdxWritePtr = IdxBuffer.Data + idx_buffer_old_size;

	mov	rax, QWORD PTR [rbx+24]

; 648  : }

	mov	rsi, QWORD PTR [rsp+80]
	lea	rcx, QWORD PTR [rax+r15*2]
	mov	QWORD PTR [rbx+80], rcx
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
?PrimReserve@ImDrawList@@QEAAXHH@Z ENDP			; ImDrawList::PrimReserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?PrimRect@ImDrawList@@QEAAXAEBUImVec2@@0I@Z
_TEXT	SEGMENT
this$ = 32
a$ = 40
c$ = 48
col$ = 56
?PrimRect@ImDrawList@@QEAAXAEBUImVec2@@0I@Z PROC	; ImDrawList::PrimRect, COMDAT

; 663  : {

$LN8:
	sub	rsp, 24

; 664  :     ImVec2 b(c.x, a.y), d(a.x, c.y), uv(_Data->TexUvWhitePixel);

	mov	rax, QWORD PTR [rcx+56]
	mov	r11, rcx

; 665  :     ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;

	movzx	r10d, WORD PTR [rcx+52]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm1, DWORD PTR [r8]
	movss	xmm2, DWORD PTR [rdx+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 664  :     ImVec2 b(c.x, a.y), d(a.x, c.y), uv(_Data->TexUvWhitePixel);

	movss	xmm5, DWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm3, DWORD PTR [rdx]
	movss	xmm4, DWORD PTR [r8+4]
	movaps	XMMWORD PTR [rsp], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 664  :     ImVec2 b(c.x, a.y), d(a.x, c.y), uv(_Data->TexUvWhitePixel);

	movss	xmm6, DWORD PTR [rax+4]

; 666  :     _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);

	mov	rax, QWORD PTR [rcx+80]
	lea	ecx, DWORD PTR [r10+1]
	mov	WORD PTR [rax], r10w
	mov	rax, QWORD PTR [r11+80]
	mov	WORD PTR [rax+2], cx
	lea	ecx, DWORD PTR [r10+2]
	mov	rax, QWORD PTR [r11+80]
	mov	WORD PTR [rax+4], cx

; 667  :     _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx+2); _IdxWritePtr[5] = (ImDrawIdx)(idx+3);

	mov	rax, QWORD PTR [r11+80]
	mov	WORD PTR [rax+6], r10w
	add	r10w, 3
	mov	rax, QWORD PTR [r11+80]
	mov	WORD PTR [rax+8], cx
	mov	rax, QWORD PTR [r11+80]
	mov	WORD PTR [rax+10], r10w

; 668  :     _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;

	movsd	xmm0, QWORD PTR [rdx]
	mov	rax, QWORD PTR [r11+72]
	movsd	QWORD PTR [rax], xmm0
	mov	rax, QWORD PTR [r11+72]
	movss	DWORD PTR [rax+8], xmm5
	movss	DWORD PTR [rax+12], xmm6
	mov	rax, QWORD PTR [r11+72]
	mov	DWORD PTR [rax+16], r9d

; 669  :     _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col;

	mov	rax, QWORD PTR [r11+72]
	movss	DWORD PTR [rax+20], xmm1
	movss	DWORD PTR [rax+24], xmm2
	mov	rax, QWORD PTR [r11+72]
	movss	DWORD PTR [rax+28], xmm5
	movss	DWORD PTR [rax+32], xmm6
	mov	rax, QWORD PTR [r11+72]
	mov	DWORD PTR [rax+36], r9d

; 670  :     _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col;

	movsd	xmm0, QWORD PTR [r8]
	mov	rax, QWORD PTR [r11+72]
	movsd	QWORD PTR [rax+40], xmm0
	mov	rax, QWORD PTR [r11+72]
	movss	DWORD PTR [rax+48], xmm5
	movss	DWORD PTR [rax+52], xmm6
	mov	rax, QWORD PTR [r11+72]
	mov	DWORD PTR [rax+56], r9d

; 671  :     _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv; _VtxWritePtr[3].col = col;

	mov	rax, QWORD PTR [r11+72]
	movss	DWORD PTR [rax+60], xmm3
	movss	DWORD PTR [rax+64], xmm4
	mov	rax, QWORD PTR [r11+72]
	movss	DWORD PTR [rax+68], xmm5
	movss	DWORD PTR [rax+72], xmm6
	mov	rax, QWORD PTR [r11+72]

; 672  :     _VtxWritePtr += 4;
; 673  :     _VtxCurrentIdx += 4;
; 674  :     _IdxWritePtr += 6;
; 675  : }

	movaps	xmm6, XMMWORD PTR [rsp]
	mov	DWORD PTR [rax+76], r9d
	add	QWORD PTR [r11+72], 80			; 00000050H
	add	DWORD PTR [r11+52], 4
	add	QWORD PTR [r11+80], 12
	add	rsp, 24
	ret	0
?PrimRect@ImDrawList@@QEAAXAEBUImVec2@@0I@Z ENDP	; ImDrawList::PrimRect
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?PrimRectUV@ImDrawList@@QEAAXAEBUImVec2@@000I@Z
_TEXT	SEGMENT
this$ = 80
a$ = 88
c$ = 96
uv_a$ = 104
uv_c$ = 112
col$ = 120
?PrimRectUV@ImDrawList@@QEAAXAEBUImVec2@@000I@Z PROC	; ImDrawList::PrimRectUV, COMDAT

; 678  : {

$LN12:
	push	rbx
	sub	rsp, 64					; 00000040H

; 681  :     _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);

	mov	rax, QWORD PTR [rcx+80]
	mov	rbx, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm4, DWORD PTR [r8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 678  : {

	mov	r11, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm5, DWORD PTR [rdx+4]
	movss	xmm3, DWORD PTR [r9+4]
	mov	r10, QWORD PTR uv_c$[rsp]
	movaps	XMMWORD PTR [rsp+48], xmm6
	movss	xmm6, DWORD PTR [r9]
	movaps	XMMWORD PTR [rsp+32], xmm7
	movss	xmm7, DWORD PTR [r10+4]
	movss	xmm2, DWORD PTR [r10]
	movaps	XMMWORD PTR [rsp+16], xmm8
	movss	xmm8, DWORD PTR [rdx]
	movaps	XMMWORD PTR [rsp], xmm9
	movss	xmm9, DWORD PTR [r8+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 680  :     ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;

	movzx	r8d, WORD PTR [rcx+52]

; 681  :     _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);

	mov	WORD PTR [rax], r8w
	mov	rax, QWORD PTR [rbx+80]
	lea	ecx, DWORD PTR [r8+1]
	mov	WORD PTR [rax+2], cx
	lea	ecx, DWORD PTR [r8+2]
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+4], cx

; 682  :     _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx+2); _IdxWritePtr[5] = (ImDrawIdx)(idx+3);

	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+6], r8w
	add	r8w, 3
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+8], cx
	mov	rax, QWORD PTR [rbx+80]

; 683  :     _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv_a; _VtxWritePtr[0].col = col;

	mov	ecx, DWORD PTR col$[rsp]
	mov	WORD PTR [rax+10], r8w
	movsd	xmm0, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rbx+72]
	movsd	QWORD PTR [rax], xmm0
	movsd	xmm1, QWORD PTR [r9]
	mov	rax, QWORD PTR [rbx+72]
	movsd	QWORD PTR [rax+8], xmm1
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+16], ecx

; 684  :     _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv_b; _VtxWritePtr[1].col = col;

	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+20], xmm4
	movss	DWORD PTR [rax+24], xmm5
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+28], xmm2
	movss	DWORD PTR [rax+32], xmm3
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+36], ecx

; 685  :     _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv_c; _VtxWritePtr[2].col = col;

	movsd	xmm0, QWORD PTR [r11]
	mov	rax, QWORD PTR [rbx+72]
	movsd	QWORD PTR [rax+40], xmm0
	movsd	xmm1, QWORD PTR [r10]
	mov	rax, QWORD PTR [rbx+72]
	movsd	QWORD PTR [rax+48], xmm1
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+56], ecx

; 686  :     _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv_d; _VtxWritePtr[3].col = col;

	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+60], xmm8

; 687  :     _VtxWritePtr += 4;
; 688  :     _VtxCurrentIdx += 4;
; 689  :     _IdxWritePtr += 6;
; 690  : }

	movaps	xmm8, XMMWORD PTR [rsp+16]
	movss	DWORD PTR [rax+64], xmm9
	mov	rax, QWORD PTR [rbx+72]
	movaps	xmm9, XMMWORD PTR [rsp]
	movss	DWORD PTR [rax+68], xmm6
	movaps	xmm6, XMMWORD PTR [rsp+48]
	movss	DWORD PTR [rax+72], xmm7
	mov	rax, QWORD PTR [rbx+72]
	movaps	xmm7, XMMWORD PTR [rsp+32]
	mov	DWORD PTR [rax+76], ecx
	add	QWORD PTR [rbx+72], 80			; 00000050H
	add	DWORD PTR [rbx+52], 4
	add	QWORD PTR [rbx+80], 12
	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
?PrimRectUV@ImDrawList@@QEAAXAEBUImVec2@@000I@Z ENDP	; ImDrawList::PrimRectUV
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z
_TEXT	SEGMENT
this$ = 96
center$ = 104
extra_max_sample$1$ = 112
radius$ = 112
a_min_sample$ = 120
a_max_sample$ = 128
tv703 = 136
a_step$dead$ = 136
?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z PROC ; ImDrawList::_PathArcToFastEx, COMDAT

; 1056 : {

$LN59:
	push	rbp
	push	rdi
	push	r14
	push	r15
	sub	rsp, 56					; 00000038H

; 1057 :     if (radius < 0.5f)

	movss	xmm0, DWORD PTR __real@3f000000
	mov	edi, r9d
	mov	r14d, DWORD PTR a_max_sample$[rsp]
	mov	r15, rdx
	movaps	XMMWORD PTR [rsp+32], xmm6
	mov	rbp, rcx
	movaps	xmm6, xmm2
	comiss	xmm0, xmm6
	jbe	SHORT $LN8@PathArcToF

; 1058 :     {
; 1059 :         _Path.push_back(center);

	add	rcx, 120				; 00000078H

; 1141 :         out_ptr++;
; 1142 :     }
; 1143 : 
; 1144 :     IM_ASSERT_PARANOID(_Path.Data + _Path.Size == out_ptr);
; 1145 : }

	movaps	xmm6, XMMWORD PTR [rsp+32]
	add	rsp, 56					; 00000038H
	pop	r15
	pop	r14
	pop	rdi
	pop	rbp

; 1058 :     {
; 1059 :         _Path.push_back(center);

	jmp	?push_back@?$ImVector@UImVec2@@@@QEAAXAEBUImVec2@@@Z ; ImVector<ImVec2>::push_back
$LN8@PathArcToF:
	mov	QWORD PTR [rsp+96], rbx

; 1065 :         a_step = IM_DRAWLIST_ARCFAST_SAMPLE_MAX / _CalcCircleAutoSegmentCount(radius);

	movaps	xmm1, xmm6
	mov	QWORD PTR [rsp+104], rsi
	mov	QWORD PTR [rsp+120], r12
	mov	QWORD PTR [rsp+48], r13
	call	?_CalcCircleAutoSegmentCount@ImDrawList@@QEBAHM@Z ; ImDrawList::_CalcCircleAutoSegmentCount
	mov	ecx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	mov	BYTE PTR extra_max_sample$1$[rsp], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1065 :         a_step = IM_DRAWLIST_ARCFAST_SAMPLE_MAX / _CalcCircleAutoSegmentCount(radius);

	mov	eax, 48					; 00000030H
	cdq
	idiv	ecx
	mov	ebx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	cmp	eax, 1
	jge	SHORT $LN25@PathArcToF
	mov	eax, r14d
	mov	esi, 1
	sub	eax, edi
	mov	ebx, esi
	cdq
	mov	ecx, eax
	xor	ecx, edx
	sub	ecx, edx
	inc	ecx
	jmp	SHORT $LN12@PathArcToF
$LN25@PathArcToF:
	mov	eax, 12
	cmp	ebx, eax
	cmovg	ebx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1070 :     const int sample_range = ImAbs(a_max_sample - a_min_sample);

	mov	eax, r14d
	sub	eax, edi

; 1074 :     bool extra_max_sample = false;

	mov	esi, ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 440  : static inline int    ImAbs(int x)               { return x < 0 ? -x : x; }

	cdq
	mov	r8d, eax
	xor	r8d, edx
	sub	r8d, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1073 :     int samples = sample_range + 1;

	lea	ecx, DWORD PTR [r8+1]

; 1075 :     if (a_step > 1)

	cmp	ebx, 1
	jle	SHORT $LN12@PathArcToF

; 1076 :     {
; 1077 :         samples            = sample_range / a_step + 1;

	mov	eax, r8d
	cdq
	idiv	ebx
	lea	ecx, DWORD PTR [rax+1]

; 1078 :         const int overstep = sample_range % a_step;

	mov	eax, r8d
	cdq
	idiv	ebx

; 1079 : 
; 1080 :         if (overstep > 0)

	test	edx, edx
	jle	SHORT $LN12@PathArcToF

; 1081 :         {
; 1082 :             extra_max_sample = true;
; 1083 :             samples++;

	inc	ecx
	mov	BYTE PTR extra_max_sample$1$[rsp], 1

; 1084 : 
; 1085 :             // When we have overstep to avoid awkwardly looking one long line and one tiny one at the end,
; 1086 :             // distribute first step range evenly between them by reducing first step size.
; 1087 :             if (sample_range > 0)

	test	r8d, r8d
	jle	SHORT $LN12@PathArcToF

; 1088 :                 a_step -= (a_step - overstep) / 2;

	mov	eax, ebx
	sub	eax, edx
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	esi, eax
$LN12@PathArcToF:

; 1089 :         }
; 1090 :     }
; 1091 : 
; 1092 :     _Path.resize(_Path.Size + samples);

	mov	eax, DWORD PTR [rbp+120]
	mov	DWORD PTR tv703[rsp], eax
	lea	r13d, DWORD PTR [rax+rcx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	ecx, DWORD PTR [rbp+124]
	cmp	r13d, ecx
	jle	SHORT $LN30@PathArcToF

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN34@PathArcToF
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN35@PathArcToF
$LN34@PathArcToF:
	mov	eax, 8
$LN35@PathArcToF:
	cmp	eax, r13d

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	lea	rcx, QWORD PTR [rbp+120]

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	edx, r13d
	cmovg	edx, eax

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
	mov	eax, DWORD PTR tv703[rsp]
$LN30@PathArcToF:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1095 :     int sample_index = a_min_sample;

	mov	r12, QWORD PTR [rsp+120]
	movsxd	rcx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [rbp+120], r13d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1093 :     ImVec2* out_ptr = _Path.Data + (_Path.Size - samples);

	mov	rax, QWORD PTR [rbp+128]

; 1095 :     int sample_index = a_min_sample;

	mov	r13, QWORD PTR [rsp+48]
	lea	r8, QWORD PTR [rax+rcx*8]
	mov	ecx, edi

; 1096 :     if (sample_index < 0 || sample_index >= IM_DRAWLIST_ARCFAST_SAMPLE_MAX)

	cmp	edi, 47					; 0000002fH
	jbe	SHORT $LN15@PathArcToF

; 1097 :     {
; 1098 :         sample_index = sample_index % IM_DRAWLIST_ARCFAST_SAMPLE_MAX;

	mov	eax, 715827883				; 2aaaaaabH
	imul	edi
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	lea	eax, DWORD PTR [rdx+rdx*2]
	shl	eax, 4
	sub	ecx, eax

; 1099 :         if (sample_index < 0)

	jns	SHORT $LN15@PathArcToF

; 1100 :             sample_index += IM_DRAWLIST_ARCFAST_SAMPLE_MAX;

	add	ecx, 48					; 00000030H
$LN15@PathArcToF:

; 1101 :     }
; 1102 : 
; 1103 :     if (a_max_sample >= a_min_sample)

	movsxd	rdx, ecx
	movsxd	r9, esi
	movsxd	r10, ebx
	cmp	r14d, edi
	jl	SHORT $LL16@PathArcToF
	npad	14
$LL4@PathArcToF:

; 1104 :     {
; 1105 :         for (int a = a_min_sample; a <= a_max_sample; a += a_step, sample_index += a_step, a_step = a_next_step)
; 1106 :         {
; 1107 :             // a_step is clamped to IM_DRAWLIST_ARCFAST_SAMPLE_MAX, so we have guaranteed that it will not wrap over range twice or more
; 1108 :             if (sample_index >= IM_DRAWLIST_ARCFAST_SAMPLE_MAX)
; 1109 :                 sample_index -= IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
; 1110 : 
; 1111 :             const ImVec2 s = _Data->ArcFastVtx[sample_index];

	mov	rax, QWORD PTR [rbp+56]
	lea	rcx, QWORD PTR [rdx-48]
	cmp	rdx, 48					; 00000030H
	cmovl	rcx, rdx
	add	edi, esi
	mov	esi, ebx
	movss	xmm0, DWORD PTR [rax+rcx*8+64]
	lea	rdx, QWORD PTR [rcx+r9]
	movss	xmm1, DWORD PTR [rax+rcx*8+68]
	mov	r9, r10

; 1112 :             out_ptr->x = center.x + s.x * radius;

	mulss	xmm0, xmm6

; 1113 :             out_ptr->y = center.y + s.y * radius;

	mulss	xmm1, xmm6
	addss	xmm0, DWORD PTR [r15]
	movss	DWORD PTR [r8], xmm0
	addss	xmm1, DWORD PTR [r15+4]
	movss	DWORD PTR [r8+4], xmm1

; 1114 :             out_ptr++;

	add	r8, 8
	cmp	edi, r14d
	jle	SHORT $LL4@PathArcToF
	jmp	SHORT $LN6@PathArcToF
$LL16@PathArcToF:

; 1115 :         }
; 1116 :     }
; 1117 :     else
; 1118 :     {
; 1119 :         for (int a = a_min_sample; a >= a_max_sample; a -= a_step, sample_index -= a_step, a_step = a_next_step)
; 1120 :         {
; 1121 :             // a_step is clamped to IM_DRAWLIST_ARCFAST_SAMPLE_MAX, so we have guaranteed that it will not wrap over range twice or more
; 1122 :             if (sample_index < 0)
; 1123 :                 sample_index += IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
; 1124 : 
; 1125 :             const ImVec2 s = _Data->ArcFastVtx[sample_index];

	test	rdx, rdx
	lea	rax, QWORD PTR [rdx+48]
	cmovns	rax, rdx
	sub	edi, esi
	mov	rdx, rax
	mov	esi, ebx
	mov	rax, QWORD PTR [rbp+56]
	movss	xmm0, DWORD PTR [rax+rdx*8+64]
	movss	xmm1, DWORD PTR [rax+rdx*8+68]
	sub	rdx, r9

; 1126 :             out_ptr->x = center.x + s.x * radius;

	mulss	xmm0, xmm6
	mov	r9, r10

; 1127 :             out_ptr->y = center.y + s.y * radius;

	mulss	xmm1, xmm6
	addss	xmm0, DWORD PTR [r15]
	movss	DWORD PTR [r8], xmm0
	addss	xmm1, DWORD PTR [r15+4]
	movss	DWORD PTR [r8+4], xmm1

; 1128 :             out_ptr++;

	add	r8, 8
	cmp	edi, r14d
	jge	SHORT $LL16@PathArcToF
$LN6@PathArcToF:

; 1129 :         }
; 1130 :     }
; 1131 : 
; 1132 :     if (extra_max_sample)

	cmp	BYTE PTR extra_max_sample$1$[rsp], 0
	mov	rsi, QWORD PTR [rsp+104]
	mov	rbx, QWORD PTR [rsp+96]
	je	SHORT $LN20@PathArcToF

; 1133 :     {
; 1134 :         int normalized_max_sample = a_max_sample % IM_DRAWLIST_ARCFAST_SAMPLE_MAX;

	mov	eax, 715827883				; 2aaaaaabH
	imul	r14d
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	lea	eax, DWORD PTR [rdx+rdx*2]
	shl	eax, 4
	sub	r14d, eax

; 1135 :         if (normalized_max_sample < 0)
; 1136 :             normalized_max_sample += IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
; 1137 : 
; 1138 :         const ImVec2 s = _Data->ArcFastVtx[normalized_max_sample];

	lea	eax, DWORD PTR [r14+48]
	cmovns	eax, r14d
	movsxd	rcx, eax
	mov	rax, QWORD PTR [rbp+56]
	movss	xmm0, DWORD PTR [rax+rcx*8+64]
	movss	xmm1, DWORD PTR [rax+rcx*8+68]

; 1139 :         out_ptr->x = center.x + s.x * radius;

	mulss	xmm0, xmm6

; 1140 :         out_ptr->y = center.y + s.y * radius;

	mulss	xmm1, xmm6
	addss	xmm0, DWORD PTR [r15]
	movss	DWORD PTR [r8], xmm0
	addss	xmm1, DWORD PTR [r15+4]
	movss	DWORD PTR [r8+4], xmm1
$LN20@PathArcToF:

; 1141 :         out_ptr++;
; 1142 :     }
; 1143 : 
; 1144 :     IM_ASSERT_PARANOID(_Path.Data + _Path.Size == out_ptr);
; 1145 : }

	movaps	xmm6, XMMWORD PTR [rsp+32]
	add	rsp, 56					; 00000038H
	pop	r15
	pop	r14
	pop	rdi
	pop	rbp
	ret	0
?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z ENDP ; ImDrawList::_PathArcToFastEx
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 144
center$ = 152
radius$ = 160
a_min$ = 168
a_max$ = 176
num_segments$ = 184
?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z PROC	; ImDrawList::_PathArcToN, COMDAT

; 1148 : {

$LN27:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	sub	rsp, 128				; 00000080H

; 1149 :     if (radius < 0.5f)

	movss	xmm0, DWORD PTR __real@3f000000
	lea	rbx, QWORD PTR [rcx+120]
	movaps	XMMWORD PTR [rsp+80], xmm8
	mov	rbp, rdx
	movaps	xmm8, xmm2
	movaps	XMMWORD PTR [rsp+64], xmm9
	comiss	xmm0, xmm8
	mov	rcx, rbx
	movaps	xmm9, xmm3
	jbe	SHORT $LN5@PathArcToN

; 1150 :     {
; 1151 :         _Path.push_back(center);

	call	?push_back@?$ImVector@UImVec2@@@@QEAAXAEBUImVec2@@@Z ; ImVector<ImVec2>::push_back

; 1152 :         return;

	jmp	$LN3@PathArcToN
$LN5@PathArcToN:
	mov	QWORD PTR [rsp+144], rsi

; 1153 :     }
; 1154 : 
; 1155 :     // Note that we are adding a point at both a_min and a_max.
; 1156 :     // If you are trying to draw a full closed circle you don't want the overlapping points!
; 1157 :     _Path.reserve(_Path.Size + (num_segments + 1));

	mov	esi, DWORD PTR num_segments$[rsp]
	mov	QWORD PTR [rsp+152], rdi
	lea	edx, DWORD PTR [rsi+1]
	add	edx, DWORD PTR [rbx]
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
	xor	edi, edi

; 1158 :     for (int i = 0; i <= num_segments; i++)

	test	esi, esi
	js	$LN25@PathArcToN
	movaps	XMMWORD PTR [rsp+112], xmm6
	movaps	XMMWORD PTR [rsp+96], xmm7
	movss	xmm7, DWORD PTR a_max$[rsp]
	movaps	XMMWORD PTR [rsp+48], xmm10
	subss	xmm7, xmm9
	movd	xmm10, esi
	cvtdq2ps xmm10, xmm10
	npad	11
$LL4@PathArcToN:

; 1159 :     {
; 1160 :         const float a = a_min + ((float)i / (float)num_segments) * (a_max - a_min);

	xorps	xmm6, xmm6
	cvtsi2ss xmm6, edi
	divss	xmm6, xmm10
	mulss	xmm6, xmm7
	addss	xmm6, xmm9

; 1161 :         _Path.push_back(ImVec2(center.x + ImCos(a) * radius, center.y + ImSin(a) * radius));

	movaps	xmm0, xmm6
	call	cosf
	mulss	xmm0, xmm8
	addss	xmm0, DWORD PTR [rbp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T1[rsp], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1161 :         _Path.push_back(ImVec2(center.x + ImCos(a) * radius, center.y + ImSin(a) * radius));

	movaps	xmm0, xmm6
	call	sinf
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	ecx, DWORD PTR [rbx]
	mov	r8d, DWORD PTR [rbx+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1161 :         _Path.push_back(ImVec2(center.x + ImCos(a) * radius, center.y + ImSin(a) * radius));

	mulss	xmm0, xmm8
	addss	xmm0, DWORD PTR [rbp+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T1[rsp+4], xmm0

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	cmp	ecx, r8d
	jne	SHORT $LN10@PathArcToN
	inc	ecx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	r8d, r8d
	je	SHORT $LN14@PathArcToN
	mov	eax, r8d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r8d
	jmp	SHORT $LN15@PathArcToN
$LN14@PathArcToN:
	mov	eax, 8
$LN15@PathArcToN:
	cmp	eax, ecx
	cmovg	ecx, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, ecx
	mov	rcx, rbx
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN10@PathArcToN:
	movsxd	rdx, DWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1158 :     for (int i = 0; i <= num_segments; i++)

	inc	edi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rcx, QWORD PTR [rbx+8]
	mov	rax, QWORD PTR $T1[rsp]
	mov	QWORD PTR [rcx+rdx*8], rax
	inc	DWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1158 :     for (int i = 0; i <= num_segments; i++)

	cmp	edi, esi
	jle	$LL4@PathArcToN
	movaps	xmm10, XMMWORD PTR [rsp+48]
	movaps	xmm7, XMMWORD PTR [rsp+96]
	movaps	xmm6, XMMWORD PTR [rsp+112]
$LN25@PathArcToN:
	mov	rsi, QWORD PTR [rsp+144]
	mov	rdi, QWORD PTR [rsp+152]
$LN3@PathArcToN:

; 1162 :     }
; 1163 : }

	mov	rbx, QWORD PTR [rsp+160]
	movaps	xmm8, XMMWORD PTR [rsp+80]
	movaps	xmm9, XMMWORD PTR [rsp+64]
	add	rsp, 128				; 00000080H
	pop	rbp
	ret	0
?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z ENDP	; ImDrawList::_PathArcToN
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?PathBezierCubicCurveToCasteljau@@YAXPEAU?$ImVector@UImVec2@@@@MMMMMMMMMH@Z
_TEXT	SEGMENT
$T1 = 96
path$ = 288
x1$ = 296
y1$ = 304
x2$ = 312
y2$ = 320
x3$ = 328
y3$ = 336
x4$ = 344
y4$ = 352
tess_tol$ = 360
level$ = 368
?PathBezierCubicCurveToCasteljau@@YAXPEAU?$ImVector@UImVec2@@@@MMMMMMMMMH@Z PROC ; PathBezierCubicCurveToCasteljau, COMDAT

; 1247 : {

	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	movss	DWORD PTR [rax+24], xmm2
	movss	DWORD PTR [rax+16], xmm1
	push	rdi
	sub	rsp, 272				; 00000110H
	movaps	XMMWORD PTR [rax-24], xmm6
	mov	rbx, rcx
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	XMMWORD PTR [rax-56], xmm8

; 1248 :     float dx = x4 - x1;

	movss	xmm8, DWORD PTR x4$[rsp]
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	xmm5, xmm8

; 1249 :     float dy = y4 - y1;

	movss	xmm9, DWORD PTR y4$[rsp]
	subss	xmm5, xmm1
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	xmm6, xmm9
	movaps	XMMWORD PTR [rax-104], xmm11
	subss	xmm6, xmm2
	movaps	XMMWORD PTR [rax-120], xmm12
	movaps	xmm11, xmm3

; 1250 :     float d2 = (x2 - x4) * dy - (y2 - y4) * dx;

	movss	xmm12, DWORD PTR y2$[rsp]
	movaps	xmm3, xmm1
	movaps	XMMWORD PTR [rax-136], xmm13
	movaps	xmm0, xmm12

; 1251 :     float d3 = (x3 - x4) * dy - (y3 - y4) * dx;

	movss	xmm13, DWORD PTR x3$[rsp]
	subss	xmm0, xmm9
	movaps	XMMWORD PTR [rax-152], xmm14
	movaps	xmm4, xmm11
	movss	xmm14, DWORD PTR y3$[rsp]
	movaps	XMMWORD PTR [rsp+112], xmm15
	subss	xmm4, xmm8

; 1252 :     d2 = (d2 >= 0) ? d2 : -d2;

	movss	xmm15, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
	movaps	xmm1, xmm13
	mulss	xmm0, xmm5
	subss	xmm1, xmm8
	mulss	xmm4, xmm6
	mulss	xmm1, xmm6
	subss	xmm4, xmm0

; 1253 :     d3 = (d3 >= 0) ? d3 : -d3;
; 1254 :     if ((d2 + d3) * (d2 + d3) < tess_tol * (dx * dx + dy * dy))

	mulss	xmm6, xmm6
	movaps	xmm0, xmm14
	subss	xmm0, xmm9
	andps	xmm4, xmm15
	mulss	xmm0, xmm5
	mulss	xmm5, xmm5
	subss	xmm1, xmm0
	addss	xmm6, xmm5
	andps	xmm1, xmm15
	addss	xmm4, xmm1
	mulss	xmm6, DWORD PTR tess_tol$[rsp]
	mulss	xmm4, xmm4
	comiss	xmm6, xmm4
	ja	$LN17@PathBezier
	movss	xmm10, DWORD PTR __real@3f000000
	mov	edi, DWORD PTR level$[rsp]
	npad	1
$LL15@PathBezier:

; 1255 :     {
; 1256 :         path->push_back(ImVec2(x4, y4));
; 1257 :     }
; 1258 :     else if (level < 10)

	cmp	edi, 10
	jge	$LN4@PathBezier

; 1259 :     {
; 1260 :         float x12 = (x1 + x2) * 0.5f, y12 = (y1 + y2) * 0.5f;

	addss	xmm3, xmm11
	movaps	xmm5, xmm2

; 1261 :         float x23 = (x2 + x3) * 0.5f, y23 = (y2 + y3) * 0.5f;

	addss	xmm11, xmm13

; 1262 :         float x34 = (x3 + x4) * 0.5f, y34 = (y3 + y4) * 0.5f;
; 1263 :         float x123 = (x12 + x23) * 0.5f, y123 = (y12 + y23) * 0.5f;
; 1264 :         float x234 = (x23 + x34) * 0.5f, y234 = (y23 + y34) * 0.5f;
; 1265 :         float x1234 = (x123 + x234) * 0.5f, y1234 = (y123 + y234) * 0.5f;
; 1266 :         PathBezierCubicCurveToCasteljau(path, x1, y1, x12, y12, x123, y123, x1234, y1234, tess_tol, level + 1);

	inc	edi
	addss	xmm5, xmm12
	mov	DWORD PTR [rsp+80], edi
	addss	xmm12, xmm14
	mov	rcx, rbx
	addss	xmm14, xmm9
	addss	xmm13, xmm8
	mulss	xmm3, xmm10
	mulss	xmm11, xmm10
	mulss	xmm12, xmm10
	movaps	xmm0, xmm11
	mulss	xmm5, xmm10
	movaps	xmm4, xmm0
	mulss	xmm14, xmm10
	movaps	xmm1, xmm12
	mulss	xmm13, xmm10
	movaps	xmm2, xmm1
	addss	xmm4, xmm3
	movaps	xmm12, xmm14
	addss	xmm2, xmm5
	addss	xmm12, xmm1
	movaps	xmm11, xmm13
	movss	xmm1, DWORD PTR x1$[rsp]
	addss	xmm11, xmm0
	movss	xmm0, DWORD PTR tess_tol$[rsp]
	movss	DWORD PTR [rsp+72], xmm0
	mulss	xmm2, xmm10
	mulss	xmm4, xmm10
	mulss	xmm12, xmm10
	mulss	xmm11, xmm10
	movaps	xmm6, xmm12
	addss	xmm6, xmm2
	movaps	xmm7, xmm11
	addss	xmm7, xmm4
	mulss	xmm6, xmm10
	mulss	xmm7, xmm10
	movss	DWORD PTR [rsp+64], xmm6
	movss	DWORD PTR [rsp+56], xmm7
	movss	DWORD PTR [rsp+48], xmm2
	movss	xmm2, DWORD PTR y1$[rsp]
	movss	DWORD PTR [rsp+40], xmm4
	movss	DWORD PTR [rsp+32], xmm5
	call	?PathBezierCubicCurveToCasteljau@@YAXPEAU?$ImVector@UImVec2@@@@MMMMMMMMMH@Z ; PathBezierCubicCurveToCasteljau
	movaps	xmm3, xmm8

; 1267 :         PathBezierCubicCurveToCasteljau(path, x1234, y1234, x234, y234, x34, y34, x4, y4, tess_tol, level + 1);

	movss	DWORD PTR y1$[rsp], xmm6
	subss	xmm3, xmm7
	movss	DWORD PTR x1$[rsp], xmm7
	movaps	xmm2, xmm11
	movaps	xmm0, xmm12
	subss	xmm2, xmm8
	movaps	xmm4, xmm9
	subss	xmm4, xmm6
	movaps	xmm1, xmm13
	subss	xmm0, xmm9
	subss	xmm1, xmm8
	mulss	xmm2, xmm4
	mulss	xmm0, xmm3
	mulss	xmm1, xmm4
	subss	xmm2, xmm0
	mulss	xmm4, xmm4
	movaps	xmm0, xmm14
	subss	xmm0, xmm9
	andps	xmm2, xmm15
	mulss	xmm0, xmm3
	mulss	xmm3, xmm3
	subss	xmm1, xmm0
	addss	xmm4, xmm3
	movss	xmm3, DWORD PTR x1$[rsp]
	andps	xmm1, xmm15
	addss	xmm2, xmm1
	mulss	xmm4, DWORD PTR tess_tol$[rsp]
	mulss	xmm2, xmm2
	comiss	xmm4, xmm2
	movss	xmm2, DWORD PTR y1$[rsp]
	jbe	$LL15@PathBezier
$LN17@PathBezier:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	r8d, DWORD PTR [rbx]
	mov	ecx, DWORD PTR [rbx+4]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T1[rsp], xmm8
	movss	DWORD PTR $T1[rsp+4], xmm9

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	cmp	r8d, ecx
	jne	SHORT $LN9@PathBezier
	inc	r8d

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN13@PathBezier
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN14@PathBezier
$LN13@PathBezier:
	mov	eax, 8
$LN14@PathBezier:
	cmp	eax, r8d

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rcx, rbx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	r8d, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, r8d
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN9@PathBezier:
	movsxd	rdx, DWORD PTR [rbx]
	mov	rcx, QWORD PTR [rbx+8]
	mov	rax, QWORD PTR $T1[rsp]
	mov	QWORD PTR [rcx+rdx*8], rax
	inc	DWORD PTR [rbx]
$LN4@PathBezier:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1269 : }

	movaps	xmm15, XMMWORD PTR [rsp+112]
	lea	r11, QWORD PTR [rsp+272]
	mov	rbx, QWORD PTR [r11+16]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	movaps	xmm14, XMMWORD PTR [r11-144]
	mov	rsp, r11
	pop	rdi
	ret	0
?PathBezierCubicCurveToCasteljau@@YAXPEAU?$ImVector@UImVec2@@@@MMMMMMMMMH@Z ENDP ; PathBezierCubicCurveToCasteljau
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?FixRectCornerFlags@@YAHH@Z
_TEXT	SEGMENT
flags$ = 8
?FixRectCornerFlags@@YAHH@Z PROC			; FixRectCornerFlags, COMDAT

; 1323 : {

	mov	edx, ecx

; 1324 : #ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
; 1325 :     // Obsoleted in 1.82 (from February 2021)
; 1326 :     // Legacy Support for hard coded ~0 (used to be a suggested equivalent to ImDrawCornerFlags_All)
; 1327 :     //   ~0   --> ImDrawFlags_RoundCornersAll or 0
; 1328 :     if (flags == ~0)

	cmp	ecx, -1
	jne	SHORT $LN2@FixRectCor

; 1329 :         return ImDrawFlags_RoundCornersAll;

	mov	eax, 240				; 000000f0H

; 1354 : }

	ret	0
$LN2@FixRectCor:

; 1330 : 
; 1331 :     // Legacy Support for hard coded 0x01 to 0x0F (matching 15 out of 16 old flags combinations)
; 1332 :     //   0x01 --> ImDrawFlags_RoundCornersTopLeft (VALUE 0x01 OVERLAPS ImDrawFlags_Closed but ImDrawFlags_Closed is never valid in this path!)
; 1333 :     //   0x02 --> ImDrawFlags_RoundCornersTopRight
; 1334 :     //   0x03 --> ImDrawFlags_RoundCornersTopLeft | ImDrawFlags_RoundCornersTopRight
; 1335 :     //   0x04 --> ImDrawFlags_RoundCornersBotLeft
; 1336 :     //   0x05 --> ImDrawFlags_RoundCornersTopLeft | ImDrawFlags_RoundCornersBotLeft
; 1337 :     //   ...
; 1338 :     //   0x0F --> ImDrawFlags_RoundCornersAll or 0
; 1339 :     // (See all values in ImDrawCornerFlags_)
; 1340 :     if (flags >= 0x01 && flags <= 0x0F)

	lea	eax, DWORD PTR [rcx-1]
	cmp	eax, 14
	ja	SHORT $LN3@FixRectCor

; 1341 :         return (flags << 4);

	shl	edx, 4
	mov	eax, edx

; 1354 : }

	ret	0
$LN3@FixRectCor:

; 1342 : 
; 1343 :     // We cannot support hard coded 0x00 with 'float rounding > 0.0f' --> replace with ImDrawFlags_RoundCornersNone or use 'float rounding = 0.0f'
; 1344 : #endif
; 1345 : 
; 1346 :     // If this triggers, please update your code replacing hardcoded values with new ImDrawFlags_RoundCorners* values.
; 1347 :     // Note that ImDrawFlags_Closed (== 0x01) is an invalid flag for AddRect(), AddRectFilled(), PathRect() etc...
; 1348 :     IM_ASSERT((flags & 0x0F) == 0 && "Misuse of legacy hardcoded ImDrawCornerFlags values!");
; 1349 : 
; 1350 :     if ((flags & ImDrawFlags_RoundCornersMask_) == 0)
; 1351 :         flags |= ImDrawFlags_RoundCornersAll;
; 1352 : 
; 1353 :     return flags;

	mov	eax, edx
	or	eax, 240				; 000000f0H
	test	edx, 496				; 000001f0H
	cmovne	eax, edx

; 1354 : }

	ret	0
?FixRectCornerFlags@@YAHH@Z ENDP			; FixRectCornerFlags
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z
_TEXT	SEGMENT
this$ = 144
$T1 = 152
$T2 = 152
$T3 = 152
$T4 = 152
$T5 = 152
$T6 = 152
a$ = 152
b$ = 160
rounding$ = 168
flags$ = 176
?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z PROC	; ImDrawList::PathRect, COMDAT

; 1357 : {

$LN159:
	push	rbp
	push	r14
	push	r15
	sub	rsp, 112				; 00000070H
	mov	r9d, DWORD PTR flags$[rsp]
	mov	r14, r8

; 1328 :     if (flags == ~0)

	movss	xmm2, DWORD PTR __real@3f800000

; 1357 : {

	mov	r15, rdx
	movaps	XMMWORD PTR [rsp+96], xmm6
	movaps	xmm6, xmm3
	movaps	XMMWORD PTR [rsp+48], xmm9
	mov	rbp, rcx

; 1328 :     if (flags == ~0)

	movss	xmm9, DWORD PTR __real@3f000000

; 1357 : {

	mov	r10d, r9d

; 1328 :     if (flags == ~0)

	cmp	r9d, -1
	jne	SHORT $LN19@PathRect

; 1329 :         return ImDrawFlags_RoundCornersAll;

	mov	r9d, 240				; 000000f0H
$LN6@PathRect:

; 1359 :     rounding = ImMin(rounding, ImFabs(b.x - a.x) * ( ((flags & ImDrawFlags_RoundCornersTop)  == ImDrawFlags_RoundCornersTop)  || ((flags & ImDrawFlags_RoundCornersBottom) == ImDrawFlags_RoundCornersBottom) ? 0.5f : 1.0f ) - 1.0f);

	movaps	xmm1, xmm9
$LN7@PathRect:
	movss	xmm4, DWORD PTR [rdx]
	movss	xmm0, DWORD PTR [r8]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	movss	xmm3, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1359 :     rounding = ImMin(rounding, ImFabs(b.x - a.x) * ( ((flags & ImDrawFlags_RoundCornersTop)  == ImDrawFlags_RoundCornersTop)  || ((flags & ImDrawFlags_RoundCornersBottom) == ImDrawFlags_RoundCornersBottom) ? 0.5f : 1.0f ) - 1.0f);

	subss	xmm0, xmm4
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	andps	xmm0, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1359 :     rounding = ImMin(rounding, ImFabs(b.x - a.x) * ( ((flags & ImDrawFlags_RoundCornersTop)  == ImDrawFlags_RoundCornersTop)  || ((flags & ImDrawFlags_RoundCornersBottom) == ImDrawFlags_RoundCornersBottom) ? 0.5f : 1.0f ) - 1.0f);

	mulss	xmm0, xmm1
	subss	xmm0, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	comiss	xmm0, xmm6
	ja	SHORT $LN28@PathRect
	movaps	xmm6, xmm0
$LN28@PathRect:
	mov	eax, r9d
	and	eax, 160				; 000000a0H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1360 :     rounding = ImMin(rounding, ImFabs(b.y - a.y) * ( ((flags & ImDrawFlags_RoundCornersLeft) == ImDrawFlags_RoundCornersLeft) || ((flags & ImDrawFlags_RoundCornersRight)  == ImDrawFlags_RoundCornersRight)  ? 0.5f : 1.0f ) - 1.0f);

	cmp	al, 160					; 000000a0H
	mov	eax, r9d
	setne	cl
	and	eax, 80					; 00000050H
	cmp	al, 80					; 00000050H
	setne	al
	test	cl, al
	je	SHORT $LN8@PathRect
	movaps	xmm1, xmm2
	jmp	SHORT $LN9@PathRect
$LN19@PathRect:

; 1340 :     if (flags >= 0x01 && flags <= 0x0F)

	lea	eax, DWORD PTR [r9-1]
	cmp	eax, 14
	ja	SHORT $LN20@PathRect

; 1341 :         return (flags << 4);

	shl	r9d, 4
	jmp	SHORT $LN18@PathRect
$LN20@PathRect:

; 1342 : 
; 1343 :     // We cannot support hard coded 0x00 with 'float rounding > 0.0f' --> replace with ImDrawFlags_RoundCornersNone or use 'float rounding = 0.0f'
; 1344 : #endif
; 1345 : 
; 1346 :     // If this triggers, please update your code replacing hardcoded values with new ImDrawFlags_RoundCorners* values.
; 1347 :     // Note that ImDrawFlags_Closed (== 0x01) is an invalid flag for AddRect(), AddRectFilled(), PathRect() etc...
; 1348 :     IM_ASSERT((flags & 0x0F) == 0 && "Misuse of legacy hardcoded ImDrawCornerFlags values!");
; 1349 : 
; 1350 :     if ((flags & ImDrawFlags_RoundCornersMask_) == 0)
; 1351 :         flags |= ImDrawFlags_RoundCornersAll;
; 1352 : 
; 1353 :     return flags;

	mov	eax, r9d
	mov	ecx, r9d
	mov	r9d, 240				; 000000f0H
	or	r9d, eax
	test	eax, 496				; 000001f0H
	cmovne	r9d, r10d
$LN18@PathRect:
	mov	eax, r9d
	and	eax, 192				; 000000c0H

; 1359 :     rounding = ImMin(rounding, ImFabs(b.x - a.x) * ( ((flags & ImDrawFlags_RoundCornersTop)  == ImDrawFlags_RoundCornersTop)  || ((flags & ImDrawFlags_RoundCornersBottom) == ImDrawFlags_RoundCornersBottom) ? 0.5f : 1.0f ) - 1.0f);

	cmp	al, 192					; 000000c0H
	mov	eax, r9d
	setne	cl
	and	eax, 48					; 00000030H
	cmp	al, 48					; 00000030H
	setne	al
	test	cl, al
	je	$LN6@PathRect
	movaps	xmm1, xmm2
	jmp	$LN7@PathRect
$LN8@PathRect:

; 1360 :     rounding = ImMin(rounding, ImFabs(b.y - a.y) * ( ((flags & ImDrawFlags_RoundCornersLeft) == ImDrawFlags_RoundCornersLeft) || ((flags & ImDrawFlags_RoundCornersRight)  == ImDrawFlags_RoundCornersRight)  ? 0.5f : 1.0f ) - 1.0f);

	movaps	xmm1, xmm9
$LN9@PathRect:
	movss	xmm5, DWORD PTR [rdx+4]
	movss	xmm0, DWORD PTR [r8+4]
	subss	xmm0, xmm5
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	andps	xmm0, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1360 :     rounding = ImMin(rounding, ImFabs(b.y - a.y) * ( ((flags & ImDrawFlags_RoundCornersLeft) == ImDrawFlags_RoundCornersLeft) || ((flags & ImDrawFlags_RoundCornersRight)  == ImDrawFlags_RoundCornersRight)  ? 0.5f : 1.0f ) - 1.0f);

	mulss	xmm0, xmm1
	subss	xmm0, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	comiss	xmm0, xmm6
	ja	SHORT $LN34@PathRect
	movaps	xmm6, xmm0
$LN34@PathRect:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1362 :     if (rounding < 0.5f || (flags & ImDrawFlags_RoundCornersMask_) == ImDrawFlags_RoundCornersNone)

	comiss	xmm9, xmm6
	mov	QWORD PTR [rsp+144], rbx
	mov	QWORD PTR [rsp+168], rdi
	ja	$LN124@PathRect
	mov	eax, r9d
	and	eax, 496				; 000001f0H
	cmp	eax, 256				; 00000100H
	je	$LN124@PathRect
	mov	QWORD PTR [rsp+160], rsi
	movaps	XMMWORD PTR [rsp+80], xmm7
	movaps	XMMWORD PTR [rsp+64], xmm8

; 1363 :     {
; 1364 :         PathLineTo(a);
; 1365 :         PathLineTo(ImVec2(b.x, a.y));
; 1366 :         PathLineTo(b);
; 1367 :         PathLineTo(ImVec2(a.x, b.y));
; 1368 :     }
; 1369 :     else
; 1370 :     {
; 1371 :         const float rounding_tl = (flags & ImDrawFlags_RoundCornersTopLeft)     ? rounding : 0.0f;

	test	r9b, 16
	je	SHORT $LN10@PathRect
	movaps	xmm2, xmm6
	jmp	SHORT $LN11@PathRect
$LN10@PathRect:
	xorps	xmm2, xmm2
$LN11@PathRect:

; 1372 :         const float rounding_tr = (flags & ImDrawFlags_RoundCornersTopRight)    ? rounding : 0.0f;

	test	r9b, 32					; 00000020H
	je	SHORT $LN12@PathRect
	movaps	xmm7, xmm6
	jmp	SHORT $LN13@PathRect
$LN12@PathRect:
	xorps	xmm7, xmm7
$LN13@PathRect:

; 1373 :         const float rounding_br = (flags & ImDrawFlags_RoundCornersBottomRight) ? rounding : 0.0f;

	test	r9b, r9b
	jns	SHORT $LN14@PathRect
	movaps	xmm8, xmm6
	jmp	SHORT $LN15@PathRect
$LN14@PathRect:
	xorps	xmm8, xmm8
$LN15@PathRect:

; 1374 :         const float rounding_bl = (flags & ImDrawFlags_RoundCornersBottomLeft)  ? rounding : 0.0f;

	test	r9b, 64					; 00000040H
	jne	SHORT $LN17@PathRect
	xorps	xmm6, xmm6
$LN17@PathRect:

; 1168 :     if (radius < 0.5f)

	comiss	xmm9, xmm2
	mov	edi, 8

; 1375 :         PathArcToFast(ImVec2(a.x + rounding_tl, a.y + rounding_tl), rounding_tl, 6, 9);

	addss	xmm4, xmm2
	addss	xmm5, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T4[rsp], xmm4
	movss	DWORD PTR $T4[rsp+4], xmm5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1168 :     if (radius < 0.5f)

	jbe	SHORT $LN78@PathRect
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	eax, DWORD PTR [rbp+120]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1170 :         _Path.push_back(center);

	lea	rbx, QWORD PTR [rbp+120]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	ecx, DWORD PTR [rbx+4]
	cmp	eax, ecx
	jne	SHORT $LN81@PathRect
	lea	r8d, DWORD PTR [rax+1]

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN85@PathRect
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN86@PathRect
$LN85@PathRect:
	mov	eax, edi
$LN86@PathRect:
	cmp	eax, r8d

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rcx, rbx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	r8d, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, r8d
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN81@PathRect:
	movsxd	rdx, DWORD PTR [rbx]
	mov	rcx, QWORD PTR [rbx+8]
	mov	rax, QWORD PTR $T4[rsp]
	mov	QWORD PTR [rcx+rdx*8], rax
	inc	DWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1171 :         return;

	jmp	SHORT $LN77@PathRect
$LN78@PathRect:

; 1172 :     }
; 1173 :     _PathArcToFastEx(center, radius, a_min_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, a_max_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, 0);

	mov	r9d, 24
	mov	DWORD PTR [rsp+32], 36			; 00000024H
	lea	rdx, QWORD PTR $T4[rsp]
	mov	rcx, rbp
	call	?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z ; ImDrawList::_PathArcToFastEx
	lea	rbx, QWORD PTR [rbp+120]
$LN77@PathRect:

; 1168 :     if (radius < 0.5f)

	comiss	xmm9, xmm7

; 1376 :         PathArcToFast(ImVec2(b.x - rounding_tr, a.y + rounding_tr), rounding_tr, 9, 12);

	movss	xmm0, DWORD PTR [r14]
	movaps	xmm1, xmm7
	addss	xmm1, DWORD PTR [r15+4]
	subss	xmm0, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T3[rsp+4], xmm1
	movss	DWORD PTR $T3[rsp], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1168 :     if (radius < 0.5f)

	jbe	SHORT $LN90@PathRect
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	r8d, DWORD PTR [rbx]
	mov	ecx, DWORD PTR [rbx+4]
	cmp	r8d, ecx
	jne	SHORT $LN93@PathRect
	inc	r8d

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN97@PathRect
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN98@PathRect
$LN97@PathRect:
	mov	eax, edi
$LN98@PathRect:
	cmp	eax, r8d

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rcx, rbx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	r8d, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, r8d
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN93@PathRect:
	movsxd	rdx, DWORD PTR [rbx]
	mov	rcx, QWORD PTR [rbx+8]
	mov	rax, QWORD PTR $T3[rsp]
	mov	QWORD PTR [rcx+rdx*8], rax
	inc	DWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1171 :         return;

	jmp	SHORT $LN89@PathRect
$LN90@PathRect:

; 1172 :     }
; 1173 :     _PathArcToFastEx(center, radius, a_min_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, a_max_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, 0);

	mov	r9d, 36					; 00000024H
	mov	DWORD PTR [rsp+32], 48			; 00000030H
	movaps	xmm2, xmm7
	lea	rdx, QWORD PTR $T3[rsp]
	mov	rcx, rbp
	call	?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z ; ImDrawList::_PathArcToFastEx
$LN89@PathRect:

; 1168 :     if (radius < 0.5f)

	comiss	xmm9, xmm8

; 1377 :         PathArcToFast(ImVec2(b.x - rounding_br, b.y - rounding_br), rounding_br, 0, 3);

	movss	xmm0, DWORD PTR [r14]
	movss	xmm1, DWORD PTR [r14+4]
	subss	xmm0, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm7, XMMWORD PTR [rsp+80]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1377 :         PathArcToFast(ImVec2(b.x - rounding_br, b.y - rounding_br), rounding_br, 0, 3);

	subss	xmm1, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T2[rsp], xmm0
	movss	DWORD PTR $T2[rsp+4], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1168 :     if (radius < 0.5f)

	jbe	SHORT $LN102@PathRect
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	r8d, DWORD PTR [rbx]
	mov	ecx, DWORD PTR [rbx+4]
	cmp	r8d, ecx
	jne	SHORT $LN105@PathRect
	inc	r8d

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN109@PathRect
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN110@PathRect
$LN109@PathRect:
	mov	eax, edi
$LN110@PathRect:
	cmp	eax, r8d

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rcx, rbx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	r8d, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, r8d
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN105@PathRect:
	movsxd	rdx, DWORD PTR [rbx]
	mov	rcx, QWORD PTR [rbx+8]
	mov	rax, QWORD PTR $T2[rsp]
	mov	QWORD PTR [rcx+rdx*8], rax
	inc	DWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1171 :         return;

	jmp	SHORT $LN101@PathRect
$LN102@PathRect:

; 1172 :     }
; 1173 :     _PathArcToFastEx(center, radius, a_min_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, a_max_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, 0);

	xor	r9d, r9d
	mov	DWORD PTR [rsp+32], 12
	movaps	xmm2, xmm8
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, rbp
	call	?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z ; ImDrawList::_PathArcToFastEx
$LN101@PathRect:

; 1168 :     if (radius < 0.5f)

	comiss	xmm9, xmm6

; 1378 :         PathArcToFast(ImVec2(a.x + rounding_bl, b.y - rounding_bl), rounding_bl, 3, 6);

	movss	xmm1, DWORD PTR [r14+4]
	movaps	xmm0, xmm6
	addss	xmm0, DWORD PTR [r15]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm8, XMMWORD PTR [rsp+64]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1378 :         PathArcToFast(ImVec2(a.x + rounding_bl, b.y - rounding_bl), rounding_bl, 3, 6);

	subss	xmm1, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T1[rsp], xmm0
	movss	DWORD PTR $T1[rsp+4], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1168 :     if (radius < 0.5f)

	jbe	SHORT $LN114@PathRect
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	r8d, DWORD PTR [rbx]
	mov	ecx, DWORD PTR [rbx+4]
	cmp	r8d, ecx
	jne	SHORT $LN117@PathRect
	inc	r8d

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN121@PathRect
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	lea	edi, DWORD PTR [rcx+rax]
$LN121@PathRect:
	cmp	edi, r8d

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rcx, rbx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	r8d, edi

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, r8d
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN117@PathRect:
	movsxd	rdx, DWORD PTR [rbx]
	mov	rcx, QWORD PTR [rbx+8]
	mov	rax, QWORD PTR $T1[rsp]
	mov	QWORD PTR [rcx+rdx*8], rax
	inc	DWORD PTR [rbx]
$LN157@PathRect:
	mov	rsi, QWORD PTR [rsp+160]
$LN113@PathRect:
	mov	rdi, QWORD PTR [rsp+168]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1380 : }

	mov	rbx, QWORD PTR [rsp+144]
	movaps	xmm6, XMMWORD PTR [rsp+96]
	movaps	xmm9, XMMWORD PTR [rsp+48]
	add	rsp, 112				; 00000070H
	pop	r15
	pop	r14
	pop	rbp
	ret	0
$LN114@PathRect:

; 1173 :     _PathArcToFastEx(center, radius, a_min_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, a_max_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, 0);

	mov	r9d, 12
	mov	DWORD PTR [rsp+32], 24
	movaps	xmm2, xmm6
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rbp
	call	?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z ; ImDrawList::_PathArcToFastEx
	jmp	SHORT $LN157@PathRect
$LN124@PathRect:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	r8d, DWORD PTR [rbp+120]
	mov	edi, 8
	mov	ecx, DWORD PTR [rbp+124]
	cmp	r8d, ecx
	jne	SHORT $LN38@PathRect
	inc	r8d

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN42@PathRect
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN43@PathRect
$LN42@PathRect:
	mov	eax, edi
$LN43@PathRect:
	cmp	eax, r8d

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	lea	rcx, QWORD PTR [rbp+120]

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	r8d, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, r8d
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN38@PathRect:
	movsxd	rdx, DWORD PTR [rbp+120]
	mov	rcx, QWORD PTR [rbp+128]
	mov	rax, QWORD PTR [r15]
	mov	QWORD PTR [rcx+rdx*8], rax
	mov	ecx, DWORD PTR [rbp+120]
	inc	ecx
	mov	DWORD PTR [rbp+120], ecx

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm0, DWORD PTR [r14]
	movss	xmm1, DWORD PTR [r15+4]

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	r8d, DWORD PTR [rbp+124]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T6[rsp], xmm0
	movss	DWORD PTR $T6[rsp+4], xmm1

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	cmp	ecx, r8d
	jne	SHORT $LN49@PathRect
	inc	ecx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	r8d, r8d
	je	SHORT $LN53@PathRect
	mov	eax, r8d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r8d
	jmp	SHORT $LN54@PathRect
$LN53@PathRect:
	mov	eax, edi
$LN54@PathRect:
	cmp	eax, ecx
	cmovg	ecx, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, ecx
	lea	rcx, QWORD PTR [rbp+120]
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN49@PathRect:
	movsxd	rdx, DWORD PTR [rbp+120]
	mov	rcx, QWORD PTR [rbp+128]
	mov	rax, QWORD PTR $T6[rsp]
	mov	QWORD PTR [rcx+rdx*8], rax
	mov	ecx, DWORD PTR [rbp+120]
	inc	ecx
	mov	DWORD PTR [rbp+120], ecx
	mov	r8d, DWORD PTR [rbp+124]
	cmp	ecx, r8d
	jne	SHORT $LN58@PathRect
	inc	ecx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	r8d, r8d
	je	SHORT $LN62@PathRect
	mov	eax, r8d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r8d
	jmp	SHORT $LN63@PathRect
$LN62@PathRect:
	mov	eax, edi
$LN63@PathRect:
	cmp	eax, ecx
	cmovg	ecx, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, ecx
	lea	rcx, QWORD PTR [rbp+120]
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN58@PathRect:
	movsxd	rdx, DWORD PTR [rbp+120]
	mov	rcx, QWORD PTR [rbp+128]
	mov	rax, QWORD PTR [r14]
	mov	QWORD PTR [rcx+rdx*8], rax
	mov	ecx, DWORD PTR [rbp+120]
	inc	ecx
	mov	DWORD PTR [rbp+120], ecx

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm0, DWORD PTR [r15]
	movss	xmm1, DWORD PTR [r14+4]

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	r8d, DWORD PTR [rbp+124]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T5[rsp], xmm0
	movss	DWORD PTR $T5[rsp+4], xmm1

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	cmp	ecx, r8d
	jne	SHORT $LN69@PathRect
	inc	ecx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	r8d, r8d
	je	SHORT $LN73@PathRect
	mov	eax, r8d
	cdq
	sub	eax, edx
	sar	eax, 1
	lea	edi, DWORD PTR [r8+rax]
$LN73@PathRect:
	cmp	edi, ecx
	cmovg	ecx, edi

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, ecx
	lea	rcx, QWORD PTR [rbp+120]
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN69@PathRect:
	movsxd	rdx, DWORD PTR [rbp+120]
	mov	rcx, QWORD PTR [rbp+128]
	mov	rax, QWORD PTR $T5[rsp]
	mov	QWORD PTR [rcx+rdx*8], rax
	inc	DWORD PTR [rbp+120]
	jmp	$LN113@PathRect
?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z ENDP	; ImDrawList::PathRect
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?AddImageRounded@ImDrawList@@QEAAXPEAXAEBUImVec2@@111IMH@Z
_TEXT	SEGMENT
this$ = 96
user_texture_id$ = 104
p_min$ = 112
p_max$ = 120
uv_min$ = 128
uv_max$ = 136
col$ = 144
rounding$ = 152
flags$dead$ = 160
?AddImageRounded@ImDrawList@@QEAAXPEAXAEBUImVec2@@111IMH@Z PROC ; ImDrawList::AddImageRounded, COMDAT

; 1643 : {

$LN20:
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r12
	push	r15
	sub	rsp, 64					; 00000040H

; 1644 :     if ((col & IM_COL32_A_MASK) == 0)

	mov	ebp, DWORD PTR col$[rsp]
	mov	r15, r9
	mov	r12, r8
	mov	rsi, rdx
	mov	rdi, rcx
	test	ebp, -16777216				; ff000000H
	je	$LN6@AddImageRo

; 1645 :         return;
; 1646 : 
; 1647 :     flags = FixRectCornerFlags(flags);
; 1648 :     if (rounding < 0.5f || (flags & ImDrawFlags_RoundCornersMask_) == ImDrawFlags_RoundCornersNone)

	movss	xmm0, DWORD PTR __real@3f000000
	comiss	xmm0, DWORD PTR rounding$[rsp]
	ja	$LN4@AddImageRo
	mov	QWORD PTR [rsp+96], rbx
	mov	QWORD PTR [rsp+104], r14

; 1651 :         return;
; 1652 :     }
; 1653 : 
; 1654 :     const bool push_texture_id = user_texture_id != _CmdHeader.TextureId;

	mov	r14, QWORD PTR [rcx+152]

; 1655 :     if (push_texture_id)

	cmp	rdx, r14
	je	SHORT $LN5@AddImageRo

; 1656 :         PushTextureID(user_texture_id);

	call	?PushTextureID@ImDrawList@@QEAAXPEAX@Z	; ImDrawList::PushTextureID
$LN5@AddImageRo:

; 1657 : 
; 1658 :     int vert_start_idx = VtxBuffer.Size;
; 1659 :     PathRect(p_min, p_max, rounding, flags);

	movss	xmm3, DWORD PTR rounding$[rsp]
	mov	r8, r15
	mov	ebx, DWORD PTR [rdi+32]
	mov	rdx, r12
	mov	rcx, rdi
	mov	DWORD PTR [rsp+32], 48			; 00000030H
	call	?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z ; ImDrawList::PathRect
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	r8d, DWORD PTR [rdi+120]
	mov	r9d, ebp
	mov	rdx, QWORD PTR [rdi+128]
	mov	rcx, rdi
	call	?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z ; ImDrawList::AddConvexPolyFilled
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1662 :     ImGui::ShadeVertsLinearUV(this, vert_start_idx, vert_end_idx, p_min, p_max, uv_min, uv_max, true);

	mov	rax, QWORD PTR uv_max$[rsp]
	mov	r9, r12
	mov	r8d, DWORD PTR [rdi+32]
	mov	edx, ebx
	mov	QWORD PTR [rsp+48], rax
	mov	rcx, rdi
	mov	rax, QWORD PTR uv_min$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], r15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	DWORD PTR [rdi+120], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1662 :     ImGui::ShadeVertsLinearUV(this, vert_start_idx, vert_end_idx, p_min, p_max, uv_min, uv_max, true);

	call	?ShadeVertsLinearUV@ImGui@@YAXPEAUImDrawList@@HHAEBUImVec2@@111_N@Z ; ImGui::ShadeVertsLinearUV
	mov	rbx, QWORD PTR [rsp+96]

; 1663 : 
; 1664 :     if (push_texture_id)

	cmp	rsi, r14
	mov	r14, QWORD PTR [rsp+104]
	je	SHORT $LN6@AddImageRo

; 1665 :         PopTextureID();

	mov	rcx, rdi
	call	?PopTextureID@ImDrawList@@QEAAXXZ	; ImDrawList::PopTextureID
	jmp	SHORT $LN6@AddImageRo
$LN4@AddImageRo:

; 1649 :     {
; 1650 :         AddImage(user_texture_id, p_min, p_max, uv_min, uv_max, col);

	mov	rax, QWORD PTR uv_max$[rsp]
	mov	DWORD PTR [rsp+48], ebp
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR uv_min$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z ; ImDrawList::AddImage
$LN6@AddImageRo:

; 1666 : }

	mov	rbp, QWORD PTR [rsp+112]
	mov	rsi, QWORD PTR [rsp+120]
	add	rsp, 64					; 00000040H
	pop	r15
	pop	r12
	pop	rdi
	ret	0
?AddImageRounded@ImDrawList@@QEAAXPEAXAEBUImVec2@@111IMH@Z ENDP ; ImDrawList::AddImageRounded
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??0ImDrawChannel@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0ImDrawChannel@@QEAA@XZ PROC				; ImDrawChannel::ImDrawChannel, COMDAT

; 1903 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax
	mov	rax, rcx
	ret	0
??0ImDrawChannel@@QEAA@XZ ENDP				; ImDrawChannel::ImDrawChannel
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?ShadeVertsLinearColorGradientKeepAlpha@ImGui@@YAXPEAUImDrawList@@HHUImVec2@@1II@Z
_TEXT	SEGMENT
gradient_p0$ = 0
draw_list$ = 224
vert_start_idx$ = 232
vert_end_idx$ = 240
gradient_p1$ = 256
col0$ = 264
col1$ = 272
?ShadeVertsLinearColorGradientKeepAlpha@ImGui@@YAXPEAUImDrawList@@HHUImVec2@@1II@Z PROC ; ImGui::ShadeVertsLinearColorGradientKeepAlpha, COMDAT

; 1916 : {

$LN56:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 176				; 000000b0H

; 1918 :     float gradient_inv_length2 = 1.0f / ImLengthSqr(gradient_extent);

	movss	xmm4, DWORD PTR __real@3f800000
	movaps	XMMWORD PTR [rsp+80], xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm11, DWORD PTR gradient_p1$[rsp]
	movaps	XMMWORD PTR [rsp+64], xmm12
	movss	xmm12, DWORD PTR gradient_p1$[rsp+4]
	movaps	XMMWORD PTR [rsp+48], xmm13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1918 :     float gradient_inv_length2 = 1.0f / ImLengthSqr(gradient_extent);

	movaps	xmm13, xmm4
	mov	QWORD PTR gradient_p0$[rsp], r9

; 1920 :     ImDrawVert* vert_end = draw_list->VtxBuffer.Data + vert_end_idx;

	movsxd	rax, r8d
	movaps	XMMWORD PTR [rsp+32], xmm14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm14, DWORD PTR gradient_p0$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1916 : {

	movsxd	r10, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	subss	xmm11, xmm14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1920 :     ImDrawVert* vert_end = draw_list->VtxBuffer.Data + vert_end_idx;

	mov	rdx, QWORD PTR [rcx+40]
	lea	rcx, QWORD PTR [rax+rax*4]
	movaps	XMMWORD PTR [rsp+16], xmm15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm15, DWORD PTR gradient_p0$[rsp+4]
	subss	xmm12, xmm15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1920 :     ImDrawVert* vert_end = draw_list->VtxBuffer.Data + vert_end_idx;

	lea	r14, QWORD PTR [rdx+rcx*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 469  : static inline float  ImLengthSqr(const ImVec2& lhs)                             { return (lhs.x * lhs.x) + (lhs.y * lhs.y); }

	movaps	xmm0, xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1921 :     const int col0_r = (int)(col0 >> IM_COL32_R_SHIFT) & 0xFF;

	mov	ecx, DWORD PTR col0$[rsp]

; 1922 :     const int col0_g = (int)(col0 >> IM_COL32_G_SHIFT) & 0xFF;

	mov	eax, ecx
	movzx	edi, cl

; 1923 :     const int col0_b = (int)(col0 >> IM_COL32_B_SHIFT) & 0xFF;

	shr	ecx, 16
	shr	eax, 8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm1, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1923 :     const int col0_b = (int)(col0 >> IM_COL32_B_SHIFT) & 0xFF;

	movzx	ebp, cl

; 1924 :     const int col_delta_r = ((int)(col1 >> IM_COL32_R_SHIFT) & 0xFF) - col0_r;

	mov	ecx, DWORD PTR col1$[rsp]
	movzx	esi, al

; 1925 :     const int col_delta_g = ((int)(col1 >> IM_COL32_G_SHIFT) & 0xFF) - col0_g;

	mov	eax, ecx
	movzx	r9d, cl

; 1926 :     const int col_delta_b = ((int)(col1 >> IM_COL32_B_SHIFT) & 0xFF) - col0_b;

	shr	ecx, 16
	sub	r9d, edi
	shr	eax, 8
	movzx	ebx, cl
	lea	rcx, QWORD PTR [r10+r10*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mulss	xmm1, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1919 :     ImDrawVert* vert_start = draw_list->VtxBuffer.Data + vert_start_idx;

	lea	r8, QWORD PTR [rdx+rcx*4]

; 1926 :     const int col_delta_b = ((int)(col1 >> IM_COL32_B_SHIFT) & 0xFF) - col0_b;

	sub	ebx, ebp
	movzx	r11d, al
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 469  : static inline float  ImLengthSqr(const ImVec2& lhs)                             { return (lhs.x * lhs.x) + (lhs.y * lhs.y); }

	mulss	xmm0, xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1925 :     const int col_delta_g = ((int)(col1 >> IM_COL32_G_SHIFT) & 0xFF) - col0_g;

	sub	r11d, esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 469  : static inline float  ImLengthSqr(const ImVec2& lhs)                             { return (lhs.x * lhs.x) + (lhs.y * lhs.y); }

	addss	xmm1, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1918 :     float gradient_inv_length2 = 1.0f / ImLengthSqr(gradient_extent);

	divss	xmm13, xmm1

; 1927 :     for (ImDrawVert* vert = vert_start; vert < vert_end; vert++)

	cmp	r8, r14
	jae	$LN27@ShadeVerts
	movaps	XMMWORD PTR [rsp+160], xmm6
	mov	rax, r14
	movaps	XMMWORD PTR [rsp+144], xmm7
	sub	rax, r8
	movaps	XMMWORD PTR [rsp+128], xmm8
	add	rax, 19
	movaps	XMMWORD PTR [rsp+112], xmm9
	xorps	xmm5, xmm5
	movaps	XMMWORD PTR [rsp+96], xmm10
	xorps	xmm10, xmm10
	xorps	xmm6, xmm6
	xorps	xmm7, xmm7
	xorps	xmm8, xmm8
	xorps	xmm9, xmm9
	xorps	xmm3, xmm3
	cvtsi2ss xmm10, edi
	cvtsi2ss xmm5, ebx
	cvtsi2ss xmm6, ebp
	cvtsi2ss xmm7, r11d
	cvtsi2ss xmm8, esi
	cvtsi2ss xmm9, r9d
	cmp	rax, 80					; 00000050H
	jb	$LN38@ShadeVerts
	lea	r9, QWORD PTR [r14-60]
	lea	rdx, QWORD PTR [r8+44]
	npad	12
$LL37@ShadeVerts:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm1, DWORD PTR [rdx-40]
	movss	xmm0, DWORD PTR [r8]
	subss	xmm1, xmm15
	subss	xmm0, xmm14

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mulss	xmm1, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 477  : static inline float  ImDot(const ImVec2& a, const ImVec2& b)                    { return a.x * b.x + a.y * b.y; }

	mulss	xmm0, xmm11
	addss	xmm1, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1930 :         float t = ImClamp(d * gradient_inv_length2, 0.0f, 1.0f);

	mulss	xmm1, xmm13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm3, xmm1
	jbe	SHORT $LN29@ShadeVerts
	movaps	xmm2, xmm3
	jmp	SHORT $LN30@ShadeVerts
$LN29@ShadeVerts:
	movaps	xmm2, xmm4
	minss	xmm2, xmm1
$LN30@ShadeVerts:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1933 :         int b = (int)(col0_b + col_delta_b * t);

	movaps	xmm0, xmm5
	movaps	xmm1, xmm7
	mulss	xmm0, xmm2
	mulss	xmm1, xmm2
	addss	xmm0, xmm6
	addss	xmm1, xmm8
	cvttss2si ecx, xmm0
	cvttss2si eax, xmm1

; 1934 :         vert->col = (r << IM_COL32_R_SHIFT) | (g << IM_COL32_G_SHIFT) | (b << IM_COL32_B_SHIFT) | (vert->col & IM_COL32_A_MASK);

	shl	ecx, 8
	movaps	xmm0, xmm9
	or	ecx, eax
	mulss	xmm0, xmm2
	shl	ecx, 8
	addss	xmm0, xmm10
	cvttss2si eax, xmm0
	or	ecx, eax
	mov	eax, DWORD PTR [rdx-28]
	and	eax, -16777216				; ff000000H
	or	ecx, eax
	mov	DWORD PTR [rdx-28], ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm1, DWORD PTR [rdx-20]
	movss	xmm0, DWORD PTR [rdx-24]
	subss	xmm1, xmm15
	subss	xmm0, xmm14

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mulss	xmm1, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 477  : static inline float  ImDot(const ImVec2& a, const ImVec2& b)                    { return a.x * b.x + a.y * b.y; }

	mulss	xmm0, xmm11
	addss	xmm1, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1930 :         float t = ImClamp(d * gradient_inv_length2, 0.0f, 1.0f);

	mulss	xmm1, xmm13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm3, xmm1
	jbe	SHORT $LN31@ShadeVerts
	movaps	xmm2, xmm3
	jmp	SHORT $LN32@ShadeVerts
$LN31@ShadeVerts:
	movaps	xmm2, xmm4
	minss	xmm2, xmm1
$LN32@ShadeVerts:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1933 :         int b = (int)(col0_b + col_delta_b * t);

	movaps	xmm0, xmm5
	movaps	xmm1, xmm7
	mulss	xmm0, xmm2
	mulss	xmm1, xmm2
	addss	xmm0, xmm6
	addss	xmm1, xmm8
	cvttss2si ecx, xmm0
	cvttss2si eax, xmm1

; 1934 :         vert->col = (r << IM_COL32_R_SHIFT) | (g << IM_COL32_G_SHIFT) | (b << IM_COL32_B_SHIFT) | (vert->col & IM_COL32_A_MASK);

	shl	ecx, 8
	movaps	xmm0, xmm9
	or	ecx, eax
	mulss	xmm0, xmm2
	shl	ecx, 8
	addss	xmm0, xmm10
	cvttss2si eax, xmm0
	or	ecx, eax
	mov	eax, DWORD PTR [rdx-8]
	and	eax, -16777216				; ff000000H
	or	ecx, eax
	mov	DWORD PTR [rdx-8], ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm1, DWORD PTR [rdx-4]
	movss	xmm0, DWORD PTR [rdx]
	subss	xmm1, xmm14
	subss	xmm0, xmm15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 477  : static inline float  ImDot(const ImVec2& a, const ImVec2& b)                    { return a.x * b.x + a.y * b.y; }

	mulss	xmm1, xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mulss	xmm0, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 477  : static inline float  ImDot(const ImVec2& a, const ImVec2& b)                    { return a.x * b.x + a.y * b.y; }

	addss	xmm1, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1930 :         float t = ImClamp(d * gradient_inv_length2, 0.0f, 1.0f);

	mulss	xmm1, xmm13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm3, xmm1
	jbe	SHORT $LN33@ShadeVerts
	movaps	xmm2, xmm3
	jmp	SHORT $LN34@ShadeVerts
$LN33@ShadeVerts:
	movaps	xmm2, xmm4
	minss	xmm2, xmm1
$LN34@ShadeVerts:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1933 :         int b = (int)(col0_b + col_delta_b * t);

	movaps	xmm0, xmm5
	movaps	xmm1, xmm7
	mulss	xmm0, xmm2
	mulss	xmm1, xmm2
	addss	xmm0, xmm6
	addss	xmm1, xmm8
	cvttss2si ecx, xmm0
	cvttss2si eax, xmm1

; 1934 :         vert->col = (r << IM_COL32_R_SHIFT) | (g << IM_COL32_G_SHIFT) | (b << IM_COL32_B_SHIFT) | (vert->col & IM_COL32_A_MASK);

	shl	ecx, 8
	movaps	xmm0, xmm9
	or	ecx, eax
	mulss	xmm0, xmm2
	shl	ecx, 8
	addss	xmm0, xmm10
	cvttss2si eax, xmm0
	or	ecx, eax
	mov	eax, DWORD PTR [rdx+12]
	and	eax, -16777216				; ff000000H
	or	ecx, eax
	mov	DWORD PTR [rdx+12], ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm1, DWORD PTR [rdx+20]
	movss	xmm0, DWORD PTR [rdx+16]
	subss	xmm1, xmm15
	subss	xmm0, xmm14

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mulss	xmm1, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 477  : static inline float  ImDot(const ImVec2& a, const ImVec2& b)                    { return a.x * b.x + a.y * b.y; }

	mulss	xmm0, xmm11
	addss	xmm1, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1930 :         float t = ImClamp(d * gradient_inv_length2, 0.0f, 1.0f);

	mulss	xmm1, xmm13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm3, xmm1
	jbe	SHORT $LN35@ShadeVerts
	movaps	xmm2, xmm3
	jmp	SHORT $LN36@ShadeVerts
$LN35@ShadeVerts:
	movaps	xmm2, xmm4
	minss	xmm2, xmm1
$LN36@ShadeVerts:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1933 :         int b = (int)(col0_b + col_delta_b * t);

	movaps	xmm0, xmm5
	movaps	xmm1, xmm7
	mulss	xmm0, xmm2

; 1934 :         vert->col = (r << IM_COL32_R_SHIFT) | (g << IM_COL32_G_SHIFT) | (b << IM_COL32_B_SHIFT) | (vert->col & IM_COL32_A_MASK);

	add	r8, 80					; 00000050H
	mulss	xmm1, xmm2
	addss	xmm0, xmm6
	addss	xmm1, xmm8
	cvttss2si ecx, xmm0
	cvttss2si eax, xmm1
	shl	ecx, 8
	movaps	xmm0, xmm9
	or	ecx, eax
	mulss	xmm0, xmm2
	shl	ecx, 8
	addss	xmm0, xmm10
	cvttss2si eax, xmm0
	or	ecx, eax
	mov	eax, DWORD PTR [rdx+32]
	and	eax, -16777216				; ff000000H
	or	ecx, eax
	mov	DWORD PTR [rdx+32], ecx
	add	rdx, 80					; 00000050H
	cmp	r8, r9
	jb	$LL37@ShadeVerts

; 1927 :     for (ImDrawVert* vert = vert_start; vert < vert_end; vert++)

	cmp	r8, r14
	jae	$LN54@ShadeVerts
$LN38@ShadeVerts:
	lea	rdx, QWORD PTR [r8+16]
$LC4@ShadeVerts:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm1, DWORD PTR [rdx-12]
	movss	xmm0, DWORD PTR [rdx-16]
	subss	xmm1, xmm15
	subss	xmm0, xmm14

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mulss	xmm1, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 477  : static inline float  ImDot(const ImVec2& a, const ImVec2& b)                    { return a.x * b.x + a.y * b.y; }

	mulss	xmm0, xmm11
	addss	xmm1, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1930 :         float t = ImClamp(d * gradient_inv_length2, 0.0f, 1.0f);

	mulss	xmm1, xmm13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm3, xmm1
	jbe	SHORT $LN22@ShadeVerts
	movaps	xmm2, xmm3
	jmp	SHORT $LN23@ShadeVerts
$LN22@ShadeVerts:
	movaps	xmm2, xmm4
	minss	xmm2, xmm1
$LN23@ShadeVerts:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1934 :         vert->col = (r << IM_COL32_R_SHIFT) | (g << IM_COL32_G_SHIFT) | (b << IM_COL32_B_SHIFT) | (vert->col & IM_COL32_A_MASK);

	and	DWORD PTR [rdx], -16777216		; ff000000H
	movaps	xmm0, xmm5
	mulss	xmm0, xmm2
	movaps	xmm1, xmm7
	mulss	xmm1, xmm2
	addss	xmm0, xmm6
	addss	xmm1, xmm8
	cvttss2si ecx, xmm0
	cvttss2si eax, xmm1
	shl	ecx, 8
	movaps	xmm0, xmm9
	or	ecx, eax
	mulss	xmm0, xmm2
	shl	ecx, 8
	addss	xmm0, xmm10
	cvttss2si eax, xmm0
	or	ecx, eax
	or	DWORD PTR [rdx], ecx
	add	rdx, 20
	lea	rax, QWORD PTR [rdx-16]
	cmp	rax, r14
	jb	$LC4@ShadeVerts
$LN54@ShadeVerts:
	movaps	xmm9, XMMWORD PTR [rsp+112]
	movaps	xmm8, XMMWORD PTR [rsp+128]
	movaps	xmm7, XMMWORD PTR [rsp+144]
	movaps	xmm6, XMMWORD PTR [rsp+160]
	movaps	xmm10, XMMWORD PTR [rsp+96]
$LN27@ShadeVerts:

; 1935 :     }
; 1936 : }

	movaps	xmm11, XMMWORD PTR [rsp+80]
	movaps	xmm12, XMMWORD PTR [rsp+64]
	movaps	xmm13, XMMWORD PTR [rsp+48]
	movaps	xmm14, XMMWORD PTR [rsp+32]
	movaps	xmm15, XMMWORD PTR [rsp+16]
	add	rsp, 176				; 000000b0H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
?ShadeVertsLinearColorGradientKeepAlpha@ImGui@@YAXPEAUImDrawList@@HHUImVec2@@1II@Z ENDP ; ImGui::ShadeVertsLinearColorGradientKeepAlpha
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?ShadeVertsLinearUV@ImGui@@YAXPEAUImDrawList@@HHAEBUImVec2@@111_N@Z
_TEXT	SEGMENT
draw_list$ = 80
vert_start_idx$ = 88
vert_end_idx$ = 96
a$ = 104
b$ = 112
uv_a$ = 120
uv_b$ = 128
clamp$dead$ = 136
?ShadeVertsLinearUV@ImGui@@YAXPEAUImDrawList@@HHAEBUImVec2@@111_N@Z PROC ; ImGui::ShadeVertsLinearUV, COMDAT

; 1940 : {

$LN133:
	sub	rsp, 72					; 00000048H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	mov	rax, QWORD PTR b$[rsp]
	mov	r10, QWORD PTR uv_a$[rsp]
	movaps	XMMWORD PTR [rsp+48], xmm6
	movaps	XMMWORD PTR [rsp+32], xmm7
	xorps	xmm7, xmm7
	movss	xmm0, DWORD PTR [rax]
	movss	xmm1, DWORD PTR [rax+4]
	mov	rax, QWORD PTR uv_b$[rsp]
	subss	xmm1, DWORD PTR [r9+4]
	movss	xmm5, DWORD PTR [r10]
	movss	xmm6, DWORD PTR [r10+4]
	movss	xmm4, DWORD PTR [rax]
	subss	xmm0, DWORD PTR [r9]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	ucomiss	xmm1, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1940 : {

	movsxd	r11, r8d
	movsxd	r8, edx
	movaps	XMMWORD PTR [rsp+16], xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movaps	xmm2, xmm4
	movaps	XMMWORD PTR [rsp], xmm9
	subss	xmm2, xmm5
	movss	xmm9, DWORD PTR [rax+4]
	movaps	xmm8, xmm9
	subss	xmm8, xmm6

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	jp	SHORT $LN115@ShadeVerts
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1943 :     const ImVec2 scale = ImVec2(

	jne	SHORT $LN115@ShadeVerts
	xorps	xmm8, xmm8
	jmp	SHORT $LN12@ShadeVerts
$LN115@ShadeVerts:
	divss	xmm8, xmm1
$LN12@ShadeVerts:
	ucomiss	xmm0, xmm7
	jp	SHORT $LN114@ShadeVerts
	je	SHORT $LN14@ShadeVerts
$LN114@ShadeVerts:
	movaps	xmm7, xmm2
	divss	xmm7, xmm0
$LN14@ShadeVerts:

; 1947 :     ImDrawVert* vert_start = draw_list->VtxBuffer.Data + vert_start_idx;

	mov	rdx, QWORD PTR [rcx+40]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 462  : static inline ImVec2 ImMin(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x < rhs.x ? lhs.x : rhs.x, lhs.y < rhs.y ? lhs.y : rhs.y); }

	movaps	xmm0, xmm5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1947 :     ImDrawVert* vert_start = draw_list->VtxBuffer.Data + vert_start_idx;

	lea	rcx, QWORD PTR [r8+r8*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 462  : static inline ImVec2 ImMin(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x < rhs.x ? lhs.x : rhs.x, lhs.y < rhs.y ? lhs.y : rhs.y); }

	movaps	xmm3, xmm6
	minss	xmm0, xmm4
	minss	xmm3, xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1947 :     ImDrawVert* vert_start = draw_list->VtxBuffer.Data + vert_start_idx;

	lea	r8, QWORD PTR [rdx+rcx*4]

; 1948 :     ImDrawVert* vert_end = draw_list->VtxBuffer.Data + vert_end_idx;

	lea	rcx, QWORD PTR [r11+r11*4]
	lea	r11, QWORD PTR [rdx+rcx*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 463  : static inline ImVec2 ImMax(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x >= rhs.x ? lhs.x : rhs.x, lhs.y >= rhs.y ? lhs.y : rhs.y); }

	maxss	xmm5, xmm4
	maxss	xmm6, xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1953 :         for (ImDrawVert* vertex = vert_start; vertex < vert_end; ++vertex)

	cmp	r8, r11
	jae	$LN87@ShadeVerts
	mov	rax, r11
	sub	rax, r8
	add	rax, 19
	cmp	rax, 80					; 00000050H
	jb	$LN113@ShadeVerts
	lea	rdx, QWORD PTR [r11-60]
	lea	rax, QWORD PTR [r8+32]
	npad	2
$LL105@ShadeVerts:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm2, DWORD PTR [rax-28]
	subss	xmm2, DWORD PTR [r9+4]
	movss	xmm1, DWORD PTR [r8]
	subss	xmm1, DWORD PTR [r9]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mulss	xmm2, xmm8
	mulss	xmm1, xmm7

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm2, DWORD PTR [r10+4]
	addss	xmm1, DWORD PTR [r10]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1954 :             vertex->uv = ImClamp(uv_a + ImMul(ImVec2(vertex->pos.x, vertex->pos.y) - a, scale), min, max);

	comiss	xmm3, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 464  : static inline ImVec2 ImClamp(const ImVec2& v, const ImVec2& mn, ImVec2 mx)      { return ImVec2((v.x < mn.x) ? mn.x : (v.x > mx.x) ? mx.x : v.x, (v.y < mn.y) ? mn.y : (v.y > mx.y) ? mx.y : v.y); }

	jbe	SHORT $LN89@ShadeVerts
	movaps	xmm4, xmm3
	jmp	SHORT $LN90@ShadeVerts
$LN89@ShadeVerts:
	movaps	xmm4, xmm6
	minss	xmm4, xmm2
$LN90@ShadeVerts:
	comiss	xmm0, xmm1
	jbe	SHORT $LN91@ShadeVerts
	movaps	xmm2, xmm0
	jmp	SHORT $LN92@ShadeVerts
$LN91@ShadeVerts:
	movaps	xmm2, xmm5
	minss	xmm2, xmm1
$LN92@ShadeVerts:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm1, DWORD PTR [rax-12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1954 :             vertex->uv = ImClamp(uv_a + ImMul(ImVec2(vertex->pos.x, vertex->pos.y) - a, scale), min, max);

	movss	DWORD PTR [rax-24], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm2, DWORD PTR [rax-8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1954 :             vertex->uv = ImClamp(uv_a + ImMul(ImVec2(vertex->pos.x, vertex->pos.y) - a, scale), min, max);

	movss	DWORD PTR [rax-20], xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	subss	xmm2, DWORD PTR [r9+4]
	subss	xmm1, DWORD PTR [r9]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mulss	xmm2, xmm8
	mulss	xmm1, xmm7

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm2, DWORD PTR [r10+4]
	addss	xmm1, DWORD PTR [r10]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1954 :             vertex->uv = ImClamp(uv_a + ImMul(ImVec2(vertex->pos.x, vertex->pos.y) - a, scale), min, max);

	comiss	xmm3, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 464  : static inline ImVec2 ImClamp(const ImVec2& v, const ImVec2& mn, ImVec2 mx)      { return ImVec2((v.x < mn.x) ? mn.x : (v.x > mx.x) ? mx.x : v.x, (v.y < mn.y) ? mn.y : (v.y > mx.y) ? mx.y : v.y); }

	jbe	SHORT $LN93@ShadeVerts
	movaps	xmm4, xmm3
	jmp	SHORT $LN94@ShadeVerts
$LN93@ShadeVerts:
	movaps	xmm4, xmm6
	minss	xmm4, xmm2
$LN94@ShadeVerts:
	comiss	xmm0, xmm1
	jbe	SHORT $LN95@ShadeVerts
	movaps	xmm2, xmm0
	jmp	SHORT $LN96@ShadeVerts
$LN95@ShadeVerts:
	movaps	xmm2, xmm5
	minss	xmm2, xmm1
$LN96@ShadeVerts:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm1, DWORD PTR [rax+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1954 :             vertex->uv = ImClamp(uv_a + ImMul(ImVec2(vertex->pos.x, vertex->pos.y) - a, scale), min, max);

	movss	DWORD PTR [rax-4], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm2, DWORD PTR [rax+12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1954 :             vertex->uv = ImClamp(uv_a + ImMul(ImVec2(vertex->pos.x, vertex->pos.y) - a, scale), min, max);

	movss	DWORD PTR [rax], xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	subss	xmm2, DWORD PTR [r9+4]
	subss	xmm1, DWORD PTR [r9]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mulss	xmm2, xmm8
	mulss	xmm1, xmm7

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm2, DWORD PTR [r10+4]
	addss	xmm1, DWORD PTR [r10]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1954 :             vertex->uv = ImClamp(uv_a + ImMul(ImVec2(vertex->pos.x, vertex->pos.y) - a, scale), min, max);

	comiss	xmm3, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 464  : static inline ImVec2 ImClamp(const ImVec2& v, const ImVec2& mn, ImVec2 mx)      { return ImVec2((v.x < mn.x) ? mn.x : (v.x > mx.x) ? mx.x : v.x, (v.y < mn.y) ? mn.y : (v.y > mx.y) ? mx.y : v.y); }

	jbe	SHORT $LN97@ShadeVerts
	movaps	xmm4, xmm3
	jmp	SHORT $LN98@ShadeVerts
$LN97@ShadeVerts:
	movaps	xmm4, xmm6
	minss	xmm4, xmm2
$LN98@ShadeVerts:
	comiss	xmm0, xmm1
	jbe	SHORT $LN99@ShadeVerts
	movaps	xmm2, xmm0
	jmp	SHORT $LN100@ShadeVerts
$LN99@ShadeVerts:
	movaps	xmm2, xmm5
	minss	xmm2, xmm1
$LN100@ShadeVerts:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm1, DWORD PTR [rax+28]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1954 :             vertex->uv = ImClamp(uv_a + ImMul(ImVec2(vertex->pos.x, vertex->pos.y) - a, scale), min, max);

	movss	DWORD PTR [rax+16], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm2, DWORD PTR [rax+32]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1954 :             vertex->uv = ImClamp(uv_a + ImMul(ImVec2(vertex->pos.x, vertex->pos.y) - a, scale), min, max);

	movss	DWORD PTR [rax+20], xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	subss	xmm2, DWORD PTR [r9+4]
	subss	xmm1, DWORD PTR [r9]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mulss	xmm2, xmm8
	mulss	xmm1, xmm7

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm2, DWORD PTR [r10+4]
	addss	xmm1, DWORD PTR [r10]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1954 :             vertex->uv = ImClamp(uv_a + ImMul(ImVec2(vertex->pos.x, vertex->pos.y) - a, scale), min, max);

	comiss	xmm3, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 464  : static inline ImVec2 ImClamp(const ImVec2& v, const ImVec2& mn, ImVec2 mx)      { return ImVec2((v.x < mn.x) ? mn.x : (v.x > mx.x) ? mx.x : v.x, (v.y < mn.y) ? mn.y : (v.y > mx.y) ? mx.y : v.y); }

	jbe	SHORT $LN101@ShadeVerts
	movaps	xmm4, xmm3
	jmp	SHORT $LN102@ShadeVerts
$LN101@ShadeVerts:
	movaps	xmm4, xmm6
	minss	xmm4, xmm2
$LN102@ShadeVerts:
	comiss	xmm0, xmm1
	jbe	SHORT $LN103@ShadeVerts
	movaps	xmm2, xmm0
	jmp	SHORT $LN104@ShadeVerts
$LN103@ShadeVerts:
	movaps	xmm2, xmm5
	minss	xmm2, xmm1
$LN104@ShadeVerts:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1954 :             vertex->uv = ImClamp(uv_a + ImMul(ImVec2(vertex->pos.x, vertex->pos.y) - a, scale), min, max);

	movss	DWORD PTR [rax+36], xmm2
	add	r8, 80					; 00000050H
	movss	DWORD PTR [rax+40], xmm4
	add	rax, 80					; 00000050H
	cmp	r8, rdx
	jb	$LL105@ShadeVerts

; 1953 :         for (ImDrawVert* vertex = vert_start; vertex < vert_end; ++vertex)

	cmp	r8, r11
	jae	SHORT $LN87@ShadeVerts
$LN113@ShadeVerts:
	lea	rcx, QWORD PTR [r8+4]
$LC4@ShadeVerts:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm2, DWORD PTR [rcx]
	subss	xmm2, DWORD PTR [r9+4]
	movss	xmm1, DWORD PTR [rcx-4]
	subss	xmm1, DWORD PTR [r9]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mulss	xmm2, xmm8
	mulss	xmm1, xmm7

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm2, DWORD PTR [r10+4]
	addss	xmm1, DWORD PTR [r10]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1954 :             vertex->uv = ImClamp(uv_a + ImMul(ImVec2(vertex->pos.x, vertex->pos.y) - a, scale), min, max);

	comiss	xmm3, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 464  : static inline ImVec2 ImClamp(const ImVec2& v, const ImVec2& mn, ImVec2 mx)      { return ImVec2((v.x < mn.x) ? mn.x : (v.x > mx.x) ? mx.x : v.x, (v.y < mn.y) ? mn.y : (v.y > mx.y) ? mx.y : v.y); }

	jbe	SHORT $LN59@ShadeVerts
	movaps	xmm4, xmm3
	jmp	SHORT $LN60@ShadeVerts
$LN59@ShadeVerts:
	movaps	xmm4, xmm6
	minss	xmm4, xmm2
$LN60@ShadeVerts:
	comiss	xmm0, xmm1
	jbe	SHORT $LN63@ShadeVerts
	movaps	xmm2, xmm0
	jmp	SHORT $LN64@ShadeVerts
$LN63@ShadeVerts:
	movaps	xmm2, xmm5
	minss	xmm2, xmm1
$LN64@ShadeVerts:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1954 :             vertex->uv = ImClamp(uv_a + ImMul(ImVec2(vertex->pos.x, vertex->pos.y) - a, scale), min, max);

	movss	DWORD PTR [rcx+4], xmm2
	movss	DWORD PTR [rcx+8], xmm4
	add	rcx, 20
	lea	rax, QWORD PTR [rcx-4]
	cmp	rax, r11
	jb	SHORT $LC4@ShadeVerts
$LN87@ShadeVerts:

; 1955 :     }
; 1956 :     else
; 1957 :     {
; 1958 :         for (ImDrawVert* vertex = vert_start; vertex < vert_end; ++vertex)
; 1959 :             vertex->uv = uv_a + ImMul(ImVec2(vertex->pos.x, vertex->pos.y) - a, scale);
; 1960 :     }
; 1961 : }

	movaps	xmm6, XMMWORD PTR [rsp+48]
	movaps	xmm7, XMMWORD PTR [rsp+32]
	movaps	xmm8, XMMWORD PTR [rsp+16]
	movaps	xmm9, XMMWORD PTR [rsp]
	add	rsp, 72					; 00000048H
	ret	0
?ShadeVertsLinearUV@ImGui@@YAXPEAUImDrawList@@HHAEBUImVec2@@111_N@Z ENDP ; ImGui::ShadeVertsLinearUV
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ??0ImFontConfig@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0ImFontConfig@@QEAA@XZ PROC				; ImFontConfig::ImFontConfig, COMDAT

; 1968 : {

	xorps	xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 269  :     constexpr ImVec2()                      : x(0.0f), y(0.0f) { }

	xor	eax, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1969 :     memset(this, 0, sizeof(*this));

	movups	XMMWORD PTR [rcx], xmm0
	movups	XMMWORD PTR [rcx+16], xmm0
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	XMMWORD PTR [rcx+48], xmm0
	movups	XMMWORD PTR [rcx+64], xmm0
	movups	XMMWORD PTR [rcx+80], xmm0
	movups	XMMWORD PTR [rcx+96], xmm0
	movups	XMMWORD PTR [rcx+112], xmm0
	mov	QWORD PTR [rcx+128], rax

; 1970 :     FontDataOwnedByAtlas = true;
; 1971 :     OversampleH = 2;
; 1972 :     OversampleV = 1;
; 1973 :     GlyphMaxAdvanceX = FLT_MAX;
; 1974 :     RasterizerMultiply = 1.0f;
; 1975 :     EllipsisChar = (ImWchar)-1;
; 1976 : }

	mov	rax, rcx
	mov	BYTE PTR [rcx+12], 1
	mov	DWORD PTR [rcx+24], 2
	mov	DWORD PTR [rcx+28], 1
	mov	DWORD PTR [rcx+68], 2139095039		; 7f7fffffH
	mov	DWORD PTR [rcx+80], 1065353216		; 3f800000H
	mov	WORD PTR [rcx+84], 65535		; 0000ffffH
	ret	0
??0ImFontConfig@@QEAA@XZ ENDP				; ImFontConfig::ImFontConfig
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?ClearInputData@ImFontAtlas@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?ClearInputData@ImFontAtlas@@QEAAXXZ PROC		; ImFontAtlas::ClearInputData, COMDAT

; 2046 : {

$LN79:
	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	sub	rsp, 32					; 00000020H

; 2047 :     IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
; 2048 :     for (int i = 0; i < ConfigData.Size; i++)

	xor	ebp, ebp
	mov	QWORD PTR [rsp+48], rsi
	mov	rbx, rcx
	mov	QWORD PTR [rsp+64], r14
	mov	esi, ebp
	cmp	DWORD PTR [rcx+120], ebp
	jle	SHORT $LN65@ClearInput
	mov	QWORD PTR [rsp+56], rdi
	mov	edi, ebp
	npad	9
$LL4@ClearInput:

; 2049 :         if (ConfigData[i].FontData && ConfigData[i].FontDataOwnedByAtlas)

	mov	rax, QWORD PTR [rbx+128]
	mov	rcx, QWORD PTR [rax+rdi]
	test	rcx, rcx
	je	SHORT $LN2@ClearInput
	cmp	BYTE PTR [rax+rdi+12], bpl
	je	SHORT $LN2@ClearInput
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN19@ClearInput

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN19@ClearInput:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2052 :             ConfigData[i].FontData = NULL;

	mov	rax, QWORD PTR [rbx+128]
	mov	QWORD PTR [rdi+rax], rbp
$LN2@ClearInput:

; 2047 :     IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
; 2048 :     for (int i = 0; i < ConfigData.Size; i++)

	inc	esi
	add	rdi, 136				; 00000088H
	cmp	esi, DWORD PTR [rbx+120]
	jl	SHORT $LL4@ClearInput
	mov	rdi, QWORD PTR [rsp+56]
$LN65@ClearInput:

; 2053 :         }
; 2054 : 
; 2055 :     // When clearing this we lose access to the font name and other information used to build the font.
; 2056 :     for (int i = 0; i < Fonts.Size; i++)

	mov	r8d, ebp
	mov	rsi, QWORD PTR [rsp+48]
	cmp	DWORD PTR [rbx+88], ebp
	jle	SHORT $LN6@ClearInput
	mov	rdx, rbp
	npad	3
$LL7@ClearInput:

; 2057 :         if (Fonts[i]->ConfigData >= ConfigData.Data && Fonts[i]->ConfigData < ConfigData.Data + ConfigData.Size)

	mov	rax, QWORD PTR [rbx+96]
	mov	r10, QWORD PTR [rbx+128]
	mov	r11, QWORD PTR [rdx+rax]
	mov	r9, QWORD PTR [r11+72]
	cmp	r9, r10
	jb	SHORT $LN5@ClearInput
	movsxd	rax, DWORD PTR [rbx+120]
	imul	rcx, rax, 136				; 00000088H
	add	rcx, r10
	cmp	r9, rcx
	jae	SHORT $LN5@ClearInput

; 2058 :         {
; 2059 :             Fonts[i]->ConfigData = NULL;

	mov	QWORD PTR [r11+72], rbp

; 2060 :             Fonts[i]->ConfigDataCount = 0;

	mov	rax, QWORD PTR [rbx+96]
	mov	rcx, QWORD PTR [rdx+rax]
	mov	WORD PTR [rcx+80], bp
$LN5@ClearInput:

; 2053 :         }
; 2054 : 
; 2055 :     // When clearing this we lose access to the font name and other information used to build the font.
; 2056 :     for (int i = 0; i < Fonts.Size; i++)

	inc	r8d
	add	rdx, 8
	cmp	r8d, DWORD PTR [rbx+88]
	jl	SHORT $LL7@ClearInput
$LN6@ClearInput:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	rcx, QWORD PTR [rbx+128]
	mov	r14, QWORD PTR [rsp+64]
	test	rcx, rcx
	je	SHORT $LN36@ClearInput
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx+120], rbp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN40@ClearInput

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN40@ClearInput:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx+128], rbp
$LN36@ClearInput:
	mov	rcx, QWORD PTR [rbx+112]
	test	rcx, rcx
	je	SHORT $LN66@ClearInput
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx+104], rbp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN51@ClearInput

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN51@ClearInput:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx+112], rbp
$LN66@ClearInput:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2066 : }

	mov	QWORD PTR [rbx+1172], -1
	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?ClearInputData@ImFontAtlas@@QEAAXXZ ENDP		; ImFontAtlas::ClearInputData
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?ClearTexData@ImFontAtlas@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?ClearTexData@ImFontAtlas@@QEAAXXZ PROC			; ImFontAtlas::ClearTexData, COMDAT

; 2069 : {

$LN26:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 2070 :     IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
; 2071 :     if (TexPixelsAlpha8)

	mov	rcx, QWORD PTR [rcx+48]
	test	rcx, rcx
	je	SHORT $LN9@ClearTexDa
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN7@ClearTexDa

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN7@ClearTexDa:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
$LN9@ClearTexDa:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2073 :     if (TexPixelsRGBA32)

	mov	rcx, QWORD PTR [rbx+56]
	test	rcx, rcx
	je	SHORT $LN17@ClearTexDa
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN15@ClearTexDa

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN15@ClearTexDa:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
$LN17@ClearTexDa:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2075 :     TexPixelsAlpha8 = NULL;

	xor	eax, eax
	mov	QWORD PTR [rbx+48], rax

; 2076 :     TexPixelsRGBA32 = NULL;

	mov	QWORD PTR [rbx+56], rax

; 2077 :     TexPixelsUseColors = false;

	mov	BYTE PTR [rbx+41], al

; 2078 :     // Important: we leave TexReady untouched
; 2079 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?ClearTexData@ImFontAtlas@@QEAAXXZ ENDP			; ImFontAtlas::ClearTexData
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?ClearFonts@ImFontAtlas@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?ClearFonts@ImFontAtlas@@QEAAXXZ PROC			; ImFontAtlas::ClearFonts, COMDAT

; 2082 : {

$LN46:
	mov	QWORD PTR [rsp+32], rbp
	push	r14
	sub	rsp, 32					; 00000020H
	mov	QWORD PTR [rsp+48], rbx
	mov	rbp, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1909 :     inline void         clear_delete()                      { for (int n = 0; n < Size; n++) IM_DELETE(Data[n]); clear(); }     // Important: never called automatically! always explicit.

	xor	ebx, ebx
	cmp	DWORD PTR [rcx+88], ebx
	jle	SHORT $LN37@ClearFonts
	mov	QWORD PTR [rsp+56], rsi
	xor	esi, esi
	mov	QWORD PTR [rsp+64], rdi
	npad	10
$LL6@ClearFonts:
	mov	rax, QWORD PTR [rbp+96]
	mov	rdi, QWORD PTR [rsi+rax]

; 1876 : template<typename T> void IM_DELETE(T* p)   { if (p) { p->~T(); ImGui::MemFree(p); } }

	test	rdi, rdi
	je	SHORT $LN4@ClearFonts
	mov	rcx, rdi
	call	??1ImFont@@QEAA@XZ			; ImFont::~ImFont
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN16@ClearFonts

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN16@ClearFonts:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	mov	rcx, rdi
	call	QWORD PTR __imp_free
$LN4@ClearFonts:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1909 :     inline void         clear_delete()                      { for (int n = 0; n < Size; n++) IM_DELETE(Data[n]); clear(); }     // Important: never called automatically! always explicit.

	inc	ebx
	add	rsi, 8
	cmp	ebx, DWORD PTR [rbp+88]
	jl	SHORT $LL6@ClearFonts
	mov	rdi, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+56]
$LN37@ClearFonts:

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	rcx, QWORD PTR [rbp+96]
	mov	rbx, QWORD PTR [rsp+48]
	test	rcx, rcx
	je	SHORT $LN38@ClearFonts
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbp+88], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN27@ClearFonts

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN27@ClearFonts:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbp+96], 0
$LN38@ClearFonts:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2086 : }

	mov	BYTE PTR [rbp+40], 0
	mov	rbp, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
?ClearFonts@ImFontAtlas@@QEAAXXZ ENDP			; ImFontAtlas::ClearFonts
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?Clear@ImFontAtlas@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?Clear@ImFontAtlas@@QEAAXXZ PROC			; ImFontAtlas::Clear, COMDAT

; 2089 : {

$LN48:
	mov	QWORD PTR [rsp+32], rdi
	push	r15
	sub	rsp, 32					; 00000020H
	mov	QWORD PTR [rsp+56], rsi
	mov	rdi, rcx

; 2090 :     ClearInputData();

	call	?ClearInputData@ImFontAtlas@@QEAAXXZ	; ImFontAtlas::ClearInputData

; 2091 :     ClearTexData();

	mov	rcx, rdi
	call	?ClearTexData@ImFontAtlas@@QEAAXXZ	; ImFontAtlas::ClearTexData
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1909 :     inline void         clear_delete()                      { for (int n = 0; n < Size; n++) IM_DELETE(Data[n]); clear(); }     // Important: never called automatically! always explicit.

	xor	esi, esi
	cmp	DWORD PTR [rdi+88], esi
	jle	SHORT $LN39@Clear
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+64], r14
	xor	r14d, r14d
	npad	12
$LL8@Clear:
	mov	rax, QWORD PTR [rdi+96]
	mov	rbx, QWORD PTR [r14+rax]

; 1876 : template<typename T> void IM_DELETE(T* p)   { if (p) { p->~T(); ImGui::MemFree(p); } }

	test	rbx, rbx
	je	SHORT $LN6@Clear
	mov	rcx, rbx
	call	??1ImFont@@QEAA@XZ			; ImFont::~ImFont
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN18@Clear

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN18@Clear:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	mov	rcx, rbx
	call	QWORD PTR __imp_free
$LN6@Clear:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1909 :     inline void         clear_delete()                      { for (int n = 0; n < Size; n++) IM_DELETE(Data[n]); clear(); }     // Important: never called automatically! always explicit.

	inc	esi
	add	r14, 8
	cmp	esi, DWORD PTR [rdi+88]
	jl	SHORT $LL8@Clear
	mov	r14, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+48]
$LN39@Clear:

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	rcx, QWORD PTR [rdi+96]
	mov	rsi, QWORD PTR [rsp+56]
	test	rcx, rcx
	je	SHORT $LN40@Clear
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rdi+88], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN29@Clear

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN29@Clear:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rdi+96], 0
$LN40@Clear:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2093 : }

	mov	BYTE PTR [rdi+40], 0
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r15
	ret	0
?Clear@ImFontAtlas@@QEAAXXZ ENDP			; ImFontAtlas::Clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?GetTexDataAsAlpha8@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z
_TEXT	SEGMENT
$T1 = 48
font_cfg$2 = 192
__$ArrayPad$ = 336
this$ = 368
out_pixels$ = 376
out_width$dead$ = 384
out_height$dead$ = 392
out_bytes_per_pixel$dead$ = 400
?GetTexDataAsAlpha8@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z PROC ; ImFontAtlas::GetTexDataAsAlpha8, COMDAT

; 2096 : {

$LN35:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rdi
	push	rbp
	lea	rbp, QWORD PTR [rsp-96]
	sub	rsp, 352				; 00000160H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax

; 2097 :     // Build atlas on demand
; 2098 :     if (TexPixelsAlpha8 == NULL)

	cmp	QWORD PTR [rcx+48], 0
	mov	rdi, rdx
	mov	rbx, rcx
	jne	$LN28@GetTexData

; 2322 :     if (ConfigData.Size == 0)

	cmp	DWORD PTR [rcx+120], 0
	jne	$LN8@GetTexData
	xorps	xmm2, xmm2

; 1969 :     memset(this, 0, sizeof(*this));

	xor	eax, eax
	movups	XMMWORD PTR $T1[rsp+16], xmm2
	mov	QWORD PTR $T1[rbp-128], rax

; 1975 :     EllipsisChar = (ImWchar)-1;

	mov	eax, 65535				; 0000ffffH
	movups	XMMWORD PTR $T1[rbp-176], xmm2
	mov	DWORD PTR $T1[rsp+24], 2
	movups	XMMWORD PTR $T1[rsp], xmm2
	mov	BYTE PTR $T1[rsp+12], 1

; 2182 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

	movaps	xmm0, XMMWORD PTR $T1[rsp]

; 1969 :     memset(this, 0, sizeof(*this));

	movups	XMMWORD PTR $T1[rsp+64], xmm2

; 1973 :     GlyphMaxAdvanceX = FLT_MAX;

	mov	DWORD PTR $T1[rsp+68], 2139095039	; 7f7fffffH

; 2182 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

	movaps	XMMWORD PTR font_cfg$2[rbp-256], xmm0
	movaps	xmm0, XMMWORD PTR $T1[rsp+64]
	movaps	XMMWORD PTR font_cfg$2[rbp-192], xmm0
	movsd	xmm0, QWORD PTR $T1[rbp-128]
	movaps	XMMWORD PTR font_cfg$2[rbp-224], xmm2

; 1972 :     OversampleV = 1;

	mov	DWORD PTR $T1[rsp+28], 1

; 2182 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

	movaps	xmm1, XMMWORD PTR $T1[rsp+16]
	movaps	XMMWORD PTR font_cfg$2[rbp-240], xmm1
	movsd	QWORD PTR font_cfg$2[rbp-128], xmm0
	xorps	xmm0, xmm0
	movaps	XMMWORD PTR font_cfg$2[rbp-208], xmm2
	movaps	XMMWORD PTR font_cfg$2[rbp-160], xmm2
	movaps	XMMWORD PTR font_cfg$2[rbp-144], xmm2

; 2187 :     }
; 2188 :     if (font_cfg.SizePixels <= 0.0f)

	movss	xmm2, DWORD PTR font_cfg$2[rbp-236]
	comiss	xmm0, xmm2

; 1974 :     RasterizerMultiply = 1.0f;

	mov	DWORD PTR $T1[rbp-176], 1065353216	; 3f800000H

; 1975 :     EllipsisChar = (ImWchar)-1;

	mov	WORD PTR $T1[rbp-172], ax

; 2185 :         font_cfg.OversampleH = font_cfg.OversampleV = 1;

	mov	DWORD PTR font_cfg$2[rbp-228], 1
	mov	DWORD PTR font_cfg$2[rbp-232], 1

; 2186 :         font_cfg.PixelSnapH = true;

	mov	BYTE PTR font_cfg$2[rbp-224], 1
	movaps	xmm1, XMMWORD PTR $T1[rbp-176]
	movaps	XMMWORD PTR font_cfg$2[rbp-176], xmm1

; 2187 :     }
; 2188 :     if (font_cfg.SizePixels <= 0.0f)

	jb	SHORT $LN13@GetTexData

; 2189 :         font_cfg.SizePixels = 13.0f * 1.0f;

	movss	xmm2, DWORD PTR __real@41500000
	movss	DWORD PTR font_cfg$2[rbp-236], xmm2
$LN13@GetTexData:

; 2190 :     if (font_cfg.Name[0] == '\0')

	psrldq	xmm1, 6
	movd	eax, xmm1
	test	al, al
	jne	SHORT $LN14@GetTexData

; 2191 :         ImFormatString(font_cfg.Name, IM_ARRAYSIZE(font_cfg.Name), "ProggyClean.ttf, %dpx", (int)font_cfg.SizePixels);

	cvttss2si r9d, xmm2
	lea	r8, OFFSET FLAT:??_C@_0BG@CONABPA@ProggyClean?4ttf?0?5?$CFdpx@
	mov	edx, 40					; 00000028H
	lea	rcx, QWORD PTR font_cfg$2[rbp-170]
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString
	movss	xmm2, DWORD PTR font_cfg$2[rbp-236]
$LN14@GetTexData:

; 2192 :     font_cfg.EllipsisChar = (ImWchar)0x0085;
; 2193 :     font_cfg.GlyphOffset.y = 1.0f * IM_FLOOR(font_cfg.SizePixels / 13.0f);  // Add +1 offset per 13 units

	movaps	xmm0, xmm2

; 2194 : 
; 2195 :     const char* ttf_compressed_base85 = GetDefaultCompressedFontDataTTFBase85();
; 2196 :     const ImWchar* glyph_ranges = font_cfg.GlyphRanges != NULL ? font_cfg.GlyphRanges : GetGlyphRangesDefault();

	lea	rcx, OFFSET FLAT:?ranges@?1??GetGlyphRangesDefault@ImFontAtlas@@QEAAPEBGXZ@4QBGB
	divss	xmm0, DWORD PTR __real@41500000
	mov	eax, 133				; 00000085H

; 2197 :     ImFont* font = AddFontFromMemoryCompressedBase85TTF(ttf_compressed_base85, font_cfg.SizePixels, &font_cfg, glyph_ranges);

	lea	r9, QWORD PTR font_cfg$2[rbp-256]
	mov	WORD PTR font_cfg$2[rbp-172], ax
	lea	rdx, OFFSET FLAT:?proggy_clean_ttf_compressed_data_base85@@3QBDB
	cvttss2si eax, xmm0
	movd	xmm0, eax

; 2194 : 
; 2195 :     const char* ttf_compressed_base85 = GetDefaultCompressedFontDataTTFBase85();
; 2196 :     const ImWchar* glyph_ranges = font_cfg.GlyphRanges != NULL ? font_cfg.GlyphRanges : GetGlyphRangesDefault();

	mov	rax, QWORD PTR font_cfg$2[rbp-200]
	test	rax, rax
	cvtdq2ps xmm0, xmm0
	cmovne	rcx, rax

; 2197 :     ImFont* font = AddFontFromMemoryCompressedBase85TTF(ttf_compressed_base85, font_cfg.SizePixels, &font_cfg, glyph_ranges);

	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, rbx
	movss	DWORD PTR font_cfg$2[rbp-208], xmm0
	call	?AddFontFromMemoryCompressedBase85TTF@ImFontAtlas@@QEAAPEAUImFont@@PEBDMPEBUImFontConfig@@PEBG@Z ; ImFontAtlas::AddFontFromMemoryCompressedBase85TTF
$LN8@GetTexData:

; 2330 :     const ImFontBuilderIO* builder_io = FontBuilderIO;

	mov	rax, QWORD PTR [rbx+1160]

; 2331 :     if (builder_io == NULL)

	test	rax, rax
	jne	SHORT $LN9@GetTexData

; 2659 :     io.FontBuilder_Build = ImFontAtlasBuildWithStbTruetype;

	lea	rax, OFFSET FLAT:?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z ; ImFontAtlasBuildWithStbTruetype
	mov	QWORD PTR ?io@?1??ImFontAtlasGetBuilderForStbTruetype@@YAPEBUImFontBuilderIO@@XZ@4U2@A, rax

; 2336 :         builder_io = ImFontAtlasGetBuilderForStbTruetype();

	lea	rax, OFFSET FLAT:?io@?1??ImFontAtlasGetBuilderForStbTruetype@@YAPEBUImFontBuilderIO@@XZ@4U2@A
$LN9@GetTexData:

; 2337 : #else
; 2338 :         IM_ASSERT(0); // Invalid Build function
; 2339 : #endif
; 2340 :     }
; 2341 : 
; 2342 :     // Build
; 2343 :     return builder_io->FontBuilder_Build(this);

	mov	rcx, rbx
	call	QWORD PTR [rax]

; 2099 :         Build();
; 2100 : 
; 2101 :     *out_pixels = TexPixelsAlpha8;

	mov	rax, QWORD PTR [rbx+48]
	mov	QWORD PTR [rdi], rax
	jmp	SHORT $LN2@GetTexData
$LN28@GetTexData:
	mov	rax, QWORD PTR [rcx+48]
	mov	QWORD PTR [rdx], rax
$LN2@GetTexData:

; 2102 :     if (out_width) *out_width = TexWidth;
; 2103 :     if (out_height) *out_height = TexHeight;
; 2104 :     if (out_bytes_per_pixel) *out_bytes_per_pixel = 1;
; 2105 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+352]
	mov	rbx, QWORD PTR [r11+32]
	mov	rdi, QWORD PTR [r11+40]
	mov	rsp, r11
	pop	rbp
	ret	0
?GetTexDataAsAlpha8@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z ENDP ; ImFontAtlas::GetTexDataAsAlpha8
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z
_TEXT	SEGMENT
$T1 = 48
font_cfg$2 = 192
__$ArrayPad$ = 336
this$ = 416
out_pixels$ = 424
out_width$ = 432
out_height$ = 440
out_bytes_per_pixel$dead$ = 448
?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z PROC ; ImFontAtlas::GetTexDataAsRGBA32, COMDAT

; 2108 : {

$LN62:
	mov	r11, rsp
	push	rbp
	push	rbx
	push	rsi
	lea	rbp, QWORD PTR [rsp-128]
	sub	rsp, 384				; 00000180H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax

; 2109 :     // Convert to RGBA32 format on demand
; 2110 :     // Although it is likely to be the most commonly used format, our font rendering is 1 channel / 8 bpp
; 2111 :     if (!TexPixelsRGBA32)

	cmp	QWORD PTR [rcx+56], 0
	mov	rsi, r9
	mov	QWORD PTR [r11-40], r14
	mov	rbx, rcx
	mov	QWORD PTR [r11-48], r15
	mov	r14, r8
	mov	r15, rdx
	jne	$LN3@GetTexData

; 2098 :     if (TexPixelsAlpha8 == NULL)

	cmp	QWORD PTR [rcx+48], 0

; 2109 :     // Convert to RGBA32 format on demand
; 2110 :     // Although it is likely to be the most commonly used format, our font rendering is 1 channel / 8 bpp
; 2111 :     if (!TexPixelsRGBA32)

	mov	QWORD PTR [r11-32], rdi

; 2098 :     if (TexPixelsAlpha8 == NULL)

	jne	$LN12@GetTexData

; 2322 :     if (ConfigData.Size == 0)

	cmp	DWORD PTR [rcx+120], 0
	jne	$LN18@GetTexData
	xorps	xmm2, xmm2

; 1969 :     memset(this, 0, sizeof(*this));

	xor	eax, eax
	movups	XMMWORD PTR $T1[rsp+16], xmm2
	mov	QWORD PTR $T1[rbp-128], rax

; 1975 :     EllipsisChar = (ImWchar)-1;

	mov	eax, 65535				; 0000ffffH
	movups	XMMWORD PTR $T1[rbp-176], xmm2
	mov	DWORD PTR $T1[rsp+24], 2
	movups	XMMWORD PTR $T1[rsp], xmm2
	mov	BYTE PTR $T1[rsp+12], 1

; 2182 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

	movaps	xmm0, XMMWORD PTR $T1[rsp]

; 1969 :     memset(this, 0, sizeof(*this));

	movups	XMMWORD PTR $T1[rsp+64], xmm2

; 1973 :     GlyphMaxAdvanceX = FLT_MAX;

	mov	DWORD PTR $T1[rsp+68], 2139095039	; 7f7fffffH

; 2182 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

	movaps	XMMWORD PTR font_cfg$2[rbp-256], xmm0
	movaps	xmm0, XMMWORD PTR $T1[rsp+64]
	movaps	XMMWORD PTR font_cfg$2[rbp-192], xmm0
	movsd	xmm0, QWORD PTR $T1[rbp-128]
	movaps	XMMWORD PTR font_cfg$2[rbp-224], xmm2

; 1972 :     OversampleV = 1;

	mov	DWORD PTR $T1[rsp+28], 1

; 2182 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

	movaps	xmm1, XMMWORD PTR $T1[rsp+16]
	movaps	XMMWORD PTR font_cfg$2[rbp-240], xmm1
	movsd	QWORD PTR font_cfg$2[rbp-128], xmm0
	xorps	xmm0, xmm0
	movaps	XMMWORD PTR font_cfg$2[rbp-208], xmm2
	movaps	XMMWORD PTR font_cfg$2[rbp-160], xmm2
	movaps	XMMWORD PTR font_cfg$2[rbp-144], xmm2

; 2187 :     }
; 2188 :     if (font_cfg.SizePixels <= 0.0f)

	movss	xmm2, DWORD PTR font_cfg$2[rbp-236]
	comiss	xmm0, xmm2

; 1974 :     RasterizerMultiply = 1.0f;

	mov	DWORD PTR $T1[rbp-176], 1065353216	; 3f800000H

; 1975 :     EllipsisChar = (ImWchar)-1;

	mov	WORD PTR $T1[rbp-172], ax

; 2185 :         font_cfg.OversampleH = font_cfg.OversampleV = 1;

	mov	DWORD PTR font_cfg$2[rbp-228], 1
	mov	DWORD PTR font_cfg$2[rbp-232], 1

; 2186 :         font_cfg.PixelSnapH = true;

	mov	BYTE PTR font_cfg$2[rbp-224], 1
	movaps	xmm1, XMMWORD PTR $T1[rbp-176]
	movaps	XMMWORD PTR font_cfg$2[rbp-176], xmm1

; 2187 :     }
; 2188 :     if (font_cfg.SizePixels <= 0.0f)

	jb	SHORT $LN23@GetTexData

; 2189 :         font_cfg.SizePixels = 13.0f * 1.0f;

	movss	xmm2, DWORD PTR __real@41500000
	movss	DWORD PTR font_cfg$2[rbp-236], xmm2
$LN23@GetTexData:

; 2190 :     if (font_cfg.Name[0] == '\0')

	psrldq	xmm1, 6
	movd	eax, xmm1
	test	al, al
	jne	SHORT $LN24@GetTexData

; 2191 :         ImFormatString(font_cfg.Name, IM_ARRAYSIZE(font_cfg.Name), "ProggyClean.ttf, %dpx", (int)font_cfg.SizePixels);

	cvttss2si r9d, xmm2
	lea	r8, OFFSET FLAT:??_C@_0BG@CONABPA@ProggyClean?4ttf?0?5?$CFdpx@
	mov	edx, 40					; 00000028H
	lea	rcx, QWORD PTR font_cfg$2[rbp-170]
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString
	movss	xmm2, DWORD PTR font_cfg$2[rbp-236]
$LN24@GetTexData:

; 2192 :     font_cfg.EllipsisChar = (ImWchar)0x0085;
; 2193 :     font_cfg.GlyphOffset.y = 1.0f * IM_FLOOR(font_cfg.SizePixels / 13.0f);  // Add +1 offset per 13 units

	movaps	xmm0, xmm2

; 2194 : 
; 2195 :     const char* ttf_compressed_base85 = GetDefaultCompressedFontDataTTFBase85();
; 2196 :     const ImWchar* glyph_ranges = font_cfg.GlyphRanges != NULL ? font_cfg.GlyphRanges : GetGlyphRangesDefault();

	lea	rcx, OFFSET FLAT:?ranges@?1??GetGlyphRangesDefault@ImFontAtlas@@QEAAPEBGXZ@4QBGB
	divss	xmm0, DWORD PTR __real@41500000
	mov	eax, 133				; 00000085H

; 2197 :     ImFont* font = AddFontFromMemoryCompressedBase85TTF(ttf_compressed_base85, font_cfg.SizePixels, &font_cfg, glyph_ranges);

	lea	r9, QWORD PTR font_cfg$2[rbp-256]
	mov	WORD PTR font_cfg$2[rbp-172], ax
	lea	rdx, OFFSET FLAT:?proggy_clean_ttf_compressed_data_base85@@3QBDB
	cvttss2si eax, xmm0
	movd	xmm0, eax

; 2194 : 
; 2195 :     const char* ttf_compressed_base85 = GetDefaultCompressedFontDataTTFBase85();
; 2196 :     const ImWchar* glyph_ranges = font_cfg.GlyphRanges != NULL ? font_cfg.GlyphRanges : GetGlyphRangesDefault();

	mov	rax, QWORD PTR font_cfg$2[rbp-200]
	test	rax, rax
	cvtdq2ps xmm0, xmm0
	cmovne	rcx, rax

; 2197 :     ImFont* font = AddFontFromMemoryCompressedBase85TTF(ttf_compressed_base85, font_cfg.SizePixels, &font_cfg, glyph_ranges);

	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, rbx
	movss	DWORD PTR font_cfg$2[rbp-208], xmm0
	call	?AddFontFromMemoryCompressedBase85TTF@ImFontAtlas@@QEAAPEAUImFont@@PEBDMPEBUImFontConfig@@PEBG@Z ; ImFontAtlas::AddFontFromMemoryCompressedBase85TTF
$LN18@GetTexData:

; 2330 :     const ImFontBuilderIO* builder_io = FontBuilderIO;

	mov	rax, QWORD PTR [rbx+1160]

; 2331 :     if (builder_io == NULL)

	test	rax, rax
	jne	SHORT $LN19@GetTexData

; 2659 :     io.FontBuilder_Build = ImFontAtlasBuildWithStbTruetype;

	lea	rax, OFFSET FLAT:?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z ; ImFontAtlasBuildWithStbTruetype
	mov	QWORD PTR ?io@?1??ImFontAtlasGetBuilderForStbTruetype@@YAPEBUImFontBuilderIO@@XZ@4U2@A, rax

; 2336 :         builder_io = ImFontAtlasGetBuilderForStbTruetype();

	lea	rax, OFFSET FLAT:?io@?1??ImFontAtlasGetBuilderForStbTruetype@@YAPEBUImFontBuilderIO@@XZ@4U2@A
$LN19@GetTexData:

; 2337 : #else
; 2338 :         IM_ASSERT(0); // Invalid Build function
; 2339 : #endif
; 2340 :     }
; 2341 : 
; 2342 :     // Build
; 2343 :     return builder_io->FontBuilder_Build(this);

	mov	rcx, rbx
	call	QWORD PTR [rax]
$LN12@GetTexData:

; 2101 :     *out_pixels = TexPixelsAlpha8;

	mov	rdi, QWORD PTR [rbx+48]

; 2112 :     {
; 2113 :         unsigned char* pixels = NULL;
; 2114 :         GetTexDataAsAlpha8(&pixels, NULL, NULL);
; 2115 :         if (pixels)

	test	rdi, rdi
	je	SHORT $LN60@GetTexData

; 2117 :             TexPixelsRGBA32 = (unsigned int*)IM_ALLOC((size_t)TexWidth * (size_t)TexHeight * 4);

	movsxd	rax, DWORD PTR [rbx+64]
	movsxd	rcx, DWORD PTR [rbx+68]
	imul	rcx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2117 :             TexPixelsRGBA32 = (unsigned int*)IM_ALLOC((size_t)TexWidth * (size_t)TexHeight * 4);

	shl	rcx, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN39@GetTexData

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN39@GetTexData:

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2120 :             for (int n = TexWidth * TexHeight; n > 0; n--)

	mov	edx, DWORD PTR [rbx+68]
	imul	edx, DWORD PTR [rbx+64]
	mov	QWORD PTR [rbx+56], rax
	test	edx, edx
	jle	SHORT $LN60@GetTexData
	npad	6
$LL4@GetTexData:

; 2121 :                 *dst++ = IM_COL32(255, 255, 255, (unsigned int)(*src++));

	movzx	ecx, BYTE PTR [rdi]
	lea	rax, QWORD PTR [rax+4]
	shl	ecx, 24
	lea	rdi, QWORD PTR [rdi+1]
	or	ecx, 16777215				; 00ffffffH
	dec	edx
	mov	DWORD PTR [rax-4], ecx
	test	edx, edx
	jg	SHORT $LL4@GetTexData
$LN60@GetTexData:
	mov	rdi, QWORD PTR [rsp+376]
$LN3@GetTexData:

; 2122 :         }
; 2123 :     }
; 2124 : 
; 2125 :     *out_pixels = (unsigned char*)TexPixelsRGBA32;

	mov	rax, QWORD PTR [rbx+56]
	mov	QWORD PTR [r15], rax
	mov	r15, QWORD PTR [rsp+360]

; 2126 :     if (out_width) *out_width = TexWidth;

	test	r14, r14
	je	SHORT $LN7@GetTexData
	mov	eax, DWORD PTR [rbx+64]
	mov	DWORD PTR [r14], eax
$LN7@GetTexData:

; 2127 :     if (out_height) *out_height = TexHeight;

	mov	r14, QWORD PTR [rsp+368]
	test	rsi, rsi
	je	SHORT $LN9@GetTexData
	mov	eax, DWORD PTR [rbx+68]
	mov	DWORD PTR [rsi], eax
$LN9@GetTexData:

; 2128 :     if (out_bytes_per_pixel) *out_bytes_per_pixel = 4;
; 2129 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 384				; 00000180H
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z ENDP ; ImFontAtlas::GetTexDataAsRGBA32
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z
_TEXT	SEGMENT
$T1 = 64
this$ = 64
font_cfg$ = 72
?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z PROC ; ImFontAtlas::AddFont, COMDAT

; 2132 : {

$LN80:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 2133 :     IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
; 2134 :     IM_ASSERT(font_cfg->FontData != NULL && font_cfg->FontDataSize > 0);
; 2135 :     IM_ASSERT(font_cfg->SizePixels > 0.0f);
; 2136 : 
; 2137 :     // Create new font
; 2138 :     if (!font_cfg->MergeMode)

	cmp	BYTE PTR [rdx+72], 0
	mov	rsi, rdx
	mov	QWORD PTR [rsp+72], rbp
	mov	rbx, rcx
	mov	QWORD PTR [rsp+88], r15
	lea	rbp, QWORD PTR [rcx+88]
	mov	r15d, 65535				; 0000ffffH
	jne	$LN2@AddFont
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN12@AddFont

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN12@AddFont:

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	mov	ecx, 120				; 00000078H
	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2139 :         Fonts.push_back(IM_NEW(ImFont));

	xor	ecx, ecx
	test	rax, rax
	je	SHORT $LN8@AddFont
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1903 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rax], rcx
	mov	QWORD PTR [rax+8], rcx
	mov	QWORD PTR [rax+24], rcx
	mov	QWORD PTR [rax+32], rcx
	mov	QWORD PTR [rax+40], rcx
	mov	QWORD PTR [rax+48], rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3182 :     FallbackAdvanceX = 0.0f;

	mov	QWORD PTR [rax+16], rcx

; 3183 :     FallbackChar = (ImWchar)-1;

	mov	DWORD PTR [rax+82], -1			; ffffffffH

; 3184 :     EllipsisChar = (ImWchar)-1;
; 3185 :     EllipsisWidth = EllipsisCharStep = 0.0f;

	mov	QWORD PTR [rax+88], rcx

; 3186 :     EllipsisCharCount = 0;

	mov	WORD PTR [rax+86], cx

; 3187 :     FallbackGlyph = NULL;

	mov	QWORD PTR [rax+56], rcx

; 3188 :     ContainerAtlas = NULL;

	mov	QWORD PTR [rax+64], rcx

; 3189 :     ConfigData = NULL;

	mov	QWORD PTR [rax+72], rcx

; 3190 :     ConfigDataCount = 0;

	mov	WORD PTR [rax+80], cx

; 3191 :     DirtyLookupTables = false;

	mov	BYTE PTR [rax+96], cl

; 3192 :     Scale = 1.0f;

	mov	QWORD PTR [rax+100], 1065353216		; 3f800000H

; 3193 :     Ascent = Descent = 0.0f;

	mov	QWORD PTR [rax+108], rcx

; 3194 :     MetricsTotalSurface = 0;
; 3195 :     memset(Used4kPagesMap, 0, sizeof(Used4kPagesMap));

	mov	WORD PTR [rax+116], cx

; 2139 :         Fonts.push_back(IM_NEW(ImFont));

	jmp	SHORT $LN9@AddFont
$LN8@AddFont:
	mov	rax, rcx
$LN9@AddFont:
	lea	rdx, QWORD PTR $T1[rsp]
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, rbp
	call	?push_back@?$ImVector@PEAUImFont@@@@QEAAXAEBQEAUImFont@@@Z ; ImVector<ImFont *>::push_back
$LN2@AddFont:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edi, DWORD PTR [rbx+120]
	mov	ecx, DWORD PTR [rbx+124]
	cmp	edi, ecx
	jne	$LN33@AddFont
	inc	edi

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN31@AddFont
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN32@AddFont
$LN31@AddFont:
	mov	eax, 8
$LN32@AddFont:
	cmp	eax, edi
	cmovg	edi, eax

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	cmp	edi, ecx
	jle	SHORT $LN33@AddFont
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rsp+80], r14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN38@AddFont

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN38@AddFont:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	movsxd	rax, edi
	imul	rcx, rax, 136				; 00000088H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	rdx, QWORD PTR [rbx+128]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	mov	r14, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	test	rdx, rdx
	je	SHORT $LN48@AddFont
	movsxd	rcx, DWORD PTR [rbx+120]
	imul	r8, rcx, 136				; 00000088H
	mov	rcx, rax
	call	memcpy
	mov	rcx, QWORD PTR [rbx+128]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	test	rcx, rcx
	je	SHORT $LN46@AddFont

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN46@AddFont

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN46@AddFont:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
$LN48@AddFont:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rbx+128], r14
	mov	r14, QWORD PTR [rsp+80]
	mov	DWORD PTR [rbx+124], edi
$LN33@AddFont:

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	movsxd	rax, DWORD PTR [rbx+120]
	movups	xmm0, XMMWORD PTR [rsi]
	movups	xmm1, XMMWORD PTR [rsi+16]
	imul	rcx, rax, 136				; 00000088H
	mov	rax, QWORD PTR [rbx+128]
	movups	XMMWORD PTR [rcx+rax], xmm0
	movups	xmm0, XMMWORD PTR [rsi+32]
	movups	XMMWORD PTR [rcx+rax+16], xmm1
	movups	xmm1, XMMWORD PTR [rsi+48]
	movups	XMMWORD PTR [rcx+rax+32], xmm0
	movups	xmm0, XMMWORD PTR [rsi+64]
	movups	XMMWORD PTR [rcx+rax+48], xmm1
	movups	xmm1, XMMWORD PTR [rsi+80]
	movups	XMMWORD PTR [rcx+rax+64], xmm0
	movups	xmm0, XMMWORD PTR [rsi+96]
	movups	XMMWORD PTR [rcx+rax+80], xmm1
	movups	xmm1, XMMWORD PTR [rsi+112]
	movups	XMMWORD PTR [rcx+rax+96], xmm0
	movsd	xmm0, QWORD PTR [rsi+128]
	movups	XMMWORD PTR [rcx+rax+112], xmm1
	movsd	QWORD PTR [rcx+rax+128], xmm0
	movsxd	rcx, DWORD PTR [rbx+120]

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	imul	rdi, rcx, 136				; 00000088H

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	lea	eax, DWORD PTR [rcx+1]
	mov	DWORD PTR [rbx+120], eax

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	add	rdi, QWORD PTR [rbx+128]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2145 :     if (new_font_cfg.DstFont == NULL)

	cmp	QWORD PTR [rdi+128], 0
	jne	SHORT $LN4@AddFont
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	movsxd	rcx, DWORD PTR [rbp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2146 :         new_font_cfg.DstFont = Fonts.back();

	mov	rax, QWORD PTR [rbp+8]
	mov	rcx, QWORD PTR [rax+rcx*8-8]
	mov	QWORD PTR [rdi+128], rcx
$LN4@AddFont:

; 2147 :     if (!new_font_cfg.FontDataOwnedByAtlas)

	cmp	BYTE PTR [rdi+12], 0
	mov	rbp, QWORD PTR [rsp+72]
	jne	SHORT $LN5@AddFont
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2149 :         new_font_cfg.FontData = IM_ALLOC(new_font_cfg.FontDataSize);

	movsxd	rcx, DWORD PTR [rdi+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN57@AddFont

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN57@AddFont:

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2151 :         memcpy(new_font_cfg.FontData, font_cfg->FontData, (size_t)new_font_cfg.FontDataSize);

	movsxd	r8, DWORD PTR [rdi+8]
	mov	rcx, rax
	mov	rdx, QWORD PTR [rsi]
	mov	QWORD PTR [rdi], rax
	mov	BYTE PTR [rdi+12], 1
	call	memcpy
$LN5@AddFont:

; 2152 :     }
; 2153 : 
; 2154 :     if (new_font_cfg.DstFont->EllipsisChar == (ImWchar)-1)

	mov	rcx, QWORD PTR [rdi+128]
	cmp	WORD PTR [rcx+84], r15w
	mov	r15, QWORD PTR [rsp+88]
	jne	SHORT $LN6@AddFont

; 2155 :         new_font_cfg.DstFont->EllipsisChar = font_cfg->EllipsisChar;

	movzx	eax, WORD PTR [rsi+84]
	mov	WORD PTR [rcx+84], ax
$LN6@AddFont:

; 2156 : 
; 2157 :     // Invalidate texture
; 2158 :     TexReady = false;
; 2159 :     ClearTexData();

	mov	rcx, rbx
	mov	BYTE PTR [rbx+40], 0
	call	?ClearTexData@ImFontAtlas@@QEAAXXZ	; ImFontAtlas::ClearTexData

; 2160 :     return new_font_cfg.DstFont;

	mov	rax, QWORD PTR [rdi+128]

; 2161 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z ENDP ; ImFontAtlas::AddFont
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?Decode85Byte@@YAID@Z
_TEXT	SEGMENT
c$ = 8
?Decode85Byte@@YAID@Z PROC				; Decode85Byte, COMDAT

; 2167 : static unsigned int Decode85Byte(char c)                                    { return c >= '\\' ? c-36 : c-35; }

	xor	edx, edx
	movsx	eax, cl
	cmp	cl, 92					; 0000005cH
	setge	dl
	add	edx, 35					; 00000023H
	sub	eax, edx
	ret	0
?Decode85Byte@@YAID@Z ENDP				; Decode85Byte
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?Decode85@@YAXPEBEPEAE@Z
_TEXT	SEGMENT
src$ = 8
dst$ = 16
?Decode85@@YAXPEBEPEAE@Z PROC				; Decode85, COMDAT

; 2169 : {

	mov	QWORD PTR [rsp+8], rbx

; 2170 :     while (*src)

	movzx	ebx, BYTE PTR [rcx]
	test	bl, bl
	je	$LN3@Decode85
	lea	r11, QWORD PTR [rdx+2]
	lea	r10, QWORD PTR [rcx+2]
	npad	8
$LL2@Decode85:

; 2171 :     {
; 2172 :         unsigned int tmp = Decode85Byte(src[0]) + 85 * (Decode85Byte(src[1]) + 85 * (Decode85Byte(src[2]) + 85 * (Decode85Byte(src[3]) + 85 * Decode85Byte(src[4]))));

	movsx	edx, BYTE PTR [r10+1]
	xor	ecx, ecx
	movsx	eax, BYTE PTR [r10+2]

; 2173 :         dst[0] = ((tmp >> 0) & 0xFF); dst[1] = ((tmp >> 8) & 0xFF); dst[2] = ((tmp >> 16) & 0xFF); dst[3] = ((tmp >> 24) & 0xFF);   // We can't assume little-endianness.
; 2174 :         src += 5;
; 2175 :         dst += 4;

	lea	r11, QWORD PTR [r11+4]
	movsx	r8d, BYTE PTR [r10]
	cmp	al, 92					; 0000005cH
	movsx	r9d, BYTE PTR [r10-1]
	lea	r10, QWORD PTR [r10+5]
	setge	cl
	add	ecx, 35					; 00000023H
	sub	eax, ecx
	imul	ecx, eax, 85				; 00000055H
	xor	eax, eax
	cmp	dl, 92					; 0000005cH
	setge	al
	add	eax, 35					; 00000023H
	sub	ecx, eax
	xor	eax, eax
	add	ecx, edx
	imul	edx, ecx, 85				; 00000055H
	cmp	r8b, 92					; 0000005cH
	setge	al
	add	eax, 35					; 00000023H
	sub	edx, eax
	xor	eax, eax
	add	edx, r8d
	imul	ecx, edx, 85				; 00000055H
	cmp	r9b, 92					; 0000005cH
	setge	al
	add	eax, 35					; 00000023H
	sub	ecx, eax
	xor	eax, eax
	add	ecx, r9d
	imul	edx, ecx, 85				; 00000055H
	cmp	bl, 92					; 0000005cH
	setge	al
	add	eax, 35					; 00000023H
	sub	edx, eax
	movsx	eax, bl
	add	edx, eax
	mov	BYTE PTR [r11-6], dl
	mov	eax, edx
	shr	eax, 8
	mov	BYTE PTR [r11-5], al
	mov	eax, edx
	shr	eax, 16
	shr	edx, 24
	mov	BYTE PTR [r11-4], al
	mov	BYTE PTR [r11-3], dl
	movzx	ebx, BYTE PTR [r10-2]
	test	bl, bl
	jne	$LL2@Decode85
$LN3@Decode85:

; 2176 :     }
; 2177 : }

	mov	rbx, QWORD PTR [rsp+8]
	ret	0
?Decode85@@YAXPEBEPEAE@Z ENDP				; Decode85
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?AddFontDefault@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z
_TEXT	SEGMENT
$T1 = 48
font_cfg$ = 192
__$ArrayPad$ = 336
this$ = 368
font_cfg_template$dead$ = 376
?AddFontDefault@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z PROC ; ImFontAtlas::AddFontDefault, COMDAT

; 2181 : {

$LN19:
	mov	QWORD PTR [rsp+16], rbx
	push	rbp
	lea	rbp, QWORD PTR [rsp-96]
	sub	rsp, 352				; 00000160H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	xorps	xmm2, xmm2

; 1969 :     memset(this, 0, sizeof(*this));

	xor	eax, eax
	movups	XMMWORD PTR $T1[rsp+16], xmm2
	mov	QWORD PTR $T1[rbp-128], rax

; 1975 :     EllipsisChar = (ImWchar)-1;

	mov	eax, 65535				; 0000ffffH
	movups	XMMWORD PTR $T1[rbp-176], xmm2
	mov	DWORD PTR $T1[rsp+24], 2

; 2181 : {

	mov	rbx, rcx

; 1969 :     memset(this, 0, sizeof(*this));

	movups	XMMWORD PTR $T1[rsp], xmm2

; 1970 :     FontDataOwnedByAtlas = true;

	mov	BYTE PTR $T1[rsp+12], 1

; 2182 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

	movaps	xmm0, XMMWORD PTR $T1[rsp]

; 1969 :     memset(this, 0, sizeof(*this));

	movups	XMMWORD PTR $T1[rsp+64], xmm2

; 1973 :     GlyphMaxAdvanceX = FLT_MAX;

	mov	DWORD PTR $T1[rsp+68], 2139095039	; 7f7fffffH

; 2182 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

	movaps	XMMWORD PTR font_cfg$[rbp-256], xmm0
	movaps	xmm0, XMMWORD PTR $T1[rsp+64]
	movaps	XMMWORD PTR font_cfg$[rbp-192], xmm0
	movsd	xmm0, QWORD PTR $T1[rbp-128]
	movaps	XMMWORD PTR font_cfg$[rbp-224], xmm2

; 1972 :     OversampleV = 1;

	mov	DWORD PTR $T1[rsp+28], 1

; 2182 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

	movaps	xmm1, XMMWORD PTR $T1[rsp+16]
	movaps	XMMWORD PTR font_cfg$[rbp-240], xmm1
	movsd	QWORD PTR font_cfg$[rbp-128], xmm0
	xorps	xmm0, xmm0
	movaps	XMMWORD PTR font_cfg$[rbp-208], xmm2
	movaps	XMMWORD PTR font_cfg$[rbp-160], xmm2
	movaps	XMMWORD PTR font_cfg$[rbp-144], xmm2

; 2187 :     }
; 2188 :     if (font_cfg.SizePixels <= 0.0f)

	movss	xmm2, DWORD PTR font_cfg$[rbp-236]
	comiss	xmm0, xmm2

; 1974 :     RasterizerMultiply = 1.0f;

	mov	DWORD PTR $T1[rbp-176], 1065353216	; 3f800000H

; 1975 :     EllipsisChar = (ImWchar)-1;

	mov	WORD PTR $T1[rbp-172], ax

; 2183 :     if (!font_cfg_template)
; 2184 :     {
; 2185 :         font_cfg.OversampleH = font_cfg.OversampleV = 1;

	mov	DWORD PTR font_cfg$[rbp-228], 1
	mov	DWORD PTR font_cfg$[rbp-232], 1

; 2186 :         font_cfg.PixelSnapH = true;

	mov	BYTE PTR font_cfg$[rbp-224], 1
	movaps	xmm1, XMMWORD PTR $T1[rbp-176]
	movaps	XMMWORD PTR font_cfg$[rbp-176], xmm1

; 2187 :     }
; 2188 :     if (font_cfg.SizePixels <= 0.0f)

	jb	SHORT $LN3@AddFontDef

; 2189 :         font_cfg.SizePixels = 13.0f * 1.0f;

	movss	xmm2, DWORD PTR __real@41500000
	movss	DWORD PTR font_cfg$[rbp-236], xmm2
$LN3@AddFontDef:

; 2190 :     if (font_cfg.Name[0] == '\0')

	psrldq	xmm1, 6
	movd	eax, xmm1
	test	al, al
	jne	SHORT $LN4@AddFontDef

; 2191 :         ImFormatString(font_cfg.Name, IM_ARRAYSIZE(font_cfg.Name), "ProggyClean.ttf, %dpx", (int)font_cfg.SizePixels);

	cvttss2si r9d, xmm2
	lea	r8, OFFSET FLAT:??_C@_0BG@CONABPA@ProggyClean?4ttf?0?5?$CFdpx@
	mov	edx, 40					; 00000028H
	lea	rcx, QWORD PTR font_cfg$[rbp-170]
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString
	movss	xmm2, DWORD PTR font_cfg$[rbp-236]
$LN4@AddFontDef:

; 2192 :     font_cfg.EllipsisChar = (ImWchar)0x0085;
; 2193 :     font_cfg.GlyphOffset.y = 1.0f * IM_FLOOR(font_cfg.SizePixels / 13.0f);  // Add +1 offset per 13 units

	movaps	xmm0, xmm2

; 2194 : 
; 2195 :     const char* ttf_compressed_base85 = GetDefaultCompressedFontDataTTFBase85();
; 2196 :     const ImWchar* glyph_ranges = font_cfg.GlyphRanges != NULL ? font_cfg.GlyphRanges : GetGlyphRangesDefault();

	lea	rdx, OFFSET FLAT:?ranges@?1??GetGlyphRangesDefault@ImFontAtlas@@QEAAPEBGXZ@4QBGB
	divss	xmm0, DWORD PTR __real@41500000
	mov	eax, 133				; 00000085H

; 2197 :     ImFont* font = AddFontFromMemoryCompressedBase85TTF(ttf_compressed_base85, font_cfg.SizePixels, &font_cfg, glyph_ranges);

	lea	r9, QWORD PTR font_cfg$[rbp-256]
	mov	WORD PTR font_cfg$[rbp-172], ax
	mov	rcx, rbx
	cvttss2si eax, xmm0
	movd	xmm0, eax
	mov	rax, QWORD PTR font_cfg$[rbp-200]
	test	rax, rax
	cvtdq2ps xmm0, xmm0
	cmovne	rdx, rax
	mov	QWORD PTR [rsp+32], rdx
	lea	rdx, OFFSET FLAT:?proggy_clean_ttf_compressed_data_base85@@3QBDB
	movss	DWORD PTR font_cfg$[rbp-208], xmm0
	call	?AddFontFromMemoryCompressedBase85TTF@ImFontAtlas@@QEAAPEAUImFont@@PEBDMPEBUImFontConfig@@PEBG@Z ; ImFontAtlas::AddFontFromMemoryCompressedBase85TTF

; 2198 :     return font;
; 2199 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+376]
	add	rsp, 352				; 00000160H
	pop	rbp
	ret	0
?AddFontDefault@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z ENDP ; ImFontAtlas::AddFontDefault
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?AddFontFromMemoryTTF@ImFontAtlas@@QEAAPEAUImFont@@PEAXHMPEBUImFontConfig@@PEBG@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
font_cfg$ = 176
this$ = 336
ttf_data$ = 344
ttf_size$ = 352
size_pixels$ = 360
font_cfg_template$ = 368
glyph_ranges$ = 376
?AddFontFromMemoryTTF@ImFontAtlas@@QEAAPEAUImFont@@PEAXHMPEBUImFontConfig@@PEBG@Z PROC ; ImFontAtlas::AddFontFromMemoryTTF, COMDAT

; 2224 : {

$LN16:
	push	rbp
	lea	rbp, QWORD PTR [rsp-64]
	sub	rsp, 320				; 00000140H

; 2225 :     IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
; 2226 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

	mov	rax, QWORD PTR font_cfg_template$[rbp-256]
	mov	r9, rcx
	test	rax, rax
	je	SHORT $LN4@AddFontFro
	movaps	xmm0, XMMWORD PTR [rax]
	movaps	xmm1, XMMWORD PTR [rax+16]
	movaps	XMMWORD PTR $T2[rsp], xmm0
	movaps	xmm0, XMMWORD PTR [rax+32]
	movaps	XMMWORD PTR $T2[rsp+32], xmm0
	movaps	xmm0, XMMWORD PTR [rax+64]
	movaps	XMMWORD PTR $T2[rsp+16], xmm1
	movaps	xmm1, XMMWORD PTR [rax+48]
	movaps	XMMWORD PTR $T2[rsp+64], xmm0
	movaps	xmm0, XMMWORD PTR [rax+96]
	movaps	XMMWORD PTR $T2[rsp+48], xmm1
	movaps	xmm1, XMMWORD PTR [rax+80]
	movaps	XMMWORD PTR $T2[rbp-160], xmm0
	movsd	xmm0, QWORD PTR [rax+128]
	movaps	XMMWORD PTR $T2[rsp+80], xmm1
	movaps	xmm1, XMMWORD PTR [rax+112]
	movsd	QWORD PTR $T2[rbp-128], xmm0
	movaps	XMMWORD PTR $T2[rbp-144], xmm1
	jmp	SHORT $LN14@AddFontFro
$LN4@AddFontFro:
	xorps	xmm0, xmm0

; 1969 :     memset(this, 0, sizeof(*this));

	xor	eax, eax
	movups	XMMWORD PTR $T1[rsp+16], xmm0
	mov	QWORD PTR $T1[rbp-128], rax

; 1970 :     FontDataOwnedByAtlas = true;
; 1971 :     OversampleH = 2;
; 1972 :     OversampleV = 1;
; 1973 :     GlyphMaxAdvanceX = FLT_MAX;
; 1974 :     RasterizerMultiply = 1.0f;
; 1975 :     EllipsisChar = (ImWchar)-1;

	mov	eax, 65535				; 0000ffffH
	movups	XMMWORD PTR $T1[rsp+80], xmm0
	mov	WORD PTR $T1[rsp+84], ax
	movups	XMMWORD PTR $T1[rsp], xmm0
	mov	BYTE PTR $T1[rsp+12], 1
	movups	XMMWORD PTR $T1[rsp+64], xmm0
	mov	DWORD PTR $T1[rsp+24], 2
	movups	XMMWORD PTR $T1[rsp+32], xmm0
	mov	DWORD PTR $T1[rsp+28], 1
	movups	XMMWORD PTR $T1[rsp+48], xmm0
	mov	DWORD PTR $T1[rsp+68], 2139095039	; 7f7fffffH
	movups	XMMWORD PTR $T1[rbp-160], xmm0
	mov	DWORD PTR $T1[rsp+80], 1065353216	; 3f800000H
	movups	XMMWORD PTR $T1[rbp-144], xmm0
$LN14@AddFontFro:

; 2225 :     IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
; 2226 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

	lea	rax, QWORD PTR $T1[rsp]
	movaps	xmm0, XMMWORD PTR [rax]
	movaps	xmm1, XMMWORD PTR [rax+16]
	movaps	XMMWORD PTR font_cfg$[rbp-256], xmm0
	movaps	xmm0, XMMWORD PTR [rax+32]
	movaps	XMMWORD PTR font_cfg$[rbp-224], xmm0
	movaps	xmm0, XMMWORD PTR [rax+64]
	movaps	XMMWORD PTR font_cfg$[rbp-192], xmm0
	movaps	xmm0, XMMWORD PTR [rax+96]
	movaps	XMMWORD PTR font_cfg$[rbp-240], xmm1
	movaps	xmm1, XMMWORD PTR [rax+48]
	movaps	XMMWORD PTR font_cfg$[rbp-160], xmm0
	movsd	xmm0, QWORD PTR [rax+128]
	movaps	XMMWORD PTR font_cfg$[rbp-208], xmm1
	movaps	xmm1, XMMWORD PTR [rax+80]
	movsd	QWORD PTR font_cfg$[rbp-128], xmm0
	xorps	xmm0, xmm0

; 2227 :     IM_ASSERT(font_cfg.FontData == NULL);
; 2228 :     font_cfg.FontData = ttf_data;
; 2229 :     font_cfg.FontDataSize = ttf_size;
; 2230 :     font_cfg.SizePixels = size_pixels > 0.0f ? size_pixels : font_cfg.SizePixels;

	comiss	xmm3, xmm0
	mov	QWORD PTR font_cfg$[rbp-256], rdx
	mov	DWORD PTR font_cfg$[rbp-248], r8d
	movaps	XMMWORD PTR font_cfg$[rbp-176], xmm1
	movaps	xmm1, XMMWORD PTR [rax+112]
	movaps	XMMWORD PTR font_cfg$[rbp-144], xmm1
	jbe	SHORT $LN6@AddFontFro
	movss	DWORD PTR font_cfg$[rbp-236], xmm3
$LN6@AddFontFro:

; 2231 :     if (glyph_ranges)

	mov	rax, QWORD PTR glyph_ranges$[rbp-256]

; 2232 :         font_cfg.GlyphRanges = glyph_ranges;
; 2233 :     return AddFont(&font_cfg);

	lea	rdx, QWORD PTR font_cfg$[rbp-256]
	mov	rcx, QWORD PTR font_cfg$[rbp-200]
	test	rax, rax
	cmovne	rcx, rax
	mov	QWORD PTR font_cfg$[rbp-200], rcx
	mov	rcx, r9
	call	?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z ; ImFontAtlas::AddFont

; 2234 : }

	add	rsp, 320				; 00000140H
	pop	rbp
	ret	0
?AddFontFromMemoryTTF@ImFontAtlas@@QEAAPEAUImFont@@PEAXHMPEBUImFontConfig@@PEBG@Z ENDP ; ImFontAtlas::AddFontFromMemoryTTF
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z
_TEXT	SEGMENT
font_cfg$1 = 32
$T2 = 32
$T3 = 176
font_cfg$ = 320
this$ = 560
compressed_ttf_data$ = 568
compressed_ttf_size$dead$ = 576
size_pixels$ = 584
font_cfg_template$ = 592
glyph_ranges$ = 600
?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z PROC ; ImFontAtlas::AddFontFromMemoryCompressedTTF, COMDAT

; 2237 : {

$LN64:
	mov	rax, rsp
	push	rbp
	push	r15
	lea	rbp, QWORD PTR [rax-296]
	sub	rsp, 536				; 00000218H
	movaps	XMMWORD PTR [rax-88], xmm9
	mov	r15, rcx
	mov	QWORD PTR [rax+8], rbx
	movaps	xmm9, xmm3
	mov	QWORD PTR [rax+16], rsi
	mov	rbx, rdx

; 4045 :     return (input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11];

	movzx	esi, BYTE PTR [rdx+10]

; 2237 : {

	mov	QWORD PTR [rax-24], r14
	movaps	XMMWORD PTR [rax-40], xmm6
	movaps	XMMWORD PTR [rax-56], xmm7
	movaps	XMMWORD PTR [rax-72], xmm8

; 4045 :     return (input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11];

	movzx	eax, BYTE PTR [rdx+9]
	shl	eax, 16
	shl	esi, 8
	add	esi, eax
	movzx	eax, BYTE PTR [rdx+8]
	shl	eax, 24
	add	esi, eax
	movzx	eax, BYTE PTR [rdx+11]
	add	esi, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN8@AddFontFro

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN8@AddFontFro:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2239 :     unsigned char* buf_decompressed_data = (unsigned char*)IM_ALLOC(buf_decompressed_size);

	mov	ecx, esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 4123 :     if (stb__in4(0) != 0x57bC0000) return 0;

	movzx	ecx, BYTE PTR [rbx+1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	mov	r14, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 4123 :     if (stb__in4(0) != 0x57bC0000) return 0;

	movzx	edx, BYTE PTR [rbx]
	shl	edx, 8
	add	edx, ecx
	movzx	ecx, BYTE PTR [rbx+2]
	shl	edx, 8
	add	edx, ecx
	movzx	ecx, BYTE PTR [rbx+3]
	shl	edx, 8
	add	edx, ecx
	cmp	edx, 1471938560				; 57bc0000H
	jne	$LN54@AddFontFro

; 4124 :     if (stb__in4(4) != 0)          return 0; // error! stream is > 4GB

	movzx	eax, BYTE PTR [rbx+5]
	movzx	ecx, BYTE PTR [rbx+4]
	shl	ecx, 8
	add	ecx, eax
	movzx	eax, BYTE PTR [rbx+6]
	shl	ecx, 8
	add	ecx, eax
	movzx	eax, BYTE PTR [rbx+7]
	shl	ecx, 8
	add	ecx, eax
	jne	$LN54@AddFontFro

; 4125 :     const unsigned int olen = stb_decompress_length(i);
; 4126 :     stb__barrier_in_b = i;
; 4127 :     stb__barrier_out_e = output + olen;

	movzx	eax, BYTE PTR [rbx+9]
	movzx	edx, BYTE PTR [rbx+8]
	shl	rdx, 8
	add	rdx, rax
	mov	QWORD PTR [rsp+576], rdi
	movzx	eax, BYTE PTR [rbx+10]
	movzx	edi, BYTE PTR [rbx+11]
	shl	rdx, 8
	add	rax, rdx
	mov	QWORD PTR ?stb__barrier_in_b@@3PEBEEB, rbx
	shl	rax, 8

; 4128 :     stb__barrier_out_b = output;
; 4129 :     i += 16;

	add	rbx, 16
	add	rax, r14
	mov	QWORD PTR ?stb__barrier_out_b@@3PEAEEA, r14
	add	rdi, rax

; 4130 : 
; 4131 :     stb__dout = output;

	mov	QWORD PTR ?stb__dout@@3PEAEEA, r14

; 4134 :         i = stb_decompress_token(i);

	mov	rcx, rbx
	mov	QWORD PTR ?stb__barrier_out_e@@3PEAEEA, rdi
	call	?stb_decompress_token@@YAPEBEPEBE@Z	; stb_decompress_token

; 4135 :         if (i == old_i) {

	cmp	rax, rbx
	je	SHORT $LN62@AddFontFro
$LL15@AddFontFro:

; 4136 :             if (*i == 0x05 && i[1] == 0xfa) {
; 4137 :                 IM_ASSERT(stb__dout == output + olen);
; 4138 :                 if (stb__dout != output + olen) return 0;
; 4139 :                 if (stb_adler32(1, output, olen) != (unsigned int) stb__in4(2))
; 4140 :                     return 0;
; 4141 :                 return olen;
; 4142 :             } else {
; 4143 :                 IM_ASSERT(0); /* NOTREACHED */
; 4144 :                 return 0;
; 4145 :             }
; 4146 :         }
; 4147 :         IM_ASSERT(stb__dout <= output + olen);
; 4148 :         if (stb__dout > output + olen)

	cmp	QWORD PTR ?stb__dout@@3PEAEEA, rdi
	ja	SHORT $LN62@AddFontFro

; 4132 :     for (;;) {
; 4133 :         const unsigned char *old_i = i;

	mov	rcx, rax
	mov	rbx, rax

; 4134 :         i = stb_decompress_token(i);

	call	?stb_decompress_token@@YAPEBEPEBE@Z	; stb_decompress_token

; 4135 :         if (i == old_i) {

	cmp	rax, rbx
	jne	SHORT $LL15@AddFontFro
$LN62@AddFontFro:
	mov	rdi, QWORD PTR [rsp+576]
$LN54@AddFontFro:

; 2240 :     stb_decompress(buf_decompressed_data, (const unsigned char*)compressed_ttf_data, (unsigned int)compressed_ttf_size);
; 2241 : 
; 2242 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

	mov	rax, QWORD PTR font_cfg_template$[rbp-256]
	mov	rbx, QWORD PTR [rsp+560]
	test	rax, rax
	je	SHORT $LN3@AddFontFro
	movaps	xmm0, XMMWORD PTR [rax]
	movaps	xmm1, XMMWORD PTR [rax+16]
	movaps	XMMWORD PTR $T3[rbp-256], xmm0
	movaps	xmm0, XMMWORD PTR [rax+32]
	movaps	XMMWORD PTR $T3[rbp-224], xmm0
	movaps	xmm0, XMMWORD PTR [rax+64]
	movaps	XMMWORD PTR $T3[rbp-240], xmm1
	movaps	xmm1, XMMWORD PTR [rax+48]
	movaps	XMMWORD PTR $T3[rbp-192], xmm0
	movaps	xmm0, XMMWORD PTR [rax+96]
	movaps	XMMWORD PTR $T3[rbp-208], xmm1
	movaps	xmm1, XMMWORD PTR [rax+80]
	movaps	XMMWORD PTR $T3[rbp-160], xmm0
	movsd	xmm0, QWORD PTR [rax+128]
	movaps	XMMWORD PTR $T3[rbp-176], xmm1
	movaps	xmm1, XMMWORD PTR [rax+112]
	lea	rax, QWORD PTR $T3[rbp-256]
	movsd	QWORD PTR $T3[rbp-128], xmm0
	movaps	XMMWORD PTR $T3[rbp-144], xmm1
	jmp	SHORT $LN4@AddFontFro
$LN3@AddFontFro:
	xorps	xmm0, xmm0

; 1969 :     memset(this, 0, sizeof(*this));

	xor	eax, eax
	mov	QWORD PTR $T2[rbp-128], rax

; 1975 :     EllipsisChar = (ImWchar)-1;

	mov	eax, 65535				; 0000ffffH
	movups	XMMWORD PTR $T2[rsp+80], xmm0
	mov	WORD PTR $T2[rsp+84], ax

; 2240 :     stb_decompress(buf_decompressed_data, (const unsigned char*)compressed_ttf_data, (unsigned int)compressed_ttf_size);
; 2241 : 
; 2242 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

	lea	rax, QWORD PTR $T2[rsp]

; 1969 :     memset(this, 0, sizeof(*this));

	movups	XMMWORD PTR $T2[rsp+16], xmm0

; 1970 :     FontDataOwnedByAtlas = true;
; 1971 :     OversampleH = 2;

	mov	DWORD PTR $T2[rsp+24], 2
	movups	XMMWORD PTR $T2[rsp], xmm0
	mov	BYTE PTR $T2[rsp+12], 1
	movups	XMMWORD PTR $T2[rsp+64], xmm0

; 1972 :     OversampleV = 1;

	mov	DWORD PTR $T2[rsp+28], 1
	movups	XMMWORD PTR $T2[rsp+32], xmm0

; 1973 :     GlyphMaxAdvanceX = FLT_MAX;

	mov	DWORD PTR $T2[rsp+68], 2139095039	; 7f7fffffH
	movups	XMMWORD PTR $T2[rsp+48], xmm0

; 1974 :     RasterizerMultiply = 1.0f;

	mov	DWORD PTR $T2[rsp+80], 1065353216	; 3f800000H
	movups	XMMWORD PTR $T2[rbp-160], xmm0
	movups	XMMWORD PTR $T2[rbp-144], xmm0
$LN4@AddFontFro:

; 2240 :     stb_decompress(buf_decompressed_data, (const unsigned char*)compressed_ttf_data, (unsigned int)compressed_ttf_size);
; 2241 : 
; 2242 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

	movaps	xmm0, XMMWORD PTR [rax]
	movaps	xmm6, XMMWORD PTR [rax+80]
	movaps	xmm7, XMMWORD PTR [rax+96]
	movaps	xmm8, XMMWORD PTR [rax+112]
	movaps	xmm2, XMMWORD PTR [rax+16]
	movaps	xmm3, XMMWORD PTR [rax+32]
	movaps	xmm4, XMMWORD PTR [rax+48]
	movaps	xmm5, XMMWORD PTR [rax+64]
	movsd	xmm1, QWORD PTR [rax+128]
	movaps	XMMWORD PTR font_cfg$[rbp-256], xmm0

; 2243 :     IM_ASSERT(font_cfg.FontData == NULL);
; 2244 :     font_cfg.FontDataOwnedByAtlas = true;

	mov	BYTE PTR font_cfg$[rbp-244], 1

; 2226 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

	movaps	xmm0, XMMWORD PTR font_cfg$[rbp-256]
	movaps	XMMWORD PTR font_cfg$1[rsp], xmm0
	xorps	xmm0, xmm0

; 2227 :     IM_ASSERT(font_cfg.FontData == NULL);
; 2228 :     font_cfg.FontData = ttf_data;
; 2229 :     font_cfg.FontDataSize = ttf_size;
; 2230 :     font_cfg.SizePixels = size_pixels > 0.0f ? size_pixels : font_cfg.SizePixels;

	comiss	xmm9, xmm0
	mov	QWORD PTR font_cfg$1[rsp], r14
	mov	r14, QWORD PTR [rsp+528]
	mov	DWORD PTR font_cfg$1[rsp+8], esi
	mov	rsi, QWORD PTR [rsp+568]
	movaps	XMMWORD PTR font_cfg$1[rsp+80], xmm6
	movaps	xmm6, XMMWORD PTR [rsp+512]
	movaps	XMMWORD PTR font_cfg$1[rbp-160], xmm7
	movaps	xmm7, XMMWORD PTR [rsp+496]
	movaps	XMMWORD PTR font_cfg$1[rbp-144], xmm8
	movaps	xmm8, XMMWORD PTR [rsp+480]
	movaps	XMMWORD PTR font_cfg$1[rsp+16], xmm2
	movaps	XMMWORD PTR font_cfg$1[rsp+32], xmm3
	movaps	XMMWORD PTR font_cfg$1[rsp+48], xmm4
	movaps	XMMWORD PTR font_cfg$1[rsp+64], xmm5
	movsd	QWORD PTR font_cfg$1[rbp-128], xmm1
	jbe	SHORT $LN40@AddFontFro
	movss	DWORD PTR font_cfg$1[rsp+20], xmm9
$LN40@AddFontFro:

; 2231 :     if (glyph_ranges)

	mov	rax, QWORD PTR glyph_ranges$[rbp-256]

; 2232 :         font_cfg.GlyphRanges = glyph_ranges;
; 2233 :     return AddFont(&font_cfg);

	lea	rdx, QWORD PTR font_cfg$1[rsp]
	mov	rcx, QWORD PTR font_cfg$1[rsp+56]
	test	rax, rax
	cmovne	rcx, rax
	mov	QWORD PTR font_cfg$1[rsp+56], rcx
	mov	rcx, r15
	call	?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z ; ImFontAtlas::AddFont

; 2245 :     return AddFontFromMemoryTTF(buf_decompressed_data, (int)buf_decompressed_size, size_pixels, &font_cfg, glyph_ranges);
; 2246 : }

	movaps	xmm9, XMMWORD PTR [rsp+464]
	add	rsp, 536				; 00000218H
	pop	r15
	pop	rbp
	ret	0
?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z ENDP ; ImFontAtlas::AddFontFromMemoryCompressedTTF
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?AddFontFromMemoryCompressedBase85TTF@ImFontAtlas@@QEAAPEAUImFont@@PEBDMPEBUImFontConfig@@PEBG@Z
_TEXT	SEGMENT
this$ = 80
compressed_ttf_data_base85$ = 88
size_pixels$ = 96
font_cfg$ = 104
glyph_ranges$ = 112
?AddFontFromMemoryCompressedBase85TTF@ImFontAtlas@@QEAAPEAUImFont@@PEBDMPEBUImFontConfig@@PEBG@Z PROC ; ImFontAtlas::AddFontFromMemoryCompressedBase85TTF, COMDAT

; 2249 : {

$LN53:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 64					; 00000040H
	movaps	XMMWORD PTR [rsp+48], xmm6
	mov	rsi, r9
	movaps	xmm6, xmm2
	mov	rbx, rdx
	mov	rbp, rcx

; 2250 :     int compressed_ttf_size = (((int)strlen(compressed_ttf_data_base85) + 4) / 5) * 4;

	mov	r8, -1
	npad	4
$LL46@AddFontFro:
	inc	r8
	cmp	BYTE PTR [rdx+r8], 0
	jne	SHORT $LL46@AddFontFro
	add	r8d, 4
	mov	eax, 1717986919				; 66666667H
	imul	r8d
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2250 :     int compressed_ttf_size = (((int)strlen(compressed_ttf_data_base85) + 4) / 5) * 4;

	shl	edx, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN4@AddFontFro

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN4@AddFontFro:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2251 :     void* compressed_ttf = IM_ALLOC((size_t)compressed_ttf_size);

	movsxd	rcx, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2170 :     while (*src)

	movzx	r11d, BYTE PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	mov	rdi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2170 :     while (*src)

	test	r11b, r11b
	je	$LN12@AddFontFro
	lea	r10, QWORD PTR [rax+2]
	add	rbx, 2
	npad	11
$LL11@AddFontFro:

; 2171 :     {
; 2172 :         unsigned int tmp = Decode85Byte(src[0]) + 85 * (Decode85Byte(src[1]) + 85 * (Decode85Byte(src[2]) + 85 * (Decode85Byte(src[3]) + 85 * Decode85Byte(src[4]))));

	movsx	edx, BYTE PTR [rbx+1]
	xor	ecx, ecx
	movsx	eax, BYTE PTR [rbx+2]

; 2173 :         dst[0] = ((tmp >> 0) & 0xFF); dst[1] = ((tmp >> 8) & 0xFF); dst[2] = ((tmp >> 16) & 0xFF); dst[3] = ((tmp >> 24) & 0xFF);   // We can't assume little-endianness.
; 2174 :         src += 5;
; 2175 :         dst += 4;

	lea	r10, QWORD PTR [r10+4]
	movsx	r8d, BYTE PTR [rbx]
	cmp	al, 92					; 0000005cH
	movsx	r9d, BYTE PTR [rbx-1]
	lea	rbx, QWORD PTR [rbx+5]
	setge	cl
	add	ecx, 35					; 00000023H
	sub	eax, ecx
	imul	ecx, eax, 85				; 00000055H
	xor	eax, eax
	cmp	dl, 92					; 0000005cH
	setge	al
	add	eax, 35					; 00000023H
	sub	ecx, eax
	xor	eax, eax
	add	ecx, edx
	imul	edx, ecx, 85				; 00000055H
	cmp	r8b, 92					; 0000005cH
	setge	al
	add	eax, 35					; 00000023H
	sub	edx, eax
	xor	eax, eax
	add	edx, r8d
	imul	ecx, edx, 85				; 00000055H
	cmp	r9b, 92					; 0000005cH
	setge	al
	add	eax, 35					; 00000023H
	sub	ecx, eax
	xor	eax, eax
	add	ecx, r9d
	imul	edx, ecx, 85				; 00000055H
	cmp	r11b, 92				; 0000005cH
	setge	al
	add	eax, 35					; 00000023H
	sub	edx, eax
	movsx	eax, r11b
	add	edx, eax
	mov	BYTE PTR [r10-6], dl
	mov	eax, edx
	shr	eax, 8
	mov	BYTE PTR [r10-5], al
	mov	eax, edx
	shr	eax, 16
	shr	edx, 24
	mov	BYTE PTR [r10-4], al
	mov	BYTE PTR [r10-3], dl
	movzx	r11d, BYTE PTR [rbx-2]
	test	r11b, r11b
	jne	$LL11@AddFontFro
$LN12@AddFontFro:

; 2252 :     Decode85((const unsigned char*)compressed_ttf_data_base85, (unsigned char*)compressed_ttf);
; 2253 :     ImFont* font = AddFontFromMemoryCompressedTTF(compressed_ttf, compressed_ttf_size, size_pixels, font_cfg, glyph_ranges);

	mov	rax, QWORD PTR glyph_ranges$[rsp]
	movaps	xmm3, xmm6
	mov	QWORD PTR [rsp+40], rax
	mov	rdx, rdi
	mov	rcx, rbp
	mov	QWORD PTR [rsp+32], rsi
	call	?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z ; ImFontAtlas::AddFontFromMemoryCompressedTTF
	mov	rbx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	test	rdi, rdi
	je	SHORT $LN36@AddFontFro

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rcx, rcx
	je	SHORT $LN36@AddFontFro

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rcx+244]
$LN36@AddFontFro:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	mov	rcx, rdi
	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2256 : }

	mov	rbp, QWORD PTR [rsp+88]
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+96]
	movaps	xmm6, XMMWORD PTR [rsp+48]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?AddFontFromMemoryCompressedBase85TTF@ImFontAtlas@@QEAAPEAUImFont@@PEBDMPEBUImFontConfig@@PEBG@Z ENDP ; ImFontAtlas::AddFontFromMemoryCompressedBase85TTF
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?AddCustomRectRegular@ImFontAtlas@@QEAAHHH@Z
_TEXT	SEGMENT
r$ = 32
this$ = 80
width$ = 88
height$ = 96
?AddCustomRectRegular@ImFontAtlas@@QEAAHHH@Z PROC	; ImFontAtlas::AddCustomRectRegular, COMDAT

; 2259 : {

$LN10:
	push	rbx
	sub	rsp, 64					; 00000040H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2950 :     ImFontAtlasCustomRect()         { Width = Height = 0; X = Y = 0xFFFF; GlyphID = 0; GlyphAdvanceX = 0.0f; GlyphOffset = ImVec2(0, 0); Font = NULL; }

	xor	eax, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2263 :     r.Width = (unsigned short)width;

	mov	WORD PTR r$[rsp], dx

; 2265 :     CustomRects.push_back(r);

	lea	rbx, QWORD PTR [rcx+104]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2950 :     ImFontAtlasCustomRect()         { Width = Height = 0; X = Y = 0xFFFF; GlyphID = 0; GlyphAdvanceX = 0.0f; GlyphOffset = ImVec2(0, 0); Font = NULL; }

	mov	DWORD PTR r$[rsp+4], -1			; ffffffffH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2265 :     CustomRects.push_back(r);

	mov	rcx, rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2950 :     ImFontAtlasCustomRect()         { Width = Height = 0; X = Y = 0xFFFF; GlyphID = 0; GlyphAdvanceX = 0.0f; GlyphOffset = ImVec2(0, 0); Font = NULL; }

	mov	QWORD PTR r$[rsp+8], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2265 :     CustomRects.push_back(r);

	lea	rdx, QWORD PTR r$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2950 :     ImFontAtlasCustomRect()         { Width = Height = 0; X = Y = 0xFFFF; GlyphID = 0; GlyphAdvanceX = 0.0f; GlyphOffset = ImVec2(0, 0); Font = NULL; }

	mov	QWORD PTR r$[rsp+16], rax
	mov	QWORD PTR r$[rsp+24], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2264 :     r.Height = (unsigned short)height;

	mov	WORD PTR r$[rsp+2], r8w

; 2265 :     CustomRects.push_back(r);

	call	?push_back@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXAEBUImFontAtlasCustomRect@@@Z ; ImVector<ImFontAtlasCustomRect>::push_back

; 2266 :     return CustomRects.Size - 1; // Return index

	mov	eax, DWORD PTR [rbx]
	dec	eax

; 2267 : }

	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
?AddCustomRectRegular@ImFontAtlas@@QEAAHHH@Z ENDP	; ImFontAtlas::AddCustomRectRegular
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?CalcCustomRectUV@ImFontAtlas@@QEBAXPEBUImFontAtlasCustomRect@@PEAUImVec2@@1@Z
_TEXT	SEGMENT
this$ = 8
rect$ = 16
out_uv_min$ = 24
out_uv_max$ = 32
?CalcCustomRectUV@ImFontAtlas@@QEBAXPEBUImFontAtlasCustomRect@@PEAUImVec2@@1@Z PROC ; ImFontAtlas::CalcCustomRectUV, COMDAT

; 2290 :     IM_ASSERT(TexWidth > 0 && TexHeight > 0);   // Font atlas needs to be built before we can calculate UV coordinates
; 2291 :     IM_ASSERT(rect->IsPacked());                // Make sure the rectangle has been packed
; 2292 :     *out_uv_min = ImVec2((float)rect->X * TexUvScale.x, (float)rect->Y * TexUvScale.y);

	movzx	eax, WORD PTR [rdx+4]
	mov	r10, rcx
	movd	xmm0, eax
	movzx	eax, WORD PTR [rdx+6]
	cvtdq2ps xmm0, xmm0
	movd	xmm1, eax
	mulss	xmm0, DWORD PTR [rcx+72]
	cvtdq2ps xmm1, xmm1
	mulss	xmm1, DWORD PTR [rcx+76]
	unpcklps xmm0, xmm1
	movsd	QWORD PTR [r8], xmm0

; 2293 :     *out_uv_max = ImVec2((float)(rect->X + rect->Width) * TexUvScale.x, (float)(rect->Y + rect->Height) * TexUvScale.y);

	movzx	eax, WORD PTR [rdx+4]
	movzx	ecx, WORD PTR [rdx]
	add	ecx, eax
	movzx	eax, WORD PTR [rdx+6]
	movd	xmm0, ecx
	movzx	ecx, WORD PTR [rdx+2]
	cvtdq2ps xmm0, xmm0
	add	ecx, eax
	movd	xmm1, ecx
	mulss	xmm0, DWORD PTR [r10+72]
	cvtdq2ps xmm1, xmm1
	mulss	xmm1, DWORD PTR [r10+76]
	unpcklps xmm0, xmm1
	movsd	QWORD PTR [r9], xmm0

; 2294 : }

	ret	0
?CalcCustomRectUV@ImFontAtlas@@QEBAXPEBUImFontAtlasCustomRect@@PEAUImVec2@@1@Z ENDP ; ImFontAtlas::CalcCustomRectUV
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?Build@ImFontAtlas@@QEAA_NXZ
_TEXT	SEGMENT
$T1 = 48
font_cfg$2 = 192
__$ArrayPad$ = 336
this$ = 368
?Build@ImFontAtlas@@QEAA_NXZ PROC			; ImFontAtlas::Build, COMDAT

; 2318 : {

$LN27:
	mov	QWORD PTR [rsp+16], rbx
	push	rbp
	lea	rbp, QWORD PTR [rsp-96]
	sub	rsp, 352				; 00000160H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax

; 2319 :     IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
; 2320 : 
; 2321 :     // Default font is none are specified
; 2322 :     if (ConfigData.Size == 0)

	cmp	DWORD PTR [rcx+120], 0
	mov	rbx, rcx
	jne	$LN2@Build
	xorps	xmm2, xmm2

; 1969 :     memset(this, 0, sizeof(*this));

	xor	eax, eax
	movups	XMMWORD PTR $T1[rsp+16], xmm2
	mov	QWORD PTR $T1[rbp-128], rax

; 1975 :     EllipsisChar = (ImWchar)-1;

	mov	eax, 65535				; 0000ffffH
	movups	XMMWORD PTR $T1[rbp-176], xmm2
	mov	DWORD PTR $T1[rsp+24], 2
	movups	XMMWORD PTR $T1[rsp], xmm2
	mov	BYTE PTR $T1[rsp+12], 1

; 2182 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

	movaps	xmm0, XMMWORD PTR $T1[rsp]

; 1969 :     memset(this, 0, sizeof(*this));

	movups	XMMWORD PTR $T1[rsp+64], xmm2

; 1973 :     GlyphMaxAdvanceX = FLT_MAX;

	mov	DWORD PTR $T1[rsp+68], 2139095039	; 7f7fffffH

; 2182 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

	movaps	XMMWORD PTR font_cfg$2[rbp-256], xmm0
	movaps	xmm0, XMMWORD PTR $T1[rsp+64]
	movaps	XMMWORD PTR font_cfg$2[rbp-192], xmm0
	movsd	xmm0, QWORD PTR $T1[rbp-128]
	movaps	XMMWORD PTR font_cfg$2[rbp-224], xmm2

; 1972 :     OversampleV = 1;

	mov	DWORD PTR $T1[rsp+28], 1

; 2182 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

	movaps	xmm1, XMMWORD PTR $T1[rsp+16]
	movaps	XMMWORD PTR font_cfg$2[rbp-240], xmm1
	movsd	QWORD PTR font_cfg$2[rbp-128], xmm0
	xorps	xmm0, xmm0
	movaps	XMMWORD PTR font_cfg$2[rbp-208], xmm2
	movaps	XMMWORD PTR font_cfg$2[rbp-160], xmm2
	movaps	XMMWORD PTR font_cfg$2[rbp-144], xmm2

; 2187 :     }
; 2188 :     if (font_cfg.SizePixels <= 0.0f)

	movss	xmm2, DWORD PTR font_cfg$2[rbp-236]
	comiss	xmm0, xmm2

; 1974 :     RasterizerMultiply = 1.0f;

	mov	DWORD PTR $T1[rbp-176], 1065353216	; 3f800000H

; 1975 :     EllipsisChar = (ImWchar)-1;

	mov	WORD PTR $T1[rbp-172], ax

; 2185 :         font_cfg.OversampleH = font_cfg.OversampleV = 1;

	mov	DWORD PTR font_cfg$2[rbp-228], 1
	mov	DWORD PTR font_cfg$2[rbp-232], 1

; 2186 :         font_cfg.PixelSnapH = true;

	mov	BYTE PTR font_cfg$2[rbp-224], 1
	movaps	xmm1, XMMWORD PTR $T1[rbp-176]
	movaps	XMMWORD PTR font_cfg$2[rbp-176], xmm1

; 2187 :     }
; 2188 :     if (font_cfg.SizePixels <= 0.0f)

	jb	SHORT $LN7@Build

; 2189 :         font_cfg.SizePixels = 13.0f * 1.0f;

	movss	xmm2, DWORD PTR __real@41500000
	movss	DWORD PTR font_cfg$2[rbp-236], xmm2
$LN7@Build:

; 2190 :     if (font_cfg.Name[0] == '\0')

	psrldq	xmm1, 6
	movd	eax, xmm1
	test	al, al
	jne	SHORT $LN8@Build

; 2191 :         ImFormatString(font_cfg.Name, IM_ARRAYSIZE(font_cfg.Name), "ProggyClean.ttf, %dpx", (int)font_cfg.SizePixels);

	cvttss2si r9d, xmm2
	lea	r8, OFFSET FLAT:??_C@_0BG@CONABPA@ProggyClean?4ttf?0?5?$CFdpx@
	mov	edx, 40					; 00000028H
	lea	rcx, QWORD PTR font_cfg$2[rbp-170]
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString
	movss	xmm2, DWORD PTR font_cfg$2[rbp-236]
$LN8@Build:

; 2192 :     font_cfg.EllipsisChar = (ImWchar)0x0085;
; 2193 :     font_cfg.GlyphOffset.y = 1.0f * IM_FLOOR(font_cfg.SizePixels / 13.0f);  // Add +1 offset per 13 units

	movaps	xmm0, xmm2

; 2194 : 
; 2195 :     const char* ttf_compressed_base85 = GetDefaultCompressedFontDataTTFBase85();
; 2196 :     const ImWchar* glyph_ranges = font_cfg.GlyphRanges != NULL ? font_cfg.GlyphRanges : GetGlyphRangesDefault();

	lea	rcx, OFFSET FLAT:?ranges@?1??GetGlyphRangesDefault@ImFontAtlas@@QEAAPEBGXZ@4QBGB
	divss	xmm0, DWORD PTR __real@41500000
	mov	eax, 133				; 00000085H

; 2197 :     ImFont* font = AddFontFromMemoryCompressedBase85TTF(ttf_compressed_base85, font_cfg.SizePixels, &font_cfg, glyph_ranges);

	lea	r9, QWORD PTR font_cfg$2[rbp-256]
	mov	WORD PTR font_cfg$2[rbp-172], ax
	lea	rdx, OFFSET FLAT:?proggy_clean_ttf_compressed_data_base85@@3QBDB
	cvttss2si eax, xmm0
	movd	xmm0, eax

; 2194 : 
; 2195 :     const char* ttf_compressed_base85 = GetDefaultCompressedFontDataTTFBase85();
; 2196 :     const ImWchar* glyph_ranges = font_cfg.GlyphRanges != NULL ? font_cfg.GlyphRanges : GetGlyphRangesDefault();

	mov	rax, QWORD PTR font_cfg$2[rbp-200]
	test	rax, rax
	cvtdq2ps xmm0, xmm0
	cmovne	rcx, rax

; 2197 :     ImFont* font = AddFontFromMemoryCompressedBase85TTF(ttf_compressed_base85, font_cfg.SizePixels, &font_cfg, glyph_ranges);

	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, rbx
	movss	DWORD PTR font_cfg$2[rbp-208], xmm0
	call	?AddFontFromMemoryCompressedBase85TTF@ImFontAtlas@@QEAAPEAUImFont@@PEBDMPEBUImFontConfig@@PEBG@Z ; ImFontAtlas::AddFontFromMemoryCompressedBase85TTF
$LN2@Build:

; 2323 :         AddFontDefault();
; 2324 : 
; 2325 :     // Select builder
; 2326 :     // - Note that we do not reassign to atlas->FontBuilderIO, since it is likely to point to static data which
; 2327 :     //   may mess with some hot-reloading schemes. If you need to assign to this (for dynamic selection) AND are
; 2328 :     //   using a hot-reloading scheme that messes up static data, store your own instance of ImFontBuilderIO somewhere
; 2329 :     //   and point to it instead of pointing directly to return value of the GetBuilderXXX functions.
; 2330 :     const ImFontBuilderIO* builder_io = FontBuilderIO;

	mov	rax, QWORD PTR [rbx+1160]

; 2331 :     if (builder_io == NULL)

	test	rax, rax
	jne	SHORT $LN3@Build

; 2659 :     io.FontBuilder_Build = ImFontAtlasBuildWithStbTruetype;

	lea	rax, OFFSET FLAT:?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z ; ImFontAtlasBuildWithStbTruetype
	mov	QWORD PTR ?io@?1??ImFontAtlasGetBuilderForStbTruetype@@YAPEBUImFontBuilderIO@@XZ@4U2@A, rax

; 2332 :     {
; 2333 : #ifdef IMGUI_ENABLE_FREETYPE
; 2334 :         builder_io = ImGuiFreeType::GetBuilderForFreeType();
; 2335 : #elif defined(IMGUI_ENABLE_STB_TRUETYPE)
; 2336 :         builder_io = ImFontAtlasGetBuilderForStbTruetype();

	lea	rax, OFFSET FLAT:?io@?1??ImFontAtlasGetBuilderForStbTruetype@@YAPEBUImFontBuilderIO@@XZ@4U2@A
$LN3@Build:

; 2337 : #else
; 2338 :         IM_ASSERT(0); // Invalid Build function
; 2339 : #endif
; 2340 :     }
; 2341 : 
; 2342 :     // Build
; 2343 :     return builder_io->FontBuilder_Build(this);

	mov	rax, QWORD PTR [rax]
	mov	rcx, rbx
	call	rax

; 2344 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+376]
	add	rsp, 352				; 00000160H
	pop	rbp
	ret	0
?Build@ImFontAtlas@@QEAA_NXZ ENDP			; ImFontAtlas::Build
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?ImFontAtlasBuildMultiplyCalcLookupTable@@YAXQEAEM@Z
_TEXT	SEGMENT
out_table$ = 8
in_brighten_factor$ = 16
?ImFontAtlasBuildMultiplyCalcLookupTable@@YAXQEAEM@Z PROC ; ImFontAtlasBuildMultiplyCalcLookupTable, COMDAT

; 2348 :     for (unsigned int i = 0; i < 256; i++)

	xor	r9d, r9d
	npad	13
$LL10@ImFontAtla:

; 2349 :     {
; 2350 :         unsigned int value = (unsigned int)(i * in_brighten_factor);

	mov	eax, r9d
	lea	rcx, QWORD PTR [rcx+1]
	xorps	xmm0, xmm0

; 2351 :         out_table[i] = value > 255 ? 255 : (value & 0xFF);

	mov	r8d, 255				; 000000ffH
	cvtsi2ss xmm0, rax
	mulss	xmm0, xmm1
	cvttss2si rdx, xmm0
	cmp	edx, r8d
	movzx	eax, dl
	cmovbe	r8d, eax
	inc	r9d
	mov	BYTE PTR [rcx-1], r8b
	cmp	r9d, 256				; 00000100H
	jb	SHORT $LL10@ImFontAtla

; 2352 :     }
; 2353 : }

	ret	0
?ImFontAtlasBuildMultiplyCalcLookupTable@@YAXQEAEM@Z ENDP ; ImFontAtlasBuildMultiplyCalcLookupTable
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?ImFontAtlasBuildMultiplyRectAlpha8@@YAXQEBEPEAEHHHHH@Z
_TEXT	SEGMENT
table$ = 16
pixels$ = 24
x$ = 32
y$ = 40
w$ = 48
h$ = 56
stride$ = 64
?ImFontAtlasBuildMultiplyRectAlpha8@@YAXQEBEPEAEHHHHH@Z PROC ; ImFontAtlasBuildMultiplyRectAlpha8, COMDAT

; 2356 : {

$LN20:
	sub	rsp, 8
	mov	r10, rcx

; 2357 :     IM_ASSERT_PARANOID(w <= stride);
; 2358 :     unsigned char* data = pixels + x + y * stride;

	movsxd	rax, r8d
	mov	ecx, DWORD PTR stride$[rsp]
	imul	r9d, ecx
	movsxd	r9, r9d
	add	rdx, r9

; 2359 :     for (int j = h; j > 0; j--, data += stride - w)

	mov	r9d, DWORD PTR h$[rsp]
	add	rax, rdx
	test	r9d, r9d
	jle	SHORT $LN3@ImFontAtla
	mov	r11d, DWORD PTR w$[rsp]
	sub	ecx, r11d
	mov	QWORD PTR [rsp], rbx
	movsxd	rbx, ecx
$LL4@ImFontAtla:

; 2360 :         for (int i = w; i > 0; i--, data++)

	mov	r8d, r11d
	test	r11d, r11d
	jle	SHORT $LN2@ImFontAtla
	npad	4
$LL7@ImFontAtla:

; 2361 :             *data = table[*data];

	movzx	ecx, BYTE PTR [rax]
	dec	r8d
	movzx	edx, BYTE PTR [rcx+r10]
	mov	BYTE PTR [rax], dl
	inc	rax
	test	r8d, r8d
	jg	SHORT $LL7@ImFontAtla
$LN2@ImFontAtla:

; 2359 :     for (int j = h; j > 0; j--, data += stride - w)

	dec	r9d
	add	rax, rbx
	test	r9d, r9d
	jg	SHORT $LL4@ImFontAtla
	mov	rbx, QWORD PTR [rsp]
$LN3@ImFontAtla:

; 2362 : }

	add	rsp, 8
	ret	0
?ImFontAtlasBuildMultiplyRectAlpha8@@YAXQEBEPEAEHHHHH@Z ENDP ; ImFontAtlasBuildMultiplyRectAlpha8
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?UnpackBitVectorToFlatIndexList@@YAXPEBUImBitVector@@PEAU?$ImVector@H@@@Z
_TEXT	SEGMENT
in$ = 80
out$ = 88
?UnpackBitVectorToFlatIndexList@@YAXPEBUImBitVector@@PEAU?$ImVector@H@@@Z PROC ; UnpackBitVectorToFlatIndexList, COMDAT

; 2391 : {

	push	rbx
	push	r12
	push	r13
	push	r14
	sub	rsp, 40					; 00000028H

; 2392 :     IM_ASSERT(sizeof(in->Storage.Data[0]) == sizeof(int));
; 2393 :     const ImU32* it_begin = in->Storage.begin();

	mov	r12, QWORD PTR [rcx+8]
	mov	rbx, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1923 :     inline const T*     end() const                         { return Data + Size; }

	movsxd	rax, DWORD PTR [rcx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2395 :     for (const ImU32* it = it_begin; it < it_end; it++)

	mov	r14, r12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1923 :     inline const T*     end() const                         { return Data + Size; }

	lea	r13, QWORD PTR [r12+rax*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2395 :     for (const ImU32* it = it_begin; it < it_end; it++)

	cmp	r12, r13
	jae	$LN3@UnpackBitV
	mov	QWORD PTR [rsp+80], rbp
	mov	QWORD PTR [rsp+88], rsi
	mov	QWORD PTR [rsp+96], rdi
	mov	QWORD PTR [rsp+32], r15
	npad	6
$LL4@UnpackBitV:

; 2396 :         if (ImU32 entries_32 = *it)

	mov	r15d, DWORD PTR [r14]
	test	r15d, r15d
	je	SHORT $LN2@UnpackBitV

; 2397 :             for (ImU32 bit_n = 0; bit_n < 32; bit_n++)

	xor	esi, esi
	mov	edi, 1
	npad	1
$LL7@UnpackBitV:

; 2398 :                 if (entries_32 & ((ImU32)1 << bit_n))

	test	edi, r15d
	je	SHORT $LN5@UnpackBitV
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	r8d, DWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2399 :                     out->push_back((int)(((it - it_begin) << 5) + bit_n));

	lea	rbp, QWORD PTR [r14*8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	ecx, DWORD PTR [rbx+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2399 :                     out->push_back((int)(((it - it_begin) << 5) + bit_n));

	lea	rax, QWORD PTR [r12*8]
	sub	ebp, eax
	and	ebp, -32				; ffffffffffffffe0H
	add	ebp, esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	cmp	r8d, ecx
	jne	SHORT $LN14@UnpackBitV
	inc	r8d

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN18@UnpackBitV
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN19@UnpackBitV
$LN18@UnpackBitV:
	mov	eax, 8
$LN19@UnpackBitV:
	cmp	eax, r8d

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rcx, rbx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	r8d, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, r8d
	call	?reserve@?$ImVector@H@@QEAAXH@Z		; ImVector<int>::reserve
$LN14@UnpackBitV:
	movsxd	rcx, DWORD PTR [rbx]
	mov	rax, QWORD PTR [rbx+8]
	mov	DWORD PTR [rax+rcx*4], ebp
	inc	DWORD PTR [rbx]
$LN5@UnpackBitV:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2397 :             for (ImU32 bit_n = 0; bit_n < 32; bit_n++)

	inc	esi
	rol	edi, 1
	cmp	esi, 32					; 00000020H
	jb	SHORT $LL7@UnpackBitV
$LN2@UnpackBitV:

; 2395 :     for (const ImU32* it = it_begin; it < it_end; it++)

	add	r14, 4
	cmp	r14, r13
	jb	SHORT $LL4@UnpackBitV
	mov	r15, QWORD PTR [rsp+32]
	mov	rdi, QWORD PTR [rsp+96]
	mov	rsi, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+80]
$LN3@UnpackBitV:

; 2400 : }

	add	rsp, 40					; 00000028H
	pop	r14
	pop	r13
	pop	r12
	pop	rbx
	ret	0
?UnpackBitVectorToFlatIndexList@@YAXPEBUImBitVector@@PEAU?$ImVector@H@@@Z ENDP ; UnpackBitVectorToFlatIndexList
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z
_TEXT	SEGMENT
src_tmp_array$2$ = 96
buf_packedchars$1$ = 104
tv7712 = 104
tv7705 = 104
new_size$1$ = 112
buf_rects_out_n$1$ = 112
buf_packedchars_out_n$1$ = 116
total_glyphs_count$1$ = 116
src_tmp_array$1$ = 120
$T7 = 128
tv7561 = 128
dst_tmp_array$1$ = 136
it_end$1$ = 144
buf_rects$1$ = 144
r$8 = 152
r$9 = 152
r$10 = 152
buf_packedchars$ = 152
total_surface$1$ = 184
atlas$GSCopy$1$ = 192
tv7564 = 192
dst_tmp_array$ = 200
buf_rects$ = 216
src_tmp_array$ = 232
x0$11 = 252
x1$12 = 256
padding$1$ = 260
y1$13 = 264
y0$14 = 268
spc$ = 272
multiply_table$15 = 336
__$ArrayPad$ = 592
atlas$ = 784
?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z PROC ; ImFontAtlasBuildWithStbTruetype, COMDAT

; 2403 : {

	mov	rax, rsp
	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-520]
	sub	rsp, 736				; 000002e0H
	movaps	XMMWORD PTR [rax-56], xmm6
	movaps	XMMWORD PTR [rax-72], xmm7
	movaps	XMMWORD PTR [rax-88], xmm8
	movaps	XMMWORD PTR [rax-104], xmm9
	movaps	XMMWORD PTR [rax-120], xmm10
	movaps	XMMWORD PTR [rax-136], xmm11
	movaps	XMMWORD PTR [rax-152], xmm12
	movaps	XMMWORD PTR [rax-168], xmm13
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	r13, rcx
	mov	QWORD PTR atlas$GSCopy$1$[rbp-256], rcx

; 2825 :     if (atlas->PackIdMouseCursors < 0)

	xor	r14d, r14d
	xorps	xmm13, xmm13
	cmp	DWORD PTR [rcx+1172], r14d
	jge	SHORT $LN559@ImFontAtla

; 2826 :     {
; 2827 :         if (!(atlas->Flags & ImFontAtlasFlags_NoMouseCursors))

	mov	DWORD PTR r$8[rbp-252], -1		; ffffffffH
	mov	QWORD PTR r$8[rbp-248], r14
	mov	QWORD PTR r$8[rbp-240], r14
	mov	QWORD PTR r$8[rbp-232], r14
	lea	rdx, QWORD PTR r$8[rbp-256]
	test	BYTE PTR [rcx], 2

; 2263 :     r.Width = (unsigned short)width;

	mov	DWORD PTR r$8[rbp-256], 1769717		; 001b00f5H

; 2827 :         if (!(atlas->Flags & ImFontAtlasFlags_NoMouseCursors))

	je	SHORT $LN826@ImFontAtla

; 2263 :     r.Width = (unsigned short)width;

	mov	DWORD PTR r$9[rbp-256], 131074		; 00020002H
$LN826@ImFontAtla:

; 2835 :     if (atlas->PackIdLines < 0)

	add	rcx, 104				; 00000068H
	call	?push_back@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXAEBUImFontAtlasCustomRect@@@Z ; ImVector<ImFontAtlasCustomRect>::push_back
	mov	eax, DWORD PTR [r13+104]
	dec	eax
	mov	DWORD PTR [r13+1172], eax
$LN559@ImFontAtla:
	cmp	DWORD PTR [r13+1176], r14d
	jge	SHORT $LN561@ImFontAtla

; 2836 :     {
; 2837 :         if (!(atlas->Flags & ImFontAtlasFlags_NoBakedLines))

	test	BYTE PTR [r13], 4
	jne	SHORT $LN561@ImFontAtla
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2950 :     ImFontAtlasCustomRect()         { Width = Height = 0; X = Y = 0xFFFF; GlyphID = 0; GlyphAdvanceX = 0.0f; GlyphOffset = ImVec2(0, 0); Font = NULL; }

	mov	DWORD PTR r$10[rbp-252], -1		; ffffffffH
	mov	QWORD PTR r$10[rbp-248], r14
	mov	QWORD PTR r$10[rbp-240], r14
	mov	QWORD PTR r$10[rbp-232], r14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2263 :     r.Width = (unsigned short)width;

	mov	DWORD PTR r$10[rbp-256], 4194369	; 00400041H

; 2264 :     r.Height = (unsigned short)height;
; 2265 :     CustomRects.push_back(r);

	lea	rdx, QWORD PTR r$10[rbp-256]
	lea	rcx, QWORD PTR [r13+104]
	call	?push_back@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXAEBUImFontAtlasCustomRect@@@Z ; ImVector<ImFontAtlasCustomRect>::push_back

; 2266 :     return CustomRects.Size - 1; // Return index

	mov	eax, DWORD PTR [r13+104]
	dec	eax

; 2838 :             atlas->PackIdLines = atlas->AddCustomRectRegular(IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 2, IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 1);

	mov	DWORD PTR [r13+1176], eax
$LN561@ImFontAtla:

; 2404 :     IM_ASSERT(atlas->ConfigData.Size > 0);
; 2405 : 
; 2406 :     ImFontAtlasBuildInit(atlas);
; 2407 : 
; 2408 :     // Clear atlas
; 2409 :     atlas->TexID = (ImTextureID)NULL;

	mov	QWORD PTR [r13+8], r14

; 2410 :     atlas->TexWidth = atlas->TexHeight = 0;

	mov	QWORD PTR [r13+64], r14

; 2411 :     atlas->TexUvScale = ImVec2(0.0f, 0.0f);

	mov	QWORD PTR [r13+72], r14

; 2412 :     atlas->TexUvWhitePixel = ImVec2(0.0f, 0.0f);

	mov	QWORD PTR [r13+80], r14

; 2413 :     atlas->ClearTexData();

	mov	rcx, r13
	call	?ClearTexData@ImFontAtlas@@QEAAXXZ	; ImFontAtlas::ClearTexData
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1903 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR src_tmp_array$[rbp-256], r14
	mov	r12, r14
	mov	QWORD PTR src_tmp_array$1$[rsp], r14
	mov	QWORD PTR src_tmp_array$[rbp-248], r14
	mov	QWORD PTR dst_tmp_array$[rbp-256], r14
	mov	r15, r14
	mov	QWORD PTR dst_tmp_array$1$[rbp-256], r14
	mov	QWORD PTR dst_tmp_array$[rbp-248], r14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2418 :     src_tmp_array.resize(atlas->ConfigData.Size);

	mov	esi, DWORD PTR [r13+120]
	mov	DWORD PTR src_tmp_array$2$[rsp], esi
	mov	eax, 8
	test	esi, esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	jle	SHORT $LN624@ImFontAtla

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	ebx, esi
	cmp	esi, eax
	cmovl	ebx, eax

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	test	ebx, ebx

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	jle	SHORT $LN624@ImFontAtla
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN629@ImFontAtla

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN629@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	movsxd	rax, ebx
	imul	rcx, rax, 272				; 00000110H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
	mov	r12, rax
	mov	QWORD PTR src_tmp_array$1$[rsp], rax
	mov	QWORD PTR src_tmp_array$[rbp-248], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	DWORD PTR src_tmp_array$[rbp-252], ebx
	mov	eax, 8
$LN624@ImFontAtla:

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR src_tmp_array$[rbp-256], esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2419 :     dst_tmp_array.resize(atlas->Fonts.Size);

	mov	edi, DWORD PTR [r13+88]
	mov	DWORD PTR new_size$1$[rsp], edi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	test	edi, edi
	jle	SHORT $LN598@ImFontAtla

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	ebx, edi
	cmp	edi, 8
	cmovl	ebx, eax

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	test	ebx, ebx
	jle	SHORT $LN598@ImFontAtla
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN603@ImFontAtla

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN603@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	movsxd	rcx, ebx
	shl	rcx, 5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
	mov	r15, rax
	mov	QWORD PTR dst_tmp_array$1$[rbp-256], rax
	mov	QWORD PTR dst_tmp_array$[rbp-248], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	DWORD PTR dst_tmp_array$[rbp-252], ebx
$LN598@ImFontAtla:

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR dst_tmp_array$[rbp-256], edi

; 1914 :     inline int          size_in_bytes() const               { return Size * (int)sizeof(T); }

	imul	ecx, esi, 272				; 00000110H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2420 :     memset(src_tmp_array.Data, 0, (size_t)src_tmp_array.size_in_bytes());

	movsxd	r8, ecx
	xor	edx, edx
	mov	rcx, r12
	call	memset

; 2421 :     memset(dst_tmp_array.Data, 0, (size_t)dst_tmp_array.size_in_bytes());

	mov	ecx, edi
	shl	ecx, 5
	movsxd	r8, ecx
	xor	edx, edx
	mov	rcx, r15
	call	memset

; 2422 : 
; 2423 :     // 1. Initialize font loading structure, check font data validity
; 2424 :     for (int src_i = 0; src_i < atlas->ConfigData.Size; src_i++)

	mov	r15d, r14d
	cmp	DWORD PTR [r13+120], r14d
	jle	$LN824@ImFontAtla
	mov	rdi, r14
	lea	rbx, QWORD PTR [r12+228]
$LL4@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	rsi, QWORD PTR [r13+128]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2431 :         src_tmp.DstIndex = -1;

	mov	DWORD PTR [rbx-4], -1

; 2432 :         for (int output_i = 0; output_i < atlas->Fonts.Size && src_tmp.DstIndex == -1; output_i++)

	mov	r8d, r14d
	cmp	DWORD PTR [r13+88], 0
	jle	$LN724@ImFontAtla
	mov	edx, -1
	mov	r9, r14
$LL7@ImFontAtla:
	mov	eax, edx
	cmp	edx, -1
	jne	SHORT $LN6@ImFontAtla

; 2433 :             if (cfg.DstFont == atlas->Fonts[output_i])

	mov	rax, QWORD PTR [r13+96]
	mov	rcx, QWORD PTR [r9+rax]
	cmp	QWORD PTR [rdi+rsi+128], rcx
	jne	SHORT $LN5@ImFontAtla

; 2434 :                 src_tmp.DstIndex = output_i;

	mov	DWORD PTR [rbx-4], r8d
	mov	edx, r8d
$LN5@ImFontAtla:

; 2432 :         for (int output_i = 0; output_i < atlas->Fonts.Size && src_tmp.DstIndex == -1; output_i++)

	inc	r8d
	add	r9, 8
	mov	eax, edx
	cmp	r8d, DWORD PTR [r13+88]
	jl	SHORT $LL7@ImFontAtla
$LN6@ImFontAtla:

; 2435 :         if (src_tmp.DstIndex == -1)

	cmp	eax, -1
	je	$LN724@ImFontAtla
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 4952 :    return stbtt_GetFontOffsetForIndex_internal((unsigned char *) data, index);

	mov	edx, DWORD PTR [rdi+rsi+16]
	mov	rcx, QWORD PTR [rdi+rsi]
	call	?stbtt_GetFontOffsetForIndex_internal@@YAHPEAEH@Z ; stbtt_GetFontOffsetForIndex_internal

; 4962 :    return stbtt_InitFont_internal(info, (unsigned char *) data, offset);

	mov	r8d, eax
	mov	rdx, QWORD PTR [rdi+rsi]
	lea	rcx, QWORD PTR [rbx-228]
	call	?stbtt_InitFont_internal@@YAHPEAUstbtt_fontinfo@@PEAEH@Z ; stbtt_InitFont_internal
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2443 :         if (!stbtt_InitFont(&src_tmp.FontInfo, (unsigned char*)cfg.FontData, font_offset))

	test	eax, eax
	je	$LN724@ImFontAtla
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	r8, DWORD PTR [rbx-4]
	shl	r8, 5
	mov	r9, QWORD PTR dst_tmp_array$1$[rbp-256]
	add	r8, r9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2448 :         src_tmp.SrcRanges = cfg.GlyphRanges ? cfg.GlyphRanges : atlas->GetGlyphRangesDefault();

	mov	rax, QWORD PTR [rdi+rsi+56]
	lea	rdx, OFFSET FLAT:?ranges@?1??GetGlyphRangesDefault@ImFontAtlas@@QEAAPEBGXZ@4QBGB
	test	rax, rax
	cmovne	rdx, rax
	mov	QWORD PTR [rbx-12], rdx

; 2449 :         for (const ImWchar* src_range = src_tmp.SrcRanges; src_range[0] && src_range[1]; src_range += 2)

	cmp	WORD PTR [rdx], 0
	je	SHORT $LN9@ImFontAtla
$LL10@ImFontAtla:
	movzx	eax, WORD PTR [rdx+2]
	test	ax, ax
	je	SHORT $LN9@ImFontAtla

; 2454 :             src_tmp.GlyphsHighest = ImMax(src_tmp.GlyphsHighest, (int)src_range[1]);

	mov	ecx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	cmp	DWORD PTR [rbx], eax
	cmovge	ecx, DWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2454 :             src_tmp.GlyphsHighest = ImMax(src_tmp.GlyphsHighest, (int)src_range[1]);

	mov	DWORD PTR [rbx], ecx

; 2449 :         for (const ImWchar* src_range = src_tmp.SrcRanges; src_range[0] && src_range[1]; src_range += 2)

	add	rdx, 4
	cmp	WORD PTR [rdx], 0
	jne	SHORT $LL10@ImFontAtla
$LN9@ImFontAtla:

; 2455 :         }
; 2456 :         dst_tmp.SrcCount++;

	inc	DWORD PTR [r8]

; 2457 :         dst_tmp.GlyphsHighest = ImMax(dst_tmp.GlyphsHighest, src_tmp.GlyphsHighest);

	mov	ecx, DWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	cmp	DWORD PTR [r8+4], ecx
	cmovge	ecx, DWORD PTR [r8+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2457 :         dst_tmp.GlyphsHighest = ImMax(dst_tmp.GlyphsHighest, src_tmp.GlyphsHighest);

	mov	DWORD PTR [r8+4], ecx

; 2422 : 
; 2423 :     // 1. Initialize font loading structure, check font data validity
; 2424 :     for (int src_i = 0; src_i < atlas->ConfigData.Size; src_i++)

	inc	r15d
	add	rbx, 272				; 00000110H
	add	rdi, 136				; 00000088H
	cmp	r15d, DWORD PTR [r13+120]
	mov	r14d, 0
	jl	$LL4@ImFontAtla

; 2443 :         if (!stbtt_InitFont(&src_tmp.FontInfo, (unsigned char*)cfg.FontData, font_offset))

	mov	esi, DWORD PTR src_tmp_array$2$[rsp]
	jmp	SHORT $LN3@ImFontAtla
$LN724@ImFontAtla:
	xor	bl, bl
	jmp	$LN225@ImFontAtla
$LN824@ImFontAtla:

; 2422 : 
; 2423 :     // 1. Initialize font loading structure, check font data validity
; 2424 :     for (int src_i = 0; src_i < atlas->ConfigData.Size; src_i++)

	mov	r9, QWORD PTR dst_tmp_array$1$[rbp-256]
$LN3@ImFontAtla:

; 2458 :     }
; 2459 : 
; 2460 :     // 2. For every requested codepoint, check for their presence in the font data, and handle redundancy or overlaps between source fonts to avoid unused glyphs.
; 2461 :     int total_glyphs_count = 0;

	mov	r12d, r14d

; 2462 :     for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)

	mov	eax, esi
	mov	QWORD PTR $T7[rbp-256], rax
	test	esi, esi
	jle	$LN21@ImFontAtla
	mov	r14, QWORD PTR src_tmp_array$1$[rsp]
	add	r14, 232				; 000000e8H
	mov	QWORD PTR tv7705[rsp], rsi
	npad	12
$LL13@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	r15, DWORD PTR [r14-8]
	shl	r15, 5
	add	r15, r9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 597  :     void            Create(int sz)              { Storage.resize((sz + 31) >> 5); memset(Storage.Data, 0, (size_t)Storage.Size * sizeof(Storage.Data[0])); }

	mov	ebx, DWORD PTR [r14-4]
	add	ebx, 32					; 00000020H
	sar	ebx, 5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	ecx, DWORD PTR [r14+12]
	cmp	ebx, ecx
	jle	SHORT $LN807@ImFontAtla

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN527@ImFontAtla
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN528@ImFontAtla
$LN527@ImFontAtla:
	mov	eax, 8
$LN528@ImFontAtla:

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	lea	rdi, QWORD PTR [r14+8]

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	edx, ebx
	cmp	eax, ebx
	cmovg	edx, eax

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	rcx, rdi
	call	?reserve@?$ImVector@I@@QEAAXH@Z		; ImVector<unsigned int>::reserve
	jmp	SHORT $LN523@ImFontAtla
$LN807@ImFontAtla:
	lea	rdi, QWORD PTR [r14+8]
$LN523@ImFontAtla:
	mov	DWORD PTR [rdi], ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 597  :     void            Create(int sz)              { Storage.resize((sz + 31) >> 5); memset(Storage.Data, 0, (size_t)Storage.Size * sizeof(Storage.Data[0])); }

	movsxd	r8, ebx
	shl	r8, 2
	xor	edx, edx
	mov	rcx, QWORD PTR [r14+16]
	call	memset
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1912 :     inline bool         empty() const                       { return Size == 0; }

	cmp	DWORD PTR [r15+16], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2467 :         if (dst_tmp.GlyphsSet.Storage.empty())

	jne	SHORT $LN53@ImFontAtla
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 597  :     void            Create(int sz)              { Storage.resize((sz + 31) >> 5); memset(Storage.Data, 0, (size_t)Storage.Size * sizeof(Storage.Data[0])); }

	mov	ebx, DWORD PTR [r15+4]
	add	ebx, 32					; 00000020H
	sar	ebx, 5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	ecx, DWORD PTR [r15+20]
	cmp	ebx, ecx
	jle	SHORT $LN542@ImFontAtla

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN546@ImFontAtla
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN547@ImFontAtla
$LN546@ImFontAtla:
	mov	eax, 8
$LN547@ImFontAtla:
	mov	edx, ebx
	cmp	eax, ebx
	cmovg	edx, eax

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	lea	rcx, QWORD PTR [r15+16]
	call	?reserve@?$ImVector@I@@QEAAXH@Z		; ImVector<unsigned int>::reserve
$LN542@ImFontAtla:
	mov	DWORD PTR [r15+16], ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 597  :     void            Create(int sz)              { Storage.resize((sz + 31) >> 5); memset(Storage.Data, 0, (size_t)Storage.Size * sizeof(Storage.Data[0])); }

	movsxd	r8, ebx
	shl	r8, 2
	xor	edx, edx
	mov	rcx, QWORD PTR [r15+24]
	call	memset
$LN53@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2470 :         for (const ImWchar* src_range = src_tmp.SrcRanges; src_range[0] && src_range[1]; src_range += 2)

	mov	r13, QWORD PTR [r14-16]
	cmp	WORD PTR [r13], 0
	je	SHORT $LN11@ImFontAtla
	npad	3
$LL16@ImFontAtla:
	movzx	eax, WORD PTR [r13+2]
	test	ax, ax
	je	SHORT $LN818@ImFontAtla

; 2471 :             for (unsigned int codepoint = src_range[0]; codepoint <= src_range[1]; codepoint++)

	movzx	edi, WORD PTR [r13]
	cmp	edi, eax
	ja	SHORT $LN14@ImFontAtla
$LL19@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 599  :     bool            TestBit(int n) const        { IM_ASSERT(n < (Storage.Size << 5)); return IM_BITARRAY_TESTBIT(Storage.Data, n); }

	movsxd	rbx, edi
	sar	rbx, 5
	mov	ecx, edi
	and	ecx, 31
	mov	esi, 1
	shl	esi, cl
	mov	rax, QWORD PTR [r15+24]
	test	DWORD PTR [rax+rbx*4], esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2473 :                 if (dst_tmp.GlyphsSet.TestBit(codepoint))    // Don't overwrite existing glyphs. We could make this an option for MergeMode (e.g. MergeOverwrite==true)

	jne	SHORT $LN17@ImFontAtla

; 2474 :                     continue;
; 2475 :                 if (!stbtt_FindGlyphIndex(&src_tmp.FontInfo, codepoint))    // It is actually in the font?

	lea	rcx, QWORD PTR [r14-232]
	mov	edx, edi
	call	stbtt_FindGlyphIndex
	test	eax, eax
	je	SHORT $LN17@ImFontAtla

; 2476 :                     continue;
; 2477 : 
; 2478 :                 // Add to avail set/counters
; 2479 :                 src_tmp.GlyphsCount++;

	inc	DWORD PTR [r14]

; 2480 :                 dst_tmp.GlyphsCount++;

	inc	DWORD PTR [r15+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 600  :     void            SetBit(int n)               { IM_ASSERT(n < (Storage.Size << 5)); ImBitArraySetBit(Storage.Data, n); }

	mov	rax, QWORD PTR [r14+16]

; 560  : inline void     ImBitArraySetBit(ImU32* arr, int n)             { ImU32 mask = (ImU32)1 << (n & 31); arr[n >> 5] |= mask; }

	or	DWORD PTR [rax+rbx*4], esi

; 600  :     void            SetBit(int n)               { IM_ASSERT(n < (Storage.Size << 5)); ImBitArraySetBit(Storage.Data, n); }

	mov	rax, QWORD PTR [r15+24]

; 560  : inline void     ImBitArraySetBit(ImU32* arr, int n)             { ImU32 mask = (ImU32)1 << (n & 31); arr[n >> 5] |= mask; }

	or	DWORD PTR [rax+rbx*4], esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2483 :                 total_glyphs_count++;

	inc	r12d
$LN17@ImFontAtla:

; 2471 :             for (unsigned int codepoint = src_range[0]; codepoint <= src_range[1]; codepoint++)

	inc	edi
	movzx	eax, WORD PTR [r13+2]
	cmp	edi, eax
	jbe	SHORT $LL19@ImFontAtla
$LN14@ImFontAtla:

; 2470 :         for (const ImWchar* src_range = src_tmp.SrcRanges; src_range[0] && src_range[1]; src_range += 2)

	add	r13, 4
	cmp	WORD PTR [r13], 0
	jne	SHORT $LL16@ImFontAtla
$LN818@ImFontAtla:
	mov	rsi, QWORD PTR tv7705[rsp]
$LN11@ImFontAtla:

; 2462 :     for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)

	add	r14, 272				; 00000110H
	sub	rsi, 1
	mov	QWORD PTR tv7705[rsp], rsi
	mov	r9, QWORD PTR dst_tmp_array$1$[rbp-256]
	jne	$LL13@ImFontAtla
	mov	rbx, QWORD PTR src_tmp_array$1$[rsp]
	add	rbx, 256				; 00000100H
	mov	rax, QWORD PTR $T7[rbp-256]
	mov	QWORD PTR tv7712[rsp], rax

; 2675 :         font->Descent = descent;

	mov	DWORD PTR total_glyphs_count$1$[rsp], r12d
	npad	7
$LL22@ImFontAtla:

; 2489 :     {
; 2490 :         ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
; 2491 :         src_tmp.GlyphsList.reserve(src_tmp.GlyphsCount);

	movsxd	rdi, DWORD PTR [rbx-24]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	cmp	edi, DWORD PTR [rbx+4]
	jle	SHORT $LN809@ImFontAtla
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN460@ImFontAtla

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN460@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	rcx, rdi
	shl	rcx, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
	mov	rsi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	rdx, QWORD PTR [rbx+8]
	test	rdx, rdx
	je	SHORT $LN470@ImFontAtla
	movsxd	r8, DWORD PTR [rbx]
	shl	r8, 2
	mov	rcx, rax
	call	memcpy
	mov	rcx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	test	rcx, rcx
	je	SHORT $LN468@ImFontAtla

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN468@ImFontAtla

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN468@ImFontAtla:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
$LN470@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rbx+8], rsi
	mov	DWORD PTR [rbx+4], edi
$LN809@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2393 :     const ImU32* it_begin = in->Storage.begin();

	mov	r13, QWORD PTR [rbx-8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1923 :     inline const T*     end() const                         { return Data + Size; }

	movsxd	rax, DWORD PTR [rbx-16]
	lea	rax, QWORD PTR [rax*4]
	add	rax, r13
	mov	QWORD PTR it_end$1$[rbp-256], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2395 :     for (const ImU32* it = it_begin; it < it_end; it++)

	mov	r15, r13
	cmp	r13, rax
	jae	$LN478@ImFontAtla
	npad	2
$LL479@ImFontAtla:

; 2396 :         if (ImU32 entries_32 = *it)

	mov	r12d, DWORD PTR [r15]
	test	r12d, r12d
	je	SHORT $LN477@ImFontAtla

; 2397 :             for (ImU32 bit_n = 0; bit_n < 32; bit_n++)

	xor	r14d, r14d
	mov	esi, 1
$LL482@ImFontAtla:

; 2398 :                 if (entries_32 & ((ImU32)1 << bit_n))

	test	r12d, esi
	je	SHORT $LN480@ImFontAtla

; 2399 :                     out->push_back((int)(((it - it_begin) << 5) + bit_n));

	lea	rdi, QWORD PTR [r15*8]
	lea	rax, QWORD PTR [r13*8]
	sub	edi, eax
	and	edi, -32				; ffffffffffffffe0H
	add	edi, r14d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	ecx, DWORD PTR [rbx+4]
	mov	r8d, DWORD PTR [rbx]
	cmp	r8d, ecx
	jne	SHORT $LN489@ImFontAtla
	inc	r8d

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN493@ImFontAtla
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN494@ImFontAtla
$LN493@ImFontAtla:
	mov	eax, 8
$LN494@ImFontAtla:
	cmp	eax, r8d
	cmovg	r8d, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, r8d
	mov	rcx, rbx
	call	?reserve@?$ImVector@H@@QEAAXH@Z		; ImVector<int>::reserve
$LN489@ImFontAtla:
	movsxd	rcx, DWORD PTR [rbx]
	mov	rax, QWORD PTR [rbx+8]
	mov	DWORD PTR [rax+rcx*4], edi
	inc	DWORD PTR [rbx]
$LN480@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2397 :             for (ImU32 bit_n = 0; bit_n < 32; bit_n++)

	inc	r14d
	rol	esi, 1
	cmp	r14d, 32				; 00000020H
	jb	SHORT $LL482@ImFontAtla
	mov	rax, QWORD PTR it_end$1$[rbp-256]
$LN477@ImFontAtla:

; 2395 :     for (const ImU32* it = it_begin; it < it_end; it++)

	add	r15, 4
	cmp	r15, rax
	jb	$LL479@ImFontAtla
$LN478@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	rcx, QWORD PTR [rbx-8]
	xor	r14d, r14d
	test	rcx, rcx
	je	SHORT $LN20@ImFontAtla
	mov	QWORD PTR [rbx-16], r14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN502@ImFontAtla

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN502@ImFontAtla:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx-8], r14
$LN20@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2488 :     for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)

	add	rbx, 272				; 00000110H
	sub	QWORD PTR tv7712[rsp], 1
	jne	$LL22@ImFontAtla
	mov	r12d, DWORD PTR total_glyphs_count$1$[rsp]
	mov	r13, QWORD PTR atlas$GSCopy$1$[rbp-256]
	mov	esi, DWORD PTR src_tmp_array$2$[rsp]
$LN21@ImFontAtla:

; 2496 :     for (int dst_i = 0; dst_i < dst_tmp_array.Size; dst_i++)

	mov	eax, DWORD PTR new_size$1$[rsp]
	test	eax, eax
	jle	SHORT $LN24@ImFontAtla
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	rbx, QWORD PTR dst_tmp_array$1$[rbp-256]
	add	rbx, 24
	mov	edi, eax
$LL25@ImFontAtla:

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN23@ImFontAtla
	mov	QWORD PTR [rbx-8], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN434@ImFontAtla

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN434@ImFontAtla:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx], r14
$LN23@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2496 :     for (int dst_i = 0; dst_i < dst_tmp_array.Size; dst_i++)

	add	rbx, 32					; 00000020H
	sub	rdi, 1
	jne	SHORT $LL25@ImFontAtla
$LN24@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	rdx, QWORD PTR dst_tmp_array$1$[rbp-256]
	test	rdx, rdx
	je	SHORT $LN441@ImFontAtla
	mov	QWORD PTR dst_tmp_array$[rbp-256], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN445@ImFontAtla

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN445@ImFontAtla:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	mov	rcx, rdx
	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	rdx, r14
	mov	QWORD PTR dst_tmp_array$1$[rbp-256], rdx
	mov	QWORD PTR dst_tmp_array$[rbp-248], rdx
$LN441@ImFontAtla:

; 1903 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR buf_rects$[rbp-256], 0
	mov	r15, r14
	mov	QWORD PTR buf_rects$1$[rbp-256], r14
	mov	QWORD PTR buf_rects$[rbp-248], r14
	mov	QWORD PTR buf_packedchars$[rbp-256], 0
	mov	rcx, r14
	mov	QWORD PTR buf_packedchars$1$[rsp], rcx
	mov	QWORD PTR buf_packedchars$[rbp-248], rcx

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	eax, 8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2503 :     ImVector<stbtt_packedchar> buf_packedchars;

	test	r12d, r12d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	jle	SHORT $LN376@ImFontAtla

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	ebx, r12d
	cmp	r12d, eax
	cmovl	ebx, eax

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	test	ebx, ebx

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	jle	SHORT $LN376@ImFontAtla
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN381@ImFontAtla

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN381@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	movsxd	rax, ebx
	lea	rcx, QWORD PTR [rax+rax*2]
	shl	rcx, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
	mov	r15, rax
	mov	QWORD PTR buf_rects$1$[rbp-256], rax
	mov	QWORD PTR buf_rects$[rbp-248], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	DWORD PTR buf_rects$[rbp-252], ebx
	mov	eax, 8
$LN376@ImFontAtla:

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR buf_rects$[rbp-256], r12d
	test	r12d, r12d
	jle	SHORT $LN402@ImFontAtla

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	ebx, r12d
	cmp	r12d, 8
	cmovl	ebx, eax

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	test	ebx, ebx
	jle	SHORT $LN402@ImFontAtla
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN407@ImFontAtla

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN407@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	movsxd	rax, ebx
	imul	rcx, rax, 28
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
	mov	QWORD PTR buf_packedchars$1$[rsp], rax
	mov	QWORD PTR buf_packedchars$[rbp-248], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	DWORD PTR buf_packedchars$[rbp-252], ebx
$LN402@ImFontAtla:

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR buf_packedchars$[rbp-256], r12d

; 1914 :     inline int          size_in_bytes() const               { return Size * (int)sizeof(T); }

	lea	ecx, DWORD PTR [r12+r12*2]
	shl	ecx, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2506 :     memset(buf_rects.Data, 0, (size_t)buf_rects.size_in_bytes());

	movsxd	r8, ecx
	xor	edx, edx
	mov	rcx, r15
	call	memset

; 2507 :     memset(buf_packedchars.Data, 0, (size_t)buf_packedchars.size_in_bytes());

	imul	ecx, r12d, 28
	movsxd	r8, ecx
	xor	edx, edx
	mov	rbx, QWORD PTR buf_packedchars$1$[rsp]
	mov	rcx, rbx
	call	memset

; 2508 : 
; 2509 :     // 4. Gather glyphs sizes so we can pack them in our virtual canvas.
; 2510 :     int total_surface = 0;

	mov	ecx, r14d
	mov	DWORD PTR total_surface$1$[rbp-256], ecx

; 2511 :     int buf_rects_out_n = 0;

	mov	r9d, r14d
	mov	DWORD PTR buf_rects_out_n$1$[rsp], r14d

; 2512 :     int buf_packedchars_out_n = 0;

	mov	r10d, r14d
	mov	DWORD PTR buf_packedchars_out_n$1$[rsp], r14d

; 2513 :     for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)

	mov	r12d, 256				; 00000100H
	test	esi, esi
	jle	$LN27@ImFontAtla
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	rsi, r14
	mov	rdi, QWORD PTR src_tmp_array$1$[rsp]
	add	rdi, 208				; 000000d0H
	movss	xmm7, DWORD PTR __xmm@80000000800000008000000080000000
	mov	rax, QWORD PTR $T7[rbp-256]
	npad	10
$LL28@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2516 :         if (src_tmp.GlyphsCount == 0)

	mov	r8d, DWORD PTR [rdi+24]
	test	r8d, r8d
	je	$LN26@ImFontAtla
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rax, r9d
	lea	rcx, QWORD PTR [rax+rax*2]
	lea	rax, QWORD PTR [r15+rcx*8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2519 :         src_tmp.Rects = &buf_rects[buf_rects_out_n];

	mov	QWORD PTR [rdi-8], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rax, r10d
	imul	rdx, rax, 28
	add	rdx, rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2520 :         src_tmp.PackedChars = &buf_packedchars[buf_packedchars_out_n];

	mov	QWORD PTR [rdi], rdx

; 2521 :         buf_rects_out_n += src_tmp.GlyphsCount;

	add	r9d, r8d
	mov	DWORD PTR buf_rects_out_n$1$[rsp], r9d

; 2522 :         buf_packedchars_out_n += src_tmp.GlyphsCount;

	add	r10d, r8d
	mov	DWORD PTR buf_packedchars_out_n$1$[rsp], r10d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	r15, QWORD PTR [r13+128]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2526 :         src_tmp.PackRange.font_size = cfg.SizePixels;

	mov	eax, DWORD PTR [rsi+r15+20]
	mov	DWORD PTR [rdi-48], eax

; 2527 :         src_tmp.PackRange.first_unicode_codepoint_in_range = 0;

	mov	DWORD PTR [rdi-44], r14d

; 2528 :         src_tmp.PackRange.array_of_unicode_codepoints = src_tmp.GlyphsList.Data;

	mov	rax, QWORD PTR [rdi+56]
	mov	QWORD PTR [rdi-40], rax

; 2529 :         src_tmp.PackRange.num_chars = src_tmp.GlyphsList.Size;

	mov	ebx, DWORD PTR [rdi+48]
	mov	DWORD PTR [rdi-32], ebx

; 2530 :         src_tmp.PackRange.chardata_for_range = src_tmp.PackedChars;

	mov	QWORD PTR [rdi-24], rdx

; 2531 :         src_tmp.PackRange.h_oversample = (unsigned char)cfg.OversampleH;

	movzx	eax, BYTE PTR [rsi+r15+24]
	mov	BYTE PTR [rdi-16], al

; 2532 :         src_tmp.PackRange.v_oversample = (unsigned char)cfg.OversampleV;

	movzx	eax, BYTE PTR [rsi+r15+28]
	mov	BYTE PTR [rdi-15], al

; 2535 :         const float scale = (cfg.SizePixels > 0) ? stbtt_ScaleForPixelHeight(&src_tmp.FontInfo, cfg.SizePixels) : stbtt_ScaleForMappingEmToPixels(&src_tmp.FontInfo, -cfg.SizePixels);

	movss	xmm6, DWORD PTR [rsi+r15+20]
	comiss	xmm6, xmm13
	jbe	SHORT $LN67@ImFontAtla
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 2667 :    int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);

	movsxd	r11, DWORD PTR [rdi-172]
	mov	r10, QWORD PTR [rdi-200]

; 1292 : static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }

	movzx	r8d, BYTE PTR [r11+r10+5]
	movzx	edx, BYTE PTR [r11+r10+4]
	movsx	ecx, r12w
	imul	edx, ecx
	add	r8w, dx

; 2667 :    int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);

	movsx	r9d, r8w

; 1292 : static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }

	movzx	r8d, BYTE PTR [r11+r10+7]
	movzx	eax, BYTE PTR [r11+r10+6]
	movsx	ecx, r12w
	imul	eax, ecx
	add	ax, r8w

; 2667 :    int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);

	cwde
	sub	r9d, eax
	movd	xmm0, r9d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2535 :         const float scale = (cfg.SizePixels > 0) ? stbtt_ScaleForPixelHeight(&src_tmp.FontInfo, cfg.SizePixels) : stbtt_ScaleForMappingEmToPixels(&src_tmp.FontInfo, -cfg.SizePixels);

	jmp	SHORT $LN827@ImFontAtla
$LN67@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 2673 :    int unitsPerEm = ttUSHORT(info->data + info->head + 18);

	movsxd	rcx, DWORD PTR [rdi-180]
	mov	rax, QWORD PTR [rdi-200]
	movzx	edx, BYTE PTR [rcx+rax+18]
	shl	edx, 8
	movzx	eax, BYTE PTR [rcx+rax+19]
	add	edx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2535 :         const float scale = (cfg.SizePixels > 0) ? stbtt_ScaleForPixelHeight(&src_tmp.FontInfo, cfg.SizePixels) : stbtt_ScaleForMappingEmToPixels(&src_tmp.FontInfo, -cfg.SizePixels);

	xorps	xmm6, xmm7
	movd	xmm0, edx
$LN827@ImFontAtla:

; 2536 :         const int padding = atlas->TexGlyphPadding;

	cvtdq2ps xmm0, xmm0
	divss	xmm6, xmm0
	mov	eax, DWORD PTR [r13+20]
	mov	DWORD PTR padding$1$[rbp-256], eax

; 2537 :         for (int glyph_i = 0; glyph_i < src_tmp.GlyphsList.Size; glyph_i++)

	test	ebx, ebx
	jle	$LN819@ImFontAtla

; 2536 :         const int padding = atlas->TexGlyphPadding;

	xor	r12d, r12d
	mov	r13d, r14d
	npad	8
$LL31@ImFontAtla:

; 2538 :         {
; 2539 :             int x0, y0, x1, y1;
; 2540 :             const int glyph_index_in_font = stbtt_FindGlyphIndex(&src_tmp.FontInfo, src_tmp.GlyphsList[glyph_i]);

	mov	rdx, QWORD PTR [rdi+56]
	mov	edx, DWORD PTR [r12+rdx]
	lea	rcx, QWORD PTR [rdi-208]
	call	stbtt_FindGlyphIndex
	movd	xmm3, DWORD PTR [rsi+r15+28]

; 2541 :             IM_ASSERT(glyph_index_in_font != 0);
; 2542 :             stbtt_GetGlyphBitmapBoxSubpixel(&src_tmp.FontInfo, glyph_index_in_font, scale * cfg.OversampleH, scale * cfg.OversampleV, 0, 0, &x0, &y0, &x1, &y1);

	cvtdq2ps xmm3, xmm3
	mulss	xmm3, xmm6
	movd	xmm2, DWORD PTR [rsi+r15+24]
	cvtdq2ps xmm2, xmm2
	mulss	xmm2, xmm6
	lea	rcx, QWORD PTR y1$13[rbp-256]
	mov	QWORD PTR [rsp+72], rcx
	lea	rcx, QWORD PTR x1$12[rbp-256]
	mov	QWORD PTR [rsp+64], rcx
	lea	rcx, QWORD PTR y0$14[rbp-256]
	mov	QWORD PTR [rsp+56], rcx
	lea	rcx, QWORD PTR x0$11[rbp-256]
	mov	QWORD PTR [rsp+48], rcx
	movss	DWORD PTR [rsp+40], xmm13
	movss	DWORD PTR [rsp+32], xmm13
	mov	edx, eax
	lea	rcx, QWORD PTR [rdi-208]
	call	stbtt_GetGlyphBitmapBoxSubpixel

; 2543 :             src_tmp.Rects[glyph_i].w = (stbrp_coord)(x1 - x0 + padding + cfg.OversampleH - 1);

	mov	eax, DWORD PTR [rsi+r15+24]
	sub	eax, DWORD PTR x0$11[rbp-256]
	add	eax, DWORD PTR x1$12[rbp-256]
	mov	edx, DWORD PTR padding$1$[rbp-256]
	lea	ecx, DWORD PTR [rdx-1]
	add	ecx, eax
	mov	rax, QWORD PTR [rdi-8]
	mov	DWORD PTR [rax+r14+4], ecx

; 2544 :             src_tmp.Rects[glyph_i].h = (stbrp_coord)(y1 - y0 + padding + cfg.OversampleV - 1);

	mov	ecx, DWORD PTR y1$13[rbp-256]
	sub	ecx, DWORD PTR y0$14[rbp-256]
	dec	ecx
	add	ecx, edx
	add	ecx, DWORD PTR [rsi+r15+28]
	mov	rax, QWORD PTR [rdi-8]
	mov	DWORD PTR [rax+r14+8], ecx

; 2545 :             total_surface += src_tmp.Rects[glyph_i].w * src_tmp.Rects[glyph_i].h;

	mov	rcx, QWORD PTR [rdi-8]
	mov	eax, DWORD PTR [rcx+r14+8]
	imul	eax, DWORD PTR [rcx+r14+4]
	mov	ecx, DWORD PTR total_surface$1$[rbp-256]
	add	ecx, eax
	mov	DWORD PTR total_surface$1$[rbp-256], ecx

; 2537 :         for (int glyph_i = 0; glyph_i < src_tmp.GlyphsList.Size; glyph_i++)

	inc	r13d
	lea	r12, QWORD PTR [r12+4]
	lea	r14, QWORD PTR [r14+24]
	cmp	r13d, DWORD PTR [rdi+48]
	jl	$LL31@ImFontAtla
	mov	r13, QWORD PTR atlas$GSCopy$1$[rbp-256]
	xor	r14d, r14d
	mov	r12d, 256				; 00000100H
	jmp	SHORT $LN828@ImFontAtla
$LN819@ImFontAtla:
	mov	ecx, DWORD PTR total_surface$1$[rbp-256]
$LN828@ImFontAtla:

; 2513 :     for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)

	mov	rax, QWORD PTR $T7[rbp-256]
	mov	rbx, QWORD PTR buf_packedchars$1$[rsp]
	mov	r15, QWORD PTR buf_rects$1$[rbp-256]
$LN26@ImFontAtla:
	add	rdi, 272				; 00000110H
	add	rsi, 136				; 00000088H
	sub	rax, 1
	mov	QWORD PTR $T7[rbp-256], rax
	mov	r9d, DWORD PTR buf_rects_out_n$1$[rsp]
	mov	r10d, DWORD PTR buf_packedchars_out_n$1$[rsp]
	jne	$LL28@ImFontAtla
$LN27@ImFontAtla:
	movd	xmm1, ecx

; 2546 :         }
; 2547 :     }
; 2548 : 
; 2549 :     // We need a width for the skyline algorithm, any width!
; 2550 :     // The exact width doesn't really matter much, but some API/GPU have texture size limitations and increasing width can decrease height.
; 2551 :     // User can override TexDesiredWidth and TexGlyphPadding if they wish, otherwise we use a simple heuristic to select the width based on expected surface.
; 2552 :     const int surface_sqrt = (int)ImSqrt((float)total_surface) + 1;

	cvtdq2ps xmm1, xmm1
	xorps	xmm0, xmm0
	ucomiss	xmm0, xmm1
	ja	SHORT $LN814@ImFontAtla
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm1
	jmp	SHORT $LN815@ImFontAtla
$LN814@ImFontAtla:
	movaps	xmm0, xmm1
	call	sqrtf
$LN815@ImFontAtla:
	cvttss2si ecx, xmm0
	inc	ecx

; 2553 :     atlas->TexHeight = 0;

	mov	DWORD PTR [r13+68], r14d

; 2554 :     if (atlas->TexDesiredWidth > 0)

	mov	eax, DWORD PTR [r13+16]
	test	eax, eax
	jg	SHORT $LN58@ImFontAtla
	movd	xmm0, ecx

; 2555 :         atlas->TexWidth = atlas->TexDesiredWidth;
; 2556 :     else
; 2557 :         atlas->TexWidth = (surface_sqrt >= 4096 * 0.7f) ? 4096 : (surface_sqrt >= 2048 * 0.7f) ? 2048 : (surface_sqrt >= 1024 * 0.7f) ? 1024 : 512;

	cvtdq2ps xmm0, xmm0
	comiss	xmm0, DWORD PTR __real@45333333
	jb	SHORT $LN71@ImFontAtla
	mov	eax, 4096				; 00001000H
	jmp	SHORT $LN58@ImFontAtla
$LN71@ImFontAtla:
	comiss	xmm0, DWORD PTR __real@44b33333
	jb	SHORT $LN69@ImFontAtla
	mov	eax, 2048				; 00000800H
	jmp	SHORT $LN58@ImFontAtla
$LN69@ImFontAtla:
	mov	eax, 512				; 00000200H
	mov	ecx, 1024				; 00000400H
	comiss	xmm0, DWORD PTR __real@44333333
	cmovae	eax, ecx
$LN58@ImFontAtla:

; 2558 : 
; 2559 :     // 5. Start packing
; 2560 :     // Pack our extra data rectangles first, so it will be on the upper-left corner of our texture (UV will have small values).
; 2561 :     const int TEX_HEIGHT_MAX = 1024 * 32;
; 2562 :     stbtt_pack_context spc = {};

	mov	DWORD PTR [r13+64], eax
	mov	QWORD PTR spc$[rbp-256], r14
	mov	rdi, r14
	mov	QWORD PTR spc$[rbp-248], r14
	mov	DWORD PTR spc$[rbp-240], r14d
	mov	QWORD PTR spc$[rbp-232], r14
	xorps	xmm0, xmm0
	movdqa	XMMWORD PTR spc$[rbp-224], xmm0
	mov	r12, r14
	mov	QWORD PTR spc$[rbp-200], r14

; 2563 :     stbtt_PackBegin(&spc, NULL, atlas->TexWidth, TEX_HEIGHT_MAX, 0, atlas->TexGlyphPadding, NULL);

	mov	r14d, DWORD PTR [r13+20]
	mov	r15d, DWORD PTR [r13+64]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN320@ImFontAtla

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN320@ImFontAtla:

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	mov	ecx, 72					; 00000048H
	call	QWORD PTR __imp_malloc
	mov	rsi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 3968 :    int            num_nodes = pw - padding;

	mov	ebx, r15d
	sub	ebx, r14d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN327@ImFontAtla

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN327@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 3969 :    stbrp_node    *nodes   = (stbrp_node    *) STBTT_malloc(sizeof(*nodes  ) * num_nodes,alloc_context);

	movsxd	rcx, ebx
	shl	rcx, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
	mov	r9, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 3971 :    if (context == NULL || nodes == NULL) {

	test	rsi, rsi
	je	SHORT $LN337@ImFontAtla
	test	rax, rax
	je	SHORT $LN314@ImFontAtla

; 3974 :       return 0;
; 3975 :    }
; 3976 : 
; 3977 :    spc->user_allocator_context = alloc_context;
; 3978 :    spc->width = pw;

	mov	DWORD PTR spc$[rbp-240], r15d

; 3979 :    spc->height = ph;
; 3980 :    spc->pixels = pixels;
; 3981 :    spc->pack_info = context;

	mov	rdi, rsi
	mov	QWORD PTR spc$[rbp-248], rsi

; 3982 :    spc->nodes = nodes;

	mov	r12, rax
	mov	QWORD PTR spc$[rbp-200], rax

; 3983 :    spc->padding = padding;

	mov	DWORD PTR spc$[rbp-228], r14d

; 3984 :    spc->stride_in_bytes = stride_in_bytes != 0 ? stride_in_bytes : pw;

	mov	DWORD PTR spc$[rbp-232], r15d

; 3985 :    spc->h_oversample = 1;

	mov	DWORD PTR spc$[rbp-220], 1

; 3986 :    spc->v_oversample = 1;

	mov	DWORD PTR spc$[rbp-216], 1

; 3987 :    spc->skip_missing = 0;

	xor	r15d, r15d
	mov	DWORD PTR spc$[rbp-224], r15d

; 3988 : 
; 3989 :    stbrp_init_target(context, pw-padding, ph-padding, nodes, num_nodes);

	mov	r8d, 32768				; 00008000H
	sub	r8d, r14d
	mov	DWORD PTR [rsp+32], ebx
	mov	edx, ebx
	mov	rcx, rsi
	call	stbrp_init_target

; 3990 : 
; 3991 :    if (pixels)

	jmp	SHORT $LN345@ImFontAtla
$LN314@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN335@ImFontAtla

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN335@ImFontAtla:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	mov	rcx, rsi
	jmp	SHORT $LN830@ImFontAtla
$LN337@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 3973 :       if (nodes   != NULL) STBTT_free(nodes  , alloc_context);

	test	r9, r9
	je	SHORT $LN821@ImFontAtla
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN343@ImFontAtla

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN343@ImFontAtla:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	mov	rcx, r9
$LN830@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2564 :     ImFontAtlasBuildPackCustomRects(atlas, spc.pack_info);

	call	QWORD PTR __imp_free
$LN821@ImFontAtla:
	xor	r15d, r15d
$LN345@ImFontAtla:
	mov	rdx, rdi
	mov	rcx, r13
	call	?ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z ; ImFontAtlasBuildPackCustomRects

; 2565 : 
; 2566 :     // 6. Pack each source font. No rendering yet, we are working with rectangles in an infinitely tall texture at this point.
; 2567 :     for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)

	mov	r14d, DWORD PTR src_tmp_array$2$[rsp]
	test	r14d, r14d
	jle	SHORT $LN33@ImFontAtla
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	rbx, QWORD PTR src_tmp_array$1$[rsp]
	add	rbx, 232				; 000000e8H
	mov	esi, r14d
	npad	7
$LL34@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2570 :         if (src_tmp.GlyphsCount == 0)

	mov	r8d, DWORD PTR [rbx]
	test	r8d, r8d
	je	SHORT $LN32@ImFontAtla

; 2571 :             continue;
; 2572 : 
; 2573 :         stbrp_pack_rects((stbrp_context*)spc.pack_info, src_tmp.Rects, src_tmp.GlyphsCount);

	mov	rdx, QWORD PTR [rbx-32]
	mov	rcx, rdi
	call	stbrp_pack_rects

; 2574 : 
; 2575 :         // Extend texture height and mark missing glyphs as non-packed so we won't render them.
; 2576 :         // FIXME: We are not handling packing failure here (would happen if we got off TEX_HEIGHT_MAX or if a single if larger than TexWidth?)
; 2577 :         for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++)

	mov	r8d, r15d
	cmp	DWORD PTR [rbx], 0
	jle	SHORT $LN32@ImFontAtla

; 2571 :             continue;
; 2572 : 
; 2573 :         stbrp_pack_rects((stbrp_context*)spc.pack_info, src_tmp.Rects, src_tmp.GlyphsCount);

	mov	rdx, r15
	npad	1
$LL37@ImFontAtla:

; 2578 :             if (src_tmp.Rects[glyph_i].was_packed)

	mov	rax, QWORD PTR [rbx-32]
	cmp	DWORD PTR [rdx+rax+20], 0
	je	SHORT $LN35@ImFontAtla

; 2579 :                 atlas->TexHeight = ImMax(atlas->TexHeight, src_tmp.Rects[glyph_i].y + src_tmp.Rects[glyph_i].h);

	mov	ecx, DWORD PTR [rdx+rax+16]
	add	ecx, DWORD PTR [rdx+rax+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	cmp	DWORD PTR [r13+68], ecx
	cmovge	ecx, DWORD PTR [r13+68]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2579 :                 atlas->TexHeight = ImMax(atlas->TexHeight, src_tmp.Rects[glyph_i].y + src_tmp.Rects[glyph_i].h);

	mov	DWORD PTR [r13+68], ecx
$LN35@ImFontAtla:

; 2574 : 
; 2575 :         // Extend texture height and mark missing glyphs as non-packed so we won't render them.
; 2576 :         // FIXME: We are not handling packing failure here (would happen if we got off TEX_HEIGHT_MAX or if a single if larger than TexWidth?)
; 2577 :         for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++)

	inc	r8d
	add	rdx, 24
	cmp	r8d, DWORD PTR [rbx]
	jl	SHORT $LL37@ImFontAtla
$LN32@ImFontAtla:

; 2565 : 
; 2566 :     // 6. Pack each source font. No rendering yet, we are working with rectangles in an infinitely tall texture at this point.
; 2567 :     for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)

	add	rbx, 272				; 00000110H
	sub	rsi, 1
	jne	SHORT $LL34@ImFontAtla
$LN33@ImFontAtla:

; 2583 :     atlas->TexHeight = (atlas->Flags & ImFontAtlasFlags_NoPowerOfTwoHeight) ? (atlas->TexHeight + 1) : ImUpperPowerOfTwo(atlas->TexHeight);

	mov	eax, DWORD PTR [r13+68]
	test	BYTE PTR [r13], 1
	jne	SHORT $LN74@ImFontAtla
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 358  : static inline int       ImUpperPowerOfTwo(int v)        { v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++; return v; }

	lea	ecx, DWORD PTR [rax-1]
	mov	eax, ecx
	sar	eax, 1
	or	ecx, eax
	mov	eax, ecx
	sar	eax, 2
	or	ecx, eax
	mov	eax, ecx
	sar	eax, 4
	or	ecx, eax
	mov	eax, ecx
	sar	eax, 8
	or	ecx, eax
	mov	eax, ecx
	sar	eax, 16
	or	eax, ecx
$LN74@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2583 :     atlas->TexHeight = (atlas->Flags & ImFontAtlasFlags_NoPowerOfTwoHeight) ? (atlas->TexHeight + 1) : ImUpperPowerOfTwo(atlas->TexHeight);

	lea	ecx, DWORD PTR [rax+1]
	mov	DWORD PTR [r13+68], ecx
	movd	xmm0, ecx

; 2584 :     atlas->TexUvScale = ImVec2(1.0f / atlas->TexWidth, 1.0f / atlas->TexHeight);

	cvtdq2ps xmm0, xmm0
	movss	xmm12, DWORD PTR __real@3f800000
	movaps	xmm2, xmm12
	divss	xmm2, xmm0
	mov	eax, DWORD PTR [r13+64]
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	movaps	xmm1, xmm12
	divss	xmm1, xmm0
	movss	DWORD PTR [r13+72], xmm1
	movss	DWORD PTR [r13+76], xmm2

; 2585 :     atlas->TexPixelsAlpha8 = (unsigned char*)IM_ALLOC(atlas->TexWidth * atlas->TexHeight);

	imul	eax, ecx
	movsxd	rcx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN300@ImFontAtla

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN300@ImFontAtla:

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2585 :     atlas->TexPixelsAlpha8 = (unsigned char*)IM_ALLOC(atlas->TexWidth * atlas->TexHeight);

	mov	QWORD PTR [r13+48], rax

; 2586 :     memset(atlas->TexPixelsAlpha8, 0, atlas->TexWidth * atlas->TexHeight);

	mov	ecx, DWORD PTR [r13+64]
	imul	ecx, DWORD PTR [r13+68]
	movsxd	r8, ecx
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 2587 :     spc.pixels = atlas->TexPixelsAlpha8;

	mov	rax, QWORD PTR [r13+48]
	mov	QWORD PTR spc$[rbp-208], rax

; 2588 :     spc.height = atlas->TexHeight;

	mov	eax, DWORD PTR [r13+68]
	mov	DWORD PTR spc$[rbp-236], eax

; 2589 : 
; 2590 :     // 8. Render/rasterize font characters into the texture
; 2591 :     for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)

	test	r14d, r14d
	jle	$LN39@ImFontAtla

; 2579 :                 atlas->TexHeight = ImMax(atlas->TexHeight, src_tmp.Rects[glyph_i].y + src_tmp.Rects[glyph_i].h);

	mov	r14, r15
	mov	rsi, QWORD PTR src_tmp_array$1$[rsp]
	mov	r12d, DWORD PTR src_tmp_array$2$[rsp]
	npad	12
$LL40@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	rbx, QWORD PTR [r13+128]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2595 :         if (src_tmp.GlyphsCount == 0)

	cmp	DWORD PTR [rsi+232], 0
	je	$LN38@ImFontAtla

; 2596 :             continue;
; 2597 : 
; 2598 :         stbtt_PackFontRangesRenderIntoRects(&spc, &src_tmp.FontInfo, &src_tmp.PackRange, 1, src_tmp.Rects);

	lea	r8, QWORD PTR [rsi+160]
	mov	rax, QWORD PTR [rsi+200]
	mov	QWORD PTR [rsp+32], rax
	mov	rdx, rsi
	lea	rcx, QWORD PTR spc$[rbp-256]
	call	stbtt_PackFontRangesRenderIntoRects

; 2599 : 
; 2600 :         // Apply multiply operator
; 2601 :         if (cfg.RasterizerMultiply != 1.0f)

	movss	xmm1, DWORD PTR [r14+rbx+80]
	ucomiss	xmm1, xmm12
	jp	SHORT $LN813@ImFontAtla
	je	$LN42@ImFontAtla
$LN813@ImFontAtla:

; 2602 :         {
; 2603 :             unsigned char multiply_table[256];
; 2604 :             ImFontAtlasBuildMultiplyCalcLookupTable(multiply_table, cfg.RasterizerMultiply);

	mov	r8d, r15d
	lea	r9, QWORD PTR multiply_table$15[rbp-256]
	npad	3
$LL749@ImFontAtla:

; 2350 :         unsigned int value = (unsigned int)(i * in_brighten_factor);

	mov	eax, r8d
	xorps	xmm0, xmm0
	cvtsi2ss xmm0, rax
	mulss	xmm0, xmm1
	cvttss2si rcx, xmm0

; 2351 :         out_table[i] = value > 255 ? 255 : (value & 0xFF);

	mov	edx, 255				; 000000ffH
	movzx	eax, cl
	cmp	ecx, edx
	cmovbe	edx, eax
	mov	BYTE PTR [r9], dl

; 2294 : }
; 2295 : 
; 2296 : bool ImFontAtlas::GetMouseCursorTexData(ImGuiMouseCursor cursor_type, ImVec2* out_offset, ImVec2* out_size, ImVec2 out_uv_border[2], ImVec2 out_uv_fill[2])
; 2297 : {
; 2298 :     if (cursor_type <= ImGuiMouseCursor_None || cursor_type >= ImGuiMouseCursor_COUNT)
; 2299 :         return false;
; 2300 :     if (Flags & ImFontAtlasFlags_NoMouseCursors)
; 2301 :         return false;
; 2302 : 
; 2303 :     IM_ASSERT(PackIdMouseCursors != -1);
; 2304 :     ImFontAtlasCustomRect* r = GetCustomRectByIndex(PackIdMouseCursors);
; 2305 :     ImVec2 pos = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][0] + ImVec2((float)r->X, (float)r->Y);
; 2306 :     ImVec2 size = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][1];
; 2307 :     *out_size = size;
; 2308 :     *out_offset = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][2];
; 2309 :     out_uv_border[0] = (pos) * TexUvScale;
; 2310 :     out_uv_border[1] = (pos + size) * TexUvScale;
; 2311 :     pos.x += FONT_ATLAS_DEFAULT_TEX_DATA_W + 1;
; 2312 :     out_uv_fill[0] = (pos) * TexUvScale;
; 2313 :     out_uv_fill[1] = (pos + size) * TexUvScale;
; 2314 :     return true;
; 2315 : }
; 2316 : 
; 2317 : bool    ImFontAtlas::Build()
; 2318 : {
; 2319 :     IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
; 2320 : 
; 2321 :     // Default font is none are specified
; 2322 :     if (ConfigData.Size == 0)
; 2323 :         AddFontDefault();
; 2324 : 
; 2325 :     // Select builder
; 2326 :     // - Note that we do not reassign to atlas->FontBuilderIO, since it is likely to point to static data which
; 2327 :     //   may mess with some hot-reloading schemes. If you need to assign to this (for dynamic selection) AND are
; 2328 :     //   using a hot-reloading scheme that messes up static data, store your own instance of ImFontBuilderIO somewhere
; 2329 :     //   and point to it instead of pointing directly to return value of the GetBuilderXXX functions.
; 2330 :     const ImFontBuilderIO* builder_io = FontBuilderIO;
; 2331 :     if (builder_io == NULL)
; 2332 :     {
; 2333 : #ifdef IMGUI_ENABLE_FREETYPE
; 2334 :         builder_io = ImGuiFreeType::GetBuilderForFreeType();
; 2335 : #elif defined(IMGUI_ENABLE_STB_TRUETYPE)
; 2336 :         builder_io = ImFontAtlasGetBuilderForStbTruetype();
; 2337 : #else
; 2338 :         IM_ASSERT(0); // Invalid Build function
; 2339 : #endif
; 2340 :     }
; 2341 : 
; 2342 :     // Build
; 2343 :     return builder_io->FontBuilder_Build(this);
; 2344 : }
; 2345 : 
; 2346 : void    ImFontAtlasBuildMultiplyCalcLookupTable(unsigned char out_table[256], float in_brighten_factor)
; 2347 : {
; 2348 :     for (unsigned int i = 0; i < 256; i++)

	inc	r8d
	lea	r9, QWORD PTR [r9+1]
	cmp	r8d, 256				; 00000100H
	jb	SHORT $LL749@ImFontAtla

; 2605 :             stbrp_rect* r = &src_tmp.Rects[0];

	mov	r11, QWORD PTR [rsi+200]

; 2606 :             for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++, r++)

	mov	edi, r15d
	cmp	DWORD PTR [rsi+232], 0
	jle	SHORT $LN42@ImFontAtla

; 2605 :             stbrp_rect* r = &src_tmp.Rects[0];

	add	r11, 8
	npad	5
$LL43@ImFontAtla:

; 2607 :                 if (r->was_packed)

	cmp	DWORD PTR [r11+12], 0
	je	SHORT $LN41@ImFontAtla

; 2608 :                     ImFontAtlasBuildMultiplyRectAlpha8(multiply_table, atlas->TexPixelsAlpha8, r->x, r->y, r->w, r->h, atlas->TexWidth * 1);

	mov	r8d, DWORD PTR [r13+64]
	mov	r9d, DWORD PTR [r11]
	mov	r10d, DWORD PTR [r11-4]
	mov	eax, DWORD PTR [r11+8]

; 2358 :     unsigned char* data = pixels + x + y * stride;

	imul	eax, r8d
	cdqe
	movsxd	rdx, DWORD PTR [r11+4]
	add	rax, QWORD PTR [r13+48]
	add	rdx, rax

; 2359 :     for (int j = h; j > 0; j--, data += stride - w)

	test	r9d, r9d
	jle	SHORT $LN41@ImFontAtla
	sub	r8d, r10d
	movsxd	rbx, r8d
$LL283@ImFontAtla:

; 2360 :         for (int i = w; i > 0; i--, data++)

	mov	r8d, r10d
	test	r10d, r10d
	jle	SHORT $LN281@ImFontAtla
	npad	6
$LL286@ImFontAtla:

; 2361 :             *data = table[*data];

	movzx	eax, BYTE PTR [rdx]
	movzx	ecx, BYTE PTR multiply_table$15[rbp+rax-256]
	mov	BYTE PTR [rdx], cl

; 2360 :         for (int i = w; i > 0; i--, data++)

	dec	r8d
	inc	rdx
	test	r8d, r8d
	jg	SHORT $LL286@ImFontAtla
$LN281@ImFontAtla:

; 2359 :     for (int j = h; j > 0; j--, data += stride - w)

	dec	r9d
	add	rdx, rbx
	test	r9d, r9d
	jg	SHORT $LL283@ImFontAtla
$LN41@ImFontAtla:

; 2606 :             for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++, r++)

	inc	edi
	add	r11, 24
	cmp	edi, DWORD PTR [rsi+232]
	jl	SHORT $LL43@ImFontAtla
$LN42@ImFontAtla:

; 2609 :         }
; 2610 :         src_tmp.Rects = NULL;

	mov	QWORD PTR [rsi+200], r15
$LN38@ImFontAtla:

; 2589 : 
; 2590 :     // 8. Render/rasterize font characters into the texture
; 2591 :     for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)

	add	r14, 136				; 00000088H
	add	rsi, 272				; 00000110H
	sub	r12, 1
	jne	$LL40@ImFontAtla
	mov	r12, QWORD PTR spc$[rbp-200]
	mov	rdi, QWORD PTR spc$[rbp-248]
	mov	r14d, DWORD PTR src_tmp_array$2$[rsp]
$LN39@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	test	r12, r12
	je	SHORT $LN262@ImFontAtla

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN262@ImFontAtla

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN262@ImFontAtla:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	mov	rcx, r12
	call	QWORD PTR __imp_free

; 4311 :     if (ptr)

	test	rdi, rdi
	je	SHORT $LN270@ImFontAtla

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN270@ImFontAtla

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN270@ImFontAtla:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	mov	rcx, rdi
	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	rcx, QWORD PTR buf_rects$1$[rbp-256]
	test	rcx, rcx
	je	SHORT $LN248@ImFontAtla
	mov	QWORD PTR buf_rects$[rbp-256], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN252@ImFontAtla

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN252@ImFontAtla:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	rcx, r15
	mov	QWORD PTR buf_rects$1$[rbp-256], rcx
	mov	QWORD PTR buf_rects$[rbp-248], rcx
$LN248@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2618 :     for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)

	test	r14d, r14d
	jle	$LN823@ImFontAtla

; 2579 :                 atlas->TexHeight = ImMax(atlas->TexHeight, src_tmp.Rects[glyph_i].y + src_tmp.Rects[glyph_i].h);

	mov	rcx, r15
	mov	QWORD PTR tv7564[rbp-256], rcx
	mov	rsi, QWORD PTR src_tmp_array$1$[rsp]
	add	rsi, 8
	mov	eax, r14d
	mov	QWORD PTR tv7561[rbp-256], rax
	movss	xmm11, DWORD PTR __real@3f000000
	npad	9
$LL46@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	r14, QWORD PTR [r13+128]
	add	r14, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2625 :         ImFont* dst_font = cfg.DstFont;

	mov	rbx, QWORD PTR [r14+128]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 2667 :    int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);

	movsxd	r10, DWORD PTR [rsi+28]
	mov	r9, QWORD PTR [rsi]

; 1292 : static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }

	movzx	edx, BYTE PTR [r10+r9+6]
	mov	edi, 256				; 00000100H
	movsx	ecx, di
	imul	edx, ecx
	movzx	eax, BYTE PTR [r10+r9+7]
	add	dx, ax

; 2667 :    int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);

	movsx	r11d, dx

; 1292 : static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }

	movzx	r8d, BYTE PTR [r10+r9+5]
	movzx	edx, BYTE PTR [r10+r9+4]
	movsx	ecx, di
	imul	edx, ecx
	add	r8w, dx

; 2667 :    int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);

	movsx	ecx, r8w
	mov	eax, ecx
	sub	eax, r11d
	movd	xmm0, eax

; 2668 :    return (float) height / fheight;

	cvtdq2ps xmm0, xmm0
	movss	xmm3, DWORD PTR [r14+20]
	divss	xmm3, xmm0
	movd	xmm2, ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2631 :         const float ascent = ImFloor(unscaled_ascent * font_scale + ((unscaled_ascent > 0.0f) ? +1 : -1));

	cvtdq2ps xmm2, xmm2
	mov	eax, -1
	comiss	xmm2, xmm13
	mov	ecx, 1
	cmova	eax, ecx
	movd	xmm1, eax
	cvtdq2ps xmm1, xmm1
	movaps	xmm0, xmm3
	mulss	xmm0, xmm2
	addss	xmm1, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 472  : static inline float  ImFloor(float f)                                           { return (float)(int)(f); }

	cvttss2si eax, xmm1
	movd	xmm6, eax
	cvtdq2ps xmm6, xmm6
	movd	xmm2, r11d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2632 :         const float descent = ImFloor(unscaled_descent * font_scale + ((unscaled_descent > 0.0f) ? +1 : -1));

	cvtdq2ps xmm2, xmm2
	mov	eax, -1
	comiss	xmm2, xmm13
	cmova	eax, ecx
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	mulss	xmm3, xmm2
	addss	xmm0, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 472  : static inline float  ImFloor(float f)                                           { return (float)(int)(f); }

	cvttss2si eax, xmm0
	movd	xmm7, eax
	cvtdq2ps xmm7, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2667 :     if (!font_config->MergeMode)

	cmp	BYTE PTR [r14+72], 0
	jne	SHORT $LN811@ImFontAtla

; 2668 :     {
; 2669 :         font->ClearOutputData();

	mov	rcx, rbx
	call	?ClearOutputData@ImFont@@QEAAXXZ	; ImFont::ClearOutputData

; 2670 :         font->FontSize = font_config->SizePixels;

	mov	eax, DWORD PTR [r14+20]
	mov	DWORD PTR [rbx+20], eax

; 2671 :         font->ConfigData = font_config;

	mov	QWORD PTR [rbx+72], r14

; 2672 :         font->ConfigDataCount = 0;

	xor	eax, eax
	mov	WORD PTR [rbx+80], ax

; 2673 :         font->ContainerAtlas = atlas;

	mov	QWORD PTR [rbx+64], r13

; 2674 :         font->Ascent = ascent;

	movss	DWORD PTR [rbx+104], xmm6

; 2675 :         font->Descent = descent;

	movss	DWORD PTR [rbx+108], xmm7
$LN811@ImFontAtla:

; 2676 :     }
; 2677 :     font->ConfigDataCount++;

	inc	WORD PTR [rbx+80]

; 2633 :         ImFontAtlasBuildSetupFont(atlas, dst_font, &cfg, ascent, descent);
; 2634 :         const float font_off_x = cfg.GlyphOffset.x;

	movss	xmm10, DWORD PTR [r14+44]

; 2635 :         const float font_off_y = cfg.GlyphOffset.y + IM_ROUND(dst_font->Ascent);

	movss	xmm0, DWORD PTR [rbx+104]
	addss	xmm0, xmm11
	cvttss2si eax, xmm0
	movd	xmm9, eax
	cvtdq2ps xmm9, xmm9
	addss	xmm9, DWORD PTR [r14+48]

; 2636 : 
; 2637 :         for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++)

	xor	eax, eax
	mov	r12d, eax
	cmp	DWORD PTR [rsi+224], eax
	jle	$LN44@ImFontAtla

; 2677 :     font->ConfigDataCount++;

	mov	edi, eax
	mov	r15d, eax
$LL49@ImFontAtla:

; 2638 :         {
; 2639 :             // Register glyph
; 2640 :             const int codepoint = src_tmp.GlyphsList[glyph_i];

	mov	rax, QWORD PTR [rsi+256]
	mov	r8d, DWORD PTR [r15+rax]

; 2641 :             const stbtt_packedchar& pc = src_tmp.PackedChars[glyph_i];

	mov	rcx, QWORD PTR [rsi+200]
	movd	xmm0, DWORD PTR [r13+64]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 4373 :    float ipw = 1.0f / pw, iph = 1.0f / ph;

	cvtdq2ps xmm0, xmm0
	movaps	xmm2, xmm12
	divss	xmm2, xmm0
	movd	xmm1, DWORD PTR [r13+68]
	cvtdq2ps xmm1, xmm1
	movaps	xmm0, xmm12
	divss	xmm0, xmm1

; 4388 :    }
; 4389 : 
; 4390 :    q->s0 = b->x0 * ipw;

	movzx	eax, WORD PTR [rdi+rcx]
	movd	xmm8, eax
	cvtdq2ps xmm8, xmm8
	mulss	xmm8, xmm2

; 4391 :    q->t0 = b->y0 * iph;

	movzx	eax, WORD PTR [rdi+rcx+2]
	movd	xmm7, eax
	cvtdq2ps xmm7, xmm7
	mulss	xmm7, xmm0

; 4392 :    q->s1 = b->x1 * ipw;

	movzx	eax, WORD PTR [rdi+rcx+4]
	movd	xmm6, eax
	cvtdq2ps xmm6, xmm6
	mulss	xmm6, xmm2

; 4393 :    q->t1 = b->y1 * iph;

	movzx	eax, WORD PTR [rdi+rcx+6]
	movd	xmm4, eax
	cvtdq2ps xmm4, xmm4
	mulss	xmm4, xmm0

; 4387 :       q->y1 = *ypos + b->yoff2;

	movss	xmm5, DWORD PTR [rdi+rcx+24]
	addss	xmm5, xmm13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2645 :             dst_font->AddGlyph(&cfg, (ImWchar)codepoint, q.x0 + font_off_x, q.y0 + font_off_y, q.x1 + font_off_x, q.y1 + font_off_y, q.s0, q.t0, q.s1, q.t1, pc.xadvance);

	addss	xmm5, xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 4386 :       q->x1 = *xpos + b->xoff2;

	movss	xmm2, DWORD PTR [rdi+rcx+20]
	addss	xmm2, xmm13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2645 :             dst_font->AddGlyph(&cfg, (ImWchar)codepoint, q.x0 + font_off_x, q.y0 + font_off_y, q.x1 + font_off_x, q.y1 + font_off_y, q.s0, q.t0, q.s1, q.t1, pc.xadvance);

	addss	xmm2, xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 4385 :       q->y0 = *ypos + b->yoff;

	movss	xmm1, DWORD PTR [rdi+rcx+12]
	addss	xmm1, xmm13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2645 :             dst_font->AddGlyph(&cfg, (ImWchar)codepoint, q.x0 + font_off_x, q.y0 + font_off_y, q.x1 + font_off_x, q.y1 + font_off_y, q.s0, q.t0, q.s1, q.t1, pc.xadvance);

	addss	xmm1, xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_truetype.h

; 4384 :       q->x0 = *xpos + b->xoff;

	movss	xmm3, DWORD PTR [rdi+rcx+8]
	addss	xmm3, xmm13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2645 :             dst_font->AddGlyph(&cfg, (ImWchar)codepoint, q.x0 + font_off_x, q.y0 + font_off_y, q.x1 + font_off_x, q.y1 + font_off_y, q.s0, q.t0, q.s1, q.t1, pc.xadvance);

	addss	xmm3, xmm10
	movss	xmm0, DWORD PTR [rdi+rcx+16]
	movss	DWORD PTR [rsp+88], xmm0
	movss	DWORD PTR [rsp+80], xmm4
	movss	DWORD PTR [rsp+72], xmm6
	movss	DWORD PTR [rsp+64], xmm7
	movss	DWORD PTR [rsp+56], xmm8
	movss	DWORD PTR [rsp+48], xmm5
	movss	DWORD PTR [rsp+40], xmm2
	movss	DWORD PTR [rsp+32], xmm1
	mov	rdx, r14
	mov	rcx, rbx
	call	?AddGlyph@ImFont@@QEAAXPEBUImFontConfig@@GMMMMMMMMM@Z ; ImFont::AddGlyph

; 2636 : 
; 2637 :         for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++)

	inc	r12d
	add	r15, 4
	add	rdi, 28
	cmp	r12d, DWORD PTR [rsi+224]
	jl	$LL49@ImFontAtla
$LN44@ImFontAtla:

; 2618 :     for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)

	add	rsi, 272				; 00000110H
	mov	rcx, QWORD PTR tv7564[rbp-256]
	add	rcx, 136				; 00000088H
	mov	QWORD PTR tv7564[rbp-256], rcx
	sub	QWORD PTR tv7561[rbp-256], 1
	jne	$LL46@ImFontAtla
	mov	r14d, DWORD PTR src_tmp_array$2$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1910 :     inline void         clear_destruct()                    { for (int n = 0; n < Size; n++) Data[n].~T(); clear(); }           // Important: never called automatically! always explicit.

	test	r14d, r14d
	jle	SHORT $LN823@ImFontAtla
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2675 :         font->Descent = descent;

	mov	r12, QWORD PTR src_tmp_array$1$[rsp]
	lea	rbx, QWORD PTR [r12+248]
	mov	edi, r14d
	npad	1
$LL149@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1906 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

	mov	rcx, QWORD PTR [rbx+16]
	test	rcx, rcx
	je	SHORT $LN165@ImFontAtla
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN163@ImFontAtla

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN163@ImFontAtla:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
	npad	1
$LN165@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1906 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN180@ImFontAtla
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN178@ImFontAtla

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN178@ImFontAtla:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
	npad	1
$LN180@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1910 :     inline void         clear_destruct()                    { for (int n = 0; n < Size; n++) Data[n].~T(); clear(); }           // Important: never called automatically! always explicit.

	add	rbx, 272				; 00000110H
	sub	rdi, 1
	jne	SHORT $LL149@ImFontAtla
	jmp	SHORT $LN148@ImFontAtla
$LN823@ImFontAtla:
	mov	r12, QWORD PTR src_tmp_array$1$[rsp]
$LN148@ImFontAtla:

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	xor	esi, esi
	test	r12, r12
	je	SHORT $LN185@ImFontAtla
	mov	QWORD PTR src_tmp_array$[rbp-256], rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN189@ImFontAtla

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN189@ImFontAtla:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	mov	rcx, r12
	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	r12, rsi
	mov	QWORD PTR src_tmp_array$[rbp-248], rsi
$LN185@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2847 :     ImFontAtlasBuildRenderDefaultTexData(atlas);

	mov	rcx, r13
	call	?ImFontAtlasBuildRenderDefaultTexData@@YAXPEAUImFontAtlas@@@Z ; ImFontAtlasBuildRenderDefaultTexData

; 2848 :     ImFontAtlasBuildRenderLinesTexData(atlas);

	mov	rcx, r13
	call	?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z ; ImFontAtlasBuildRenderLinesTexData

; 2849 : 
; 2850 :     // Register custom rectangle glyphs
; 2851 :     for (int i = 0; i < atlas->CustomRects.Size; i++)

	mov	edi, esi
	cmp	DWORD PTR [r13+104], 0
	jle	$LN121@ImFontAtla

; 2675 :         font->Descent = descent;

	mov	rbx, rsi
$LL122@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	r10, QWORD PTR [r13+112]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2854 :         if (r->Font == NULL || r->GlyphID == 0)

	mov	r11, QWORD PTR [rbx+r10+24]
	test	r11, r11
	je	$LN120@ImFontAtla
	mov	r8d, DWORD PTR [rbx+r10+8]
	test	r8d, r8d
	je	$LN120@ImFontAtla

; 2292 :     *out_uv_min = ImVec2((float)rect->X * TexUvScale.x, (float)rect->Y * TexUvScale.y);

	movzx	eax, WORD PTR [rbx+r10+6]
	movd	xmm8, eax
	cvtdq2ps xmm8, xmm8
	mulss	xmm8, DWORD PTR [r13+76]
	movzx	ecx, WORD PTR [rbx+r10+4]

; 2293 :     *out_uv_max = ImVec2((float)(rect->X + rect->Width) * TexUvScale.x, (float)(rect->Y + rect->Height) * TexUvScale.y);

	movzx	r9d, WORD PTR [rbx+r10+2]
	add	eax, r9d
	movd	xmm6, eax
	cvtdq2ps xmm6, xmm6
	mulss	xmm6, DWORD PTR [r13+76]
	movzx	edx, WORD PTR [rbx+r10]

; 2861 :         r->Font->AddGlyph(NULL, (ImWchar)r->GlyphID, r->GlyphOffset.x, r->GlyphOffset.y, r->GlyphOffset.x + r->Width, r->GlyphOffset.y + r->Height, uv0.x, uv0.y, uv1.x, uv1.y, r->GlyphAdvanceX);

	movss	xmm7, DWORD PTR [rbx+r10+20]
	movss	xmm3, DWORD PTR [rbx+r10+16]

; 2293 :     *out_uv_max = ImVec2((float)(rect->X + rect->Width) * TexUvScale.x, (float)(rect->Y + rect->Height) * TexUvScale.y);

	lea	eax, DWORD PTR [rdx+rcx]
	movd	xmm4, eax
	cvtdq2ps xmm4, xmm4
	mulss	xmm4, DWORD PTR [r13+72]
	movd	xmm5, ecx

; 2267 : }
; 2268 : 
; 2269 : int ImFontAtlas::AddCustomRectFontGlyph(ImFont* font, ImWchar id, int width, int height, float advance_x, const ImVec2& offset)
; 2270 : {
; 2271 : #ifdef IMGUI_USE_WCHAR32
; 2272 :     IM_ASSERT(id <= IM_UNICODE_CODEPOINT_MAX);
; 2273 : #endif
; 2274 :     IM_ASSERT(font != NULL);
; 2275 :     IM_ASSERT(width > 0 && width <= 0xFFFF);
; 2276 :     IM_ASSERT(height > 0 && height <= 0xFFFF);
; 2277 :     ImFontAtlasCustomRect r;
; 2278 :     r.Width = (unsigned short)width;
; 2279 :     r.Height = (unsigned short)height;
; 2280 :     r.GlyphID = id;
; 2281 :     r.GlyphAdvanceX = advance_x;
; 2282 :     r.GlyphOffset = offset;
; 2283 :     r.Font = font;
; 2284 :     CustomRects.push_back(r);
; 2285 :     return CustomRects.Size - 1; // Return index
; 2286 : }
; 2287 : 
; 2288 : void ImFontAtlas::CalcCustomRectUV(const ImFontAtlasCustomRect* rect, ImVec2* out_uv_min, ImVec2* out_uv_max) const
; 2289 : {
; 2290 :     IM_ASSERT(TexWidth > 0 && TexHeight > 0);   // Font atlas needs to be built before we can calculate UV coordinates
; 2291 :     IM_ASSERT(rect->IsPacked());                // Make sure the rectangle has been packed
; 2292 :     *out_uv_min = ImVec2((float)rect->X * TexUvScale.x, (float)rect->Y * TexUvScale.y);

	cvtdq2ps xmm5, xmm5
	mulss	xmm5, DWORD PTR [r13+72]
	movd	xmm2, r9d

; 2861 :         r->Font->AddGlyph(NULL, (ImWchar)r->GlyphID, r->GlyphOffset.x, r->GlyphOffset.y, r->GlyphOffset.x + r->Width, r->GlyphOffset.y + r->Height, uv0.x, uv0.y, uv1.x, uv1.y, r->GlyphAdvanceX);

	cvtdq2ps xmm2, xmm2
	addss	xmm2, xmm7
	movd	xmm1, edx
	cvtdq2ps xmm1, xmm1
	addss	xmm1, xmm3
	movss	xmm0, DWORD PTR [rbx+r10+12]
	movss	DWORD PTR [rsp+88], xmm0
	movss	DWORD PTR [rsp+80], xmm6
	movss	DWORD PTR [rsp+72], xmm4
	movss	DWORD PTR [rsp+64], xmm8
	movss	DWORD PTR [rsp+56], xmm5
	movss	DWORD PTR [rsp+48], xmm2
	movss	DWORD PTR [rsp+40], xmm1
	movss	DWORD PTR [rsp+32], xmm7
	xor	edx, edx
	mov	rcx, r11
	call	?AddGlyph@ImFont@@QEAAXPEBUImFontConfig@@GMMMMMMMMM@Z ; ImFont::AddGlyph
$LN120@ImFontAtla:

; 2849 : 
; 2850 :     // Register custom rectangle glyphs
; 2851 :     for (int i = 0; i < atlas->CustomRects.Size; i++)

	inc	edi
	add	rbx, 32					; 00000020H
	cmp	edi, DWORD PTR [r13+104]
	jl	$LL122@ImFontAtla
$LN121@ImFontAtla:

; 2862 :     }
; 2863 : 
; 2864 :     // Build all fonts lookup tables
; 2865 :     for (int i = 0; i < atlas->Fonts.Size; i++)

	cmp	DWORD PTR [r13+88], 0
	jle	SHORT $LN124@ImFontAtla

; 2675 :         font->Descent = descent;

	mov	rbx, rsi
	npad	8
$LL125@ImFontAtla:

; 2866 :         if (atlas->Fonts[i]->DirtyLookupTables)

	mov	rax, QWORD PTR [r13+96]
	mov	rcx, QWORD PTR [rbx+rax]
	cmp	BYTE PTR [rcx+96], 0
	je	SHORT $LN123@ImFontAtla

; 2867 :             atlas->Fonts[i]->BuildLookupTable();

	call	?BuildLookupTable@ImFont@@QEAAXXZ	; ImFont::BuildLookupTable
$LN123@ImFontAtla:

; 2862 :     }
; 2863 : 
; 2864 :     // Build all fonts lookup tables
; 2865 :     for (int i = 0; i < atlas->Fonts.Size; i++)

	inc	esi
	add	rbx, 8
	cmp	esi, DWORD PTR [r13+88]
	jl	SHORT $LL125@ImFontAtla
$LN124@ImFontAtla:

; 2868 : 
; 2869 :     atlas->TexReady = true;

	mov	BYTE PTR [r13+40], 1

; 2646 :         }
; 2647 :     }
; 2648 : 
; 2649 :     // Cleanup
; 2650 :     src_tmp_array.clear_destruct();
; 2651 : 
; 2652 :     ImFontAtlasBuildFinish(atlas);
; 2653 :     return true;

	mov	bl, 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1906 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

	mov	rcx, QWORD PTR buf_packedchars$1$[rsp]
	test	rcx, rcx
	je	SHORT $LN243@ImFontAtla
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN241@ImFontAtla

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN241@ImFontAtla:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
	npad	1
$LN243@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1906 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

	mov	rcx, QWORD PTR buf_rects$1$[rbp-256]
	test	rcx, rcx
	je	SHORT $LN231@ImFontAtla
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN229@ImFontAtla

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN229@ImFontAtla:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
	npad	1
$LN231@ImFontAtla:
$LN225@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1906 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

	mov	rcx, QWORD PTR dst_tmp_array$1$[rbp-256]
	test	rcx, rcx
	je	SHORT $LN115@ImFontAtla
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN113@ImFontAtla

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN113@ImFontAtla:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
	npad	1
$LN115@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1906 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

	test	r12, r12
	je	SHORT $LN816@ImFontAtla
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rcx, rcx
	je	SHORT $LN101@ImFontAtla

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rcx+244]
$LN101@ImFontAtla:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	mov	rcx, r12
	call	QWORD PTR __imp_free
	npad	1
$LN816@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2654 : }

	movzx	eax, bl
	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+736]
	mov	rbx, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	mov	rdi, QWORD PTR [r11+72]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z ENDP ; ImFontAtlasBuildWithStbTruetype
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
src_tmp_array$2$ = 96
buf_packedchars$1$ = 104
tv7712 = 104
tv7705 = 104
new_size$1$ = 112
buf_rects_out_n$1$ = 112
buf_packedchars_out_n$1$ = 116
total_glyphs_count$1$ = 116
src_tmp_array$1$ = 120
$T7 = 128
tv7561 = 128
dst_tmp_array$1$ = 136
it_end$1$ = 144
buf_rects$1$ = 144
r$8 = 152
r$9 = 152
r$10 = 152
buf_packedchars$ = 152
total_surface$1$ = 184
atlas$GSCopy$1$ = 192
tv7564 = 192
dst_tmp_array$ = 200
buf_rects$ = 216
src_tmp_array$ = 232
x0$11 = 252
x1$12 = 256
padding$1$ = 260
y1$13 = 264
y0$14 = 268
spc$ = 272
multiply_table$15 = 336
__$ArrayPad$ = 592
atlas$ = 784
?dtor$0@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA PROC ; `ImFontAtlasBuildWithStbTruetype'::`1'::dtor$0
	lea	rcx, QWORD PTR src_tmp_array$[rdx]
	jmp	??1?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ ; ImVector<ImFontBuildSrcData>::~ImVector<ImFontBuildSrcData>
?dtor$0@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA ENDP ; `ImFontAtlasBuildWithStbTruetype'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
src_tmp_array$2$ = 96
buf_packedchars$1$ = 104
tv7712 = 104
tv7705 = 104
new_size$1$ = 112
buf_rects_out_n$1$ = 112
buf_packedchars_out_n$1$ = 116
total_glyphs_count$1$ = 116
src_tmp_array$1$ = 120
$T7 = 128
tv7561 = 128
dst_tmp_array$1$ = 136
it_end$1$ = 144
buf_rects$1$ = 144
r$8 = 152
r$9 = 152
r$10 = 152
buf_packedchars$ = 152
total_surface$1$ = 184
atlas$GSCopy$1$ = 192
tv7564 = 192
dst_tmp_array$ = 200
buf_rects$ = 216
src_tmp_array$ = 232
x0$11 = 252
x1$12 = 256
padding$1$ = 260
y1$13 = 264
y0$14 = 268
spc$ = 272
multiply_table$15 = 336
__$ArrayPad$ = 592
atlas$ = 784
?dtor$1@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA PROC ; `ImFontAtlasBuildWithStbTruetype'::`1'::dtor$1
	lea	rcx, QWORD PTR dst_tmp_array$[rdx]
	jmp	??1?$ImVector@UImFontBuildDstData@@@@QEAA@XZ ; ImVector<ImFontBuildDstData>::~ImVector<ImFontBuildDstData>
?dtor$1@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA ENDP ; `ImFontAtlasBuildWithStbTruetype'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
src_tmp_array$2$ = 96
buf_packedchars$1$ = 104
tv7712 = 104
tv7705 = 104
new_size$1$ = 112
buf_rects_out_n$1$ = 112
buf_packedchars_out_n$1$ = 116
total_glyphs_count$1$ = 116
src_tmp_array$1$ = 120
$T7 = 128
tv7561 = 128
dst_tmp_array$1$ = 136
it_end$1$ = 144
buf_rects$1$ = 144
r$8 = 152
r$9 = 152
r$10 = 152
buf_packedchars$ = 152
total_surface$1$ = 184
atlas$GSCopy$1$ = 192
tv7564 = 192
dst_tmp_array$ = 200
buf_rects$ = 216
src_tmp_array$ = 232
x0$11 = 252
x1$12 = 256
padding$1$ = 260
y1$13 = 264
y0$14 = 268
spc$ = 272
multiply_table$15 = 336
__$ArrayPad$ = 592
atlas$ = 784
?dtor$2@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA PROC ; `ImFontAtlasBuildWithStbTruetype'::`1'::dtor$2
	lea	rcx, QWORD PTR buf_rects$[rdx]
	jmp	??1?$ImVector@Ustbrp_rect@@@@QEAA@XZ	; ImVector<stbrp_rect>::~ImVector<stbrp_rect>
?dtor$2@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA ENDP ; `ImFontAtlasBuildWithStbTruetype'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
src_tmp_array$2$ = 96
buf_packedchars$1$ = 104
tv7712 = 104
tv7705 = 104
new_size$1$ = 112
buf_rects_out_n$1$ = 112
buf_packedchars_out_n$1$ = 116
total_glyphs_count$1$ = 116
src_tmp_array$1$ = 120
$T7 = 128
tv7561 = 128
dst_tmp_array$1$ = 136
it_end$1$ = 144
buf_rects$1$ = 144
r$8 = 152
r$9 = 152
r$10 = 152
buf_packedchars$ = 152
total_surface$1$ = 184
atlas$GSCopy$1$ = 192
tv7564 = 192
dst_tmp_array$ = 200
buf_rects$ = 216
src_tmp_array$ = 232
x0$11 = 252
x1$12 = 256
padding$1$ = 260
y1$13 = 264
y0$14 = 268
spc$ = 272
multiply_table$15 = 336
__$ArrayPad$ = 592
atlas$ = 784
?dtor$3@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA PROC ; `ImFontAtlasBuildWithStbTruetype'::`1'::dtor$3
	lea	rcx, QWORD PTR buf_packedchars$[rdx]
	jmp	??1?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ ; ImVector<stbtt_packedchar>::~ImVector<stbtt_packedchar>
?dtor$3@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA ENDP ; `ImFontAtlasBuildWithStbTruetype'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?ImFontAtlasGetBuilderForStbTruetype@@YAPEBUImFontBuilderIO@@XZ
_TEXT	SEGMENT
?ImFontAtlasGetBuilderForStbTruetype@@YAPEBUImFontBuilderIO@@XZ PROC ; ImFontAtlasGetBuilderForStbTruetype, COMDAT

; 2658 :     static ImFontBuilderIO io;
; 2659 :     io.FontBuilder_Build = ImFontAtlasBuildWithStbTruetype;

	lea	rax, OFFSET FLAT:?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z ; ImFontAtlasBuildWithStbTruetype
	mov	QWORD PTR ?io@?1??ImFontAtlasGetBuilderForStbTruetype@@YAPEBUImFontBuilderIO@@XZ@4U2@A, rax

; 2660 :     return &io;

	lea	rax, OFFSET FLAT:?io@?1??ImFontAtlasGetBuilderForStbTruetype@@YAPEBUImFontBuilderIO@@XZ@4U2@A

; 2661 : }

	ret	0
?ImFontAtlasGetBuilderForStbTruetype@@YAPEBUImFontBuilderIO@@XZ ENDP ; ImFontAtlasGetBuilderForStbTruetype
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?ImFontAtlasBuildSetupFont@@YAXPEAUImFontAtlas@@PEAUImFont@@PEAUImFontConfig@@MM@Z
_TEXT	SEGMENT
atlas$ = 64
font$ = 72
font_config$ = 80
ascent$ = 88
descent$ = 96
?ImFontAtlasBuildSetupFont@@YAXPEAUImFontAtlas@@PEAUImFont@@PEAUImFontConfig@@MM@Z PROC ; ImFontAtlasBuildSetupFont, COMDAT

; 2666 : {

$LN8:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 48					; 00000030H

; 2667 :     if (!font_config->MergeMode)

	cmp	BYTE PTR [r8+72], 0
	mov	rdi, r8
	movaps	XMMWORD PTR [rsp+32], xmm6
	mov	rbx, rdx
	movaps	xmm6, xmm3
	mov	rsi, rcx
	jne	SHORT $LN5@ImFontAtla

; 2668 :     {
; 2669 :         font->ClearOutputData();

	mov	rcx, rdx
	call	?ClearOutputData@ImFont@@QEAAXXZ	; ImFont::ClearOutputData

; 2670 :         font->FontSize = font_config->SizePixels;

	mov	eax, DWORD PTR [rdi+20]

; 2671 :         font->ConfigData = font_config;
; 2672 :         font->ConfigDataCount = 0;
; 2673 :         font->ContainerAtlas = atlas;
; 2674 :         font->Ascent = ascent;
; 2675 :         font->Descent = descent;

	movss	xmm0, DWORD PTR descent$[rsp]
	mov	DWORD PTR [rbx+20], eax
	xor	eax, eax
	mov	WORD PTR [rbx+80], ax

; 2676 :     }
; 2677 :     font->ConfigDataCount++;

	inc	WORD PTR [rbx+80]
	movss	DWORD PTR [rbx+104], xmm6
	movss	DWORD PTR [rbx+108], xmm0
	mov	QWORD PTR [rbx+72], rdi
	mov	QWORD PTR [rbx+64], rsi
	jmp	SHORT $LN4@ImFontAtla
$LN5@ImFontAtla:
	inc	WORD PTR [rdx+80]
$LN4@ImFontAtla:

; 2678 : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	movaps	xmm6, XMMWORD PTR [rsp+32]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?ImFontAtlasBuildSetupFont@@YAXPEAUImFontAtlas@@PEAUImFont@@PEAUImFontConfig@@MM@Z ENDP ; ImFontAtlasBuildSetupFont
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z
_TEXT	SEGMENT
pack_rects$ = 32
atlas$ = 64
stbrp_context_opaque$ = 72
?ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z PROC ; ImFontAtlasBuildPackCustomRects, COMDAT

; 2681 : {

$LN91:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 48					; 00000030H
	mov	rbp, rdx
	mov	rdi, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1903 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

	xor	ebx, ebx
	mov	QWORD PTR pack_rects$[rsp], rbx
	mov	esi, ebx
	mov	QWORD PTR pack_rects$[rsp+8], rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2692 :     pack_rects.resize(user_rects.Size);

	mov	r14d, DWORD PTR [rcx+104]
	test	r14d, r14d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	jle	SHORT $LN58@ImFontAtla

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	ecx, r14d
	mov	eax, 8
	cmp	r14d, eax
	cmovl	ecx, eax

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	test	ecx, ecx

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	jle	SHORT $LN58@ImFontAtla
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN63@ImFontAtla

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN63@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	movsxd	rax, ecx
	lea	rcx, QWORD PTR [rax+rax*2]
	shl	rcx, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
	mov	rsi, rax
$LN58@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2693 :     memset(pack_rects.Data, 0, (size_t)pack_rects.size_in_bytes());

	lea	ecx, DWORD PTR [r14+r14*2]
	shl	ecx, 3
	movsxd	r8, ecx
	xor	edx, edx
	mov	rcx, rsi
	call	memset

; 2694 :     for (int i = 0; i < user_rects.Size; i++)

	mov	r9d, ebx
	cmp	DWORD PTR [rdi+104], ebx
	jle	SHORT $LN3@ImFontAtla
	mov	rdx, rbx
	lea	r8, QWORD PTR [rsi+8]
	npad	14
$LL4@ImFontAtla:

; 2695 :     {
; 2696 :         pack_rects[i].w = user_rects[i].Width;

	mov	rax, QWORD PTR [rdi+112]
	movzx	ecx, WORD PTR [rdx+rax]
	mov	DWORD PTR [r8-4], ecx

; 2697 :         pack_rects[i].h = user_rects[i].Height;

	mov	rax, QWORD PTR [rdi+112]
	movzx	ecx, WORD PTR [rdx+rax+2]
	mov	DWORD PTR [r8], ecx

; 2694 :     for (int i = 0; i < user_rects.Size; i++)

	inc	r9d
	lea	rdx, QWORD PTR [rdx+32]
	lea	r8, QWORD PTR [r8+24]
	cmp	r9d, DWORD PTR [rdi+104]
	jl	SHORT $LL4@ImFontAtla
$LN3@ImFontAtla:

; 2698 :     }
; 2699 :     stbrp_pack_rects(pack_context, &pack_rects[0], pack_rects.Size);

	mov	r8d, r14d
	mov	rdx, rsi
	mov	rcx, rbp
	call	stbrp_pack_rects

; 2700 :     for (int i = 0; i < pack_rects.Size; i++)

	test	r14d, r14d
	jle	SHORT $LN6@ImFontAtla
	lea	rdx, QWORD PTR [rsi+16]
	mov	r8, r14
$LL7@ImFontAtla:

; 2701 :         if (pack_rects[i].was_packed)

	cmp	DWORD PTR [rdx+4], 0
	je	SHORT $LN5@ImFontAtla

; 2702 :         {
; 2703 :             user_rects[i].X = (unsigned short)pack_rects[i].x;

	movzx	ecx, WORD PTR [rdx-4]
	mov	rax, QWORD PTR [rdi+112]
	mov	WORD PTR [rbx+rax+4], cx

; 2704 :             user_rects[i].Y = (unsigned short)pack_rects[i].y;

	movzx	ecx, WORD PTR [rdx]
	mov	rax, QWORD PTR [rdi+112]
	mov	WORD PTR [rbx+rax+6], cx

; 2706 :             atlas->TexHeight = ImMax(atlas->TexHeight, pack_rects[i].y + pack_rects[i].h);

	mov	ecx, DWORD PTR [rdx-8]
	add	ecx, DWORD PTR [rdx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	cmp	DWORD PTR [rdi+68], ecx
	cmovge	ecx, DWORD PTR [rdi+68]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2706 :             atlas->TexHeight = ImMax(atlas->TexHeight, pack_rects[i].y + pack_rects[i].h);

	mov	DWORD PTR [rdi+68], ecx
$LN5@ImFontAtla:

; 2700 :     for (int i = 0; i < pack_rects.Size; i++)

	add	rbx, 32					; 00000020H
	add	rdx, 24
	sub	r8, 1
	jne	SHORT $LL7@ImFontAtla
$LN6@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1906 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

	test	rsi, rsi
	je	SHORT $LN88@ImFontAtla
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN19@ImFontAtla

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN19@ImFontAtla:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	mov	rcx, rsi
	call	QWORD PTR __imp_free
	npad	1
$LN88@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2708 : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	r14
	ret	0
?ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z ENDP ; ImFontAtlasBuildPackCustomRects
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
pack_rects$ = 32
atlas$ = 64
stbrp_context_opaque$ = 72
?dtor$0@?0??ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z@4HA PROC ; `ImFontAtlasBuildPackCustomRects'::`1'::dtor$0
	lea	rcx, QWORD PTR pack_rects$[rdx]
	jmp	??1?$ImVector@Ustbrp_rect@@@@QEAA@XZ	; ImVector<stbrp_rect>::~ImVector<stbrp_rect>
?dtor$0@?0??ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z@4HA ENDP ; `ImFontAtlasBuildPackCustomRects'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?ImFontAtlasBuildRender8bppRectFromString@@YAXPEAUImFontAtlas@@HHHHPEBDDE@Z
_TEXT	SEGMENT
atlas$ = 8
x$ = 16
y$ = 24
w$dead$ = 32
h$dead$ = 40
in_str$dead$ = 48
in_marker_char$ = 56
in_marker_pixel_value$dead$ = 64
?ImFontAtlasBuildRender8bppRectFromString@@YAXPEAUImFontAtlas@@HHHHPEBDDE@Z PROC ; ImFontAtlasBuildRender8bppRectFromString, COMDAT

; 2711 : {

$LN29:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi

; 2712 :     IM_ASSERT(x >= 0 && x + w <= atlas->TexWidth);
; 2713 :     IM_ASSERT(y >= 0 && y + h <= atlas->TexHeight);
; 2714 :     unsigned char* out_pixel = atlas->TexPixelsAlpha8 + x + (y * atlas->TexWidth);

	imul	r8d, DWORD PTR [rcx+64]
	lea	r11, OFFSET FLAT:?FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS@@3QBDB
	movzx	r9d, BYTE PTR in_marker_char$[rsp]
	mov	rdi, rcx
	movsxd	rax, edx
	mov	ebx, 27
	movsxd	r10, r8d
	add	r10, QWORD PTR [rcx+48]
	add	r10, rax
	xor	esi, esi
	npad	8
$LL4@ImFontAtla:

; 2716 :         for (int off_x = 0; off_x < w; off_x++)

	mov	rdx, r11
	lea	rax, QWORD PTR [r10+1]
	sub	rdx, r10
	mov	r8d, 61					; 0000003dH
$LL15@ImFontAtla:

; 2717 :             out_pixel[off_x] = (in_str[off_x] == in_marker_char) ? in_marker_pixel_value : 0x00;

	cmp	BYTE PTR [rdx+rax-1], r9b
	lea	rax, QWORD PTR [rax+2]
	mov	ecx, 255				; 000000ffH
	cmovne	ecx, esi
	mov	BYTE PTR [rax-3], cl
	mov	ecx, 255				; 000000ffH
	cmp	BYTE PTR [rdx+rax-2], r9b
	cmovne	ecx, esi
	mov	BYTE PTR [rax-2], cl
	sub	r8, 1
	jne	SHORT $LL15@ImFontAtla

; 2715 :     for (int off_y = 0; off_y < h; off_y++, out_pixel += atlas->TexWidth, in_str += w)

	movsxd	rax, DWORD PTR [rdi+64]
	add	r11, 122				; 0000007aH
	add	r10, rax
	sub	rbx, 1
	jne	SHORT $LL4@ImFontAtla

; 2718 : }

	mov	rbx, QWORD PTR [rsp+8]
	mov	rsi, QWORD PTR [rsp+16]
	mov	rdi, QWORD PTR [rsp+24]
	ret	0
?ImFontAtlasBuildRender8bppRectFromString@@YAXPEAUImFontAtlas@@HHHHPEBDDE@Z ENDP ; ImFontAtlasBuildRender8bppRectFromString
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?ImFontAtlasBuildRender32bppRectFromString@@YAXPEAUImFontAtlas@@HHHHPEBDDI@Z
_TEXT	SEGMENT
atlas$ = 8
x$ = 16
y$ = 24
w$dead$ = 32
h$dead$ = 40
in_str$dead$ = 48
in_marker_char$ = 56
in_marker_pixel_value$dead$ = 64
?ImFontAtlasBuildRender32bppRectFromString@@YAXPEAUImFontAtlas@@HHHHPEBDDI@Z PROC ; ImFontAtlasBuildRender32bppRectFromString, COMDAT

; 2721 : {

$LN84:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rdi

; 2722 :     IM_ASSERT(x >= 0 && x + w <= atlas->TexWidth);
; 2723 :     IM_ASSERT(y >= 0 && y + h <= atlas->TexHeight);
; 2724 :     unsigned int* out_pixel = atlas->TexPixelsRGBA32 + x + (y * atlas->TexWidth);

	imul	r8d, DWORD PTR [rcx+64]
	mov	rbx, rcx
	movsxd	rax, edx
	mov	edi, -1					; ffffffffH
	mov	r10d, 27
	movsxd	r8, r8d
	add	r8, rax
	mov	rax, QWORD PTR [rcx+56]
	lea	r9, QWORD PTR [rax+r8*4]
	movzx	r8d, BYTE PTR in_marker_char$[rsp]
	lea	rax, OFFSET FLAT:?FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS@@3QBDB+2
	npad	5
$LL4@ImFontAtla:

; 2726 :         for (int off_x = 0; off_x < w; off_x++)

	lea	rdx, QWORD PTR [r9+8]
	mov	r11d, 2
	npad	6
$LL13@ImFontAtla:

; 2727 :             out_pixel[off_x] = (in_str[off_x] == in_marker_char) ? in_marker_pixel_value : IM_COL32_BLACK_TRANS;

	xor	ecx, ecx
	cmp	BYTE PTR [rax-2], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx-8], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax-1], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx-4], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+1], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+4], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+2], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+8], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+3], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+12], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+4], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+16], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+5], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+20], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+6], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+24], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+7], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+28], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+8], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+32], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+9], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+36], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+10], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+40], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+11], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+44], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+12], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+48], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+13], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+52], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+14], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+56], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+15], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+60], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+16], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+64], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+17], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+68], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+18], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+72], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+19], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+76], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+20], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+80], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+21], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+84], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+22], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+88], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+23], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+92], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+24], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+96], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+25], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+100], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+26], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+104], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+27], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+108], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+28], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+112], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+29], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+116], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+30], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+120], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+31], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+124], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+32], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+128], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+33], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+132], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+34], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+136], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+35], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+140], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+36], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+144], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+37], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+148], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+38], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+152], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+39], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+156], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+40], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+160], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+41], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+164], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+42], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+168], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+43], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+172], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+44], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+176], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+45], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+180], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+46], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+184], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+47], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+188], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+48], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+192], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+49], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+196], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+50], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+200], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+51], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+204], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+52], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+208], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+53], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+212], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+54], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+216], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+55], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+220], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+56], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+224], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+57], r8b
	cmove	ecx, edi
	mov	DWORD PTR [rdx+228], ecx
	xor	ecx, ecx
	cmp	BYTE PTR [rax+58], r8b
	cmove	ecx, edi
	add	rax, 61					; 0000003dH
	mov	DWORD PTR [rdx+232], ecx
	lea	rdx, QWORD PTR [rdx+244]
	sub	r11, 1
	jne	$LL13@ImFontAtla

; 2725 :     for (int off_y = 0; off_y < h; off_y++, out_pixel += atlas->TexWidth, in_str += w)

	movsxd	rcx, DWORD PTR [rbx+64]
	lea	r9, QWORD PTR [r9+rcx*4]
	sub	r10, 1
	jne	$LL4@ImFontAtla

; 2728 : }

	mov	rbx, QWORD PTR [rsp+8]
	mov	rdi, QWORD PTR [rsp+16]
	ret	0
?ImFontAtlasBuildRender32bppRectFromString@@YAXPEAUImFontAtlas@@HHHHPEBDDI@Z ENDP ; ImFontAtlasBuildRender32bppRectFromString
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?ImFontAtlasBuildRenderDefaultTexData@@YAXPEAUImFontAtlas@@@Z
_TEXT	SEGMENT
atlas$ = 80
?ImFontAtlasBuildRenderDefaultTexData@@YAXPEAUImFontAtlas@@@Z PROC ; ImFontAtlasBuildRenderDefaultTexData, COMDAT

; 2731 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 64					; 00000040H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rdi, DWORD PTR [rcx+1172]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2731 : {

	mov	rbx, rcx

; 2732 :     ImFontAtlasCustomRect* r = atlas->GetCustomRectByIndex(atlas->PackIdMouseCursors);
; 2733 :     IM_ASSERT(r->IsPacked());
; 2734 : 
; 2735 :     const int w = atlas->TexWidth;

	mov	r8d, DWORD PTR [rcx+64]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	shl	rdi, 5
	add	rdi, QWORD PTR [rcx+112]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2736 :     if (!(atlas->Flags & ImFontAtlasFlags_NoMouseCursors))

	test	BYTE PTR [rcx], 2
	jne	SHORT $LN2@ImFontAtla

; 2737 :     {
; 2738 :         // Render/copy pixels
; 2739 :         IM_ASSERT(r->Width == FONT_ATLAS_DEFAULT_TEX_DATA_W * 2 + 1 && r->Height == FONT_ATLAS_DEFAULT_TEX_DATA_H);
; 2740 :         const int x_for_white = r->X;
; 2741 :         const int x_for_black = r->X + FONT_ATLAS_DEFAULT_TEX_DATA_W + 1;
; 2742 :         if (atlas->TexPixelsAlpha8 != NULL)

	cmp	QWORD PTR [rcx+48], 0
	movzx	edx, WORD PTR [rdi+4]
	movzx	r8d, WORD PTR [rdi+6]
	mov	BYTE PTR [rsp+48], 46			; 0000002eH
	lea	esi, DWORD PTR [rdx+123]
	je	SHORT $LN4@ImFontAtla

; 2743 :         {
; 2744 :             ImFontAtlasBuildRender8bppRectFromString(atlas, x_for_white, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, '.', 0xFF);

	call	?ImFontAtlasBuildRender8bppRectFromString@@YAXPEAUImFontAtlas@@HHHHPEBDDE@Z ; ImFontAtlasBuildRender8bppRectFromString

; 2745 :             ImFontAtlasBuildRender8bppRectFromString(atlas, x_for_black, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, 'X', 0xFF);

	movzx	r8d, WORD PTR [rdi+6]
	mov	edx, esi
	mov	rcx, rbx
	mov	BYTE PTR [rsp+48], 88			; 00000058H
	call	?ImFontAtlasBuildRender8bppRectFromString@@YAXPEAUImFontAtlas@@HHHHPEBDDE@Z ; ImFontAtlasBuildRender8bppRectFromString

; 2746 :         }

	jmp	$LN7@ImFontAtla
$LN4@ImFontAtla:

; 2747 :         else
; 2748 :         {
; 2749 :             ImFontAtlasBuildRender32bppRectFromString(atlas, x_for_white, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, '.', IM_COL32_WHITE);

	call	?ImFontAtlasBuildRender32bppRectFromString@@YAXPEAUImFontAtlas@@HHHHPEBDDI@Z ; ImFontAtlasBuildRender32bppRectFromString

; 2750 :             ImFontAtlasBuildRender32bppRectFromString(atlas, x_for_black, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, 'X', IM_COL32_WHITE);

	movzx	r8d, WORD PTR [rdi+6]
	mov	edx, esi
	mov	rcx, rbx
	mov	BYTE PTR [rsp+48], 88			; 00000058H
	call	?ImFontAtlasBuildRender32bppRectFromString@@YAXPEAUImFontAtlas@@HHHHPEBDDI@Z ; ImFontAtlasBuildRender32bppRectFromString

; 2751 :         }
; 2752 :     }

	jmp	SHORT $LN7@ImFontAtla
$LN2@ImFontAtla:

; 2753 :     else
; 2754 :     {
; 2755 :         // Render 4 white pixels
; 2756 :         IM_ASSERT(r->Width == 2 && r->Height == 2);
; 2757 :         const int offset = (int)r->X + (int)r->Y * w;

	movzx	eax, WORD PTR [rdi+4]

; 2758 :         if (atlas->TexPixelsAlpha8 != NULL)

	mov	r9, QWORD PTR [rcx+48]
	movzx	edx, WORD PTR [rdi+6]
	imul	edx, r8d
	add	edx, eax
	lea	eax, DWORD PTR [rdx+r8]
	movsxd	r8, edx
	movsxd	rcx, eax
	test	r9, r9
	je	SHORT $LN6@ImFontAtla

; 2759 :         {
; 2760 :             atlas->TexPixelsAlpha8[offset] = atlas->TexPixelsAlpha8[offset + 1] = atlas->TexPixelsAlpha8[offset + w] = atlas->TexPixelsAlpha8[offset + w + 1] = 0xFF;

	mov	BYTE PTR [rcx+r9+1], 255		; 000000ffH
	mov	rax, QWORD PTR [rbx+48]
	mov	BYTE PTR [rcx+rax], 255			; 000000ffH
	mov	rax, QWORD PTR [rbx+48]
	mov	BYTE PTR [r8+rax+1], 255		; 000000ffH
	mov	rax, QWORD PTR [rbx+48]
	mov	BYTE PTR [r8+rax], 255			; 000000ffH

; 2761 :         }

	jmp	SHORT $LN7@ImFontAtla
$LN6@ImFontAtla:

; 2762 :         else
; 2763 :         {
; 2764 :             atlas->TexPixelsRGBA32[offset] = atlas->TexPixelsRGBA32[offset + 1] = atlas->TexPixelsRGBA32[offset + w] = atlas->TexPixelsRGBA32[offset + w + 1] = IM_COL32_WHITE;

	mov	rax, QWORD PTR [rbx+56]
	mov	DWORD PTR [rax+rcx*4+4], -1		; ffffffffH
	mov	rax, QWORD PTR [rbx+56]
	mov	DWORD PTR [rax+rcx*4], -1		; ffffffffH
	mov	rax, QWORD PTR [rbx+56]
	mov	DWORD PTR [rax+r8*4+4], -1		; ffffffffH
	mov	rax, QWORD PTR [rbx+56]
	mov	DWORD PTR [rax+r8*4], -1		; ffffffffH
$LN7@ImFontAtla:

; 2765 :         }
; 2766 :     }
; 2767 :     atlas->TexUvWhitePixel = ImVec2((r->X + 0.5f) * atlas->TexUvScale.x, (r->Y + 0.5f) * atlas->TexUvScale.y);

	movzx	eax, WORD PTR [rdi+4]

; 2768 : }

	mov	rsi, QWORD PTR [rsp+88]
	movd	xmm2, eax
	movzx	eax, WORD PTR [rdi+6]
	cvtdq2ps xmm2, xmm2
	movd	xmm1, eax
	addss	xmm2, DWORD PTR __real@3f000000
	cvtdq2ps xmm1, xmm1
	mulss	xmm2, DWORD PTR [rbx+72]
	addss	xmm1, DWORD PTR __real@3f000000
	movss	DWORD PTR [rbx+80], xmm2
	mulss	xmm1, DWORD PTR [rbx+76]
	movss	DWORD PTR [rbx+84], xmm1
	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?ImFontAtlasBuildRenderDefaultTexData@@YAXPEAUImFontAtlas@@@Z ENDP ; ImFontAtlasBuildRenderDefaultTexData
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z
_TEXT	SEGMENT
tv1329 = 112
atlas$ = 112
?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z PROC ; ImFontAtlasBuildRenderLinesTexData, COMDAT

; 2771 : {

	mov	rax, rsp
	push	r13
	sub	rsp, 96					; 00000060H

; 2772 :     if (atlas->Flags & ImFontAtlasFlags_NoBakedLines)

	test	BYTE PTR [rcx], 4
	mov	r13, rcx
	jne	$LN3@ImFontAtla
	mov	QWORD PTR [rax+16], rbx

; 2773 :         return;
; 2774 : 
; 2775 :     // This generates a triangular shape in the texture, with the various line widths stacked on top of each other to allow interpolation between them
; 2776 :     ImFontAtlasCustomRect* r = atlas->GetCustomRectByIndex(atlas->PackIdLines);

	lea	r8, QWORD PTR [rcx+136]
	mov	QWORD PTR [rax+24], rbp
	mov	QWORD PTR [rax+32], rsi
	mov	QWORD PTR [rax-16], rdi
	mov	QWORD PTR [rax-24], r12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	r12, DWORD PTR [rcx+1176]
	shl	r12, 5
	add	r12, QWORD PTR [rcx+112]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2772 :     if (atlas->Flags & ImFontAtlasFlags_NoBakedLines)

	mov	QWORD PTR [rax-32], r14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 3037 :     ImFontAtlasCustomRect*      GetCustomRectByIndex(int index) { IM_ASSERT(index >= 0); return &CustomRects[index]; }

	xor	ebx, ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2772 :     if (atlas->Flags & ImFontAtlasFlags_NoBakedLines)

	movaps	XMMWORD PTR [rax-56], xmm6

; 2773 :         return;
; 2774 : 
; 2775 :     // This generates a triangular shape in the texture, with the various line widths stacked on top of each other to allow interpolation between them
; 2776 :     ImFontAtlasCustomRect* r = atlas->GetCustomRectByIndex(atlas->PackIdLines);

	movss	xmm6, DWORD PTR __real@3f000000
	mov	QWORD PTR tv1329[rsp], r8
	mov	QWORD PTR [rax-40], r15
	npad	6
$LL4@ImFontAtla:

; 2779 :     {
; 2780 :         // Each line consists of at least two empty pixels at the ends, with a line of solid pixels in the middle
; 2781 :         unsigned int y = n;
; 2782 :         unsigned int line_width = n;
; 2783 :         unsigned int pad_left = (r->Width - line_width) / 2;

	movzx	ebp, WORD PTR [r12]

; 2784 :         unsigned int pad_right = r->Width - (pad_left + line_width);
; 2785 : 
; 2786 :         // Write each slice
; 2787 :         IM_ASSERT(pad_left + line_width + pad_right == r->Width && y < r->Height); // Make sure we're inside the texture bounds before we start writing pixels
; 2788 :         if (atlas->TexPixelsAlpha8 != NULL)

	movzx	ecx, WORD PTR [r12+6]
	mov	r14d, ebp
	movzx	eax, WORD PTR [r12+4]
	add	ecx, ebx
	imul	ecx, DWORD PTR [r13+64]
	sub	r14d, ebx
	mov	rdi, QWORD PTR [r13+48]
	shr	r14d, 1
	sub	ebp, r14d
	mov	esi, r14d
	sub	ebp, ebx
	add	ecx, eax
	test	rdi, rdi
	je	$LN24@ImFontAtla

; 2789 :         {
; 2790 :             unsigned char* write_ptr = &atlas->TexPixelsAlpha8[r->X + ((r->Y + y) * atlas->TexWidth)];

	lea	r15, QWORD PTR [rdi+rcx]

; 2791 :             for (unsigned int i = 0; i < pad_left; i++)

	test	r14d, r14d
	je	SHORT $LN79@ImFontAtla
	mov	r8d, esi
	xor	edx, edx
	mov	rcx, r15
	call	memset
$LN79@ImFontAtla:

; 2792 :                 *(write_ptr + i) = 0x00;
; 2793 : 
; 2794 :             for (unsigned int i = 0; i < line_width; i++)

	mov	edi, ebx
	test	ebx, ebx
	je	SHORT $LN9@ImFontAtla
	lea	rcx, QWORD PTR [r14+r15]
	mov	r8d, ebx
	mov	dl, 255					; 000000ffH
	call	memset
$LN9@ImFontAtla:

; 2795 :                 *(write_ptr + pad_left + i) = 0xFF;
; 2796 : 
; 2797 :             for (unsigned int i = 0; i < pad_right; i++)

	test	ebp, ebp
	je	SHORT $LN82@ImFontAtla

; 2798 :                 *(write_ptr + pad_left + line_width + i) = 0x00;

	lea	rcx, QWORD PTR [rdi+r14]
	mov	r8d, ebp
	add	rcx, r15
	xor	edx, edx
	call	memset
$LN82@ImFontAtla:

; 2814 :         ImVec2 uv0 = ImVec2((float)(r->X + pad_left - 1), (float)(r->Y + y)) * atlas->TexUvScale;

	mov	r8, QWORD PTR tv1329[rsp]
$LN61@ImFontAtla:
	movzx	edi, WORD PTR [r12+4]
	xorps	xmm1, xmm1
	movzx	edx, WORD PTR [r12+6]
	xorps	xmm0, xmm0
	add	edx, ebx
	xorps	xmm3, xmm3
	mov	eax, edx

; 2815 :         ImVec2 uv1 = ImVec2((float)(r->X + pad_left + line_width + 1), (float)(r->Y + y + 1)) * atlas->TexUvScale;

	lea	ecx, DWORD PTR [rdx+1]
	cvtsi2ss xmm3, rcx
	lea	ecx, DWORD PTR [rdi-1]
	add	ecx, r14d
	cvtsi2ss xmm0, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2540 : static inline ImVec2  operator*(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }

	mulss	xmm3, DWORD PTR [r13+76]
	mulss	xmm0, DWORD PTR [r13+76]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2814 :         ImVec2 uv0 = ImVec2((float)(r->X + pad_left - 1), (float)(r->Y + y)) * atlas->TexUvScale;

	cvtsi2ss xmm1, rcx

; 2815 :         ImVec2 uv1 = ImVec2((float)(r->X + pad_left + line_width + 1), (float)(r->Y + y + 1)) * atlas->TexUvScale;

	lea	ecx, DWORD PTR [rdi+1]
	add	ecx, r14d
	add	ecx, ebx
	inc	ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm3, xmm0
	xorps	xmm0, xmm0

; 2540 : static inline ImVec2  operator*(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }

	mulss	xmm1, DWORD PTR [r13+72]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2815 :         ImVec2 uv1 = ImVec2((float)(r->X + pad_left + line_width + 1), (float)(r->Y + y + 1)) * atlas->TexUvScale;

	cvtsi2ss xmm0, rcx

; 2817 :         atlas->TexUvLines[n] = ImVec4(uv0.x, half_v, uv1.x, half_v);

	shufps	xmm1, xmm1, 225				; 000000e1H
	mulss	xmm3, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2540 : static inline ImVec2  operator*(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }

	mulss	xmm0, DWORD PTR [r13+72]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2817 :         atlas->TexUvLines[n] = ImVec4(uv0.x, half_v, uv1.x, half_v);

	movss	xmm1, xmm3
	shufps	xmm1, xmm1, 198				; 000000c6H
	movss	xmm1, xmm0
	shufps	xmm1, xmm1, 39				; 00000027H
	movss	xmm1, xmm3
	shufps	xmm1, xmm1, 57				; 00000039H
	movups	XMMWORD PTR [r8], xmm1
	add	r8, 16
	mov	QWORD PTR tv1329[rsp], r8
	cmp	ebx, 64					; 00000040H
	jb	$LL4@ImFontAtla

; 2777 :     IM_ASSERT(r->IsPacked());
; 2778 :     for (unsigned int n = 0; n < IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 1; n++) // +1 because of the zero-width row

	movaps	xmm6, XMMWORD PTR [rsp+48]
	mov	r15, QWORD PTR [rsp+64]
	mov	r14, QWORD PTR [rsp+72]
	mov	r12, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+136]
	mov	rbp, QWORD PTR [rsp+128]
	mov	rbx, QWORD PTR [rsp+120]
$LN3@ImFontAtla:

; 2818 :     }
; 2819 : }

	add	rsp, 96					; 00000060H
	pop	r13
	ret	0
$LN24@ImFontAtla:

; 2799 :         }
; 2800 :         else
; 2801 :         {
; 2802 :             unsigned int* write_ptr = &atlas->TexPixelsRGBA32[r->X + ((r->Y + y) * atlas->TexWidth)];

	mov	rax, QWORD PTR [r13+56]

; 2803 :             for (unsigned int i = 0; i < pad_left; i++)

	lea	rdx, QWORD PTR [r14*4]
	lea	r15, QWORD PTR [rax+rcx*4]
	test	r14d, r14d
	je	SHORT $LN15@ImFontAtla

; 2799 :         }
; 2800 :         else
; 2801 :         {
; 2802 :             unsigned int* write_ptr = &atlas->TexPixelsRGBA32[r->X + ((r->Y + y) * atlas->TexWidth)];

	mov	rcx, rdx
	mov	rdi, r15
	shr	rcx, 2
	mov	eax, 16777215				; 00ffffffH
	rep stosd
$LN15@ImFontAtla:

; 2804 :                 *(write_ptr + i) = IM_COL32(255, 255, 255, 0);
; 2805 : 
; 2806 :             for (unsigned int i = 0; i < line_width; i++)

	mov	edi, ebx
	test	ebx, ebx
	je	SHORT $LN18@ImFontAtla
	lea	rcx, QWORD PTR [rdx+r15]
	mov	r8d, ebx
	shl	r8, 2
	mov	edx, -1					; ffffffffH
	call	memset
	mov	r8, QWORD PTR tv1329[rsp]
$LN18@ImFontAtla:

; 2807 :                 *(write_ptr + pad_left + i) = IM_COL32_WHITE;
; 2808 : 
; 2809 :             for (unsigned int i = 0; i < pad_right; i++)

	test	ebp, ebp
	je	$LN61@ImFontAtla

; 2799 :         }
; 2800 :         else
; 2801 :         {
; 2802 :             unsigned int* write_ptr = &atlas->TexPixelsRGBA32[r->X + ((r->Y + y) * atlas->TexWidth)];

	lea	rax, QWORD PTR [rdi+r14]
	mov	ecx, ebp
	lea	rdi, QWORD PTR [r15+rax*4]
	mov	eax, 16777215				; 00ffffffH
	rep stosd
	jmp	$LN61@ImFontAtla
?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z ENDP ; ImFontAtlasBuildRenderLinesTexData
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?ImFontAtlasBuildInit@@YAXPEAUImFontAtlas@@@Z
_TEXT	SEGMENT
r$4 = 32
r$5 = 32
r$6 = 32
atlas$ = 80
?ImFontAtlasBuildInit@@YAXPEAUImFontAtlas@@@Z PROC	; ImFontAtlasBuildInit, COMDAT

; 2823 : {

$LN38:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	mov	QWORD PTR [rsp+32], r14
	push	rbp
	mov	rbp, rsp
	sub	rsp, 64					; 00000040H

; 2824 :     // Register texture region for mouse cursors or standard white pixels
; 2825 :     if (atlas->PackIdMouseCursors < 0)

	xor	esi, esi
	mov	rdi, rcx
	cmp	DWORD PTR [rcx+1172], esi
	jge	SHORT $LN4@ImFontAtla

; 2826 :     {
; 2827 :         if (!(atlas->Flags & ImFontAtlasFlags_NoMouseCursors))

	test	BYTE PTR [rcx], 2
	lea	rdx, QWORD PTR r$4[rbp-64]
	mov	DWORD PTR r$4[rbp-60], -1		; ffffffffH
	mov	QWORD PTR r$4[rbp-56], rsi
	mov	QWORD PTR r$4[rbp-48], rsi
	mov	QWORD PTR r$4[rbp-40], rsi

; 2263 :     r.Width = (unsigned short)width;

	mov	DWORD PTR r$4[rbp-64], 1769717		; 001b00f5H

; 2826 :     {
; 2827 :         if (!(atlas->Flags & ImFontAtlasFlags_NoMouseCursors))

	je	SHORT $LN36@ImFontAtla

; 2263 :     r.Width = (unsigned short)width;

	mov	DWORD PTR r$6[rbp-64], 131074		; 00020002H
$LN36@ImFontAtla:

; 2828 :             atlas->PackIdMouseCursors = atlas->AddCustomRectRegular(FONT_ATLAS_DEFAULT_TEX_DATA_W * 2 + 1, FONT_ATLAS_DEFAULT_TEX_DATA_H);
; 2829 :         else
; 2830 :             atlas->PackIdMouseCursors = atlas->AddCustomRectRegular(2, 2);
; 2831 :     }
; 2832 : 
; 2833 :     // Register texture region for thick lines
; 2834 :     // The +2 here is to give space for the end caps, whilst height +1 is to accommodate the fact we have a zero-width row
; 2835 :     if (atlas->PackIdLines < 0)

	add	rcx, 104				; 00000068H
	call	?push_back@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXAEBUImFontAtlasCustomRect@@@Z ; ImVector<ImFontAtlasCustomRect>::push_back
	mov	eax, DWORD PTR [rdi+104]
	dec	eax
	mov	DWORD PTR [rdi+1172], eax
$LN4@ImFontAtla:
	cmp	DWORD PTR [rdi+1176], esi
	jge	SHORT $LN6@ImFontAtla

; 2836 :     {
; 2837 :         if (!(atlas->Flags & ImFontAtlasFlags_NoBakedLines))

	test	BYTE PTR [rdi], 4
	jne	SHORT $LN6@ImFontAtla

; 2265 :     CustomRects.push_back(r);

	lea	rdx, QWORD PTR r$5[rbp-64]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2950 :     ImFontAtlasCustomRect()         { Width = Height = 0; X = Y = 0xFFFF; GlyphID = 0; GlyphAdvanceX = 0.0f; GlyphOffset = ImVec2(0, 0); Font = NULL; }

	mov	DWORD PTR r$5[rbp-60], -1		; ffffffffH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2265 :     CustomRects.push_back(r);

	lea	rcx, QWORD PTR [rdi+104]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2950 :     ImFontAtlasCustomRect()         { Width = Height = 0; X = Y = 0xFFFF; GlyphID = 0; GlyphAdvanceX = 0.0f; GlyphOffset = ImVec2(0, 0); Font = NULL; }

	mov	QWORD PTR r$5[rbp-56], rsi
	mov	QWORD PTR r$5[rbp-48], rsi
	mov	QWORD PTR r$5[rbp-40], rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2263 :     r.Width = (unsigned short)width;

	mov	DWORD PTR r$5[rbp-64], 4194369		; 00400041H

; 2265 :     CustomRects.push_back(r);

	call	?push_back@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXAEBUImFontAtlasCustomRect@@@Z ; ImVector<ImFontAtlasCustomRect>::push_back

; 2266 :     return CustomRects.Size - 1; // Return index

	mov	eax, DWORD PTR [rdi+104]
	dec	eax

; 2838 :             atlas->PackIdLines = atlas->AddCustomRectRegular(IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 2, IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 1);

	mov	DWORD PTR [rdi+1176], eax
$LN6@ImFontAtla:

; 2839 :     }
; 2840 : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	mov	rdi, QWORD PTR [rsp+96]
	mov	r14, QWORD PTR [rsp+104]
	add	rsp, 64					; 00000040H
	pop	rbp
	ret	0
?ImFontAtlasBuildInit@@YAXPEAUImFontAtlas@@@Z ENDP	; ImFontAtlasBuildInit
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z
_TEXT	SEGMENT
atlas$ = 160
?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z PROC	; ImFontAtlasBuildFinish, COMDAT

; 2844 : {

$LN44:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 144				; 00000090H
	mov	QWORD PTR [rsp+160], rbp
	mov	rbx, rcx

; 2845 :     // Render into our custom data blocks
; 2846 :     IM_ASSERT(atlas->TexPixelsAlpha8 != NULL || atlas->TexPixelsRGBA32 != NULL);
; 2847 :     ImFontAtlasBuildRenderDefaultTexData(atlas);

	call	?ImFontAtlasBuildRenderDefaultTexData@@YAXPEAUImFontAtlas@@@Z ; ImFontAtlasBuildRenderDefaultTexData

; 2848 :     ImFontAtlasBuildRenderLinesTexData(atlas);

	mov	rcx, rbx
	call	?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z ; ImFontAtlasBuildRenderLinesTexData

; 2849 : 
; 2850 :     // Register custom rectangle glyphs
; 2851 :     for (int i = 0; i < atlas->CustomRects.Size; i++)

	xor	esi, esi
	mov	ebp, esi
	cmp	DWORD PTR [rbx+104], esi
	jle	$LN3@ImFontAtla
	mov	QWORD PTR [rsp+168], r14
	mov	edi, esi
	movaps	XMMWORD PTR [rsp+128], xmm6
	movaps	XMMWORD PTR [rsp+112], xmm7
	movaps	XMMWORD PTR [rsp+96], xmm8
$LL4@ImFontAtla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	r10, QWORD PTR [rbx+112]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 2854 :         if (r->Font == NULL || r->GlyphID == 0)

	mov	r14, QWORD PTR [rdi+r10+24]
	test	r14, r14
	je	$LN2@ImFontAtla
	mov	r11d, DWORD PTR [rdi+r10+8]
	test	r11d, r11d
	je	$LN2@ImFontAtla

; 2292 :     *out_uv_min = ImVec2((float)rect->X * TexUvScale.x, (float)rect->Y * TexUvScale.y);

	movzx	ecx, WORD PTR [rdi+r10+6]

; 2293 :     *out_uv_max = ImVec2((float)(rect->X + rect->Width) * TexUvScale.x, (float)(rect->Y + rect->Height) * TexUvScale.y);

	movzx	edx, WORD PTR [rdi+r10+2]
	movzx	r8d, WORD PTR [rdi+r10+4]
	movzx	r9d, WORD PTR [rdi+r10]

; 2855 :             continue;
; 2856 : 
; 2857 :         // Will ignore ImFontConfig settings: GlyphMinAdvanceX, GlyphMinAdvanceY, GlyphExtraSpacing, PixelSnapH
; 2858 :         IM_ASSERT(r->Font->ContainerAtlas == atlas);
; 2859 :         ImVec2 uv0, uv1;
; 2860 :         atlas->CalcCustomRectUV(r, &uv0, &uv1);
; 2861 :         r->Font->AddGlyph(NULL, (ImWchar)r->GlyphID, r->GlyphOffset.x, r->GlyphOffset.y, r->GlyphOffset.x + r->Width, r->GlyphOffset.y + r->Height, uv0.x, uv0.y, uv1.x, uv1.y, r->GlyphAdvanceX);

	movss	xmm8, DWORD PTR [rdi+r10+20]
	movss	xmm3, DWORD PTR [rdi+r10+16]

; 2293 :     *out_uv_max = ImVec2((float)(rect->X + rect->Width) * TexUvScale.x, (float)(rect->Y + rect->Height) * TexUvScale.y);

	lea	eax, DWORD PTR [rdx+rcx]

; 2855 :             continue;
; 2856 : 
; 2857 :         // Will ignore ImFontConfig settings: GlyphMinAdvanceX, GlyphMinAdvanceY, GlyphExtraSpacing, PixelSnapH
; 2858 :         IM_ASSERT(r->Font->ContainerAtlas == atlas);
; 2859 :         ImVec2 uv0, uv1;
; 2860 :         atlas->CalcCustomRectUV(r, &uv0, &uv1);
; 2861 :         r->Font->AddGlyph(NULL, (ImWchar)r->GlyphID, r->GlyphOffset.x, r->GlyphOffset.y, r->GlyphOffset.x + r->Width, r->GlyphOffset.y + r->Height, uv0.x, uv0.y, uv1.x, uv1.y, r->GlyphAdvanceX);

	movss	xmm0, DWORD PTR [rdi+r10+12]
	movss	DWORD PTR [rsp+88], xmm0
	movd	xmm7, eax

; 2293 :     *out_uv_max = ImVec2((float)(rect->X + rect->Width) * TexUvScale.x, (float)(rect->Y + rect->Height) * TexUvScale.y);

	lea	eax, DWORD PTR [r9+r8]
	movd	xmm5, ecx

; 2855 :             continue;
; 2856 : 
; 2857 :         // Will ignore ImFontConfig settings: GlyphMinAdvanceX, GlyphMinAdvanceY, GlyphExtraSpacing, PixelSnapH
; 2858 :         IM_ASSERT(r->Font->ContainerAtlas == atlas);
; 2859 :         ImVec2 uv0, uv1;
; 2860 :         atlas->CalcCustomRectUV(r, &uv0, &uv1);
; 2861 :         r->Font->AddGlyph(NULL, (ImWchar)r->GlyphID, r->GlyphOffset.x, r->GlyphOffset.y, r->GlyphOffset.x + r->Width, r->GlyphOffset.y + r->Height, uv0.x, uv0.y, uv1.x, uv1.y, r->GlyphAdvanceX);

	mov	rcx, r14
	movd	xmm4, r8d
	movzx	r8d, r11w
	movd	xmm2, edx
	xor	edx, edx
	movd	xmm6, eax

; 2293 :     *out_uv_max = ImVec2((float)(rect->X + rect->Width) * TexUvScale.x, (float)(rect->Y + rect->Height) * TexUvScale.y);

	cvtdq2ps xmm7, xmm7
	cvtdq2ps xmm6, xmm6
	mulss	xmm7, DWORD PTR [rbx+76]
	mulss	xmm6, DWORD PTR [rbx+72]

; 2855 :             continue;
; 2856 : 
; 2857 :         // Will ignore ImFontConfig settings: GlyphMinAdvanceX, GlyphMinAdvanceY, GlyphExtraSpacing, PixelSnapH
; 2858 :         IM_ASSERT(r->Font->ContainerAtlas == atlas);
; 2859 :         ImVec2 uv0, uv1;
; 2860 :         atlas->CalcCustomRectUV(r, &uv0, &uv1);
; 2861 :         r->Font->AddGlyph(NULL, (ImWchar)r->GlyphID, r->GlyphOffset.x, r->GlyphOffset.y, r->GlyphOffset.x + r->Width, r->GlyphOffset.y + r->Height, uv0.x, uv0.y, uv1.x, uv1.y, r->GlyphAdvanceX);

	movss	DWORD PTR [rsp+80], xmm7

; 2292 :     *out_uv_min = ImVec2((float)rect->X * TexUvScale.x, (float)rect->Y * TexUvScale.y);

	cvtdq2ps xmm5, xmm5

; 2855 :             continue;
; 2856 : 
; 2857 :         // Will ignore ImFontConfig settings: GlyphMinAdvanceX, GlyphMinAdvanceY, GlyphExtraSpacing, PixelSnapH
; 2858 :         IM_ASSERT(r->Font->ContainerAtlas == atlas);
; 2859 :         ImVec2 uv0, uv1;
; 2860 :         atlas->CalcCustomRectUV(r, &uv0, &uv1);
; 2861 :         r->Font->AddGlyph(NULL, (ImWchar)r->GlyphID, r->GlyphOffset.x, r->GlyphOffset.y, r->GlyphOffset.x + r->Width, r->GlyphOffset.y + r->Height, uv0.x, uv0.y, uv1.x, uv1.y, r->GlyphAdvanceX);

	movss	DWORD PTR [rsp+72], xmm6

; 2292 :     *out_uv_min = ImVec2((float)rect->X * TexUvScale.x, (float)rect->Y * TexUvScale.y);

	mulss	xmm5, DWORD PTR [rbx+76]
	movd	xmm1, r9d
	cvtdq2ps xmm4, xmm4

; 2855 :             continue;
; 2856 : 
; 2857 :         // Will ignore ImFontConfig settings: GlyphMinAdvanceX, GlyphMinAdvanceY, GlyphExtraSpacing, PixelSnapH
; 2858 :         IM_ASSERT(r->Font->ContainerAtlas == atlas);
; 2859 :         ImVec2 uv0, uv1;
; 2860 :         atlas->CalcCustomRectUV(r, &uv0, &uv1);
; 2861 :         r->Font->AddGlyph(NULL, (ImWchar)r->GlyphID, r->GlyphOffset.x, r->GlyphOffset.y, r->GlyphOffset.x + r->Width, r->GlyphOffset.y + r->Height, uv0.x, uv0.y, uv1.x, uv1.y, r->GlyphAdvanceX);

	movss	DWORD PTR [rsp+64], xmm5

; 2292 :     *out_uv_min = ImVec2((float)rect->X * TexUvScale.x, (float)rect->Y * TexUvScale.y);

	mulss	xmm4, DWORD PTR [rbx+72]

; 2855 :             continue;
; 2856 : 
; 2857 :         // Will ignore ImFontConfig settings: GlyphMinAdvanceX, GlyphMinAdvanceY, GlyphExtraSpacing, PixelSnapH
; 2858 :         IM_ASSERT(r->Font->ContainerAtlas == atlas);
; 2859 :         ImVec2 uv0, uv1;
; 2860 :         atlas->CalcCustomRectUV(r, &uv0, &uv1);
; 2861 :         r->Font->AddGlyph(NULL, (ImWchar)r->GlyphID, r->GlyphOffset.x, r->GlyphOffset.y, r->GlyphOffset.x + r->Width, r->GlyphOffset.y + r->Height, uv0.x, uv0.y, uv1.x, uv1.y, r->GlyphAdvanceX);

	cvtdq2ps xmm2, xmm2
	movss	DWORD PTR [rsp+56], xmm4
	cvtdq2ps xmm1, xmm1
	addss	xmm2, xmm8
	addss	xmm1, xmm3
	movss	DWORD PTR [rsp+48], xmm2
	movss	DWORD PTR [rsp+40], xmm1
	movss	DWORD PTR [rsp+32], xmm8
	call	?AddGlyph@ImFont@@QEAAXPEBUImFontConfig@@GMMMMMMMMM@Z ; ImFont::AddGlyph
$LN2@ImFontAtla:

; 2849 : 
; 2850 :     // Register custom rectangle glyphs
; 2851 :     for (int i = 0; i < atlas->CustomRects.Size; i++)

	inc	ebp
	add	rdi, 32					; 00000020H
	cmp	ebp, DWORD PTR [rbx+104]
	jl	$LL4@ImFontAtla
	movaps	xmm8, XMMWORD PTR [rsp+96]
	movaps	xmm7, XMMWORD PTR [rsp+112]
	movaps	xmm6, XMMWORD PTR [rsp+128]
	mov	r14, QWORD PTR [rsp+168]
$LN3@ImFontAtla:

; 2862 :     }
; 2863 : 
; 2864 :     // Build all fonts lookup tables
; 2865 :     for (int i = 0; i < atlas->Fonts.Size; i++)

	mov	rbp, QWORD PTR [rsp+160]
	cmp	DWORD PTR [rbx+88], esi
	jle	SHORT $LN36@ImFontAtla
	mov	rdi, rsi
	npad	7
$LL7@ImFontAtla:

; 2866 :         if (atlas->Fonts[i]->DirtyLookupTables)

	mov	rax, QWORD PTR [rbx+96]
	mov	rcx, QWORD PTR [rdi+rax]
	cmp	BYTE PTR [rcx+96], 0
	je	SHORT $LN5@ImFontAtla

; 2867 :             atlas->Fonts[i]->BuildLookupTable();

	call	?BuildLookupTable@ImFont@@QEAAXXZ	; ImFont::BuildLookupTable
$LN5@ImFontAtla:

; 2862 :     }
; 2863 : 
; 2864 :     // Build all fonts lookup tables
; 2865 :     for (int i = 0; i < atlas->Fonts.Size; i++)

	inc	esi
	add	rdi, 8
	cmp	esi, DWORD PTR [rbx+88]
	jl	SHORT $LL7@ImFontAtla
$LN36@ImFontAtla:

; 2868 : 
; 2869 :     atlas->TexReady = true;
; 2870 : }

	lea	r11, QWORD PTR [rsp+144]
	mov	BYTE PTR [rbx+40], 1
	mov	rbx, QWORD PTR [r11+32]
	mov	rsi, QWORD PTR [r11+40]
	mov	rsp, r11
	pop	rdi
	ret	0
?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z ENDP	; ImFontAtlasBuildFinish
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?GetGlyphRangesDefault@ImFontAtlas@@QEAAPEBGXZ
_TEXT	SEGMENT
this$dead$ = 8
?GetGlyphRangesDefault@ImFontAtlas@@QEAAPEBGXZ PROC	; ImFontAtlas::GetGlyphRangesDefault, COMDAT

; 2875 :     static const ImWchar ranges[] =
; 2876 :     {
; 2877 :         0x0020, 0x00FF, // Basic Latin + Latin Supplement
; 2878 :         0,
; 2879 :     };
; 2880 :     return &ranges[0];

	lea	rax, OFFSET FLAT:?ranges@?1??GetGlyphRangesDefault@ImFontAtlas@@QEAAPEBGXZ@4QBGB

; 2881 : }

	ret	0
?GetGlyphRangesDefault@ImFontAtlas@@QEAAPEBGXZ ENDP	; ImFontAtlas::GetGlyphRangesDefault
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?ClearOutputData@ImFont@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?ClearOutputData@ImFont@@QEAAXXZ PROC			; ImFont::ClearOutputData, COMDAT

; 3204 : {

$LN43:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 3205 :     FontSize = 0.0f;

	xor	edi, edi
	mov	rbx, rcx

; 3206 :     FallbackAdvanceX = 0.0f;

	mov	QWORD PTR [rcx+16], rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	rcx, QWORD PTR [rcx+48]
	test	rcx, rcx
	je	SHORT $LN4@ClearOutpu
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx+40], rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN8@ClearOutpu

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN8@ClearOutpu:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx+48], rdi
$LN4@ClearOutpu:
	mov	rcx, QWORD PTR [rbx+8]
	test	rcx, rcx
	je	SHORT $LN15@ClearOutpu
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx], rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN19@ClearOutpu

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN19@ClearOutpu:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx+8], rdi
$LN15@ClearOutpu:
	mov	rcx, QWORD PTR [rbx+32]
	test	rcx, rcx
	je	SHORT $LN26@ClearOutpu
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx+24], rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN30@ClearOutpu

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN30@ClearOutpu:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx+32], rdi
$LN26@ClearOutpu:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3210 :     FallbackGlyph = NULL;

	mov	QWORD PTR [rbx+56], rdi

; 3211 :     ContainerAtlas = NULL;

	mov	QWORD PTR [rbx+64], rdi

; 3212 :     DirtyLookupTables = true;

	mov	BYTE PTR [rbx+96], 1

; 3213 :     Ascent = Descent = 0.0f;

	mov	QWORD PTR [rbx+104], rdi

; 3214 :     MetricsTotalSurface = 0;

	mov	DWORD PTR [rbx+112], edi

; 3215 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?ClearOutputData@ImFont@@QEAAXXZ ENDP			; ImFont::ClearOutputData
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?FindFirstExistingGlyph@@YAGPEAUImFont@@PEBGH@Z
_TEXT	SEGMENT
font$ = 8
candidate_chars$ = 16
candidate_chars_count$ = 24
?FindFirstExistingGlyph@@YAGPEAUImFont@@PEBGH@Z PROC	; FindFirstExistingGlyph, COMDAT

; 3218 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rdi
	mov	r11, rdx
	mov	r9, rcx

; 3219 :     for (int n = 0; n < candidate_chars_count; n++)

	mov	edi, 65535				; 0000ffffH
	test	r8d, r8d
	jle	SHORT $LN17@FindFirstE
	movsxd	rbx, DWORD PTR [rcx+24]
	xor	eax, eax
	movsxd	r10, r8d
$LL4@FindFirstE:

; 3220 :         if (font->FindGlyphNoFallback(candidate_chars[n]) != NULL)

	movzx	r8d, WORD PTR [r11+rax*2]

; 3410 :     if (c >= (size_t)IndexLookup.Size)

	cmp	r8, rbx
	jae	SHORT $LN16@FindFirstE

; 3411 :         return NULL;
; 3412 :     const ImWchar i = IndexLookup.Data[c];

	mov	rcx, QWORD PTR [r9+32]
	movzx	edx, WORD PTR [rcx+r8*2]

; 3413 :     if (i == (ImWchar)-1)

	cmp	dx, di
	je	SHORT $LN16@FindFirstE

; 3414 :         return NULL;
; 3415 :     return &Glyphs.Data[i];

	mov	rcx, QWORD PTR [r9+48]
	lea	rdx, QWORD PTR [rdx+rdx*4]
	lea	rdx, QWORD PTR [rcx+rdx*8]

; 3220 :         if (font->FindGlyphNoFallback(candidate_chars[n]) != NULL)

	test	rdx, rdx
	jne	SHORT $LN12@FindFirstE
$LN16@FindFirstE:

; 3219 :     for (int n = 0; n < candidate_chars_count; n++)

	inc	rax
	cmp	rax, r10
	jl	SHORT $LL4@FindFirstE
$LN17@FindFirstE:

; 3221 :             return candidate_chars[n];
; 3222 :     return (ImWchar)-1;

	movzx	eax, di

; 3223 : }

	mov	rbx, QWORD PTR [rsp+8]
	mov	rdi, QWORD PTR [rsp+16]
	ret	0
$LN12@FindFirstE:
	mov	rbx, QWORD PTR [rsp+8]
	movzx	eax, r8w
	mov	rdi, QWORD PTR [rsp+16]
	ret	0
?FindFirstExistingGlyph@@YAGPEAUImFont@@PEBGH@Z ENDP	; FindFirstExistingGlyph
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?BuildLookupTable@ImFont@@QEAAXXZ
_TEXT	SEGMENT
ellipsis_chars$ = 32
dots_chars$ = 36
fallback_chars$ = 36
__$ArrayPad$ = 48
this$ = 96
?BuildLookupTable@ImFont@@QEAAXXZ PROC			; ImFont::BuildLookupTable, COMDAT

; 3226 : {

$LN264:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 64					; 00000040H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 3227 :     int max_codepoint = 0;
; 3228 :     for (int i = 0; i != Glyphs.Size; i++)

	mov	eax, DWORD PTR [rcx+40]
	xor	edi, edi
	mov	rbx, rcx
	mov	esi, edi
	test	eax, eax
	je	SHORT $LN184@BuildLooku
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	rcx, QWORD PTR [rcx+48]
	mov	edx, eax
	npad	5
$LL4@BuildLooku:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3229 :         max_codepoint = ImMax(max_codepoint, (int)Glyphs[i].Codepoint);

	mov	eax, DWORD PTR [rcx]
	lea	rcx, QWORD PTR [rcx+40]
	shr	eax, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	cmp	esi, eax
	cmovge	eax, esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3229 :         max_codepoint = ImMax(max_codepoint, (int)Glyphs[i].Codepoint);

	mov	esi, eax
	sub	rdx, 1
	jne	SHORT $LL4@BuildLooku
$LN184@BuildLooku:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	rcx, QWORD PTR [rbx+8]
	test	rcx, rcx
	je	SHORT $LN116@BuildLooku
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx], rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN120@BuildLooku

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN120@BuildLooku:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx+8], rdi
$LN116@BuildLooku:
	mov	rcx, QWORD PTR [rbx+32]
	test	rcx, rcx
	je	SHORT $LN127@BuildLooku
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx+24], rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN131@BuildLooku

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN131@BuildLooku:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx+32], rdi
$LN127@BuildLooku:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3236 :     memset(Used4kPagesMap, 0, sizeof(Used4kPagesMap));

	xor	eax, eax
	mov	BYTE PTR [rbx+96], dil

; 3237 :     GrowIndex(max_codepoint + 1);

	inc	esi
	mov	WORD PTR [rbx+116], ax
	mov	edx, esi
	mov	rcx, rbx
	call	?GrowIndex@ImFont@@QEAAXH@Z		; ImFont::GrowIndex

; 3238 :     for (int i = 0; i < Glyphs.Size; i++)

	mov	r10d, DWORD PTR [rbx+40]
	mov	r9d, edi
	test	r10d, r10d
	jle	SHORT $LN185@BuildLooku
	npad	7
$LL7@BuildLooku:

; 3240 :         int codepoint = (int)Glyphs[i].Codepoint;

	mov	rcx, QWORD PTR [rbx+48]

; 3241 :         IndexAdvanceX[codepoint] = Glyphs[i].AdvanceX;

	mov	rdx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rax, r9d
	lea	r8, QWORD PTR [rax+rax*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3240 :         int codepoint = (int)Glyphs[i].Codepoint;

	mov	eax, DWORD PTR [rcx+r8*8]

; 3241 :         IndexAdvanceX[codepoint] = Glyphs[i].AdvanceX;

	mov	ecx, DWORD PTR [rcx+r8*8+4]
	shr	eax, 2
	mov	DWORD PTR [rdx+rax*4], ecx

; 3242 :         IndexLookup[codepoint] = (ImWchar)i;

	mov	rcx, QWORD PTR [rbx+32]
	mov	WORD PTR [rcx+rax*2], r9w

; 3243 : 
; 3244 :         // Mark 4K page as used
; 3245 :         const int page_n = codepoint / 4096;

	cdq
	and	edx, 4095				; 00000fffH
	inc	r9d
	add	eax, edx
	sar	eax, 12

; 3246 :         Used4kPagesMap[page_n >> 3] |= 1 << (page_n & 7);

	movsxd	rdx, eax
	and	eax, 7
	sar	rdx, 3
	movzx	ecx, BYTE PTR [rdx+rbx+116]
	bts	ecx, eax
	mov	BYTE PTR [rdx+rbx+116], cl
	mov	r10d, DWORD PTR [rbx+40]
	cmp	r9d, r10d
	jl	SHORT $LL7@BuildLooku
$LN185@BuildLooku:

; 3400 :     if (c >= (size_t)IndexLookup.Size)

	cmp	DWORD PTR [rbx+24], 32			; 00000020H
	mov	ebp, 65535				; 0000ffffH
	ja	SHORT $LN62@BuildLooku

; 3401 :         return FallbackGlyph;

	mov	rax, QWORD PTR [rbx+56]
	mov	r8, rax
	jmp	SHORT $LN61@BuildLooku
$LN62@BuildLooku:

; 3402 :     const ImWchar i = IndexLookup.Data[c];

	mov	rax, QWORD PTR [rbx+32]
	mov	r8, QWORD PTR [rbx+56]
	movzx	ecx, WORD PTR [rax+64]

; 3403 :     if (i == (ImWchar)-1)

	cmp	cx, bp
	jne	SHORT $LN63@BuildLooku

; 3404 :         return FallbackGlyph;

	mov	rax, r8
	jmp	SHORT $LN61@BuildLooku
$LN63@BuildLooku:

; 3405 :     return &Glyphs.Data[i];

	mov	rax, QWORD PTR [rbx+48]
	lea	rcx, QWORD PTR [rcx+rcx*4]
	lea	rax, QWORD PTR [rax+rcx*8]
$LN61@BuildLooku:

; 3247 :     }
; 3248 : 
; 3249 :     // Create a glyph to handle TAB
; 3250 :     // FIXME: Needs proper TAB handling but it needs to be contextualized (or we could arbitrary say that each string starts at "column 0" ?)
; 3251 :     if (FindGlyph((ImWchar)' '))

	test	rax, rax
	je	$LN11@BuildLooku
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	movsxd	rax, r10d
	lea	rcx, QWORD PTR [rax+rax*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3253 :         if (Glyphs.back().Codepoint != '\t')   // So we can call this function multiple times (FIXME: Flaky)

	mov	rax, QWORD PTR [rbx+48]
	mov	edx, DWORD PTR [rax+rcx*8-40]
	and	edx, -4					; fffffffcH
	cmp	edx, 36					; 00000024H
	je	SHORT $LN12@BuildLooku

; 3254 :             Glyphs.resize(Glyphs.Size + 1);

	lea	edx, DWORD PTR [r10+1]
	lea	rcx, QWORD PTR [rbx+40]
	call	?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z ; ImVector<ImFontGlyph>::resize
	mov	r8, QWORD PTR [rbx+56]
$LN12@BuildLooku:

; 3400 :     if (c >= (size_t)IndexLookup.Size)

	cmp	DWORD PTR [rbx+24], 32			; 00000020H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	movsxd	rax, DWORD PTR [rbx+40]
	mov	r10, QWORD PTR [rbx+48]
	lea	r9, QWORD PTR [rax+rax*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3400 :     if (c >= (size_t)IndexLookup.Size)

	jbe	SHORT $LN87@BuildLooku

; 3402 :     const ImWchar i = IndexLookup.Data[c];

	mov	rax, QWORD PTR [rbx+32]
	movzx	ecx, WORD PTR [rax+64]

; 3403 :     if (i == (ImWchar)-1)

	cmp	cx, bp
	je	SHORT $LN87@BuildLooku

; 3405 :     return &Glyphs.Data[i];

	mov	rax, r10
	lea	rcx, QWORD PTR [rcx+rcx*4]
	lea	r8, QWORD PTR [rax+rcx*8]
$LN87@BuildLooku:

; 3255 :         ImFontGlyph& tab_glyph = Glyphs.back();
; 3256 :         tab_glyph = *FindGlyph((ImWchar)' ');

	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [r10+r9*8-40], xmm0
	movups	xmm1, XMMWORD PTR [r8+16]
	movups	XMMWORD PTR [r10+r9*8-24], xmm1
	movsd	xmm0, QWORD PTR [r8+32]
	movsd	QWORD PTR [r10+r9*8-8], xmm0

; 3257 :         tab_glyph.Codepoint = '\t';

	mov	ecx, DWORD PTR [r10+r9*8-40]

; 3258 :         tab_glyph.AdvanceX *= IM_TABSIZE;

	movss	xmm0, DWORD PTR [r10+r9*8-36]
	and	ecx, 3
	mulss	xmm0, DWORD PTR __real@40800000
	or	ecx, 36					; 00000024H
	mov	DWORD PTR [r10+r9*8-40], ecx

; 3259 :         IndexAdvanceX[(int)tab_glyph.Codepoint] = (float)tab_glyph.AdvanceX;

	shr	rcx, 2
	movss	DWORD PTR [r10+r9*8-36], xmm0
	mov	rax, QWORD PTR [rbx+8]
	movss	DWORD PTR [rax+rcx*4], xmm0

; 3260 :         IndexLookup[(int)tab_glyph.Codepoint] = (ImWchar)(Glyphs.Size - 1);

	movzx	edx, WORD PTR [rbx+40]
	mov	ecx, DWORD PTR [r10+r9*8-40]
	dec	dx
	mov	rax, QWORD PTR [rbx+32]
	shr	rcx, 2
	mov	WORD PTR [rax+rcx*2], dx
	mov	r8, QWORD PTR [rbx+56]
$LN11@BuildLooku:

; 3400 :     if (c >= (size_t)IndexLookup.Size)

	cmp	DWORD PTR [rbx+24], 32			; 00000020H
	ja	SHORT $LN69@BuildLooku

; 3401 :         return FallbackGlyph;

	mov	rax, r8
	jmp	SHORT $LN68@BuildLooku
$LN69@BuildLooku:

; 3402 :     const ImWchar i = IndexLookup.Data[c];

	mov	rax, QWORD PTR [rbx+32]
	movzx	ecx, WORD PTR [rax+64]

; 3403 :     if (i == (ImWchar)-1)

	cmp	cx, bp
	jne	SHORT $LN70@BuildLooku

; 3404 :         return FallbackGlyph;

	mov	rax, r8
	jmp	SHORT $LN68@BuildLooku
$LN70@BuildLooku:

; 3405 :     return &Glyphs.Data[i];

	mov	rax, QWORD PTR [rbx+48]
	lea	rcx, QWORD PTR [rcx+rcx*4]
	lea	rax, QWORD PTR [rax+rcx*8]
$LN68@BuildLooku:

; 3323 :     if (ImFontGlyph* glyph = (ImFontGlyph*)(void*)FindGlyph((ImWchar)c))

	test	rax, rax
	je	SHORT $LN66@BuildLooku

; 3324 :         glyph->Visible = visible ? 1 : 0;

	and	DWORD PTR [rax], -3			; fffffffdH
	mov	r8, QWORD PTR [rbx+56]
$LN66@BuildLooku:

; 3400 :     if (c >= (size_t)IndexLookup.Size)

	cmp	DWORD PTR [rbx+24], 9
	jbe	SHORT $LN75@BuildLooku

; 3402 :     const ImWchar i = IndexLookup.Data[c];

	mov	rax, QWORD PTR [rbx+32]
	movzx	ecx, WORD PTR [rax+18]

; 3403 :     if (i == (ImWchar)-1)

	cmp	cx, bp
	je	SHORT $LN75@BuildLooku

; 3405 :     return &Glyphs.Data[i];

	mov	rax, QWORD PTR [rbx+48]
	lea	rcx, QWORD PTR [rcx+rcx*4]
	lea	r8, QWORD PTR [rax+rcx*8]
$LN75@BuildLooku:

; 3323 :     if (ImFontGlyph* glyph = (ImFontGlyph*)(void*)FindGlyph((ImWchar)c))

	test	r8, r8
	je	SHORT $LN73@BuildLooku

; 3324 :         glyph->Visible = visible ? 1 : 0;

	and	DWORD PTR [r8], -3			; fffffffdH
$LN73@BuildLooku:

; 3410 :     if (c >= (size_t)IndexLookup.Size)

	movsxd	r9, DWORD PTR [rbx+24]

; 3261 :     }
; 3262 : 
; 3263 :     // Mark special glyphs as not visible (note that AddGlyph already mark as non-visible glyphs with zero-size polygons)
; 3264 :     SetGlyphVisible((ImWchar)' ', false);
; 3265 :     SetGlyphVisible((ImWchar)'\t', false);
; 3266 : 
; 3267 :     // Setup Fallback character
; 3268 :     const ImWchar fallback_chars[] = { (ImWchar)IM_UNICODE_CODEPOINT_INVALID, (ImWchar)'?', (ImWchar)' ' };

	mov	eax, 32					; 00000020H

; 3410 :     if (c >= (size_t)IndexLookup.Size)

	movzx	ecx, WORD PTR [rbx+82]

; 3261 :     }
; 3262 : 
; 3263 :     // Mark special glyphs as not visible (note that AddGlyph already mark as non-visible glyphs with zero-size polygons)
; 3264 :     SetGlyphVisible((ImWchar)' ', false);
; 3265 :     SetGlyphVisible((ImWchar)'\t', false);
; 3266 : 
; 3267 :     // Setup Fallback character
; 3268 :     const ImWchar fallback_chars[] = { (ImWchar)IM_UNICODE_CODEPOINT_INVALID, (ImWchar)'?', (ImWchar)' ' };

	mov	DWORD PTR fallback_chars$[rsp], 4194301	; 003ffffdH
	mov	WORD PTR fallback_chars$[rsp+4], ax

; 3410 :     if (c >= (size_t)IndexLookup.Size)

	cmp	rcx, r9
	jae	SHORT $LN191@BuildLooku

; 3411 :         return NULL;
; 3412 :     const ImWchar i = IndexLookup.Data[c];

	mov	rax, QWORD PTR [rbx+32]
	movzx	ecx, WORD PTR [rax+rcx*2]

; 3413 :     if (i == (ImWchar)-1)

	cmp	cx, bp
	je	SHORT $LN191@BuildLooku

; 3415 :     return &Glyphs.Data[i];

	mov	rax, QWORD PTR [rbx+48]
	lea	rcx, QWORD PTR [rcx+rcx*4]
	lea	rdx, QWORD PTR [rax+rcx*8]

; 3269 :     FallbackGlyph = FindGlyphNoFallback(FallbackChar);

	mov	QWORD PTR [rbx+56], rdx

; 3270 :     if (FallbackGlyph == NULL)

	test	rdx, rdx
	jne	$LN14@BuildLooku
	jmp	SHORT $LN188@BuildLooku
$LN191@BuildLooku:

; 3414 :         return NULL;

	mov	QWORD PTR [rbx+56], rdi
$LN188@BuildLooku:

; 3415 :     return &Glyphs.Data[i];

	mov	rdx, rdi
$LL98@BuildLooku:

; 3220 :         if (font->FindGlyphNoFallback(candidate_chars[n]) != NULL)

	movzx	r8d, WORD PTR fallback_chars$[rsp+rdx*2]

; 3410 :     if (c >= (size_t)IndexLookup.Size)

	cmp	r8, r9
	jae	SHORT $LN178@BuildLooku

; 3411 :         return NULL;
; 3412 :     const ImWchar i = IndexLookup.Data[c];

	mov	rax, QWORD PTR [rbx+32]
	movzx	ecx, WORD PTR [rax+r8*2]

; 3413 :     if (i == (ImWchar)-1)

	cmp	cx, bp
	je	SHORT $LN178@BuildLooku

; 3415 :     return &Glyphs.Data[i];

	mov	rax, QWORD PTR [rbx+48]
	lea	rcx, QWORD PTR [rcx+rcx*4]
	lea	rcx, QWORD PTR [rax+rcx*8]

; 3220 :         if (font->FindGlyphNoFallback(candidate_chars[n]) != NULL)

	test	rcx, rcx
	jne	SHORT $LN95@BuildLooku
$LN178@BuildLooku:

; 3219 :     for (int n = 0; n < candidate_chars_count; n++)

	inc	rdx
	cmp	rdx, 3
	jl	SHORT $LL98@BuildLooku

; 3221 :             return candidate_chars[n];
; 3222 :     return (ImWchar)-1;

	movzx	r8d, bp
$LN95@BuildLooku:

; 3410 :     if (c >= (size_t)IndexLookup.Size)

	movzx	ecx, r8w

; 3271 :     {
; 3272 :         FallbackChar = FindFirstExistingGlyph(this, fallback_chars, IM_ARRAYSIZE(fallback_chars));

	mov	WORD PTR [rbx+82], r8w

; 3410 :     if (c >= (size_t)IndexLookup.Size)

	cmp	rcx, r9
	jae	SHORT $LN189@BuildLooku

; 3411 :         return NULL;
; 3412 :     const ImWchar i = IndexLookup.Data[c];

	mov	rax, QWORD PTR [rbx+32]
	movzx	edx, WORD PTR [rax+rcx*2]

; 3413 :     if (i == (ImWchar)-1)

	cmp	dx, bp
	je	SHORT $LN189@BuildLooku

; 3415 :     return &Glyphs.Data[i];

	mov	rax, QWORD PTR [rbx+48]
	lea	rcx, QWORD PTR [rdx+rdx*4]
	lea	rdx, QWORD PTR [rax+rcx*8]

; 3273 :         FallbackGlyph = FindGlyphNoFallback(FallbackChar);

	mov	QWORD PTR [rbx+56], rdx

; 3274 :         if (FallbackGlyph == NULL)

	test	rdx, rdx
	jne	SHORT $LN14@BuildLooku
	jmp	SHORT $LN187@BuildLooku
$LN189@BuildLooku:

; 3414 :         return NULL;

	mov	QWORD PTR [rbx+56], rdi
$LN187@BuildLooku:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	movsxd	rax, DWORD PTR [rbx+40]
	lea	rdx, QWORD PTR [rax+rax*4]
	mov	rax, QWORD PTR [rbx+48]
	lea	rdx, QWORD PTR [rdx-5]
	lea	rdx, QWORD PTR [rax+rdx*8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3276 :             FallbackGlyph = &Glyphs.back();

	mov	QWORD PTR [rbx+56], rdx

; 3277 :             FallbackChar = (ImWchar)FallbackGlyph->Codepoint;

	mov	eax, DWORD PTR [rdx]
	shr	eax, 2
	mov	WORD PTR [rbx+82], ax
$LN14@BuildLooku:

; 3278 :         }
; 3279 :     }
; 3280 :     FallbackAdvanceX = FallbackGlyph->AdvanceX;

	mov	eax, DWORD PTR [rdx+4]
	xorps	xmm0, xmm0

; 3281 :     for (int i = 0; i < max_codepoint + 1; i++)

	movsxd	r10, esi
	mov	rdx, rdi
	mov	DWORD PTR [rbx+16], eax
	cmp	r10, 4
	jl	SHORT $LC159@BuildLooku
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	r9, QWORD PTR [rbx+8]
	lea	r8, QWORD PTR [r10-4]
	shr	r8, 2
	inc	r8
	lea	rcx, QWORD PTR [r9+8]
	lea	rdx, QWORD PTR [r8*4]
$LL164@BuildLooku:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3282 :         if (IndexAdvanceX[i] < 0.0f)

	comiss	xmm0, DWORD PTR [rcx-8]
	jbe	SHORT $LN160@BuildLooku

; 3283 :             IndexAdvanceX[i] = FallbackAdvanceX;

	mov	eax, DWORD PTR [rbx+16]
	mov	DWORD PTR [rcx-8], eax
$LN160@BuildLooku:

; 3282 :         if (IndexAdvanceX[i] < 0.0f)

	comiss	xmm0, DWORD PTR [rcx-4]
	jbe	SHORT $LN161@BuildLooku

; 3283 :             IndexAdvanceX[i] = FallbackAdvanceX;

	mov	eax, DWORD PTR [rbx+16]
	mov	DWORD PTR [rcx-4], eax
$LN161@BuildLooku:

; 3282 :         if (IndexAdvanceX[i] < 0.0f)

	comiss	xmm0, DWORD PTR [rcx]
	jbe	SHORT $LN162@BuildLooku

; 3283 :             IndexAdvanceX[i] = FallbackAdvanceX;

	mov	eax, DWORD PTR [rbx+16]
	mov	DWORD PTR [rcx], eax
$LN162@BuildLooku:

; 3282 :         if (IndexAdvanceX[i] < 0.0f)

	comiss	xmm0, DWORD PTR [rcx+4]
	jbe	SHORT $LN163@BuildLooku

; 3283 :             IndexAdvanceX[i] = FallbackAdvanceX;

	mov	eax, DWORD PTR [rbx+16]
	mov	DWORD PTR [rcx+4], eax
$LN163@BuildLooku:
	add	rcx, 16
	sub	r8, 1
	jne	SHORT $LL164@BuildLooku

; 3281 :     for (int i = 0; i < max_codepoint + 1; i++)

	jmp	SHORT $LN260@BuildLooku
$LC159@BuildLooku:
	test	esi, esi
	jle	SHORT $LN158@BuildLooku
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	r9, QWORD PTR [rbx+8]
$LL208@BuildLooku:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3282 :         if (IndexAdvanceX[i] < 0.0f)

	comiss	xmm0, DWORD PTR [r9+rdx*4]
	jbe	SHORT $LN8@BuildLooku

; 3283 :             IndexAdvanceX[i] = FallbackAdvanceX;

	mov	eax, DWORD PTR [rbx+16]
	mov	DWORD PTR [r9+rdx*4], eax
$LN8@BuildLooku:

; 3281 :     for (int i = 0; i < max_codepoint + 1; i++)

	inc	rdx
$LN260@BuildLooku:

; 3284 : 
; 3285 :     // Setup Ellipsis character. It is required for rendering elided text. We prefer using U+2026 (horizontal ellipsis).
; 3286 :     // However some old fonts may contain ellipsis at U+0085. Here we auto-detect most suitable ellipsis character.
; 3287 :     // FIXME: Note that 0x2026 is rarely included in our font ranges. Because of this we are more likely to use three individual dots.
; 3288 :     const ImWchar ellipsis_chars[] = { (ImWchar)0x2026, (ImWchar)0x0085 };

	cmp	rdx, r10
	jl	SHORT $LL208@BuildLooku
$LN158@BuildLooku:
	mov	DWORD PTR ellipsis_chars$[rsp], 8724518	; 00852026H

; 3289 :     const ImWchar dots_chars[] = { (ImWchar)'.', (ImWchar)0xFF0E };

	mov	DWORD PTR dots_chars$[rsp], -15859666	; ff0e002eH

; 3290 :     if (EllipsisChar == (ImWchar)-1)

	cmp	WORD PTR [rbx+84], bp
	jne	SHORT $LN16@BuildLooku
	movsxd	r9, DWORD PTR [rbx+24]

; 3415 :     return &Glyphs.Data[i];

	mov	rdx, rdi
$LL38@BuildLooku:

; 3220 :         if (font->FindGlyphNoFallback(candidate_chars[n]) != NULL)

	movzx	r8d, WORD PTR ellipsis_chars$[rsp+rdx*2]

; 3410 :     if (c >= (size_t)IndexLookup.Size)

	cmp	r8, r9
	jae	SHORT $LN179@BuildLooku

; 3411 :         return NULL;
; 3412 :     const ImWchar i = IndexLookup.Data[c];

	mov	rax, QWORD PTR [rbx+32]
	movzx	ecx, WORD PTR [rax+r8*2]

; 3413 :     if (i == (ImWchar)-1)

	cmp	cx, bp
	je	SHORT $LN179@BuildLooku

; 3415 :     return &Glyphs.Data[i];

	mov	rax, QWORD PTR [rbx+48]
	lea	rcx, QWORD PTR [rcx+rcx*4]
	lea	rcx, QWORD PTR [rax+rcx*8]

; 3220 :         if (font->FindGlyphNoFallback(candidate_chars[n]) != NULL)

	test	rcx, rcx
	jne	SHORT $LN35@BuildLooku
$LN179@BuildLooku:

; 3219 :     for (int n = 0; n < candidate_chars_count; n++)

	inc	rdx
	cmp	rdx, 2
	jl	SHORT $LL38@BuildLooku

; 3221 :             return candidate_chars[n];
; 3222 :     return (ImWchar)-1;

	movzx	r8d, bp
$LN35@BuildLooku:

; 3291 :         EllipsisChar = FindFirstExistingGlyph(this, ellipsis_chars, IM_ARRAYSIZE(ellipsis_chars));

	mov	WORD PTR [rbx+84], r8w
$LN16@BuildLooku:
	movsxd	r8, DWORD PTR [rbx+24]
$LL26@BuildLooku:

; 3220 :         if (font->FindGlyphNoFallback(candidate_chars[n]) != NULL)

	movzx	edx, WORD PTR dots_chars$[rsp+rdi*2]

; 3410 :     if (c >= (size_t)IndexLookup.Size)

	cmp	rdx, r8
	jae	SHORT $LN180@BuildLooku

; 3411 :         return NULL;
; 3412 :     const ImWchar i = IndexLookup.Data[c];

	mov	rax, QWORD PTR [rbx+32]
	movzx	ecx, WORD PTR [rax+rdx*2]

; 3413 :     if (i == (ImWchar)-1)

	cmp	cx, bp
	je	SHORT $LN180@BuildLooku

; 3415 :     return &Glyphs.Data[i];

	mov	rax, QWORD PTR [rbx+48]
	lea	rcx, QWORD PTR [rcx+rcx*4]
	lea	rcx, QWORD PTR [rax+rcx*8]

; 3220 :         if (font->FindGlyphNoFallback(candidate_chars[n]) != NULL)

	test	rcx, rcx
	jne	SHORT $LN23@BuildLooku
$LN180@BuildLooku:

; 3219 :     for (int n = 0; n < candidate_chars_count; n++)

	inc	rdi
	cmp	rdi, 2
	jl	SHORT $LL26@BuildLooku

; 3221 :             return candidate_chars[n];
; 3222 :     return (ImWchar)-1;

	movzx	edx, bp
$LN23@BuildLooku:

; 3292 :     const ImWchar dot_char = FindFirstExistingGlyph(this, dots_chars, IM_ARRAYSIZE(dots_chars));
; 3293 :     if (EllipsisChar != (ImWchar)-1)

	movzx	eax, WORD PTR [rbx+84]
	cmp	ax, bp
	je	SHORT $LN17@BuildLooku

; 3294 :     {
; 3295 :         EllipsisCharCount = 1;

	mov	WORD PTR [rbx+86], 1

; 3400 :     if (c >= (size_t)IndexLookup.Size)

	mov	ecx, eax
	cmp	rax, r8
	jb	SHORT $LN46@BuildLooku
$LN261@BuildLooku:

; 3296 :         EllipsisWidth = EllipsisCharStep = FindGlyph(EllipsisChar)->X1;

	mov	rax, QWORD PTR [rbx+56]
	movss	xmm0, DWORD PTR [rax+16]
	movss	DWORD PTR [rbx+92], xmm0
	movss	DWORD PTR [rbx+88], xmm0

; 3297 :     }

	jmp	$LN19@BuildLooku
$LN46@BuildLooku:

; 3402 :     const ImWchar i = IndexLookup.Data[c];

	mov	rax, QWORD PTR [rbx+32]
	movzx	ecx, WORD PTR [rax+rcx*2]

; 3403 :     if (i == (ImWchar)-1)

	cmp	cx, bp
	je	SHORT $LN261@BuildLooku

; 3405 :     return &Glyphs.Data[i];

	mov	rax, QWORD PTR [rbx+48]
	lea	rcx, QWORD PTR [rcx+rcx*4]

; 3296 :         EllipsisWidth = EllipsisCharStep = FindGlyph(EllipsisChar)->X1;

	movss	xmm0, DWORD PTR [rax+rcx*8+16]

; 3405 :     return &Glyphs.Data[i];

	lea	rax, QWORD PTR [rax+rcx*8]

; 3296 :         EllipsisWidth = EllipsisCharStep = FindGlyph(EllipsisChar)->X1;

	movss	DWORD PTR [rbx+92], xmm0
	movss	DWORD PTR [rbx+88], xmm0

; 3297 :     }

	jmp	SHORT $LN19@BuildLooku
$LN17@BuildLooku:

; 3298 :     else if (dot_char != (ImWchar)-1)

	cmp	dx, bp
	je	SHORT $LN19@BuildLooku

; 3400 :     if (c >= (size_t)IndexLookup.Size)

	movzx	ecx, dx
	cmp	rcx, r8
	jb	SHORT $LN50@BuildLooku
$LN262@BuildLooku:

; 3299 :     {
; 3300 :         const ImFontGlyph* glyph = FindGlyph(dot_char);
; 3301 :         EllipsisChar = dot_char;

	mov	rax, QWORD PTR [rbx+56]
	jmp	SHORT $LN49@BuildLooku
$LN50@BuildLooku:

; 3402 :     const ImWchar i = IndexLookup.Data[c];

	mov	rax, QWORD PTR [rbx+32]
	movzx	r8d, WORD PTR [rax+rcx*2]

; 3403 :     if (i == (ImWchar)-1)

	cmp	r8w, bp
	je	SHORT $LN262@BuildLooku

; 3405 :     return &Glyphs.Data[i];

	mov	rax, QWORD PTR [rbx+48]
	lea	rcx, QWORD PTR [r8+r8*4]
	lea	rax, QWORD PTR [rax+rcx*8]
$LN49@BuildLooku:

; 3299 :     {
; 3300 :         const ImFontGlyph* glyph = FindGlyph(dot_char);
; 3301 :         EllipsisChar = dot_char;

	mov	WORD PTR [rbx+84], dx

; 3302 :         EllipsisCharCount = 3;

	mov	WORD PTR [rbx+86], 3

; 3303 :         EllipsisCharStep = (glyph->X1 - glyph->X0) + 1.0f;

	movss	xmm1, DWORD PTR [rax+16]
	subss	xmm1, DWORD PTR [rax+8]
	addss	xmm1, DWORD PTR __real@3f800000
	movss	DWORD PTR [rbx+92], xmm1

; 3304 :         EllipsisWidth = EllipsisCharStep * 3.0f - 1.0f;

	mulss	xmm1, DWORD PTR __real@40400000
	subss	xmm1, DWORD PTR __real@3f800000
	movss	DWORD PTR [rbx+88], xmm1
$LN19@BuildLooku:

; 3305 :     }
; 3306 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+104]
	mov	rbp, QWORD PTR [rsp+112]
	mov	rsi, QWORD PTR [rsp+120]
	add	rsp, 64					; 00000040H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
?BuildLookupTable@ImFont@@QEAAXXZ ENDP			; ImFont::BuildLookupTable
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?SetGlyphVisible@ImFont@@QEAAXG_N@Z
_TEXT	SEGMENT
this$ = 8
c$ = 16
visible$dead$ = 24
?SetGlyphVisible@ImFont@@QEAAXG_N@Z PROC		; ImFont::SetGlyphVisible, COMDAT

; 3322 : {

	mov	r8, rcx

; 3400 :     if (c >= (size_t)IndexLookup.Size)

	movzx	ecx, dx
	movsxd	rax, DWORD PTR [r8+24]
	cmp	rcx, rax
	jb	SHORT $LN5@SetGlyphVi

; 3401 :         return FallbackGlyph;

	mov	rax, QWORD PTR [r8+56]
	jmp	SHORT $LN4@SetGlyphVi
$LN5@SetGlyphVi:

; 3402 :     const ImWchar i = IndexLookup.Data[c];

	mov	rax, QWORD PTR [r8+32]
	movzx	ecx, WORD PTR [rax+rcx*2]

; 3403 :     if (i == (ImWchar)-1)

	mov	eax, 65535				; 0000ffffH
	cmp	cx, ax
	jne	SHORT $LN6@SetGlyphVi

; 3404 :         return FallbackGlyph;

	mov	rax, QWORD PTR [r8+56]
	jmp	SHORT $LN4@SetGlyphVi
$LN6@SetGlyphVi:

; 3405 :     return &Glyphs.Data[i];

	mov	rax, QWORD PTR [r8+48]
	lea	rcx, QWORD PTR [rcx+rcx*4]
	lea	rax, QWORD PTR [rax+rcx*8]
$LN4@SetGlyphVi:

; 3323 :     if (ImFontGlyph* glyph = (ImFontGlyph*)(void*)FindGlyph((ImWchar)c))

	test	rax, rax
	je	SHORT $LN2@SetGlyphVi

; 3324 :         glyph->Visible = visible ? 1 : 0;

	and	DWORD PTR [rax], -3			; fffffffdH
$LN2@SetGlyphVi:

; 3325 : }

	ret	0
?SetGlyphVisible@ImFont@@QEAAXG_N@Z ENDP		; ImFont::SetGlyphVisible
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?GrowIndex@ImFont@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 64
$T1 = 72
new_size$ = 72
?GrowIndex@ImFont@@QEAAXH@Z PROC			; ImFont::GrowIndex, COMDAT

; 3328 : {

$LN44:
	push	rbx
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H
	movsxd	rbx, edx
	mov	rdi, rcx

; 3330 :     if (new_size <= IndexLookup.Size)

	cmp	ebx, DWORD PTR [rcx+24]
	jle	$LN1@GrowIndex
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1932 :     inline void         resize(int new_size, const T& v)    { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }

	mov	ecx, DWORD PTR [rcx+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3330 :     if (new_size <= IndexLookup.Size)

	mov	QWORD PTR [rsp+64], rbp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1932 :     inline void         resize(int new_size, const T& v)    { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }

	mov	ebp, 8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3330 :     if (new_size <= IndexLookup.Size)

	mov	QWORD PTR [rsp+80], rsi

; 3331 :         return;
; 3332 :     IndexAdvanceX.resize(new_size, -1.0f);

	mov	DWORD PTR $T1[rsp], -1082130432		; bf800000H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1932 :     inline void         resize(int new_size, const T& v)    { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }

	cmp	ebx, ecx
	jle	SHORT $LN8@GrowIndex

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN13@GrowIndex
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN14@GrowIndex
$LN13@GrowIndex:
	mov	eax, ebp
$LN14@GrowIndex:
	cmp	eax, ebx
	mov	edx, ebx

; 1932 :     inline void         resize(int new_size, const T& v)    { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }

	mov	rcx, rdi

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	edx, eax

; 1932 :     inline void         resize(int new_size, const T& v)    { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }

	call	?reserve@?$ImVector@M@@QEAAXH@Z		; ImVector<float>::reserve
$LN8@GrowIndex:
	movsxd	rax, DWORD PTR [rdi]
	cmp	ebx, eax
	jle	SHORT $LN6@GrowIndex
	mov	rdx, rax
	cmp	rax, rbx
	jge	SHORT $LN6@GrowIndex
	mov	eax, DWORD PTR $T1[rsp]
	npad	7
$LL7@GrowIndex:
	mov	rcx, QWORD PTR [rdi+8]
	mov	DWORD PTR [rcx+rdx*4], eax
	inc	rdx
	cmp	rdx, rbx
	jl	SHORT $LL7@GrowIndex
$LN6@GrowIndex:
	mov	DWORD PTR [rdi], ebx
	mov	ecx, DWORD PTR [rdi+28]
	cmp	ebx, ecx
	jle	SHORT $LN19@GrowIndex

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN24@GrowIndex
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	lea	ebp, DWORD PTR [rcx+rax]
$LN24@GrowIndex:
	cmp	ebp, ebx

; 1932 :     inline void         resize(int new_size, const T& v)    { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }

	lea	rcx, QWORD PTR [rdi+24]

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	edx, ebx
	cmovg	edx, ebp

; 1932 :     inline void         resize(int new_size, const T& v)    { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }

	call	?reserve@?$ImVector@G@@QEAAXH@Z		; ImVector<unsigned short>::reserve
$LN19@GrowIndex:
	movsxd	rax, DWORD PTR [rdi+24]
	mov	rbp, QWORD PTR [rsp+64]
	cmp	ebx, eax
	jle	SHORT $LN17@GrowIndex
	mov	rcx, rax
	cmp	rax, rbx
	jge	SHORT $LN17@GrowIndex
	npad	5
$LL18@GrowIndex:
	mov	rax, QWORD PTR [rdi+32]
	mov	WORD PTR [rax+rcx*2], 65535		; 0000ffffH
	inc	rcx
	cmp	rcx, rbx
	jl	SHORT $LL18@GrowIndex
$LN17@GrowIndex:
	mov	rsi, QWORD PTR [rsp+80]
	mov	DWORD PTR [rdi+24], ebx
$LN1@GrowIndex:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3334 : }

	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rbx
	ret	0
?GrowIndex@ImFont@@QEAAXH@Z ENDP			; ImFont::GrowIndex
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?AddGlyph@ImFont@@QEAAXPEBUImFontConfig@@GMMMMMMMMM@Z
_TEXT	SEGMENT
this$ = 96
cfg$ = 104
codepoint$ = 112
x0$ = 120
y0$ = 128
x1$ = 136
y1$ = 144
u0$ = 152
v0$ = 160
u1$ = 168
v1$ = 176
advance_x$ = 184
?AddGlyph@ImFont@@QEAAXPEBUImFontConfig@@GMMMMMMMMM@Z PROC ; ImFont::AddGlyph, COMDAT

; 3340 : {

$LN35:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 80					; 00000050H
	movaps	XMMWORD PTR [rsp+64], xmm6
	mov	rdi, rcx
	movaps	XMMWORD PTR [rsp+48], xmm7
	movaps	XMMWORD PTR [rsp+32], xmm8
	movaps	xmm8, xmm3
	movzx	esi, r8w

; 3341 :     if (cfg != NULL)

	test	rdx, rdx
	je	$LN25@AddGlyph

; 3342 :     {
; 3343 :         // Clamp & recenter if needed
; 3344 :         const float advance_x_original = advance_x;

	movss	xmm1, DWORD PTR advance_x$[rsp]

; 3345 :         advance_x = ImClamp(advance_x, cfg->GlyphMinAdvanceX, cfg->GlyphMaxAdvanceX);

	movss	xmm6, DWORD PTR [rdx+64]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm6, xmm1
	ja	SHORT $LN12@AddGlyph
	movss	xmm6, DWORD PTR [rdx+68]
	minss	xmm6, xmm1
$LN12@AddGlyph:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3346 :         if (advance_x != advance_x_original)

	ucomiss	xmm6, xmm1
	movss	xmm2, DWORD PTR __real@3f000000
	jp	SHORT $LN24@AddGlyph
	jne	SHORT $LN24@AddGlyph

; 3350 :             x1 += char_off_x;

	movss	xmm7, DWORD PTR x1$[rsp]
	jmp	SHORT $LN20@AddGlyph
$LN24@AddGlyph:

; 3347 :         {
; 3348 :             float char_off_x = cfg->PixelSnapH ? ImFloor((advance_x - advance_x_original) * 0.5f) : (advance_x - advance_x_original) * 0.5f;

	cmp	BYTE PTR [rdx+32], 0
	movaps	xmm0, xmm6
	subss	xmm0, xmm1
	mulss	xmm0, xmm2
	je	SHORT $LN6@AddGlyph
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 472  : static inline float  ImFloor(float f)                                           { return (float)(int)(f); }

	cvttss2si eax, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
$LN6@AddGlyph:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3350 :             x1 += char_off_x;

	movss	xmm7, DWORD PTR x1$[rsp]
	addss	xmm8, xmm0
	addss	xmm7, xmm0
$LN20@AddGlyph:

; 3351 :         }
; 3352 : 
; 3353 :         // Snap to pixel
; 3354 :         if (cfg->PixelSnapH)

	cmp	BYTE PTR [rdx+32], 0
	je	SHORT $LN4@AddGlyph

; 3355 :             advance_x = IM_ROUND(advance_x);

	addss	xmm6, xmm2
	cvttss2si eax, xmm6
	movd	xmm6, eax
	cvtdq2ps xmm6, xmm6
$LN4@AddGlyph:

; 3356 : 
; 3357 :         // Bake spacing
; 3358 :         advance_x += cfg->GlyphExtraSpacing.x;

	addss	xmm6, DWORD PTR [rdx+36]
	jmp	SHORT $LN2@AddGlyph
$LN25@AddGlyph:

; 3341 :     if (cfg != NULL)

	movss	xmm6, DWORD PTR advance_x$[rsp]
	movss	xmm7, DWORD PTR x1$[rsp]
$LN2@AddGlyph:

; 3359 :     }
; 3360 : 
; 3361 :     Glyphs.resize(Glyphs.Size + 1);

	mov	edx, DWORD PTR [rcx+40]
	add	rcx, 40					; 00000028H
	inc	edx
	call	?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z ; ImVector<ImFontGlyph>::resize
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	movsxd	rax, DWORD PTR [rdi+40]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3363 :     glyph.Codepoint = (unsigned int)codepoint;

	mov	ecx, esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	mov	r8, QWORD PTR [rdi+48]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3364 :     glyph.Visible = (x0 != x1) && (y0 != y1);

	movss	xmm0, DWORD PTR y1$[rsp]
	movss	xmm1, DWORD PTR y0$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	lea	rdx, QWORD PTR [rax+rax*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3363 :     glyph.Codepoint = (unsigned int)codepoint;

	shl	ecx, 2
	mov	eax, DWORD PTR [r8+rdx*8-40]
	and	eax, 3
	or	ecx, eax

; 3364 :     glyph.Visible = (x0 != x1) && (y0 != y1);

	ucomiss	xmm8, xmm7
	jp	SHORT $LN23@AddGlyph
	je	SHORT $LN8@AddGlyph
$LN23@AddGlyph:
	ucomiss	xmm1, xmm0
	jp	SHORT $LN22@AddGlyph
	jne	SHORT $LN22@AddGlyph
$LN8@AddGlyph:
	xor	eax, eax
	jmp	SHORT $LN9@AddGlyph
$LN22@AddGlyph:
	mov	eax, 2
$LN9@AddGlyph:

; 3365 :     glyph.Colored = false;
; 3366 :     glyph.X0 = x0;
; 3367 :     glyph.Y0 = y0;
; 3368 :     glyph.X1 = x1;
; 3369 :     glyph.Y1 = y1;
; 3370 :     glyph.U0 = u0;
; 3371 :     glyph.V0 = v0;
; 3372 :     glyph.U1 = u1;
; 3373 :     glyph.V1 = v1;
; 3374 :     glyph.AdvanceX = advance_x;
; 3375 : 
; 3376 :     // Compute rough surface usage metrics (+1 to account for average padding, +0.99 to round)
; 3377 :     // We use (U1-U0)*TexWidth instead of X1-X0 to account for oversampling.
; 3378 :     float pad = ContainerAtlas->TexGlyphPadding + 0.99f;
; 3379 :     DirtyLookupTables = true;
; 3380 :     MetricsTotalSurface += (int)((glyph.U1 - glyph.U0) * ContainerAtlas->TexWidth + pad) * (int)((glyph.V1 - glyph.V0) * ContainerAtlas->TexHeight + pad);
; 3381 : }

	mov	rbx, QWORD PTR [rsp+96]
	and	ecx, -3					; fffffffdH
	mov	rsi, QWORD PTR [rsp+104]
	or	ecx, eax
	movss	DWORD PTR [r8+rdx*8-28], xmm1
	and	ecx, -2					; fffffffeH
	movss	xmm1, DWORD PTR v0$[rsp]
	movss	DWORD PTR [r8+rdx*8-20], xmm0
	movss	xmm0, DWORD PTR u0$[rsp]
	movss	DWORD PTR [r8+rdx*8-12], xmm1
	movss	xmm1, DWORD PTR v1$[rsp]
	movss	DWORD PTR [r8+rdx*8-16], xmm0
	movss	xmm0, DWORD PTR u1$[rsp]
	movss	DWORD PTR [r8+rdx*8-4], xmm1
	movss	DWORD PTR [r8+rdx*8-8], xmm0
	mov	DWORD PTR [r8+rdx*8-40], ecx
	movss	DWORD PTR [r8+rdx*8-32], xmm8
	movaps	xmm8, XMMWORD PTR [rsp+32]
	movss	DWORD PTR [r8+rdx*8-24], xmm7
	movaps	xmm7, XMMWORD PTR [rsp+48]
	movss	DWORD PTR [r8+rdx*8-36], xmm6
	mov	rax, QWORD PTR [rdi+64]
	movaps	xmm6, XMMWORD PTR [rsp+64]
	movd	xmm3, DWORD PTR [rax+20]
	mov	BYTE PTR [rdi+96], 1
	movd	xmm1, DWORD PTR [rax+64]
	movss	xmm0, DWORD PTR [r8+rdx*8-8]
	subss	xmm0, DWORD PTR [r8+rdx*8-16]
	movss	xmm2, DWORD PTR [r8+rdx*8-4]
	subss	xmm2, DWORD PTR [r8+rdx*8-12]
	cvtdq2ps xmm1, xmm1
	cvtdq2ps xmm3, xmm3
	mulss	xmm1, xmm0
	movd	xmm0, DWORD PTR [rax+68]
	addss	xmm3, DWORD PTR __real@3f7d70a4
	cvtdq2ps xmm0, xmm0
	addss	xmm1, xmm3
	mulss	xmm2, xmm0
	addss	xmm2, xmm3
	cvttss2si ecx, xmm1
	cvttss2si eax, xmm2
	imul	ecx, eax
	add	DWORD PTR [rdi+112], ecx
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
?AddGlyph@ImFont@@QEAAXPEBUImFontConfig@@GMMMMMMMMM@Z ENDP ; ImFont::AddGlyph
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?FindGlyph@ImFont@@QEBAPEBUImFontGlyph@@G@Z
_TEXT	SEGMENT
this$ = 8
c$ = 16
?FindGlyph@ImFont@@QEBAPEBUImFontGlyph@@G@Z PROC	; ImFont::FindGlyph, COMDAT

; 3400 :     if (c >= (size_t)IndexLookup.Size)

	movsxd	rax, DWORD PTR [rcx+24]
	movzx	edx, dx
	cmp	rdx, rax
	jae	SHORT $LN5@FindGlyph

; 3401 :         return FallbackGlyph;
; 3402 :     const ImWchar i = IndexLookup.Data[c];

	mov	rax, QWORD PTR [rcx+32]
	movzx	edx, WORD PTR [rax+rdx*2]

; 3403 :     if (i == (ImWchar)-1)

	mov	eax, 65535				; 0000ffffH
	cmp	dx, ax
	je	SHORT $LN5@FindGlyph

; 3405 :     return &Glyphs.Data[i];

	mov	rax, QWORD PTR [rcx+48]
	lea	rdx, QWORD PTR [rdx+rdx*4]
	lea	rax, QWORD PTR [rax+rdx*8]

; 3406 : }

	ret	0
$LN5@FindGlyph:

; 3404 :         return FallbackGlyph;

	mov	rax, QWORD PTR [rcx+56]

; 3406 : }

	ret	0
?FindGlyph@ImFont@@QEBAPEBUImFontGlyph@@G@Z ENDP	; ImFont::FindGlyph
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?CalcWordWrapNextLineStartA@@YAPEBDPEBD0@Z
_TEXT	SEGMENT
text$ = 8
text_end$ = 16
?CalcWordWrapNextLineStartA@@YAPEBDPEBD0@Z PROC		; CalcWordWrapNextLineStartA, COMDAT

; 3421 :     while (text < text_end && ImCharIsBlankA(*text))

	cmp	rcx, rdx
	jae	SHORT $LN15@CalcWordWr
$LL2@CalcWordWr:
	movzx	eax, BYTE PTR [rcx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 375  : static inline bool      ImCharIsBlankA(char c)          { return c == ' ' || c == '\t'; }

	cmp	al, 32					; 00000020H
	je	SHORT $LN14@CalcWordWr
	cmp	al, 9
	jne	SHORT $LN15@CalcWordWr
$LN14@CalcWordWr:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3422 :         text++;

	inc	rcx
	cmp	rcx, rdx
	jb	SHORT $LL2@CalcWordWr
$LN15@CalcWordWr:

; 3423 :     if (*text == '\n')
; 3424 :         text++;
; 3425 :     return text;

	cmp	BYTE PTR [rcx], 10
	lea	rax, QWORD PTR [rcx+1]
	cmovne	rax, rcx

; 3426 : }

	ret	0
?CalcWordWrapNextLineStartA@@YAPEBDPEBD0@Z ENDP		; CalcWordWrapNextLineStartA
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z
_TEXT	SEGMENT
this$ = 80
scale$ = 88
text$ = 96
text_end$ = 104
c$1 = 112
wrap_width$ = 112
?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z PROC	; ImFont::CalcWordWrapPositionA, COMDAT

; 3432 : {

$LN55:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 3433 :     // For references, possible wrap point marked with ^
; 3434 :     //  "aaa bbb, ccc,ddd. eee   fff. ggg!"
; 3435 :     //      ^    ^    ^   ^   ^__    ^    ^
; 3436 : 
; 3437 :     // List of hardcoded separators: .,;!?'"
; 3438 : 
; 3439 :     // Skip extra blanks after a line returns (that includes not counting them in width computation)
; 3440 :     // e.g. "Hello    world" --> "Hello" "World"
; 3441 : 
; 3442 :     // Cut words that cannot possibly fit within one line.
; 3443 :     // e.g.: "The tropical fish" with ~5 characters worth of width --> "The tr" "opical" "fish"
; 3444 :     float line_width = 0.0f;
; 3445 :     float word_width = 0.0f;
; 3446 :     float blank_width = 0.0f;
; 3447 :     wrap_width /= scale; // We work with unscaled widths to avoid scaling every characters

	movss	xmm5, DWORD PTR wrap_width$[rsp]

; 3448 : 
; 3449 :     const char* word_end = text;
; 3450 :     const char* prev_word_end = NULL;

	xor	ebp, ebp
	mov	r15, r9
	mov	r12, r8
	mov	r14, rcx
	xorps	xmm4, xmm4
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	mov	rsi, r8

; 3451 :     bool inside_word = true;

	mov	dil, 1

; 3452 : 
; 3453 :     const char* s = text;

	mov	rbx, r8
	divss	xmm5, xmm1

; 3454 :     IM_ASSERT(text_end != NULL);
; 3455 :     while (s < text_end)

	cmp	r8, r9
	jae	$LN16@CalcWordWr
	mov	QWORD PTR [rsp+80], r13
	mov	r13, -8646823297851326464		; 8800500600000000H
	npad	11
$LL2@CalcWordWr:

; 3456 :     {
; 3457 :         unsigned int c = (unsigned int)*s;

	movsx	edx, BYTE PTR [rbx]
	mov	DWORD PTR c$1[rsp], edx
	cmp	edx, 128				; 00000080H

; 3458 :         const char* next_s;
; 3459 :         if (c < 0x80)

	jae	SHORT $LN4@CalcWordWr

; 3460 :             next_s = s + 1;

	mov	eax, 1
	jmp	SHORT $LN5@CalcWordWr
$LN4@CalcWordWr:

; 3461 :         else
; 3462 :             next_s = s + ImTextCharFromUtf8(&c, s, text_end);

	mov	r8, r15
	lea	rcx, QWORD PTR c$1[rsp]
	mov	rdx, rbx
	call	?ImTextCharFromUtf8@@YAHPEAIPEBD1@Z	; ImTextCharFromUtf8
	mov	edx, DWORD PTR c$1[rsp]
	cdqe
$LN5@CalcWordWr:

; 3463 : 
; 3464 :         if (c < 32)

	lea	r8, QWORD PTR [rax+rbx]
	cmp	edx, 32					; 00000020H
	jae	SHORT $LN8@CalcWordWr

; 3465 :         {
; 3466 :             if (c == '\n')

	cmp	edx, 10
	jne	SHORT $LN7@CalcWordWr

; 3467 :             {
; 3468 :                 line_width = word_width = blank_width = 0.0f;
; 3469 :                 inside_word = true;

	xorps	xmm2, xmm2
	xorps	xmm3, xmm3
	xorps	xmm4, xmm4
	mov	dil, 1

; 3470 :                 s = next_s;
; 3471 :                 continue;

	jmp	$LN30@CalcWordWr
$LN7@CalcWordWr:

; 3472 :             }
; 3473 :             if (c == '\r')

	cmp	edx, 13
	je	$LN30@CalcWordWr
$LN8@CalcWordWr:

; 3474 :             {
; 3475 :                 s = next_s;
; 3476 :                 continue;
; 3477 :             }
; 3478 :         }
; 3479 : 
; 3480 :         const float char_width = ((int)c < IndexAdvanceX.Size ? IndexAdvanceX.Data[c] : FallbackAdvanceX);

	cmp	edx, DWORD PTR [r14]
	jge	SHORT $LN18@CalcWordWr
	mov	rax, QWORD PTR [r14+8]
	mov	ecx, edx
	movss	xmm0, DWORD PTR [rax+rcx*4]
	jmp	SHORT $LN19@CalcWordWr
$LN18@CalcWordWr:
	movss	xmm0, DWORD PTR [r14+16]
$LN19@CalcWordWr:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 376  : static inline bool      ImCharIsBlankW(unsigned int c)  { return c == ' ' || c == '\t' || c == 0x3000; }

	cmp	edx, 32					; 00000020H
	je	SHORT $LN34@CalcWordWr
	cmp	edx, 9
	je	SHORT $LN34@CalcWordWr
	cmp	edx, 12288				; 00003000H
	je	SHORT $LN34@CalcWordWr
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3495 :             if (inside_word)

	addss	xmm3, xmm0
	test	dil, dil
	jne	SHORT $LN52@CalcWordWr

; 3496 :             {
; 3497 :                 word_end = next_s;
; 3498 :             }
; 3499 :             else
; 3500 :             {
; 3501 :                 prev_word_end = word_end;
; 3502 :                 line_width += word_width + blank_width;

	addss	xmm2, xmm3
	xorps	xmm3, xmm3
	addss	xmm4, xmm2
	xorps	xmm2, xmm2
$LN52@CalcWordWr:

; 3503 :                 word_width = blank_width = 0.0f;
; 3504 :             }
; 3505 : 
; 3506 :             // Allow wrapping after punctuation.
; 3507 :             inside_word = (c != '.' && c != ',' && c != ';' && c != '!' && c != '?' && c != '\"');

	cmove	rbp, rsi
	mov	rax, r8
	test	dil, dil
	cmove	rax, rsi
	mov	rsi, rax
	cmp	edx, 63					; 0000003fH
	ja	SHORT $LN35@CalcWordWr
	bt	r13, rdx
	jb	SHORT $LN53@CalcWordWr
$LN35@CalcWordWr:
	mov	dil, 1
	jmp	SHORT $LN21@CalcWordWr
$LN34@CalcWordWr:

; 3481 :         if (ImCharIsBlankW(c))
; 3482 :         {
; 3483 :             if (inside_word)

	test	dil, dil
	je	SHORT $LN11@CalcWordWr

; 3484 :             {
; 3485 :                 line_width += blank_width;

	addss	xmm4, xmm2
	xorps	xmm2, xmm2
$LN11@CalcWordWr:

; 3486 :                 blank_width = 0.0f;
; 3487 :                 word_end = s;
; 3488 :             }
; 3489 :             blank_width += char_width;

	test	dil, dil
	addss	xmm2, xmm0
	mov	rax, rbx
	cmove	rax, rsi
	mov	rsi, rax
$LN53@CalcWordWr:

; 3508 :         }
; 3509 : 
; 3510 :         // We ignore blank width at the end of the line (they can be skipped)
; 3511 :         if (line_width + word_width > wrap_width)

	xor	dil, dil
$LN21@CalcWordWr:
	movaps	xmm0, xmm3
	addss	xmm0, xmm4
	comiss	xmm0, xmm5
	ja	SHORT $LN29@CalcWordWr
$LN30@CalcWordWr:

; 3454 :     IM_ASSERT(text_end != NULL);
; 3455 :     while (s < text_end)

	mov	rbx, r8
	cmp	r8, r15
	jb	$LL2@CalcWordWr

; 3508 :         }
; 3509 : 
; 3510 :         // We ignore blank width at the end of the line (they can be skipped)
; 3511 :         if (line_width + word_width > wrap_width)

	jmp	SHORT $LN15@CalcWordWr
$LN29@CalcWordWr:

; 3512 :         {
; 3513 :             // Words that cannot possibly fit within an entire line will be cut anywhere.
; 3514 :             if (word_width < wrap_width)

	comiss	xmm5, xmm3
	jbe	SHORT $LN15@CalcWordWr

; 3515 :                 s = prev_word_end ? prev_word_end : word_end;

	test	rbp, rbp
	mov	rbx, rsi
	cmovne	rbx, rbp
$LN15@CalcWordWr:

; 3516 :             break;
; 3517 :         }
; 3518 : 
; 3519 :         s = next_s;
; 3520 :     }
; 3521 : 
; 3522 :     // Wrap_width is too small to fit anything. Force displaying 1 character to minimize the height discontinuity.
; 3523 :     // +1 may not be a character start point in UTF-8 but it's ok because caller loops use (text >= word_wrap_eol).
; 3524 :     if (s == text && text < text_end)
; 3525 :         return s + 1;

	mov	r13, QWORD PTR [rsp+80]
	lea	rax, QWORD PTR [rbx+1]
	cmp	rbx, r12
	je	SHORT $LN1@CalcWordWr
$LN16@CalcWordWr:

; 3526 :     return s;

	mov	rax, rbx
$LN1@CalcWordWr:

; 3527 : }

	mov	rbx, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+96]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	ret	0
?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z ENDP	; ImFont::CalcWordWrapPositionA
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?RenderText@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IAEBUImVec4@@PEBD3M_N@Z
_TEXT	SEGMENT
start_x$1$ = 48
col_untinted$1$ = 52
idx_expected_size$1$ = 56
this$ = 288
draw_list$ = 296
size$ = 304
line_height$1$ = 312
pos$ = 312
col$ = 320
c$1 = 328
clip_rect$ = 328
text_begin$ = 336
word_wrap_enabled$1$ = 344
text_end$ = 344
wrap_width$ = 352
cpu_fine_clip$ = 360
?RenderText@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IAEBUImVec4@@PEBD3M_N@Z PROC ; ImFont::RenderText, COMDAT

; 3624 : {

$LN147:
	mov	QWORD PTR [rsp+16], rdx
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r15
	sub	rsp, 240				; 000000f0H

; 3625 :     if (!text_end)

	mov	rdi, QWORD PTR text_end$[rsp]
	mov	rbp, rdx
	mov	rbx, QWORD PTR text_begin$[rsp]
	mov	rsi, rcx
	movaps	XMMWORD PTR [rsp+160], xmm9
	movaps	xmm9, xmm2
	movaps	XMMWORD PTR [rsp+80], xmm14
	movaps	XMMWORD PTR [rsp+64], xmm15
	test	rdi, rdi
	jne	SHORT $LN8@RenderText

; 3626 :         text_end = text_begin + strlen(text_begin); // ImGui:: functions generally already provides a valid text_end, so this is merely to handle direct calls.

	mov	rdi, -1
	npad	3
$LL98@RenderText:
	inc	rdi
	cmp	BYTE PTR [rbx+rdi], 0
	jne	SHORT $LL98@RenderText
	add	rdi, rbx
$LN8@RenderText:

; 3627 : 
; 3628 :     // Align to be pixel perfect
; 3629 :     float x = IM_FLOOR(pos.x);

	cvttss2si eax, DWORD PTR [r9]

; 3630 :     float y = IM_FLOOR(pos.y);
; 3631 :     if (y > clip_rect.w)

	mov	r15, QWORD PTR clip_rect$[rsp]
	movd	xmm15, eax
	cvttss2si eax, DWORD PTR [r9+4]
	cvtdq2ps xmm15, xmm15
	movd	xmm14, eax
	cvtdq2ps xmm14, xmm14
	comiss	xmm14, DWORD PTR [r15+12]
	ja	$LN1@RenderText
	mov	QWORD PTR [rsp+224], r14
	xorps	xmm0, xmm0
	movaps	XMMWORD PTR [rsp+208], xmm6

; 3632 :         return;
; 3633 : 
; 3634 :     const float start_x = x;

	movaps	xmm6, xmm15
	movaps	XMMWORD PTR [rsp+192], xmm7

; 3635 :     const float scale = size / FontSize;
; 3636 :     const float line_height = FontSize * scale;
; 3637 :     const bool word_wrap_enabled = (wrap_width > 0.0f);

	movss	xmm7, DWORD PTR wrap_width$[rsp]
	movaps	XMMWORD PTR [rsp+176], xmm8
	movss	xmm8, DWORD PTR [rcx+20]
	divss	xmm9, xmm8
	comiss	xmm7, xmm0

; 3638 : 
; 3639 :     // Fast-forward to first visible line
; 3640 :     const char* s = text_begin;
; 3641 :     if (y + line_height < clip_rect.y)

	movss	xmm0, DWORD PTR [r15+4]
	mulss	xmm8, xmm9
	seta	r14b
	movss	DWORD PTR start_x$1$[rsp], xmm6
	movss	DWORD PTR size$[rsp], xmm9
	movaps	xmm1, xmm8
	movss	DWORD PTR line_height$1$[rsp], xmm8
	addss	xmm1, xmm14
	mov	BYTE PTR word_wrap_enabled$1$[rsp], r14b
	comiss	xmm0, xmm1
	jbe	$LN100@RenderText
	npad	2
$LL2@RenderText:

; 3642 :         while (y + line_height < clip_rect.y && s < text_end)

	cmp	rbx, rdi
	jae	$LN100@RenderText

; 3643 :         {
; 3644 :             const char* line_end = (const char*)memchr(s, '\n', text_end - s);

	mov	r8, rdi
	mov	edx, 10
	sub	r8, rbx
	mov	rcx, rbx
	call	memchr

; 3645 :             if (word_wrap_enabled)

	test	r14b, r14b
	je	SHORT $LN11@RenderText

; 3646 :             {
; 3647 :                 // FIXME-OPT: This is not optimal as do first do a search for \n before calling CalcWordWrapPositionA().
; 3648 :                 // If the specs for CalcWordWrapPositionA() were reworked to optionally return on \n we could combine both.
; 3649 :                 // However it is still better than nothing performing the fast-forward!
; 3650 :                 s = CalcWordWrapPositionA(scale, s, line_end ? line_end : text_end, wrap_width);

	test	rax, rax
	movss	DWORD PTR [rsp+32], xmm7
	mov	r9, rdi
	mov	r8, rbx
	cmovne	r9, rax
	movaps	xmm1, xmm9
	mov	rcx, rsi
	call	?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z ; ImFont::CalcWordWrapPositionA
	mov	rbx, rax

; 3421 :     while (text < text_end && ImCharIsBlankA(*text))

	cmp	rax, rdi
	jae	SHORT $LN99@RenderText
$LL39@RenderText:
	movzx	eax, BYTE PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 375  : static inline bool      ImCharIsBlankA(char c)          { return c == ' ' || c == '\t'; }

	cmp	al, 32					; 00000020H
	je	SHORT $LN95@RenderText
	cmp	al, 9
	jne	SHORT $LN99@RenderText
$LN95@RenderText:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3422 :         text++;

	inc	rbx
	cmp	rbx, rdi
	jb	SHORT $LL39@RenderText
$LN99@RenderText:

; 3423 :     if (*text == '\n')

	cmp	BYTE PTR [rbx], 10
	jne	SHORT $LN35@RenderText

; 3424 :         text++;

	inc	rbx

; 3651 :                 s = CalcWordWrapNextLineStartA(s, text_end);
; 3652 :             }

	jmp	SHORT $LN35@RenderText
$LN11@RenderText:

; 3653 :             else
; 3654 :             {
; 3655 :                 s = line_end ? line_end + 1 : text_end;

	lea	rbx, QWORD PTR [rax+1]
	test	rax, rax
	jne	SHORT $LN35@RenderText
	mov	rbx, rdi
$LN35@RenderText:

; 3642 :         while (y + line_height < clip_rect.y && s < text_end)

	movss	xmm0, DWORD PTR [r15+4]

; 3656 :             }
; 3657 :             y += line_height;

	addss	xmm14, xmm8
	movaps	xmm1, xmm8
	addss	xmm1, xmm14
	comiss	xmm0, xmm1
	ja	$LL2@RenderText
$LN100@RenderText:

; 3658 :         }
; 3659 : 
; 3660 :     // For large text, scan for the last visible line in order to avoid over-reserving in the call to PrimReserve()
; 3661 :     // Note that very large horizontal line will still be affected by the issue (e.g. a one megabyte string buffer without a newline will likely crash atm)
; 3662 :     if (text_end - s > 10000 && !word_wrap_enabled)

	mov	rax, rdi
	sub	rax, rbx
	cmp	rax, 10000				; 00002710H
	jle	SHORT $LN13@RenderText
	test	r14b, r14b
	jne	SHORT $LN13@RenderText

; 3663 :     {
; 3664 :         const char* s_end = s;
; 3665 :         float y_end = y;
; 3666 :         while (y_end < clip_rect.w && s_end < text_end)

	movss	xmm7, DWORD PTR [r15+12]
	mov	rax, rbx
	comiss	xmm7, xmm14
	movaps	xmm6, xmm14
	jbe	SHORT $LN101@RenderText
$LL4@RenderText:
	cmp	rax, rdi
	jae	SHORT $LN101@RenderText

; 3667 :         {
; 3668 :             s_end = (const char*)memchr(s_end, '\n', text_end - s_end);

	mov	r8, rdi
	mov	edx, 10
	sub	r8, rax
	mov	rcx, rax
	call	memchr

; 3669 :             s_end = s_end ? s_end + 1 : text_end;

	test	rax, rax
	je	SHORT $LN36@RenderText
	inc	rax
	jmp	SHORT $LN37@RenderText
$LN36@RenderText:
	mov	rax, rdi
$LN37@RenderText:

; 3670 :             y_end += line_height;

	addss	xmm6, xmm8
	comiss	xmm7, xmm6
	ja	SHORT $LL4@RenderText
$LN101@RenderText:
	movss	xmm6, DWORD PTR start_x$1$[rsp]

; 3671 :         }
; 3672 :         text_end = s_end;

	mov	rdi, rax
	movss	xmm7, DWORD PTR wrap_width$[rsp]
$LN13@RenderText:

; 3673 :     }
; 3674 :     if (s == text_end)

	cmp	rbx, rdi
	je	$LN145@RenderText

; 3675 :         return;
; 3676 : 
; 3677 :     // Reserve vertices for remaining worse case (over-reserving is useful and easily amortized)
; 3678 :     const int vtx_count_max = (int)(text_end - s) * 4;
; 3679 :     const int idx_count_max = (int)(text_end - s) * 6;
; 3680 :     const int idx_expected_size = draw_list->IdxBuffer.Size + idx_count_max;

	mov	eax, DWORD PTR [rbp+16]
	mov	r8d, edi
	sub	r8d, ebx
	mov	QWORD PTR [rsp+288], r12

; 3681 :     draw_list->PrimReserve(idx_count_max, vtx_count_max);

	mov	rcx, rbp
	mov	QWORD PTR [rsp+232], r13
	lea	edx, DWORD PTR [r8+r8*2]
	add	edx, edx
	lea	r8d, DWORD PTR [r8*4]
	add	eax, edx
	mov	DWORD PTR idx_expected_size$1$[rsp], eax
	call	?PrimReserve@ImDrawList@@QEAAXHH@Z	; ImDrawList::PrimReserve

; 3682 :     ImDrawVert*  vtx_write = draw_list->_VtxWritePtr;

	mov	r8, QWORD PTR draw_list$[rsp]

; 3683 :     ImDrawIdx*   idx_write = draw_list->_IdxWritePtr;
; 3684 :     unsigned int vtx_index = draw_list->_VtxCurrentIdx;
; 3685 : 
; 3686 :     const ImU32 col_untinted = col | ~IM_COL32_A_MASK;
; 3687 :     const char* word_wrap_eol = NULL;

	xor	r14d, r14d
	mov	eax, DWORD PTR col$[rsp]
	or	eax, 16777215				; 00ffffffH
	mov	DWORD PTR col_untinted$1$[rsp], eax
	mov	rbp, QWORD PTR [r8+72]
	mov	r12, QWORD PTR [r8+80]
	mov	r13d, DWORD PTR [r8+52]

; 3688 : 
; 3689 :     while (s < text_end)

	cmp	rbx, rdi
	jae	$LN72@RenderText
	movaps	XMMWORD PTR [rsp+144], xmm10
	movaps	XMMWORD PTR [rsp+128], xmm11
	movaps	XMMWORD PTR [rsp+112], xmm12
	movaps	XMMWORD PTR [rsp+96], xmm13
$LL6@RenderText:

; 3690 :     {
; 3691 :         if (word_wrap_enabled)

	cmp	BYTE PTR word_wrap_enabled$1$[rsp], 0
	je	SHORT $LN17@RenderText

; 3692 :         {
; 3693 :             // Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.
; 3694 :             if (!word_wrap_eol)

	test	r14, r14
	jne	SHORT $LN16@RenderText

; 3695 :                 word_wrap_eol = CalcWordWrapPositionA(scale, s, text_end, wrap_width - (x - start_x));

	movaps	xmm1, xmm15
	movaps	xmm0, xmm7
	subss	xmm1, xmm6
	mov	r9, rdi
	mov	r8, rbx
	mov	rcx, rsi
	subss	xmm0, xmm1
	movaps	xmm1, xmm9
	movss	DWORD PTR [rsp+32], xmm0
	call	?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z ; ImFont::CalcWordWrapPositionA
	mov	r14, rax
$LN16@RenderText:

; 3696 : 
; 3697 :             if (s >= word_wrap_eol)

	cmp	rbx, r14
	jb	SHORT $LN17@RenderText

; 3698 :             {
; 3699 :                 x = start_x;
; 3700 :                 y += line_height;
; 3701 :                 word_wrap_eol = NULL;

	xor	r14d, r14d
	addss	xmm14, xmm8
	movaps	xmm15, xmm6

; 3421 :     while (text < text_end && ImCharIsBlankA(*text))

	cmp	rbx, rdi
	jae	SHORT $LN102@RenderText
$LL48@RenderText:
	movzx	eax, BYTE PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 375  : static inline bool      ImCharIsBlankA(char c)          { return c == ' ' || c == '\t'; }

	cmp	al, 32					; 00000020H
	je	SHORT $LN94@RenderText
	cmp	al, 9
	jne	SHORT $LN102@RenderText
$LN94@RenderText:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3422 :         text++;

	inc	rbx
	cmp	rbx, rdi
	jb	SHORT $LL48@RenderText
$LN102@RenderText:

; 3423 :     if (*text == '\n')

	cmp	BYTE PTR [rbx], 10
	jne	$LN77@RenderText

; 3424 :         text++;

	inc	rbx

; 3702 :                 s = CalcWordWrapNextLineStartA(s, text_end); // Wrapping skips upcoming blanks
; 3703 :                 continue;

	jmp	$LN77@RenderText
$LN17@RenderText:

; 3704 :             }
; 3705 :         }
; 3706 : 
; 3707 :         // Decode and advance source
; 3708 :         unsigned int c = (unsigned int)*s;

	movsx	eax, BYTE PTR [rbx]
	mov	DWORD PTR c$1[rsp], eax

; 3709 :         if (c < 0x80)

	cmp	eax, 128				; 00000080H
	jae	SHORT $LN18@RenderText

; 3710 :             s += 1;

	inc	rbx
	jmp	SHORT $LN19@RenderText
$LN18@RenderText:

; 3711 :         else
; 3712 :             s += ImTextCharFromUtf8(&c, s, text_end);

	mov	r8, rdi
	lea	rcx, QWORD PTR c$1[rsp]
	mov	rdx, rbx
	call	?ImTextCharFromUtf8@@YAHPEAIPEBD1@Z	; ImTextCharFromUtf8
	movsxd	rcx, eax
	mov	eax, DWORD PTR c$1[rsp]
	add	rbx, rcx
$LN19@RenderText:

; 3713 : 
; 3714 :         if (c < 32)

	cmp	eax, 32					; 00000020H
	jae	SHORT $LN23@RenderText

; 3715 :         {
; 3716 :             if (c == '\n')

	cmp	eax, 10
	jne	SHORT $LN21@RenderText

; 3717 :             {
; 3718 :                 x = start_x;
; 3719 :                 y += line_height;

	addss	xmm14, xmm8
	movaps	xmm15, xmm6

; 3720 :                 if (y > clip_rect.w)

	comiss	xmm14, DWORD PTR [r15+12]
	ja	$LN103@RenderText

; 3721 :                     break; // break out of main loop
; 3722 :                 continue;

	jmp	$LN77@RenderText
$LN21@RenderText:

; 3723 :             }
; 3724 :             if (c == '\r')

	cmp	eax, 13
	je	$LN77@RenderText
$LN23@RenderText:

; 3400 :     if (c >= (size_t)IndexLookup.Size)

	movzx	ecx, ax
	movsxd	rax, DWORD PTR [rsi+24]
	cmp	rcx, rax
	jb	SHORT $LN57@RenderText

; 3401 :         return FallbackGlyph;

	mov	rax, QWORD PTR [rsi+56]
	jmp	SHORT $LN56@RenderText
$LN57@RenderText:

; 3402 :     const ImWchar i = IndexLookup.Data[c];

	mov	rax, QWORD PTR [rsi+32]
	movzx	edx, WORD PTR [rax+rcx*2]

; 3403 :     if (i == (ImWchar)-1)

	mov	eax, 65535				; 0000ffffH
	cmp	dx, ax
	jne	SHORT $LN58@RenderText

; 3404 :         return FallbackGlyph;

	mov	rax, QWORD PTR [rsi+56]
	jmp	SHORT $LN56@RenderText
$LN58@RenderText:

; 3405 :     return &Glyphs.Data[i];

	mov	rax, QWORD PTR [rsi+48]
	lea	rcx, QWORD PTR [rdx+rdx*4]
	lea	rax, QWORD PTR [rax+rcx*8]
$LN56@RenderText:

; 3725 :                 continue;
; 3726 :         }
; 3727 : 
; 3728 :         const ImFontGlyph* glyph = FindGlyph((ImWchar)c);
; 3729 :         if (glyph == NULL)

	test	rax, rax
	je	$LN77@RenderText

; 3730 :             continue;
; 3731 : 
; 3732 :         float char_width = glyph->AdvanceX * scale;
; 3733 :         if (glyph->Visible)

	mov	ecx, DWORD PTR [rax]
	movaps	xmm8, xmm9
	mulss	xmm8, DWORD PTR [rax+4]
	test	cl, 2
	je	$LN26@RenderText

; 3734 :         {
; 3735 :             // We don't do a second finer clipping test on the Y axis as we've already skipped anything before clip_rect.y and exit once we pass clip_rect.w
; 3736 :             float x1 = x + glyph->X0 * scale;
; 3737 :             float x2 = x + glyph->X1 * scale;
; 3738 :             float y1 = y + glyph->Y0 * scale;
; 3739 :             float y2 = y + glyph->Y1 * scale;
; 3740 :             if (x1 <= clip_rect.z && x2 >= clip_rect.x)

	movss	xmm11, DWORD PTR [r15+8]
	movaps	xmm7, xmm9
	mulss	xmm7, DWORD PTR [rax+8]
	movaps	xmm3, xmm9
	mulss	xmm3, DWORD PTR [rax+16]
	movaps	xmm6, xmm9
	mulss	xmm6, DWORD PTR [rax+12]
	addss	xmm7, xmm15
	movaps	xmm4, xmm9
	addss	xmm3, xmm15
	mulss	xmm4, DWORD PTR [rax+20]
	comiss	xmm11, xmm7
	addss	xmm6, xmm14
	addss	xmm4, xmm14
	jb	$LN26@RenderText
	movss	xmm5, DWORD PTR [r15]
	comiss	xmm3, xmm5
	jb	$LN26@RenderText

; 3741 :             {
; 3742 :                 // Render a character
; 3743 :                 float u1 = glyph->U0;
; 3744 :                 float v1 = glyph->V0;
; 3745 :                 float u2 = glyph->U1;
; 3746 :                 float v2 = glyph->V1;
; 3747 : 
; 3748 :                 // CPU side clipping used to fit text in their frame when the frame is too small. Only does clipping for axis aligned quads.
; 3749 :                 if (cpu_fine_clip)

	cmp	BYTE PTR cpu_fine_clip$[rsp], 0
	movss	xmm12, DWORD PTR [rax+24]
	movss	xmm13, DWORD PTR [rax+28]
	movss	xmm9, DWORD PTR [rax+32]
	movss	xmm10, DWORD PTR [rax+36]
	je	$LN32@RenderText

; 3750 :                 {
; 3751 :                     if (x1 < clip_rect.x)

	comiss	xmm5, xmm7
	jbe	SHORT $LN28@RenderText

; 3752 :                     {
; 3753 :                         u1 = u1 + (1.0f - (x2 - clip_rect.x) / (x2 - x1)) * (u2 - u1);

	movss	xmm1, DWORD PTR __real@3f800000
	movaps	xmm0, xmm3
	subss	xmm0, xmm7
	movaps	xmm2, xmm3
	subss	xmm2, xmm5

; 3754 :                         x1 = clip_rect.x;

	movaps	xmm7, xmm5
	divss	xmm2, xmm0
	movaps	xmm0, xmm9
	subss	xmm0, xmm12
	subss	xmm1, xmm2
	mulss	xmm1, xmm0
	addss	xmm12, xmm1
$LN28@RenderText:

; 3755 :                     }
; 3756 :                     if (y1 < clip_rect.y)

	movss	xmm5, DWORD PTR [r15+4]
	comiss	xmm5, xmm6
	jbe	SHORT $LN29@RenderText

; 3757 :                     {
; 3758 :                         v1 = v1 + (1.0f - (y2 - clip_rect.y) / (y2 - y1)) * (v2 - v1);

	movss	xmm1, DWORD PTR __real@3f800000
	movaps	xmm0, xmm4
	subss	xmm0, xmm6
	movaps	xmm2, xmm4
	subss	xmm2, xmm5

; 3759 :                         y1 = clip_rect.y;

	movaps	xmm6, xmm5
	divss	xmm2, xmm0
	movaps	xmm0, xmm10
	subss	xmm0, xmm13
	subss	xmm1, xmm2
	mulss	xmm1, xmm0
	addss	xmm13, xmm1
$LN29@RenderText:

; 3760 :                     }
; 3761 :                     if (x2 > clip_rect.z)

	comiss	xmm3, xmm11
	jbe	SHORT $LN30@RenderText

; 3762 :                     {
; 3763 :                         u2 = u1 + ((clip_rect.z - x1) / (x2 - x1)) * (u2 - u1);

	movaps	xmm0, xmm9
	subss	xmm3, xmm7
	movaps	xmm1, xmm11
	subss	xmm0, xmm12
	subss	xmm1, xmm7
	divss	xmm1, xmm3

; 3764 :                         x2 = clip_rect.z;

	movaps	xmm3, xmm11
	movaps	xmm9, xmm1
	mulss	xmm9, xmm0
	addss	xmm9, xmm12
$LN30@RenderText:

; 3765 :                     }
; 3766 :                     if (y2 > clip_rect.w)

	movss	xmm2, DWORD PTR [r15+12]
	comiss	xmm4, xmm2
	jbe	SHORT $LN31@RenderText

; 3767 :                     {
; 3768 :                         v2 = v1 + ((clip_rect.w - y1) / (y2 - y1)) * (v2 - v1);

	movaps	xmm0, xmm10
	subss	xmm4, xmm6
	movaps	xmm1, xmm2
	subss	xmm0, xmm13
	subss	xmm1, xmm6
	divss	xmm1, xmm4

; 3769 :                         y2 = clip_rect.w;

	movaps	xmm4, xmm2
	movaps	xmm10, xmm1
	mulss	xmm10, xmm0
	addss	xmm10, xmm13
$LN31@RenderText:

; 3770 :                     }
; 3771 :                     if (y1 >= y2)

	comiss	xmm6, xmm4
	jae	$LN26@RenderText
$LN32@RenderText:

; 3772 :                     {
; 3773 :                         x += char_width;
; 3774 :                         continue;
; 3775 :                     }
; 3776 :                 }
; 3777 : 
; 3778 :                 // Support for untinted glyphs
; 3779 :                 ImU32 glyph_col = glyph->Colored ? col_untinted : col;

	mov	eax, DWORD PTR col$[rsp]
	test	cl, 1

; 3780 : 
; 3781 :                 // We are NOT calling PrimRectUV() here because non-inlined causes too much overhead in a debug builds. Inlined here:
; 3782 :                 {
; 3783 :                     vtx_write[0].pos.x = x1; vtx_write[0].pos.y = y1; vtx_write[0].col = glyph_col; vtx_write[0].uv.x = u1; vtx_write[0].uv.y = v1;

	movss	DWORD PTR [rbp], xmm7
	cmovne	eax, DWORD PTR col_untinted$1$[rsp]
	mov	DWORD PTR [rbp+16], eax

; 3784 :                     vtx_write[1].pos.x = x2; vtx_write[1].pos.y = y1; vtx_write[1].col = glyph_col; vtx_write[1].uv.x = u2; vtx_write[1].uv.y = v1;

	mov	DWORD PTR [rbp+36], eax

; 3785 :                     vtx_write[2].pos.x = x2; vtx_write[2].pos.y = y2; vtx_write[2].col = glyph_col; vtx_write[2].uv.x = u2; vtx_write[2].uv.y = v2;

	mov	DWORD PTR [rbp+56], eax

; 3786 :                     vtx_write[3].pos.x = x1; vtx_write[3].pos.y = y2; vtx_write[3].col = glyph_col; vtx_write[3].uv.x = u1; vtx_write[3].uv.y = v2;

	mov	DWORD PTR [rbp+76], eax

; 3787 :                     idx_write[0] = (ImDrawIdx)(vtx_index); idx_write[1] = (ImDrawIdx)(vtx_index + 1); idx_write[2] = (ImDrawIdx)(vtx_index + 2);

	lea	eax, DWORD PTR [r13+1]
	movss	DWORD PTR [rbp+4], xmm6
	movss	DWORD PTR [rbp+8], xmm12
	movss	DWORD PTR [rbp+12], xmm13
	movss	DWORD PTR [rbp+20], xmm3
	movss	DWORD PTR [rbp+24], xmm6
	movss	DWORD PTR [rbp+28], xmm9
	movss	DWORD PTR [rbp+32], xmm13
	movss	DWORD PTR [rbp+40], xmm3
	movss	DWORD PTR [rbp+44], xmm4
	movss	DWORD PTR [rbp+48], xmm9
	movss	DWORD PTR [rbp+52], xmm10
	movss	DWORD PTR [rbp+60], xmm7
	movss	DWORD PTR [rbp+64], xmm4
	movss	DWORD PTR [rbp+68], xmm12
	movss	DWORD PTR [rbp+72], xmm10

; 3788 :                     idx_write[3] = (ImDrawIdx)(vtx_index); idx_write[4] = (ImDrawIdx)(vtx_index + 2); idx_write[5] = (ImDrawIdx)(vtx_index + 3);
; 3789 :                     vtx_write += 4;

	add	rbp, 80					; 00000050H
	mov	WORD PTR [r12+2], ax
	lea	eax, DWORD PTR [r13+2]
	mov	WORD PTR [r12+4], ax
	mov	WORD PTR [r12+8], ax
	lea	eax, DWORD PTR [r13+3]
	mov	WORD PTR [r12], r13w
	mov	WORD PTR [r12+6], r13w

; 3790 :                     vtx_index += 4;

	add	r13d, 4
	mov	WORD PTR [r12+10], ax

; 3791 :                     idx_write += 6;

	add	r12, 12
$LN26@RenderText:

; 3688 : 
; 3689 :     while (s < text_end)

	addss	xmm15, xmm8
	movss	xmm8, DWORD PTR line_height$1$[rsp]
$LN77@RenderText:
	movss	xmm9, DWORD PTR size$[rsp]
	movss	xmm6, DWORD PTR start_x$1$[rsp]
	movss	xmm7, DWORD PTR wrap_width$[rsp]
	cmp	rbx, rdi
	jb	$LL6@RenderText
$LN103@RenderText:
	mov	r8, QWORD PTR draw_list$[rsp]
	movaps	xmm13, XMMWORD PTR [rsp+96]
	movaps	xmm12, XMMWORD PTR [rsp+112]
	movaps	xmm11, XMMWORD PTR [rsp+128]
	movaps	xmm10, XMMWORD PTR [rsp+144]
$LN72@RenderText:

; 3792 :                 }
; 3793 :             }
; 3794 :         }
; 3795 :         x += char_width;
; 3796 :     }
; 3797 : 
; 3798 :     // Give back unused vertices (clipped ones, blanks) ~ this is essentially a PrimUnreserve() action.
; 3799 :     draw_list->VtxBuffer.Size = (int)(vtx_write - draw_list->VtxBuffer.Data); // Same as calling shrink()

	mov	rcx, -3689348814741910323		; cccccccccccccccdH

; 3800 :     draw_list->IdxBuffer.Size = (int)(idx_write - draw_list->IdxBuffer.Data);

	mov	rdx, r12
	sub	rdx, QWORD PTR [r8+24]
	mov	rax, rbp
	sub	rax, QWORD PTR [r8+40]
	sar	rax, 2
	imul	rax, rcx
	sar	rdx, 1
	mov	DWORD PTR [r8+32], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rax, DWORD PTR [r8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3800 :     draw_list->IdxBuffer.Size = (int)(idx_write - draw_list->IdxBuffer.Data);

	mov	DWORD PTR [r8+16], edx

; 3801 :     draw_list->CmdBuffer[draw_list->CmdBuffer.Size - 1].ElemCount -= (idx_expected_size - draw_list->IdxBuffer.Size);

	sub	edx, DWORD PTR idx_expected_size$1$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	imul	rcx, rax, 56				; 00000038H
	mov	rax, QWORD PTR [r8+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3801 :     draw_list->CmdBuffer[draw_list->CmdBuffer.Size - 1].ElemCount -= (idx_expected_size - draw_list->IdxBuffer.Size);

	add	DWORD PTR [rcx+rax-24], edx

; 3802 :     draw_list->_VtxWritePtr = vtx_write;
; 3803 :     draw_list->_IdxWritePtr = idx_write;

	mov	QWORD PTR [r8+80], r12

; 3804 :     draw_list->_VtxCurrentIdx = vtx_index;

	mov	r12, QWORD PTR [rsp+288]
	mov	DWORD PTR [r8+52], r13d
	mov	r13, QWORD PTR [rsp+232]
	mov	QWORD PTR [r8+72], rbp
$LN145@RenderText:
	movaps	xmm7, XMMWORD PTR [rsp+192]
	movaps	xmm6, XMMWORD PTR [rsp+208]
	mov	r14, QWORD PTR [rsp+224]
	movaps	xmm8, XMMWORD PTR [rsp+176]
$LN1@RenderText:

; 3805 : }

	movaps	xmm9, XMMWORD PTR [rsp+160]
	movaps	xmm14, XMMWORD PTR [rsp+80]
	movaps	xmm15, XMMWORD PTR [rsp+64]
	add	rsp, 240				; 000000f0H
	pop	r15
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
?RenderText@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IAEBUImVec4@@PEBD3M_N@Z ENDP ; ImFont::RenderText
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?RenderArrow@ImGui@@YAXPEAUImDrawList@@UImVec2@@IHM@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 48
pos$ = 48
draw_list$ = 144
col$ = 160
dir$ = 168
scale$ = 176
?RenderArrow@ImGui@@YAXPEAUImDrawList@@UImVec2@@IHM@Z PROC ; ImGui::RenderArrow, COMDAT

; 3825 : {

$LN87:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 128				; 00000080H

; 3826 :     const float h = draw_list->_Data->FontSize * 1.00f;

	mov	rax, QWORD PTR [rcx+56]
	mov	rbx, rcx
	movaps	XMMWORD PTR [rsp+112], xmm6
	mov	edi, r8d
	movaps	XMMWORD PTR [rsp+96], xmm7
	xorps	xmm3, xmm3
	movaps	XMMWORD PTR [rsp+80], xmm8
	xorps	xmm6, xmm6
	movss	xmm2, DWORD PTR [rax+16]
	xorps	xmm4, xmm4
	mov	QWORD PTR pos$[rsp], rdx

; 3827 :     float r = h * 0.40f * scale;

	movaps	xmm1, xmm2

; 3828 :     ImVec2 center = pos + ImVec2(h * 0.50f, h * 0.50f * scale);

	mulss	xmm2, DWORD PTR __real@3f000000
	xorps	xmm5, xmm5

; 3831 :     switch (dir)

	mov	ecx, r9d
	mulss	xmm1, DWORD PTR __real@3ecccccd
	xorps	xmm8, xmm8
	movaps	XMMWORD PTR [rsp+64], xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm7, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3828 :     ImVec2 center = pos + ImVec2(h * 0.50f, h * 0.50f * scale);

	mulss	xmm2, DWORD PTR scale$[rsp]
	xorps	xmm9, xmm9
	mulss	xmm1, DWORD PTR scale$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm2, DWORD PTR pos$[rsp+4]
	addss	xmm7, DWORD PTR pos$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3831 :     switch (dir)

	test	r9d, r9d
	je	SHORT $LN85@RenderArro
	sub	ecx, 1
	je	SHORT $LN7@RenderArro
	sub	ecx, 1
	je	SHORT $LN4@RenderArro
	cmp	ecx, 1
	jne	$LN10@RenderArro
$LN4@RenderArro:

; 3832 :     {
; 3833 :     case ImGuiDir_Up:
; 3834 :     case ImGuiDir_Down:
; 3835 :         if (dir == ImGuiDir_Up) r = -r;

	cmp	r9d, 2
	jne	SHORT $LN6@RenderArro
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
$LN6@RenderArro:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm5, xmm1
	movaps	xmm6, xmm1
	mulss	xmm5, DWORD PTR __real@bf400000
	movaps	xmm4, xmm1
	mulss	xmm4, DWORD PTR __real@bf5db22d
	movaps	xmm8, xmm1
	mulss	xmm8, DWORD PTR __real@3f5db22d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3838 :         c = ImVec2(+0.866f, -0.750f) * r;

	movaps	xmm9, xmm5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mulss	xmm6, xmm3
	movaps	xmm3, xmm1
	mulss	xmm3, DWORD PTR __real@3f400000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3839 :         break;

	jmp	SHORT $LN10@RenderArro
$LN7@RenderArro:

; 3840 :     case ImGuiDir_Left:
; 3841 :     case ImGuiDir_Right:
; 3842 :         if (dir == ImGuiDir_Left) r = -r;

	test	r9d, r9d
	jne	SHORT $LN9@RenderArro
$LN85@RenderArro:
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
$LN9@RenderArro:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm0, xmm1
	movaps	xmm4, xmm1
	mulss	xmm4, DWORD PTR __real@bf400000
	movaps	xmm6, xmm1
	mulss	xmm6, DWORD PTR __real@3f400000
	movaps	xmm5, xmm1
	mulss	xmm5, DWORD PTR __real@3f5db22d
	movaps	xmm9, xmm1
	mulss	xmm9, DWORD PTR __real@bf5db22d
	movaps	xmm8, xmm4
	mulss	xmm0, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3845 :         c = ImVec2(-0.750f, -0.866f) * r;

	movaps	xmm3, xmm0
$LN10@RenderArro:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movaps	xmm0, xmm7

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm1, xmm2

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm0, xmm8

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm1, xmm9
	movss	DWORD PTR $T2[rsp], xmm0
	movaps	xmm0, xmm7
	movss	DWORD PTR $T2[rsp+4], xmm1
	movaps	xmm1, xmm2
	addss	xmm0, xmm4
	addss	xmm1, xmm5
	addss	xmm7, xmm6
	addss	xmm2, xmm3
	movss	DWORD PTR $T1[rsp], xmm0
	movss	DWORD PTR $T1[rsp+4], xmm1
	movss	DWORD PTR $T3[rsp], xmm7
	movss	DWORD PTR $T3[rsp+4], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1473 :     if ((col & IM_COL32_A_MASK) == 0)

	test	edi, -16777216				; ff000000H
	je	SHORT $LN37@RenderArro

; 1474 :         return;
; 1475 : 
; 1476 :     PathLineTo(p1);

	lea	rdx, QWORD PTR $T3[rsp]
	mov	rcx, rbx
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo

; 1477 :     PathLineTo(p2);

	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rbx
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo

; 1478 :     PathLineTo(p3);

	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, rbx
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	r8d, DWORD PTR [rbx+120]
	mov	r9d, edi
	mov	rdx, QWORD PTR [rbx+128]
	mov	rcx, rbx
	call	?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z ; ImDrawList::AddConvexPolyFilled
	mov	DWORD PTR [rbx+120], 0
$LN37@RenderArro:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3853 : }

	mov	rbx, QWORD PTR [rsp+160]
	movaps	xmm6, XMMWORD PTR [rsp+112]
	movaps	xmm7, XMMWORD PTR [rsp+96]
	movaps	xmm8, XMMWORD PTR [rsp+80]
	movaps	xmm9, XMMWORD PTR [rsp+64]
	add	rsp, 128				; 00000080H
	pop	rdi
	ret	0
?RenderArrow@ImGui@@YAXPEAUImDrawList@@UImVec2@@IHM@Z ENDP ; ImGui::RenderArrow
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?RenderCheckMark@ImGui@@YAXPEAUImDrawList@@UImVec2@@IM@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 48
$T3 = 48
pos$ = 48
draw_list$ = 176
col$ = 192
sz$ = 200
?RenderCheckMark@ImGui@@YAXPEAUImDrawList@@UImVec2@@IM@Z PROC ; ImGui::RenderCheckMark, COMDAT

; 3862 : {

$LN53:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 136				; 00000088H
	movaps	XMMWORD PTR [rsp+112], xmm6
	mov	rsi, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	ecx, DWORD PTR [rcx+120]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3862 : {

	mov	ebp, r8d
	movaps	XMMWORD PTR [rsp+96], xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edi, 8
	movaps	XMMWORD PTR [rsp+80], xmm8
	mov	r8d, DWORD PTR [rsi+124]
	movaps	XMMWORD PTR [rsp+64], xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3863 :     float thickness = ImMax(sz / 5.0f, 1.0f);

	movaps	xmm9, xmm3
	mov	QWORD PTR pos$[rsp], rdx
	divss	xmm9, DWORD PTR __real@40a00000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm9, DWORD PTR __real@3f800000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3864 :     sz -= thickness * 0.5f;

	movaps	xmm0, xmm9

; 3865 :     pos += ImVec2(thickness * 0.25f, thickness * 0.25f);

	movaps	xmm6, xmm9
	mulss	xmm0, DWORD PTR __real@3f000000
	mulss	xmm6, DWORD PTR __real@3e800000
	subss	xmm3, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm8, xmm6

; 2545 : static inline ImVec2& operator+=(ImVec2& lhs, const ImVec2& rhs)        { lhs.x += rhs.x; lhs.y += rhs.y; return lhs; }

	addss	xmm6, DWORD PTR pos$[rsp+4]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm8, DWORD PTR pos$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3867 :     float third = sz / 3.0f;

	movaps	xmm7, xmm3
	divss	xmm7, DWORD PTR __real@40400000

; 3868 :     float bx = pos.x + third;

	addss	xmm6, xmm3
	addss	xmm8, xmm7

; 3869 :     float by = pos.y + sz - third * 0.5f;

	movaps	xmm0, xmm7
	mulss	xmm0, DWORD PTR __real@3f000000
	subss	xmm6, xmm0

; 3870 :     draw_list->PathLineTo(ImVec2(bx - third, by - third));

	movaps	xmm0, xmm8
	subss	xmm0, xmm7
	movaps	xmm1, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T3[rsp], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3870 :     draw_list->PathLineTo(ImVec2(bx - third, by - third));

	subss	xmm1, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T3[rsp+4], xmm1

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	cmp	ecx, r8d
	jne	SHORT $LN16@RenderChec
	inc	ecx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	r8d, r8d
	je	SHORT $LN20@RenderChec
	mov	eax, r8d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r8d
	jmp	SHORT $LN21@RenderChec
$LN20@RenderChec:
	mov	eax, edi
$LN21@RenderChec:
	cmp	eax, ecx
	cmovg	ecx, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, ecx
	lea	rcx, QWORD PTR [rsi+120]
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN16@RenderChec:
	mov	rax, QWORD PTR $T3[rsp]
	movsxd	rdx, DWORD PTR [rsi+120]
	mov	rcx, QWORD PTR [rsi+128]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T2[rsp], xmm8
	movss	DWORD PTR $T2[rsp+4], xmm6

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	QWORD PTR [rcx+rdx*8], rax
	mov	ecx, DWORD PTR [rsi+120]
	inc	ecx
	mov	DWORD PTR [rsi+120], ecx
	mov	r8d, DWORD PTR [rsi+124]
	cmp	ecx, r8d
	jne	SHORT $LN27@RenderChec
	inc	ecx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	r8d, r8d
	je	SHORT $LN31@RenderChec
	mov	eax, r8d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r8d
	jmp	SHORT $LN32@RenderChec
$LN31@RenderChec:
	mov	eax, edi
$LN32@RenderChec:
	cmp	eax, ecx
	cmovg	ecx, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, ecx
	lea	rcx, QWORD PTR [rsi+120]
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN27@RenderChec:
	mov	rax, QWORD PTR $T2[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3872 :     draw_list->PathLineTo(ImVec2(bx + third * 2.0f, by - third * 2.0f));

	addss	xmm7, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	movsxd	rdx, DWORD PTR [rsi+120]
	mov	rcx, QWORD PTR [rsi+128]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3872 :     draw_list->PathLineTo(ImVec2(bx + third * 2.0f, by - third * 2.0f));

	movaps	xmm0, xmm7
	subss	xmm6, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	QWORD PTR [rcx+rdx*8], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3872 :     draw_list->PathLineTo(ImVec2(bx + third * 2.0f, by - third * 2.0f));

	addss	xmm0, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	ecx, DWORD PTR [rsi+120]
	inc	ecx
	mov	DWORD PTR [rsi+120], ecx
	mov	r8d, DWORD PTR [rsi+124]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T1[rsp], xmm0
	movss	DWORD PTR $T1[rsp+4], xmm6

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	cmp	ecx, r8d
	jne	SHORT $LN38@RenderChec
	inc	ecx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	r8d, r8d
	je	SHORT $LN42@RenderChec
	mov	eax, r8d
	cdq
	sub	eax, edx
	sar	eax, 1
	lea	edi, DWORD PTR [r8+rax]
$LN42@RenderChec:
	cmp	edi, ecx
	cmovg	ecx, edi

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, ecx
	lea	rcx, QWORD PTR [rsi+120]
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN38@RenderChec:
	movsxd	r8, DWORD PTR [rsi+120]

; 2808 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

	xor	edi, edi

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rdx, QWORD PTR [rsi+128]

; 2808 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

	mov	r9d, ebp

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rax, QWORD PTR $T1[rsp]

; 2808 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

	mov	rcx, rsi
	movss	DWORD PTR [rsp+40], xmm9
	mov	DWORD PTR [rsp+32], edi

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	QWORD PTR [rdx+r8*8], rax
	inc	DWORD PTR [rsi+120]

; 2808 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

	mov	r8d, DWORD PTR [rsi+120]
	mov	rdx, QWORD PTR [rsi+128]
	call	?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z ; ImDrawList::AddPolyline
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3874 : }

	movaps	xmm6, XMMWORD PTR [rsp+112]
	movaps	xmm7, XMMWORD PTR [rsp+96]
	movaps	xmm8, XMMWORD PTR [rsp+80]
	movaps	xmm9, XMMWORD PTR [rsp+64]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2808 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

	mov	DWORD PTR [rsi+120], edi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3874 : }

	add	rsp, 136				; 00000088H
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
?RenderCheckMark@ImGui@@YAXPEAUImDrawList@@UImVec2@@IM@Z ENDP ; ImGui::RenderCheckMark
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?RenderArrowPointingAt@ImGui@@YAXPEAUImDrawList@@UImVec2@@1HI@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
half_sz$ = 48
pos$ = 56
draw_list$ = 96
direction$ = 120
col$ = 128
?RenderArrowPointingAt@ImGui@@YAXPEAUImDrawList@@UImVec2@@1HI@Z PROC ; ImGui::RenderArrowPointingAt, COMDAT

; 3878 : {

$LN169:
	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	QWORD PTR half_sz$[rsp], r8
	mov	rsi, rcx
	mov	QWORD PTR pos$[rsp], rdx

; 3879 :     switch (direction)

	test	r9d, r9d
	je	$LN4@RenderArro
	sub	r9d, 1
	je	$LN5@RenderArro
	sub	r9d, 1
	je	$LN6@RenderArro
	cmp	r9d, 1
	jne	$LN15@RenderArro

; 3884 :     case ImGuiDir_Down:  draw_list->AddTriangleFilled(ImVec2(pos.x - half_sz.x, pos.y - half_sz.y), ImVec2(pos.x + half_sz.x, pos.y - half_sz.y), pos, col); return;

	movss	xmm3, DWORD PTR half_sz$[rsp]
	movss	xmm2, DWORD PTR pos$[rsp]
	movaps	xmm0, xmm3
	movss	xmm1, DWORD PTR pos$[rsp+4]
	addss	xmm0, xmm2
	subss	xmm1, DWORD PTR half_sz$[rsp+4]

; 1473 :     if ((col & IM_COL32_A_MASK) == 0)

	mov	ebp, DWORD PTR col$[rsp]

; 3884 :     case ImGuiDir_Down:  draw_list->AddTriangleFilled(ImVec2(pos.x - half_sz.x, pos.y - half_sz.y), ImVec2(pos.x + half_sz.x, pos.y - half_sz.y), pos, col); return;

	subss	xmm2, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T5[rsp], xmm0
	movss	DWORD PTR $T5[rsp+4], xmm1
	movss	DWORD PTR $T1[rsp], xmm2
	movss	DWORD PTR $T1[rsp+4], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1473 :     if ((col & IM_COL32_A_MASK) == 0)

	test	ebp, -16777216				; ff000000H
	je	$LN15@RenderArro
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	r8d, DWORD PTR [rcx+120]
	lea	ebx, QWORD PTR [r9+7]
	mov	ecx, DWORD PTR [rcx+124]
	cmp	r8d, ecx
	jne	SHORT $LN111@RenderArro
	inc	r8d

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN115@RenderArro
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN116@RenderArro
$LN115@RenderArro:
	mov	eax, ebx
$LN116@RenderArro:
	cmp	eax, r8d

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	lea	rcx, QWORD PTR [rsi+120]

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	r8d, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, r8d
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN111@RenderArro:
	movsxd	rdx, DWORD PTR [rsi+120]
	mov	rcx, QWORD PTR [rsi+128]
	mov	rax, QWORD PTR $T1[rsp]
	mov	QWORD PTR [rcx+rdx*8], rax
	mov	ecx, DWORD PTR [rsi+120]
	inc	ecx
	mov	DWORD PTR [rsi+120], ecx
	mov	r8d, DWORD PTR [rsi+124]
	cmp	ecx, r8d
	jne	SHORT $LN120@RenderArro
	inc	ecx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	r8d, r8d
	je	SHORT $LN124@RenderArro
	mov	eax, r8d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r8d
	jmp	SHORT $LN125@RenderArro
$LN124@RenderArro:
	mov	eax, ebx
$LN125@RenderArro:
	cmp	eax, ecx
	cmovg	ecx, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, ecx
	lea	rcx, QWORD PTR [rsi+120]
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN120@RenderArro:
	movsxd	rdx, DWORD PTR [rsi+120]
	mov	rcx, QWORD PTR [rsi+128]
	mov	rax, QWORD PTR $T5[rsp]
	mov	QWORD PTR [rcx+rdx*8], rax
	mov	ecx, DWORD PTR [rsi+120]
	inc	ecx
	mov	DWORD PTR [rsi+120], ecx
	mov	r8d, DWORD PTR [rsi+124]
	cmp	ecx, r8d
	jne	SHORT $LN129@RenderArro
	inc	ecx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	r8d, r8d
	je	SHORT $LN133@RenderArro
	mov	eax, r8d
	cdq
	sub	eax, edx
	sar	eax, 1
	lea	ebx, DWORD PTR [r8+rax]
$LN133@RenderArro:
	cmp	ebx, ecx
	cmovg	ecx, ebx

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, ecx
	lea	rcx, QWORD PTR [rsi+120]
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN129@RenderArro:
	movsxd	r8, DWORD PTR [rsi+120]
	mov	rdx, QWORD PTR [rsi+128]
	mov	rax, QWORD PTR pos$[rsp]
	mov	QWORD PTR [rdx+r8*8], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3884 :     case ImGuiDir_Down:  draw_list->AddTriangleFilled(ImVec2(pos.x - half_sz.x, pos.y - half_sz.y), ImVec2(pos.x + half_sz.x, pos.y - half_sz.y), pos, col); return;

	jmp	$LN165@RenderArro
$LN6@RenderArro:

; 3883 :     case ImGuiDir_Up:    draw_list->AddTriangleFilled(ImVec2(pos.x + half_sz.x, pos.y + half_sz.y), ImVec2(pos.x - half_sz.x, pos.y + half_sz.y), pos, col); return;

	movss	xmm3, DWORD PTR pos$[rsp]
	movss	xmm2, DWORD PTR half_sz$[rsp]
	movaps	xmm0, xmm3
	movss	xmm1, DWORD PTR half_sz$[rsp+4]
	subss	xmm0, xmm2
	addss	xmm1, DWORD PTR pos$[rsp+4]
	addss	xmm2, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T2[rsp], xmm0
	movss	DWORD PTR $T2[rsp+4], xmm1
	movss	DWORD PTR $T6[rsp], xmm2
$LN167@RenderArro:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3887 : }

	mov	ebp, DWORD PTR col$[rsp]
	movss	DWORD PTR $T6[rsp+4], xmm1
	test	ebp, -16777216				; ff000000H
	je	$LN15@RenderArro
	mov	r8d, DWORD PTR [rcx+120]
	mov	ebx, 8
	mov	ecx, DWORD PTR [rcx+124]
	cmp	r8d, ecx
	jne	SHORT $LN75@RenderArro
	inc	r8d
	test	ecx, ecx
	je	SHORT $LN79@RenderArro
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN80@RenderArro
$LN79@RenderArro:
	mov	eax, ebx
$LN80@RenderArro:
	cmp	eax, r8d
	lea	rcx, QWORD PTR [rsi+120]
	cmovg	r8d, eax
	mov	edx, r8d
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN75@RenderArro:
	mov	rcx, QWORD PTR [rsi+128]
	movsxd	rdx, DWORD PTR [rsi+120]
	mov	rax, QWORD PTR $T6[rsp]
	mov	QWORD PTR [rcx+rdx*8], rax
	mov	ecx, DWORD PTR [rsi+120]
	inc	ecx
	mov	DWORD PTR [rsi+120], ecx
	mov	r8d, DWORD PTR [rsi+124]
	cmp	ecx, r8d
	jne	SHORT $LN84@RenderArro
	inc	ecx
	test	r8d, r8d
	je	SHORT $LN88@RenderArro
	mov	eax, r8d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r8d
	jmp	SHORT $LN89@RenderArro
$LN88@RenderArro:
	mov	eax, ebx
$LN89@RenderArro:
	cmp	eax, ecx
	cmovg	ecx, eax
	mov	edx, ecx
	lea	rcx, QWORD PTR [rsi+120]
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN84@RenderArro:
	mov	rcx, QWORD PTR [rsi+128]
	movsxd	rdx, DWORD PTR [rsi+120]
	mov	rax, QWORD PTR $T2[rsp]
	mov	QWORD PTR [rcx+rdx*8], rax
	mov	ecx, DWORD PTR [rsi+120]
	inc	ecx
	mov	DWORD PTR [rsi+120], ecx
	mov	r8d, DWORD PTR [rsi+124]
	cmp	ecx, r8d
	jne	$LN21@RenderArro
	inc	ecx
	test	r8d, r8d
	je	$LN26@RenderArro
$LN166@RenderArro:
	mov	eax, r8d
	cdq
	sub	eax, edx
	sar	eax, 1
	lea	ebx, DWORD PTR [r8+rax]
	jmp	$LN26@RenderArro
$LN5@RenderArro:

; 3882 :     case ImGuiDir_Right: draw_list->AddTriangleFilled(ImVec2(pos.x - half_sz.x, pos.y + half_sz.y), ImVec2(pos.x - half_sz.x, pos.y - half_sz.y), pos, col); return;

	movss	xmm2, DWORD PTR pos$[rsp+4]
	movss	xmm1, DWORD PTR half_sz$[rsp+4]
	movaps	xmm0, xmm2
	movss	xmm3, DWORD PTR pos$[rsp]
	subss	xmm0, xmm1
	subss	xmm3, DWORD PTR half_sz$[rsp]
	addss	xmm1, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T3[rsp+4], xmm0
	movss	DWORD PTR $T3[rsp], xmm3
	movss	DWORD PTR $T7[rsp], xmm3

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	jmp	$LN167@RenderArro
$LN4@RenderArro:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3881 :     case ImGuiDir_Left:  draw_list->AddTriangleFilled(ImVec2(pos.x + half_sz.x, pos.y - half_sz.y), ImVec2(pos.x + half_sz.x, pos.y + half_sz.y), pos, col); return;

	movss	xmm2, DWORD PTR half_sz$[rsp+4]
	movss	xmm1, DWORD PTR pos$[rsp+4]
	movaps	xmm0, xmm2
	movss	xmm3, DWORD PTR half_sz$[rsp]
	addss	xmm0, xmm1
	addss	xmm3, DWORD PTR pos$[rsp]

; 1473 :     if ((col & IM_COL32_A_MASK) == 0)

	mov	ebp, DWORD PTR col$[rsp]

; 3881 :     case ImGuiDir_Left:  draw_list->AddTriangleFilled(ImVec2(pos.x + half_sz.x, pos.y - half_sz.y), ImVec2(pos.x + half_sz.x, pos.y + half_sz.y), pos, col); return;

	subss	xmm1, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T4[rsp+4], xmm0
	movss	DWORD PTR $T4[rsp], xmm3
	movss	DWORD PTR $T8[rsp+4], xmm1
	movss	DWORD PTR $T8[rsp], xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1473 :     if ((col & IM_COL32_A_MASK) == 0)

	test	ebp, -16777216				; ff000000H
	je	SHORT $LN15@RenderArro

; 1474 :         return;
; 1475 : 
; 1476 :     PathLineTo(p1);

	lea	rdx, QWORD PTR $T8[rsp]
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo

; 1477 :     PathLineTo(p2);

	lea	rdx, QWORD PTR $T4[rsp]
	mov	rcx, rsi
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	ecx, DWORD PTR [rsi+120]
	mov	r8d, DWORD PTR [rsi+124]
	cmp	ecx, r8d
	jne	SHORT $LN21@RenderArro
	inc	ecx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	r8d, r8d
	jne	$LN166@RenderArro
	mov	ebx, 8
$LN26@RenderArro:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3887 : }

	cmp	ebx, ecx
	cmovg	ecx, ebx
	mov	edx, ecx
	lea	rcx, QWORD PTR [rsi+120]
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN21@RenderArro:
	movsxd	rdx, DWORD PTR [rsi+120]
	mov	rcx, QWORD PTR [rsi+128]
	mov	rax, QWORD PTR pos$[rsp]
	mov	QWORD PTR [rcx+rdx*8], rax
$LN165@RenderArro:
	inc	DWORD PTR [rsi+120]
	mov	r9d, ebp
	mov	r8d, DWORD PTR [rsi+120]
	mov	rcx, rsi
	mov	rdx, QWORD PTR [rsi+128]
	call	?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z ; ImDrawList::AddConvexPolyFilled
	mov	DWORD PTR [rsi+120], 0
$LN15@RenderArro:
	mov	rbx, QWORD PTR [rsp+120]
	add	rsp, 64					; 00000040H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?RenderArrowPointingAt@ImGui@@YAXPEAUImDrawList@@UImVec2@@1HI@Z ENDP ; ImGui::RenderArrowPointingAt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?RenderArrowDockMenu@ImGui@@YAXPEAUImDrawList@@UImVec2@@MI@Z
_TEXT	SEGMENT
$T2 = 48
$T3 = 56
pos$ = 64
p_min$ = 64
draw_list$ = 144
sz$ = 160
col$ = 168
?RenderArrowDockMenu@ImGui@@YAXPEAUImDrawList@@UImVec2@@MI@Z PROC ; ImGui::RenderArrowDockMenu, COMDAT

; 3892 : {

$LN167:
	mov	rax, rsp
	push	rbp
	push	rsi
	sub	rsp, 120				; 00000078H
	mov	QWORD PTR p_min$[rsp], rdx

; 3893 :     draw_list->AddRectFilled(p_min + ImVec2(sz * 0.20f, sz * 0.15f), p_min + ImVec2(sz * 0.80f, sz * 0.30f), col);

	lea	r8, QWORD PTR [rax-88]
	movaps	XMMWORD PTR [rax-40], xmm8
	lea	rdx, QWORD PTR [rax-80]
	movaps	xmm0, xmm2
	movaps	XMMWORD PTR [rax-56], xmm9
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	movaps	xmm8, xmm2
	mov	DWORD PTR [rax-96], 0
	mov	ebp, r9d
	mulss	xmm8, DWORD PTR __real@3e99999a
	movaps	xmm1, xmm2
	mov	rsi, rcx
	mulss	xmm1, DWORD PTR __real@3e4ccccd
	movaps	xmm9, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm0, DWORD PTR p_min$[rsp]
	addss	xmm1, DWORD PTR p_min$[rsp]
	movss	DWORD PTR [rax-88], xmm0
	movaps	xmm0, xmm8
	addss	xmm0, DWORD PTR p_min$[rsp+4]
	movss	DWORD PTR [rax-80], xmm1
	movss	DWORD PTR [rax-84], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3893 :     draw_list->AddRectFilled(p_min + ImVec2(sz * 0.20f, sz * 0.15f), p_min + ImVec2(sz * 0.80f, sz * 0.30f), col);

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR __real@3e19999a
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm0, DWORD PTR p_min$[rsp+4]
	movss	DWORD PTR [rax-76], xmm0
	xorps	xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3893 :     draw_list->AddRectFilled(p_min + ImVec2(sz * 0.20f, sz * 0.15f), p_min + ImVec2(sz * 0.80f, sz * 0.30f), col);

	movss	DWORD PTR [rax-104], xmm0
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled

; 3894 :     RenderArrowPointingAt(draw_list, p_min + ImVec2(sz * 0.50f, sz * 0.85f), ImVec2(sz * 0.30f, sz * 0.40f), ImGuiDir_Down, col);

	movaps	xmm2, xmm9
	movaps	xmm1, xmm9
	mulss	xmm2, DWORD PTR __real@3f000000
	mulss	xmm1, DWORD PTR __real@3f59999a
	mulss	xmm9, DWORD PTR __real@3ecccccd
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm2, DWORD PTR p_min$[rsp]
	addss	xmm1, DWORD PTR p_min$[rsp+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3894 :     RenderArrowPointingAt(draw_list, p_min + ImVec2(sz * 0.50f, sz * 0.85f), ImVec2(sz * 0.30f, sz * 0.40f), ImGuiDir_Down, col);

	movss	DWORD PTR pos$[rsp], xmm2

; 3884 :     case ImGuiDir_Down:  draw_list->AddTriangleFilled(ImVec2(pos.x - half_sz.x, pos.y - half_sz.y), ImVec2(pos.x + half_sz.x, pos.y - half_sz.y), pos, col); return;

	movaps	xmm0, xmm2

; 3894 :     RenderArrowPointingAt(draw_list, p_min + ImVec2(sz * 0.50f, sz * 0.85f), ImVec2(sz * 0.30f, sz * 0.40f), ImGuiDir_Down, col);

	movss	DWORD PTR pos$[rsp+4], xmm1

; 3884 :     case ImGuiDir_Down:  draw_list->AddTriangleFilled(ImVec2(pos.x - half_sz.x, pos.y - half_sz.y), ImVec2(pos.x + half_sz.x, pos.y - half_sz.y), pos, col); return;

	subss	xmm1, xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm9, XMMWORD PTR [rsp+80]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3884 :     case ImGuiDir_Down:  draw_list->AddTriangleFilled(ImVec2(pos.x - half_sz.x, pos.y - half_sz.y), ImVec2(pos.x + half_sz.x, pos.y - half_sz.y), pos, col); return;

	addss	xmm0, xmm8
	subss	xmm2, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm8, XMMWORD PTR [rsp+96]
	movss	DWORD PTR $T2[rsp+4], xmm1
	movss	DWORD PTR $T2[rsp], xmm0
	movss	DWORD PTR $T3[rsp], xmm2
	movss	DWORD PTR $T3[rsp+4], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1473 :     if ((col & IM_COL32_A_MASK) == 0)

	test	ebp, -16777216				; ff000000H
	je	$LN127@RenderArro
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	r8d, DWORD PTR [rsi+120]
	mov	ecx, DWORD PTR [rsi+124]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1473 :     if ((col & IM_COL32_A_MASK) == 0)

	mov	QWORD PTR [rsp+160], rbx
	mov	QWORD PTR [rsp+112], rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edi, 8
	cmp	r8d, ecx
	jne	SHORT $LN133@RenderArro
	inc	r8d

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN137@RenderArro
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN138@RenderArro
$LN137@RenderArro:
	mov	eax, edi
$LN138@RenderArro:
	cmp	eax, r8d

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	lea	rcx, QWORD PTR [rsi+120]

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	r8d, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, r8d
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN133@RenderArro:
	movsxd	rdx, DWORD PTR [rsi+120]
	mov	rcx, QWORD PTR [rsi+128]
	mov	rax, QWORD PTR $T3[rsp]
	mov	QWORD PTR [rcx+rdx*8], rax
	mov	ecx, DWORD PTR [rsi+120]
	inc	ecx
	mov	DWORD PTR [rsi+120], ecx
	mov	r8d, DWORD PTR [rsi+124]
	cmp	ecx, r8d
	jne	SHORT $LN142@RenderArro
	inc	ecx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	r8d, r8d
	je	SHORT $LN146@RenderArro
	mov	eax, r8d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r8d
	jmp	SHORT $LN147@RenderArro
$LN146@RenderArro:
	mov	eax, edi
$LN147@RenderArro:
	cmp	eax, ecx
	cmovg	ecx, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, ecx
	lea	rcx, QWORD PTR [rsi+120]
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN142@RenderArro:
	movsxd	rdx, DWORD PTR [rsi+120]
	mov	rcx, QWORD PTR [rsi+128]
	mov	rax, QWORD PTR $T2[rsp]
	mov	QWORD PTR [rcx+rdx*8], rax
	mov	ecx, DWORD PTR [rsi+120]
	inc	ecx
	mov	DWORD PTR [rsi+120], ecx
	mov	r8d, DWORD PTR [rsi+124]
	cmp	ecx, r8d
	jne	SHORT $LN151@RenderArro
	inc	ecx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	r8d, r8d
	je	SHORT $LN155@RenderArro
	mov	eax, r8d
	cdq
	sub	eax, edx
	sar	eax, 1
	lea	edi, DWORD PTR [r8+rax]
$LN155@RenderArro:
	cmp	edi, ecx
	cmovg	ecx, edi

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, ecx
	lea	rcx, QWORD PTR [rsi+120]
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN151@RenderArro:
	movsxd	r8, DWORD PTR [rsi+120]

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	r9d, ebp

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rdx, QWORD PTR [rsi+128]

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	rcx, rsi

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rax, QWORD PTR pos$[rsp]
	mov	QWORD PTR [rdx+r8*8], rax
	inc	DWORD PTR [rsi+120]

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	r8d, DWORD PTR [rsi+120]
	mov	rdx, QWORD PTR [rsi+128]
	call	?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z ; ImDrawList::AddConvexPolyFilled
	mov	rdi, QWORD PTR [rsp+112]
	mov	rbx, QWORD PTR [rsp+160]
	mov	DWORD PTR [rsi+120], 0
$LN127@RenderArro:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3895 : }

	add	rsp, 120				; 00000078H
	pop	rsi
	pop	rbp
	ret	0
?RenderArrowDockMenu@ImGui@@YAXPEAUImDrawList@@UImVec2@@MI@Z ENDP ; ImGui::RenderArrowDockMenu
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?RenderColorRectWithAlphaCheckerboard@ImGui@@YAXPEAUImDrawList@@UImVec2@@1IM1MH@Z
_TEXT	SEGMENT
y$1$ = 48
$T1 = 52
$T2 = 60
p_max$ = 72
p_min$ = 80
draw_list$ = 304
col$ = 328
grid_step$ = 336
grid_off$ = 344
rounding$ = 352
flags$ = 360
?RenderColorRectWithAlphaCheckerboard@ImGui@@YAXPEAUImDrawList@@UImVec2@@1IM1MH@Z PROC ; ImGui::RenderColorRectWithAlphaCheckerboard, COMDAT

; 3998 : {

$LN82:
	push	rbx
	push	rbp
	push	rdi
	sub	rsp, 272				; 00000110H

; 3999 :     if ((flags & ImDrawFlags_RoundCornersMask_) == 0)

	test	DWORD PTR flags$[rsp], 496		; 000001f0H

; 4000 :         flags = ImDrawFlags_RoundCornersDefault_;
; 4001 :     if (((col & IM_COL32_A_MASK) >> IM_COL32_A_SHIFT) < 0xFF)

	mov	edi, 240				; 000000f0H
	mov	eax, r9d
	mov	QWORD PTR p_max$[rsp], r8
	cmovne	edi, DWORD PTR flags$[rsp]
	mov	ebx, r9d
	and	eax, -16777216				; ff000000H
	mov	QWORD PTR p_min$[rsp], rdx
	mov	rbp, rcx
	cmp	eax, -16777216				; ff000000H
	jae	$LN9@RenderColo
	mov	QWORD PTR [rsp+264], rsi

; 4003 :         ImU32 col_bg1 = GetColorU32(ImAlphaBlendColors(IM_COL32(204, 204, 204, 255), col));

	mov	edx, ebx
	movaps	XMMWORD PTR [rsp+160], xmm11
	mov	ecx, -3355444				; ffccccccH
	movaps	XMMWORD PTR [rsp+128], xmm13
	movaps	XMMWORD PTR [rsp+96], xmm15
	call	?ImAlphaBlendColors@@YAIII@Z		; ImAlphaBlendColors
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3113 :     if (style.Alpha >= 1.0f)

	movss	xmm4, DWORD PTR __real@3f800000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 4003 :         ImU32 col_bg1 = GetColorU32(ImAlphaBlendColors(IM_COL32(204, 204, 204, 255), col));

	mov	r11d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3113 :     if (style.Alpha >= 1.0f)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movss	xmm3, DWORD PTR [rax+14552]
	comiss	xmm3, xmm4
	jae	SHORT $LN22@RenderColo

; 3114 :         return col;
; 3115 :     ImU32 a = (col & IM_COL32_A_MASK) >> IM_COL32_A_SHIFT;

	mov	eax, r11d
	xorps	xmm0, xmm0
	shr	eax, 24

; 3116 :     a = (ImU32)(a * style.Alpha); // We don't need to clamp 0..255 because Style.Alpha is in 0..1 range.

	cvtsi2ss xmm0, rax

; 3117 :     return (col & ~IM_COL32_A_MASK) | (a << IM_COL32_A_SHIFT);

	mov	eax, r11d
	and	eax, 16777215				; 00ffffffH
	mulss	xmm0, xmm3
	cvttss2si rcx, xmm0
	shl	ecx, 24
	mov	r11d, ecx
	or	r11d, eax
$LN22@RenderColo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 4004 :         ImU32 col_bg2 = GetColorU32(ImAlphaBlendColors(IM_COL32(128, 128, 128, 255), col));

	mov	edx, ebx
	mov	ecx, -8355712				; ff808080H
	call	?ImAlphaBlendColors@@YAIII@Z		; ImAlphaBlendColors
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3113 :     if (style.Alpha >= 1.0f)

	comiss	xmm3, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 4004 :         ImU32 col_bg2 = GetColorU32(ImAlphaBlendColors(IM_COL32(128, 128, 128, 255), col));

	mov	ebx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3113 :     if (style.Alpha >= 1.0f)

	jae	SHORT $LN25@RenderColo

; 3114 :         return col;
; 3115 :     ImU32 a = (col & IM_COL32_A_MASK) >> IM_COL32_A_SHIFT;

	shr	eax, 24
	xorps	xmm0, xmm0

; 3116 :     a = (ImU32)(a * style.Alpha); // We don't need to clamp 0..255 because Style.Alpha is in 0..1 range.

	cvtsi2ss xmm0, rax

; 3117 :     return (col & ~IM_COL32_A_MASK) | (a << IM_COL32_A_SHIFT);

	mov	eax, ebx
	and	eax, 16777215				; 00ffffffH
	mulss	xmm0, xmm3
	cvttss2si rcx, xmm0
	shl	ecx, 24
	mov	ebx, ecx
	or	ebx, eax
$LN25@RenderColo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 4005 :         draw_list->AddRectFilled(p_min, p_max, col_bg1, rounding, flags);

	movss	xmm0, DWORD PTR rounding$[rsp]
	lea	r8, QWORD PTR p_max$[rsp]
	mov	DWORD PTR [rsp+40], edi
	lea	rdx, QWORD PTR p_min$[rsp]
	mov	r9d, r11d
	movss	DWORD PTR [rsp+32], xmm0
	mov	rcx, rbp
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled

; 4006 : 
; 4007 :         int yi = 0;
; 4008 :         for (float y = p_min.y + grid_off.y; y < p_max.y; y += grid_step, yi++)

	movss	xmm11, DWORD PTR grid_off$[rsp+4]
	xor	esi, esi
	movss	xmm15, DWORD PTR p_min$[rsp+4]
	movss	xmm13, DWORD PTR p_max$[rsp+4]
	addss	xmm11, xmm15
	comiss	xmm13, xmm11
	jbe	$LN80@RenderColo
	mov	QWORD PTR [rsp+256], r14
	mov	r14d, 272				; 00000110H
	movaps	XMMWORD PTR [rsp+240], xmm6
	movaps	XMMWORD PTR [rsp+224], xmm7
	movss	xmm7, DWORD PTR p_max$[rsp]
	movaps	XMMWORD PTR [rsp+208], xmm8
	movss	xmm8, DWORD PTR p_min$[rsp]
	movaps	XMMWORD PTR [rsp+192], xmm9
	movaps	XMMWORD PTR [rsp+176], xmm10
	movaps	XMMWORD PTR [rsp+144], xmm12
	movaps	XMMWORD PTR [rsp+112], xmm14
	movss	xmm14, DWORD PTR grid_step$[rsp]
	npad	2
$LL4@RenderColo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm15, xmm11
	jbe	SHORT $LN32@RenderColo
	movaps	xmm9, xmm15
	jmp	SHORT $LN33@RenderColo
$LN32@RenderColo:
	movaps	xmm9, xmm13
	minss	xmm9, xmm11
$LN33@RenderColo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 4010 :             float y1 = ImClamp(y, p_min.y, p_max.y), y2 = ImMin(y + grid_step, p_max.y);

	addss	xmm11, xmm14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	movaps	xmm10, xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 4010 :             float y1 = ImClamp(y, p_min.y, p_max.y), y2 = ImMin(y + grid_step, p_max.y);

	movss	DWORD PTR y$1$[rsp], xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	minss	xmm10, xmm13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 4011 :             if (y2 <= y1)

	comiss	xmm9, xmm10
	jae	$LN2@RenderColo

; 4012 :                 continue;
; 4013 :             for (float x = p_min.x + grid_off.x + (yi & 1) * grid_step; x < p_max.x; x += grid_step * 2.0f)

	movss	xmm0, DWORD PTR grid_off$[rsp]
	mov	eax, esi
	and	eax, 1
	addss	xmm0, xmm8
	movd	xmm6, eax
	cvtdq2ps xmm6, xmm6
	mulss	xmm6, xmm14
	addss	xmm6, xmm0
	comiss	xmm7, xmm6
	jbe	$LN2@RenderColo
	movss	xmm11, DWORD PTR rounding$[rsp]
	movaps	xmm12, xmm14
	addss	xmm12, xmm14
$LL7@RenderColo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm8, xmm6
	jbe	SHORT $LN42@RenderColo
	movaps	xmm0, xmm8
	jmp	SHORT $LN43@RenderColo
$LN42@RenderColo:
	movaps	xmm0, xmm7
	minss	xmm0, xmm6
$LN43@RenderColo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 4015 :                 float x1 = ImClamp(x, p_min.x, p_max.x), x2 = ImMin(x + grid_step, p_max.x);

	movaps	xmm1, xmm6
	addss	xmm1, xmm14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	minss	xmm1, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 4016 :                 if (x2 <= x1)

	comiss	xmm0, xmm1
	jae	$LN5@RenderColo

; 4017 :                     continue;
; 4018 :                 ImDrawFlags cell_flags = ImDrawFlags_RoundCornersNone;
; 4019 :                 if (y1 <= p_min.y) { if (x1 <= p_min.x) cell_flags |= ImDrawFlags_RoundCornersTopLeft; if (x2 >= p_max.x) cell_flags |= ImDrawFlags_RoundCornersTopRight; }

	comiss	xmm15, xmm9
	mov	eax, 256				; 00000100H
	jb	SHORT $LN15@RenderColo
	comiss	xmm8, xmm0
	cmovae	eax, r14d
	comiss	xmm1, xmm7
	jb	SHORT $LN15@RenderColo
	or	eax, 32					; 00000020H
$LN15@RenderColo:

; 4020 :                 if (y2 >= p_max.y) { if (x1 <= p_min.x) cell_flags |= ImDrawFlags_RoundCornersBottomLeft; if (x2 >= p_max.x) cell_flags |= ImDrawFlags_RoundCornersBottomRight; }

	comiss	xmm10, xmm13
	jb	SHORT $LN18@RenderColo
	comiss	xmm8, xmm0
	jb	SHORT $LN17@RenderColo
	or	eax, 64					; 00000040H
$LN17@RenderColo:
	comiss	xmm1, xmm7
	jb	SHORT $LN18@RenderColo
	bts	eax, 7
$LN18@RenderColo:

; 4021 : 
; 4022 :                 // Combine flags
; 4023 :                 cell_flags = (flags == ImDrawFlags_RoundCornersNone || cell_flags == ImDrawFlags_RoundCornersNone) ? ImDrawFlags_RoundCornersNone : (cell_flags & flags);

	cmp	edi, 256				; 00000100H
	je	SHORT $LN20@RenderColo
	cmp	eax, 256				; 00000100H
	je	SHORT $LN20@RenderColo
	and	eax, edi
	jmp	SHORT $LN21@RenderColo
$LN20@RenderColo:
	mov	eax, 256				; 00000100H
$LN21@RenderColo:

; 4024 :                 draw_list->AddRectFilled(ImVec2(x1, y1), ImVec2(x2, y2), col_bg2, rounding, cell_flags);

	mov	DWORD PTR [rsp+40], eax
	lea	r8, QWORD PTR $T1[rsp]
	mov	r9d, ebx
	movss	DWORD PTR [rsp+32], xmm11
	lea	rdx, QWORD PTR $T2[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T1[rsp], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 4024 :                 draw_list->AddRectFilled(ImVec2(x1, y1), ImVec2(x2, y2), col_bg2, rounding, cell_flags);

	mov	rcx, rbp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T1[rsp+4], xmm10
	movss	DWORD PTR $T2[rsp], xmm0
	movss	DWORD PTR $T2[rsp+4], xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 4024 :                 draw_list->AddRectFilled(ImVec2(x1, y1), ImVec2(x2, y2), col_bg2, rounding, cell_flags);

	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
$LN5@RenderColo:

; 4012 :                 continue;
; 4013 :             for (float x = p_min.x + grid_off.x + (yi & 1) * grid_step; x < p_max.x; x += grid_step * 2.0f)

	addss	xmm6, xmm12
	comiss	xmm7, xmm6
	ja	$LL7@RenderColo
	movss	xmm11, DWORD PTR y$1$[rsp]
$LN2@RenderColo:

; 4006 : 
; 4007 :         int yi = 0;
; 4008 :         for (float y = p_min.y + grid_off.y; y < p_max.y; y += grid_step, yi++)

	inc	esi
	comiss	xmm13, xmm11
	ja	$LL4@RenderColo

; 4025 :             }
; 4026 :         }
; 4027 :     }

	movaps	xmm14, XMMWORD PTR [rsp+112]
	movaps	xmm12, XMMWORD PTR [rsp+144]
	movaps	xmm10, XMMWORD PTR [rsp+176]
	movaps	xmm9, XMMWORD PTR [rsp+192]
	movaps	xmm8, XMMWORD PTR [rsp+208]
	movaps	xmm7, XMMWORD PTR [rsp+224]
	movaps	xmm6, XMMWORD PTR [rsp+240]
	mov	r14, QWORD PTR [rsp+256]
$LN80@RenderColo:
	movaps	xmm13, XMMWORD PTR [rsp+128]
	movaps	xmm11, XMMWORD PTR [rsp+160]
	mov	rsi, QWORD PTR [rsp+264]
	movaps	xmm15, XMMWORD PTR [rsp+96]

; 4031 :     }
; 4032 : }

	add	rsp, 272				; 00000110H
	pop	rdi
	pop	rbp
	pop	rbx
	ret	0
$LN9@RenderColo:

; 4028 :     else
; 4029 :     {
; 4030 :         draw_list->AddRectFilled(p_min, p_max, col, rounding, flags);

	movss	xmm0, DWORD PTR rounding$[rsp]
	lea	r8, QWORD PTR p_max$[rsp]
	mov	DWORD PTR [rsp+40], edi
	lea	rdx, QWORD PTR p_min$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled

; 4031 :     }
; 4032 : }

	add	rsp, 272				; 00000110H
	pop	rdi
	pop	rbp
	pop	rbx
	ret	0
?RenderColorRectWithAlphaCheckerboard@ImGui@@YAXPEAUImDrawList@@UImVec2@@1IM1MH@Z ENDP ; ImGui::RenderColorRectWithAlphaCheckerboard
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?stb_decompress_length@@YAIPEBE@Z
_TEXT	SEGMENT
input$ = 8
?stb_decompress_length@@YAIPEBE@Z PROC			; stb_decompress_length, COMDAT

; 4045 :     return (input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11];

	movzx	edx, BYTE PTR [rcx+9]
	movzx	eax, BYTE PTR [rcx+8]
	shl	eax, 8
	add	eax, edx
	movzx	edx, BYTE PTR [rcx+10]
	movzx	ecx, BYTE PTR [rcx+11]
	shl	eax, 8
	add	eax, edx
	shl	eax, 8
	add	eax, ecx

; 4046 : }

	ret	0
?stb_decompress_length@@YAIPEBE@Z ENDP			; stb_decompress_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?stb__match@@YAXPEBEI@Z
_TEXT	SEGMENT
data$ = 8
length$ = 16
?stb__match@@YAXPEBEI@Z PROC				; stb__match, COMDAT

; 4053 :     // INVERSE of memmove... write each byte before copying the next...
; 4054 :     IM_ASSERT(stb__dout + length <= stb__barrier_out_e);
; 4055 :     if (stb__dout + length > stb__barrier_out_e) { stb__dout += length; return; }

	mov	rax, QWORD PTR ?stb__dout@@3PEAEEA
	mov	r9, rcx
	mov	r8, QWORD PTR ?stb__barrier_out_e@@3PEAEEA
	mov	ecx, edx
	add	rcx, rax
	cmp	rcx, r8
	jbe	SHORT $LN4@stb__match
	mov	QWORD PTR ?stb__dout@@3PEAEEA, rcx

; 4058 : }

	ret	0
$LN4@stb__match:

; 4056 :     if (data < stb__barrier_out_b) { stb__dout = stb__barrier_out_e+1; return; }

	cmp	r9, QWORD PTR ?stb__barrier_out_b@@3PEAEEA
	jae	SHORT $LN7@stb__match
	lea	rax, QWORD PTR [r8+1]

; 4058 : }

	mov	QWORD PTR ?stb__dout@@3PEAEEA, rax
	ret	0
$LN7@stb__match:

; 4057 :     while (length--) *stb__dout++ = *data++;

	test	edx, edx
	je	SHORT $LN8@stb__match
	sub	r9, rax
	npad	1
$LL2@stb__match:
	movzx	ecx, BYTE PTR [r9+rax]
	mov	BYTE PTR [rax], cl
	inc	rax
	add	edx, -1					; ffffffffH
	jne	SHORT $LL2@stb__match

; 4058 : }

	mov	QWORD PTR ?stb__dout@@3PEAEEA, rax
$LN8@stb__match:
	ret	0
?stb__match@@YAXPEBEI@Z ENDP				; stb__match
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?stb__lit@@YAXPEBEI@Z
_TEXT	SEGMENT
data$ = 48
length$ = 56
?stb__lit@@YAXPEBEI@Z PROC				; stb__lit, COMDAT

; 4061 : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 4062 :     IM_ASSERT(stb__dout + length <= stb__barrier_out_e);
; 4063 :     if (stb__dout + length > stb__barrier_out_e) { stb__dout += length; return; }

	mov	r9, QWORD PTR ?stb__dout@@3PEAEEA
	mov	rax, QWORD PTR ?stb__barrier_out_e@@3PEAEEA
	mov	r8d, edx
	lea	rbx, QWORD PTR [r8+r9]
	cmp	rbx, rax
	ja	SHORT $LN7@stb__lit

; 4064 :     if (data < stb__barrier_in_b) { stb__dout = stb__barrier_out_e+1; return; }

	cmp	rcx, QWORD PTR ?stb__barrier_in_b@@3PEBEEB
	jae	SHORT $LN3@stb__lit
	inc	rax

; 4066 :     stb__dout += length;
; 4067 : }

	mov	QWORD PTR ?stb__dout@@3PEAEEA, rax
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN3@stb__lit:

; 4065 :     memcpy(stb__dout, data, length);

	mov	rdx, rcx
	mov	rcx, r9
	call	memcpy
$LN7@stb__lit:

; 4066 :     stb__dout += length;
; 4067 : }

	mov	QWORD PTR ?stb__dout@@3PEAEEA, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?stb__lit@@YAXPEBEI@Z ENDP				; stb__lit
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?stb_decompress_token@@YAPEBEPEBE@Z
_TEXT	SEGMENT
i$ = 48
?stb_decompress_token@@YAPEBEPEBE@Z PROC		; stb_decompress_token, COMDAT

; 4074 : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 4075 :     if (*i >= 0x20) { // use fewer if's for cases that expand small

	movzx	r8d, BYTE PTR [rcx]
	mov	rbx, rcx
	cmp	r8b, 32					; 00000020H
	jb	$LN2@stb_decomp

; 4076 :         if (*i >= 0x80)       stb__match(stb__dout-i[1]-1, i[0] - 0x80 + 1), i += 2;

	cmp	r8b, 128				; 00000080H
	jb	SHORT $LN4@stb_decomp
	movzx	eax, BYTE PTR [rcx+1]
	lea	edx, DWORD PTR [r8-127]
	mov	rcx, QWORD PTR ?stb__dout@@3PEAEEA
	sub	rcx, rax
	dec	rcx
	call	?stb__match@@YAXPEBEI@Z			; stb__match
	add	rbx, 2

; 4086 :     }
; 4087 :     return i;

	mov	rax, rbx

; 4088 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN4@stb_decomp:

; 4077 :         else if (*i >= 0x40)  stb__match(stb__dout-(stb__in2(0) - 0x4000 + 1), i[2]+1), i += 3;

	cmp	r8b, 64					; 00000040H
	jb	SHORT $LN6@stb_decomp
	movzx	edx, BYTE PTR [rcx+2]
	mov	rax, r8
	mov	rcx, QWORD PTR ?stb__dout@@3PEAEEA
	inc	edx
	shl	rax, 8
	sub	rcx, rax
	movzx	eax, BYTE PTR [rbx+1]
	sub	rcx, rax
	add	rcx, 16383				; 00003fffH
	call	?stb__match@@YAXPEBEI@Z			; stb__match
	add	rbx, 3

; 4086 :     }
; 4087 :     return i;

	mov	rax, rbx

; 4088 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN6@stb_decomp:

; 4078 :         else /* *i >= 0x20 */ stb__lit(i+1, i[0] - 0x20 + 1), i += 1 + (i[0] - 0x20 + 1);

	lea	edx, DWORD PTR [r8-31]
	inc	rcx
	call	?stb__lit@@YAXPEBEI@Z			; stb__lit
	movzx	eax, BYTE PTR [rbx]
	add	rbx, -30
	add	rbx, rax

; 4086 :     }
; 4087 :     return i;

	mov	rax, rbx

; 4088 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN2@stb_decomp:

; 4079 :     } else { // more ifs for cases that expand large, since overhead is amortized
; 4080 :         if (*i >= 0x18)       stb__match(stb__dout-(stb__in3(0) - 0x180000 + 1), i[3]+1), i += 4;

	cmp	r8b, 24
	jb	SHORT $LN8@stb_decomp
	movzx	eax, BYTE PTR [rcx+1]
	movzx	edx, BYTE PTR [rcx+3]
	mov	rcx, QWORD PTR ?stb__dout@@3PEAEEA
	inc	edx
	shl	r8, 8
	add	r8, rax
	movzx	eax, BYTE PTR [rbx+2]
	shl	r8, 8
	sub	rcx, r8
	sub	rcx, rax
	add	rcx, 1572863				; 0017ffffH
	call	?stb__match@@YAXPEBEI@Z			; stb__match
	add	rbx, 4

; 4086 :     }
; 4087 :     return i;

	mov	rax, rbx

; 4088 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN8@stb_decomp:

; 4081 :         else if (*i >= 0x10)  stb__match(stb__dout-(stb__in3(0) - 0x100000 + 1), stb__in2(3)+1), i += 5;

	cmp	r8b, 16
	jb	SHORT $LN10@stb_decomp
	movzx	ecx, BYTE PTR [rcx+3]
	movzx	eax, BYTE PTR [rbx+1]
	movzx	edx, BYTE PTR [rbx+4]
	shl	ecx, 8
	inc	ecx
	shl	r8, 8
	add	edx, ecx
	add	r8, rax
	mov	rcx, QWORD PTR ?stb__dout@@3PEAEEA
	movzx	eax, BYTE PTR [rbx+2]
	shl	r8, 8
	sub	rcx, r8
	sub	rcx, rax
	add	rcx, 1048575				; 000fffffH
	call	?stb__match@@YAXPEBEI@Z			; stb__match
	add	rbx, 5

; 4086 :     }
; 4087 :     return i;

	mov	rax, rbx

; 4088 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN10@stb_decomp:

; 4082 :         else if (*i >= 0x08)  stb__lit(i+2, stb__in2(0) - 0x0800 + 1), i += 2 + (stb__in2(0) - 0x0800 + 1);

	cmp	r8b, 8
	jb	SHORT $LN12@stb_decomp
	movzx	edx, BYTE PTR [rbx+1]
	mov	ecx, r8d
	shl	ecx, 8
	add	edx, -2047				; fffff801H
	add	edx, ecx
	lea	rcx, QWORD PTR [rbx+2]
	call	?stb__lit@@YAXPEBEI@Z			; stb__lit
	movzx	ecx, BYTE PTR [rbx]
	movzx	eax, BYTE PTR [rbx+1]
	add	rax, rbx
	shl	rcx, 8
	lea	rbx, QWORD PTR [rcx-2045]
	add	rbx, rax

; 4086 :     }
; 4087 :     return i;

	mov	rax, rbx

; 4088 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN12@stb_decomp:

; 4083 :         else if (*i == 0x07)  stb__lit(i+3, stb__in2(1) + 1), i += 3 + (stb__in2(1) + 1);

	cmp	r8b, 7
	jne	SHORT $LN14@stb_decomp
	movzx	ecx, BYTE PTR [rcx+1]
	movzx	edx, BYTE PTR [rbx+2]
	shl	ecx, 8
	inc	ecx
	add	edx, ecx
	lea	rcx, QWORD PTR [rbx+3]
	call	?stb__lit@@YAXPEBEI@Z			; stb__lit
	movzx	ecx, BYTE PTR [rbx+1]
	movzx	eax, BYTE PTR [rbx+2]
	add	rax, rbx
	shl	rcx, 8
	lea	rbx, QWORD PTR [rcx+4]
	add	rbx, rax

; 4086 :     }
; 4087 :     return i;

	mov	rax, rbx

; 4088 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN14@stb_decomp:

; 4084 :         else if (*i == 0x06)  stb__match(stb__dout-(stb__in3(1)+1), i[4]+1), i += 5;

	cmp	r8b, 6
	jne	SHORT $LN16@stb_decomp
	movzx	eax, BYTE PTR [rcx+2]
	movzx	r8d, BYTE PTR [rcx+1]
	movzx	edx, BYTE PTR [rcx+4]
	mov	rcx, QWORD PTR ?stb__dout@@3PEAEEA
	inc	edx
	shl	r8, 8
	add	r8, rax
	movzx	eax, BYTE PTR [rbx+3]
	shl	r8, 8
	sub	rcx, r8
	sub	rcx, rax
	dec	rcx
	call	?stb__match@@YAXPEBEI@Z			; stb__match
	add	rbx, 5

; 4086 :     }
; 4087 :     return i;

	mov	rax, rbx

; 4088 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN16@stb_decomp:

; 4085 :         else if (*i == 0x04)  stb__match(stb__dout-(stb__in3(1)+1), stb__in2(4)+1), i += 6;

	cmp	r8b, 4
	jne	SHORT $LN18@stb_decomp
	movzx	ecx, BYTE PTR [rcx+4]
	movzx	eax, BYTE PTR [rbx+2]
	movzx	r8d, BYTE PTR [rbx+1]
	movzx	edx, BYTE PTR [rbx+5]
	shl	ecx, 8
	inc	ecx
	shl	r8, 8
	add	edx, ecx
	add	r8, rax
	mov	rcx, QWORD PTR ?stb__dout@@3PEAEEA
	movzx	eax, BYTE PTR [rbx+3]
	shl	r8, 8
	sub	rcx, r8
	sub	rcx, rax
	dec	rcx
	call	?stb__match@@YAXPEBEI@Z			; stb__match
	add	rbx, 6
$LN18@stb_decomp:

; 4086 :     }
; 4087 :     return i;

	mov	rax, rbx

; 4088 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?stb_decompress_token@@YAPEBEPEBE@Z ENDP		; stb_decompress_token
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?stb_adler32@@YAIIPEAEI@Z
_TEXT	SEGMENT
adler32$dead$ = 16
buffer$ = 24
buflen$ = 32
?stb_adler32@@YAIIPEAEI@Z PROC				; stb_adler32, COMDAT

; 4091 : {

	mov	QWORD PTR [rsp+32], rbx
	push	rsi
	mov	r10, rdx

; 4092 :     const unsigned long ADLER_MOD = 65521;
; 4093 :     unsigned long s1 = adler32 & 0xffff, s2 = adler32 >> 16;
; 4094 :     unsigned long blocklen = buflen % 5552;

	mov	eax, 1584310703				; 5e6ea9afH
	mul	r8d
	mov	ebx, r8d
	xor	r9d, r9d
	shr	edx, 11
	mov	esi, r8d
	imul	eax, edx, 5552				; 000015b0H
	mov	ecx, 1
	sub	ebx, eax

; 4095 : 
; 4096 :     unsigned long i;
; 4097 :     while (buflen) {

	test	r8d, r8d
	je	$LN3@stb_adler3
	mov	QWORD PTR [rsp+32], rdi
$LL2@stb_adler3:

; 4098 :         for (i=0; i + 7 < blocklen; i += 8) {

	xor	edx, edx
	cmp	ebx, 7
	jbe	SHORT $LN5@stb_adler3
	lea	r8d, QWORD PTR [rdx+7]
$LL6@stb_adler3:

; 4099 :             s1 += buffer[0], s2 += s1;

	movzx	eax, BYTE PTR [r10]
	add	edx, 8
	add	ecx, eax
	add	r8d, 8

; 4100 :             s1 += buffer[1], s2 += s1;

	movzx	eax, BYTE PTR [r10+1]
	add	r9d, ecx
	add	ecx, eax

; 4101 :             s1 += buffer[2], s2 += s1;

	movzx	eax, BYTE PTR [r10+2]
	add	r9d, ecx
	add	ecx, eax

; 4102 :             s1 += buffer[3], s2 += s1;

	movzx	eax, BYTE PTR [r10+3]
	add	r9d, ecx
	add	ecx, eax

; 4103 :             s1 += buffer[4], s2 += s1;

	movzx	eax, BYTE PTR [r10+4]
	add	r9d, ecx
	add	ecx, eax

; 4104 :             s1 += buffer[5], s2 += s1;

	movzx	eax, BYTE PTR [r10+5]
	add	r9d, ecx
	add	ecx, eax

; 4105 :             s1 += buffer[6], s2 += s1;

	movzx	eax, BYTE PTR [r10+6]
	add	r9d, ecx
	add	ecx, eax

; 4106 :             s1 += buffer[7], s2 += s1;

	movzx	eax, BYTE PTR [r10+7]
	add	r9d, ecx
	add	ecx, eax

; 4107 : 
; 4108 :             buffer += 8;

	add	r10, 8
	add	r9d, ecx
	cmp	r8d, ebx
	jb	SHORT $LL6@stb_adler3
$LN5@stb_adler3:
	xor	r8d, r8d
	xor	r11d, r11d

; 4109 :         }
; 4110 : 
; 4111 :         for (; i < blocklen; ++i)

	cmp	edx, ebx
	jae	SHORT $LN22@stb_adler3
	mov	eax, ebx
	sub	eax, edx
	cmp	eax, 2
	jb	SHORT $LN29@stb_adler3
	mov	eax, ebx
	sub	eax, edx
	sub	eax, 2
	shr	eax, 1
	inc	eax
	mov	edi, eax
	lea	edx, DWORD PTR [rdx+rax*2]
	npad	11
$LL25@stb_adler3:

; 4112 :             s1 += *buffer++, s2 += s1;

	movzx	eax, BYTE PTR [r10]
	add	ecx, eax
	movzx	eax, BYTE PTR [r10+1]
	add	r8d, ecx
	add	r10, 2
	add	ecx, eax
	add	r11d, ecx
	sub	rdi, 1
	jne	SHORT $LL25@stb_adler3

; 4109 :         }
; 4110 : 
; 4111 :         for (; i < blocklen; ++i)

	cmp	edx, ebx
	jae	SHORT $LN24@stb_adler3
$LN29@stb_adler3:

; 4112 :             s1 += *buffer++, s2 += s1;

	movzx	eax, BYTE PTR [r10]
	add	ecx, eax
	add	r9d, ecx
	inc	r10
$LN24@stb_adler3:
	lea	eax, DWORD PTR [r11+r8]
	add	r9d, eax
$LN22@stb_adler3:

; 4113 : 
; 4114 :         s1 %= ADLER_MOD, s2 %= ADLER_MOD;

	mov	eax, -2146992015			; 80078071H
	mul	ecx
	shr	edx, 15
	imul	eax, edx, -65521			; ffff000fH
	add	ecx, eax
	mov	eax, -2146992015			; 80078071H
	mul	r9d
	shr	edx, 15
	imul	edx, edx, -65521			; ffff000fH
	add	r9d, edx

; 4115 :         buflen -= blocklen;

	sub	esi, ebx

; 4116 :         blocklen = 5552;

	mov	ebx, 5552				; 000015b0H
	jne	$LL2@stb_adler3

; 4095 : 
; 4096 :     unsigned long i;
; 4097 :     while (buflen) {

	mov	rdi, QWORD PTR [rsp+32]
$LN3@stb_adler3:

; 4117 :     }
; 4118 :     return (unsigned int)(s2 << 16) + (unsigned int)s1;
; 4119 : }

	mov	rbx, QWORD PTR [rsp+40]
	shl	r9d, 16
	lea	eax, DWORD PTR [rcx+r9]
	pop	rsi
	ret	0
?stb_adler32@@YAIIPEAEI@Z ENDP				; stb_adler32
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?stb_decompress@@YAIPEAEPEBEI@Z
_TEXT	SEGMENT
output$ = 48
i$ = 56
__formal$dead$ = 64
?stb_decompress@@YAIPEAEPEBEI@Z PROC			; stb_decompress, COMDAT

; 4122 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 4123 :     if (stb__in4(0) != 0x57bC0000) return 0;

	movzx	eax, BYTE PTR [rdx+1]
	mov	rdi, rdx
	movzx	r8d, BYTE PTR [rdx]
	mov	r14, rcx
	shl	r8d, 8
	add	r8d, eax
	movzx	eax, BYTE PTR [rdx+2]
	shl	r8d, 8
	add	r8d, eax
	movzx	eax, BYTE PTR [rdx+3]
	shl	r8d, 8
	add	r8d, eax
	cmp	r8d, 1471938560				; 57bc0000H
	jne	$LN19@stb_decomp

; 4124 :     if (stb__in4(4) != 0)          return 0; // error! stream is > 4GB

	movzx	eax, BYTE PTR [rdx+5]
	movzx	ecx, BYTE PTR [rdx+4]
	shl	ecx, 8
	add	ecx, eax
	movzx	eax, BYTE PTR [rdx+6]
	shl	ecx, 8
	add	ecx, eax
	movzx	eax, BYTE PTR [rdx+7]
	shl	ecx, 8
	add	ecx, eax
	jne	$LN19@stb_decomp

; 4045 :     return (input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11];

	movzx	ebp, BYTE PTR [rdx+8]

; 4129 :     i += 16;

	add	rdi, 16

; 4045 :     return (input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11];

	movzx	eax, BYTE PTR [rdx+9]

; 4134 :         i = stb_decompress_token(i);

	mov	rcx, rdi

; 4045 :     return (input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11];

	shl	eax, 16
	shl	ebp, 24
	add	ebp, eax

; 4125 :     const unsigned int olen = stb_decompress_length(i);
; 4126 :     stb__barrier_in_b = i;

	mov	QWORD PTR ?stb__barrier_in_b@@3PEBEEB, rdx

; 4045 :     return (input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11];

	movzx	eax, BYTE PTR [rdx+10]
	shl	eax, 8
	add	ebp, eax

; 4127 :     stb__barrier_out_e = output + olen;
; 4128 :     stb__barrier_out_b = output;

	mov	QWORD PTR ?stb__barrier_out_b@@3PEAEEA, r14

; 4045 :     return (input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11];

	movzx	eax, BYTE PTR [rdx+11]
	add	ebp, eax

; 4130 : 
; 4131 :     stb__dout = output;

	mov	QWORD PTR ?stb__dout@@3PEAEEA, r14
	mov	esi, ebp
	add	rsi, r14
	mov	QWORD PTR ?stb__barrier_out_e@@3PEAEEA, rsi

; 4134 :         i = stb_decompress_token(i);

	call	?stb_decompress_token@@YAPEBEPEBE@Z	; stb_decompress_token
	mov	rbx, rax

; 4135 :         if (i == old_i) {

	cmp	rax, rdi
	je	SHORT $LN18@stb_decomp
	npad	5
$LL2@stb_decomp:

; 4142 :             } else {
; 4143 :                 IM_ASSERT(0); /* NOTREACHED */
; 4144 :                 return 0;
; 4145 :             }
; 4146 :         }
; 4147 :         IM_ASSERT(stb__dout <= output + olen);
; 4148 :         if (stb__dout > output + olen)

	cmp	QWORD PTR ?stb__dout@@3PEAEEA, rsi
	ja	SHORT $LN19@stb_decomp

; 4132 :     for (;;) {
; 4133 :         const unsigned char *old_i = i;

	mov	rcx, rbx
	mov	rdi, rbx

; 4134 :         i = stb_decompress_token(i);

	call	?stb_decompress_token@@YAPEBEPEBE@Z	; stb_decompress_token
	mov	rbx, rax

; 4135 :         if (i == old_i) {

	cmp	rax, rdi
	jne	SHORT $LL2@stb_decomp
$LN18@stb_decomp:

; 4136 :             if (*i == 0x05 && i[1] == 0xfa) {

	cmp	BYTE PTR [rbx], 5
	jne	SHORT $LN19@stb_decomp
	cmp	BYTE PTR [rbx+1], 250			; 000000faH
	jne	SHORT $LN19@stb_decomp

; 4137 :                 IM_ASSERT(stb__dout == output + olen);
; 4138 :                 if (stb__dout != output + olen) return 0;

	cmp	QWORD PTR ?stb__dout@@3PEAEEA, rsi
	jne	SHORT $LN19@stb_decomp

; 4139 :                 if (stb_adler32(1, output, olen) != (unsigned int) stb__in4(2))

	mov	r8d, ebp
	mov	rdx, r14
	call	?stb_adler32@@YAIIPEAEI@Z		; stb_adler32
	movzx	edx, BYTE PTR [rbx+2]
	movzx	ecx, BYTE PTR [rbx+3]
	shl	ecx, 16
	shl	edx, 24
	add	edx, ecx
	movzx	ecx, BYTE PTR [rbx+4]
	shl	ecx, 8
	add	edx, ecx
	movzx	ecx, BYTE PTR [rbx+5]
	add	edx, ecx
	cmp	eax, edx
	jne	SHORT $LN19@stb_decomp

; 4140 :                     return 0;
; 4141 :                 return olen;

	mov	eax, ebp
	jmp	SHORT $LN3@stb_decomp
$LN19@stb_decomp:

; 4149 :             return 0;

	xor	eax, eax
$LN3@stb_decomp:

; 4150 :     }
; 4151 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
?stb_decompress@@YAIPEAEPEBEI@Z ENDP			; stb_decompress
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
;	COMDAT ?GetDefaultCompressedFontDataTTFBase85@@YAPEBDXZ
_TEXT	SEGMENT
?GetDefaultCompressedFontDataTTFBase85@@YAPEBDXZ PROC	; GetDefaultCompressedFontDataTTFBase85, COMDAT

; 4255 :     return proggy_clean_ttf_compressed_data_base85;

	lea	rax, OFFSET FLAT:?proggy_clean_ttf_compressed_data_base85@@3QBDB

; 4256 : }

	ret	0
?GetDefaultCompressedFontDataTTFBase85@@YAPEBDXZ ENDP	; GetDefaultCompressedFontDataTTFBase85
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z PROC	; ImVector<stbtt_packedchar>::resize, COMDAT

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN38:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	edi, edx
	mov	ecx, DWORD PTR [rcx+4]
	cmp	edx, ecx
	jle	$LN27@resize
	mov	QWORD PTR [rsp+56], rsi

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN6@resize
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@resize
$LN6@resize:
	mov	eax, 8
$LN7@resize:
	cmp	eax, edi
	mov	esi, edi
	cmovg	esi, eax

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	cmp	esi, ecx
	jle	SHORT $LN28@resize
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rsp+48], rbp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN13@resize

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN13@resize:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	movsxd	rax, esi
	imul	rcx, rax, 28
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	rdx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	mov	rbp, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	test	rdx, rdx
	je	SHORT $LN23@resize
	movsxd	rcx, DWORD PTR [rbx]
	imul	r8, rcx, 28
	mov	rcx, rax
	call	memcpy
	mov	rcx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	test	rcx, rcx
	je	SHORT $LN21@resize

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN21@resize

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN21@resize:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
$LN23@resize:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rbx+8], rbp

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	rbp, QWORD PTR [rsp+48]

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	DWORD PTR [rbx+4], esi
	mov	rsi, QWORD PTR [rsp+56]

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [rbx], edi
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN28@resize:
	mov	rsi, QWORD PTR [rsp+56]
	mov	DWORD PTR [rbx], edi
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN27@resize:
	mov	DWORD PTR [rbx], edi
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?resize@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z ENDP	; ImVector<stbtt_packedchar>::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??A?$ImVector@Ustbtt_packedchar@@@@QEAAAEAUstbtt_packedchar@@H@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@Ustbtt_packedchar@@@@QEAAAEAUstbtt_packedchar@@H@Z PROC ; ImVector<stbtt_packedchar>::operator[], COMDAT

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rax, edx
	imul	rax, rax, 28
	add	rax, QWORD PTR [rcx+8]
	ret	0
??A?$ImVector@Ustbtt_packedchar@@@@QEAAAEAUstbtt_packedchar@@H@Z ENDP ; ImVector<stbtt_packedchar>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?size_in_bytes@?$ImVector@Ustbtt_packedchar@@@@QEBAHXZ
_TEXT	SEGMENT
this$ = 8
?size_in_bytes@?$ImVector@Ustbtt_packedchar@@@@QEBAHXZ PROC ; ImVector<stbtt_packedchar>::size_in_bytes, COMDAT

; 1914 :     inline int          size_in_bytes() const               { return Size * (int)sizeof(T); }

	imul	eax, DWORD PTR [rcx], 28
	ret	0
?size_in_bytes@?$ImVector@Ustbtt_packedchar@@@@QEBAHXZ ENDP ; ImVector<stbtt_packedchar>::size_in_bytes
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??1?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ PROC		; ImVector<stbtt_packedchar>::~ImVector<stbtt_packedchar>, COMDAT

; 1906 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

$LN14:
	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN8@ImVector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN6@ImVector

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN6@ImVector:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	rex_jmp	QWORD PTR __imp_free
$LN8@ImVector:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1906 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

	ret	0
??1?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ ENDP		; ImVector<stbtt_packedchar>::~ImVector<stbtt_packedchar>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??0?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ PROC		; ImVector<stbtt_packedchar>::ImVector<stbtt_packedchar>, COMDAT

; 1903 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	rax, rcx
	ret	0
??0?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ ENDP		; ImVector<stbtt_packedchar>::ImVector<stbtt_packedchar>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z PROC		; ImVector<stbrp_rect>::resize, COMDAT

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN38:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	edi, edx
	mov	ecx, DWORD PTR [rcx+4]
	cmp	edx, ecx
	jle	$LN27@resize
	mov	QWORD PTR [rsp+56], rsi

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN6@resize
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@resize
$LN6@resize:
	mov	eax, 8
$LN7@resize:
	cmp	eax, edi
	mov	esi, edi
	cmovg	esi, eax

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	cmp	esi, ecx
	jle	$LN28@resize
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rsp+48], rbp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN13@resize

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN13@resize:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	movsxd	rax, esi
	lea	rcx, QWORD PTR [rax+rax*2]
	shl	rcx, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	rdx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	mov	rbp, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	test	rdx, rdx
	je	SHORT $LN23@resize
	movsxd	rcx, DWORD PTR [rbx]
	lea	r8, QWORD PTR [rcx+rcx*2]
	mov	rcx, rax
	shl	r8, 3
	call	memcpy
	mov	rcx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	test	rcx, rcx
	je	SHORT $LN21@resize

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN21@resize

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN21@resize:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
$LN23@resize:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rbx+8], rbp

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	rbp, QWORD PTR [rsp+48]

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	DWORD PTR [rbx+4], esi
	mov	rsi, QWORD PTR [rsp+56]

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [rbx], edi
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN28@resize:
	mov	rsi, QWORD PTR [rsp+56]
	mov	DWORD PTR [rbx], edi
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN27@resize:
	mov	DWORD PTR [rbx], edi
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?resize@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z ENDP		; ImVector<stbrp_rect>::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??A?$ImVector@Ustbrp_rect@@@@QEAAAEAUstbrp_rect@@H@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@Ustbrp_rect@@@@QEAAAEAUstbrp_rect@@H@Z PROC ; ImVector<stbrp_rect>::operator[], COMDAT

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rax, edx
	lea	rdx, QWORD PTR [rax+rax*2]
	mov	rax, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rax+rdx*8]
	ret	0
??A?$ImVector@Ustbrp_rect@@@@QEAAAEAUstbrp_rect@@H@Z ENDP ; ImVector<stbrp_rect>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?size_in_bytes@?$ImVector@Ustbrp_rect@@@@QEBAHXZ
_TEXT	SEGMENT
this$ = 8
?size_in_bytes@?$ImVector@Ustbrp_rect@@@@QEBAHXZ PROC	; ImVector<stbrp_rect>::size_in_bytes, COMDAT

; 1914 :     inline int          size_in_bytes() const               { return Size * (int)sizeof(T); }

	mov	eax, DWORD PTR [rcx]
	lea	eax, DWORD PTR [rax+rax*2]
	shl	eax, 3
	ret	0
?size_in_bytes@?$ImVector@Ustbrp_rect@@@@QEBAHXZ ENDP	; ImVector<stbrp_rect>::size_in_bytes
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@Ustbrp_rect@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@Ustbrp_rect@@@@QEAAXXZ PROC		; ImVector<stbrp_rect>::clear, COMDAT

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

$LN15:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN2@clear
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN6@clear

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN6@clear:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx+8], 0
$LN2@clear:
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?clear@?$ImVector@Ustbrp_rect@@@@QEAAXXZ ENDP		; ImVector<stbrp_rect>::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??1?$ImVector@Ustbrp_rect@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$ImVector@Ustbrp_rect@@@@QEAA@XZ PROC		; ImVector<stbrp_rect>::~ImVector<stbrp_rect>, COMDAT

; 1906 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

$LN14:
	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN8@ImVector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN6@ImVector

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN6@ImVector:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	rex_jmp	QWORD PTR __imp_free
$LN8@ImVector:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1906 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

	ret	0
??1?$ImVector@Ustbrp_rect@@@@QEAA@XZ ENDP		; ImVector<stbrp_rect>::~ImVector<stbrp_rect>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??0?$ImVector@Ustbrp_rect@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@Ustbrp_rect@@@@QEAA@XZ PROC		; ImVector<stbrp_rect>::ImVector<stbrp_rect>, COMDAT

; 1903 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	rax, rcx
	ret	0
??0?$ImVector@Ustbrp_rect@@@@QEAA@XZ ENDP		; ImVector<stbrp_rect>::ImVector<stbrp_rect>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z PROC	; ImVector<ImFontBuildDstData>::resize, COMDAT

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN38:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	edi, edx
	mov	ecx, DWORD PTR [rcx+4]
	cmp	edx, ecx
	jle	$LN27@resize
	mov	QWORD PTR [rsp+56], rsi

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN6@resize
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@resize
$LN6@resize:
	mov	eax, 8
$LN7@resize:
	cmp	eax, edi
	mov	esi, edi
	cmovg	esi, eax

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	cmp	esi, ecx
	jle	SHORT $LN28@resize
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rsp+48], rbp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN13@resize

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN13@resize:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	movsxd	rcx, esi
	shl	rcx, 5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	rdx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	mov	rbp, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	test	rdx, rdx
	je	SHORT $LN23@resize
	movsxd	r8, DWORD PTR [rbx]
	mov	rcx, rax
	shl	r8, 5
	call	memcpy
	mov	rcx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	test	rcx, rcx
	je	SHORT $LN21@resize

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN21@resize

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN21@resize:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
$LN23@resize:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rbx+8], rbp

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	rbp, QWORD PTR [rsp+48]

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	DWORD PTR [rbx+4], esi
	mov	rsi, QWORD PTR [rsp+56]

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [rbx], edi
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN28@resize:
	mov	rsi, QWORD PTR [rsp+56]
	mov	DWORD PTR [rbx], edi
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN27@resize:
	mov	DWORD PTR [rbx], edi
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?resize@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z ENDP	; ImVector<ImFontBuildDstData>::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??A?$ImVector@UImFontBuildDstData@@@@QEAAAEAUImFontBuildDstData@@H@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@UImFontBuildDstData@@@@QEAAAEAUImFontBuildDstData@@H@Z PROC ; ImVector<ImFontBuildDstData>::operator[], COMDAT

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rax, edx
	shl	rax, 5
	add	rax, QWORD PTR [rcx+8]
	ret	0
??A?$ImVector@UImFontBuildDstData@@@@QEAAAEAUImFontBuildDstData@@H@Z ENDP ; ImVector<ImFontBuildDstData>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?size_in_bytes@?$ImVector@UImFontBuildDstData@@@@QEBAHXZ
_TEXT	SEGMENT
this$ = 8
?size_in_bytes@?$ImVector@UImFontBuildDstData@@@@QEBAHXZ PROC ; ImVector<ImFontBuildDstData>::size_in_bytes, COMDAT

; 1914 :     inline int          size_in_bytes() const               { return Size * (int)sizeof(T); }

	mov	eax, DWORD PTR [rcx]
	shl	eax, 5
	ret	0
?size_in_bytes@?$ImVector@UImFontBuildDstData@@@@QEBAHXZ ENDP ; ImVector<ImFontBuildDstData>::size_in_bytes
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImFontBuildDstData@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@UImFontBuildDstData@@@@QEAAXXZ PROC	; ImVector<ImFontBuildDstData>::clear, COMDAT

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

$LN15:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN2@clear
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN6@clear

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN6@clear:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx+8], 0
$LN2@clear:
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?clear@?$ImVector@UImFontBuildDstData@@@@QEAAXXZ ENDP	; ImVector<ImFontBuildDstData>::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??1?$ImVector@UImFontBuildDstData@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$ImVector@UImFontBuildDstData@@@@QEAA@XZ PROC	; ImVector<ImFontBuildDstData>::~ImVector<ImFontBuildDstData>, COMDAT

; 1906 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

$LN14:
	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN8@ImVector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN6@ImVector

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN6@ImVector:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	rex_jmp	QWORD PTR __imp_free
$LN8@ImVector:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1906 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

	ret	0
??1?$ImVector@UImFontBuildDstData@@@@QEAA@XZ ENDP	; ImVector<ImFontBuildDstData>::~ImVector<ImFontBuildDstData>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??0?$ImVector@UImFontBuildDstData@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@UImFontBuildDstData@@@@QEAA@XZ PROC	; ImVector<ImFontBuildDstData>::ImVector<ImFontBuildDstData>, COMDAT

; 1903 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	rax, rcx
	ret	0
??0?$ImVector@UImFontBuildDstData@@@@QEAA@XZ ENDP	; ImVector<ImFontBuildDstData>::ImVector<ImFontBuildDstData>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z PROC	; ImVector<ImFontBuildSrcData>::resize, COMDAT

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN38:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	edi, edx
	mov	ecx, DWORD PTR [rcx+4]
	cmp	edx, ecx
	jle	$LN27@resize
	mov	QWORD PTR [rsp+56], rsi

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN6@resize
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@resize
$LN6@resize:
	mov	eax, 8
$LN7@resize:
	cmp	eax, edi
	mov	esi, edi
	cmovg	esi, eax

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	cmp	esi, ecx
	jle	$LN28@resize
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rsp+48], rbp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN13@resize

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN13@resize:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	movsxd	rax, esi
	imul	rcx, rax, 272				; 00000110H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	rdx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	mov	rbp, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	test	rdx, rdx
	je	SHORT $LN23@resize
	movsxd	rcx, DWORD PTR [rbx]
	imul	r8, rcx, 272				; 00000110H
	mov	rcx, rax
	call	memcpy
	mov	rcx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	test	rcx, rcx
	je	SHORT $LN21@resize

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN21@resize

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN21@resize:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
$LN23@resize:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rbx+8], rbp

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	rbp, QWORD PTR [rsp+48]

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	DWORD PTR [rbx+4], esi
	mov	rsi, QWORD PTR [rsp+56]

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [rbx], edi
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN28@resize:
	mov	rsi, QWORD PTR [rsp+56]
	mov	DWORD PTR [rbx], edi
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN27@resize:
	mov	DWORD PTR [rbx], edi
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?resize@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z ENDP	; ImVector<ImFontBuildSrcData>::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??A?$ImVector@UImFontBuildSrcData@@@@QEAAAEAUImFontBuildSrcData@@H@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@UImFontBuildSrcData@@@@QEAAAEAUImFontBuildSrcData@@H@Z PROC ; ImVector<ImFontBuildSrcData>::operator[], COMDAT

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rax, edx
	imul	rax, rax, 272				; 00000110H
	add	rax, QWORD PTR [rcx+8]
	ret	0
??A?$ImVector@UImFontBuildSrcData@@@@QEAAAEAUImFontBuildSrcData@@H@Z ENDP ; ImVector<ImFontBuildSrcData>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?size_in_bytes@?$ImVector@UImFontBuildSrcData@@@@QEBAHXZ
_TEXT	SEGMENT
this$ = 8
?size_in_bytes@?$ImVector@UImFontBuildSrcData@@@@QEBAHXZ PROC ; ImVector<ImFontBuildSrcData>::size_in_bytes, COMDAT

; 1914 :     inline int          size_in_bytes() const               { return Size * (int)sizeof(T); }

	imul	eax, DWORD PTR [rcx], 272		; 00000110H
	ret	0
?size_in_bytes@?$ImVector@UImFontBuildSrcData@@@@QEBAHXZ ENDP ; ImVector<ImFontBuildSrcData>::size_in_bytes
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?clear_destruct@?$ImVector@UImFontBuildSrcData@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear_destruct@?$ImVector@UImFontBuildSrcData@@@@QEAAXXZ PROC ; ImVector<ImFontBuildSrcData>::clear_destruct, COMDAT

; 1910 :     inline void         clear_destruct()                    { for (int n = 0; n < Size; n++) Data[n].~T(); clear(); }           // Important: never called automatically! always explicit.

$LN57:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	mov	QWORD PTR [rsp+32], r14
	push	r15
	sub	rsp, 32					; 00000020H
	mov	r14, rcx
	xor	ebx, ebx
	cmp	DWORD PTR [rcx], ebx
	jle	SHORT $LN54@clear_dest
	xor	edi, edi
	npad	11
$LL4@clear_dest:
	mov	rsi, QWORD PTR [r14+8]

; 1906 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

	mov	rcx, QWORD PTR [rsi+rdi+264]
	test	rcx, rcx
	je	SHORT $LN20@clear_dest
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN18@clear_dest

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN18@clear_dest:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
	npad	1
$LN20@clear_dest:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1906 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

	mov	rcx, QWORD PTR [rsi+rdi+248]
	test	rcx, rcx
	je	SHORT $LN35@clear_dest
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN33@clear_dest

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN33@clear_dest:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
	npad	1
$LN35@clear_dest:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1910 :     inline void         clear_destruct()                    { for (int n = 0; n < Size; n++) Data[n].~T(); clear(); }           // Important: never called automatically! always explicit.

	inc	ebx
	add	rdi, 272				; 00000110H
	cmp	ebx, DWORD PTR [r14]
	jl	SHORT $LL4@clear_dest
$LN54@clear_dest:

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	rcx, QWORD PTR [r14+8]
	test	rcx, rcx
	je	SHORT $LN40@clear_dest
	mov	QWORD PTR [r14], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN44@clear_dest

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN44@clear_dest:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [r14+8], 0
$LN40@clear_dest:

; 1910 :     inline void         clear_destruct()                    { for (int n = 0; n < Size; n++) Data[n].~T(); clear(); }           // Important: never called automatically! always explicit.

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+64]
	mov	r14, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r15
	ret	0
?clear_destruct@?$ImVector@UImFontBuildSrcData@@@@QEAAXXZ ENDP ; ImVector<ImFontBuildSrcData>::clear_destruct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??1?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ PROC	; ImVector<ImFontBuildSrcData>::~ImVector<ImFontBuildSrcData>, COMDAT

; 1906 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

$LN14:
	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN8@ImVector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN6@ImVector

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN6@ImVector:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	rex_jmp	QWORD PTR __imp_free
$LN8@ImVector:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1906 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

	ret	0
??1?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ ENDP	; ImVector<ImFontBuildSrcData>::~ImVector<ImFontBuildSrcData>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??0?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ PROC	; ImVector<ImFontBuildSrcData>::ImVector<ImFontBuildSrcData>, COMDAT

; 1903 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	rax, rcx
	ret	0
??0?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ ENDP	; ImVector<ImFontBuildSrcData>::ImVector<ImFontBuildSrcData>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z PROC	; ImVector<ImFontGlyph>::resize, COMDAT

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN38:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	edi, edx
	mov	ecx, DWORD PTR [rcx+4]
	cmp	edx, ecx
	jle	$LN27@resize
	mov	QWORD PTR [rsp+56], rsi

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN6@resize
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@resize
$LN6@resize:
	mov	eax, 8
$LN7@resize:
	cmp	eax, edi
	mov	esi, edi
	cmovg	esi, eax

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	cmp	esi, ecx
	jle	$LN28@resize
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rsp+48], rbp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN13@resize

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN13@resize:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	movsxd	rax, esi
	lea	rcx, QWORD PTR [rax+rax*4]
	shl	rcx, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	rdx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	mov	rbp, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	test	rdx, rdx
	je	SHORT $LN23@resize
	movsxd	rcx, DWORD PTR [rbx]
	lea	r8, QWORD PTR [rcx+rcx*4]
	mov	rcx, rax
	shl	r8, 3
	call	memcpy
	mov	rcx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	test	rcx, rcx
	je	SHORT $LN21@resize

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN21@resize

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN21@resize:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
$LN23@resize:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rbx+8], rbp

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	rbp, QWORD PTR [rsp+48]

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	DWORD PTR [rbx+4], esi
	mov	rsi, QWORD PTR [rsp+56]

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [rbx], edi
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN28@resize:
	mov	rsi, QWORD PTR [rsp+56]
	mov	DWORD PTR [rbx], edi
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN27@resize:
	mov	DWORD PTR [rbx], edi
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z ENDP	; ImVector<ImFontGlyph>::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?back@?$ImVector@UImFontGlyph@@@@QEAAAEAUImFontGlyph@@XZ
_TEXT	SEGMENT
this$ = 8
?back@?$ImVector@UImFontGlyph@@@@QEAAAEAUImFontGlyph@@XZ PROC ; ImVector<ImFontGlyph>::back, COMDAT

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	mov	eax, DWORD PTR [rcx]
	dec	eax
	cdqe
	lea	rdx, QWORD PTR [rax+rax*4]
	mov	rax, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rax+rdx*8]
	ret	0
?back@?$ImVector@UImFontGlyph@@@@QEAAAEAUImFontGlyph@@XZ ENDP ; ImVector<ImFontGlyph>::back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??A?$ImVector@UImFontGlyph@@@@QEAAAEAUImFontGlyph@@H@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@UImFontGlyph@@@@QEAAAEAUImFontGlyph@@H@Z PROC ; ImVector<ImFontGlyph>::operator[], COMDAT

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rax, edx
	lea	rdx, QWORD PTR [rax+rax*4]
	mov	rax, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rax+rdx*8]
	ret	0
??A?$ImVector@UImFontGlyph@@@@QEAAAEAUImFontGlyph@@H@Z ENDP ; ImVector<ImFontGlyph>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImFontGlyph@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@UImFontGlyph@@@@QEAAXXZ PROC		; ImVector<ImFontGlyph>::clear, COMDAT

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

$LN15:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN2@clear
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN6@clear

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN6@clear:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx+8], 0
$LN2@clear:
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?clear@?$ImVector@UImFontGlyph@@@@QEAAXXZ ENDP		; ImVector<ImFontGlyph>::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??1?$ImVector@UImFontGlyph@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$ImVector@UImFontGlyph@@@@QEAA@XZ PROC		; ImVector<ImFontGlyph>::~ImVector<ImFontGlyph>, COMDAT

; 1906 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

$LN14:
	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN8@ImVector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN6@ImVector

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN6@ImVector:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	rex_jmp	QWORD PTR __imp_free
$LN8@ImVector:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1906 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

	ret	0
??1?$ImVector@UImFontGlyph@@@@QEAA@XZ ENDP		; ImVector<ImFontGlyph>::~ImVector<ImFontGlyph>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??0?$ImVector@UImFontGlyph@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@UImFontGlyph@@@@QEAA@XZ PROC		; ImVector<ImFontGlyph>::ImVector<ImFontGlyph>, COMDAT

; 1903 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	rax, rcx
	ret	0
??0?$ImVector@UImFontGlyph@@@@QEAA@XZ ENDP		; ImVector<ImFontGlyph>::ImVector<ImFontGlyph>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@M@@QEAAXHAEBM@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
v$ = 64
?resize@?$ImVector@M@@QEAAXHAEBM@Z PROC			; ImVector<float>::resize, COMDAT

; 1932 :     inline void         resize(int new_size, const T& v)    { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }

$LN24:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	movsxd	rdi, edx
	mov	rbx, rcx
	mov	ecx, DWORD PTR [rcx+4]
	mov	rsi, r8
	cmp	edi, ecx
	jle	SHORT $LN5@resize

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN10@resize
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN11@resize
$LN10@resize:
	mov	eax, 8
$LN11@resize:
	cmp	eax, edi
	mov	edx, edi

; 1932 :     inline void         resize(int new_size, const T& v)    { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }

	mov	rcx, rbx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	edx, eax

; 1932 :     inline void         resize(int new_size, const T& v)    { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }

	call	?reserve@?$ImVector@M@@QEAAXH@Z		; ImVector<float>::reserve
$LN5@resize:
	movsxd	rax, DWORD PTR [rbx]
	cmp	edi, eax
	jle	SHORT $LN16@resize
	mov	rdx, rax
	cmp	rax, rdi
	jge	SHORT $LN16@resize
$LL4@resize:
	mov	rcx, QWORD PTR [rbx+8]
	mov	eax, DWORD PTR [rsi]
	mov	DWORD PTR [rcx+rdx*4], eax
	inc	rdx
	cmp	rdx, rdi
	jl	SHORT $LL4@resize
$LN16@resize:
	mov	rsi, QWORD PTR [rsp+56]
	mov	DWORD PTR [rbx], edi
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?resize@?$ImVector@M@@QEAAXHAEBM@Z ENDP			; ImVector<float>::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UImFontConfig@@@@QEAAXAEBUImFontConfig@@@Z
_TEXT	SEGMENT
this$ = 48
v$ = 56
?push_back@?$ImVector@UImFontConfig@@@@QEAAXAEBUImFontConfig@@@Z PROC ; ImVector<ImFontConfig>::push_back, COMDAT

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

$LN35:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	edi, DWORD PTR [rcx]
	mov	rbx, rcx
	mov	ecx, DWORD PTR [rcx+4]
	mov	rsi, rdx
	cmp	edi, ecx
	jne	$LN8@push_back
	inc	edi

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN6@push_back
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@push_back
$LN6@push_back:
	mov	eax, 8
$LN7@push_back:
	cmp	eax, edi
	cmovg	edi, eax

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	cmp	edi, ecx
	jle	SHORT $LN8@push_back
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rsp+48], rbp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN13@push_back

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN13@push_back:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	movsxd	rax, edi
	imul	rcx, rax, 136				; 00000088H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	rdx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	mov	rbp, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	test	rdx, rdx
	je	SHORT $LN23@push_back
	movsxd	rcx, DWORD PTR [rbx]
	imul	r8, rcx, 136				; 00000088H
	mov	rcx, rax
	call	memcpy
	mov	rcx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	test	rcx, rcx
	je	SHORT $LN21@push_back

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN21@push_back

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN21@push_back:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
$LN23@push_back:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rbx+8], rbp
	mov	rbp, QWORD PTR [rsp+48]
	mov	DWORD PTR [rbx+4], edi
$LN8@push_back:

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	movsxd	rax, DWORD PTR [rbx]
	movaps	xmm0, XMMWORD PTR [rsi]
	movaps	xmm1, XMMWORD PTR [rsi+16]
	imul	rcx, rax, 136				; 00000088H
	mov	rax, QWORD PTR [rbx+8]
	movups	XMMWORD PTR [rcx+rax], xmm0
	movaps	xmm0, XMMWORD PTR [rsi+32]
	movups	XMMWORD PTR [rcx+rax+16], xmm1
	movaps	xmm1, XMMWORD PTR [rsi+48]
	movups	XMMWORD PTR [rcx+rax+32], xmm0
	movaps	xmm0, XMMWORD PTR [rsi+64]
	movups	XMMWORD PTR [rcx+rax+48], xmm1
	movaps	xmm1, XMMWORD PTR [rsi+80]
	movups	XMMWORD PTR [rcx+rax+64], xmm0
	movaps	xmm0, XMMWORD PTR [rsi+96]
	movups	XMMWORD PTR [rcx+rax+80], xmm1
	movaps	xmm1, XMMWORD PTR [rsi+112]
	movups	XMMWORD PTR [rcx+rax+96], xmm0
	movsd	xmm0, QWORD PTR [rsi+128]
	mov	rsi, QWORD PTR [rsp+64]
	movups	XMMWORD PTR [rcx+rax+112], xmm1
	movsd	QWORD PTR [rcx+rax+128], xmm0
	inc	DWORD PTR [rbx]
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?push_back@?$ImVector@UImFontConfig@@@@QEAAXAEBUImFontConfig@@@Z ENDP ; ImVector<ImFontConfig>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?back@?$ImVector@UImFontConfig@@@@QEAAAEAUImFontConfig@@XZ
_TEXT	SEGMENT
this$ = 8
?back@?$ImVector@UImFontConfig@@@@QEAAAEAUImFontConfig@@XZ PROC ; ImVector<ImFontConfig>::back, COMDAT

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	mov	eax, DWORD PTR [rcx]
	dec	eax
	cdqe
	imul	rax, rax, 136				; 00000088H
	add	rax, QWORD PTR [rcx+8]
	ret	0
?back@?$ImVector@UImFontConfig@@@@QEAAAEAUImFontConfig@@XZ ENDP ; ImVector<ImFontConfig>::back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??A?$ImVector@UImFontConfig@@@@QEAAAEAUImFontConfig@@H@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@UImFontConfig@@@@QEAAAEAUImFontConfig@@H@Z PROC ; ImVector<ImFontConfig>::operator[], COMDAT

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rax, edx
	imul	rax, rax, 136				; 00000088H
	add	rax, QWORD PTR [rcx+8]
	ret	0
??A?$ImVector@UImFontConfig@@@@QEAAAEAUImFontConfig@@H@Z ENDP ; ImVector<ImFontConfig>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImFontConfig@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@UImFontConfig@@@@QEAAXXZ PROC		; ImVector<ImFontConfig>::clear, COMDAT

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

$LN15:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN2@clear
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN6@clear

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN6@clear:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx+8], 0
$LN2@clear:
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?clear@?$ImVector@UImFontConfig@@@@QEAAXXZ ENDP		; ImVector<ImFontConfig>::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??1?$ImVector@UImFontConfig@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$ImVector@UImFontConfig@@@@QEAA@XZ PROC		; ImVector<ImFontConfig>::~ImVector<ImFontConfig>, COMDAT

; 1906 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

$LN14:
	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN8@ImVector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN6@ImVector

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN6@ImVector:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	rex_jmp	QWORD PTR __imp_free
$LN8@ImVector:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1906 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

	ret	0
??1?$ImVector@UImFontConfig@@@@QEAA@XZ ENDP		; ImVector<ImFontConfig>::~ImVector<ImFontConfig>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??0?$ImVector@UImFontConfig@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@UImFontConfig@@@@QEAA@XZ PROC		; ImVector<ImFontConfig>::ImVector<ImFontConfig>, COMDAT

; 1903 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	rax, rcx
	ret	0
??0?$ImVector@UImFontConfig@@@@QEAA@XZ ENDP		; ImVector<ImFontConfig>::ImVector<ImFontConfig>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXAEBUImFontAtlasCustomRect@@@Z
_TEXT	SEGMENT
this$ = 48
v$ = 56
?push_back@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXAEBUImFontAtlasCustomRect@@@Z PROC ; ImVector<ImFontAtlasCustomRect>::push_back, COMDAT

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

$LN35:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	edi, DWORD PTR [rcx]
	mov	rbx, rcx
	mov	ecx, DWORD PTR [rcx+4]
	mov	rbp, rdx
	cmp	edi, ecx
	jne	$LN8@push_back
	inc	edi

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN6@push_back
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@push_back
$LN6@push_back:
	mov	eax, 8
$LN7@push_back:
	cmp	eax, edi
	cmovg	edi, eax

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	cmp	edi, ecx
	jle	SHORT $LN8@push_back
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rsp+48], rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN13@push_back

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN13@push_back:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	movsxd	rcx, edi
	shl	rcx, 5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	rdx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	mov	rsi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	test	rdx, rdx
	je	SHORT $LN23@push_back
	movsxd	r8, DWORD PTR [rbx]
	mov	rcx, rax
	shl	r8, 5
	call	memcpy
	mov	rcx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	test	rcx, rcx
	je	SHORT $LN21@push_back

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN21@push_back

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN21@push_back:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
$LN23@push_back:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rbx+8], rsi
	mov	rsi, QWORD PTR [rsp+48]
	mov	DWORD PTR [rbx+4], edi
$LN8@push_back:

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	movsxd	rcx, DWORD PTR [rbx]
	movups	xmm0, XMMWORD PTR [rbp]
	mov	rax, QWORD PTR [rbx+8]
	shl	rcx, 5
	movups	XMMWORD PTR [rcx+rax], xmm0
	movups	xmm1, XMMWORD PTR [rbp+16]
	mov	rbp, QWORD PTR [rsp+64]
	movups	XMMWORD PTR [rcx+rax+16], xmm1
	inc	DWORD PTR [rbx]
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?push_back@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXAEBUImFontAtlasCustomRect@@@Z ENDP ; ImVector<ImFontAtlasCustomRect>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??A?$ImVector@UImFontAtlasCustomRect@@@@QEAAAEAUImFontAtlasCustomRect@@H@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@UImFontAtlasCustomRect@@@@QEAAAEAUImFontAtlasCustomRect@@H@Z PROC ; ImVector<ImFontAtlasCustomRect>::operator[], COMDAT

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rax, edx
	shl	rax, 5
	add	rax, QWORD PTR [rcx+8]
	ret	0
??A?$ImVector@UImFontAtlasCustomRect@@@@QEAAAEAUImFontAtlasCustomRect@@H@Z ENDP ; ImVector<ImFontAtlasCustomRect>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXXZ PROC ; ImVector<ImFontAtlasCustomRect>::clear, COMDAT

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

$LN15:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN2@clear
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN6@clear

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN6@clear:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx+8], 0
$LN2@clear:
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?clear@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXXZ ENDP ; ImVector<ImFontAtlasCustomRect>::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??1?$ImVector@UImFontAtlasCustomRect@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$ImVector@UImFontAtlasCustomRect@@@@QEAA@XZ PROC	; ImVector<ImFontAtlasCustomRect>::~ImVector<ImFontAtlasCustomRect>, COMDAT

; 1906 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

$LN14:
	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN8@ImVector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN6@ImVector

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN6@ImVector:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	rex_jmp	QWORD PTR __imp_free
$LN8@ImVector:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1906 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

	ret	0
??1?$ImVector@UImFontAtlasCustomRect@@@@QEAA@XZ ENDP	; ImVector<ImFontAtlasCustomRect>::~ImVector<ImFontAtlasCustomRect>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??0?$ImVector@UImFontAtlasCustomRect@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@UImFontAtlasCustomRect@@@@QEAA@XZ PROC	; ImVector<ImFontAtlasCustomRect>::ImVector<ImFontAtlasCustomRect>, COMDAT

; 1903 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	rax, rcx
	ret	0
??0?$ImVector@UImFontAtlasCustomRect@@@@QEAA@XZ ENDP	; ImVector<ImFontAtlasCustomRect>::ImVector<ImFontAtlasCustomRect>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?clear_delete@?$ImVector@PEAUImFont@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear_delete@?$ImVector@PEAUImFont@@@@QEAAXXZ PROC	; ImVector<ImFont *>::clear_delete, COMDAT

; 1909 :     inline void         clear_delete()                      { for (int n = 0; n < Size; n++) IM_DELETE(Data[n]); clear(); }     // Important: never called automatically! always explicit.

$LN43:
	mov	QWORD PTR [rsp+32], r14
	push	r15
	sub	rsp, 32					; 00000020H
	mov	QWORD PTR [rsp+48], rbx
	mov	r14, rcx
	xor	ebx, ebx
	cmp	DWORD PTR [rcx], ebx
	jle	SHORT $LN35@clear_dele
	mov	QWORD PTR [rsp+56], rsi
	xor	esi, esi
	mov	QWORD PTR [rsp+64], rdi
	npad	11
$LL4@clear_dele:
	mov	rax, QWORD PTR [r14+8]
	mov	rdi, QWORD PTR [rsi+rax]

; 1876 : template<typename T> void IM_DELETE(T* p)   { if (p) { p->~T(); ImGui::MemFree(p); } }

	test	rdi, rdi
	je	SHORT $LN2@clear_dele
	mov	rcx, rdi
	call	??1ImFont@@QEAA@XZ			; ImFont::~ImFont
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN14@clear_dele

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN14@clear_dele:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	mov	rcx, rdi
	call	QWORD PTR __imp_free
$LN2@clear_dele:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1909 :     inline void         clear_delete()                      { for (int n = 0; n < Size; n++) IM_DELETE(Data[n]); clear(); }     // Important: never called automatically! always explicit.

	inc	ebx
	add	rsi, 8
	cmp	ebx, DWORD PTR [r14]
	jl	SHORT $LL4@clear_dele
	mov	rdi, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+56]
$LN35@clear_dele:

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	rcx, QWORD PTR [r14+8]
	mov	rbx, QWORD PTR [rsp+48]
	test	rcx, rcx
	je	SHORT $LN21@clear_dele
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [r14], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN25@clear_dele

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN25@clear_dele:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [r14+8], 0
$LN21@clear_dele:

; 1909 :     inline void         clear_delete()                      { for (int n = 0; n < Size; n++) IM_DELETE(Data[n]); clear(); }     // Important: never called automatically! always explicit.

	mov	r14, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r15
	ret	0
?clear_delete@?$ImVector@PEAUImFont@@@@QEAAXXZ ENDP	; ImVector<ImFont *>::clear_delete
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?end@?$ImVector@I@@QEBAPEBIXZ
_TEXT	SEGMENT
this$ = 8
?end@?$ImVector@I@@QEBAPEBIXZ PROC			; ImVector<unsigned int>::end, COMDAT

; 1923 :     inline const T*     end() const                         { return Data + Size; }

	movsxd	rdx, DWORD PTR [rcx]
	mov	rax, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rax+rdx*4]
	ret	0
?end@?$ImVector@I@@QEBAPEBIXZ ENDP			; ImVector<unsigned int>::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?begin@?$ImVector@I@@QEBAPEBIXZ
_TEXT	SEGMENT
this$ = 8
?begin@?$ImVector@I@@QEBAPEBIXZ PROC			; ImVector<unsigned int>::begin, COMDAT

; 1921 :     inline const T*     begin() const                       { return Data; }

	mov	rax, QWORD PTR [rcx+8]
	ret	0
?begin@?$ImVector@I@@QEBAPEBIXZ ENDP			; ImVector<unsigned int>::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?empty@?$ImVector@I@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?empty@?$ImVector@I@@QEBA_NXZ PROC			; ImVector<unsigned int>::empty, COMDAT

; 1912 :     inline bool         empty() const                       { return Size == 0; }

	cmp	DWORD PTR [rcx], 0
	sete	al
	ret	0
?empty@?$ImVector@I@@QEBA_NXZ ENDP			; ImVector<unsigned int>::empty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@PEAUImDrawList@@@@QEAAXAEBQEAUImDrawList@@@Z
_TEXT	SEGMENT
this$ = 48
v$ = 56
?push_back@?$ImVector@PEAUImDrawList@@@@QEAAXAEBQEAUImDrawList@@@Z PROC ; ImVector<ImDrawList *>::push_back, COMDAT

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

$LN11:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	r8d, DWORD PTR [rcx]
	mov	rbx, rcx
	mov	ecx, DWORD PTR [rcx+4]
	mov	rdi, rdx
	cmp	r8d, ecx
	jne	SHORT $LN2@push_back
	inc	r8d

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN6@push_back
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@push_back
$LN6@push_back:
	mov	eax, 8
$LN7@push_back:
	cmp	eax, r8d

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rcx, rbx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	r8d, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, r8d
	call	?reserve@?$ImVector@PEAUImDrawList@@@@QEAAXH@Z ; ImVector<ImDrawList *>::reserve
$LN2@push_back:
	movsxd	rdx, DWORD PTR [rbx]
	mov	rcx, QWORD PTR [rbx+8]
	mov	rax, QWORD PTR [rdi]
	mov	QWORD PTR [rcx+rdx*8], rax
	inc	DWORD PTR [rbx]
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?push_back@?$ImVector@PEAUImDrawList@@@@QEAAXAEBQEAUImDrawList@@@Z ENDP ; ImVector<ImDrawList *>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?reserve_discard@?$ImVector@UImVec2@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_capacity$ = 56
?reserve_discard@?$ImVector@UImVec2@@@@QEAAXH@Z PROC	; ImVector<ImVec2>::reserve_discard, COMDAT

; 1935 :     inline void         reserve_discard(int new_capacity)   { if (new_capacity <= Capacity) return; if (Data) IM_FREE(Data); Data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); Capacity = new_capacity; }

$LN25:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	movsxd	rdi, edx
	mov	rbx, rcx
	cmp	edi, DWORD PTR [rcx+4]
	jle	SHORT $LN1@reserve_di
	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN9@reserve_di
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN7@reserve_di

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN7@reserve_di:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
$LN9@reserve_di:

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN14@reserve_di

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN14@reserve_di:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1935 :     inline void         reserve_discard(int new_capacity)   { if (new_capacity <= Capacity) return; if (Data) IM_FREE(Data); Data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); Capacity = new_capacity; }

	mov	rcx, rdi
	shl	rcx, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1935 :     inline void         reserve_discard(int new_capacity)   { if (new_capacity <= Capacity) return; if (Data) IM_FREE(Data); Data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); Capacity = new_capacity; }

	mov	QWORD PTR [rbx+8], rax
	mov	DWORD PTR [rbx+4], edi
$LN1@reserve_di:
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?reserve_discard@?$ImVector@UImVec2@@@@QEAAXH@Z ENDP	; ImVector<ImVec2>::reserve_discard
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?pop_back@?$ImVector@PEAX@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?pop_back@?$ImVector@PEAX@@QEAAXXZ PROC			; ImVector<void *>::pop_back, COMDAT

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [rcx]
	ret	0
?pop_back@?$ImVector@PEAX@@QEAAXXZ ENDP			; ImVector<void *>::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@PEAX@@QEAAXAEBQEAX@Z
_TEXT	SEGMENT
this$ = 48
v$ = 56
?push_back@?$ImVector@PEAX@@QEAAXAEBQEAX@Z PROC		; ImVector<void *>::push_back, COMDAT

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

$LN11:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	r8d, DWORD PTR [rcx]
	mov	rbx, rcx
	mov	ecx, DWORD PTR [rcx+4]
	mov	rdi, rdx
	cmp	r8d, ecx
	jne	SHORT $LN2@push_back
	inc	r8d

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN6@push_back
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@push_back
$LN6@push_back:
	mov	eax, 8
$LN7@push_back:
	cmp	eax, r8d

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rcx, rbx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	r8d, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, r8d
	call	?reserve@?$ImVector@PEAX@@QEAAXH@Z	; ImVector<void *>::reserve
$LN2@push_back:
	movsxd	rdx, DWORD PTR [rbx]
	mov	rcx, QWORD PTR [rbx+8]
	mov	rax, QWORD PTR [rdi]
	mov	QWORD PTR [rcx+rdx*8], rax
	inc	DWORD PTR [rbx]
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?push_back@?$ImVector@PEAX@@QEAAXAEBQEAX@Z ENDP		; ImVector<void *>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@PEAX@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$dead$ = 56
?resize@?$ImVector@PEAX@@QEAAXH@Z PROC			; ImVector<void *>::resize, COMDAT

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN11:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	ecx, DWORD PTR [rcx+4]
	test	ecx, ecx
	jns	SHORT $LN8@resize

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	eax, ecx
	cdq
	sub	eax, edx
	xor	edx, edx
	sar	eax, 1
	add	eax, ecx

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	rcx, rbx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	eax, eax
	cmovg	edx, eax

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	call	?reserve@?$ImVector@PEAX@@QEAAXH@Z	; ImVector<void *>::reserve
$LN8@resize:
	mov	DWORD PTR [rbx], 0
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?resize@?$ImVector@PEAX@@QEAAXH@Z ENDP			; ImVector<void *>::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@PEAX@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@PEAX@@QEAAXXZ PROC			; ImVector<void *>::clear, COMDAT

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

$LN15:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN2@clear
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN6@clear

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN6@clear:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx+8], 0
$LN2@clear:
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?clear@?$ImVector@PEAX@@QEAAXXZ ENDP			; ImVector<void *>::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?pop_back@?$ImVector@UImVec4@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?pop_back@?$ImVector@UImVec4@@@@QEAAXXZ PROC		; ImVector<ImVec4>::pop_back, COMDAT

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [rcx]
	ret	0
?pop_back@?$ImVector@UImVec4@@@@QEAAXXZ ENDP		; ImVector<ImVec4>::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UImVec4@@@@QEAAXAEBUImVec4@@@Z
_TEXT	SEGMENT
this$ = 48
v$ = 56
?push_back@?$ImVector@UImVec4@@@@QEAAXAEBUImVec4@@@Z PROC ; ImVector<ImVec4>::push_back, COMDAT

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

$LN11:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	r8d, DWORD PTR [rcx]
	mov	rbx, rcx
	mov	ecx, DWORD PTR [rcx+4]
	mov	rdi, rdx
	cmp	r8d, ecx
	jne	SHORT $LN2@push_back
	inc	r8d

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN6@push_back
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@push_back
$LN6@push_back:
	mov	eax, 8
$LN7@push_back:
	cmp	eax, r8d

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rcx, rbx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	r8d, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, r8d
	call	?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z	; ImVector<ImVec4>::reserve
$LN2@push_back:
	movsxd	rcx, DWORD PTR [rbx]
	mov	rax, QWORD PTR [rbx+8]
	add	rcx, rcx
	movups	xmm0, XMMWORD PTR [rdi]
	movups	XMMWORD PTR [rax+rcx*8], xmm0
	inc	DWORD PTR [rbx]
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?push_back@?$ImVector@UImVec4@@@@QEAAXAEBUImVec4@@@Z ENDP ; ImVector<ImVec4>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImVec4@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$dead$ = 56
?resize@?$ImVector@UImVec4@@@@QEAAXH@Z PROC		; ImVector<ImVec4>::resize, COMDAT

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN11:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	ecx, DWORD PTR [rcx+4]
	test	ecx, ecx
	jns	SHORT $LN8@resize

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	eax, ecx
	cdq
	sub	eax, edx
	xor	edx, edx
	sar	eax, 1
	add	eax, ecx

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	rcx, rbx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	eax, eax
	cmovg	edx, eax

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	call	?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z	; ImVector<ImVec4>::reserve
$LN8@resize:
	mov	DWORD PTR [rbx], 0
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?resize@?$ImVector@UImVec4@@@@QEAAXH@Z ENDP		; ImVector<ImVec4>::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImVec4@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@UImVec4@@@@QEAAXXZ PROC		; ImVector<ImVec4>::clear, COMDAT

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

$LN15:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN2@clear
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN6@clear

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN6@clear:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx+8], 0
$LN2@clear:
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?clear@?$ImVector@UImVec4@@@@QEAAXXZ ENDP		; ImVector<ImVec4>::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImDrawVert@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@UImDrawVert@@@@QEAAXH@Z PROC		; ImVector<ImDrawVert>::resize, COMDAT

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN12:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx
	mov	ebx, edx
	mov	ecx, DWORD PTR [rcx+4]
	cmp	edx, ecx
	jle	SHORT $LN8@resize

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN6@resize
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@resize
$LN6@resize:
	mov	eax, 8
$LN7@resize:
	cmp	eax, ebx
	mov	edx, ebx

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	rcx, rdi

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	edx, eax

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	call	?reserve@?$ImVector@UImDrawVert@@@@QEAAXH@Z ; ImVector<ImDrawVert>::reserve
$LN8@resize:
	mov	DWORD PTR [rdi], ebx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?resize@?$ImVector@UImDrawVert@@@@QEAAXH@Z ENDP		; ImVector<ImDrawVert>::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImDrawVert@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@UImDrawVert@@@@QEAAXXZ PROC		; ImVector<ImDrawVert>::clear, COMDAT

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

$LN15:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN2@clear
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN6@clear

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN6@clear:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx+8], 0
$LN2@clear:
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?clear@?$ImVector@UImDrawVert@@@@QEAAXXZ ENDP		; ImVector<ImDrawVert>::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImDrawChannel@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_capacity$ = 56
?reserve@?$ImVector@UImDrawChannel@@@@QEAAXH@Z PROC	; ImVector<ImDrawChannel>::reserve, COMDAT

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

$LN26:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	movsxd	rdi, edx
	mov	rbx, rcx
	cmp	edi, DWORD PTR [rcx+4]
	jle	SHORT $LN1@reserve
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rsp+48], rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN6@reserve

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN6@reserve:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	rcx, rdi
	shl	rcx, 5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	rdx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	mov	rsi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	test	rdx, rdx
	je	SHORT $LN16@reserve
	movsxd	r8, DWORD PTR [rbx]
	mov	rcx, rax
	shl	r8, 5
	call	memcpy
	mov	rcx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	test	rcx, rcx
	je	SHORT $LN14@reserve

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN14@reserve

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN14@reserve:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
$LN16@reserve:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rbx+8], rsi
	mov	rsi, QWORD PTR [rsp+48]
	mov	DWORD PTR [rbx+4], edi
$LN1@reserve:
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?reserve@?$ImVector@UImDrawChannel@@@@QEAAXH@Z ENDP	; ImVector<ImDrawChannel>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImDrawChannel@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@UImDrawChannel@@@@QEAAXH@Z PROC	; ImVector<ImDrawChannel>::resize, COMDAT

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN12:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx
	mov	ebx, edx
	mov	ecx, DWORD PTR [rcx+4]
	cmp	edx, ecx
	jle	SHORT $LN8@resize

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN6@resize
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@resize
$LN6@resize:
	mov	eax, 8
$LN7@resize:
	cmp	eax, ebx
	mov	edx, ebx

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	rcx, rdi

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	edx, eax

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	call	?reserve@?$ImVector@UImDrawChannel@@@@QEAAXH@Z ; ImVector<ImDrawChannel>::reserve
$LN8@resize:
	mov	DWORD PTR [rdi], ebx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?resize@?$ImVector@UImDrawChannel@@@@QEAAXH@Z ENDP	; ImVector<ImDrawChannel>::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??A?$ImVector@UImDrawChannel@@@@QEAAAEAUImDrawChannel@@H@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@UImDrawChannel@@@@QEAAAEAUImDrawChannel@@H@Z PROC ; ImVector<ImDrawChannel>::operator[], COMDAT

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rax, edx
	shl	rax, 5
	add	rax, QWORD PTR [rcx+8]
	ret	0
??A?$ImVector@UImDrawChannel@@@@QEAAAEAUImDrawChannel@@H@Z ENDP ; ImVector<ImDrawChannel>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?erase@?$ImVector@UImDrawCmd@@@@QEAAPEAUImDrawCmd@@PEBU2@@Z
_TEXT	SEGMENT
this$ = 48
it$ = 56
?erase@?$ImVector@UImDrawCmd@@@@QEAAPEAUImDrawCmd@@PEBU2@@Z PROC ; ImVector<ImDrawCmd>::erase, COMDAT

; 1941 :     inline T*           erase(const T* it)                  { IM_ASSERT(it >= Data && it < Data + Size); const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + 1, ((size_t)Size - (size_t)off - 1) * sizeof(T)); Size--; return Data + off; }

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	r8, QWORD PTR [rcx+8]
	mov	rdi, rcx
	sub	rdx, r8
	mov	rax, 5270498306774157605		; 4924924924924925H
	imul	rdx
	sar	rdx, 4
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
	movsxd	rax, DWORD PTR [rdi]
	imul	rbx, rdx, 56				; 00000038H
	sub	rax, rdx
	lea	rcx, QWORD PTR [rbx+r8]
	imul	r8, rax, 56				; 00000038H
	lea	rdx, QWORD PTR [rcx+56]
	sub	r8, 56					; 00000038H
	call	memmove
	mov	rax, QWORD PTR [rdi+8]
	dec	DWORD PTR [rdi]
	add	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?erase@?$ImVector@UImDrawCmd@@@@QEAAPEAUImDrawCmd@@PEBU2@@Z ENDP ; ImVector<ImDrawCmd>::erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImDrawCmd@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@UImDrawCmd@@@@QEAAXH@Z PROC		; ImVector<ImDrawCmd>::resize, COMDAT

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN12:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx
	mov	ebx, edx
	mov	ecx, DWORD PTR [rcx+4]
	cmp	edx, ecx
	jle	SHORT $LN8@resize

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN6@resize
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@resize
$LN6@resize:
	mov	eax, 8
$LN7@resize:
	cmp	eax, ebx
	mov	edx, ebx

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	rcx, rdi

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	edx, eax

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	call	?reserve@?$ImVector@UImDrawCmd@@@@QEAAXH@Z ; ImVector<ImDrawCmd>::reserve
$LN8@resize:
	mov	DWORD PTR [rdi], ebx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?resize@?$ImVector@UImDrawCmd@@@@QEAAXH@Z ENDP		; ImVector<ImDrawCmd>::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??A?$ImVector@UImDrawCmd@@@@QEAAAEAUImDrawCmd@@H@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@UImDrawCmd@@@@QEAAAEAUImDrawCmd@@H@Z PROC	; ImVector<ImDrawCmd>::operator[], COMDAT

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rax, edx
	imul	rax, rax, 56				; 00000038H
	add	rax, QWORD PTR [rcx+8]
	ret	0
??A?$ImVector@UImDrawCmd@@@@QEAAAEAUImDrawCmd@@H@Z ENDP	; ImVector<ImDrawCmd>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImDrawCmd@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@UImDrawCmd@@@@QEAAXXZ PROC		; ImVector<ImDrawCmd>::clear, COMDAT

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

$LN15:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN2@clear
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN6@clear

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN6@clear:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx+8], 0
$LN2@clear:
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?clear@?$ImVector@UImDrawCmd@@@@QEAAXXZ ENDP		; ImVector<ImDrawCmd>::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@G@@QEAAXHAEBG@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
v$ = 64
?resize@?$ImVector@G@@QEAAXHAEBG@Z PROC			; ImVector<unsigned short>::resize, COMDAT

; 1932 :     inline void         resize(int new_size, const T& v)    { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }

$LN24:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	movsxd	rdi, edx
	mov	rbx, rcx
	mov	ecx, DWORD PTR [rcx+4]
	mov	rsi, r8
	cmp	edi, ecx
	jle	SHORT $LN5@resize

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN10@resize
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN11@resize
$LN10@resize:
	mov	eax, 8
$LN11@resize:
	cmp	eax, edi
	mov	edx, edi

; 1932 :     inline void         resize(int new_size, const T& v)    { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }

	mov	rcx, rbx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	edx, eax

; 1932 :     inline void         resize(int new_size, const T& v)    { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }

	call	?reserve@?$ImVector@G@@QEAAXH@Z		; ImVector<unsigned short>::reserve
$LN5@resize:
	movsxd	rax, DWORD PTR [rbx]
	cmp	edi, eax
	jle	SHORT $LN16@resize
	mov	rdx, rax
	cmp	rax, rdi
	jge	SHORT $LN16@resize
$LL4@resize:
	mov	rcx, QWORD PTR [rbx+8]
	movzx	eax, WORD PTR [rsi]
	mov	WORD PTR [rcx+rdx*2], ax
	inc	rdx
	cmp	rdx, rdi
	jl	SHORT $LL4@resize
$LN16@resize:
	mov	rsi, QWORD PTR [rsp+56]
	mov	DWORD PTR [rbx], edi
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?resize@?$ImVector@G@@QEAAXHAEBG@Z ENDP			; ImVector<unsigned short>::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
;	COMDAT ??_GImFontBuildSrcData@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_GImFontBuildSrcData@@QEAAPEAXI@Z PROC		; ImFontBuildSrcData::`scalar deleting destructor', COMDAT
$LN37:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1906 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

	mov	rcx, QWORD PTR [rcx+264]
	test	rcx, rcx
	je	SHORT $LN15@scalar
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN13@scalar

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN13@scalar:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
	npad	1
$LN15@scalar:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1906 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

	mov	rcx, QWORD PTR [rbx+248]
	test	rcx, rcx
	je	SHORT $LN34@scalar
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN28@scalar

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN28@scalar:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
	npad	1
$LN34@scalar:
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_GImFontBuildSrcData@@QEAAPEAXI@Z ENDP		; ImFontBuildSrcData::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
;	COMDAT ??1ImFontBuildSrcData@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1ImFontBuildSrcData@@QEAA@XZ PROC			; ImFontBuildSrcData::~ImFontBuildSrcData, COMDAT
$LN33:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1906 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

	mov	rcx, QWORD PTR [rcx+264]
	test	rcx, rcx
	je	SHORT $LN11@ImFontBuil
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN9@ImFontBuil

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN9@ImFontBuil:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
	npad	1
$LN11@ImFontBuil:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1906 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

	mov	rcx, QWORD PTR [rbx+248]
	test	rcx, rcx
	je	SHORT $LN30@ImFontBuil
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN24@ImFontBuil

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN24@ImFontBuil:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
	npad	1
$LN30@ImFontBuil:
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1ImFontBuildSrcData@@QEAA@XZ ENDP			; ImFontBuildSrcData::~ImFontBuildSrcData
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
;	COMDAT ??1ImBitVector@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1ImBitVector@@QEAA@XZ PROC				; ImBitVector::~ImBitVector, COMDAT
$LN18:
	sub	rsp, 40					; 00000028H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1906 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN15@ImBitVecto
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN9@ImBitVecto

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN9@ImBitVecto:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
	npad	1
$LN15@ImBitVecto:
	add	rsp, 40					; 00000028H
	ret	0
??1ImBitVector@@QEAA@XZ ENDP				; ImBitVector::~ImBitVector
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_capacity$ = 56
?reserve@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z PROC	; ImVector<stbtt_packedchar>::reserve, COMDAT

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

$LN26:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	movsxd	rdi, edx
	mov	rbx, rcx
	cmp	edi, DWORD PTR [rcx+4]
	jle	SHORT $LN1@reserve
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rsp+48], rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN6@reserve

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN6@reserve:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	imul	rcx, rdi, 28
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	rdx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	mov	rsi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	test	rdx, rdx
	je	SHORT $LN16@reserve
	movsxd	rcx, DWORD PTR [rbx]
	imul	r8, rcx, 28
	mov	rcx, rax
	call	memcpy
	mov	rcx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	test	rcx, rcx
	je	SHORT $LN14@reserve

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN14@reserve

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN14@reserve:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
$LN16@reserve:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rbx+8], rsi
	mov	rsi, QWORD PTR [rsp+48]
	mov	DWORD PTR [rbx+4], edi
$LN1@reserve:
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?reserve@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z ENDP	; ImVector<stbtt_packedchar>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@Ustbtt_packedchar@@@@QEBAHH@Z
_TEXT	SEGMENT
this$ = 8
sz$ = 16
?_grow_capacity@?$ImVector@Ustbtt_packedchar@@@@QEBAHH@Z PROC ; ImVector<stbtt_packedchar>::_grow_capacity, COMDAT

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	r9d, DWORD PTR [rcx+4]
	mov	r8d, edx
	test	r9d, r9d
	je	SHORT $LN3@grow_capac
	mov	eax, r9d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r9d
	cmp	eax, r8d
	cmovg	r8d, eax
	mov	eax, r8d
	ret	0
$LN3@grow_capac:
	mov	eax, 8
	cmp	eax, r8d
	cmovg	r8d, eax
	mov	eax, r8d
	ret	0
?_grow_capacity@?$ImVector@Ustbtt_packedchar@@@@QEBAHH@Z ENDP ; ImVector<stbtt_packedchar>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_capacity$ = 56
?reserve@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z PROC	; ImVector<stbrp_rect>::reserve, COMDAT

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

$LN26:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	movsxd	rdi, edx
	mov	rbx, rcx
	cmp	edi, DWORD PTR [rcx+4]
	jle	SHORT $LN1@reserve
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rsp+48], rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN6@reserve

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN6@reserve:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	lea	rcx, QWORD PTR [rdi+rdi*2]
	shl	rcx, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	rdx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	mov	rsi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	test	rdx, rdx
	je	SHORT $LN16@reserve
	movsxd	rcx, DWORD PTR [rbx]
	lea	r8, QWORD PTR [rcx+rcx*2]
	mov	rcx, rax
	shl	r8, 3
	call	memcpy
	mov	rcx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	test	rcx, rcx
	je	SHORT $LN14@reserve

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN14@reserve

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN14@reserve:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
$LN16@reserve:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rbx+8], rsi
	mov	rsi, QWORD PTR [rsp+48]
	mov	DWORD PTR [rbx+4], edi
$LN1@reserve:
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?reserve@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z ENDP	; ImVector<stbrp_rect>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@Ustbrp_rect@@@@QEBAHH@Z
_TEXT	SEGMENT
this$ = 8
sz$ = 16
?_grow_capacity@?$ImVector@Ustbrp_rect@@@@QEBAHH@Z PROC	; ImVector<stbrp_rect>::_grow_capacity, COMDAT

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	r9d, DWORD PTR [rcx+4]
	mov	r8d, edx
	test	r9d, r9d
	je	SHORT $LN3@grow_capac
	mov	eax, r9d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r9d
	cmp	eax, r8d
	cmovg	r8d, eax
	mov	eax, r8d
	ret	0
$LN3@grow_capac:
	mov	eax, 8
	cmp	eax, r8d
	cmovg	r8d, eax
	mov	eax, r8d
	ret	0
?_grow_capacity@?$ImVector@Ustbrp_rect@@@@QEBAHH@Z ENDP	; ImVector<stbrp_rect>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_capacity$ = 56
?reserve@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z PROC ; ImVector<ImFontBuildDstData>::reserve, COMDAT

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

$LN26:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	movsxd	rdi, edx
	mov	rbx, rcx
	cmp	edi, DWORD PTR [rcx+4]
	jle	SHORT $LN1@reserve
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rsp+48], rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN6@reserve

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN6@reserve:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	rcx, rdi
	shl	rcx, 5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	rdx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	mov	rsi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	test	rdx, rdx
	je	SHORT $LN16@reserve
	movsxd	r8, DWORD PTR [rbx]
	mov	rcx, rax
	shl	r8, 5
	call	memcpy
	mov	rcx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	test	rcx, rcx
	je	SHORT $LN14@reserve

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN14@reserve

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN14@reserve:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
$LN16@reserve:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rbx+8], rsi
	mov	rsi, QWORD PTR [rsp+48]
	mov	DWORD PTR [rbx+4], edi
$LN1@reserve:
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?reserve@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z ENDP ; ImVector<ImFontBuildDstData>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImFontBuildDstData@@@@QEBAHH@Z
_TEXT	SEGMENT
this$ = 8
sz$ = 16
?_grow_capacity@?$ImVector@UImFontBuildDstData@@@@QEBAHH@Z PROC ; ImVector<ImFontBuildDstData>::_grow_capacity, COMDAT

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	r9d, DWORD PTR [rcx+4]
	mov	r8d, edx
	test	r9d, r9d
	je	SHORT $LN3@grow_capac
	mov	eax, r9d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r9d
	cmp	eax, r8d
	cmovg	r8d, eax
	mov	eax, r8d
	ret	0
$LN3@grow_capac:
	mov	eax, 8
	cmp	eax, r8d
	cmovg	r8d, eax
	mov	eax, r8d
	ret	0
?_grow_capacity@?$ImVector@UImFontBuildDstData@@@@QEBAHH@Z ENDP ; ImVector<ImFontBuildDstData>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_capacity$ = 56
?reserve@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z PROC ; ImVector<ImFontBuildSrcData>::reserve, COMDAT

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

$LN26:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	movsxd	rdi, edx
	mov	rbx, rcx
	cmp	edi, DWORD PTR [rcx+4]
	jle	SHORT $LN1@reserve
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rsp+48], rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN6@reserve

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN6@reserve:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	imul	rcx, rdi, 272				; 00000110H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	rdx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	mov	rsi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	test	rdx, rdx
	je	SHORT $LN16@reserve
	movsxd	rcx, DWORD PTR [rbx]
	imul	r8, rcx, 272				; 00000110H
	mov	rcx, rax
	call	memcpy
	mov	rcx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	test	rcx, rcx
	je	SHORT $LN14@reserve

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN14@reserve

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN14@reserve:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
$LN16@reserve:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rbx+8], rsi
	mov	rsi, QWORD PTR [rsp+48]
	mov	DWORD PTR [rbx+4], edi
$LN1@reserve:
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?reserve@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z ENDP ; ImVector<ImFontBuildSrcData>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImFontBuildSrcData@@@@QEBAHH@Z
_TEXT	SEGMENT
this$ = 8
sz$ = 16
?_grow_capacity@?$ImVector@UImFontBuildSrcData@@@@QEBAHH@Z PROC ; ImVector<ImFontBuildSrcData>::_grow_capacity, COMDAT

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	r9d, DWORD PTR [rcx+4]
	mov	r8d, edx
	test	r9d, r9d
	je	SHORT $LN3@grow_capac
	mov	eax, r9d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r9d
	cmp	eax, r8d
	cmovg	r8d, eax
	mov	eax, r8d
	ret	0
$LN3@grow_capac:
	mov	eax, 8
	cmp	eax, r8d
	cmovg	r8d, eax
	mov	eax, r8d
	ret	0
?_grow_capacity@?$ImVector@UImFontBuildSrcData@@@@QEBAHH@Z ENDP ; ImVector<ImFontBuildSrcData>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImFontBuildSrcData@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@UImFontBuildSrcData@@@@QEAAXXZ PROC	; ImVector<ImFontBuildSrcData>::clear, COMDAT

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

$LN15:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN2@clear
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN6@clear

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN6@clear:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx+8], 0
$LN2@clear:
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?clear@?$ImVector@UImFontBuildSrcData@@@@QEAAXXZ ENDP	; ImVector<ImFontBuildSrcData>::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImFontGlyph@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_capacity$ = 56
?reserve@?$ImVector@UImFontGlyph@@@@QEAAXH@Z PROC	; ImVector<ImFontGlyph>::reserve, COMDAT

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

$LN26:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	movsxd	rdi, edx
	mov	rbx, rcx
	cmp	edi, DWORD PTR [rcx+4]
	jle	SHORT $LN1@reserve
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rsp+48], rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN6@reserve

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN6@reserve:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	lea	rcx, QWORD PTR [rdi+rdi*4]
	shl	rcx, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	rdx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	mov	rsi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	test	rdx, rdx
	je	SHORT $LN16@reserve
	movsxd	rcx, DWORD PTR [rbx]
	lea	r8, QWORD PTR [rcx+rcx*4]
	mov	rcx, rax
	shl	r8, 3
	call	memcpy
	mov	rcx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	test	rcx, rcx
	je	SHORT $LN14@reserve

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN14@reserve

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN14@reserve:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
$LN16@reserve:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rbx+8], rsi
	mov	rsi, QWORD PTR [rsp+48]
	mov	DWORD PTR [rbx+4], edi
$LN1@reserve:
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?reserve@?$ImVector@UImFontGlyph@@@@QEAAXH@Z ENDP	; ImVector<ImFontGlyph>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImFontGlyph@@@@QEBAHH@Z
_TEXT	SEGMENT
this$ = 8
sz$ = 16
?_grow_capacity@?$ImVector@UImFontGlyph@@@@QEBAHH@Z PROC ; ImVector<ImFontGlyph>::_grow_capacity, COMDAT

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	r9d, DWORD PTR [rcx+4]
	mov	r8d, edx
	test	r9d, r9d
	je	SHORT $LN3@grow_capac
	mov	eax, r9d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r9d
	cmp	eax, r8d
	cmovg	r8d, eax
	mov	eax, r8d
	ret	0
$LN3@grow_capac:
	mov	eax, 8
	cmp	eax, r8d
	cmovg	r8d, eax
	mov	eax, r8d
	ret	0
?_grow_capacity@?$ImVector@UImFontGlyph@@@@QEBAHH@Z ENDP ; ImVector<ImFontGlyph>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImFontConfig@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_capacity$ = 56
?reserve@?$ImVector@UImFontConfig@@@@QEAAXH@Z PROC	; ImVector<ImFontConfig>::reserve, COMDAT

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

$LN26:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	movsxd	rdi, edx
	mov	rbx, rcx
	cmp	edi, DWORD PTR [rcx+4]
	jle	SHORT $LN1@reserve
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rsp+48], rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN6@reserve

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN6@reserve:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	imul	rcx, rdi, 136				; 00000088H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	rdx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	mov	rsi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	test	rdx, rdx
	je	SHORT $LN16@reserve
	movsxd	rcx, DWORD PTR [rbx]
	imul	r8, rcx, 136				; 00000088H
	mov	rcx, rax
	call	memcpy
	mov	rcx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	test	rcx, rcx
	je	SHORT $LN14@reserve

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN14@reserve

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN14@reserve:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
$LN16@reserve:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rbx+8], rsi
	mov	rsi, QWORD PTR [rsp+48]
	mov	DWORD PTR [rbx+4], edi
$LN1@reserve:
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?reserve@?$ImVector@UImFontConfig@@@@QEAAXH@Z ENDP	; ImVector<ImFontConfig>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImFontConfig@@@@QEBAHH@Z
_TEXT	SEGMENT
this$ = 8
sz$ = 16
?_grow_capacity@?$ImVector@UImFontConfig@@@@QEBAHH@Z PROC ; ImVector<ImFontConfig>::_grow_capacity, COMDAT

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	r9d, DWORD PTR [rcx+4]
	mov	r8d, edx
	test	r9d, r9d
	je	SHORT $LN3@grow_capac
	mov	eax, r9d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r9d
	cmp	eax, r8d
	cmovg	r8d, eax
	mov	eax, r8d
	ret	0
$LN3@grow_capac:
	mov	eax, 8
	cmp	eax, r8d
	cmovg	r8d, eax
	mov	eax, r8d
	ret	0
?_grow_capacity@?$ImVector@UImFontConfig@@@@QEBAHH@Z ENDP ; ImVector<ImFontConfig>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_capacity$ = 56
?reserve@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXH@Z PROC ; ImVector<ImFontAtlasCustomRect>::reserve, COMDAT

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

$LN26:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	movsxd	rdi, edx
	mov	rbx, rcx
	cmp	edi, DWORD PTR [rcx+4]
	jle	SHORT $LN1@reserve
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rsp+48], rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN6@reserve

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN6@reserve:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	rcx, rdi
	shl	rcx, 5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	rdx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	mov	rsi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	test	rdx, rdx
	je	SHORT $LN16@reserve
	movsxd	r8, DWORD PTR [rbx]
	mov	rcx, rax
	shl	r8, 5
	call	memcpy
	mov	rcx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	test	rcx, rcx
	je	SHORT $LN14@reserve

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN14@reserve

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN14@reserve:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
$LN16@reserve:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rbx+8], rsi
	mov	rsi, QWORD PTR [rsp+48]
	mov	DWORD PTR [rbx+4], edi
$LN1@reserve:
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?reserve@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXH@Z ENDP ; ImVector<ImFontAtlasCustomRect>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImFontAtlasCustomRect@@@@QEBAHH@Z
_TEXT	SEGMENT
this$ = 8
sz$ = 16
?_grow_capacity@?$ImVector@UImFontAtlasCustomRect@@@@QEBAHH@Z PROC ; ImVector<ImFontAtlasCustomRect>::_grow_capacity, COMDAT

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	r9d, DWORD PTR [rcx+4]
	mov	r8d, edx
	test	r9d, r9d
	je	SHORT $LN3@grow_capac
	mov	eax, r9d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r9d
	cmp	eax, r8d
	cmovg	r8d, eax
	mov	eax, r8d
	ret	0
$LN3@grow_capac:
	mov	eax, 8
	cmp	eax, r8d
	cmovg	r8d, eax
	mov	eax, r8d
	ret	0
?_grow_capacity@?$ImVector@UImFontAtlasCustomRect@@@@QEBAHH@Z ENDP ; ImVector<ImFontAtlasCustomRect>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@PEAX@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_capacity$ = 56
?reserve@?$ImVector@PEAX@@QEAAXH@Z PROC			; ImVector<void *>::reserve, COMDAT

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

$LN26:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	movsxd	rdi, edx
	mov	rbx, rcx
	cmp	edi, DWORD PTR [rcx+4]
	jle	SHORT $LN1@reserve
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rsp+48], rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN6@reserve

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN6@reserve:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	rcx, rdi
	shl	rcx, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	rdx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	mov	rsi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	test	rdx, rdx
	je	SHORT $LN16@reserve
	movsxd	r8, DWORD PTR [rbx]
	mov	rcx, rax
	shl	r8, 3
	call	memcpy
	mov	rcx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	test	rcx, rcx
	je	SHORT $LN14@reserve

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN14@reserve

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN14@reserve:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
$LN16@reserve:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rbx+8], rsi
	mov	rsi, QWORD PTR [rsp+48]
	mov	DWORD PTR [rbx+4], edi
$LN1@reserve:
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?reserve@?$ImVector@PEAX@@QEAAXH@Z ENDP			; ImVector<void *>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@PEAX@@QEBAHH@Z
_TEXT	SEGMENT
this$ = 8
sz$ = 16
?_grow_capacity@?$ImVector@PEAX@@QEBAHH@Z PROC		; ImVector<void *>::_grow_capacity, COMDAT

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	r9d, DWORD PTR [rcx+4]
	mov	r8d, edx
	test	r9d, r9d
	je	SHORT $LN3@grow_capac
	mov	eax, r9d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r9d
	cmp	eax, r8d
	cmovg	r8d, eax
	mov	eax, r8d
	ret	0
$LN3@grow_capac:
	mov	eax, 8
	cmp	eax, r8d
	cmovg	r8d, eax
	mov	eax, r8d
	ret	0
?_grow_capacity@?$ImVector@PEAX@@QEBAHH@Z ENDP		; ImVector<void *>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_capacity$ = 56
?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z PROC		; ImVector<ImVec4>::reserve, COMDAT

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

$LN26:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	movsxd	rdi, edx
	mov	rbx, rcx
	cmp	edi, DWORD PTR [rcx+4]
	jle	SHORT $LN1@reserve
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rsp+48], rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN6@reserve

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN6@reserve:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	rcx, rdi
	shl	rcx, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	rdx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	mov	rsi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	test	rdx, rdx
	je	SHORT $LN16@reserve
	movsxd	r8, DWORD PTR [rbx]
	mov	rcx, rax
	shl	r8, 4
	call	memcpy
	mov	rcx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	test	rcx, rcx
	je	SHORT $LN14@reserve

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN14@reserve

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN14@reserve:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
$LN16@reserve:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rbx+8], rsi
	mov	rsi, QWORD PTR [rsp+48]
	mov	DWORD PTR [rbx+4], edi
$LN1@reserve:
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z ENDP		; ImVector<ImVec4>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImVec4@@@@QEBAHH@Z
_TEXT	SEGMENT
this$ = 8
sz$ = 16
?_grow_capacity@?$ImVector@UImVec4@@@@QEBAHH@Z PROC	; ImVector<ImVec4>::_grow_capacity, COMDAT

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	r9d, DWORD PTR [rcx+4]
	mov	r8d, edx
	test	r9d, r9d
	je	SHORT $LN3@grow_capac
	mov	eax, r9d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r9d
	cmp	eax, r8d
	cmovg	r8d, eax
	mov	eax, r8d
	ret	0
$LN3@grow_capac:
	mov	eax, 8
	cmp	eax, r8d
	cmovg	r8d, eax
	mov	eax, r8d
	ret	0
?_grow_capacity@?$ImVector@UImVec4@@@@QEBAHH@Z ENDP	; ImVector<ImVec4>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImDrawVert@@@@QEBAHH@Z
_TEXT	SEGMENT
this$ = 8
sz$ = 16
?_grow_capacity@?$ImVector@UImDrawVert@@@@QEBAHH@Z PROC	; ImVector<ImDrawVert>::_grow_capacity, COMDAT

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	r9d, DWORD PTR [rcx+4]
	mov	r8d, edx
	test	r9d, r9d
	je	SHORT $LN3@grow_capac
	mov	eax, r9d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r9d
	cmp	eax, r8d
	cmovg	r8d, eax
	mov	eax, r8d
	ret	0
$LN3@grow_capac:
	mov	eax, 8
	cmp	eax, r8d
	cmovg	r8d, eax
	mov	eax, r8d
	ret	0
?_grow_capacity@?$ImVector@UImDrawVert@@@@QEBAHH@Z ENDP	; ImVector<ImDrawVert>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImDrawChannel@@@@QEBAHH@Z
_TEXT	SEGMENT
this$ = 8
sz$ = 16
?_grow_capacity@?$ImVector@UImDrawChannel@@@@QEBAHH@Z PROC ; ImVector<ImDrawChannel>::_grow_capacity, COMDAT

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	r9d, DWORD PTR [rcx+4]
	mov	r8d, edx
	test	r9d, r9d
	je	SHORT $LN3@grow_capac
	mov	eax, r9d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r9d
	cmp	eax, r8d
	cmovg	r8d, eax
	mov	eax, r8d
	ret	0
$LN3@grow_capac:
	mov	eax, 8
	cmp	eax, r8d
	cmovg	r8d, eax
	mov	eax, r8d
	ret	0
?_grow_capacity@?$ImVector@UImDrawChannel@@@@QEBAHH@Z ENDP ; ImVector<ImDrawChannel>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImMin@M@@YAMMM@Z
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
??$ImMin@M@@YAMMM@Z PROC				; ImMin<float>, COMDAT

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	minss	xmm0, xmm1
	ret	0
??$ImMin@M@@YAMMM@Z ENDP				; ImMin<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImMax@M@@YAMMM@Z
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
??$ImMax@M@@YAMMM@Z PROC				; ImMax<float>, COMDAT

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm0, xmm1
	ret	0
??$ImMax@M@@YAMMM@Z ENDP				; ImMax<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImClamp@H@@YAHHHH@Z
_TEXT	SEGMENT
v$ = 8
mn$ = 16
mx$ = 24
??$ImClamp@H@@YAHHHH@Z PROC				; ImClamp<int>, COMDAT

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	cmp	ecx, edx
	jge	SHORT $LN3@ImClamp
	mov	eax, edx
	ret	0
$LN3@ImClamp:
	cmp	ecx, r8d
	cmovg	ecx, r8d
	mov	eax, ecx
	ret	0
??$ImClamp@H@@YAHHHH@Z ENDP				; ImClamp<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImMax@H@@YAHHH@Z
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
??$ImMax@H@@YAHHH@Z PROC				; ImMax<int>, COMDAT

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	cmp	ecx, edx
	cmovge	edx, ecx
	mov	eax, edx
	ret	0
??$ImMax@H@@YAHHH@Z ENDP				; ImMax<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImClamp@M@@YAMMMM@Z
_TEXT	SEGMENT
v$ = 8
mn$ = 16
mx$ = 24
??$ImClamp@M@@YAMMMM@Z PROC				; ImClamp<float>, COMDAT

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm1, xmm0
	jbe	SHORT $LN5@ImClamp
	movaps	xmm0, xmm1
	ret	0
$LN5@ImClamp:
	minss	xmm2, xmm0
	movaps	xmm0, xmm2
	ret	0
??$ImClamp@M@@YAMMMM@Z ENDP				; ImClamp<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??$IM_DELETE@UImFont@@@@YAXPEAUImFont@@@Z
_TEXT	SEGMENT
p$ = 48
??$IM_DELETE@UImFont@@@@YAXPEAUImFont@@@Z PROC		; IM_DELETE<ImFont>, COMDAT

; 1876 : template<typename T> void IM_DELETE(T* p)   { if (p) { p->~T(); ImGui::MemFree(p); } }

$LN20:
	test	rcx, rcx
	je	SHORT $LN17@IM_DELETE
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	call	??1ImFont@@QEAA@XZ			; ImFont::~ImFont
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN9@IM_DELETE

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN9@IM_DELETE:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	mov	rcx, rbx
	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1876 : template<typename T> void IM_DELETE(T* p)   { if (p) { p->~T(); ImGui::MemFree(p); } }

	add	rsp, 32					; 00000020H
	pop	rbx
$LN17@IM_DELETE:
	ret	0
??$IM_DELETE@UImFont@@@@YAXPEAUImFont@@@Z ENDP		; IM_DELETE<ImFont>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_GImFont@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_GImFont@@QEAAPEAXI@Z PROC				; ImFont::`scalar deleting destructor', COMDAT
$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	call	??1ImFont@@QEAA@XZ			; ImFont::~ImFont
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_GImFont@@QEAAPEAXI@Z ENDP				; ImFont::`scalar deleting destructor'
_TEXT	ENDS
END
